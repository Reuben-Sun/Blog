<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Rust与WebAssembly画三角形</title>
      <link href="/program/Rust-WebAssembly/"/>
      <url>/program/Rust-WebAssembly/</url>
      
        <content type="html"><![CDATA[<h1>使用Rust与WASM画三角形</h1><h2 id="环境安装">环境安装</h2><blockquote><p>Windows 11 + Winget</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">winget install node.js</span><br><span class="line">winget install rustup   </span><br></pre></td></tr></table></figure><p>下载wasm-pack：[链接](<a href="https://rustwasm.github.io/wasm-pack/installer/">wasm-pack (rustwasm.github.io)</a>)</p><h3 id="第一个项目">第一个项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init rust-webpack</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p><img src="/images/rust_init.png" class="lazyload" data-srcset="/images/rust_init.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="rust_init"></p><p>此时会自动弹出一个网页，按F12可以发现，控制台输出了Hello World！</p><p><img src="/images/wasm_init.png" class="lazyload" data-srcset="/images/wasm_init.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="wasm_init"></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> WebAssembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20特性</title>
      <link href="/program/C++20/"/>
      <url>/program/C++20/</url>
      
        <content type="html"><![CDATA[<h1>C++20特性</h1><blockquote><p>现在是2023年，C++23都出来很久了（尽管很多编译器没有实现全功能），但还是有着大量C++11/17的老项目，出于人力和风险的考虑并没有上新标准，我作为一个C++菜鸡，也没想着去了解C++20都更新了什么，直到最近遇到了很多语言层面的问题，于是想着学习一下C++20特性</p><p>当然这里面不止C++20</p></blockquote><h2 id="语言特性">语言特性</h2><h3 id="指定初始化">指定初始化</h3><p>可以只初始化一部分，可以指定想要初始化的部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student s &#123; .name = <span class="string">&quot;Jack&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="Lambda">Lambda</h3><p><code>[=]</code>以前可以隐式获取<code>this</code>，现在需要改为<code>[=, this]</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++20以前</span></span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="keyword">auto</span>&amp;&amp; ...args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(std::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++20以后</span></span><br><span class="line"><span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> ...T&gt;(T&amp;&amp; ...args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(std::forward(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for循环支持初始化">for循环支持初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> data = <span class="built_in">getData</span>(); <span class="keyword">auto</span>&amp; v: data)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指引switch编译优化">指引switch编译优化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">break</span>;</span><br><span class="line">    [[likely]] <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;</span><br><span class="line">    [[unlikely]] <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-应用">C++应用</h2><h3 id="预处理include">预处理include</h3><blockquote><p>感觉不是很好用，建议不用</p></blockquote><p>判断能不能include一个文件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pch.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&quot;pch.h&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; NUMBER &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Modules-模块">Modules 模块</h3><blockquote><p>更高级的PCH，现阶段这东西大项目完全没法用</p></blockquote><h4 id="优点">优点</h4><ul><li>没有头文件，以及相关的依赖问题</li><li>引入模块时不需要像头文件那样指定路径</li><li>编译速度非常快（C++引用头文件会巨幅降低编译速度，于是很多人喜欢在头文件中只放一个类指针，到用到里面内容的时候在引用头文件，这样会大幅提高编译速度）</li><li>显示指定导入导出</li><li>模块引入顺序无关</li><li>与现有的头文件兼容</li><li>未来也许会像Python那样提供pip和包管理器？</li></ul><h4 id="缺点">缺点</h4><ul><li>除了最新的MSVC，其他编译器都没怎么实现这个功能</li><li>MSVC自己擅自主张，不按C++标准改了很多东西</li><li>IDE不支持全局modules的提示和跳转（VS2022在2023年10月支持了，clion至今还是垃圾）</li><li>需要反复引入std头文件（在C++23有快捷引入方式，但MSVC实现的很阴间）</li><li>对第三方库极度不友好</li><li>没有保存修改，IDE几乎没法解析，大多数情况IDE不给智能提示</li><li>和头文件、宏混用时容易报错</li><li>缺少std头文件时报错几乎无法阅读，大量匹配问题</li><li>cmake对其支持相当差</li><li>有的编译器无法将<code>.cpp</code>识别为modules？？？</li><li>import是局部的，每一个文件都需要反复import modules</li><li>一些静态变量、函数要到被用到时才会报错，build通过的代码不能保证能运行</li></ul><h4 id="用例">用例</h4><p>以MSVC的写法为例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// student.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> Student;</span><br><span class="line"><span class="keyword">import</span> &lt;string&gt;;</span><br><span class="line"><span class="keyword">namespace</span> Demo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>();</span><br><span class="line">        ~<span class="built_in">Student</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string m_name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// student.cppm</span></span><br><span class="line"><span class="keyword">import</span> Student;<span class="comment">// MSVC擅自废弃了module Student的写法，很离谱</span></span><br><span class="line"><span class="keyword">import</span> &lt;string&gt;;<span class="comment">// 反复import std也阴间了，C++23赶快端上来吧</span></span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">namespace</span> Demo</span><br><span class="line">&#123;</span><br><span class="line">    Student::<span class="built_in">Student</span>()&#123;</span><br><span class="line">        m_name = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Student::~<span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line">    Student::<span class="built_in">display</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计模式">设计模式</h2><blockquote><p>记住单例就行</p></blockquote><h3 id="单例（Singleton）">单例（Singleton）</h3><p>也分懒汉式和饿汉式，最常用的设计模式，讲了很多次</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> GameManager* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">m_instance = <span class="keyword">new</span> <span class="built_in">GameManager</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> GameManager* m_instance;</span><br><span class="line">    <span class="built_in">GameManager</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="工厂（Factory）">工厂（Factory）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Weapon</span>(std::string name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeaponFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Weapon* <span class="title">createWeapon</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Weapon</span>(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="享元（Flyweight）">享元（Flyweight）</h3><p>共享相似数据，对象仅拥有指向，下面的示例不同的享元类共用了工厂中的“颜色”</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象享元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元类 - 圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string color;  <span class="comment">// 内部状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">const</span> std::string&amp; color) : <span class="built_in">color</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Draw a &quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot; circle at position (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元类 - 矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string color;  <span class="comment">// 内部状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">const</span> std::string&amp; color) : <span class="built_in">color</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Draw a &quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot; rectangle at position (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, Shape*&gt; shapes;  <span class="comment">// 享元对象池</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shape* <span class="title">getShape</span><span class="params">(<span class="type">const</span> std::string&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shapes.<span class="built_in">find</span>(color) == shapes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果池中没有该颜色的图形，创建并加入池中</span></span><br><span class="line">            <span class="keyword">if</span> (color == <span class="string">&quot;Red&quot;</span>) &#123;</span><br><span class="line">                shapes[color] = <span class="keyword">new</span> <span class="built_in">Circle</span>(color);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color == <span class="string">&quot;Blue&quot;</span>) &#123;</span><br><span class="line">                shapes[color] = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shapes[color];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ShapeFactory shapeFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在不同位置绘制相同颜色的圆形和矩形</span></span><br><span class="line">    Shape* redCircle = shapeFactory.<span class="built_in">getShape</span>(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    redCircle-&gt;<span class="built_in">draw</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    Shape* blueRectangle = shapeFactory.<span class="built_in">getShape</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    blueRectangle-&gt;<span class="built_in">draw</span>(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次在不同位置绘制相同颜色的圆形</span></span><br><span class="line">    Shape* anotherRedCircle = shapeFactory.<span class="built_in">getShape</span>(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    anotherRedCircle-&gt;<span class="built_in">draw</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：虽然外部状态不同，但相同颜色的圆形共享内部状态，从而减少了对象的创建</span></span><br><span class="line">    <span class="comment">// 这符合享元模式的思想，通过共享尽可能多的相似对象来减少内存或计算开销</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察者（Observer）">观察者（Observer）</h3><h3 id="状态机（State）">状态机（State）</h3><h3 id="代理（Proxy）">代理（Proxy）</h3><h3 id="装饰者（Decorator）">装饰者（Decorator）</h3><h3 id="迭代器（Iterator）">迭代器（Iterator）</h3><h3 id="适配器（Adapter">适配器（Adapter)</h3><h3 id="命令（Command）">命令（Command）</h3><h2 id="面向对象">面向对象</h2><h2 id="模板元">模板元</h2><blockquote><p>除非是库代码，不然用模板元去优化业务代码，属实是往代码里下毒</p><p>更详细的信息可以看<a href="https://reubensun.com/program/C++template">C++模板</a></p></blockquote><h3 id="Traits">Traits</h3><p>为了减少相似代码，实现泛型，我们需要模板</p><p>对于一些特殊类型，我们往往需要特殊对待，于是需要模板特化</p><p>于是我们需要知道类型的<strong>特征</strong>，这就是Type Traits的作用</p><p>C++ STL中 Type Traits是一堆形如<code>IsXxxx&lt;T&gt;::value</code>的东西</p><h4 id="原理">原理</h4><blockquote><p>下面是boost库一些traits实现</p></blockquote><p>创建一个默认的行为和一个特例，仅当模板类型是特例时，value才是true</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span> &#123; <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">false</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span>&lt; <span class="type">void</span> &gt;&#123; <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">true</span>; &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer</span> &#123; <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">false</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer</span>&lt; T* &gt;&#123; <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">true</span>; &#125;;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ans = is_void&lt;T&gt;::value;</span><br><span class="line"><span class="keyword">auto</span> ans2 = is_pointer&lt;T&gt;::value;</span><br></pre></td></tr></table></figure><h4 id="std-true-type与std-false-type">std::true_type与std::false_type</h4><p>下面是通过类型萃取，判断一个类中是否有某个成员函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个支持Check的类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Check</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Check::someFunction() called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个不支持Check的类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCheck</span> &#123;</span><br><span class="line">    <span class="comment">// 没有someFunction成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasFunction_Execute</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">check</span><span class="params">(U* ptr)</span> -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;U&gt;().Execute(), std::true_type&#123;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::false_type <span class="title">check</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">check</span>&lt;T&gt;(<span class="literal">nullptr</span>))::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasFunction_Execute&lt;Check&gt;::value) &#123;</span><br><span class="line">        Check obj;</span><br><span class="line">        obj.<span class="built_in">Execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试NoCheck类</span></span><br><span class="line">    <span class="keyword">if</span> (hasFunction_Execute&lt;NoCheck&gt;::value) &#123;</span><br><span class="line">        <span class="comment">// 不会执行到这里，因为NoCheck类没有someFunction成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TMP">TMP</h3><blockquote><p>template metaprogramming（TMP）：将其他程序的<strong>代码视为数据</strong>的编程技术</p><p>TMP通常意味着代码可以被其他程序读取、生成、分析、转化，甚至运行时修改</p></blockquote><p>C++ TMP是一种用编译速度和存储空间换运行时速度的技术，将计算放在编译期，可以提高运行时性能</p><h4 id="递归">递归</h4><p>C++ TMP很适合写递归，比如计算阶乘</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title">Factorial</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X == <span class="number">0</span>) ? <span class="number">1</span> : X * <span class="built_in">Factorial</span>(X - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> x = <span class="built_in">Factorial</span>(<span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;<span class="comment">// 24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为汇编，发现程序并没有调用<code>Factorial</code>函数，而是直接找了一个立即数24</p><h4 id="构造函数">构造函数</h4><p>constexpr也可以修饰构造函数，创建编译器常量，以提高性能</p><p>使用该功能需要构造函数体的<strong>简单性</strong>，比如不能有虚函数，不能使用动态内存分配，条件语句，成员必须使用常量表达式初始化，递归必须在编译器能中止</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> : value(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; obj1.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL">STL</h2><h3 id="内存分配">内存分配</h3><p><code>&lt;memory&gt;</code>库提供了两个基础函数，<code>allocate()</code>和<code>deallocate()</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line"><span class="comment">// 开辟一个长度为10个int的空间</span></span><br><span class="line"><span class="type">int</span>* p = alloc.<span class="built_in">allocate</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 将数组第一个值构设为42</span></span><br><span class="line">std::allocator_traits&lt;std::allocator&lt;<span class="type">int</span>&gt;&gt;::<span class="built_in">construct</span>(alloc, p, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// 销毁这个数组</span></span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="concept-迭代器">concept 迭代器</h3><blockquote><p>C++迭代器已经是要被淘汰的概念了，但是新的C++标准仍然在对迭代器进行拓展</p></blockquote><p>concept可以对迭代器进行约束（也就是提要求<code>requires-expression</code>）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="keyword">concept</span> InputIterator = <span class="built_in">requires</span>(Iter iter) &#123;</span><br><span class="line">    &#123; iter++ &#125; -&gt; std::same_as&lt;Iter&gt;;<span class="comment">// 要求自增</span></span><br><span class="line">    &#123; iter != iter &#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;<span class="comment">// 要求能比较不等</span></span><br><span class="line">    &#123; ++iter &#125; -&gt; std::same_as&lt;Iter&amp;&gt;;<span class="comment">// 要求迭代器能前进</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;InputIterator Iter&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElements</span><span class="params">(Iter begin, Iter end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (begin != end) &#123;</span><br><span class="line">        std::cout &lt;&lt; *begin &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">printElements</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());<span class="comment">// 若不满足会编译报错</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式编程">函数式编程</h2><p>函数式编程将程序分解为函数（而非对象），使用表达式进行操作（而非语句）</p><p>函数式编程的核心是将一个大问题切成多个小问题</p><p>函数式编程更适合多线程</p><h3 id="std-function">std::function</h3><p>函数式编程将函数视为一等公民，常常将函数作为参数进行传递。不过一般公民通常需要有自己的成员和状态，函数指针无法满足我们的需求，重载类的<code>()</code>运算符有点太OOP了</p><p>C++提供了高阶函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::function&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">get_multiplier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::function&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [a](<span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> mul = <span class="built_in">get_multiplier</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">mul</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">10</span>)(<span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> mul3 = <span class="built_in">multiply</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">mul3</span>(<span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ranges-范围">Ranges 范围</h3><blockquote><p>感觉不同编译器对这个功能的支持差异好大</p></blockquote><ul><li>为std容器提供了简洁、强大、顺序可控的操作方式</li><li>引入view概念，运行创建一个惰性计算操作，不立即得到结果，提高内存利用率和性能</li><li>使用<code>|</code>和<code>-&gt;</code>操作符处理范围变量</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找array中偶数的数量</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> res = std::<span class="built_in">count_if</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);<span class="comment">// 2 个偶数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> res2 = arr | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : res2) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;<span class="comment">// 输出 2 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transform和filter返回的是一个range结构，而非容器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将vector中所有元素做平方，并去掉奇数项</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> square = [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i * i; &#125;;</span><br><span class="line"><span class="keyword">auto</span> odd = [](<span class="type">int</span> i)&#123; <span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> result = data | std::views::<span class="built_in">transform</span>(square) | std::views::<span class="built_in">filter</span>(odd);<span class="comment">// 1 9 25</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将一个二维数组展成一维</span></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; v2 = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> result2 = v2 | std::views::join;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个从1开始递增的数组，并对其进行平方，取前十个数（最后实际也只会计算十个数）</span></span><br><span class="line"><span class="keyword">auto</span> square = [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i * i; &#125;;</span><br><span class="line"><span class="keyword">auto</span> res = std::views::<span class="built_in">iota</span>(<span class="number">1</span>) |  std::views::<span class="built_in">transform</span>(square)| std::views::<span class="built_in">take</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : res) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">// 1 4 9 16 25 36 49 64 81 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="纯函数">纯函数</h3><blockquote><p>pure</p></blockquote><p>纯函数：不改变程序状态的函数</p><p>纯函数给定输入，无论执行多少次，都返回相同的结果</p><p>传函数不访问全局变量，仅使用输入的参数</p><h3 id="折叠">折叠</h3><p>折叠：将一组数据整合为数量更少的数据的方式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 一个累乘的示例</span></span><br><span class="line">    <span class="type">int</span> product = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">1</span>, std::<span class="built_in">multiplies</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product of elements: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::multiplies&lt;int&gt;()</code>可以替换为lambda表达式</p><h2 id="并发和多线程">并发和多线程</h2><blockquote><p>感觉不如TBB</p></blockquote><h3 id="std-thread">std::thread</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_background</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Background: &quot;</span> &lt;&lt; i++ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread background&#123;print_background&#125;;</span><br><span class="line">    <span class="keyword">auto</span> j&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: &quot;</span> &lt;&lt; j++ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待线程结束">等待线程结束</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread tl</span><br><span class="line">    &#123;</span><br><span class="line">        [] &#123; std::cout &lt;&lt; <span class="string">&quot;A lambda passed to the thread&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    tl.<span class="built_in">join</span>();<span class="comment">// 等待 tl执行结束</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-jthread">std::jthread</h3><blockquote><p>C++20提供的新线程库，可以完美替代std::thread</p></blockquote><p><code>std::jthread</code>在线程运行结束后再进行析构，可以确保线程安全退出</p><p>对异常和中断的支持更好</p><h4 id="主动停止">主动停止</h4><p>主动请求某个线程结束，下面的代码在<code>Main</code>输出完毕后<code>background</code>也会停止输出</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_background</span><span class="params">(std::stop_token stoken)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stoken.<span class="built_in">stop_requested</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Background: &quot;</span> &lt;&lt; i++ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::jthread background&#123;print_background&#125;;</span><br><span class="line">    std::stop_token stoken = background.<span class="built_in">get_stop_token</span>();</span><br><span class="line">    <span class="keyword">auto</span> jx&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (jx &lt; <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: &quot;</span> &lt;&lt; jx++ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    background.<span class="built_in">request_stop</span>();<span class="comment">// 请求结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传参">传参</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; std::format(<span class="string">&quot;Hello from thread, a: &#123;0&#125;, b: &#123;1&#125;&quot;</span>, a, b) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t1&#123; foo, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁">锁</h3><p>有时我们不得不多线程访问全局变量，为了避免冲突，需要对变量进行加锁</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex locker;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_value&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">g</span><span class="params">(locker)</span></span>;<span class="comment">// 通过生命周期管理锁</span></span><br><span class="line">    global_value++;</span><br><span class="line">    std::cout &lt;&lt; global_value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t1&#123; inc &#125;;</span><br><span class="line">    std::thread t2&#123; inc &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协程">协程</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, doSomething);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>co_await</li><li>co_yield</li></ul><h2 id="参考">参考</h2><p><a href="https://blog.csdn.net/qq_41854911/article/details/119657617">C++11、14、17、20新增内容</a></p><p>《Expert C++》</p><p><a href="https://en.cppreference.com/w/cpp/20">CppReference</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan学习笔记</title>
      <link href="/graphics/Vulkan%E5%AD%A6%E4%B9%A0/"/>
      <url>/graphics/Vulkan%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>Vulkan学习笔记</h1><blockquote><p>在过去，我以为Vulkan只有高端安卓才会用，相当复杂，没有下定决心去学。后来发现很多桌面和主机游戏也在用Vulkan，Vulkan真的很出色很重要，于是这几天开始看<a href="https://github.com/nvpro-samples/build_all">英伟达nvpro</a>和<a href="https://vulkan-tutorial.com/Introduction">Vulkan官方教程</a>，打算自己敲一个小demo</p></blockquote><h2 id="Vulkan-API">Vulkan API</h2><h3 id="Render-Pass">Render Pass</h3><blockquote><p>画啥</p></blockquote><p>Vulkan相较于OpenGL、DX11/12，一大特点就是有Render Pass这个概念</p><p>Render Pass的作用是描述绘制的目标（attachments），比如color，比如depth，这个概念很像RT</p><p>比如一个Forward Pass，他的目标可能就是一张color和一张depth，一个Deferred Pass，他的目标可能是GBuffer（一组color）和一个depth</p><h4 id="Subpass">Subpass</h4><p>一个像素在绘制单元绘制后，通常需要被拷贝出去，形成一张完整的RT，然后再由另一个绘制单元绘制</p><p>Subpass的一大特点是一个像素被一个Subpass绘制后，并不会立刻被拷贝出去，而是继续被另一个Subpass绘制</p><p><strong>优点：</strong></p><ol><li>减少了拷贝带来的带宽，减少延迟和发热，移动端延迟渲染常用该技术</li><li>像素间绘制彼此独立，不需要一整张RT绘制后再绘制下一张，提高并行效率，还能用来实现OIT和Zero Overdraw</li></ol><p><strong>缺点：</strong></p><ol><li>拿不到其他位置的RT的绘制内容，无法实现一些依赖RT的屏幕后效</li></ol><h3 id="Pipeline">Pipeline</h3><blockquote><p>怎么画</p></blockquote><p>用于设置管线的状态</p><table><thead><tr><th>参数</th><th>主要作用</th></tr></thead><tbody><tr><td>管线类型</td><td>图形管线还是计算管线</td></tr><tr><td>Shader Stage</td><td>指定绘制用的Shader</td></tr><tr><td>Vertex Input</td><td>顶点缓冲的结构</td></tr><tr><td>Input Assembly</td><td>输入的结构，比如三角形的拓扑规则</td></tr><tr><td>Viewport &amp; Scissors</td><td></td></tr><tr><td>Rasterizer</td><td>光栅化的规则，比如用线、用三角面绘制，是否背面剔除</td></tr><tr><td>Multisampling</td><td>多采样的规则</td></tr><tr><td>Depth Stencil</td><td>深度测试、模板测试的规则</td></tr><tr><td>Blending</td><td>颜色混合规则（半透明）</td></tr><tr><td>Pipeline Layout</td><td>管线的结构，比如UBO binding规则</td></tr></tbody></table><p>在Vulkan中，Render Pass是比Pipeline大的，这也很好理解，毕竟只要绘制目标没有改变，自然不需要改动Render Pass</p><p>而一个场景中有大量不同材质、Shader的对象，而且有的可能是线，有的是三角形，于是需要经常调整Pipeline，于是Vulkan的Pipeline就像Descriptor Set一样，可以随时改绑定的</p><p>Vulkan的Pipeline是很大的东西，实时创建大量开销过大，而大部分的Pipeline对象都很接近，可能就只有一小部分有差异。为了实现复用，Vulkan的Pipeline是可以动态修改、可以Cache、可以生成子类</p><h3 id="Descriptor-Set-Layout">Descriptor Set Layout</h3><blockquote><p>Shader中的资源位置</p></blockquote><p>Shader中会使用很多资源，比如UBO，比如贴图Sampler，需要指定绑定的位置</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform GlobalUBO &#123;</span><br><span class="line">    mat4 modelMatrix;</span><br><span class="line">    mat4 viewMatrix;</span><br><span class="line">    mat4 projectionMatrix;</span><br><span class="line">&#125; ubo;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">layout</span>(binding = <span class="number">1</span>) uniform sampler2D texSampler;</span><br></pre></td></tr></table></figure><h3 id="Descriptor-Set">Descriptor Set</h3><blockquote><p>资源</p></blockquote><p>简单理解为Vulkan管线能理解、使用的资源，比如UBO，比如贴图Sampler</p><p>在绘制时，我们可以绑定一个Descriptor Sets，里面包含多个Descriptor Set，其结构是Layout决定的</p><p>我们可以单独更新某一个Set</p><table><thead><tr><th>VkDescriptorType</th><th>含义</th><th>类似DX12中的</th></tr></thead><tbody><tr><td>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</td><td>读图片</td><td>SRV</td></tr><tr><td>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</td><td>读写图片</td><td>UAV</td></tr><tr><td>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</td><td>读图片，并包含各种采样配置</td><td>SRV + Sampler</td></tr><tr><td>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</td><td>常量缓冲</td><td>UBO</td></tr></tbody></table><h3 id="Image">Image</h3><blockquote><p>Texure</p></blockquote><h4 id="Usage">Usage</h4><blockquote><p>图片的使用目的</p></blockquote><table><thead><tr><th>VkImageUsageFlagBits</th><th>含义</th></tr></thead><tbody><tr><td>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</td><td>Color渲染目标</td></tr><tr><td>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</td><td>深度缓冲、模板缓冲渲染目标</td></tr><tr><td>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</td><td>图像拷贝的源</td></tr><tr><td>VK_IMAGE_USAGE_TRANSFER_DST_BIT</td><td>图形拷贝的目标</td></tr><tr><td>VK_IMAGE_USAGE_SAMPLED_BIT</td><td>可以被着色器读</td></tr><tr><td>VK_IMAGE_USAGE_STORAGE_BIT</td><td>可以被着色器写</td></tr></tbody></table><h4 id="Layout">Layout</h4><blockquote><p>图形在内存的布局和排列，会影响拷贝、渲染等行为的可用性</p></blockquote><table><thead><tr><th>VkImageLayout</th><th>用途</th></tr></thead><tbody><tr><td>VK_IMAGE_LAYOUT_UNDEFINED</td><td>图形初始化</td></tr><tr><td>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</td><td>Color渲染目标</td></tr><tr><td>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</td><td>深度缓冲、模板缓冲渲染目标</td></tr><tr><td>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</td><td>Shader可读的贴图</td></tr></tbody></table><p>Image的Layout转化需要使用Pipeline Barrier</p><h3 id="Image-View">Image View</h3><h2 id="Shader">Shader</h2><p>Vulkan使用SPIR-V作为着色语言，这是一种底层的二进制着色语言，可以使用glslang编译GLSL得到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将vert_shader.vert编译为vert_spv</span></span><br><span class="line"><span class="variable">$glslangValidator</span> -V vert_shader.vert</span><br><span class="line"><span class="comment"># 将vert_shader.vert编译为test.spv</span></span><br><span class="line"><span class="variable">$glslangValidator</span> -V vert_shader.vert -o test.spv</span><br></pre></td></tr></table></figure><h3 id="GLSL文件类型">GLSL文件类型</h3><ul><li>头文件（header）<ul><li><code>.glsl</code></li></ul></li><li>源文件（source）<ul><li><code>.vert</code>：Vertex</li><li><code>.frag</code>：Fragment</li><li><code>.comp</code>：Compute</li><li><code>.geom</code>：Geometry</li><li><code>.mesh</code>：Mesh</li><li><code>.rahit</code>：Ray any hit</li><li><code>.rcall</code>：Ray callable</li><li><code>.rchit</code>：Ray closest hit</li><li><code>.rgen</code>：Ray generation</li><li><code>.rint</code>：Ray intersection</li><li><code>.rmiss</code>：Ray miss</li><li><code>.task</code>：Task</li><li><code>.tesc</code>：Tessellation control</li><li><code>.tese</code>：Tessellation evaluation</li></ul></li></ul><h3 id="Vertex">Vertex</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform GlobalUBO &#123;</span><br><span class="line">    mat4 modelMatrix;</span><br><span class="line">    mat4 viewMatrix;</span><br><span class="line">    mat4 projectionMatrix;</span><br><span class="line">&#125; ubo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 inPosition;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec3 inColor;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">2</span>) in vec2 inTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec3 fragColor;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) out vec2 uv0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = ubo.projectionMatrix * ubo.viewMatrix * ubo.modelMatrix * <span class="built_in">vec4</span>(inPosition, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">    uv0 = inTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fragment">Fragment</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 fragColor;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec2 uv0;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 outColor;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(binding = <span class="number">1</span>) uniform sampler2D texSampler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    outColor = <span class="built_in">texture</span>(texSampler, uv0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# Attribute用法</title>
      <link href="/program/CSharpeAttribute/"/>
      <url>/program/CSharpeAttribute/</url>
      
        <content type="html"><![CDATA[<h1>C# Attribute用法</h1><h2 id="内建功能">内建功能</h2><h3 id="标记函数">标记函数</h3><p>比如标记函数已过时，再调用这个函数时会有绿色的波浪线，并提示你函数已过时</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Obsolete(<span class="string">&quot;This func is obsolete, use newFunc()&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OldFunc</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据验证">数据验证</h3><p>可以确保某个数据存在</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserModel</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">Required</span>(ErrorMessage = <span class="string">&quot;Username is required.&quot;</span>)]</span><br><span class="line">    <span class="keyword">public</span> string Username &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Required</span>(ErrorMessage = <span class="string">&quot;Password is required.&quot;</span>)]</span><br><span class="line">    <span class="keyword">public</span> string Password &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象，但是没有填充Required信息</span></span><br><span class="line"><span class="keyword">var</span> invalidUser = <span class="keyword">new</span> UserModel();</span><br><span class="line"><span class="keyword">var</span> validationResults = <span class="keyword">new</span> List&lt;System.ComponentModel.DataAnnotations.ValidationResult&gt;();</span><br><span class="line"><span class="built_in">bool</span> isValid = Validator.TryValidateObject(invalidUser, <span class="keyword">new</span> ValidationContext(invalidUser), validationResults, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (!isValid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> errorMessage = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> validationResult <span class="keyword">in</span> validationResults)</span><br><span class="line">    &#123;</span><br><span class="line">        errorMessage +=validationResult.ErrorMessage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出 &quot;Username is required.Password is required.&quot;</span></span><br><span class="line">    Console.WriteLine(errorMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化与反序列化">序列化与反序列化</h3><h4 id="WCF">WCF</h4><blockquote><p>Windows Communication Foundation</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DataContract</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DataMember</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DataMember</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> serializer = <span class="keyword">new</span> DataContractSerializer(<span class="keyword">typeof</span>(Person));</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> memoryStream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    serializer.WriteObject(memoryStream, person);</span><br><span class="line">    memoryStream.Position = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> serializedData = <span class="keyword">new</span> StreamReader(memoryStream).ReadToEnd();</span><br><span class="line">    LabelText = serializedData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = XmlReader.Create(<span class="keyword">new</span> StringReader(LabelText)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> deserializedPerson = (Person)serializer.ReadObject(reader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化的产物是一个xml：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.datacontract.org/2004/07/AttributeStudy&quot;</span> <span class="attr">xmlns:i</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">Age</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>John<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Serializable">Serializable</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person</span><br><span class="line">&#123;</span><br><span class="line">    Name = <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">    Age = <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化 Person 对象到文件</span></span><br><span class="line">System.Xml.Serialization.XmlSerializer serializer = <span class="keyword">new</span> System.Xml.Serialization.<span class="built_in">XmlSerializer</span>(<span class="built_in">typeof</span>(Person));</span><br><span class="line"><span class="built_in">using</span> (var stream = <span class="keyword">new</span> System.IO.<span class="built_in">FileStream</span>(<span class="string">&quot;F:\\person.xml&quot;</span>, System.IO.FileMode.Create))</span><br><span class="line">&#123;</span><br><span class="line">    serializer.<span class="built_in">Serialize</span>(stream, person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化从文件读取的数据</span></span><br><span class="line"><span class="built_in">using</span> (var stream = <span class="keyword">new</span> System.IO.<span class="built_in">FileStream</span>(<span class="string">&quot;F:\\person.xml&quot;</span>, System.IO.FileMode.Open))</span><br><span class="line">&#123;</span><br><span class="line">    Person deserializedPerson = (Person)serializer.<span class="built_in">Deserialize</span>(stream);</span><br><span class="line">    Console.<span class="built_in">WriteLine</span>($<span class="string">&quot;Name: &#123;deserializedPerson.Name&#125;, Age: &#123;deserializedPerson.Age&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化产物是一个xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Name</span>&gt;</span>John Doe<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Age</span>&gt;</span>30<span class="tag">&lt;/<span class="name">Age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="引入DLL">引入DLL</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">MessageBox</span>(<span class="params">IntPtr hWnd, <span class="built_in">string</span> text, <span class="built_in">string</span> caption, <span class="built_in">uint</span> type</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(IntPtr.Zero, <span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;Message&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义功能">自定义功能</h2><h3 id="插件">插件</h3><p>自定义属性</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class, AllowMultiple = false)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PluginAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PluginAttribute</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自定义的属性都形如xxxAttribute，在使用时只需要[xxx(“…”)]</p></blockquote><p>插件接口和插件实现</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPlugin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Plugin(<span class="string">&quot;MyPlugin&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPlugin</span> : <span class="title">IPlugin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyPlugin is executing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Plugin(<span class="string">&quot;MyPlugin2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPlugin2</span> : <span class="title">IPlugin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyPlugin2 is executing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到所有插件，并执行所有插件</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;IPlugin&gt; plugins = <span class="keyword">new</span> List&lt;IPlugin&gt;();</span><br><span class="line"><span class="comment">// 获取所有插件类型</span></span><br><span class="line"><span class="keyword">var</span> pluginTypes = Assembly.GetExecutingAssembly().GetTypes()</span><br><span class="line">.Where(type =&gt; type.GetCustomAttributes(<span class="keyword">typeof</span>(PluginAttribute), <span class="literal">true</span>).Length &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 实例化插件</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> pluginType <span class="keyword">in</span> pluginTypes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> pluginAttribute = (PluginAttribute)Attribute.GetCustomAttribute(pluginType, <span class="keyword">typeof</span>(PluginAttribute));</span><br><span class="line">    <span class="keyword">var</span> plugin = (IPlugin)Activator.CreateInstance(pluginType);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Loaded plugin: <span class="subst">&#123;pluginAttribute.Name&#125;</span>&quot;</span>);</span><br><span class="line">    plugins.Add(plugin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插件执行</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> plugin <span class="keyword">in</span> plugins)</span><br><span class="line">&#123;</span><br><span class="line">    plugin.Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake构建C#项目并使用DLL</title>
      <link href="/program/CSharpCmakeDLL/"/>
      <url>/program/CSharpCmakeDLL/</url>
      
        <content type="html"><![CDATA[<h1>CMake构建C#项目并使用DLL</h1><p>项目路径</p><blockquote><p>Windows cmd下使用<code>tree /f</code>即可生成文件路径</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">│  CMakeLists.txt</span><br><span class="line">│  Main.cs</span><br><span class="line">│  p4api.net.dll</span><br><span class="line">│  p4bridge.dll</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.23</span>)</span><br><span class="line"><span class="built_in">project</span>(P4Test CSharp)</span><br><span class="line"><span class="built_in">set_property</span>(GLOBAL PROPERTY VS_STARTUP_PROJECT P4Test)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_VS_EFFECTIVE_PLATFORMS x64) </span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(SOURCES</span><br><span class="line">    $&#123;CMAKE_SOURCE_DIR&#125;/Main.cs</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(P4Test $&#123;SOURCES&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set_property</span>(TARGET P4Test PROPERTY VS_DOTNET_TARGET_FRAMEWORK_VERSION <span class="string">&quot;v4.7.2&quot;</span>)</span><br><span class="line"><span class="built_in">set_property</span>(TARGET P4Test PROPERTY VS_DOTNET_REFERENCE_P4API <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/p4api.net.dll&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">add_custom_command</span>(</span><br><span class="line">    TARGET P4Test</span><br><span class="line">    POST_BUILD</span><br><span class="line">    COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_if_different</span><br><span class="line">        $&#123;CMAKE_SOURCE_DIR&#125;/p4api.net.dll</span><br><span class="line">        $&lt;TARGET_FILE_DIR:P4Test&gt;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">add_custom_command</span>(</span><br><span class="line">    TARGET P4Test</span><br><span class="line">    POST_BUILD</span><br><span class="line">    COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_if_different</span><br><span class="line">        $&#123;CMAKE_SOURCE_DIR&#125;/p4bridge.dll</span><br><span class="line">        $&lt;TARGET_FILE_DIR:P4Test&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Perforce.P4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> P4DoNetApi</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吸血鬼幸存者+战意</title>
      <link href="/game/%E5%90%B8%E8%A1%80%E9%AC%BC%E5%B9%B8%E5%AD%98%E8%80%85like/"/>
      <url>/game/%E5%90%B8%E8%A1%80%E9%AC%BC%E5%B9%B8%E5%AD%98%E8%80%85like/</url>
      
        <content type="html"><![CDATA[<h1>吸血鬼幸存者+战意</h1><h2 id="灵感起源">灵感起源</h2><p>最近在玩战意，感觉这游戏玩法设计的有问题</p><ol><li>主打将军梦的游戏，一次却只能带十几个兵，而且ACT玩法会给人一种这些小兵是具体的个体，而非抽象的军团，玩家扮演的是一个个十夫长（一个武将能杀几十个小兵，但绝不可能杀一个军团，但游戏中经常出现一个太刀侠杀一堆弓箭手）</li><li>小兵AI非常蠢，缺乏操作性，胜利基本取决于双方兵种的养成强度，而非操作</li><li>特别缺统御值，一场游戏只能带很少的兵，很快就成光杆司令，变成垃圾时间</li><li>攻防战体验非常糟糕，攻守不应该是等人数公平对战，攻城人数应该比守方多五到十倍</li><li>守方获胜的方式是等时间耗尽，没法主动出击快速结束游戏</li><li>游戏开始时攻方要推攻城塔，守方要等攻方进来，开局充满了垃圾时间</li><li>战斗区域大多在城内巷战，而现实中攻破城门其实基本宣告守城失败，主要战斗应该是野战夺旗</li><li>城防和工事基本没有用，战斗的本质是战旗，敌我双方把兵放在一起，让他们互砍</li><li>没有感受到明显的兵种克制，就算有克制，起码要让玩家每种兵开局各解锁一套，战斗时可以随时切换，现在一次只能带一队，变成猜拳游戏，希望对方不使用克制自己的兵，不是我的兵不强，只是我开局首发错了</li></ol><p>于是我打算从去年爆火的吸血鬼幸存者中吸取经验，做一个吸血鬼幸存者+战意的游戏</p><h2 id="玩法">玩法</h2><h3 id="背景">背景</h3><blockquote><p>你知道吗？拿破仑的法军都不带后勤的，敌人屯粮我屯枪，敌人就是我粮仓，去杀光烧光抢光吧，去征服整个大陆，你入关之后自有大儒辩经</p></blockquote><p>玩家出生在一个大陆上，这个大陆有很多国家（城市）和城邦。玩家需要收割麦子（掠夺农民），去城邦雇佣军队，攻打城市，最后统一整个大陆吧</p><h3 id="设计目标">设计目标</h3><p>体验一把中世纪掠夺者征服大陆，过足将军梦</p><h3 id="玩家目标">玩家目标</h3><p>收割麦子 —— 获得第一桶金 —— 去城邦购买军队 —— 控制军队攻打城市 —— 占领的城市会给玩家提供一次性的掠夺收入和持续的税收收入 —— 用收入去城邦买军队 —— 攻打其他城市 —— 统一整个大陆 —— 游戏结束</p><p>单局时长控制在二十分钟，玩家需要做的就是用鼠标左键控制主角移动，按按键指挥小兵</p><h3 id="游戏开始">游戏开始</h3><p>游戏开始时要选择地图和继承卡（如果没有可以不选择）</p><h3 id="继承卡">继承卡</h3><blockquote><p>类似于赛马娘</p></blockquote><p>游戏结束时会进行结算，获得一张继承卡，如果游戏胜利会获得更多的继承属性</p><p>继承卡中有各种因子，因子有三种，红因子（某种兵战斗力提升），黄因子（某种兵购买折扣），蓝因子（某种固有技能）</p><p>因子的获取是概率的，取决于你这把的得分</p><p>比如你这把买了很多骑兵，那么游戏结束就更有概率获得骑兵黄因子</p><p>如果这把骑兵杀了很多敌人，那么容易获得骑兵红因子</p><p>如果骑兵强化了很多次（去城邦买强化），那么容易得到骑兵蓝因子</p><h3 id="主角移动">主角移动</h3><p>TopDown俯视角游戏，主角始终保持在屏幕中间，通过鼠标左键点击移动</p><p><img src="/images/%E4%B8%BB%E8%A7%92%E7%A7%BB%E5%8A%A8.gif" class="lazyload" data-srcset="/images/%E4%B8%BB%E8%A7%92%E7%A7%BB%E5%8A%A8.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="主角移动"></p><h3 id="收割麦子">收割麦子</h3><p>主角走到麦子上即可获取麦子（就像捡地上的金币），麦子会转化为金钱（虚拟物品，在左上角显示）</p><h3 id="控兵">控兵</h3><p>主角不能直接控制兵，只能给兵发命令（不能像RTS那样框选，只能发指令，大部分情况都是自动战斗，以降低操作复杂度）</p><p>主角最多有控制四队兵，用1234切换，右侧会有小兵的状态（类似于原神）</p><p>兵有四种，铁剑、弓箭手、枪兵、骑兵</p><p>兵有三种状态，自由攻击、跟随攻击、驻扎攻击</p><p>士兵在驻扎期间可以缓慢恢复生命，提高向前的防御力，但不能移动</p><p>驻扎有形状（类似于战意中的X键）</p><p>骑兵可以像笔一样画移动方向（有些像红警的路径）</p><h3 id="城邦">城邦</h3><p>类似于吸血鬼幸存者中的箱子，玩家在靠近城邦后会弹出三张卡，支付金钱可以获得卡片收益，比如获得某个军队，升级某个军队</p><h3 id="敌方城市">敌方城市</h3><blockquote><p>初版认为城市的相同的</p></blockquote><p>当玩家靠近敌方城市时，敌方城市会开始刷兵，刷兵强度与玩家已经占领的城市数量有关</p><p>城市有一层塔皮，可以被攻击打掉，打光后成为我方城市，第一次占领可以获得一笔掠夺收益</p><p>敌方城市会射箭（类似于moba游戏的防御塔）</p><h3 id="我方城市">我方城市</h3><p>城市有塔皮，可以自动射箭攻击</p><p>塔皮被打光后会变回敌方城市</p><p>城市会为主角提供税金</p><h3 id="敌兵">敌兵</h3><p>敌兵会攻击我方的小兵和主角</p><p>杀死敌兵后会获得金币</p><h3 id="主角死亡">主角死亡</h3><p>主角死亡游戏失败，开下一把吧</p><h2 id="小兵">小兵</h2><h3 id="铁剑">铁剑</h3><p>均衡的小兵，最便宜</p><p>主打自由攻击</p><p>狂暴：提高攻击速度和移动速度</p><h3 id="枪兵">枪兵</h3><p>相较于铁剑，攻击距离更长，攻击频率更慢，更贵</p><p>克制枪兵</p><p>驻扎时正面防御力提高，有圆形驻扎、方形驻扎、长条形驻扎</p><p>齐攻：将所有小兵的攻击CD清空，向前挥出一个次长而有力的攻击（相较于普攻）</p><h3 id="骑士">骑士</h3><p>最贵</p><p>可以画线指挥路径</p><p>克制铁剑，被枪兵克制</p><h3 id="弓箭手">弓箭手</h3><p>比铁剑贵</p><p>发射箭矢攻击最近的敌人</p><p>驻扎攻击时提高攻速</p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译与链接</title>
      <link href="/program/%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
      <url>/program/%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1>C/C++编译与链接</h1><blockquote><p>《程序员的自我修养：链接、装载与库》阅读笔记</p></blockquote><h2 id="编译">编译</h2><p>编译可以被分为四个步骤：</p><ol><li>预编译（Prepressing）</li><li>编译（Compilation）</li><li>汇编（Assembly）</li><li>链接（Linking）</li></ol><h3 id="预编译">预编译</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure><ul><li>移除并展开所有<code>#define</code></li><li>处理所有条件预编译指令，如<code>#ifdef</code></li><li>递归处理<code>#include</code>指令，将被包含的文件拷贝到该指令位置</li><li>删除所有的注释</li><li>添加行号和文件名标识，便于产生调试和报错的行号信息</li><li>保留<code>#pragma</code>指令</li></ul><h3 id="编译-2">编译</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><ol><li>词法分析：扫描器使用有限状态机将源代码的字符切分为一系列记号（Token）</li><li>语法分析：分析记号，得到语法树，树的节点是表达式</li><li>语义分析：分析所有的<strong>静态语义</strong>，为表达式标注类型</li><li>中间语言生成：优化一些代码，比如2+6优化成8<ul><li>三地址码与P代码</li></ul></li><li>目标代码的生成与优化</li></ol><p>GCC可以将预编译和编译合成一个步骤</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cc1 hello.c</span><br></pre></td></tr></table></figure><h3 id="汇编">汇编</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure><h3 id="链接">链接</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ld -<span class="type">static</span> xxxx hello.o -xxxx</span><br></pre></td></tr></table></figure><p>链接的本质是替换指令中（对函数和变量）的地址引用</p><ol><li>地址和空间分配</li><li>符号决议</li><li>重定位</li></ol><p>main.c文件调用了func.c文件中的函数<code>foo()</code>，所以需要知道<code>foo()</code>的确切地址。但C++不同模块是单独编译的，因此编译main.c时不知道<code>foo()</code>的地址</p><p>于是编译器先将<code>foo()</code>的地址搁置，在链接的时候再逐个修正，填入<code>foo()</code>真实的地址</p><p>这个地址修复的过程也叫做重定位（Relocation），每一个需要修正的地方叫重定位入口（Relocation Entry）</p><h2 id="目标文件">目标文件</h2><p>编译器编译后生成的文件是目标文件（<code>.obj</code>和<code>.o</code>），结构跟可执行文件相同，只是还未链接</p><p>可执行文件、目标文件、动态库、静态库均采用相同的存储格式，在Windows下使用PE-COFF格式存储，在Linux下使用ELF格式存储</p><ul><li>Windows：PE-COFF（Probable Executable-Common File Format）</li><li>Linux：ELF（Executable Linkable Format）</li></ul><h3 id="目标文件格式">目标文件格式</h3><p>由四个部分组成：</p><ul><li>文件头（File Header）：文件可否执行、是静态链接还是动态链接、链接入口、目标硬件、目标操作系统、<strong>段表</strong>（Section Table）<ul><li>段表描述了文件中各个段的偏移位置和属性，用于找到代码段、数据段</li></ul></li><li>代码段（.text section）：编译得到的执行语句</li><li>数据段（.data section）：已初始化的静态/全局变量</li><li>.bss section：为未初始化的静态/全局变量预留位置，没有内容</li><li>.rodata section：只读数据，比如用const修饰的变量、字符串常量</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> global_inited_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, var);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_inited_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_uninit_var;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> local_inited_var = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> loacl_uninit_var;</span><br><span class="line">    <span class="built_in">func</span>(static_inited_var + static_uninit_var + local_inited_var + loacl_uninit_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="objdump-h-hello-o">objdump -h hello.o</h3><p>查看目标文件的结构</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hello.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000064</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000008</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a4  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000008</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>ac  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .rodata       <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>ac  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">4</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000b</span>0  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.GNU-stack <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>dc  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">6</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000e0</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">7</span> .eh_frame     <span class="number">00000058</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000100</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure><h3 id="objdump-s-d-hello-o">objdump -s -d hello.o</h3><p>将段内容以十六进制的形式打印出来，并将指令段反汇编</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hello.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> <span class="number">0000</span> f30f1efa <span class="number">554889e5</span> <span class="number">4883</span>ec10 <span class="number">897</span>dfc8b  ....UH..H....&#125;..</span><br><span class="line"> <span class="number">0010</span> <span class="number">45f</span>c89c6 <span class="number">488</span>d0500 <span class="number">00000048</span> <span class="number">89</span>c7b800  E...H......H....</span><br><span class="line"> <span class="number">0020</span> <span class="number">000000e8</span> <span class="number">00000000</span> <span class="number">90</span>c9c3f3 <span class="number">0f</span>1efa55  ...............U</span><br><span class="line"> <span class="number">0030</span> <span class="number">4889e548</span> <span class="number">83</span>ec10c7 <span class="number">45f</span>80100 <span class="number">00008b</span>15  H..H....E.......</span><br><span class="line"> <span class="number">0040</span> <span class="number">00000000</span> <span class="number">8b</span>050000 <span class="number">000001</span>c2 <span class="number">8b</span>45f801  .............E..</span><br><span class="line"> <span class="number">0050</span> c28b45fc <span class="number">01</span>d089c7 e8000000 <span class="number">00b</span>80000  ..E.............</span><br><span class="line"> <span class="number">0060</span> <span class="number">0000</span>c9c3                             ....</span><br><span class="line">Contents of section .data:</span><br><span class="line"> <span class="number">0000</span> <span class="number">54000000</span> <span class="number">55000000</span>                    T...U...</span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> <span class="number">0000</span> <span class="number">25640</span>a00                             %d..</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> <span class="number">0000</span> <span class="number">00474343</span> <span class="number">3</span>a202855 <span class="number">62756e74</span> <span class="number">75203131</span>  .GCC: (Ubuntu <span class="number">11</span></span><br><span class="line"> <span class="number">0010</span> <span class="number">2e332</span>e30 <span class="number">2</span>d317562 <span class="number">756e7475</span> <span class="number">317e3232</span>  <span class="number">.3</span><span class="number">.0</span><span class="number">-1u</span>buntu1~<span class="number">22</span></span><br><span class="line"> <span class="number">0020</span> <span class="number">2e303429</span> <span class="number">2031312</span>e <span class="number">332e3000</span>           <span class="number">.04</span>) <span class="number">11.3</span><span class="number">.0</span>.</span><br><span class="line">Contents of section .note.gnu.property:</span><br><span class="line"> <span class="number">0000</span> <span class="number">04000000</span> <span class="number">10000000</span> <span class="number">05000000</span> <span class="number">474e5500</span>  ............GNU.</span><br><span class="line"> <span class="number">0010</span> <span class="number">020000</span>c0 <span class="number">04000000</span> <span class="number">03000000</span> <span class="number">00000000</span>  ................</span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> <span class="number">0000</span> <span class="number">14000000</span> <span class="number">00000000</span> <span class="number">017</span>a5200 <span class="number">01781001</span>  .........zR..x..</span><br><span class="line"> <span class="number">0010</span> <span class="number">1b</span>0c0708 <span class="number">90010000</span> <span class="number">1</span>c000000 <span class="number">1</span>c000000  ................</span><br><span class="line"> <span class="number">0020</span> <span class="number">00000000</span> <span class="number">2b</span>000000 <span class="number">00450e10</span> <span class="number">8602430</span>d  ....+....E....C.</span><br><span class="line"> <span class="number">0030</span> <span class="number">06620</span>c07 <span class="number">08000000</span> <span class="number">1</span>c000000 <span class="number">3</span>c000000  .b..........&lt;...</span><br><span class="line"> <span class="number">0040</span> <span class="number">00000000</span> <span class="number">39000000</span> <span class="number">00450e10</span> <span class="number">8602430</span>d  ...<span class="number">.9</span>....E....C.</span><br><span class="line"> <span class="number">0050</span> <span class="number">06700</span>c07 <span class="number">08000000</span>                    .p......</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;func&gt;:</span><br><span class="line">   <span class="number">0</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64</span><br><span class="line">   <span class="number">4</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="number">5</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="number">8</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   c:   <span class="number">89</span> <span class="number">7</span>d fc                mov    %edi,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   f:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">12</span>:   <span class="number">89</span> c6                   mov    %eax,%esi</span><br><span class="line">  <span class="number">14</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rax        # <span class="number">1b</span> &lt;func+<span class="number">0x1b</span>&gt;</span><br><span class="line">  <span class="number">1b</span>:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">  <span class="number">1</span>e:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">23</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">28</span> &lt;func+<span class="number">0x28</span>&gt;</span><br><span class="line">  <span class="number">28</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">29</span>:   c9                      leave</span><br><span class="line">  <span class="number">2</span>a:   c3                      ret</span><br><span class="line"></span><br><span class="line"><span class="number">000000000000002b</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">2b</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64</span><br><span class="line">  <span class="number">2f</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">  <span class="number">30</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">  <span class="number">33</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">37</span>:   c7 <span class="number">45</span> f8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x1</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">3</span>e:   <span class="number">8b</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%edx        # <span class="number">44</span> &lt;main+<span class="number">0x19</span>&gt;</span><br><span class="line">  <span class="number">44</span>:   <span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">4</span>a &lt;main+<span class="number">0x1f</span>&gt;</span><br><span class="line">  <span class="number">4</span>a:   <span class="number">01</span> c2                   add    %eax,%edx</span><br><span class="line">  <span class="number">4</span>c:   <span class="number">8b</span> <span class="number">45</span> f8                mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">4f</span>:   <span class="number">01</span> c2                   add    %eax,%edx</span><br><span class="line">  <span class="number">51</span>:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">54</span>:   <span class="number">01</span> d0                   add    %edx,%eax</span><br><span class="line">  <span class="number">56</span>:   <span class="number">89</span> c7                   mov    %eax,%edi</span><br><span class="line">  <span class="number">58</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">5</span>d &lt;main+<span class="number">0x32</span>&gt;</span><br><span class="line">  <span class="number">5</span>d:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">62</span>:   c9                      leave</span><br><span class="line">  <span class="number">63</span>:   c3                      ret</span><br></pre></td></tr></table></figure><p>.data中<code>54000000</code>转化到十进制是84，<code>55000000</code>是85</p><h4 id="大小端">大小端</h4><p>注意十六进制的读法，0x54是最低位，后面三个0x00是更高的位，这种低位在前高位在后的字节序是<strong>小端序</strong>，有点反人类</p><h4 id="为什么要区分代码块和数据块呢？">为什么要区分代码块和数据块呢？</h4><ol><li>程序被装载后，数据区域是可读写的，而代码区域是只读的，将段进行分离，可以防止潜在的错误修改</li><li>数据集中存储，可以利用局部性原理提高缓存利用率</li><li>当系统同时运行多个同一文件时，可以共享只读的指令和数据，能大幅节省空间</li></ol><h3 id="readelf-h-hello-o">readelf -h hello.o</h3><p>查看elf文件头的详细信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              <span class="built_in">REL</span> (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x0</span></span><br><span class="line">  Start of program headers:          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1048</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of <span class="keyword">this</span> header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">14</span></span><br><span class="line">  Section header string table index: <span class="number">13</span></span><br></pre></td></tr></table></figure><p>魔术（Magic）用于区分ELF文件类型（与Windows里用后缀名区分不同）</p><h2 id="符号">符号</h2><h3 id="符号表">符号表</h3><p>如果目标文件B用到了目标文件A的函数<code>foo()</code>，我们称目标文件A定义（Define）了函数<code>foo()</code>，目标文件B引用（Reference）了函数<code>foo()</code></p><p>我们称函数、变量为符号（Symbol），他们的名字被称为符号名（Symbol Name），符号名独一无二</p><p>编译过程中每个目标文件都有一个符号表，每个符号能找到一个对应的符号值，对于变量和函数，符号值就是他们的地址</p><p>符号值的类型有：</p><ul><li><strong>定义在本文件内的全局符号</strong>，比如<code>global_inited_var</code>，<code>func</code></li><li><strong>定义在其他文件内，但是被本文件引用的全局符号</strong>，叫外部符号（External Symbol），比如<code>printf</code></li><li>段名，是段的起始地址</li><li>局部符号，比如<code>static_inited_var</code></li><li>行号</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">readelf -s hello.o</span><br></pre></td></tr></table></figure><h3 id="Name-Mangling">Name Mangling</h3><p>为了防止符号名冲突，C语言会加上命名空间等方法修饰符号，C++会做<strong>符号改编</strong>（Name Mangling）</p><p><strong>函数签名</strong>：由函数的名称、参数数量与类型、所在的类、所在的命名空间等组成</p><p>在C++进行编译链接时，会使用函数签名生成一个修饰后名称，使用这个修饰后名称作为符号名</p><p>C++允许使用函数重载，但是重载函数的参数不能完全相同</p><p>C++允许局部变量和全局变量重名，因为他们修饰后是两个不同的符号</p><blockquote><p>C++的Name Mangling规则取决于编译器版本，没有统一和公开</p></blockquote><h4 id="extern-“C”">extern “C”</h4><p>C++的符号十分复杂，C的符号兼容性会更好，于是我们可以使用<code>extern &quot;C&quot;</code>声明一个C符号，里面的符号不会被Name Mangling</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="强弱符号">强弱符号</h3><p>强符号：C++默认函数和初始化的全局变量为强符号，如果多个目标文件拥有相同名字的强符号，链接时会报符号重定义的错误</p><p>弱符号：C++未初始化的全局变量是弱符号</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;<span class="comment">// 不是强、弱符号，因为是外部文件定义的变量</span></span><br><span class="line"><span class="type">int</span> weak_var;<span class="comment">// 弱符号，未初始化的全局变量</span></span><br><span class="line"><span class="type">int</span> strong_var = <span class="number">1</span>;<span class="comment">// 强符号，初始化的全局变量</span></span><br><span class="line">__attribute__((weak)) weak_var2;<span class="comment">// 弱符号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">// main是强符号，函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则：</p><ul><li>不允许强符号重定义</li><li>弱符号会被强符号覆盖</li><li>若一个符号在所有文件中都是弱符号，则选择体积最大的符号去链接</li></ul><h4 id="强弱引用">强弱引用</h4><p>强引用：在链接时，如果没有找到强引用的符号，会报符号未定义的错误</p><p>弱引用：在链接时，若符号未定义，会给一个默认值0</p><p>弱符号、弱引用对于库来说十分有用，可以被用户自己定义的强符号所覆盖，也可以使得程序功能被剪裁组合</p><h2 id="静态链接">静态链接</h2><p>链接会将多个目标文件加工成一个可执行文件</p><h3 id="段合并">段合并</h3><p>相似段合并：将所有具有相同性质的段合并在一起，比如多个文件的.data段合在一个大的.data段中</p><h3 id="两步链接">两步链接</h3><ol><li>空间和地址分配</li><li><strong>符号解析</strong>和重定位</li></ol><h3 id="C-链接步骤">C++链接步骤</h3><ol><li>重复代码消除，一个模板可能在多个编译单元中被实例化，且实例化成相同的代码，将这些重复代码消除可以提高缓存利用率和节约空间</li><li>函数级别链接（选择性开启）：每一个函数都单独存储在一个段中，链接时按需添加到目标文件，可以减少包体，但是会降低编译链接速度</li></ol><h3 id="程序入口">程序入口</h3><p>Linux下程序的入口是<code>_start</code>，这是Glibc库的一部分，会进行程序的初始化，比如全局函数的创建，然后再去<code>main</code>函数执行</p><p>ELF有.init和.fini两个段，在这两个段中的代码会在<code>mian</code>前后执行</p><h3 id="ABI">ABI</h3><p>两个代码想要链接，需要使用相同的目标文件格式。我们将符号修饰、变量内存布局、函数调用方法等和二进制可执行文件兼容性相关的内容称为ABI（Application Binary Interface）</p><p>对于C语言，通过下列内容判断二进制兼容性：</p><ul><li>内置类型（int、char）的大小、字节序、对齐方式</li><li>组合类型（struct、array、union）的存储方式和内存分布</li><li>外部符号的解析方式，比如外部的<code>func</code>被解析为<code>_func</code></li><li>函数调用方式，比如参数入栈顺序，返回值如何保持</li><li>堆栈分布方式</li><li>寄存器使用约定</li></ul><p>对于C++还额外有：</p><ul><li>继承相关的内存分布</li><li>指向成员函数的指针的内存分布，如何通过成员函数指针调用成员函数，如何传递this指针</li><li>如何调用虚函数，虚表的内容及分布</li><li>模板如何实例化</li><li>Name Mangling</li><li>全局对象的构造与析构</li><li>异常</li><li>RTTI</li><li>inline</li></ul><p>C++的ABI不稳定，于是DLL建议使用C风格</p><h2 id="装载">装载</h2><p>可执行文件要装载到内存中才能被CPU执行</p><p>动态装入：许多情况下程序所需要的内存远超物理内存，为此我们会将一部分数据存储在磁盘里，内存中只保留最常用的部分。目前最常用的方法是页映射</p><h3 id="进程的创建">进程的创建</h3><ol><li>创建一个独立的虚拟内存空间<ul><li>分配页目录</li><li>虚拟内存区域（VMA）</li><li>段（Segment）</li></ul></li><li>读取可执行文件的头，建立虚拟空间和可执行文件的映射关系<ul><li>当程序发生<strong>缺页</strong>时，需要知道当前所需的页在可执行文件的哪一位置，这个位置信息存储在映射关系中</li><li>这是装载最核心的步骤，于是很多可执行文件也叫映像文件（Image）</li></ul></li><li>CPU指令寄存器设置为可执行文件的入口，程序运行</li></ol><h3 id="页错误">页错误</h3><p>当CPU开始执行一段指令时，发现所在地址的页面是一个空页面，这就是页错误</p><ol><li>此时操作系统会去读映射关系，找到当前页所在的VMA，计算出该页在可执行文件的位置</li><li>去物理内存中读这个页，并建立虚拟页和物理页的映射关系</li><li>回到先前的地址，继续执行指令</li></ol><h3 id="VMA">VMA</h3><p>VMA除了可以映射段，还会映射堆（Stack）和栈（Heap）</p><table><thead><tr><th>VMA类型</th><th>权限</th><th>能否执行</th></tr></thead><tbody><tr><td>代码VMA</td><td>只读</td><td>可执行</td></tr><tr><td>数据VMA</td><td>读写</td><td>可执行</td></tr><tr><td>堆VMA</td><td>读写</td><td>可执行</td></tr><tr><td>栈VMA</td><td>读写</td><td>不可执行</td></tr></tbody></table><h3 id="段地址对齐">段地址对齐</h3><p>x86处理器默认页的大小为4096字节，于是物理地址和虚拟地址进行映射时，虚拟内存空间的大小应该为4096字节的整数倍</p><h2 id="动态链接">动态链接</h2><p>静态链接浪费内存空间、磁盘空间、难以更新</p><p>动态链接将链接推迟到了运行（装载），能够实现库的复用，减少包体、提高缓存命中率</p><p>动态链接升级模块时，理论上只需要重新编译、替换动态库的模块，可以实现插件系统</p><p>Linux下动态库是动态共享对象（DSO），以<code>.so</code>结尾</p><p>Windows下动态库是动态链接库（DLL），以<code>.dll</code>结尾</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map</title>
      <link href="/program/map/"/>
      <url>/program/map/</url>
      
        <content type="html"><![CDATA[<h1>map</h1><blockquote><p>突然发现一个华科大佬的博客，学习一波</p></blockquote><p>map是一种映射结构，能够存取键值对（键是唯一的）</p><p>map通常有两种实现方式：哈希表（<code>std::unordered_map</code>）、红黑树（<code>std::map</code>）</p><h2 id="哈希表">哈希表</h2><p>哈希表的查找删除均为O(1)</p><p>哈希表是一种空间换时间的算法，现在我们要存储一组键值对，假设键的范围是0~99，那么我们就开辟一个大小为100的数组，数组中存储了指向值的指针，于是我们就可以通过Key去数组中找指针，再找到值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">value = a[key];</span><br></pre></td></tr></table></figure><p>不过开辟大小为100的数组过于昂贵了，只开辟大小为10的数组，Key去找值时先取模，再去数组中找指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">value = a[key%<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>不过这样也带来了一个问题，我们无法区分<code>key==21</code>和<code>key==31</code>，这种情况我们称之为<strong>哈希冲突</strong>，我们称21和31为同义词</p><p>解决哈希冲突的方式有：</p><ul><li>开放地址法</li><li>拉链法</li></ul><h3 id="拉链法">拉链法</h3><p>Key取模后去数组中找指针，这个指针是一个链表的头，遍历链表，找到对应Key的value</p><p>这种方法非同义词间不会影响</p><p><img src="/images/%E6%8B%89%E9%93%BE%E6%B3%95.jpg" class="lazyload" data-srcset="/images/%E6%8B%89%E9%93%BE%E6%B3%95.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="拉链法"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">point = a[key%<span class="number">10</span>];</span><br><span class="line"><span class="keyword">while</span>(point != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(point-&gt;key != key)</span><br><span class="line">    &#123;</span><br><span class="line">        point = point-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">break</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">value = point-&gt;value;</span><br></pre></td></tr></table></figure><h2 id="红黑树">红黑树</h2><p>红黑树的查找删除为O(logN)，但是空间效率更高</p><p>红黑树是一种自平衡的二叉搜索树，每个节点是黑色或红色</p><h3 id="二叉搜索树">二叉搜索树</h3><p>二叉搜索树（BST）：排序二叉树，任意一个根节点，其左子树Key均小于根，其右子树Key均大于根</p><p>BST的操作复杂度取决于树的高度，但某些情况下BST会退化为一条链</p><h3 id="平衡二叉树">平衡二叉树</h3><p>平衡二叉树（AVL）：左右子树的高度差不能大于1，操作过程中树一旦不稳定，就会进行旋转，以重新恢复平衡</p><p><img src="/images/avl-LL.jpg" class="lazyload" data-srcset="/images/avl-LL.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avl-LL"></p><p><img src="/images/avl-RR.jpg" class="lazyload" data-srcset="/images/avl-RR.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avl-RR"></p><p><img src="/images/avl-LR.jpg" class="lazyload" data-srcset="/images/avl-LR.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avl-LR"></p><p><img src="/images/avl-RL.jpg" class="lazyload" data-srcset="/images/avl-RL.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avl-RL"></p><h3 id="红黑树-2">红黑树</h3><p>红黑树左右子树高度差不能超过一倍</p><ol><li>所有null节点都认为是黑色。</li><li>一个红节点不能有红色孩子，即红色节点之间不能相邻。</li><li>红黑树中的节点到其任意叶子节点路径上的黑节点个数相同。</li><li>新插入的节点都是红色，在平衡过程中可能变色。</li></ol><p>红黑树比平衡二叉树更容易保持平衡，于是效率更高</p><p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91.png" class="lazyload" data-srcset="/images/%E7%BA%A2%E9%BB%91%E6%A0%91.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="红黑树"></p><h2 id="参考">参考</h2><p><a href="https://gufeijun.com/">辜飞俊的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BCN编码</title>
      <link href="/graphics/BCN%E7%BC%96%E7%A0%81/"/>
      <url>/graphics/BCN%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1>BCN编码</h1><blockquote><p>之前在知乎看到有美术在吵PNG和TGA哪一个更好用，但实际上引擎里使用的贴图是需要经过编码处理为GPU友好的资源格式，比如Windows上常用BCN编码，iOS常用ASTC编码</p></blockquote><h2 id="BCN原理">BCN原理</h2><blockquote><p>By storing some colors in their original size, and other colors using an encoding scheme, you can dramatically reduce the amount of memory required to store the image</p></blockquote><p>BCN是指一系列使用Block Compression技术的格式，比如BC3、BC7，在过去也被称为DXT</p><p>4x4的未压缩贴图在内存中会被排成一个长度为16的数组，如果一个像素要1bytes，那么未压缩的容量为16bytes</p><p><img src="/images/4x4%E8%B4%B4%E5%9B%BE.png" class="lazyload" data-srcset="/images/4x4%E8%B4%B4%E5%9B%BE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="4x4贴图"></p><p><img src="/images/4x4%E4%B8%8D%E5%8E%8B%E7%BC%A9.png" class="lazyload" data-srcset="/images/4x4%E4%B8%8D%E5%8E%8B%E7%BC%A9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="4x4不压缩"></p><h3 id="BCN-Format">BCN Format</h3><table><thead><tr><th>原始数据</th><th>编码精度需求 (单位bits)</th><th>推荐编码格式</th><th>每4x4像素大小</th></tr></thead><tbody><tr><td>RGBA</td><td>5 : 6 : 5 : 0 或 5 : 6 : 5 : 1</td><td>BC1</td><td>8</td></tr><tr><td>RGBA</td><td>5 : 6 : 5 : 4</td><td>BC2</td><td>16</td></tr><tr><td>RGBA</td><td>5 : 6 : 5 : 8</td><td>BC3</td><td>16</td></tr><tr><td>单通道灰度</td><td>8</td><td>BC4</td><td>8</td></tr><tr><td>双通道</td><td>8 : 8</td><td>BC5</td><td>16</td></tr><tr><td>RGB HDR</td><td>16 : 16 : 16</td><td>BC6H</td><td>16</td></tr><tr><td>RGB(A)</td><td>4 : 4 : 4 : (0~8) 或  7 : 7 : 7 : (0~8)</td><td>BC7</td><td>16</td></tr></tbody></table><p>DX9：BC1~3</p><p>DX10：BC4~5</p><p>DX11：BC7，BC6H</p><h3 id="BC1">BC1</h3><blockquote><p>下面这些图左边这个n bytes是指每一行是n bytes</p></blockquote><p>4x4的颜色被存储为两个color和16个index，每个index仅有两个比特位</p><p><img src="/images/BC1.png" class="lazyload" data-srcset="/images/BC1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC1"></p><p>color_0是这16个颜色中的最小值，color_1是最大值，我们先用这两个颜色生成两个中间值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">color_2 = <span class="number">2</span>/<span class="number">3</span>*color_0 + <span class="number">1</span>/<span class="number">3</span>*color_1</span><br><span class="line">color_3 = <span class="number">1</span>/<span class="number">3</span>*color_0 + <span class="number">2</span>/<span class="number">3</span>*color_1</span><br></pre></td></tr></table></figure><p>每个index只有两个比特位，只能存储四个信息，于是正好就可以存下这四个颜色的索引，对于每个像素，我们找到和他颜色最接近的color_x，并将他的index改为x</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">color_0 = <span class="number">00</span></span><br><span class="line">color_1 = <span class="number">01</span></span><br><span class="line">color_2 = <span class="number">10</span></span><br><span class="line">color_3 = <span class="number">11</span></span><br></pre></td></tr></table></figure><p>可以看出BC1的误差是相当大的，这个4x4个像素最后只有四种颜色</p><h3 id="BC2">BC2</h3><blockquote><p>BC2的RGB通道算法和BC1完全一致，然后为每一个像素加一个Alpha通道，也就是说，BC2的Alpha是完全没有被压缩的</p></blockquote><p><img src="/images/BC2.png" class="lazyload" data-srcset="/images/BC2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC2"></p><p>原理和BC1相同，都是用color_0和color_1生成四个颜色，每个index有两个位，存最相近的颜色的索引。唯一不同的是，BC2专门为每一个像素提供了一个 4位（0.5bytes）的Alpha通道</p><h3 id="BC3">BC3</h3><blockquote><p>BC2是完全不做Alpha的压缩，于是在BC3开始对其进行压缩，体现了技术的进步？</p></blockquote><p>BC3的RGB与BC1完全相同，Alpha使用类似思想进行压缩，将16个Alpha转化为两个alpha_x和16个index，两个alpha_x会插值出Alpha Table，16个像素各自去找最接近的Alpha，index记录他们的位数</p><p><img src="/images/BC3.png" class="lazyload" data-srcset="/images/BC3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC3"></p><p>为了精度，Alpha的位数是三个比特位，最多能表示八种Alpha，也就是说这16个像素最多会被分成八种Alpha</p><blockquote><p>alpha_0和alpha_1的大小对比提供了两个模式，使用第二个模式时可以直接得到0和255两个极值，而其他颜色还是在color间插值，效果会比所有颜色都直接在0和255两个极值间插8份更好，适用于颜色中存在极值的情况</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( alpha_0 &gt; alpha_1 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 6 interpolated alpha values.</span></span><br><span class="line">  alpha_2 = <span class="number">6</span>/<span class="number">7</span>*alpha_0 + <span class="number">1</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 010</span></span><br><span class="line">  alpha_3 = <span class="number">5</span>/<span class="number">7</span>*alpha_0 + <span class="number">2</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 011</span></span><br><span class="line">  alpha_4 = <span class="number">4</span>/<span class="number">7</span>*alpha_0 + <span class="number">3</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 100</span></span><br><span class="line">  alpha_5 = <span class="number">3</span>/<span class="number">7</span>*alpha_0 + <span class="number">4</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 101</span></span><br><span class="line">  alpha_6 = <span class="number">2</span>/<span class="number">7</span>*alpha_0 + <span class="number">5</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 110</span></span><br><span class="line">  alpha_7 = <span class="number">1</span>/<span class="number">7</span>*alpha_0 + <span class="number">6</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 111</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 4 interpolated alpha values.</span></span><br><span class="line">  alpha_2 = <span class="number">4</span>/<span class="number">5</span>*alpha_0 + <span class="number">1</span>/<span class="number">5</span>*alpha_1; <span class="comment">// bit code 010</span></span><br><span class="line">  alpha_3 = <span class="number">3</span>/<span class="number">5</span>*alpha_0 + <span class="number">2</span>/<span class="number">5</span>*alpha_1; <span class="comment">// bit code 011</span></span><br><span class="line">  alpha_4 = <span class="number">2</span>/<span class="number">5</span>*alpha_0 + <span class="number">3</span>/<span class="number">5</span>*alpha_1; <span class="comment">// bit code 100</span></span><br><span class="line">  alpha_5 = <span class="number">1</span>/<span class="number">5</span>*alpha_0 + <span class="number">4</span>/<span class="number">5</span>*alpha_1; <span class="comment">// bit code 101</span></span><br><span class="line">  alpha_6 = <span class="number">0</span>;                         <span class="comment">// bit code 110</span></span><br><span class="line">  alpha_7 = <span class="number">255</span>;                       <span class="comment">// bit code 111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BC4">BC4</h3><blockquote><p>BC4极少使用</p></blockquote><p>与BC1那种将4x4的像素转化为四种颜色不同，BC4是在两个颜色间做线性插值，red_0和red_1是最大最小颜色，像素数据转化为一个权重值（是一个0到1的float），使用这个权重值对red_0和red_1做线性插值即可还原颜色</p><p><img src="/images/BC4.png" class="lazyload" data-srcset="/images/BC4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC4"></p><p>不过三个比特位存一个0~1的浮点，精度其实很也很差吧，和离散的比没啥区别？</p><p>BC4_UNORM和BC4_SNORM仍然是使用BC3的离散Table算法</p><h3 id="BC5">BC5</h3><p>BC4的进阶版，简单来说就是将两个BC4拼在了一起</p><p><img src="/images/BC5.png" class="lazyload" data-srcset="/images/BC5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC5"></p><p>BC5_UNORM和BC5_SNORM也就是把对应的BC4拼起来</p><h4 id="法线贴图">法线贴图</h4><p>值得一提的是，BC5常用于压缩法线贴图，因为法线贴图有两个性质</p><ol><li>法线是归一化的$z=\pm\sqrt{1-x^2-y^2}$</li><li>法线各通道间是独立的</li></ol><p>BC1的方案将RGB三个通道进行杂糅，整体混合，这对于法线贴图来说是不可接受的，梯度太小，精度太差了，使用BC5存法线的两个通道，使用时再还原第三个通道，这些效果会更好</p><p><img src="/images/BC5%E6%B3%95%E7%BA%BF.png" class="lazyload" data-srcset="/images/BC5%E6%B3%95%E7%BA%BF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC5法线"></p><h3 id="承上启下">承上启下</h3><p>DX11提供了两个新的编码格式BC6H和BC7，再研究他们之前，我们先细数BC1压缩算法的问题吧</p><ol><li>信道不均，这很好理解，RGB通道分别被分了5 : 6 : 5位，这会导致三个通道全取最大值时会更偏绿（相较于三个通道相同尺寸）</li><li>精度太低，16个像素只能被转化位4种不同的颜色</li><li>三个通道耦合，且只使用两个颜色进行插值，这是一个线而非三角形</li></ol><p><img src="/images/BC1%E7%9A%84%E9%97%AE%E9%A2%98.png" class="lazyload" data-srcset="/images/BC1%E7%9A%84%E9%97%AE%E9%A2%98.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC1的问题"></p><h3 id="BC7">BC7</h3><p>核心思想</p><ol><li>存多个color，两个index</li><li>使用预计算的<strong>partition sets</strong>（调色盘）</li></ol><p>如果16个方块使用两个颜色涂抹，那么一共只会有$2^{16}$个情况，我们将这些情况全部离线存储在本地，并称之为调色盘（partition sets），使用一个索引即可得到对应的调色盘，还原出当前情况。</p><p>事实上由于颜色是存在连续性的，于是并不会出现这么多情况，于是我们可以大幅简化，使得几百种调色盘就足够使用。</p><p>更进一步，我们可以在调色盘种类和颜色数量间做平衡，使用更多种类的颜色和更少的调色盘种类，得到更丰富的模式</p><blockquote><p>BC7不同模式下总位数是确定的，于是color占的位数多了，调色盘占的位数就会变少</p></blockquote><p><img src="/images/BC7.png" class="lazyload" data-srcset="/images/BC7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC7"></p><p><img src="/images/BC7_2.png" class="lazyload" data-srcset="/images/BC7_2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC7_2"></p><p>BC7有很多模式（mode），我们可以为每块（4x4）选择一种模式，模式存储在BC7的开头（上图00001和1）</p><p>在不同的模式下，color数量和精度会改变，color越少越低精度，调色盘的选择就越多，反之color数据越多，调色盘选择就越少</p><p><img src="/images/BC7mode.jpg" class="lazyload" data-srcset="/images/BC7mode.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC7mode"></p><p>BC1是对两个color做个插值得到4个或者8个颜色，而BC7不做这个插值，需要多少颜色就存多少颜色，然后根据剩余的位数选择调色盘即可</p><p>![partition sets](/images/partition sets.jpg)</p><p>能看出下图上面一排只存了两个颜色，但调色盘变化更多样，下面一排存了三个颜色，调色盘变化略显单调</p><p><img src="/images/BC7_3.jpg" class="lazyload" data-srcset="/images/BC7_3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC7_3"></p><h3 id="BC6H">BC6H</h3><blockquote><p>干翻了RGBM，是BCN中唯一一个支持HDR的格式</p></blockquote><p>插值算法与BC7相同，用无符号整数来表示浮点数，将16位的数据的Sign位移除，加到Fraction位上，以提高float范围和精度</p><p><img src="/images/BC6H.png" class="lazyload" data-srcset="/images/BC6H.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC6H"></p><h2 id="DDS">DDS</h2><blockquote><p>注意区分贴图Compress和zlib、lz4压缩</p></blockquote><p>使用BCN编码格式的文件在Windows操作系统下后缀为<code>.dds</code></p><p>DDS文件：DDS Header + DX10 Header + Mip0 raw data + Mip1 raw data + …</p><p>BCN是一种GPU友好型的数据格式，DDS文件大小仅与贴图大小、Mipmap数量、像素格式有关，一张1024x1024一级Mipmap一个像素4 bytes的贴图，无论其质量如何，<strong>其大小是确定的</strong>，都是1KB（Header） + 1024KB</p><p>尽管DDS比TGA小很多，但还是有进一步的压缩空间，UE使用Oodle进行BCN编码，通过设置RDO来影响数据的紧凑程度，经由lz4二压可以再降低10%~40%的包体大小</p><h3 id="DDS-Header">DDS Header</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PixelFormat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> fourCC;</span><br><span class="line">    <span class="type">uint32_t</span> RGBBitCount;</span><br><span class="line">    <span class="type">uint32_t</span> RBitMask;</span><br><span class="line">    <span class="type">uint32_t</span> GBitMask;</span><br><span class="line">    <span class="type">uint32_t</span> BBitMask;</span><br><span class="line">    <span class="type">uint32_t</span> ABitMask;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DDSHeader</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> Magic; <span class="comment">// Must be DDS_MAGIC</span></span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> height;</span><br><span class="line">    <span class="type">uint32_t</span> width;</span><br><span class="line">    <span class="type">uint32_t</span> pitchOrLinearSize;</span><br><span class="line">    <span class="type">uint32_t</span> depth;</span><br><span class="line">    <span class="type">uint32_t</span> num_mips;</span><br><span class="line">    <span class="type">uint32_t</span> reserved1[<span class="number">11</span>];</span><br><span class="line">    PixelFormat ddspf;</span><br><span class="line">    <span class="type">uint32_t</span> caps;</span><br><span class="line">    <span class="type">uint32_t</span> caps2;</span><br><span class="line">    <span class="type">uint32_t</span> caps3;</span><br><span class="line">    <span class="type">uint32_t</span> caps4;</span><br><span class="line">    <span class="type">uint32_t</span> reserved2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="DX10-Header">DX10 Header</h3><blockquote><p>在DX9中BC叫DXT，DX10以后才改为BC</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DX10Header</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> dxgi_format;</span><br><span class="line">    <span class="type">uint32_t</span> resource_dimension;</span><br><span class="line">    <span class="type">uint32_t</span> misc_flag; <span class="comment">// see D3D11_RESOURCE_MISC_FLAG</span></span><br><span class="line">    <span class="type">uint32_t</span> array_size;</span><br><span class="line">    <span class="type">uint32_t</span> misc_flag2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="dxgi-format">dxgi format</h4><p>dxgi_format：DirectX Graphics Infrastructure，格式为<code>DXGI_FORMAT_&#123;编码类型&#125;_&#123;规范类型&#125;</code>，比如<code>DXGI_FORMAT_BC1_UNORM</code>、<code>DXGI_FORMAT_R32_FLOAT</code></p><p>规范格式有：</p><ul><li>UNORM：Unsigned Normalized，无符号归一化</li><li>SNORM：Signed Normalized，有符号归一化</li><li>FLOAT：浮点数，动态范围更大，但储存空间更大</li><li>TYPELESS：没有具体的规范类型，用于运行时确定格式</li><li>UINT：无符号整数（不归一化）</li><li>SINT：有符号整数（不归一化）</li></ul><h2 id="BCN-Compress">BCN Compress</h2><p>常见的BCN压缩工具有Texconv、NVTT、Oodle</p><ul><li>这里面我感觉NVTT是优雅最方便的，很适合嵌入引擎或者小项目使用</li><li>Texconv有很浓厚的微软风格。。。</li><li>Oodle是商业软件，编码速度极慢，而且没有内置的Mipmap和贴图IO工具，他只会处理raw block data，说实话挺不方便的，而且网上资料特别少，用过的人也因为版权不敢去分享，传Github还会被删库，但是Oodle生成的dds二压后包体特别小，正式项目还是建议用Oodle</li></ul><p>下面是NVTT读TGA生成BC7格式DDS的样例代码，可以说非常地干净清晰</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nvtt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string raw_tga_path = <span class="string">&quot;D:\\art\\raw.tga&quot;</span>;</span><br><span class="line">std::string output_dds_path = <span class="string">&quot;D:\\art\\out\\nvtt_out.dds&quot;</span>;</span><br><span class="line">    <span class="type">int</span> mipmap_count = <span class="number">3</span>;</span><br><span class="line">    nvtt::Surface image;</span><br><span class="line">    image.<span class="built_in">load</span>(raw_tga_path.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="function">nvtt::Context <span class="title">context</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    nvtt::CompressionOptions compression_options;</span><br><span class="line">    compression_options.<span class="built_in">setFormat</span>(nvtt::Format_BC7);</span><br><span class="line">    nvtt::OutputOptions output_options;</span><br><span class="line">    output_options.<span class="built_in">setFileName</span>(output_dds_path.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!context.<span class="built_in">outputHeader</span>(image, mipmap_count, compression_options, output_options)) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Writing the DDS header failed!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compress and write the compressed data.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mipmap_index = <span class="number">0</span>; mipmap_index &lt; mipmap_count; mipmap_index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!context.<span class="built_in">compress</span>(image, <span class="number">0</span> , mipmap_index, compression_options, output_options)) </span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Compressing and writing the DDS file failed!&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mipmap_index == mipmap_count - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        image.<span class="built_in">toLinearFromSrgb</span>();</span><br><span class="line">        image.<span class="built_in">premultiplyAlpha</span>();</span><br><span class="line">        image.<span class="built_in">buildNextMipmap</span>(nvtt::MipmapFilter_Triangle);</span><br><span class="line">        image.<span class="built_in">demultiplyAlpha</span>();</span><br><span class="line">        image.<span class="built_in">toSrgb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://github.com/microsoft/DirectXTex">微软开源的贴图工具，包含Texconv</a></p><p><a href="https://learn.microsoft.com/en-us/windows/win32/direct3d10/d3d10-graphics-programming-guide-resources-block-compression">微软关于BCN的介绍</a></p><p><a href="https://github.com/nvpro-samples/nvtt_samples">英伟达开源的贴图工具NVTT</a></p><p><a href="http://www.radgametools.com/oodletexture.htm">UE使用的商业贴图工具Oodle官网</a></p><p><a href="https://sv-journal.org/2014-1/06/en/index.php?lang=en">BCN算法</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Texture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软光栅化遮挡剔除</title>
      <link href="/graphics/%E8%BD%AF%E5%85%89%E6%A0%85%E5%8C%96%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/"/>
      <url>/graphics/%E8%BD%AF%E5%85%89%E6%A0%85%E5%8C%96%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1>软光栅化遮挡剔除</h1><p>DrawCall和着色十分昂贵，于是我们希望可以剔除掉那些看不见的物体，以提高性能。而简单的视锥剔除并不能剃干净场景的物体，于是需要遮挡剔除。</p><p>这篇文章是一个CPU端的遮挡剔除，需要离线制作Occlusion Mesh，但不依赖各种GPU Driven的技术</p><p>Intel认为，CPU端使用GPU生成的Depth buffer做剔除，如果你不提前开一个Depth Only Pass画深度，那就要用上一帧的深度，一般而言，根据连续性，用上一帧的深度也没什么问题。但实际上CPU和GPU的Tick频率可能不同，两者间可能会差好几帧，于是用复用上一帧的深度不靠谱。</p><p>那什么靠谱呢？在CPU端用软光栅画一个Depth buffer，保证一定是当帧剔除。</p><h2 id="软光栅生成深度图">软光栅生成深度图</h2><p>Tile Base的软光栅</p><p>若三角形横跨多个Tile，则在每个Tile组中都加入这个三角形</p><p>Tile间互相独立，并行软光栅</p><p>对于三角形内的像素，通过重心公式插值出深度</p><p>如果软光栅得到的深度比深度缓冲更接近观察者，写深度</p><h2 id="剔除">剔除</h2><h3 id="1-近裁剪平面裁剪">1. 近裁剪平面裁剪</h3><p>若近裁剪平面设为1，顶点的齐次坐标为w，若$0 &lt; w &lt; 1$，则裁剪通过</p><h3 id="2-视锥剔除">2. 视锥剔除</h3><h3 id="3-深度测试">3. 深度测试</h3><p>若一个物体、AABB有像素可见，那么整体都可见</p><p>如一个物体、AABB完全被遮挡，那就继续检测这个物体所有的像素，直到发现这个物体所有像素均被遮挡</p><h2 id="优化">优化</h2><ul><li>Tile Base</li><li>视锥剔除</li><li>SSE intrinsics</li><li>TBB并行</li><li>遮挡物/被遮挡物大小阈值</li></ul><h2 id="参考">参考</h2><p><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/software-occlusion-culling.html">Intel Software Occlusion Culling</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Culling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep搜索lib文件</title>
      <link href="/program/grep/"/>
      <url>/program/grep/</url>
      
        <content type="html"><![CDATA[<h1>grep搜索lib</h1><p>前几天写Vulkan发现链接不到<code>vkCmdBeginDebugUtilsLabelEXT</code>这个函数，同事说我肯定少链接了一个<code>.lib</code>文件，然我却不知道少链接了谁</p><p>同事交给我一个小技巧，lib文件本质是一个代码压缩包，是可以对里面的内容进行搜索的，在Linux（WSL）中进入存放<code>.lib</code>的库，输入命令</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">grep -r vkCmdBeginDebugUtilsLabelEXT .</span><br></pre></td></tr></table></figure><p>就会匹配<code>vkCmdBeginDebugUtilsLabelEXT</code>这个函数在哪一个<code>.lib</code>中出现过</p><p>最后的输出是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">grep: ./volk.lib: binary file matches</span><br></pre></td></tr></table></figure><p>所以我少链接了<code>volk.lib</code></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雨雪图</title>
      <link href="/graphics/%E9%9B%A8%E9%9B%AA%E5%9B%BE/"/>
      <url>/graphics/%E9%9B%A8%E9%9B%AA%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1>雨雪图</h1><p>现在游戏大多会有天气系统，尤其是雨天雪天</p><p>在雨天和雪天静态物上面要覆盖一层雪，可以参考Shadow Map的方法，从顶部向下绘制一张深度图（一般只收集静态物），运行时比较深度即可判断像素是否在最上面</p><p>值得注意的是玻璃等半透明物体按不透明的方式绘制深度图</p><h2 id="参考">参考</h2><p><a href="https://seblagarde.wordpress.com/2012/12/27/water-drop-2a-dynamic-rain-and-its-effects/">Water drop</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++获取CPU型号</title>
      <link href="/program/%E8%8E%B7%E5%8F%96CPU%E5%9E%8B%E5%8F%B7/"/>
      <url>/program/%E8%8E%B7%E5%8F%96CPU%E5%9E%8B%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1>C++获取CPU型号</h1><blockquote><p>不同CPU的指令集有所差异，尤其是在使用SIMD之类的feature时要十分注意，以MSVC获取CPU型号为例</p></blockquote><p>核心是使用指令<code>__cpuid</code>，其实你也可以<code>__asm &#123;&#125;</code>自己写汇编</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 4&gt; regs;</span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, 4&gt;&gt; data;</span><br><span class="line">    std::string vendor_string;</span><br><span class="line">    __cpuid(regs.<span class="built_in">data</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= regs[<span class="number">0</span>]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        __cpuidex(regs.<span class="built_in">data</span>(), i, <span class="number">0</span>);</span><br><span class="line">        data.<span class="built_in">push_back</span>(regs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> vendor[<span class="number">0x20</span>];</span><br><span class="line">    <span class="built_in">memset</span>(vendor, <span class="number">0</span>, <span class="built_in">sizeof</span>(vendor));</span><br><span class="line">    *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(vendor) = data[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(vendor + <span class="number">4</span>) = data[<span class="number">0</span>][<span class="number">3</span>];</span><br><span class="line">    *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(vendor + <span class="number">8</span>) = data[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    vendor_string = vendor;</span><br><span class="line">    <span class="keyword">if</span> (vendor_string == <span class="string">&quot;GenuineIntel&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Intel&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (vendor_string == <span class="string">&quot;AuthenticAMD&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AMD&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clustered Shading</title>
      <link href="/graphics/ClusteredShading/"/>
      <url>/graphics/ClusteredShading/</url>
      
        <content type="html"><![CDATA[<h1>Clustered Shading</h1><blockquote><p>《Clustered Deferred and Forward Shading》阅读笔记</p></blockquote><p>Cluster：组，簇，一堆物体的群集，将一个个零散的小物体整合为一个Cluster，可以加速剔除</p><p>Cluster的思路跟TBS思路很像，也是将view进行切分，但是每一个Cluster拥有一个固定的三维边界（坐标和法线），于是解决了Tiles退化的问题</p><p>光照计算时需要遍历物体和灯光，Clustered Shading的目的是剔除灯光</p><h2 id="Tile-base-Shading">Tile base Shading</h2><p>在讲Cluster前，先介绍什么是Tile base shading。TBS使用屏幕坐标将view切分为一个个小Tiles，单独绘制每一个Tiles，渲染结束后将所有Tiles合并呈现到屏幕上（得到framebuffer）</p><p>每一个Tiles会维护最小和最大深度，这两个深度和Tiles的屏幕UV就会组成一个粒度比较大的BV（Bound Volume），用于粗粒度的视锥剔除。在绘制每一个Tiles时，我只关注这个Tiles内的物体、灯光，不关心场景整体的复杂度，可以少遍历很多物体</p><p>此外这个Tiles之间是互相独立的，于是你可以自由控制他们的绘制顺序，比如如果某个像素上有两个半透明物体重叠，那么可以并行计算两个半透明物体的绘制结果，在最后一步混合时再手动排序</p><h3 id="优点">优点</h3><p>由于每次只需要绘制一个小Tiles，于是大幅减小的最大带宽（变得细水长流）</p><p>Tiles足够小，我们可以将Tiles放到片上缓存中，只需要调整着色器而无需移动资源位置（无需在显存和内存间传递，尤其是移动端这种共用全局内存的GPU），更进一步减少了带宽</p><img src="/images/AppleTBDR.png" class="lazyload" data-srcset="/images/AppleTBDR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="AppleTBDR" style="zoom:50%;" /><h3 id="问题">问题</h3><p>Tiles的BV是不确定的，通过屏幕UV采样深度得到的第三维边界是粗粒度的，不确定的。在某些极端相机视角下，min和max可能会差距很大，而内部的深度其实不连续（也就是最前面有个物体，最后面有个物体，结果得到了一个巨大的BV）</p><p>在这种情况下，BV就退化为一个平面，大幅降低了剔除效率</p><h2 id="相关技术">相关技术</h2><h3 id="Run-length-encoding">Run length encoding</h3><p>RLE（Run length encoding）是一种压缩算法，该算法依赖了数据的<strong>连续性</strong>，将一个一维的有重复值的数据进行压缩，能大幅减少数据量</p><p>此外当我们要对一个一维数组排序时，也可以将数组先做RLE，对压缩后的数据进行排序，排序结束后再展开</p><img src="/images/RLE.png" class="lazyload" data-srcset="/images/RLE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RLE" style="zoom:33%;" /><p>很多渲染技术都利用了数据的连续性，比如AA</p><h3 id="Virtual-Shadow-Maps">Virtual Shadow Maps</h3><p>VSMs是一张巨大的贴图（16k x16k），将这张巨大的贴图切成一个个小的Pages，仅当屏幕中有像素需要某个Pages时，才分配加载这个Pages</p><blockquote><p>于是出现了一个问题，要如何判定这个Pages被使用呢？</p></blockquote><h2 id="Clustered-Deferred-Shading">Clustered Deferred Shading</h2><blockquote><p>核心目标是剔除掉无用灯光</p></blockquote><ol><li>使用传统算法绘制GBuffer</li><li>分配Cluster（求切分后每一个Cluster的坐标）</li><li>找到唯一Cluster</li><li>分配灯光</li><li>着色</li></ol><h3 id="分配Cluster">分配Cluster</h3><p>根据连续性，若一个物体被某个灯光影响，其相邻的物体大概率也会被这个灯光影响</p><p>Cluster的本质就是将靠在一起的东西合并，光照计算时以Cluster为单位，而非Mesh/三角形。也就是说将这一组Mesh/三角形原子化（quantize）了</p><p>空间划分的方法有：</p><ul><li>世界坐标Grid切分<ul><li>数量过大，在远处存在浪费</li></ul></li><li>NDC空间按z均匀切分<ul><li>NDC非线性，近处Cluster过细，远处过粗</li></ul></li><li>View空间，按指数间隔切分深度</li></ul><p>最后作者选择了View空间按指数间隔切分深度，根据屏幕Tiles坐标$(i,j)$和深度等级$k$，每一个Cluster将拥有坐标$(i,j,k)$，他们在z轴方向上的距离间隔为$h_k$</p><img src="/images/指数间隔切分.png" class="lazyload" data-srcset="/images/指数间隔切分.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="指数间隔切分" style="zoom: 67%;" /><p>k是可以通过相机近平面、相机视角、该点深度和屏幕Tiles坐标求得</p><img src="/images/k的值.png" class="lazyload" data-srcset="/images/k的值.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="k的值" style="zoom:50%;" /><h3 id="找到唯一Cluster">找到唯一Cluster</h3><p>对每一个Tiles下的所有Cluster内物体进行排序</p><h3 id="分配灯光">分配灯光</h3><p>计算每一个Cluster受哪些光影响</p><p>在TBS中，我们可以直接遍历测试每一个Tiles和光源是否有覆盖，但这对于Cluster来说有些暴力了</p><ol><li>每一帧根据Z值顺序，将相邻的灯光（相邻32个灯）的BV合并，构建BVH（bounding volume hierarchy）</li><li>使用深度优先算法做Cluster和灯光BV的相交测试</li></ol><blockquote><p>英伟达GPU对32叉树更友好，而且32叉树深度更小，可以减少分支数</p></blockquote><p>这相较于Tiles Base有个好处是，当灯光特别特别多，均匀遍布在每一级深度中时，靠前的物体不需要再与靠后的灯光进行测试、着色（这是Tiles Base这种由最浅到最深构建的大BV无法做到的），能提升部分性能</p><h3 id="着色">着色</h3><p>用传统方案做着色计算</p><h2 id="作者的数据">作者的数据</h2><blockquote><p>我眼花了吗？作者对海量灯光的定义也太大了吧，这是12年的论文吧，同屏百万光源？手游项目同屏也就三四个点光吧</p></blockquote><p>在灯光数量较少时（比如同屏灯光少于1024个？？？），性能不如Tiles Base</p><p>在灯光特别多时（比如同屏灯光1048576个！！！），性能显著强于Tiles Base</p><h2 id="一点点想法">一点点想法</h2><p>延迟渲染光照计算次数 = 屏幕像素数 x 灯光数量，为了进一步提高着色效率，我们要剔掉一部分灯光</p><p>利用连续性原理，若一个像素被某个灯光影响，那么这个像素相邻的像素也可能被灯光影响，于是我们将view切分为一个个恰当尺寸的Cluster，每个Cluster只做一次灯光可见性测试，Cluster内部都使用相同的灯光list</p><p>与Tiles Base比，Cluster不仅对屏幕空间进行切分，还对深度进行切分，这使得被切分的空间复杂度是稳定的，和视角无关</p><p>不过Cluster与灯光测试比Tiles Base复杂了，而且Cluster的数据量更多，于是作者又基于深度构建了灯光的BVH，加速两个BV的测试</p><p>不过我们引入了两个3D场景描述结构，还使用了更复杂的相交测试方法，结果灯光较少时性能还更差了。。。移动端这两年苹果才刚开始大力推TBDR，感觉还是Tiles Base更有性价比</p><h2 id="参考">参考</h2><p><a href="https://developer.apple.com/documentation/metal/tailor_your_apps_for_apple_gpus_and_tile-based_deferred_rendering">Tailor Your Apps for Apple GPUs and Tile-Based Deferred Rendering</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视锥剔除</title>
      <link href="/graphics/%E8%A7%86%E9%94%A5%E5%89%94%E9%99%A4/"/>
      <url>/graphics/%E8%A7%86%E9%94%A5%E5%89%94%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1>视锥剔除</h1><blockquote><p>《Optimized View Frustum Culling Algorithms for Bounding Boxes》阅读笔记</p></blockquote><p>剔除的目的是减少要绘制不可见的物体，视锥剔除（View Frustum Culling，VFC）是使用一个平头四棱锥和场景中物体做可见性测试，实现快速剔除</p><p><img src="/images/%E8%A7%86%E9%94%A5%E5%89%94%E9%99%A4ue.png" class="lazyload" data-srcset="/images/%E8%A7%86%E9%94%A5%E5%89%94%E9%99%A4ue.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="视锥剔除ue"></p><p>为了加速视锥和场景物体的相交测试速度，我们会使用Bounding Volume（比如AABB、OBB、Sphere）来代替物体进行测试</p><p>视锥剔除可以并行计算，也可以使用BSP-trees加速</p><h2 id="基础数学知识">基础数学知识</h2><h3 id="点与面">点与面</h3><p>已知一个面的法线（已经归一化）为$\mathbf{n}$，沿着法线方向平移面，直到原点在面上，这个过程的移动距离为$d$</p><p>已知一个点的坐标$\mathbf{x}$，$\mathbf{x}$同时也是从原点指向这个点的向量，点到移动后的平面的距离是$\mathbf{n}\cdot\mathbf{x}$</p><p>所以，如果一个点在移动前的面上，那么应该满足<br>$$<br>\mathbf{n}\cdot\mathbf{x}+d=0<br>$$<br>通过这个公式，我们就可以快速判断点是否在平面上</p><h3 id="线与面">线与面</h3><p>一条线是两个点，如果两个点带入$\mathbf{n}\cdot\mathbf{x}+d$的符号是相反的，说明两个点在面的两侧，说明线与面相交</p><h3 id="AABB与面">AABB与面</h3><p>AABB是轴向包围盒，根据面的法线方向，就能知道AABB哪一个对角线轴最垂直于这个面，判读那这个对角线和面的关系，就能得到AABB和面的关系</p><p>我们还可以将这个对角线放在LUT里，加速之后几帧的相交检测（毕竟帧是连续的，我们可能会高频做相同面和对角线的相交检测）</p><h2 id="AABB视锥剔除">AABB视锥剔除</h2><h3 id="投影空间简单比较">投影空间简单比较</h3><p>还有一种和上述不同的方案，即将视锥和AABB转化到相机的透视投影空间，此时视锥变成一个立方体，于是就可以判断投影后的AABB和一个长方形视锥的相交关系，这个计算十分简单只需要算6次比较</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cube1_max[<span class="number">0</span>] &lt; cube2_min[<span class="number">0</span>] <span class="keyword">or</span> cube1_min[<span class="number">0</span>] &gt; cube2_max[<span class="number">0</span>] <span class="keyword">or</span></span><br><span class="line">    cube1_max[<span class="number">1</span>] &lt; cube2_min[<span class="number">1</span>] <span class="keyword">or</span> cube1_min[<span class="number">1</span>] &gt; cube2_max[<span class="number">1</span>] <span class="keyword">or</span></span><br><span class="line">    cube1_max[<span class="number">2</span>] &lt; cube2_min[<span class="number">2</span>] <span class="keyword">or</span> cube1_min[<span class="number">2</span>] &gt; cube2_max[<span class="number">2</span>]):</span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> True</span><br></pre></td></tr></table></figure><p>但这个方法缺点也很明显：需要做一个投影计算（很费）</p><p><img src="/images/AABB%E8%A7%86%E9%94%A5%E6%B5%8B%E8%AF%95.png" class="lazyload" data-srcset="/images/AABB%E8%A7%86%E9%94%A5%E6%B5%8B%E8%AF%95.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="AABB视锥测试"></p><h3 id="世界空间六个面替代视锥">世界空间六个面替代视锥</h3><p>我们可以将视锥是为六个平面，做六个平面和AABB的相交测试，若发现在AABB在视锥平面外，说明未相交，不可见</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">testVisible</span><span class="params">(AABB aabb, Camera camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 center = aabb.bound.center;</span><br><span class="line">    vec3 halfSize = <span class="built_in">abs</span>(aabb.bound.max - aabb.bound.min) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; plane : camera.frustumPlanes)</span><br><span class="line">    &#123;</span><br><span class="line">        SideResult side = <span class="built_in">testSide</span>(plane, center, halfSize);</span><br><span class="line">        <span class="keyword">if</span>(side == SideResult::OutSide)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作者的方案">作者的方案</h2><h3 id="八分检测">八分检测</h3><p>如图，我们使用轴将视锥切成八份，每一份是一个octant，每个octant都分到了三个外平面（图中加粗部分），若一个物体在视锥内，则必须在每一个octant的三个外平面的内侧</p><p><img src="/images/OctantTest.png" class="lazyload" data-srcset="/images/OctantTest.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="OctantTest"></p><p>对于一个AABB，他的中心点到corner的距离（其实就是半个主对角线长度）必须要小于视锥中心点到视锥平面的距离，也就是下图$d_2 \le d_1$。</p><p>这个检测的消耗特别小，不过不够准（必要不充分）</p><p>视锥中心点到六个平面的距离可以在每一帧计算前全局做一次</p><img src="/images/octantTest2.png" class="lazyload" data-srcset="/images/octantTest2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="octantTest2" style="zoom: 50%;" /><h3 id="标记视锥平面">标记视锥平面</h3><p>如果一个物体在一个视锥平面内侧，说明这个物体的所有子物体都在这个视锥平面内侧，那么我后面对子物体进行视锥剔除时不需要再用这个平面进行计算了</p><p>在AABB上维护一个bitfield，记录这个物体是被六个平面中哪些平面裁掉的</p><h3 id="连续性">连续性</h3><blockquote><p>TR：Translation and Rotation</p></blockquote><p>帧是连续的，我们让AABB记录一个bitfield和一个buffer，bitfield记录这个物体是被哪些平面裁掉，buffer记录AABB距离六个平面的距离</p><ul><li><p>如果一个物体在上一帧不可见，且视锥只移动了非常小的距离，那么这一帧这个物体大概率还是不可见</p></li><li><p>如果一个物体被视锥左平面剔除（可以复用“标记视锥平面”里的bitfield），那么视线向右转（不超过$180^{\circ}$）时，这个物体依然会不可见</p></li><li><p>如果相机只做移动，那么视锥平面到所有BV的最短距离均变化相同的值$\Delta d$（这个值可以全局只做一次），我们比较上一帧AABB到移动轴向两个平面的距离和$\Delta d$，即可判读这个物体可见性是否变化</p></li></ul><p><img src="/images/%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%89%94%E9%99%A4.png" class="lazyload" data-srcset="/images/%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%89%94%E9%99%A4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="连续性剔除"></p><h2 id="一点想法">一点想法</h2><p>一个基于连续性的剔除方法，能大幅减少剔除的次数和时间，只有第一帧在全场景遍历，后面都是增量改动。注意镜头快速移动时（比如setCameraPos）时主动重新全场景遍历一次吧</p><h2 id="参考">参考</h2><p><a href="https://docs.unrealengine.com/5.3/en-US/visibility-and-occlusion-culling-in-unreal-engine/#viewfrustum">UE5 View Frustum Document</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Culling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20下spdlog使用踩坑</title>
      <link href="/program/LogSystem/"/>
      <url>/program/LogSystem/</url>
      
        <content type="html"><![CDATA[<h1>C++20下spdlog使用踩坑</h1><p>spdlog是一个开源的被广泛使用的C++log系统，于是我模仿<a href="https://github.com/BoomingTech/Piccolo">Piccolo引擎</a>写了一个Log系统，结果由于C++不允许连续进行两次及以上的用户自定义的隐式构造，使得spdlog的log函数无法正确推断匹配<code>Args...</code>，最后在公司C++高手的帮助下成功解决了问题，于是在此记录一下踩坑历程</p><h2 id="最初的版本">最初的版本</h2><p>我参考开源项目的实现，使用spdlog写了一个简易的LogManager，将其添加到一共全局变量中，通过宏将不同类型的LOG封装，还传递了函数Module</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_HELPER(LOG_LEVEL, ...) \</span></span><br><span class="line"><span class="meta">    g_global_context.m_log_manager-&gt;log(LOG_LEVEL, <span class="string">&quot;[&quot;</span> + std::string(__FUNCTION__) + <span class="string">&quot;] &quot;</span> + __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(...) LOG_HELPER(LogManager::LogLevel::Debug, __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(...) LOG_HELPER(LogManager::LogLevel::Info, __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(...) LOG_HELPER(LogManager::LogLevel::Warn, __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(...) LOG_HELPER(LogManager::LogLevel::Error, __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FATAL(...) LOG_HELPER(LogManager::LogLevel::Fatal, __VA_ARGS__);</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogManager</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">LogLevel</span> : <span class="type">uint8_t</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug,</span><br><span class="line">        Info,</span><br><span class="line">        Warn,</span><br><span class="line">        Error,</span><br><span class="line">        Fatal</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogManager</span>();</span><br><span class="line">    ~<span class="built_in">LogManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">log</span><span class="params">(LogLevel level, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (level)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> LogLevel::Debug:</span><br><span class="line">            m_logger-&gt;<span class="built_in">debug</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LogLevel::Info:</span><br><span class="line">            m_logger-&gt;<span class="built_in">info</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LogLevel::Warn:</span><br><span class="line">            m_logger-&gt;<span class="built_in">warn</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LogLevel::Error:</span><br><span class="line">            m_logger-&gt;<span class="built_in">error</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LogLevel::Fatal:</span><br><span class="line">            m_logger-&gt;<span class="built_in">critical</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">fatalCallback</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> std::string format_str = std::format(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(format_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;spdlog::logger&gt; m_logger;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而当我测试时，却出现了错误</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LOG_INFO</span>(<span class="string">&quot;Scene Tick&#123;&#125;&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">error C7595<span class="punctuation">:</span> “fmt<span class="punctuation">:</span><span class="punctuation">:</span>v9<span class="punctuation">:</span><span class="punctuation">:</span>basic_format_string&lt;char<span class="punctuation">,</span>int&gt;<span class="punctuation">:</span><span class="punctuation">:</span>basic_format_string”<span class="punctuation">:</span> 对即时函数的调用不是常量表达式</span><br><span class="line">message <span class="punctuation">:</span> 因读取超过生命周期的变量而失败</span><br><span class="line">message <span class="punctuation">:</span> 请参见“&lt;args_0&gt;”的用法</span><br></pre></td></tr></table></figure><h2 id="fmt版本">fmt版本</h2><p>我求助了公司的C++高手，高手给我改成了这样，他将参数中函数Module分离出来，并将其和表达式宏拼接</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_HELPER(LOG_LEVEL, MODULE, FMT_STRING, ...) \</span></span><br><span class="line"><span class="meta">    g_global_context.m_log_manager-&gt;log(LOG_LEVEL, MODULE##FMT_STRING, __VA_ARGS__);</span></span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">template&lt;typename... Args&gt;</span><br><span class="line"><span class="addition">+void log(LogLevel level, const char* _module, Args&amp;&amp;... args)</span></span><br><span class="line">&#123;</span><br><span class="line">    switch (level)</span><br><span class="line">    &#123;</span><br><span class="line">    case LogLevel::Debug:</span><br><span class="line"><span class="addition">+        m_logger-&gt;debug(spdlog::fmt_runtime_string&lt;char&gt;&#123; _module &#125;, std::forward&lt;Args&gt;(args)...);</span></span><br><span class="line">        break;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并让我这样调用函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LOG_INFO</span>(__FUNCTION__, <span class="string">&quot;xxx&#123;&#125;&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>结果我发现，在高手电脑上可以正确运行的代码，在我本地缺会丢失<code>&quot;xxx1&quot;</code>这一部分，经过一段时间的排查，发现是我们的编译器预编译指令处理方式有区别，于是我修改cmake，让编译器使用符合C++标准的行为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">    <span class="built_in">target_compile_options</span>(core PUBLIC <span class="string">&quot;/Zc:preprocessor&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br></pre></td></tr></table></figure><p>添加后<code>&quot;xxx1&quot;</code>确实成功出现了</p><p>我本以为问题就这样解决，但C++高数却让我再实现一个可以只传字符串的重载（调另一个log接口），因为现在这个Log没法传入下面这种纯字符串内容</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LOG_INFO</span>(__FUNCTION__, <span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>我整个人傻眼了，心想spdlog这么厉害的库，肯定有很多人在C++20的环境下使用，怎么可能要这么丑陋的实现！</p><h2 id="std-fotmat版本">std::fotmat版本</h2><p>然后我翻看spdlog的源码，发现他有两个log的实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">const</span> T &amp;msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(level::debug, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">format_string_t</span>&lt;Args...&gt; fmt, Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(level::debug, fmt, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我就发现，原来我们之前一直想匹配到下面这个接口，却由于C++20在预编译处理上的一些改动，使我的代码十分复杂丑陋，而且还使用了spdlog内部的类型，我挺反感这种用一些模块内部类型的操作，我感觉好的工具类应该能黑箱地用</p><p>看着看着，我恍然大悟，C++20提供了<code>std::format</code>函数，我可以自己format字符串，传给spdlog一个普通字符串就行了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_HELPER(LOG_LEVEL, ...) \</span></span><br><span class="line"><span class="meta">    g_global_context.m_log_manager-&gt;log(LOG_LEVEL,<span class="string">&quot;[&quot;</span> __FUNCTION__ <span class="string">&quot;] &quot;</span> +std::format(__VA_ARGS__));</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogLevel level, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (level)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> LogLevel::Debug:</span><br><span class="line">        m_logger-&gt;<span class="built_in">debug</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉是时候深入学习C++20了</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我不小心取了一个右值的地址</title>
      <link href="/program/%E6%88%91%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%8F%96%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%B3%E5%80%BC%E7%9A%84%E5%9C%B0%E5%9D%80/"/>
      <url>/program/%E6%88%91%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%8F%96%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%B3%E5%80%BC%E7%9A%84%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1>我不小心取了一个右值的地址</h1><p>感觉每次背八股的时候都会看到左右值，但一直都是纸上谈兵（原谅我项目能力太差），结果今天真遇到了（我取了一个右值的地址</p><ul><li>左值：占用一定内存，有明确的可辨认地址的对象，在表达式结束后仍然存在</li><li>右值：左值以外的对象（类似于临时对象，在表达式结束后就会销毁）</li></ul><p>右值是一个临时的没有明确地址的对象，可能表达式结束这个对象就被销毁了，自然取它的地址是不确定行为，C++11后我们要改用移动或转发操作</p><p>然而很有意思的是，我怎么发现这个问题的呢？是我把项目升级到C++20，C++20明确禁止了取右值的引用（在过去只是不推荐，但没有明确为Error），然后编译报错了</p><p>然后我跟同事分享这个问题，他告诉我MSVC貌似对右值有优化，我过去代码能跑只是比较幸运</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glTF入门</title>
      <link href="/graphics/gltf%E5%85%A5%E9%97%A8/"/>
      <url>/graphics/gltf%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>glTF入门</h1><h2 id="glTF介绍">glTF介绍</h2><p>DCC生成的模型往往不能直接被渲染引擎使用，比如包含冗余数据、缺失场景数据、缺少动画状态机、压缩率不足等。许多引擎拥有一个Asset Pipeline，负责将不同DCC导出的各类数据转化为引擎可以直接使用的资源文件，比如UE的<a href="https://docs.unrealengine.com/4.26/zh-CN/SharingAndReleasing/Deployment/Cooking/">Cooking</a>操作</p><p>glTF是一种表示3D场景的模型格式，它的目标就是尽可能保留3D场景相关的数据（使用json描述场景），为渲染引擎提供无需解码的模型数据（使用二进制存储buffer和image）</p><h3 id="文本类型">文本类型</h3><p>glTF有二进制（.glb）和ASCII文本格式（.gltf）</p><p>一般而言，文本格式的glTF并不包含二进制内容（buffer和image），而是仅有一个uri链接，指向真正存储这些二进制数据的文件，这些数据已经被处理成GPU便于访问的格式</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;buffer01&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;byteLength&quot;</span><span class="punctuation">:</span> <span class="number">12352</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arraybuffer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;buffer01.bin&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;image01&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image01.png&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>正是因为glTF这种描述和存储分离的特点，我们可以用很小的文件就能得到场景的描述，当我们需要使用到某个buffer或image时再懒加载这个资源，于是很适合Web项目。现在很多基于WebGL的渲染器都使用glTF格式</p><p>值得注意的是，对于一些小模型，我们也可以将这些二进制嵌入到json中</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;buffers&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;uri&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;data:application/octet-stream;base64,AAABAAIAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAA=&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;byteLength&quot;</span> <span class="punctuation">:</span> <span class="number">44</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="json结构">json结构</h3><p><img src="/images/gltfJsonStructure.png" class="lazyload" data-srcset="/images/gltfJsonStructure.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="gltfJsonStructure"></p><h4 id="scene">scene</h4><p>scene是解析一个glTF的入口，一个glTF可以包含多个scene</p><p>一个scene中会有一个nodes，nodes是一个数组，指向多个node</p><p>一个node中会有mesh等元素</p><h4 id="mesh">mesh</h4><p>一个meshes包含多个primitives（图元），每个图元中有一个attributes（属性）和indices</p><p>attributes中包含着模型的顶点数据（vertices），比如POSITION、NORMAL、TEXCOORD_0</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;meshes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;primitives&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attributes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;POSITION&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;indices&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">      <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h4 id="accessor">accessor</h4><p>accessor（访问器），这是对资源的一种抽象封装，它存储了bufferView的结构，以及访问方法</p><p>对于mesh、skin、animation等数据，我们要通过accessor来访问。accessor中有一个bufferView，bufferView又指向存储真正二进制数据的buffer</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;accessors&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;bufferView&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;byteOffset&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;componentType&quot;</span> <span class="punctuation">:</span> <span class="number">5123</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;count&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;SCALAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;max&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">2</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;min&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">0</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;bufferView&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;byteOffset&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;componentType&quot;</span> <span class="punctuation">:</span> <span class="number">5126</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;count&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;VEC3&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;max&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">0.0</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;min&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">0.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">,</span> <span class="number">0.0</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h4 id="buffer">buffer</h4><blockquote><p>A buffer defines a block of raw, unstructured data with no inherent meaning</p></blockquote><p>为了便于渲染API的使用，glTF里的buffer是单纯的二进制，因此在解析时一定要明确读取的步长、类型</p><h4 id="bufferView">bufferView</h4><blockquote><p>A bufferView describes a “chunk” or a “slice” of the whole, raw buffer data</p></blockquote><p>bufferView将一个完整的巨大的二进制内容切割为一个个小片，可以实现一个buffer存储多种类型的数据，还可以实现字节对齐等功能</p><h2 id="一个简单的读mesh示例">一个简单的读mesh示例</h2><blockquote><p>这里我使用<a href="https://github.com/syoyo/tinygltf">tinygltf</a>库来加载glTF，这是一个基于cmake的纯头文件库</p></blockquote><p>举一个简单的glTF读取mesh的例子，仅读取index buffer和vertex buffer（只有POSITION和TEXCOORD_0）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GltfLoader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GltfLoader</span>(std::string model_path);</span><br><span class="line">    ~<span class="built_in">GltfLoader</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Index&gt; loaded_index_buffer;</span><br><span class="line">    std::vector&lt;Vertex&gt; loaded_vertex_buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    tinygltf::Model m_gltf_model;</span><br><span class="line">    tinygltf::TinyGLTF m_loader_context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GltfLoader::<span class="built_in">GltfLoader</span>(std::string model_path)</span><br><span class="line">&#123;</span><br><span class="line">    std::string gltf_load_error;</span><br><span class="line">    std::string gltf_load_warning;</span><br><span class="line">    <span class="type">bool</span> gltf_load_result = m_loader_context.<span class="built_in">LoadASCIIFromFile</span>(&amp;m_gltf_model, &amp;gltf_load_error, &amp;gltf_load_warning, model_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gltf_load_result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// load mesh</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; mesh : m_gltf_model.meshes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; primitive : mesh.primitives)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// vertex</span></span><br><span class="line">                <span class="type">int</span> vertex_count = <span class="number">0</span>;</span><br><span class="line">                std::vector&lt;Vertex&gt; local_vertex_buffer;</span><br><span class="line">                <span class="comment">// position</span></span><br><span class="line">                <span class="keyword">if</span> (primitive.attributes.<span class="built_in">find</span>(<span class="string">&quot;POSITION&quot;</span>) != primitive.attributes.<span class="built_in">end</span>()) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> accessor_index = primitive.attributes.<span class="built_in">at</span>(<span class="string">&quot;POSITION&quot;</span>);</span><br><span class="line">                    <span class="type">const</span> tinygltf::Accessor&amp; accessor = m_gltf_model.accessors[accessor_index];</span><br><span class="line">                    <span class="type">const</span> tinygltf::BufferView&amp; buffer_view = m_gltf_model.bufferViews[accessor.bufferView];</span><br><span class="line">                    <span class="type">const</span> tinygltf::Buffer&amp; buffer = m_gltf_model.buffers[buffer_view.buffer];</span><br><span class="line">                    <span class="type">const</span> <span class="type">float</span>* data_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">float</span>*&gt;(&amp;buffer.data[buffer_view.byteOffset + accessor.byteOffset]);</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> position_byte_stride = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                    vertex_count = accessor.count;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertex_count; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Vertex local_vertex;</span><br><span class="line">                        local_vertex.pos = glm::<span class="built_in">vec3</span>(data_ptr[i * position_byte_stride], data_ptr[i * position_byte_stride + <span class="number">1</span>], data_ptr[i * position_byte_stride + <span class="number">2</span>]);</span><br><span class="line">                        local_vertex_buffer.<span class="built_in">push_back</span>(local_vertex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// uv</span></span><br><span class="line">                <span class="keyword">if</span> (primitive.attributes.<span class="built_in">find</span>(<span class="string">&quot;TEXCOORD_0&quot;</span>) != primitive.attributes.<span class="built_in">end</span>()) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> accessor_index = primitive.attributes.<span class="built_in">at</span>(<span class="string">&quot;TEXCOORD_0&quot;</span>);</span><br><span class="line">                    <span class="type">const</span> tinygltf::Accessor&amp; accessor = m_gltf_model.accessors[accessor_index];</span><br><span class="line">                    <span class="type">const</span> tinygltf::BufferView&amp; buffer_view = m_gltf_model.bufferViews[accessor.bufferView];</span><br><span class="line">                    <span class="type">const</span> tinygltf::Buffer&amp; buffer = m_gltf_model.buffers[buffer_view.buffer];</span><br><span class="line">                    <span class="type">const</span> <span class="type">float</span>* data_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">float</span>*&gt;(&amp;buffer.data[buffer_view.byteOffset + accessor.byteOffset]);</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> uv_byte_stride = accessor.<span class="built_in">ByteStride</span>(buffer_view) ? (accessor.<span class="built_in">ByteStride</span>(buffer_view) / <span class="built_in">sizeof</span>(<span class="type">float</span>)) : tinygltf::<span class="built_in">GetNumComponentsInType</span>(TINYGLTF_TYPE_VEC2);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertex_count; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        local_vertex_buffer[i].texture_coord = glm::<span class="built_in">vec2</span>(data_ptr[i * uv_byte_stride], data_ptr[i * uv_byte_stride + <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// append local vertex buffer to loaded vertex buffer</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertex_count; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    loaded_vertex_buffer.<span class="built_in">push_back</span>(local_vertex_buffer[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// index</span></span><br><span class="line">                <span class="keyword">if</span> (primitive.indices &gt;= <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">const</span> tinygltf::Accessor&amp; accessor = m_gltf_model.accessors[primitive.indices];</span><br><span class="line">                    <span class="type">const</span> tinygltf::BufferView&amp; buffer_view = m_gltf_model.bufferViews[accessor.bufferView];</span><br><span class="line">                    <span class="type">const</span> tinygltf::Buffer&amp; buffer = m_gltf_model.buffers[buffer_view.buffer];</span><br><span class="line"></span><br><span class="line">                    <span class="type">const</span> <span class="type">void</span>* dataPtr = &amp;(buffer.data[buffer_view.byteOffset + accessor.byteOffset]);</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> elements_count = accessor.count;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// MARK: the component type is very important, common is TINYGLTF_PARAMETER_TYPE_UNSIGNED_SHORT</span></span><br><span class="line">                    <span class="keyword">switch</span> (accessor.componentType) </span><br><span class="line">                    &#123;</span><br><span class="line">                    <span class="keyword">case</span> TINYGLTF_PARAMETER_TYPE_UNSIGNED_INT:</span><br><span class="line">                        &#123;</span><br><span class="line">                        <span class="type">const</span> <span class="type">uint32_t</span>* buf = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint32_t</span>*&gt;(dataPtr);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elements_count; i++)</span><br><span class="line">                            &#123;</span><br><span class="line">                                Index local_index;</span><br><span class="line">                                local_index.index = buf[i];</span><br><span class="line">                                loaded_index_buffer.<span class="built_in">push_back</span>(local_index);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> TINYGLTF_PARAMETER_TYPE_UNSIGNED_SHORT: &#123;</span><br><span class="line">                        <span class="type">const</span> <span class="type">uint16_t</span>* buf = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint16_t</span>*&gt;(dataPtr);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elements_count; i++)</span><br><span class="line">                            &#123;</span><br><span class="line">                                Index local_index;</span><br><span class="line">                                local_index.index = buf[i];</span><br><span class="line">                                loaded_index_buffer.<span class="built_in">push_back</span>(local_index);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> TINYGLTF_PARAMETER_TYPE_UNSIGNED_BYTE: &#123;</span><br><span class="line">                        <span class="type">const</span> <span class="type">uint8_t</span>* buf = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(dataPtr);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elements_count; i++)</span><br><span class="line">                            &#123;</span><br><span class="line">                                Index local_index;</span><br><span class="line">                                local_index.index = buf[i];</span><br><span class="line">                                loaded_index_buffer.<span class="built_in">push_back</span>(local_index);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        std::cerr &lt;&lt; <span class="string">&quot;Index component type &quot;</span> &lt;&lt; accessor.componentType &lt;&lt; <span class="string">&quot; not supported!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> load children</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> load transform, material, texture, skin, skeleton, animtion, blendshape</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://github.khronos.org/glTF-Tutorials/gltfTutorial/">glTF Tutorials</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> glTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无状态方法</title>
      <link href="/program/%E6%97%A0%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/program/%E6%97%A0%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>无状态方法</h1><h2 id="线程安全">线程安全</h2><p>同事经常跟我强调线程安全的重要性，比如下面这段代码，id是一个静态成员变量，被所有Student类的对象共享，在多线程环境下可能会造成不确定行为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Student::id = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>我们可以加入一个锁以实现线程安全，std::lock_guard会通过其生命周期创建销毁锁</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::mutex id_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(id_mutex)</span></span>;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Student::id = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="无状态方法">无状态方法</h2><p>然后同事又跟我介绍了<strong>无状态方法</strong>（Stateless），即计算中不依赖先前的状态或上下文的方法。比如stl中大量的非成员函数，他们大多都是无状态方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种非成员函数是无状态的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">adder</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">adder</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过重载()运算符来实现adder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> c)&#123; <span class="keyword">this</span>-&gt;c = c; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="function">Adder <span class="title">adder</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">adder</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般而言，无状态方法只要输入是确定的，输出一般是可预料的（内部使用random相关函数的输出总体也是有期望的）</p><p>与无状态方法对应的是<strong>有状态方法</strong>（Stateful），比如一些读资源函数，我传入一个指针、Handle、索引，返回的结果取决于资源状态，输出的结果是不确定的。有状态方法一般要注意线程安全问题、空指针、索引越界等问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不好的设计，因为getCurrentDateText的结果与format的状态有关</span></span><br><span class="line"><span class="comment">// 尽管这样设计性能更好（不频繁创建新对象），一般也没人改format</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy.MM.dd&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getCurrentDateText</span><span class="params">()</span> </span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">return</span> format.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无状态方法，线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getCurrentDateText</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy.MM.dd&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://www.infoq.cn/news/2012/06/ugly-code-12">无状态方法</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分配</title>
      <link href="/program/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/program/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1>内存分配</h1><blockquote><p>最近看了一些关于内存分配的分享，发现操作系统相关的知识都忘光了，于是打算借助Linux内核的内存分配机制，简单复习一下内存分配相关的理论知识</p></blockquote><p>程序运行时不断进行内存的申请与释放，高效的分配方式不仅能提高内存的利用率，还能提高性能。</p><h2 id="Linux内存分配原理">Linux内存分配原理</h2><h3 id="地址">地址</h3><p>程序需要装入内存才能运行，程序开始的位置相较于内存0地址会有一段偏移，这个偏移被称为物理地址。</p><p>在程序内部，以程序开头为0地址，向后偏移得到的地址称为逻辑地址。</p><h3 id="分配">分配</h3><p>内存分配最大的问题是内存碎片问题，大的数据间总是残余一些小的空间，这些空间整体数量较多，但是单个空间较小，无法满足存入新的大数据，于是尽管我们还有大量空间没有被使用，但是无法分配给新的数据。</p><ul><li>连续分配（将程序放在一起）<ul><li>单一连续分配<ul><li>系统区</li><li>用户区</li></ul></li><li>固定分区分配</li><li>可变分区分配<ul><li>首次适应</li><li>最后适应</li><li>最佳适应</li><li>最坏适应</li></ul></li></ul></li><li>不连续分配（将程序分散放置）<ul><li>页式管理</li><li>段式管理</li></ul></li></ul><p>Intel CPU硬件支持段式管理和二层页式管理，Liunx主要使用二层页式管理。</p><h3 id="页式管理">页式管理</h3><blockquote><p>一本书有很多页，每一页都有页码，页码可以唯一标识一本书中的某一页，页式管理就是将数据分成一个个大小相等的页，每一页都有一个唯一的页码，通过页码可以找到对应的数据</p></blockquote><p>页式管理是一种不连续分配技术，将数据的逻辑地址拆成一个个大小相等的<strong>页面</strong>。将内存也拆成一个个大小相等的<strong>页框（物理块）</strong>，并为每个页框分配一个唯一的<strong>页框号</strong>。</p><p>程序被装入内存时，被拆成多个页，这些页会被放入内存中不连续的位置，通常只有最后一页会写不满，因此只会产生一个页内碎片。</p><p><img src="/images/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6.png" class="lazyload" data-srcset="/images/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="页表机制"></p><p>上图中间的是<strong>页表</strong>，存储着页号和物理块的对应关系，以实现页间寻址。<br>页内的数据通过虚地址（页号+页内偏移量）来实现页内寻址。</p><p>为了提速，页表含有一个缓存机制。</p><p>我们上面的页表是连续分配的，而对于一个32位系统，他拥有一个大小为$2^{32}$的逻辑空间，会形成一个巨大的页表。为此我们将页表也进行拆分，离散存储在内存中，使用一个外层目录表来存储页表的地址。当我们需要某一个页数据时，通过外层目录找到对应页表的地址，将该部分页表装入内存，再通过页表找到对应的页数据。这个方案叫做二级页表。</p><h2 id="常见内存分配器">常见内存分配器</h2><p>Linux内核为不同场景设计了不同的分配器，比如Slab、TLSF、Buddy，内存分配器需要在分配性能和空间利用率间做出权衡。</p><blockquote><p>我感觉这三个分配器并不是平级的关系，Buddy像是一个硬件级、操作系统级的分配器，进行页面级别的内存分配，他解决了程序要怎么分散放置在内存中。TLSF解决了如何具体分配一块指定大小的内存。Slab则为内存分配提供了缓存优化。</p></blockquote><h3 id="Buddy">Buddy</h3><blockquote><p>以内存页（4kb）为单位分配内存，本质还是一种空闲链表法</p></blockquote><p>Buddy系统将内存拆分为多个物理块，这些块的大小均为2的幂次方</p><p>Buddy分配器维护了一个空闲位图（也有用二叉树维护的），这个位图是一个数组，数组的每个元素是一个链表。链表中每一个元素均为$2^n$大小的空闲物理块，其中$n$为order的值。</p><p><img src="/images/buddy%E8%A1%A8.png" class="lazyload" data-srcset="/images/buddy%E8%A1%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Buddy位图"></p><p>当分配一个大小为k的内存时，分配器会找到比k大且order值最小的空闲块，如果这个最小的空闲块比k的两倍还大，那么将这个空闲块拆分为二，再次进行分配。</p><p>当释放一块内存时，将新的内存块放入对应链表中，若该链表中内存块过多，会进行合并操作</p><h3 id="TLSF">TLSF</h3><blockquote><p>用于分配介于512b和512kb的数据，实现可以参考<a href="https://github.com/mattconte/tlsf">tlsf</a></p></blockquote><p>TLSF（Two-Level Segregated Fit）的核心是使用两级链表。</p><p>第一级链表（下图f1）将空闲内存块大小根据二的幂次方进行分类（注意，这里表示的是内存的粗细粒度，而非要求内存块大小必须为二的幂次方），该行的内存块大小范围为$[2^i, 2^{i+1})$</p><p>第二级链表（下图s1）按照间隔，将索引$[2^i, 2^{i+1})$进行分段，以加速查找。二级链表的值是一个链表，链表中的每个元素是一个空闲内存块，大小和索引值相同。</p><p>FL_bitmap和SL_bitmaps[]的每一个bit表示是否被使用。</p><p>当我们需要分配一个大小为89Bytes的内存时，这个数据范围在$[64, 128)$，我们通过FL_bitmap判断出第6行是有空闲块的。然后通过SL_bitmaps[6]判断出$[88, 96)$这个范围中有空闲块，最后分配出89Bytes大小的内存块</p><p><img src="/images/TLSF%E4%B8%A4%E7%BA%A7%20%E7%B4%A2%E5%BC%95.jpg" class="lazyload" data-srcset="/images/TLSF%E4%B8%A4%E7%BA%A7%20%E7%B4%A2%E5%BC%95.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TLSF两级索引"></p><p><img src="/images/TLSF.png" class="lazyload" data-srcset="/images/TLSF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TLSF结构"></p><p>TLSF分配、释放、再分配复杂度均为稳定的O(1)，且适用于高负载和多线程环境。不过尽管操作复杂度都是常数级，但位图操作比较复杂，速度并不一定快</p><h3 id="Slab">Slab</h3><blockquote><p>用于小于512b、频繁被销毁创建的数据，</p></blockquote><p>上面的Buddy算法以页为单位进行分配，对于几字节的小文件，这十分浪费。Slab分配器用于在一个页框内分配小存储区，是对Buddy分配在小文件的补充。</p><p>Slab分配器是一种基于缓存的内存分配方法，对于一些高频使用的对象（比如进程描述符），将其放入Slab缓存中。</p><p>当需要创建一个对象时直接从缓存中拿去一份（所有权转移？）。当进程结束后，并不将对象所在的页框释放，而是重新放回Slab分配器中。</p><p>一个对象可以同时有着多个副本缓存，我们将同一个对象的所有缓存存入一个双向循环链表中，这个链表被称为“缓存链”。</p><p>通过着色技术提高缓存利用率。</p><h4 id="缓存着色技术">缓存着色技术</h4><p>缓存着色技术适用于组相联映射缓存</p><p>缓存的组织组织方式：</p><ul><li>直接映射</li><li>组相连映射（set associative cache）</li><li>全相连映射（full associative cache）</li></ul><p>直接映射：内存地址到缓存地址的映射是唯一的，通常为取模运算。这会导致相邻的内存会被映射到同一缓存地址，导致<strong>缓存冲突</strong>（conflict miss）</p><p>全相联映射：允许内存地址映射到任何缓存地址。但是为了检查特定地址是否在缓存中，需要整个便利。通常要实现一套LRU（最近最少使用）系统。全相联缓存硬件复杂，而且极其昂贵，一般都极其小。</p><p>组相联映射是对两者的折中，将整个缓存分成n个组，每个组中有m块。将内存做拆分，每个内存块有n行数据。内存中第i行的数据可以存在第i组缓存中，内存块和块之间共享m块缓存。当内存数据存入缓存时，通过取模运算得到组号，再便利组内数据，判断该数据是否已经在缓存中了。</p><p><img src="/images/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" class="lazyload" data-srcset="/images/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="组相连映射"></p><p>然后我们发现，如果同时多个数据他们的组号相同，他们还是会被映射到同一个组内，一旦数量超过了m条，就会引发缓存冲突。</p><p>缓存着色技术将内存、程序、缓存进行分行并标色，对于一段程序，操作系统会尽量将程序的某一行放到对应颜色的内存行、缓存行中（红色的程序行放在红色的缓存行中）。</p><p><img src="/images/%E7%BC%93%E5%AD%98%E7%9D%80%E8%89%B2.png" class="lazyload" data-srcset="/images/%E7%BC%93%E5%AD%98%E7%9D%80%E8%89%B2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="缓存着色"></p><h2 id="参考">参考</h2><p>《操作系统原理及应用（Linux）》王红</p><p><a href="https://www.gdcvault.com/play/1028734/Building-Night-City-The-Technology">Building Night City: The Technology of ‘Cyberpunk 2077’ - GDC 2021</a></p><p><a href="https://zhuanlan.zhihu.com/p/565768503">TLSF内存分配器</a></p><p><a href="https://blog.csdn.net/pwl999/article/details/118253758">TLSF内存分配原理</a></p><p><a href="https://stackoverflow.com/questions/30097648/difference-between-a-direct-mapped-cache-and-fully-associative-cache">组相联缓存机制</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数调用</title>
      <link href="/program/C++%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
      <url>/program/C++%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>C++函数调用</h1><p>C++支持两种函数调用方式，<code>__stdcall</code>和<code>__cdecl</code>，两者对栈帧（stack frame）的处理方式不同，<code>__stdcall</code>是由被调用函数来清理栈帧，<code>__cdecl</code>是由调用函数来清理栈帧。一旦混用，容易引发错误</p><blockquote><p>两者混用可能会导致栈帧没有被释放或者被连续释放两次</p></blockquote><h3 id="stack-frame">stack frame</h3><p>栈帧用于维护函数调用的上下文信息，在函数调用时，会在栈上分配一块内存，用于存储函数的参数、返回值、局部变量、调用者的栈指针等，函数返回后，栈帧会被销毁</p><h3 id="standard-call">standard call</h3><p><code>__stdcall</code>全称为standard call，是Pascal和Win32的默认调用方法，函数在调用时必须严格按照定义传递参数，参数从右向左入栈，在函数返回前执行出栈指令（retn x），清理栈帧</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// windef.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALLBACK   __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPI    __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPIV   __cdecl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APIENTRY   WINAPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APIPRIVATE  __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASCAL    __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cdecl _cdecl</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CDECL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CDECL _cdecl</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> __stdcall <span class="title">AddStdCall</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">AddStdCall</span>(<span class="number">5</span>, <span class="number">3</span>);        <span class="comment">// 使用stdcall调用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result using stdcall: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> __stdcall <span class="title">AddStdCall</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Declaration">C Declaration</h3><p><code>__cdecl</code>全称为C Declaration，是C/C++的缺省调用方法，该方法最大的特点是允许传入<strong>可变参数</strong>，函数返回后由调用者执行出栈指令（ret），清理栈帧</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> __cdecl <span class="title">SubtractCDecl</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">SubtractCDecl</span>(<span class="number">10</span>, <span class="number">4</span>);    <span class="comment">// 使用cdecl调用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result using cdecl: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">SubtractCDecl</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装">封装</h3><p>有的第三方库无可奈何地使用了<code>__stdcall</code>，而我们的项目使用的是<code>__cdecl</code>，这时候就需要对第三方库进行封装，以便能够正常调用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设第三方库提供的接口声明为以下形式（使用 __stdcall 调用约定）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> __stdcall <span class="title">ThirdPartyFunction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdPartyWrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CallFunction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ThirdPartyFunction</span>(a, b);    <span class="comment">// 调用第三方库函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = ThirdPartyWrapper::<span class="built_in">CallFunction</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result using third-party wrapper: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Windows函数调用约定">Windows函数调用约定</h3><blockquote><p>以<a href="https://learn.microsoft.com/zh-cn/cpp/build/x64-calling-convention?view=msvc-170">MSVC x64调用约定</a>为例</p></blockquote><p>x64 ABI使用四寄存器fast-call调用约定，在函数调用时将函数的参数存储在指定的寄存器中，参数和这些寄存器有着严格的对应关系。</p><ul><li>一个参数最多只能放在一个寄存器中</li><li>若一个参数的大小不是1、2、4、8字节，将会按引用传递</li></ul><blockquote><p>寄存器中整数右对齐，被调用方可以忽略寄存器中的高位数据，于是可以向下兼容（即1、2、4、8可以放进8字节的寄存器中）<br>为什么是8字节呢？因为8字节=64位，x64系统的寄存器大小为64位</p></blockquote><ul><li>整数参数使用RCX、RDX、R8、R9寄存器传递</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func1</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e, <span class="type">int</span> f);</span><br><span class="line"><span class="comment">// a in RCX, b in RDX, c in R8, d in R9, f then e pushed on stack</span></span><br></pre></td></tr></table></figure><ul><li>浮点参数使用XMM0-XMM3寄存器传递</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func2</span>(<span class="type">float</span> a, <span class="type">double</span> b, <span class="type">float</span> c, <span class="type">double</span> d, <span class="type">float</span> e, <span class="type">float</span> f);</span><br><span class="line"><span class="comment">// a in XMM0, b in XMM1, c in XMM2, d in XMM3, f then e pushed on stack</span></span><br></pre></td></tr></table></figure><p>整数和浮点数混合</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func3</span>(<span class="type">int</span> a, <span class="type">double</span> b, <span class="type">int</span> c, <span class="type">float</span> d, <span class="type">int</span> e, <span class="type">float</span> f);</span><br><span class="line"><span class="comment">// a in RCX, b in XMM1, c in R8, d in XMM3, f then e pushed on stack</span></span><br></pre></td></tr></table></figure><img src="/images/函数参数传递寄存器.png" class="lazyload" data-srcset="/images/函数参数传递寄存器.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="triangle" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文明6like</title>
      <link href="/game/%E6%96%87%E6%98%8E6like/"/>
      <url>/game/%E6%96%87%E6%98%8E6like/</url>
      
        <content type="html"><![CDATA[<h1>文明6like</h1><h2 id="4X游戏">4X游戏</h2><p>文明6是一个经典的历史类4x游戏</p><ul><li>e<strong>x</strong>plore（探索）</li><li>e<strong>x</strong>pand（扩张）</li><li>e<strong>x</strong>ploit（开发）</li><li>e<strong>x</strong>terminate（消灭）</li></ul><h2 id="文明6的体验">文明6的体验</h2><h3 id="游戏体验">游戏体验</h3><p>最近玩了几百小时的文明六，感觉意犹未尽，却又索然无味，想抽掉一些内容，自己做一个简易版的文明6，个人希望加强塔防、改良、贸易等元素，减少兵种操作、城市铺设。</p><p>我玩文明6，最让人兴奋的就是地块高额的产出（尤其是保护区单元格，太美丽了），我希望我的游戏也要着重地块产出和自肃</p><p>我玩文明6，最让人气愤的是AI起城墙，文明6的城墙等级几乎没用（历史上的城墙在不同时期有不同形态和意义），而城墙强度又过高（对远程和骑兵过于不友好），而且兵种和城墙间没有很好的联动，最近看了一些长城和棱堡的视频，感觉这谐内容很有意思</p><p>不过如果要做兵种和城墙这种微操，城市的数量不能太多，我打算将视角转化到城市，你拥有一个首都和少量卫星城市，从刀耕火种的营地，最后到世界级的城市</p><h3 id="感受文化">感受文化</h3><blockquote><p>参考<a href="https://www.bilibili.com/video/BV1Yr4y1G788/?spm_id_from=333.788&amp;vd_source=7cf90c391cc9c5398532df5ea93ccded">棱堡为什么消失</a>、</p></blockquote><p>文明6有一个目的是让玩家体验各个文明的特色和历史进程。通过玩文明6，我知道了蒙古除了擅长骑射外，还拥有一支庞大的重骑兵“怯薛歹”；我知道了长城除了据马、传信等功能外，还能掌控海关，在互市中实现剪刀差；我知道了马镫的出现使得骑兵成为战场上的大杀器，铁才是重骑兵生产需要的战略资源；我知道了火枪时代曾经有着排队枪毙的线列步兵，这个兵种让战争彻底平民化、综合国力化；诸如此类，数不胜数</p><p>我想让玩家体验的，其实是城墙的发展史</p><ol><li>远古城墙，是低矮的土墙，这些墙可以被人轻易翻过，但是无法让马越过，于是实现了拒马的作用</li><li>古典时期城墙变高，城墙上设有射击点，以增大攻城成本<ol><li>尤其是长城这类城墙，在军事上可以限制骑兵，可以逼迫攻城方带大型器械（对于游牧民族是很困难的），可以给中央反应时间，可以限制敌人行军路径（一般从哪里破城，劫掠后就从哪里出去，毕竟劫掠时不可能带着攻城器械），可以作为高速公路实现运兵（不用爬山了）；在经济上可以避免游牧劫掠，互市实现剪刀差，</li></ol></li><li>奥斯曼帝国时期，火药开始用于攻城，大炮对城墙的破坏力大大提高，此时（中世纪）城墙开始变矮变厚，此时城墙的拐角处往往会呈圆形突出，各个突出可以实现互相掩护，以降低射击死角</li></ol><p><img src="/images/%E4%B8%AD%E4%B8%96%E7%BA%AA%E5%9F%8E%E5%A2%99.png" class="lazyload" data-srcset="/images/%E4%B8%AD%E4%B8%96%E7%BA%AA%E5%9F%8E%E5%A2%99.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="中世纪城墙"></p><ol start="4"><li>文艺复兴时期，弹道学被发明，为了减少守军的射击死角，射击坡和棱堡出现了，拥有更大的控制区和更小的射击死角（但棱堡有些贵了）</li></ol><p><img src="/images/%E6%A3%B1%E5%A0%A1.png" class="lazyload" data-srcset="/images/%E6%A3%B1%E5%A0%A1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="棱堡"></p><p><img src="/images/%E6%A3%B1%E5%A0%A12.png" class="lazyload" data-srcset="/images/%E6%A3%B1%E5%A0%A12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="棱堡2"></p><ol start="6"><li>拿破仑时期发现城墙完全没有意义，因为法军会绕开坚城，直取首都，然后围点打援，于是在一战前，往往城市外面的山坡上设立一个个小的孤立要塞，敌人在攻城时这些要塞的大炮可以提供火力掩护，敌人在移动时也可以进行敌人探测和阻击，而且更<strong>便宜</strong></li></ol><p><img src="/images/%E8%A6%81%E5%A1%9E.png" class="lazyload" data-srcset="/images/%E8%A6%81%E5%A1%9E.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="要塞"></p><ol start="7"><li>南北战争时期，多边形城堡出现，除了射击坡外，一大特点是有地下隐藏火力点，敌人攻城时，除了受到正面的射击外，还会收到背后两侧的射击</li></ol><p><img src="/images/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A6%81%E5%A1%9E.png" class="lazyload" data-srcset="/images/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A6%81%E5%A1%9E.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="多边形要塞"></p><h2 id="我的游戏初设">我的游戏初设</h2><h3 id="游戏背景">游戏背景</h3><blockquote><p>有些类似动漫《异世界悠闲农家》</p></blockquote><p>玩家是从异世界穿越而来的勇者，能力是<strong>建造者</strong>。玩家出生在森林/雪山/海岛，这里离人类社会很远，充满了强大的魔物，主角的人物就是在出生点附近生活，建立城市，吸纳难民，开辟和其他友好部落的商路，抵御魔物的一轮轮进攻</p><h3 id="游戏目标">游戏目标</h3><p>军事胜利：击败魔王（魔王会在最后一轮进攻时出现，只要抵御所有伦次的进攻即可，不过也可以在探明魔王城后主动进攻）</p><h2 id="经济">经济</h2><h3 id="地块">地块</h3><p>游戏采用类似文明6的俯视角六边形地图，地块上绘制有地形和产出，每回合会产出对应数值</p><p>地块的产出有：</p><ul><li>粮食：1人口需要消耗1粮食，当粮食有剩余时，人口会缓慢增长</li><li></li></ul><h3 id="人口">人口</h3><p>游戏中的人口是纯概念，没有操作实体，可以锁在某个地块上</p><h2 id="科技">科技</h2><h2 id="军事">军事</h2><p>游戏中的军事单位有操作实体，类似于战旗游戏</p><p>军事单位有攻击力、生命值、移动力、等级经验等属性，攻击会消耗大量移动力，通常大部分单位一回合只能攻击一次</p><h3 id="兵种设置">兵种设置</h3><ul><li>剑士，近战单位，标准攻击力，标准移动力，兵种<strong>相邻会加力</strong></li><li>侦察兵，近战单位，拥有<strong>地图绘制能力</strong>，攻击力较弱，移动力较强，除非与敌人相邻，不然只能被其他侦察兵发现（类似于文明6中的潜艇）</li><li>弓箭手，远程单位，拥有攻击<strong>控制区</strong>，在控制区内的敌人会被减力减移动力，可以上城墙，攻击距离受地形影响</li><li>法师，远程攻城单位，拥有更强的攻击力，但<strong>无法移动攻击</strong>，能对城墙造成满额伤害</li><li>牧师，参考火焰纹章的治疗，消耗道具为一个单位<strong>回复生命值</strong></li><li>骑士，高移动力的近战单位，与敌人剑士相邻时，会<strong>消除敌人相邻加力</strong>（冲散队形）</li><li>天使，参考火焰纹章的天马，高移动力<strong>无视地形</strong>的单位，拥有地图绘制功能，并拥有更大的攻击范围（攻击方式类似于文明6的轰炸机），若攻击目标处于地方弓箭手的控制区内，会受伤。具有抗魔性。价格更高</li></ul><h4 id="控制区">控制区</h4><blockquote><p>目前是引入火力压制和火力支援的概念</p></blockquote><p>弓箭手周围区块会处于己方的控制区，使用计数法判定。每个我方弓箭手都会使得控制区内区块计数+1，每个敌方弓箭手会使计数-1</p><ul><li>若计数为负数，则处于敌方区域，我方减力、减移动力</li><li>若为正数，则处于我方区域，敌方减力、减移动力</li><li>若为0，则双方无影响</li></ul><h4 id="视野">视野</h4><blockquote><p>目的是让玩家使用侦察兵提前探路，避免陷入当前项羽进沼泽的窘境</p></blockquote><p>起初世界全是战争迷雾，普通单位仅有一格的视野，普通单位不能走进未探索地区（也就是说，把一个普通单位放在迷雾区内，会只有周围一圈的视野，且无论移动力多少，一回合只能走一个，但同时能获得新的视野）</p><blockquote><p>关于这个部分，我认为是结算依据是移动后周围六格是否有未探索的区域，若有，则失去所有移动力，刷新地图</p></blockquote><p>侦察单位的视野等同于移动力</p><h4 id="加力减力">加力减力</h4><h3 id="城防">城防</h3><ul><li>堡垒，城市外的防御塔，仅一格大小，可以驻扎一个单位，无法相邻建造，但可以用城墙相连</li><li>城墙</li><li>地堡，仅能被单侧攻击，却有三个攻击方向的建筑通常攻击方向朝向城市</li></ul>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用记录</title>
      <link href="/program/Git%E5%85%A5%E9%97%A8/"/>
      <url>/program/Git%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>Git 使用记录</h1><blockquote><p>记录一下平时使用Git的记录</p></blockquote><h3 id="为什么使用Git">为什么使用Git</h3><p>程序开发的第一步，就是做版本管理。频繁提交，可以便于环境恢复和Bug查找。分支开发，也能便于合作与多设备协同。配置Review规范，你还可以知道你的合作者在干什么，有效避免了因为开发者习惯能力差异导致的项目丑陋。配合CI的编译预检查，还能提高代码的稳健性。总之版本管理十分重要。</p><p>版本管理工具有很多，游戏开发由于拥有大量会频繁改动的二进制资源，于是常常使用SVN等工具，比如P4V。而引擎开发一般以代码为主，用Git管理，其中二进制文件（比如第三方库的超大号DLL）使用Git LFS管理</p><h3 id="Cherry-pick">Cherry pick</h3><p>常用于获取他人其他分支的某些改动，相较于Rebase，对于本地代码的破坏性更小，会保留commit信息</p><p>Cherry pick，摘樱桃，功能是将某个commit复制到当前分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Cherry pick 哈希值为8e8b...的commit</span></span><br><span class="line">git cherry-pick 8e8bd4a89063535cb91de56a57e3a1683927a3b1</span><br><span class="line"><span class="comment"># Cherry pick 哈希值从8e8b...到e652...的一系列连续的commit</span></span><br><span class="line">git cherry-pick e65275b5b2b71153ff08e865cd825e27b5d247b5^..8e8bd4a89063535cb91de56a57e3a1683927a3b1</span><br></pre></td></tr></table></figure><h3 id="设置别名">设置别名</h3><p>有时很多很常用的命令你感觉太长了，于是可以使用别名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置commit别名c，git c将等同于git commit</span></span><br><span class="line">git config --global alias.c commit</span><br><span class="line"><span class="comment"># 设置status别名s</span></span><br><span class="line">git config --global alias.s status</span><br></pre></td></tr></table></figure><h3 id="补丁">补丁</h3><p>常用于获取他人其他分支的某些改动，但并不会保存commit信息，你需要手动add、commit</p><h4 id="diff">diff</h4><p>差异，用于生成补丁文件（patch），补丁文件本身是个纯文本文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较branch1和2的最新提交间的差异，将差异保存在mypatch.patch文件中</span></span><br><span class="line">git diff branch1 branch2 &gt; mypatch.patch</span><br></pre></td></tr></table></figure><h4 id="apply">apply</h4><p>应用，用于应用补丁文件（patch），若出现冲突，会生成拒绝（reject）文件，你可以手动处理掉这些reject文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git apply xxx.ptach --reject</span><br></pre></td></tr></table></figure><h3 id="清理">清理</h3><p>手动进行垃圾回收，以释放本地存储空间</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git prune</span><br></pre></td></tr></table></figure><h3 id="网络443">网络443</h3><p>有的时候我们挂了梯子仍然连不上github服务器，报错</p><blockquote><p>fatal: unable to access ‘<a href="https://github.com/Reuben-Sun/ToolEngine.git/">https://github.com/Reuben-Sun/ToolEngine.git/</a>’: Failed to connect to <a href="http://github.com">github.com</a> port 443 after 21070 ms: Couldn’t connect to server</p></blockquote><p>此时我们可以先查看自己梯子的端口号，然后找到<code>.gitconfig</code>文件，添加代理设置（我这里以端口号为7890为例）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">user</span>]</span><br><span class="line"><span class="string">email</span> <span class="string">=</span> <span class="string">xxx@xxx.com</span></span><br><span class="line"><span class="string">name</span> <span class="string">=</span> <span class="string">xxx</span></span><br><span class="line">[<span class="string">http</span>]</span><br><span class="line"><span class="string">proxy</span> <span class="string">=</span> <span class="string">http://127.0.0.1:7890</span></span><br><span class="line">[<span class="string">https</span>]</span><br><span class="line"><span class="string">proxy</span> <span class="string">=</span> <span class="string">http://127.0.0.1:7890</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity ECS 入门</title>
      <link href="/engine/UnityECS/"/>
      <url>/engine/UnityECS/</url>
      
        <content type="html"><![CDATA[<h1>Unity ECS 入门</h1><p>曾经待的项目使用了Unity ECS 0.5，那时候功能很不完善，几乎所有功能都从头写了一遍。现在Unity ECS 1.0发布了，有点失望。看了一圈感觉系统复杂性提高了很多，而且不能保证系统的稳定性（尤其是有错的代码编译），非常不适合独立游戏制作</p><h2 id="数据驱动">数据驱动</h2><blockquote><p>ECS的本质就是数据驱动的编程，随着守望先锋的爆火进入大家视野，结果现在守望2都凉了，Unity才把ECS端上来。。。</p></blockquote><h3 id="缓存友好">缓存友好</h3><blockquote><p><a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html">每一个程序员都应该知道的数字</a></p></blockquote><p>截至2020年，电脑访问数据的速度为</p><ul><li>L1缓存：1ns</li><li>分支预测错误：3ns</li><li>L2缓存：4ns</li><li>解/锁互斥锁：17ns</li><li>内存：100ns</li><li>固态硬盘随机读取：16,000ns</li><li>固态硬盘顺序读取1,000,000bytes：49,000ns</li><li>机械硬盘顺序读取1,000,000bytes：825,000ns</li></ul><img src="/images/程序员需要知道的数据.png" class="lazyload" data-srcset="/images/程序员需要知道的数据.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SSR噪点" style="zoom:50%;" /><p>我们发现缓存的访问速度远快于内存和硬盘，缓存友好的程序性能会更好</p><h4 id="OOP与DOP">OOP与DOP</h4><p>对于OOP（Object-Oriented Programming）来说，我们可能每次仅迭代对象的某一项属性，其他属性白白加载了，造成性能的浪费和缓存的不友好</p><p>而DOP（Data-Oriented Programming）的实体由多个纯数据组成，系统运行时收集并处理所需的数据，这些数据大多为密集的同质数据，缓存友好</p><h4 id="SOA">SOA</h4><blockquote><p>SOA不同于Unity ECS，放在这里用来抛砖引玉，便于理解数据驱动</p></blockquote><p>数据驱动有很多实现方式，比如SOA（Struct of Array），将原本同质的数据合并为数组。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AOS(Array of Struct)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Particle</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3 position;</span><br><span class="line">    Vector3 velocity;</span><br><span class="line">    Color color;</span><br><span class="line">    <span class="type">float</span> age;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; m_particles[N];</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SOA(Struct of Array)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Particles</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3 position[N];</span><br><span class="line">    Vector3 velocity[N];</span><br><span class="line">    Color color[N];</span><br><span class="line">    <span class="type">float</span> age[N];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; m_particles;</span><br></pre></td></tr></table></figure><ul><li>这种实现不需要为了对齐做padding即可完美对齐，能节省内存</li><li>可以使用SIMD（单指令多数据）加速读写</li></ul><blockquote><p>缓存对齐可以去看<a href="https://reubensun.com/math/Pro-TBB/?keyword=padding">TBB Padding</a>，可以使得两个相邻的数据位置更远，从而不出现在一个缓存行中，进而避免了<strong>假共享</strong>现象</p></blockquote><h3 id="易拓展">易拓展</h3><p>相较于面向对象，数据驱动更易拓展</p><h4 id="OOP的方案">OOP的方案</h4><p>对于面向对象的数据结构，如果要拓展一个新的字段，如果直接将数据放在类里面（不管这个字段会不会被用到），会增大对象大小，浪费内存，缓存不友好，最后导致系统越来越抗拒新的拓展</p><p>如果使用union，确实可以实现不同成员共享空间，省去了那些没有被用到的数据的大小。但需要我们预先决定哪些数据不会被同时使用，大幅提高了编程难度和出错率</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> dataType;   <span class="comment">// 用于标识数据类型</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> intValue;</span><br><span class="line">        <span class="type">float</span> floatValue;</span><br><span class="line">        <span class="type">char</span> stringValue[<span class="number">10</span>];</span><br><span class="line">    &#125; dataValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果使用哈希表，确实得到了弹性，但会产生成员进map的消耗</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    unordered_map&lt;Key, Variant&gt; kv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="SOA-Flexible-Table">SOA Flexible Table</h4><blockquote><p>个人感觉本质就是哈希表，使用起来很像处理JSON和XML</p></blockquote><p>运行时为table添加项，添加项时提供项的定义信息、初始值</p><p><img src="/images/FlexibleTable.png" class="lazyload" data-srcset="/images/FlexibleTable.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Flexible Table"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MetaTable meta;</span><br><span class="line"><span class="type">const</span> TypeID floatType = meta.<span class="built_in">AddType</span>(<span class="string">&quot;float&quot;</span>, <span class="number">4</span>, <span class="number">16</span>);</span><br><span class="line"><span class="type">const</span> AttributeID positionXAttribute = meta.<span class="built_in">AddAttribute</span>(<span class="string">&quot;positionX&quot;</span>, floatType, <span class="number">0.0f</span>);</span><br><span class="line"><span class="type">const</span> AttributeID positionYAttribute = meta.<span class="built_in">AddAttribute</span>(<span class="string">&quot;positionY&quot;</span>, floatType, <span class="number">0.0f</span>);</span><br><span class="line"><span class="type">const</span> AttributeID positionZAttribute = meta.<span class="built_in">AddAttribute</span>(<span class="string">&quot;positionZ&quot;</span>, floatType, <span class="number">0.0f</span>);</span><br><span class="line"><span class="type">const</span> AttributeID velocityXAttribute = meta.<span class="built_in">AddAttribute</span>(<span class="string">&quot;velocityX&quot;</span>, floatType, <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function">SOATable <span class="title">particles</span><span class="params">(meta)</span></span>;</span><br><span class="line">particles.<span class="built_in">ReserveRows</span>(N);</span><br><span class="line">particles.<span class="built_in">AppendRows</span>(N);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">&#123;</span><br><span class="line">    particles.<span class="built_in">SetValue</span>(i, positionXAttribute, ...);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GO与ECS">GO与ECS</h3><p>Unity的GO和ECS是对OOP和DOP的具体实现</p><p>传统的GO+Mono模式：场景中有大量的GO，他们拥有各自的脚本和组件，运行时遍历GO，按生命周期执行Mono脚本（一定是所有<code>OnEnable()</code>执行完后，再执行所有的<code>Start()</code>）</p><p>ECS模式，场景由Entity和System组成，这些Entity拥有纯数据的Component，而System负责收集其负责的Component，集中处理</p><p>能看出，ECS模式是数据密集型的，同类的数据集中存储，集中处理。而GO是一个相对完整独立的个体，每个GO都会处理自己的数据。</p><p>ECS缓存友好，适用于单指令多数据、并行、上下文切换等机制，于是在逻辑处理上会比GO强很多</p><h2 id="初始化">初始化</h2><h3 id="安装">安装</h3><p>之前0.5的时候，Unity ECS就一直藏在掖着，仿佛不肯用户发现安装一般，现在正式发售了，也没有放进包管理器里</p><ol><li>打开包管理器，点击按名字添加包</li><li>依次添加<code>com.unity.entities</code>和<code>com.unity.entities.graphics</code></li></ol><p><img src="/images/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.png" class="lazyload" data-srcset="/images/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="包管理器"></p><h3 id="打开快速Play">打开快速Play</h3><blockquote><p>真的很快</p></blockquote><p><img src="/images/%E8%BF%9B%E5%85%A5%E5%9C%BA%E6%99%AF%E8%AE%BE%E7%BD%AE.png" class="lazyload" data-srcset="/images/%E8%BF%9B%E5%85%A5%E5%9C%BA%E6%99%AF%E8%AE%BE%E7%BD%AE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="进入场景设置"></p><h3 id="打开Scene预览">打开Scene预览</h3><p>不开启这个，你运行时创建的Entity无法在Scene窗口查看</p><p><img src="/images/SceneView.png" class="lazyload" data-srcset="/images/SceneView.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SceneView"></p><h3 id="Rider">Rider</h3><blockquote><p>个人建议配合Rider2023的新UI使用啊，效率能大幅提高，而且还有DOTS类型模板</p></blockquote><img src="/images/RiderECS.png" class="lazyload" data-srcset="/images/RiderECS.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RiderECS" style="zoom:50%;" /><img src="/images/RiderECS2.png" class="lazyload" data-srcset="/images/RiderECS2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RiderECS2" style="zoom:50%;" /><p>不过一定要关闭自动保存，不然一切屏就报错</p><p><img src="/images/%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98.png" class="lazyload" data-srcset="/images/%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="关闭自动保存"></p><h2 id="入门">入门</h2><h3 id="SubScene">SubScene</h3><blockquote><p>这个SubScene很久以前就有，但以前我们可以通过主动加载Prefab的方式实现流式加载，于是很少用这个SubScene，但现在好像把Prefab转Entity这个工作流取消了？</p></blockquote><p>在Hierarchy节目按右键New Sub Scene即可创建，你可以像操作GO一样在SubScene中添加物体，会自动转化为Entity</p><p><img src="/images/SubScene.png" class="lazyload" data-srcset="/images/SubScene.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SubScene"></p><p>SubScene右侧有一个Checkbox，这个是用来加载/卸载场景的，SubScene最初的用法就是用来流式加载的</p><h3 id="Entity">Entity</h3><blockquote><p>这属实优化了不少</p></blockquote><p>现在Entity的制作流程极其简答，按GO的方式制作，然后会自动转化为Entity，为了方便你编辑，还提供了两套窗口，通过按右上角的圆圈，即可调整窗口</p><p>传统的GO界面（Authoring）</p><img src="/images/GO界面.png" class="lazyload" data-srcset="/images/GO界面.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GO界面" style="zoom:50%;" /><p>Entity界面（Runtime）</p><img src="/images/Entity界面.png" class="lazyload" data-srcset="/images/Entity界面.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Entity界面" style="zoom:50%;" /><h3 id="Component">Component</h3><blockquote><p>还是一如既往的脱裤子放屁，突出一个意义不明</p></blockquote><h4 id="IComponentData">IComponentData</h4><p>纯数据结构体</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> CubeProperties: IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector2 FieldSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CubeCount;</span><br><span class="line">    <span class="keyword">public</span> Entity CubePrefab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> CubeRandom : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Random Value;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MonoBehaviour">MonoBehaviour</h4><p><code>IComponentData</code>的数据无法在Editor面板上显示（why？），需要使用Mono封装传递（what？）</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeMono</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector2 FieldSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CubeCount;</span><br><span class="line">    <span class="keyword">public</span> GameObject CubePrefab;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">uint</span> RandomSeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeBaker</span> : <span class="title">Baker</span>&lt;<span class="title">CubeMono</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bake</span>(<span class="params">CubeMono authoring</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 为当前Entity添加Component，可以添加多个</span></span><br><span class="line">        AddComponent(<span class="keyword">new</span> CubeProperties</span><br><span class="line">        &#123;</span><br><span class="line">            FieldSize = authoring.FieldSize,</span><br><span class="line">            CubeCount = authoring.CubeCount,   </span><br><span class="line">            CubePrefab = GetEntity(authoring.CubePrefab)<span class="comment">// 这里做了Prefab转Entity</span></span><br><span class="line">        &#125;);</span><br><span class="line">        AddComponent(<span class="keyword">new</span> CubeRandom</span><br><span class="line">        &#123;</span><br><span class="line">            Value = Random.CreateFromIndex(authoring.RandomSeed)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将Mono脚本挂在Entity上，切换为Runtime界面，就能看到Component信息了</p><p><img src="/images/CubeProp.png" class="lazyload" data-srcset="/images/CubeProp.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CubeProp"></p><h3 id="Aspect">Aspect</h3><p>这次ECS还新增了一个<code>IAspect</code>，看上去好像是负责收集Component数据的转换层，可以将多个Component的数据结合在一起，方便System调用</p><blockquote><p>An aspect is an object-like wrapper that you can use to group together a subset of an entity’s components into a single C# struct</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ECS.Study</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">partial</span> <span class="keyword">struct</span> CubeAspect : IAspect</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">readonly</span> Entity Entity;</span><br><span class="line"><span class="comment">// TransformAspect 已经被取消</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> RefRW&lt;LocalTransform&gt; _localTransform; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> RefRO&lt;CubeProperties&gt; _cubeProperties;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> RefRW&lt;CubeRandom&gt; _cubeRandom;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> RefRW&lt;SphereSpawnPoints&gt; _sphereSpawnPoints;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> CubeCount =&gt; _cubeProperties.ValueRO.CubeCount;</span><br><span class="line">        <span class="keyword">public</span> Entity CubePrefab =&gt; _cubeProperties.ValueRO.CubePrefab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中心创建一个球，球内将不会创建Cube</span></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> SphereCreate</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SphereSpawnPointsIsCreated</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _sphereSpawnPoints.ValueRO.Value.IsCreated &amp;&amp; SphereSpawnPointsCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> SphereSpawnPointsCount =&gt; _sphereSpawnPoints.ValueRO.Value.Value.Value.Length;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 生成Cube的位置和朝向</span></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> Transform</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LocalTransform <span class="title">GetRandomCubeTransform</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LocalTransform</span><br><span class="line">            &#123;</span><br><span class="line">                Position = GetRandomPosition(),</span><br><span class="line">                Rotation = GetRandomRotation(),</span><br><span class="line">                Scale = GetRandomScale(<span class="number">0.5f</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> float3 <span class="title">GetRandomPosition</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            float3 randomPosition;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                randomPosition = _cubeRandom.ValueRW.Value.NextFloat3(MinCorner, MaxCorner);</span><br><span class="line">            &#125; <span class="keyword">while</span> (math.distancesq(_localTransform.ValueRO.Position, randomPosition) &lt;= CUBE_SAFETY_RADIUS_SQ);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> randomPosition;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> float3 HalfDimension =&gt; <span class="keyword">new</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            x = _cubeProperties.ValueRO.FieldSize.x * <span class="number">0.5f</span>,</span><br><span class="line">            y = <span class="number">0f</span>,</span><br><span class="line">            z = _cubeProperties.ValueRO.FieldSize.y * <span class="number">0.5f</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> float3 MinCorner =&gt; _localTransform.ValueRO.Position - HalfDimension;</span><br><span class="line">        <span class="keyword">private</span> float3 MaxCorner =&gt; _localTransform.ValueRO.Position + HalfDimension;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">float</span> CUBE_SAFETY_RADIUS_SQ = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> quaternion <span class="title">GetRandomRotation</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> quaternion.RotateY(_cubeRandom.ValueRW.Value.NextFloat(<span class="number">-0.25f</span>, <span class="number">0.25f</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="built_in">float</span> <span class="title">GetRandomScale</span>(<span class="params"><span class="built_in">float</span> min</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _cubeRandom.ValueRW.Value.NextFloat(min, <span class="number">1f</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> float2 <span class="title">GetRandomOffset</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _cubeRandom.ValueRW.Value.NextFloat2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Aspect.png" class="lazyload" data-srcset="/images/Aspect.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Aspect"></p><h3 id="System">System</h3><blockquote><p>要说System最大的改动，我感觉就是这东西好建不好删，这东西只要你写了，也不需要挂载，就会直接全局生效，我开着Editor删文件会报DLL被占用，也不好修改，没写好编译就会报错，然后Rider呼吁我Revert掉</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置初始化顺序，能在System界面看到</span></span><br><span class="line">[<span class="meta">UpdateInGroup(typeof(InitializationSystemGroup))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">struct</span> CubeGenerateSystem : ISystem</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCreate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 当场景中包含至少一个 CubeProperties 组件时，启用 Update</span></span><br><span class="line">        state.RequireForUpdate&lt;CubeProperties&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">state.Enabled = <span class="literal">false</span>;  <span class="comment">// 禁用 Update</span></span><br><span class="line">        <span class="keyword">var</span> cubeEntity = SystemAPI.GetSingletonEntity&lt;CubeProperties&gt;();</span><br><span class="line">        <span class="keyword">var</span> cube = SystemAPI.GetAspect&lt;CubeAspect&gt;(cubeEntity);</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> BlobBuilder(Allocator.Temp);</span><br><span class="line">        <span class="keyword">ref</span> <span class="keyword">var</span> spawnPoints = <span class="keyword">ref</span> builder.ConstructRoot&lt;SphereSpawnPointsBlob&gt;();</span><br><span class="line">        <span class="keyword">var</span> arrayBuilder = builder.Allocate(<span class="keyword">ref</span> spawnPoints.Value, cube.CubeCount);</span><br><span class="line">        <span class="keyword">var</span> spawnOffset = <span class="keyword">new</span> float3(<span class="number">0f</span>, <span class="number">-2f</span>, <span class="number">1f</span>);</span><br><span class="line">        <span class="comment">// 创建命令缓冲区</span></span><br><span class="line">        <span class="keyword">var</span> cmd = <span class="keyword">new</span> EntityCommandBuffer(Allocator.Temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cube.CubeCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将命令添加至命令缓冲区</span></span><br><span class="line">            <span class="keyword">var</span> newCube = cmd.Instantiate(cube.CubePrefab);</span><br><span class="line">            <span class="keyword">var</span> newTransform = cube.GetRandomCubeTransform();</span><br><span class="line">            cmd.SetComponent(newCube, newTransform);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> newSpawnPoint = newTransform.Position + spawnOffset;</span><br><span class="line">            arrayBuilder[i] = newSpawnPoint;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> blobAsset = builder.CreateBlobAssetReference&lt;SphereSpawnPointsBlob&gt;(Allocator.Persistent);</span><br><span class="line">        cmd.SetComponent(cubeEntity, <span class="keyword">new</span> SphereSpawnPoints&#123; Value = blobAsset &#125;);</span><br><span class="line">        builder.Dispose();</span><br><span class="line"></span><br><span class="line">        cmd.Playback(state.EntityManager);    <span class="comment">// 执行命令 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SphereSpawnPoints : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> BlobAssetReference&lt;SphereSpawnPointsBlob&gt; Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SphereSpawnPointsBlob</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> BlobArray&lt;float3&gt; Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/System.png" class="lazyload" data-srcset="/images/System.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="System"></p><p>此时启动游戏，会发现生成了一百个Cube，他们分布在一个正方形内部圆外部，转向随机</p><p><img src="/images/ECS-Scene2.png" class="lazyload" data-srcset="/images/ECS-Scene2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ECS-Scene2"></p><h3 id="Job">Job</h3><blockquote><p>用起来很像一个函数对象</p></blockquote><p>Job是从System发出的任务</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">struct</span> DoSomeJob: IJobEntity</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这两个public的成员用来传递参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> DeltaTime;</span><br><span class="line">    <span class="keyword">public</span> EntityCommandBuffer ECS;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">CubeAspect cubeAspect</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>System通过创建对象来调用这个任务</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> deltaTime = SystemAPI.Time.DeltaTime;</span><br><span class="line">    <span class="keyword">var</span> ecbSingleton = SystemAPI.GetSingleton&lt;BeginInitializationEntityCommandBufferSystem.Singleton&gt;();</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">new</span> DoSomeJob</span><br><span class="line">    &#123;</span><br><span class="line">        DeltaTime = deltaTime,</span><br><span class="line">        ECB = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged)</span><br><span class="line">    &#125;.Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SystemBase">SystemBase</h3><p>系统交互相关的系统</p><p>下面是一个相机盯着中心看，并做旋转的示例</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">CameraControllerSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> cameraSigleton = CameraSingleton.Instance;</span><br><span class="line">        <span class="keyword">if</span>(cameraSigleton == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">float</span> positionFactor =(<span class="built_in">float</span>) SystemAPI.Time.ElapsedTime * cameraSigleton.Speed;</span><br><span class="line">        <span class="built_in">float</span> scale = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> radius = cameraSigleton.RadiusAtScale(scale);</span><br><span class="line">        <span class="keyword">var</span> height = cameraSigleton.HeightAtScale(scale);</span><br><span class="line">        cameraSigleton.transform.position = <span class="keyword">new</span> UnityEngine.Vector3</span><br><span class="line">        &#123;</span><br><span class="line">            x = Mathf.Cos(positionFactor) * radius,</span><br><span class="line">            y = height,</span><br><span class="line">            z = Mathf.Sin(positionFactor) * radius</span><br><span class="line">        &#125;;</span><br><span class="line">        cameraSigleton.transform.LookAt(Vector3.zero, Vector3.up);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个代码要挂在场景中（建议挂在相机上）</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraSingleton</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CameraSingleton Instance &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Instance != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> startRadius;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> endRadius;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> startHeight;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> endHeight;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">RadiusAtScale</span>(<span class="params"><span class="built_in">float</span> scale</span>)</span> =&gt; Mathf.Lerp(startRadius, endRadius, <span class="number">1</span> - scale);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">HeightAtScale</span>(<span class="params"><span class="built_in">float</span> scale</span>)</span> =&gt; Mathf.Lerp(startHeight, endHeight, <span class="number">1</span> - scale);</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Speed =&gt; speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锐评">锐评</h2><p>就这个简单的小demo，我的编辑器就卡死崩溃了多次，尤其是当我保存编译一个有报错的System文件时，几乎必然要用任务管理器杀项目，太不稳定了</p><p>而且这个ECS不仅跟Mono差异巨大，还和0.5版本的ECS差异也巨大，所有人都对这个系统不熟，官方也没提供一些特别好的适普的教程</p><p>如果是用Unity做小项目，完全不需要ECS，你的性能瓶颈大概率是渲染和资产。把粒子特效砍一砍，查看一下场景中有没有面数惊人的模型，模型是否有LOD，是否针对设备做了渲染分级，控制场景中实时光源数量，砍掉一些昂贵而作用不明显的渲染feature（比如基于快速傅里叶的水，比如高精度的布料、破坏仿真）</p><p>此外我诚心建议Unity把重点放在Editor上，实现一套<strong>能用</strong>的地表编辑器、动画编辑器、资产编辑器、大世界分块编辑器。引擎好不好用，关键靠Editor，你就算架构设计的再好，再适合客制化，小公司没精力没技术魔改，大公司不稀罕你的原生功能，甚至很多公司跟你闹掰转UE了，你在大型项目中有半点优势吗？</p><h2 id="参考">参考</h2><p><a href="https://www.youtube.com/watch?v=IO6_6Y_YUdE">https://www.youtube.com/watch?v=IO6_6Y_YUdE</a></p><p><a href="https://www.tmg.dev/tuts/zombieupdate/">https://www.tmg.dev/tuts/zombieupdate/</a></p><p><a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html</a></p><p>《为实现极限性能的面向数据编程范式》叶劲峰 GDC 2005</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> ECS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity小球移动</title>
      <link href="/game/Catlike%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A8/"/>
      <url>/game/Catlike%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1>Unity小球移动</h1><blockquote><p>摘自<a href="https://catlikecoding.com/unity/tutorials/movement/">Catlike的Movement Tutorial</a></p></blockquote><h2 id="小球移动">小球移动</h2><h3 id="创建小球">创建小球</h3><blockquote><p>使用Input System包，在Package Manager中Unity包搜索即可</p></blockquote><p>创建Input Action资产</p><p><img src="/images/inputAction.gif" class="lazyload" data-srcset="/images/inputAction.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="inputAction"></p><p>创建小球，包含拖尾渲染器、Player Input组件、脚本<code>SphereMovement.cs</code></p><p><img src="/images/%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A8.png" class="lazyload" data-srcset="/images/%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="小球移动"></p><h3 id="移动脚本">移动脚本</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SphereMovement</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">FormerlySerializedAs(<span class="string">&quot;movementSpeed&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;Movement Setting&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField, Range(0f, 10f)</span>] <span class="keyword">private</span> <span class="built_in">float</span> maxSpeed = <span class="number">5f</span>;</span><br><span class="line">    [<span class="meta">SerializeField, Range(0f, 100f)</span>] <span class="keyword">private</span> <span class="built_in">float</span> maxAcceleration = <span class="number">10f</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] Rect allowedArea = <span class="keyword">new</span> Rect(<span class="number">-5f</span>, <span class="number">-5f</span>, <span class="number">10f</span>, <span class="number">10f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 Velocity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> PlayerInput _input;</span><br><span class="line">    <span class="keyword">private</span> Vector2 _moveInput;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _input = GetComponent&lt;PlayerInput&gt;();</span><br><span class="line">        Velocity = Vector3.zero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _moveInput = _input.actions[<span class="string">&quot;Move&quot;</span>].ReadValue&lt;Vector2&gt;();</span><br><span class="line">        <span class="comment">// 根据输入得到预期速度</span></span><br><span class="line">        Vector3 desiredVelocity = <span class="keyword">new</span> Vector3(_moveInput.x, <span class="number">0</span>, _moveInput.y) * maxSpeed;</span><br><span class="line">        <span class="comment">// 当前时间片速度的最大变化量</span></span><br><span class="line">        <span class="built_in">float</span> maxSpeedChange = maxAcceleration * Time.deltaTime;</span><br><span class="line">        <span class="comment">// |target - current| &lt;= maxDelta ? target : current + maxDelta</span></span><br><span class="line">        Velocity.x = Mathf.MoveTowards(Velocity.x, desiredVelocity.x, maxSpeedChange);</span><br><span class="line">        Velocity.z = Mathf.MoveTowards(Velocity.z, desiredVelocity.z, maxSpeedChange);</span><br><span class="line">        <span class="comment">// 新速度在当前时间片的位移</span></span><br><span class="line">        Vector3 displacement = Velocity * Time.deltaTime;</span><br><span class="line">        <span class="comment">// 判断新位置是否越界</span></span><br><span class="line">        Vector3 newPosition = transform.localPosition + displacement;</span><br><span class="line">        <span class="keyword">if</span> (newPosition.x &lt; allowedArea.xMin) &#123;</span><br><span class="line">            newPosition.x = allowedArea.xMin;</span><br><span class="line">            Velocity.x = <span class="number">0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newPosition.x &gt; allowedArea.xMax) &#123;</span><br><span class="line">            newPosition.x = allowedArea.xMax;</span><br><span class="line">            Velocity.x = <span class="number">0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newPosition.z &lt; allowedArea.yMin) &#123;</span><br><span class="line">            newPosition.z = allowedArea.yMin;</span><br><span class="line">            Velocity.z = <span class="number">0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newPosition.z &gt; allowedArea.yMax) &#123;</span><br><span class="line">            newPosition.z = allowedArea.yMax;</span><br><span class="line">            Velocity.z = <span class="number">0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改位置</span></span><br><span class="line">        transform.localPosition = newPosition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A81.gif" class="lazyload" data-srcset="/images/%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A81.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="小球移动1"></p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blender使用笔记</title>
      <link href="/dcc/blender%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/dcc/blender%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>Blender使用笔记</h1><h3 id="网格合并">网格合并</h3><p>选中模型，按快捷键<code>ctrl+J</code></p><h3 id="布尔建模">布尔建模</h3><ol><li>创建一个圆柱1，按tab进入编辑模式，选中上表面，按s将上表面进行缩放，变成一个类似“圆锥”的东西</li><li>在圆锥上侧创建一个球，下侧创建一个圆柱2</li><li>使用布尔操作，球布尔Difference，圆柱2布尔Union（注意操作后隐藏球和圆柱）</li></ol><p><img src="/images/%E5%B8%83%E5%B0%94%E5%BB%BA%E6%A8%A12.gif" class="lazyload" data-srcset="/images/%E5%B8%83%E5%B0%94%E5%BB%BA%E6%A8%A12.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="布尔建模2"></p><p>于是得到了枪的建模（相当粗糙）</p><img src="/images/布尔建模.png" class="lazyload" data-srcset="/images/布尔建模.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="布尔建模" style="zoom:50%;" /><h3 id="模型添加材质">模型添加材质</h3><img src="/images/模型材质.png" class="lazyload" data-srcset="/images/模型材质.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="模型材质" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blender </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3dmax使用笔记</title>
      <link href="/dcc/Max%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/dcc/Max%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>3dmax使用笔记</h1><p>3dmax是一个被广泛使用的DCC工具，我之前对这个软件不是很熟悉，于是记录一些平时遇到的常用操作</p><h3 id="材质编辑">材质编辑</h3><p>选中模型，按键盘<code>m</code>，打开材质界面。点击吸管后再点击模型，即可得到该网格所使用的材质列表</p><p><img src="/images/%E6%9D%90%E8%B4%A8%E9%9D%A2%E6%9D%BF.jpg" class="lazyload" data-srcset="/images/%E6%9D%90%E8%B4%A8%E9%9D%A2%E6%9D%BF.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="材质面板"></p><p>点击Modes——Slate Material Editor，即可打开材质连连看</p><p><img src="/images/%E6%9D%90%E8%B4%A8%E8%BF%9E%E8%BF%9E%E7%9C%8B.jpg" class="lazyload" data-srcset="/images/%E6%9D%90%E8%B4%A8%E8%BF%9E%E8%BF%9E%E7%9C%8B.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="材质连连看"></p><h3 id="网格塌缩">网格塌缩</h3><p>我们预览模型动画时，想要导出某一帧的网格，而且希望这个网格位置本身被修改，而非运行时被骨骼驱动，于是需要做塌缩</p><h4 id="选中网格">选中网格</h4><p>在窗口左侧，我们可以看到当前FBX是由哪些东西组成的（比如Mesh、骨骼），如果我们想同时选中所有的Mesh，可以按键盘<code>h</code>，打开快速选中界面，在最上一栏仅选择Mesh（图中蓝色背景的圆球），筛选的就是所有Mesh</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E9%80%89%E4%B8%AD.jpg" class="lazyload" data-srcset="/images/%E5%BF%AB%E9%80%9F%E9%80%89%E4%B8%AD.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="快速选中"></p><h4 id="塌缩">塌缩</h4><p>选中网格后对模型按右键——Convert To：——Convert to Editable Poly，即可完成塌缩</p><p><img src="/images/%E5%A1%8C%E7%BC%A9.jpg" class="lazyload" data-srcset="/images/%E5%A1%8C%E7%BC%A9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="塌缩"></p>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3dmax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模版</title>
      <link href="/program/C++template/"/>
      <url>/program/C++template/</url>
      
        <content type="html"><![CDATA[<h1>C++模版</h1><blockquote><p>《C++ Templates: The Complete Guide》笔记</p></blockquote><h2 id="为什么使用模版">为什么使用模版</h2><p>为了实现泛型</p><p>如果不使用泛型，对于一些通用的函数或容器，比如print、vector，我们可能需要逐个实现他们的函数，尽管这些函数的功能十分类似（可能相同），低效复杂而且难以维护</p><p>在C++标准库中使用了大量模版</p><h2 id="函数模版">函数模版</h2><h3 id="模版定义">模版定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">getMax</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">5</span>, <span class="number">6</span>) &lt;&lt; std::endl;<span class="comment">// 6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">5.1</span>, <span class="number">6.1</span>) &lt;&lt; std::endl;<span class="comment">// 6.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>T</code>是<strong>类型参数</strong>，我们可以使用任意字符，不过习惯上使用<code>T</code></p><p>处于历史原因，我们也可以使用<code>class</code>来代替<code>typename</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">getMax</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模版实例化">模版实例化</h3><p>在编译阶段，模版会被编译为多个独立的实体，比如我们调用<code>getMax(5, 6)</code>，编译器会编译出：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样用具体类型<code>int</code>取代类型参数<code>T</code>的过程叫做<strong>实例化</strong></p><h3 id="两阶段编译检查">两阶段编译检查</h3><p>模版分为两步编译：模版定义阶段、模版实例化阶段</p><p>在模版定义阶段，不会对类型参数做检查，比如你让两个<code>T</code>对象进行大小比较（<code>a &gt; b</code>），编译器不会去质疑<code>T</code>对象是否支持比较操作符</p><p>在模版实例化阶段，模版会再次被检查（尤其是类型参数），如果编译器发现<code>T</code>对象不支持比较操作符，就会报错</p><p>我们发现，当我们在实例化一个模版时，编译器需要看到模版的完整定义，但C++函数采用声明和实现分离的思想，函数在编译阶段只需要声明，这出现了冲突。简单的做法是<strong>将模版的实现写在头文件中</strong></p><h3 id="类型推断">类型推断</h3><p>我们在调用<code>getMax</code>时，会根据传入的参数类型，自动推断出<code>T</code>的类型，但这种推断是有限制的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getMax</span>(<span class="number">4</span>, <span class="number">5</span>);<span class="comment">// OK, T is int</span></span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">4.1</span>, <span class="number">5.1</span>);<span class="comment">// OK, T is double</span></span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">4</span>, <span class="number">5.1</span>);<span class="comment">// Error, 无法正确推断T的类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">2</span>, a);<span class="comment">// OK, T is int, a的const会被decay掉</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> &amp;c = b;</span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">2</span>, c);<span class="comment">// OK, T is int, c的引用会被decay掉</span></span><br></pre></td></tr></table></figure><h4 id="decay">decay</h4><p>退化（decay）是指<strong>数组变指针</strong>，<strong>函数变指针</strong>，<strong>左值变右值</strong>的过程</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="built_in">foo</span>(myArray);<span class="comment">// 等价于foo(&amp;myArray[0])</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码，数组<code>myArray</code>被转化为指向数组第一个元素的指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">void</span> (*ptr)() = foo;</span><br><span class="line">  <span class="built_in">ptr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码，函数<code>foo</code>被转化为函数指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> &amp;c = b;</span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">2</span>, a);<span class="comment">// OK, T is int, a的const会被decay掉</span></span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">2</span>, c);<span class="comment">// OK, T is int, c的引用会被decay掉</span></span><br></pre></td></tr></table></figure><p>在上面这段代码，<code>int&amp;</code>和<code>const int&amp;</code>都被转化为对应的右值</p><p>我们可以使用type_traits库来检测decay的合法性</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">decay_equiv</span>: std::is_same&lt;<span class="keyword">typename</span> std::decay&lt;T&gt;::type, U&gt;::type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; std::boolalpha &lt;&lt; decay_equiv&lt;<span class="type">int</span>&amp;, <span class="type">int</span>&gt;::value &lt;&lt; std::endl;<span class="comment">// true</span></span><br><span class="line">  std::cout &lt;&lt; std::boolalpha &lt;&lt; decay_equiv&lt;<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">int</span>&gt;::value &lt;&lt; std::endl;<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>std::boolalpha的作用是将bool类型以true/false的形式打印出来，而非1/0</p></blockquote><h3 id="多个模板参数">多个模板参数</h3><p>当模板有多个参数时，我们可以用<code>&lt;&gt;</code>指定参数类型</p><p>在后面的类型，如果可以自动推断出来，可以不写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">RT <span class="title">getMax</span><span class="params">(T1 a, T2 b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>) &lt;&lt; std::endl;<span class="comment">// 7</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>) &lt;&lt; std::endl;<span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回类型推断">返回类型推断</h4><blockquote><p>极其推荐这样写</p></blockquote><p>上面的返回值类型是手动指定的，很容易出现编写错误，因此我们一般会让编译器来角色返回值类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getMax</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(a &gt; b ? a : b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">4</span>, <span class="number">7.2</span>) &lt;&lt; std::endl;<span class="comment">// 7.2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">8</span>, <span class="number">7.2</span>) &lt;&lt; std::endl;<span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现这样写的返回类型由<code>?:</code>运算符的执行结果决定，7.2大于4，于是返回类型为<code>double</code>，8大于7.2，于是返回类型为<code>int</code></p><p>进一步的，若传入的数据是引用类型，可以使用类型萃取，不过一般情况下，上面这种写法就够了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getMax2</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="keyword">typename</span> std::decay&lt; <span class="title">decltype</span><span class="params">(a &gt; b ? a : b)</span>&gt;::type</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公共类型">公共类型</h4><p>Common Type</p><p>C++11提供了一种更一般的类型，用于得到两个模板参数的公共类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">common_type_t</span>&lt;T1, T2&gt; <span class="title">getMax3</span><span class="params">(T1 a, T2 b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认参数类型">默认参数类型</h3><p>我们可以给参数指定默认值，但要同时给<code>T</code>一个对应默认参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T </span>= <span class="type">double</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T a = <span class="number">3.14</span>)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">15</span>);<span class="comment">// 15</span></span><br><span class="line">    <span class="built_in">foo</span>();<span class="comment">// 3.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载">重载</h3><p>函数模板可以与同名的普通函数共存，且优先调用普通函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">1</span>);<span class="comment">// int: 1</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">3.14</span>);<span class="comment">// 3.14 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板也可以和其他同名但参数类型数量不同的函数模板共存，但必须保证在调用模板时，<strong>有且仅有一个模板能匹配</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123; <span class="keyword">return</span> b &lt; a ? a : b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span></span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123; <span class="keyword">return</span> b &lt; a ? a : b; &#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><h4 id="使用值传递">使用值传递</h4><p>一般而言，函数参数中，简单类型值传递，复杂的类型引用传递。但在模板编程中，我们更倾向于使用值传递</p><p>值传递的优点：</p><ul><li>语法简单</li><li>编译器能更好地优化</li><li>移动一般比拷贝成本更低</li><li>某些情况没有移动或拷贝</li><li>模板既可以适用于复杂类型，也可以适用于简单类型，盲目使用引用会影响简单类型的使用</li><li>调用者可以主动使用<code>std::ref()</code>和<code>std::cref()</code></li><li>string literal和raw array使用引用传递会出现问题</li></ul><h2 id="类模板">类模板</h2><p>类也可以使用模板，STL中的容器就是这样实现的</p><p>类模版中的模版成员函数，只有在被调用时才会实例化</p><p>类模版的模版参数，要能支持模版函数中使用的各种操作和运算符</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elems.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;elem) &#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    elems.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T <span class="type">const</span>&amp; Stack&lt;T&gt;::<span class="built_in">top</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());     <span class="comment">// 断言语句，若条件不满足，程序会终止，仅在Debug模式生效</span></span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于历史原因，C++11以前的模版，两个相邻尖括号间要有空格，如<code>Stack&lt;Stack&lt;int&gt; &gt;</code>，在C++11之后就不再需要了</p></blockquote><h3 id="静态成员">静态成员</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Foo&lt;T&gt;::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo&lt;<span class="type">int</span>&gt;::count = <span class="number">10</span>;</span><br><span class="line">    Foo&lt;<span class="type">double</span>&gt;::count = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; Foo&lt;<span class="type">int</span>&gt;::count &lt;&lt; std::endl;<span class="comment">// 10</span></span><br><span class="line">    std::cout &lt;&lt; Foo&lt;<span class="type">double</span>&gt;::count &lt;&lt; std::endl;<span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特例化">特例化</h3><p>对于特定的类型，我们可以进行特例化，可以做针对性的优化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;std::string&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>特例化也可以部分特例化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T*&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以多模版参数特例化，可以给予默认模版参数</p><h3 id="类型别名">类型别名</h3><p>类型别名只是为已经存在的类型定义一个别名，并没有创建新类型，可以用<code>typedef</code>或<code>using</code>实现</p><p>typedef-name：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Stack&lt;<span class="type">int</span>&gt; IntStack;</span><br></pre></td></tr></table></figure><p>alias declaration</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> IntStack2 = Stack&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><p>alias declaration也可以被模版化，被称为alias templates</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyStack = Stack&lt;T&gt;;</span><br></pre></td></tr></table></figure><h2 id="非类型模版参数">非类型模版参数</h2><blockquote><p>所谓的非类型模版参数，就是不用typename T作为模版参数</p></blockquote><p>下面是使用<code>array</code>实现<code>Stack</code>的代码，用户可以手动指定栈容量，我们使用了<code>std::size_t</code>作为<strong>非类型模版参数</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, Maxsize&gt; elems;</span><br><span class="line">    std::<span class="type">size_t</span> elemCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elemCount == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elemCount; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line">Stack&lt;T, Maxsize&gt;::<span class="built_in">Stack</span>():  <span class="built_in">elemCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T, Maxsize&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;elem) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(elemCount &lt; Maxsize);</span><br><span class="line">    elems[elemCount] = elem;</span><br><span class="line">    ++elemCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T, Maxsize&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    --elemCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line">T <span class="type">const</span>&amp; Stack&lt;T, Maxsize&gt;::<span class="built_in">top</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems[elemCount<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>, <span class="number">10</span>&gt; st10;</span><br><span class="line">    st10.<span class="built_in">push</span>(<span class="number">15</span>);</span><br><span class="line">    std::cout &lt;&lt; st10.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，<code>Stack&lt;int, 10&gt;</code>和<code>Stack&lt;int, 20&gt;</code>是两种不同的类型，由于没有定义隐式或显示的转换规则，我们不能使用一个取代另一个，也不能把一个赋值给另一个</p><h3 id="有效类型">有效类型</h3><p>非类型模版参数只能是整形、枚举、指向对象/函数/成员的指针、指向对象/函数的左值引用、nullptr</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">double</span> VAT&gt;<span class="comment">//!!!, 这个是错误的，因为double不能作为非类型模版参数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">process</span><span class="params">(<span class="type">double</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v * VAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若表达式中使用了<code>&gt;</code>，要用<code>()</code>包裹起来</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> I, <span class="type">bool</span> B&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  C&lt;<span class="number">42</span>, <span class="built_in">sizeof</span> (<span class="type">int</span> &gt; <span class="number">4</span>)&gt; c;<span class="comment">// ERROR! 被截断为C&lt;42, sizeof (int &gt;了</span></span><br><span class="line">  C&lt;<span class="number">42</span>, (<span class="built_in">sizeof</span> (<span class="type">int</span>) &gt; <span class="number">4</span>)&gt; c;<span class="comment">// OK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="auto">auto</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, Maxsize&gt; elems;</span><br><span class="line">    std::<span class="type">size_t</span> elemCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">decltype</span>(Maxsize);<span class="comment">// !!!, 用于推断Maxsize类型</span></span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elemCount == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elemCount; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="变参模版">变参模版</h2><blockquote><p>就是接受一组数量可变的参数</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T first, Types... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(first);</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Index&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElems</span><span class="params">(C <span class="type">const</span>&amp; coll, Index... id)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(coll[id]...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">1314</span>);<span class="comment">// hello world 1314</span></span><br><span class="line">  <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">printElems</span>(a, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">// 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折叠表达式">折叠表达式</h3><p>几乎所有二元运算符都可以用于折叠表达式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getSum</span><span class="params">(T...s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (...+s);<span class="comment">// 等同于((s1 + s2) + s3)...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>) &lt;&lt; std::endl;<span class="comment">// 45</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础技巧">基础技巧</h2><h3 id="typename">typename</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T <span class="type">const</span>&amp; coll)</span></span>&#123;</span><br><span class="line">    T::const_interator pos;<span class="comment">// Error! 会被认为是静态成员</span></span><br><span class="line">  <span class="keyword">typename</span> T::const_interator pos;  <span class="comment">// OK! const_interator是定义在T内的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零初始化">零初始化</h3><p>若一个类型没有默认构造函数（比如基础类型和指针类型），被初始化前其值是<strong>未定义</strong>的，我们可以使用<strong>值初始化</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    T x &#123;&#125;;<span class="comment">// 零初始化</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    T x;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo2</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// 1, 为啥这是1啊, 因为未定义所以错了</span></span><br><span class="line">    <span class="built_in">foo2</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">foo1</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// 0, 通过零初始化所以对了</span></span><br><span class="line">    <span class="built_in">foo2</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// 0, 很难绷, 为啥你又变成0了？未定义果然不靠谱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在默认构造函数中使用零初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() : x&#123;&#125; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">    x.<span class="built_in">print</span>();<span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是非静态成员，也可以这样写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="this">this</h3><p>对于类模版，若基类也依赖于模版参数，那么子类在调用基类的成员时要使用<code>this-&gt;</code>或<code>Base&lt;T&gt;::</code>修饰</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>: Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">print</span>();<span class="comment">// !这里要使用this-&gt;不然调用不到Base的成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo&lt;<span class="type">int</span>&gt; f;</span><br><span class="line">    f.<span class="built_in">foo</span>();<span class="comment">// Hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员模版">成员模版</h3><p>类的成员也可以是模版，而且模版参数可以不同</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;T&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">    Stack&amp; <span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="type">const</span>&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Stack</span>;<span class="comment">// 为了访问其他Stack实例的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> Stack&lt;T2&gt; &amp;op2) &#123;</span><br><span class="line">    elems.<span class="built_in">clear</span>();</span><br><span class="line">    elems.<span class="built_in">insert</span>(elems.<span class="built_in">begin</span>(), op2.elems.<span class="built_in">begin</span>(), op2.elems.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">float</span>&gt; floatStack;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="type">float</span> n = <span class="number">3.14</span> * i;</span><br><span class="line">        floatStack.<span class="built_in">push</span>(n);</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">// 0 3.14 6.28 9.42 12.56 </span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">    intStack = floatStack;</span><br><span class="line">    <span class="keyword">while</span> (!intStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">// 12 9 6 3 0 </span></span><br><span class="line">        intStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lambda">lambda</h3><p>lambda表达式本质上是成员模版的简化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量模版">变量模版</h3><p>变量也可以使用模版，必须指定类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">long</span> <span class="type">double</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi &#123;<span class="number">3.1415926535897932385</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; pi&lt;&gt; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17中类型萃取就是使用了变量模版</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">bool</span> is_const_v = is_const&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模版参数模版">模版参数模版</h3><p>模版参数也可以是一个类模版</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem&gt; <span class="keyword">class</span> <span class="title class_">Cont</span> = std::deque&gt;</span><br><span class="line"><span class="keyword">class</span> Stack&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Cont&lt;T&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="移动语义">移动语义</h2><blockquote><p>移动的本质是所有权的转移，这里不过多赘述</p></blockquote><p>移动（move）：将原对象拷贝或赋值给目标对象时，若原对象马上要被销毁，可以将原对象对内部资源和状态的<strong>所有权</strong>直接转移给目标对象，避免了非必要的拷贝和临时对象</p><h3 id="禁用函数模版">禁用函数模版</h3><p>C++11提供了辅助模版<code>std::enable_if&lt;&gt;</code>，可以在编译期间忽略掉一些函数模版</p><blockquote><p>注意看，<code>foo()</code>前面的返回值类型是由<code>std::enable_if</code>决定的，</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;(<span class="built_in">sizeof</span> (T) &gt; <span class="number">4</span>)&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span> (T) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// Error! 没有找到foo, int size 4</span></span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="type">double</span>&gt;();<span class="comment">// OK, double size 8</span></span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;();<span class="comment">// OK, long long size 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若<code>(sizeof (T) &gt; 4)</code>为false，根据模版中SFINAE（substitute failure is not an error）规则，替换失败不是错误，而是会将这个函数模版忽略掉，于是<code>foo&lt;int&gt;()</code>会报找不到函数的错</p><p>若<code>(sizeof (T) &gt; 4)</code>为true，<code>std::enable_if&lt;&gt;</code>会被拓展为<code>void</code>，如果你给了第二个参数<code>T</code>，<code>std::enable_if&lt;&gt;</code>会被拓展为<code>T</code>类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;(<span class="built_in">sizeof</span> (T) &gt; <span class="number">4</span>), T&gt;</span><br><span class="line"><span class="built_in">foo</span>()&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span> (T) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更明智的写法是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfSizeGreater4 = std::<span class="type">enable_if_t</span>&lt;(<span class="built_in">sizeof</span> (T) &gt; <span class="number">4</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = EnableIfSizeGreater4&lt;T&gt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">foo</span>()&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span> (T) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="禁用构造函数模版">禁用构造函数模版</h3><p>由于转移语义的存在，构造函数的参数类型很可能是错误的，比如传入了一个右值引用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(std::string&amp;&amp; s);<span class="comment">// 我们希望禁用这个构造函数</span></span><br></pre></td></tr></table></figure><p>下面是一个例子</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString = std::<span class="type">enable_if_t</span>&lt;std::is_convertible_v&lt;T, std::string&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = EnableIfString&lt;STR&gt;&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(STR&amp;&amp; n) : <span class="built_in">name</span>(std::forward&lt;STR&gt;(n)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;模版构造函数 &quot;</span> &lt;&lt; name &lt;&lt; std::endl;    <span class="comment">// 使用了完美转发</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(Person <span class="type">const</span>&amp; p) : <span class="built_in">name</span>(p.name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝构造函数 &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(Person&amp;&amp; p) : <span class="built_in">name</span>(std::<span class="built_in">move</span>(p.name)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;移动构造函数 &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;sname&quot;</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(s)</span></span>;<span class="comment">// 模版构造函数 sname</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;temp&quot;</span>)</span></span>;<span class="comment">// 模版构造函数 temp</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>;<span class="comment">// 拷贝构造函数 sname</span></span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(std::move(p1))</span></span>;<span class="comment">// 移动构造函数 sname</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们没法禁用拷贝和移动构造函数，因为我们用成员函数来替代这些函数时，这些函数还会生成默认构造函数</p><h3 id="concept">concept</h3><p><code>enable_if</code>的语法非常丑，而且还额外使用了一个模版参数，使得代码不易读懂</p><p>我们需要的是一个能对函数施加限制的语言特性，当限制不满足时函数会被忽略掉，于是C++决定引入<code>concept</code></p><h2 id="模板元编程">模板元编程</h2><p>模板在编译器实例化，在实例化时可以进行简单的计算，这就是模板元编程</p><p>下面是用模板元判断一个数是不是质数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N, <span class="type">unsigned</span> <span class="type">int</span> Divisor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPrime</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = (N % Divisor != <span class="number">0</span>) &amp;&amp; IsPrime&lt;N, Divisor - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPrime</span>&lt;N, <span class="number">2</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = (N % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> isPrime = IsPrime&lt;N, N / <span class="number">2</span>&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> number = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span> (isPrime&lt;number&gt;) &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; is a prime number.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; is not a prime number.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="decltype">decltype</h3><p>选择合适的模板特化，也叫<strong>SFINAE</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;<span class="comment">// int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1.5</span>) &lt;&lt; std::endl;<span class="comment">// double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1.5f</span>) &lt;&lt; std::endl;<span class="comment">// float</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-constexpr">if constexpr</h3><p>编译器if</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">addIfFloat</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1.0f</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">addIfFloat</span>(<span class="number">1</span>) &lt;&lt; std::endl;<span class="comment">// 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">addIfFloat</span>(<span class="number">1.5f</span>) &lt;&lt; std::endl;<span class="comment">// 2.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型萃取">类型萃取</h2><blockquote><p>感觉不如C#的反射</p></blockquote><p>用于编译期获得模板参数的性质，下面是判断一个类中是否有成员函数<code>Execute()</code>的示例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasFunction_Execute</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">check</span><span class="params">(U* ptr)</span> -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;U&gt;().Execute(), std::true_type&#123;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::false_type <span class="title">check</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">check</span>&lt;T&gt;(<span class="literal">nullptr</span>))::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Check</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Check::someFunction() called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCheck</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasFunction_Execute&lt;Check&gt;::value) &#123;</span><br><span class="line">        Check obj;</span><br><span class="line">        obj.<span class="built_in">Execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFunction_Execute&lt;NoCheck&gt;::value) &#123;</span><br><span class="line">        <span class="comment">// 不会执行到这里，因为NoCheck类没有Execute成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里使用了<code>std::declval</code>，可以用作引用占位符</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银河恶魔城设计理念学习</title>
      <link href="/game/%E9%93%B6%E6%B2%B3%E6%81%B6%E9%AD%94%E5%9F%8E%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%AD%A6%E4%B9%A0/"/>
      <url>/game/%E9%93%B6%E6%B2%B3%E6%81%B6%E9%AD%94%E5%9F%8E%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>银河恶魔城设计理念学习</h1><blockquote><p>昨天跟魔方的策划沟通了一下，发现我之前的设计很不成熟，我所认为的Hook（比如“玩家因为缺少一个能力卡关了，于是去岔路口寻找其他能力”）原来只是这类游戏的共性（Pillar），</p></blockquote><h2 id="银河恶魔城">银河恶魔城</h2><h3 id="能力锁">能力锁</h3><p>银河恶魔城大量使用了能力锁，使用低纬度的能力构成高纬度的钥匙，服务于后续游玩，能与关卡产生协同效应</p><ul><li>道具锁（Item-Lock）：比如找到一把具体的钥匙道具开门开箱子，真实但不好玩，只能提供很低的心智挑战，或者带来一些消耗资源管理，比如做成一个玩家理论上可以通过，但由于玩家现在太弱了/太穷了而无法通过的软锁</li><li>谜题锁（Puzzle-Lock）：一段和游戏流程无关的解密，比如战神中敲钟、荒野之息中呀哈哈，能产生一次性的解密体验，常用于调整玩家游戏节奏</li><li>挑战锁（Challenge-Lock）：一段结合游戏中战斗、行动技巧的挑战，比如GTA中骑摩托车跑酷，荒野之息限时射箭</li><li>能力锁（Utility-Lock）：新能力解锁新区域，比如玩家得到了二段跳后，能跳到原来不能到达的平台，于是开放了更多的可探索内容</li></ul><img src="/images/目标挑战奖励.png" class="lazyload" data-srcset="/images/目标挑战奖励.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="目标挑战奖励" style="zoom:50%;" /><blockquote><p>以打开桃色门为例：目标是打开桃色门，挑战锁得到开门的能力/钥匙，奖励是新区域。新区域中会有新的游玩内容，新的奖励/能力，于是形成了正反馈，形成扩张式探索</p></blockquote><h3 id="回路探索">回路探索</h3><p>银河恶魔城一般关键能力的获取顺序、关键boss的击杀顺序是固定的，因此流程是线性的。同时该游戏存在破序玩法，可收集道具和某些能力不是必须的，流程又是开放的</p><p>银河恶魔城中由于能力锁的存在，玩家无法通过某个房间后，会回到岔路探索其他房间，获得相关能力后再通过原本无法探索的房间，这个过程就是回路探索。一个探索过的房间，当玩家拥有更新的能力后，会有新的体验。（让我想到一些游戏，当你通关后来到新手村，很多人对你的称呼和态度发生变化，原本的困难的敌人也能做到一击必杀，故地重游也能有新的体验）</p><blockquote><p>他建议我在设计地图时，先设计大块的区域功能和区域间的联系，再设计每个房间的整体设计，画出角色第一次进入房间的行为热线。</p><p>每个房间的作用围绕资源的布置、节奏的控制来分配；每个房间的内部结构结合这个区域的核心机制进行设计</p></blockquote><img src="/images/线性开发.jpg" class="lazyload" data-srcset="/images/线性开发.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线性开发" style="zoom: 50%;" /><p>一张绘制区域内小房间的布局；玩家从首次进入、取得能力、击败boss、进入下一区域的一个动线</p><img src="/images/热线.png" class="lazyload" data-srcset="/images/热线.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="热线" style="zoom:50%;" /><h2 id="游戏目标">游戏目标</h2><h3 id="游戏目标-2">游戏目标</h3><p>游戏中玩家目标和设计师的目标可能不一致，从用户出发设计师最先注意的是体验目标</p><img src="/images/游戏目标.png" class="lazyload" data-srcset="/images/游戏目标.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="游戏目标" style="zoom:50%;" /><p>玩家目标：玩家在游戏设置的情景中被要求达到的结果（比如打到魔王、赚到一万个金币）</p><p>体验目标：设计师希望玩家通过游戏体验到的内容（比如了解某个文明的文化，掌握超人力量的满足感，感到恐惧、好奇）</p><p>设计目标：设计师希望通过具体的设计手法达到特定的产品效果（比如为长期运营创造空间，简洁扁平的交互设计）</p><h3 id="GMT">GMT</h3><p>G（Goal）：目标</p><p>M（Means）：达成目标的高阶手段</p><p>T（Tools）：将手段细分的具体可执行的低阶要素</p><p>GMT分为玩家目标的GMT和体验目标的GMT</p><h2 id="关卡设计">关卡设计</h2><h2 id="参考">参考</h2><p><a href="https://zhuanlan.zhihu.com/p/515008876">银河恶魔城入门</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3MTQzOTY3OQ==&amp;mid=2247494931&amp;idx=1&amp;sn=f1d6cde58404aee53598de4b7016630b&amp;chksm=eac36f43ddb4e6557c4c2d87e3ec93a049da01b15cbad57b86f913eda11987081f75a3c78280&amp;scene=21#wechat_redirect">游戏设计逻辑</a></p><p><a href="https://www.youtube.com/watch?v=7ITtPPE-pXE">关卡设计</a></p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>银河战士like开发日志</title>
      <link href="/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
      <url>/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1>银河战士like开发日志</h1><p>终于把毕设忙完了，开始填坑了，首先就是这个银河战士like的游戏，说实话我已经很长时间没做过Gameplay开发了，上来就做这种高难度的动作射击，感觉有些蠢。不过多亏了Mix and Jam开源了一个教程，少走不少弯路。为了自我监督，把开发日志记录在案。说实话我GP水平很差，这个日志应该会踩不少坑</p><blockquote><p>Unity 2021.3.22 URP Windows11，使用内置的Plastic SCM做版本管理（Unity对Plastic SCM支持较好，尽管我更喜欢Git和P4V）</p></blockquote><h3 id="1-添加角色模型">1. 添加角色模型</h3><blockquote><p>使用Package Manager添加插件Input System，Player Input组件和Input Action文件均属于该插件</p></blockquote><p>从<a href="%5BMixamo%5D(https://www.mixamo.com/#/)">Mixamo</a>找一个人物模型，放入场景中</p><p>添加组件Character Controller（该组件会自带一个胶囊碰撞体，可以调整尺寸以适配角色）</p><p>添加组件Player Input</p><p>添加一个脚本<code>PlayerController.cs</code></p><p><img src="/images/mixamo.png" class="lazyload" data-srcset="/images/mixamo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="mixamo"></p><img src="/images/characterController.png" class="lazyload" data-srcset="/images/characterController.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="characterController" style="zoom:50%;" /><h3 id="2-配置Input-Action文件">2. 配置Input Action文件</h3><p>创建一个Input Action，添加一个Vector2类型的移动，一个跳跃按钮</p><p><img src="/images/inputAction.gif" class="lazyload" data-srcset="/images/inputAction.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="inputAction"></p><p>将该文件拖入Player Input组件的Actions上</p><h3 id="3-编写移动脚本">3. 编写移动脚本</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PlayerInput input;</span><br><span class="line">    <span class="keyword">private</span> CharacterController controller;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;Movement Settings&quot;</span>)</span>] </span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;水平移动速度&quot;</span>)</span>] </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> movementSpeed = <span class="number">6f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Vector2 moveInput;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取角色身上的组件</span></span><br><span class="line">        input = GetComponent&lt;PlayerInput&gt;();</span><br><span class="line">        controller = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读按键输入</span></span><br><span class="line">        moveInput = input.actions[<span class="string">&quot;Move&quot;</span>].ReadValue&lt;Vector2&gt;();</span><br><span class="line"><span class="comment">// 若输入不为空，则使用CharacterController进行移动</span></span><br><span class="line">        <span class="built_in">bool</span> isMoving = Mathf.Abs(moveInput.normalized.x) &gt; <span class="number">0.01f</span>;</span><br><span class="line">        <span class="keyword">if</span> (isMoving)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> hDir = moveInput.x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            controller.Move(Vector3.right * hDir * Mathf.Abs(moveInput.normalized.x * movementSpeed) * Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入游戏后按AD键可以实现左右移动（注意坐标系，Unity的2D游戏通常会以x轴正方向为右，y轴正方向为上）</p><h3 id="4-移动动画">4. 移动动画</h3><p>去mixamo找几段动画（动画存放在fbx文件中，将fbx导入unity后可以将动画片段抽离、切分），并创建一个Animation Controller</p><img src="/images/动画.png" class="lazyload" data-srcset="/images/动画.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="动画" style="zoom:50%;" /><p>双击打开Animation Controller后，右键创建一个BlendTree，将该BlendTree与Entry相连，并修改BlendTree的参数名为<code>MoveInput</code></p><p><img src="/images/animator.png" class="lazyload" data-srcset="/images/animator.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="animator"></p><p>双击进入BlendTree，按右键添加多个Motion，并调整他们的Threshold信息</p><p><img src="/images/blendtree.png" class="lazyload" data-srcset="/images/blendtree.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blendtree"></p><p>在角色上添加Animator组件，并将上面创建的Animation Controller拖到上面</p><img src="/images/人物动画.png" class="lazyload" data-srcset="/images/人物动画.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="人物动画" style="zoom:50%;" /><p>修改<code>PlayerController.cs</code>脚本，根据输入设置动画参数，并处理转向</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private PlayerInput input;</span><br><span class="line">private CharacterController controller;</span><br><span class="line"><span class="addition">+private Animator animator;</span></span><br><span class="line"></span><br><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">    input = GetComponent&lt;PlayerInput&gt;();</span><br><span class="line">    controller = GetComponent&lt;CharacterController&gt;();</span><br><span class="line"><span class="addition">+    animator = GetComponent&lt;Animator&gt;();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    moveInput = input.actions[&quot;Move&quot;].ReadValue&lt;Vector2&gt;();</span><br><span class="line"></span><br><span class="line">    bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f;</span><br><span class="line">    if (isMoving)</span><br><span class="line">    &#123;</span><br><span class="line">        float hDir = moveInput.x &gt; 0 ? 1 : -1;</span><br><span class="line">        controller.Move(Vector3.right * hDir * Mathf.Abs(moveInput.normalized.x * movementSpeed) * Time.deltaTime);</span><br><span class="line"><span class="addition">+        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(moveInput.x != 0 ? Vector3.right * moveInput.normalized.x : Vector3.right * hDir), 0.1f);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+    animator.SetFloat(&quot;MoveInput&quot;, Mathf.Abs(moveInput.normalized.x * movementSpeed), 0.2f, Time.deltaTime);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下，感觉运动停止时有点粘滞感，还需要细调</p><p><img src="/images/%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8.gif" class="lazyload" data-srcset="/images/%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="左右移动"></p><h3 id="5-跳跃">5. 跳跃</h3><p>跳跃是该游戏的核心，这只是我估摸着做的第一版，有一说一，手感稀烂</p><h4 id="碰撞状态检测">碰撞状态检测</h4><p>创建脚本<code>CollisionState.cs</code>，并绑定到角色身上。该脚本用于判断角色和场景的关系，目前只做了和水平地表的检测</p><blockquote><p>nearGround的作用是为了连跳</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CollisionState</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;地表的碰撞层&quot;</span>)</span>] <span class="keyword">private</span> LayerMask groundLayer;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;在地表上的检测距离&quot;</span>)</span>] <span class="keyword">private</span> <span class="built_in">float</span> testDistance = <span class="number">0f</span>;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;靠近地表的检测距离&quot;</span>)</span>] <span class="keyword">private</span> <span class="built_in">float</span> nearDistance = <span class="number">0.2f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> onGround;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> nearGround;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> offset = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        onGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, testDistance + offset, groundLayer);</span><br><span class="line">        nearGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, nearDistance + offset, groundLayer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环境设置">环境设置</h4><p>添加Ground碰撞层，并将场景物体设置为Ground（场景物体要有碰撞体）</p><p><img src="/images/GroundLayer.gif" class="lazyload" data-srcset="/images/GroundLayer.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GroundLayer"></p><p>注意设置角色身上的Ground Layer类型</p><p><img src="/images/GroundLayer2.png" class="lazyload" data-srcset="/images/GroundLayer2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GroundLayer2"></p><h4 id="角色跳跃">角色跳跃</h4><p>下面修改<code>PlayerController.cs</code>，添加跳跃逻辑</p><p>首先获取CollisionState脚本，以判断是否能进行跳跃</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">private Animator animator;</span><br><span class="line"><span class="addition">+private CollisionState collisionState;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    animator = GetComponent&lt;Animator&gt;();</span><br><span class="line"><span class="addition">+    collisionState = GetComponent&lt;CollisionState&gt;();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加一些跳跃要用到的参数</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">[Header(&quot;Movement Settings&quot;)] </span><br><span class="line">[SerializeField, Tooltip(&quot;水平移动速度&quot;)] </span><br><span class="line">private float movementSpeed = 6f;</span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;重力&quot;)] </span></span><br><span class="line"><span class="addition">+private float gravity = -9.8f;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;大跳的跳跃高度&quot;)] </span></span><br><span class="line"><span class="addition">+private float jumpHeight = 5f;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;开始加速下落时的速度&quot;)] </span></span><br><span class="line"><span class="addition">+private float fallingSpeedup = 10f;</span></span><br><span class="line"></span><br><span class="line">private Vector2 moveInput;</span><br><span class="line"><span class="addition">+private bool jumpPressed = false;</span></span><br><span class="line"><span class="addition">+private bool jumpPressDown = false;</span></span><br><span class="line"><span class="addition">+private float verticalVelocity;</span></span><br><span class="line"><span class="addition">+private bool moveAfterJump  = false;    // 移动中跳跃，还是跳跃后移动</span></span><br><span class="line"><span class="addition">+private float herizontalDirection = 1f;</span></span><br><span class="line"><span class="addition">+private bool keepJump = false;  // 保持滞空</span></span><br></pre></td></tr></table></figure><p>跳跃，包含起跳、滞空、落地三个过程。</p><ul><li><p>nearGround比真实地表要高一点，于是可以在接近落地时跳跃，优化连跳手感</p></li><li><p>若按下跳跃键后不放，重力会比直接松开小，因而跳的更高，拥有更长的滞空时间。此外若向下掉落的速度小于fallingSpeedup，仍受较小的重力。</p></li><li><p>当向下落地时遇到地面，速度为0</p></li></ul><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    moveInput = input.actions[&quot;Move&quot;].ReadValue&lt;Vector2&gt;();</span><br><span class="line"><span class="addition">+    jumpPressDown = input.actions[&quot;Jump&quot;].WasPressedThisFrame();</span></span><br><span class="line"><span class="addition">+    jumpPressed = input.actions[&quot;Jump&quot;].IsPressed();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    #region 跳跃</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    // 起跳</span></span><br><span class="line"><span class="addition">+    if (jumpPressDown &amp;&amp; collisionState.nearGround)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        verticalVelocity = Mathf.Sqrt(2 * Mathf.Abs(gravity) * jumpHeight);</span></span><br><span class="line"><span class="addition">+        moveAfterJump = Mathf.Abs(moveInput.normalized.x) &lt; 0.3f;   // 判断起跳时移动速度</span></span><br><span class="line"><span class="addition">+        keepJump = true;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    // 滞空</span></span><br><span class="line"><span class="addition">+    if (keepJump &amp;&amp; verticalVelocity &gt; -fallingSpeedup)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        verticalVelocity += gravity * Time.deltaTime;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else if(!collisionState.onGround)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        verticalVelocity += 3 * gravity * Time.deltaTime;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    if (!jumpPressed)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        keepJump = false;// 松开后不能重新滞空</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    // 落地</span></span><br><span class="line"><span class="addition">+    if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        verticalVelocity = 0;</span></span><br><span class="line"><span class="addition">+        moveAfterJump = false;</span></span><br><span class="line"><span class="addition">+        keepJump = false;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    // 运动</span></span><br><span class="line"><span class="addition">+    controller.Move(Vector3.up * verticalVelocity * Time.deltaTime);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+    #endregion</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更真实，我希望角色原地起跳时更难左右移动，于是在这种情况下水平移动速度减半</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+    #region 水平移动</span></span><br><span class="line"></span><br><span class="line">    bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f;</span><br><span class="line">    if (isMoving)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="addition">+        float herizontalSpeed = Mathf.Abs(moveInput.normalized.x * movementSpeed);</span></span><br><span class="line"></span><br><span class="line">        float hDir = moveInput.x &gt; 0 ? 1 : -1;</span><br><span class="line"><span class="addition">+        if (moveAfterJump)</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            herizontalSpeed /= 2;   // 原地起跳，在空中动能很少，按理说应该走不动</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        controller.Move(Vector3.right * hDir * herizontalSpeed * Time.deltaTime);</span></span><br><span class="line">        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(moveInput.x != 0 ? Vector3.right * moveInput.normalized.x : Vector3.right * hDir), 0.1f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">animator.SetFloat(&quot;MoveInput&quot;, Mathf.Abs(moveInput.normalized.x * movementSpeed), 0.2f, Time.deltaTime);</span><br><span class="line"><span class="addition">+    #endregion</span></span><br></pre></td></tr></table></figure><p><img src="/images/%E8%B7%B3%E8%B7%83%E7%AC%AC%E4%B8%80%E7%89%88.gif" class="lazyload" data-srcset="/images/%E8%B7%B3%E8%B7%83%E7%AC%AC%E4%B8%80%E7%89%88.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="跳跃第一版"></p><h3 id="6-跳跃动画">6. 跳跃动画</h3><blockquote><p>动画状态机比我想象中要麻烦好多。。。我也不知道我这样做对不对。。。</p><p>由于没找到合适的动画资源，这一节不少动画是我自己做的，花了相当长时间，结果效果也不太行</p></blockquote><p>按下图所示在Any State后连接跳跃状态，并添加Jump、FallLand、FastJump、FastFallLand四个动画Trigger</p><p><img src="/images/Animator2.png" class="lazyload" data-srcset="/images/Animator2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Animator2"></p><p>当开始跳跃时会进入JumpStart/RollStart（仅播放一次），播放完后进入滞空动画Jumping/Rolling（这段动画会循环播放），当落地时会进入JumpEnd/RollEnd动画</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// 起跳</span><br><span class="line">if (jumpPressDown &amp;&amp; collisionState.nearGround)</span><br><span class="line">&#123;</span><br><span class="line">    verticalVelocity = Mathf.Sqrt(2 * Mathf.Abs(gravity) * jumpHeight);</span><br><span class="line">    moveAfterJump = Mathf.Abs(moveInput.normalized.x) &lt; 0.3f;   // 判断起跳时移动速度</span><br><span class="line">    keepJump = true;</span><br><span class="line">    herizontalDirection = moveInput.x &gt; 0 ? 1 : -1;</span><br><span class="line"><span class="addition">+    if (moveAfterJump)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        animator.SetTrigger(&quot;Jump&quot;);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        animator.SetTrigger(&quot;FastJump&quot;);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">// 落地</span><br><span class="line">if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround)</span><br><span class="line">&#123;</span><br><span class="line"><span class="addition">+    if (moveAfterJump)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        animator.SetTrigger(&quot;FallLand&quot;);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        animator.SetTrigger(&quot;FastFallLand&quot;);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">    verticalVelocity = 0;</span><br><span class="line">    moveAfterJump = false;</span><br><span class="line">    keepJump = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E8%B7%B3%E8%B7%83%E5%8A%A8%E7%94%BB.gif" class="lazyload" data-srcset="/images/%E8%B7%B3%E8%B7%83%E5%8A%A8%E7%94%BB.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="跳跃动画"></p><h3 id="7-相机">7. 相机</h3><blockquote><p>使用插件Cinemachine，现在只做一个简易的版本</p></blockquote><p>在Hierarchy面板按右键——Cinemachine——Virtual Camera</p><p>设置虚拟相机，让其Follow角色，并设置死区</p><img src="/images/cinemachine.png" class="lazyload" data-srcset="/images/cinemachine.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cinemachine" style="zoom:50%;" /><p><img src="/images/cinemachine2.png" class="lazyload" data-srcset="/images/cinemachine2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cinemachine2"></p><p>效果如下（额，这跳跃的边缘检测还是有问题）</p><p><img src="/images/%E7%9B%B8%E6%9C%BA.gif" class="lazyload" data-srcset="/images/%E7%9B%B8%E6%9C%BA.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="相机"></p><h3 id="8-爬墙">8. 爬墙</h3><p>有的平台我们差一点点就能跳上去，我希望在这个边缘向左右拉动摇杆，可以实现爬墙的功能，暂时吸附在墙体上</p><p>在角色前添加一个空对象ClimbWallPoint（图中蓝色），在前上添加一个空对象PassablePoint（图中红色），这两个点将用于发射碰撞检测射线</p><p><img src="/images/%E7%88%AC%E5%A2%99%E7%82%B9.png" class="lazyload" data-srcset="/images/%E7%88%AC%E5%A2%99%E7%82%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="爬墙点"></p><p>修改<code>CollisionState.cs</code>脚本，添加爬墙检测逻辑</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">[SerializeField, Tooltip(&quot;靠近地表的检测距离&quot;)] private float nearDistance = 0.2f;</span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;爬墙检测点&quot;)] private Transform climbWallPoint;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;爬墙检测距离&quot;)] private float climbTestDistance = 0.2f;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;可通行检测点&quot;)] private Transform passablePoint;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;通行检测距离&quot;)] private float passableTestDistance = 1f;</span></span><br><span class="line"></span><br><span class="line">private float offset = 0.05f;</span><br><span class="line"><span class="addition">+private float lookRight;</span></span><br><span class="line"></span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    onGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, testDistance + offset, groundLayer);</span><br><span class="line">    nearGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, nearDistance + offset, groundLayer);</span><br><span class="line"><span class="addition">+    lookRight = (climbWallPoint.position.x - transform.position.x) &gt; 0 ? 1 : -1;</span></span><br><span class="line"><span class="addition">+    climbWall = Physics.Raycast(climbWallPoint.position, Vector3.right * lookRight, climbTestDistance, groundLayer);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+public bool GetPassable()</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+    bool passable = !Physics.Raycast(passablePoint.position, Vector3.right * lookRight, passableTestDistance, groundLayer);</span></span><br><span class="line"><span class="addition">+    return passable;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure><p>修改<code>PlayerController.cs</code>脚本，感觉角色状态越来越复杂，有些难以管理了，之后要做一个角色状态机</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private bool keepJump = false;  // 保持滞空</span><br><span class="line"><span class="addition">+private bool jumping = false;   // 处于跳跃状态</span></span><br><span class="line"><span class="addition">+private bool climbing = false;  // TODO: 角色状态机</span></span><br><span class="line"></span><br><span class="line">private void Update()&#123;</span><br><span class="line">...</span><br><span class="line">// 起跳</span><br><span class="line">    if (jumpPressDown &amp;&amp; collisionState.nearGround)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">        keepJump = true;</span><br><span class="line"><span class="addition">+        jumping = true;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...    </span><br><span class="line">if (!jumpPressed)</span><br><span class="line">    &#123;</span><br><span class="line">        keepJump = false;   // 松开后不能重新滞空</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+    // 爬墙</span></span><br><span class="line"><span class="addition">+    if (jumping &amp;&amp; collisionState.climbWall &amp;&amp; collisionState.GetPassable() &amp;&amp; Mathf.Abs(moveInput.normalized.x) &gt; 0.7)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        climbing = true;</span></span><br><span class="line"><span class="addition">+        verticalVelocity = 0;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        climbing = false;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line">    // 落地</span><br><span class="line">    if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        keepJump = false;</span><br><span class="line"><span class="addition">+        jumping = false;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f;</span><br><span class="line"><span class="addition">+    if (isMoving &amp;&amp; !climbing)</span></span><br><span class="line">    &#123;</span><br><span class="line">    float herizontalSpeed = Mathf.Abs(moveInput.normalized.x * movementSpeed);</span><br><span class="line">    ...</span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下（论动画的重要性）</p><p><img src="/images/%E7%88%AC%E5%A2%99.gif" class="lazyload" data-srcset="/images/%E7%88%AC%E5%A2%99.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="爬墙"></p><h3 id="9-抓墙动画">9. 抓墙动画</h3><p>我继续沿用老办法做抓墙动画，结果却发现手很难抓住墙壁，于是我改用Animation Rigging的方式实现</p><p><img src="/images/%E6%8A%93%E5%A2%99%E7%AC%AC%E4%B8%80%E7%89%88.gif" class="lazyload" data-srcset="/images/%E6%8A%93%E5%A2%99%E7%AC%AC%E4%B8%80%E7%89%88.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="抓墙第一版"></p><blockquote><p>骨骼的本质是矩阵树，运行时变化矩阵从根节点开始正向改变网格顶点（蒙皮），变化矩阵包含位移旋转缩放信息，Animation Rigging可以让部分骨骼不受动画影响，而是被反向动力学等方式驱动</p></blockquote><h4 id="安装插件">安装插件</h4><p>首先通过包管理器安装Animation Rigging，我们发现窗口上方出现了Animation Rigging栏</p><h4 id="配置Rig">配置Rig</h4><p>找到并选中角色后，点击Animation Rigging——Bone Renderer Setup，我们发现角色身上多了一个Bone Renderer组件，骨骼也被绘制出来</p><img src="/images/boneRender.png" class="lazyload" data-srcset="/images/boneRender.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="boneRender" style="zoom:50%;" /><img src="/images/boneRender2.png" class="lazyload" data-srcset="/images/boneRender2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="boneRender2" style="zoom:50%;" /><p>选中角色后点击Animation Rigging——Rig Setup，发现角色出现了一个子物体：Rig1</p><p>将Rig重命名为RigHand，并创建子节点RightHand，为RightHand添加组件Two Bone IK Constraint</p><p>再RightHand下面创建空的子节点，名叫Target，为了容易观察，让其拥有球形Shape</p><p><img src="/images/Target.gif" class="lazyload" data-srcset="/images/Target.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Target"></p><p>找到骨骼树中想要被反向驱动的三根骨骼，拖至Two Bone IK Constraint组件上，并将Target也拖到该组件上。现在播放动画，我们发现右手不会被动画驱动，而是被Target反向驱动</p><p><img src="/images/rig.gif" class="lazyload" data-srcset="/images/rig.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="rig"></p><p>通常状态不需要Rig，于是我们将Rig的权重设为0</p><h4 id="脚本设置手部落地">脚本设置手部落地</h4><p>修改脚本<code>CollisionState.cs</code>，添加手与墙壁的相交位置</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">public bool GetPassable()</span><br><span class="line">&#123;</span><br><span class="line">    bool passable = !Physics.Raycast(passablePoint.position, Vector3.right * lookRight, passableTestDistance, groundLayer);</span><br><span class="line">    return passable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+public Vector3 GetClimbTouchPosition()</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+    Ray ray = new Ray(climbWallPoint.position, Vector3.right * lookRight);</span></span><br><span class="line"><span class="addition">+    Physics.Raycast(ray, out RaycastHit hit);</span></span><br><span class="line"><span class="addition">+    return hit.point;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure><p>修改脚本<code>PlayerController.cs</code>，实现贴墙时修改Target的位置和Rig权重</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">[SerializeField, Tooltip(&quot;开始加速下落时的速度&quot;)] </span><br><span class="line">private float fallingSpeedup = 10f;</span><br><span class="line"></span><br><span class="line"><span class="addition">+[SerializeField] private Transform rightHandPosition;</span></span><br><span class="line"><span class="addition">+[SerializeField] private Rig rightHandRig;</span></span><br><span class="line"></span><br><span class="line">private Vector2 moveInput;</span><br><span class="line">...</span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">// 爬墙</span><br><span class="line">    if (jumping &amp;&amp; collisionState.climbWall &amp;&amp; collisionState.GetPassable() &amp;&amp; Mathf.Abs(moveInput.normalized.x) &gt; 0.7)</span><br><span class="line">    &#123;</span><br><span class="line">        climbing = true;</span><br><span class="line">        verticalVelocity = 0;</span><br><span class="line"><span class="addition">+        rightHandPosition.position = collisionState.GetClimbTouchPosition();</span></span><br><span class="line"><span class="addition">+        rightHandPosition.rotation = Quaternion.LookRotation(moveInput.x &gt; 0 ? Vector3.right : Vector3.left);</span></span><br><span class="line"><span class="addition">+        rightHandRig.weight = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        climbing = false;</span><br><span class="line"><span class="addition">+        rightHandRig.weight = 0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%8A%93%E5%A2%99%E7%AC%AC%E4%BA%8C%E7%89%88.gif" class="lazyload" data-srcset="/images/%E6%8A%93%E5%A2%99%E7%AC%AC%E4%BA%8C%E7%89%88.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="抓墙第二版"></p><p>尽管还存在臂力惊人单手悬空的问题，但相比上一版已经好了不少</p><h3 id="10-上平台">10. 上平台</h3><p>抓墙的目的自然是为了上平台，修改<code>PlayerController.cs</code>脚本</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">[SerializeField, Tooltip(&quot;开始加速下落时的速度&quot;)] </span><br><span class="line">private float fallingSpeedup = 10f;</span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;爬墙时向上跳的初速度&quot;)]</span></span><br><span class="line"><span class="addition">+private float climbingJumpSpeed = 10f;</span></span><br><span class="line">...</span><br><span class="line">private bool climbing = false;  // TODO: 角色状态机</span><br><span class="line"><span class="addition">+private bool climbingJump = false;  // 抓墙时跳跃</span></span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // 起跳</span><br><span class="line">    if (jumpPressDown &amp;&amp; collisionState.nearGround)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">        jumping = true;</span><br><span class="line"><span class="addition">+        climbingJump = false;</span></span><br><span class="line">        if (moveAfterJump)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetTrigger(&quot;Jump&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    // 爬墙</span><br><span class="line"><span class="addition">+    if (jumping &amp;&amp; collisionState.climbWall &amp;&amp; collisionState.GetPassable() &amp;&amp; Mathf.Abs(moveInput.normalized.x) &gt; 0.7 &amp;&amp; !climbingJump)</span></span><br><span class="line">    &#123;</span><br><span class="line">        climbing = true;</span><br><span class="line">        verticalVelocity = 0;</span><br><span class="line">        rightHandPosition.position = collisionState.GetClimbTouchPosition();</span><br><span class="line">        rightHandPosition.rotation = Quaternion.LookRotation(moveInput.x &gt; 0 ? Vector3.right : Vector3.left);</span><br><span class="line">        rightHandRig.weight = 1;</span><br><span class="line"><span class="addition">+        animator.SetBool(&quot;Climbing&quot;, climbing);</span></span><br><span class="line"><span class="addition">+        if (jumpPressDown)</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            rightHandRig.weight = 0;</span></span><br><span class="line"><span class="addition">+            verticalVelocity = climbingJumpSpeed;</span></span><br><span class="line"><span class="addition">+            animator.SetTrigger(&quot;ClimbingUp&quot;);</span></span><br><span class="line"><span class="addition">+            climbingJump = true;</span></span><br><span class="line"><span class="addition">+            climbing = false;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        climbing = false;</span><br><span class="line">        rightHandRig.weight = 0;</span><br><span class="line"><span class="addition">+        animator.SetBool(&quot;Climbing&quot;, climbing);</span></span><br><span class="line">    &#125;</span><br><span class="line">    // 落地</span><br><span class="line">    if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">        jumping = false;</span><br><span class="line"><span class="addition">+        climbingJump = false;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>感觉状态已经麻烦到难以管理了，是时候重构状态机了</p></blockquote><p><img src="/images/%E7%88%AC%E5%A2%99%E4%B8%8A%E5%B9%B3%E5%8F%B0.gif" class="lazyload" data-srcset="/images/%E7%88%AC%E5%A2%99%E4%B8%8A%E5%B9%B3%E5%8F%B0.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="爬墙上平台"></p><h3 id="11-瞄准射击">11. 瞄准射击</h3><h4 id="建模">建模</h4><p>首先打开blender</p><ol><li>创建一个圆柱1，按tab进入编辑模式，选中上表面，按s将上表面进行缩放，变成一个类似“圆锥”的东西</li><li>在圆锥上侧创建一个球，下侧创建一个圆柱2</li><li>使用布尔操作，球布尔Difference，圆柱2布尔Union（注意操作后隐藏球和圆柱）</li></ol><p><img src="/images/%E5%B8%83%E5%B0%94%E5%BB%BA%E6%A8%A12.gif" class="lazyload" data-srcset="/images/%E5%B8%83%E5%B0%94%E5%BB%BA%E6%A8%A12.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="布尔建模2"></p><p>于是得到了枪的建模（相当粗糙）</p><img src="/images/布尔建模.png" class="lazyload" data-srcset="/images/布尔建模.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="布尔建模" style="zoom:50%;" /><p>你可以为模型添加材质</p><img src="/images/模型材质.png" class="lazyload" data-srcset="/images/模型材质.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="模型材质" style="zoom:50%;" /><p>将模型导出至Unity后</p><img src="/images/Gun.png" class="lazyload" data-srcset="/images/Gun.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Gun" style="zoom:50%;" /><h4 id="持枪">持枪</h4><p>将枪放在左臂骨骼处，于是实现了左手和枪的绑死，播放动画时枪也跟着动，不过做的有些穿模</p><img src="/images/持枪2.png" class="lazyload" data-srcset="/images/持枪2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="持枪2" style="zoom:50%;" /><p>枪能随着手部正常运动</p><p><img src="/images/%E6%8C%81%E6%9E%AA%E5%8A%A8%E7%94%BB.gif" class="lazyload" data-srcset="/images/%E6%8C%81%E6%9E%AA%E5%8A%A8%E7%94%BB.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="持枪动画"></p><h4 id="瞄准">瞄准</h4><ol><li>动画状态机添加瞄准动画</li><li>Input System绑定左肩键为Aiming</li></ol><img src="/images/InputBumping.png" class="lazyload" data-srcset="/images/InputBumping.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="InputBumping" style="zoom:50%;" /><ol start="3"><li>为持枪的手臂添加Rig</li></ol><img src="/images/枪rig.png" class="lazyload" data-srcset="/images/枪rig.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="枪rig" style="zoom:50%;" /><ol start="4"><li>修改脚本<code>PlayerController.cs</code>，按下左肩键后手臂水平前举，根据左摇杆输入以角色左肩膀为圆心画圆，此外我希望瞄准时角色不要移动</li></ol><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+[SerializeField] private Transform gunHandPosition;</span></span><br><span class="line"><span class="addition">+[SerializeField] private Rig gunHandRig;</span></span><br><span class="line"><span class="addition">+[SerializeField] private Transform gunAimCenter;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;枪距离角色肩膀的距离&quot;)] private float gunToShoulderDistance = 2f;</span></span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">private bool jumpPressDown = false;</span><br><span class="line"><span class="addition">+private bool aiming = false;</span></span><br><span class="line">...</span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    jumpPressed = input.actions[&quot;Jump&quot;].IsPressed();</span><br><span class="line"><span class="addition">+    aiming = input.actions[&quot;Aim&quot;].IsPressed();</span></span><br><span class="line">...</span><br><span class="line">#region 水平移动</span><br><span class="line"></span><br><span class="line">    bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f;</span><br><span class="line">    if (isMoving &amp;&amp; !climbing)</span><br><span class="line">    &#123;</span><br><span class="line">        float herizontalSpeed = Mathf.Abs(moveInput.normalized.x * movementSpeed);</span><br><span class="line"></span><br><span class="line">        float hDir = moveInput.x &gt; 0 ? 1 : -1;</span><br><span class="line">        if (moveAfterJump)</span><br><span class="line">        &#123;</span><br><span class="line">            herizontalSpeed /= 2;   // 原地起跳，在空中动能很少，按理说应该走不动</span><br><span class="line">        &#125;</span><br><span class="line"><span class="addition">+        if (!aiming)</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line">            controller.Move(Vector3.right * hDir * herizontalSpeed * Time.deltaTime);</span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line">        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(moveInput.x != 0 ? Vector3.right * moveInput.normalized.x : Vector3.right * hDir), 0.1f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    animator.SetFloat(&quot;MoveInput&quot;, Mathf.Abs(moveInput.normalized.x * movementSpeed), 0.2f, Time.deltaTime);</span><br><span class="line">    #endregion</span><br><span class="line"></span><br><span class="line"><span class="addition">+    #region 瞄准射击</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    if (aiming)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+       Vector3 targetPos;</span></span><br><span class="line"><span class="addition">+        if (moveInput.magnitude &lt; 0.1f)</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;</span></span><br><span class="line"><span class="addition">+            targetPos = new Vector3(gunAimCenter.position.x + gunToShoulderDistance * hDir, gunAimCenter.position.y, gunAimCenter.position.z);</span></span><br><span class="line"><span class="addition">+            gunHandPosition.position = targetPos;</span></span><br><span class="line"><span class="addition">+            gunHandPosition.rotation = Quaternion.LookRotation(new Vector3(1,-1,0));</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        else</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;</span></span><br><span class="line"><span class="addition">+            targetPos = new Vector3(gunAimCenter.position.x + gunToShoulderDistance * moveInput.normalized.x, gunAimCenter.position.y + gunToShoulderDistance * moveInput.normalized.y, gunAimCenter.position.z);</span></span><br><span class="line"><span class="addition">+            gunHandPosition.position = targetPos;</span></span><br><span class="line"><span class="addition">+            gunHandPosition.rotation = Quaternion.LookRotation(targetPos - gunAimCenter.position);</span></span><br><span class="line"><span class="addition">+            gunHandPosition.Rotate(90f, 0f, 0f);</span></span><br><span class="line"><span class="addition">+ animator.SetBool(&quot;Aiming&quot;, true);</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        gunHandRig.weight = 0;</span></span><br><span class="line"><span class="addition">+ animator.SetBool(&quot;Aiming&quot;, false);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    #endregion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E7%9E%84%E5%87%86%E5%8A%A8%E7%94%BB.gif" class="lazyload" data-srcset="/images/%E7%9E%84%E5%87%86%E5%8A%A8%E7%94%BB.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="瞄准动画"></p><p>稍微有些生硬，不过另一只手之后要拿近战武器，所以还好。</p><h4 id="瞄准辅助线">瞄准辅助线</h4><p>在角色身上添加LineRenderer组件，设置组件的线Width、材质</p><img src="/images/线渲染器.png" class="lazyload" data-srcset="/images/线渲染器.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线渲染器" style="zoom:50%;" /><p>修改脚本<code>PlayerController.cs</code></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private CollisionState collisionState;</span><br><span class="line"><span class="addition">+private LineRenderer lineRenderer;</span></span><br><span class="line">...</span><br><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    collisionState = GetComponent&lt;CollisionState&gt;();</span><br><span class="line"><span class="addition">+    lineRenderer = GetComponent&lt;LineRenderer&gt;();</span></span><br><span class="line">&#125;</span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">if (aiming)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 targetPos;</span><br><span class="line"><span class="addition">+        Vector3 deltaPos;</span></span><br><span class="line">        if (moveInput.magnitude &lt; 0.1f)</span><br><span class="line">        &#123;</span><br><span class="line">            float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;</span><br><span class="line"><span class="addition">+            deltaPos = new Vector3(gunToShoulderDistance * hDir, 0, 0);</span></span><br><span class="line"><span class="addition">+            targetPos = gunAimCenter.position + deltaPos;</span></span><br><span class="line">            gunHandPosition.position = targetPos;</span><br><span class="line">            gunHandPosition.rotation = Quaternion.LookRotation(new Vector3(1,-1,0));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;</span><br><span class="line"><span class="addition">+            deltaPos = new Vector3(gunToShoulderDistance * moveInput.normalized.x, gunToShoulderDistance * moveInput.normalized.y, 0);</span></span><br><span class="line"><span class="addition">+            targetPos = gunAimCenter.position + deltaPos;</span></span><br><span class="line">            gunHandPosition.position = targetPos;</span><br><span class="line">            gunHandPosition.rotation = Quaternion.LookRotation(targetPos - gunAimCenter.position);</span><br><span class="line">            gunHandPosition.Rotate(90f, 0f, 0f);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="addition">+        lineRenderer.SetPositions(new []&#123;targetPos, targetPos + deltaPos * 12&#125;);</span></span><br><span class="line"><span class="addition">+        lineRenderer.enabled = true;</span></span><br><span class="line">        animator.SetBool(&quot;Aiming&quot;, true);</span><br><span class="line">        gunHandRig.weight = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"><span class="addition">+        lineRenderer.enabled = false;</span></span><br><span class="line">        gunHandRig.weight = 0;</span><br><span class="line">        animator.SetBool(&quot;Aiming&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/激光.png" class="lazyload" data-srcset="/images/激光.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="激光" style="zoom:50%;" /><h4 id="发射子弹">发射子弹</h4><ol><li><p>Input System将手柄X键绑定为Fire开火键</p></li><li><p>使用Sphere创建子弹预制体，注意关闭阴影、重力，材质我选用了一个自发光的半透明材质，并为子弹添加了一个碰撞层Bullet，同时设置其Tag为Bullet，碰撞体采用Trigger</p></li><li><p>编写子弹脚本<code>Bullet.cs</code>，子弹在碰撞到物体时会被销毁，超过一段时间后也会被销毁（具体的碰撞逻辑之后再写）</p></li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bullet</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;子弹销毁时间&quot;</span>)</span>] <span class="keyword">private</span> <span class="built_in">float</span> lifeTime = <span class="number">5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> remainingTime;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        remainingTime = lifeTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        remainingTime -= Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (remainingTime &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>编写子弹发射脚本<code>FireManager.cs</code></li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FireManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;子弹速度&quot;</span>)</span>] <span class="keyword">private</span> <span class="built_in">float</span> bulletSpeed = <span class="number">10f</span>;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;普通子弹&quot;</span>)</span>] <span class="keyword">private</span> GameObject commonBullet;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FireCommonBullet</span>(<span class="params">Vector3 initPosition, Quaternion initRotation</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject bullet = Instantiate(commonBullet, initPosition, initRotation);</span><br><span class="line">        bullet.GetComponent&lt;Rigidbody&gt;().AddForce(bullet.transform.forward * bulletSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>修改<code>PlayerController.cs</code></li></ol><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private LineRenderer lineRenderer;</span><br><span class="line"><span class="addition">+private FireManager fireManager;</span></span><br><span class="line">...</span><br><span class="line">private bool aiming = false;</span><br><span class="line"><span class="addition">+private bool firePressDown = false;</span></span><br><span class="line">...</span><br><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    lineRenderer = GetComponent&lt;LineRenderer&gt;();</span><br><span class="line"><span class="addition">+    fireManager = GetComponent&lt;FireManager&gt;();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">aiming = input.actions[&quot;Aim&quot;].IsPressed();</span><br><span class="line"><span class="addition">+    firePressDown = input.actions[&quot;Fire&quot;].WasPressedThisFrame();</span></span><br><span class="line">if (aiming)</span><br><span class="line">    &#123;</span><br><span class="line">        #region 瞄准动作</span><br><span class="line"></span><br><span class="line">        Vector3 targetPos;</span><br><span class="line">        Vector3 deltaPos;</span><br><span class="line">        if (moveInput.magnitude &lt; 0.1f)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line"><span class="addition">+        #region 射击</span></span><br><span class="line"><span class="addition">+        if (firePressDown)</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            fireManager.FireCommonBullet(targetPos, Quaternion.LookRotation(targetPos - gunAimCenter.position));</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        #endregion</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GIF的帧率太低了。。。</p></blockquote><p><img src="/images/%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9.gif" class="lazyload" data-srcset="/images/%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="发射子弹"></p><blockquote><p>注意，现在角色跳跃是也能射击，爬墙时也能射击，但是抓墙时不能自由射击，因为反向后角色会掉下来。我在考虑是否在跳跃时射击添加时停，抓墙时添加按左肩键可以自由射击，不会掉下来。</p><p>银河战士抓墙后不需要一直按左摇杆，可以自由射击，但银河战士是可以变成一格高的球的，有些狭小的管道正常姿势无法射击，于是设计了抓墙射击。而我不打算做变成球，我所有的通道都至少两格宽，很纠结</p></blockquote><h3 id="12-可被射击破环的方块">12. 可被射击破环的方块</h3><h4 id="方块预制体">方块预制体</h4><p>首先创建可被射击的方块预制体，拥有碰撞盒、VFX和一个脚本</p><img src="/images/可被射击方块.png" class="lazyload" data-srcset="/images/可被射击方块.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="可被射击方块" style="zoom:50%;" /><p>创建脚本<code>InteractiveCube.cs</code>，我希望当方块被子弹击中时会隐藏渲染和碰撞，并播放粒子效果，一段时间后再复原</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InteractiveCube</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> recoverTime = <span class="number">20f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> MeshRenderer meshRenderer;</span><br><span class="line">    <span class="keyword">private</span> Collider boxcollider;</span><br><span class="line">    <span class="keyword">private</span> VisualEffect visualEffect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentDeadTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        meshRenderer = GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">        boxcollider = GetComponent&lt;Collider&gt;();</span><br><span class="line">        visualEffect = GetComponent&lt;VisualEffect&gt;();</span><br><span class="line">        visualEffect.Stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collision other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.gameObject.CompareTag(<span class="string">&quot;Bullet&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            meshRenderer.enabled = <span class="literal">false</span>;</span><br><span class="line">            boxcollider.enabled = <span class="literal">false</span>;</span><br><span class="line">            visualEffect.Play();</span><br><span class="line">            currentDeadTime = recoverTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentDeadTime &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentDeadTime -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (currentDeadTime &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                meshRenderer.enabled = <span class="literal">true</span>;</span><br><span class="line">                boxcollider.enabled = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特效">特效</h4><blockquote><p>现在的特效是随便做的，之后要重写，我希望方块被射击会有破碎效果，复原时会有溶解效果</p><p>破碎效果使用Unity VFX插件</p></blockquote><p>首先去Package Manager安装Visual Effect Graph</p><p>右键Visual Effect——Visual Effect Graph，创建一个特效，双击后进入面板，配置为单次发射（Single Burst）、设置发射方向、粒子生命周期、添加重力</p><img src="/images/粒子特效.png" class="lazyload" data-srcset="/images/粒子特效.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="粒子特效" style="zoom:50%;" /><blockquote><p>有点绷不住了</p></blockquote><p><img src="/images/%E5%B0%84%E5%87%BB%E6%96%B9%E5%9D%97.gif" class="lazyload" data-srcset="/images/%E5%B0%84%E5%87%BB%E6%96%B9%E5%9D%97.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="射击方块"></p><h3 id="13-近战攻击">13. 近战攻击</h3><p>近战攻击相当复杂，我问了几个动作策划，给了我好几种方法：</p><ul><li>在武器上绑定胶囊体碰撞盒</li><li>在武器附近射线检测</li><li>在打击区域绘制方形碰撞盒</li><li>逐帧修改判定区域</li><li>怪物读玩家指令</li></ul><img src="/images/动作碰撞盒.jpg" class="lazyload" data-srcset="/images/动作碰撞盒.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="动作碰撞盒" style="zoom:50%;" /><p>在银河战士里，近战多用于反击远程单位（我的游戏也是这样设计的），感觉做成读指令会更方便。但我又想</p><h4 id="Timeline">Timeline</h4><blockquote><p>Timeline是Unity的时间线工具，常用于制作过场动画、相机蒙太奇，我们这里用来制作打击动作</p></blockquote><p>打开Timeline面板</p><img src="/images/timeline.png" class="lazyload" data-srcset="/images/timeline.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="timeline" style="zoom:50%;" /><p>为角色创建Timeline（此时角色身上会添加PlayableDirector组件），将近战动画clip拖入时间线中，并设置动画的Ease In/Out，这样可以使得Timeline动画和动画状态机的动画混合</p><img src="/images/easeInOut.png" class="lazyload" data-srcset="/images/easeInOut.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="easeInOut" style="zoom:50%;" /><blockquote><p>注意要关掉Timeline的Play On Awake</p></blockquote><p>我们在角色面前创建一个方形碰撞区域（有着Box Collider和锁死旋转和位移的Rigidbody），添加Tag为Hit，并默认设为unactive。</p><img src="/images/创建碰撞区域.png" class="lazyload" data-srcset="/images/创建碰撞区域.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="创建碰撞区域" style="zoom:50%;" /><img src="/images/碰撞区域.png" class="lazyload" data-srcset="/images/碰撞区域.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="碰撞区域" style="zoom:50%;" /><p>在Timeline中创建Control Track，在片段期间该物体将设为活跃，结束后恢复隐藏</p><p><img src="/images/timeline%E5%8A%A8%E4%BD%9C.png" class="lazyload" data-srcset="/images/timeline%E5%8A%A8%E4%BD%9C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="timeline动作"></p><p>点击播放键可以预览效果</p><h4 id="控制">控制</h4><p>修改脚本<code>PlayerController.cs</code></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private FireManager fireManager;</span><br><span class="line"><span class="addition">+private PlayableDirector director;</span></span><br><span class="line">...</span><br><span class="line">private bool firePressDown = false;</span><br><span class="line"><span class="addition">+private bool hitPressDown = false;</span></span><br><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="addition">+    director = GetComponent&lt;PlayableDirector&gt;();</span></span><br><span class="line">&#125;</span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="addition">+hitPressDown = input.actions[&quot;Hit&quot;].WasPressedThisFrame();</span></span><br><span class="line">...</span><br><span class="line"><span class="addition">+if (hitPressDown &amp;&amp; collisionState.onGround)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        director.Play();</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E8%BF%91%E6%88%98.gif" class="lazyload" data-srcset="/images/%E8%BF%91%E6%88%98.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="近战"></p><h3 id="14-可被近战破坏的方块">14. 可被近战破坏的方块</h3><p>修改脚本<code>InteractiveCube.cs</code></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+public enum CubeType</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+    Shoot,</span></span><br><span class="line"><span class="addition">+    Hit</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line">public class InteractibleCube : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    [SerializeField] private float recoverTime = 20f;</span><br><span class="line"><span class="addition">+    [SerializeField] private CubeType cubeType;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="addition">+    private string TagName</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        get</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            if(cubeType == CubeType.Shoot)</span></span><br><span class="line"><span class="addition">+                return &quot;Bullet&quot;;</span></span><br><span class="line"><span class="addition">+            else</span></span><br><span class="line"><span class="addition">+                return &quot;Hit&quot;;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">...</span><br><span class="line">    private void OnTriggerEnter(Collision other)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="addition">+        if (other.gameObject.CompareTag(TagName))</span></span><br><span class="line">        &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E8%BF%91%E6%88%98%E6%96%B9%E5%9D%97.gif" class="lazyload" data-srcset="/images/%E8%BF%91%E6%88%98%E6%96%B9%E5%9D%97.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="近战方块"></p><h3 id="15-零美术成本更换角色模型">15. 零美术成本更换角色模型</h3><blockquote><p>适合完全不会绑骨刷权重K帧的非美术，mmd的模型骨骼一般都十分复杂，并且和mixamo不一致</p></blockquote><p>去模之屋等网站获取mmd模型，导入blender中（详情可见blender mmd tools），个人建议选择短发角色</p><p>将角色姿态设为T Pose（你可以进入姿态模式，用手掰，可以放一个水平盒子当辅助线），T Pose很重要！</p><p>导出<strong>仅含网格</strong>的fbx模型</p><img src="/images/TPose.png" class="lazyload" data-srcset="/images/TPose.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TPose" style="zoom:50%;" /><p>打开mixamo，选择小红人，点击UPLOAD CHARACTOR（导入模型），按步骤完成</p><img src="/images/选择小红人.png" class="lazyload" data-srcset="/images/选择小红人.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="选择小红人" style="zoom:50%;" /><p>即可得到自动绑骨刷权重的角色模型，并能够完美使用mixamo的动画</p><img src="/images/mixamo导入模型.png" class="lazyload" data-srcset="/images/mixamo导入模型.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="mixamo导入模型" style="zoom:50%;" /><blockquote><p>我这里除了更换角色模型外，还使用了卡渲Shader和后效，网上关于卡渲的项目和教程相当多，这里就按下不表了</p></blockquote><p><img src="/images/%E6%9B%B4%E6%8D%A2%E8%A7%92%E8%89%B2%E6%A8%A1%E5%9E%8B.gif" class="lazyload" data-srcset="/images/%E6%9B%B4%E6%8D%A2%E8%A7%92%E8%89%B2%E6%A8%A1%E5%9E%8B.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="更换角色模型"></p><h3 id="16-地面敌人AI">16. 地面敌人AI</h3><blockquote><p>使用插件Behavior Trees，Asset Store 45刀，参考<a href="https://www.youtube.com/watch?v=X7VwAGvAOIw">空洞骑士BOSS战</a></p><p>敌人移动混用了DoTween插件和Charactor Controller</p><p>感觉这一节用文字讲好乏力。。。</p></blockquote><h4 id="创建角色单例">创建角色单例</h4><p>创建脚本<code>PlayerInfo.cs</code>，并将其绑定到Player上，该脚本控制了角色血量和是否处于无敌状态</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerInfo</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 单例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PlayerInfo instance;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PlayerInfo</span>()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Health &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = <span class="number">100f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Prop</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;处于无敌状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> invincible = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;无敌时间&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> invincibleTime = <span class="number">2f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;无敌时闪烁间隔时间&quot;</span>)</span>] </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> blinkTime = <span class="number">0.1f</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;角色渲染&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> SkinnedMeshRenderer playerRenderer;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Member</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无敌还剩多长时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentInvincibleTime = <span class="number">0f</span>;</span><br><span class="line">    <span class="comment">// 闪烁控制时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentBlinkTime = <span class="number">0.1f</span>;</span><br><span class="line">    <span class="comment">// 闪烁控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> blinkVisible = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PlayerInfo Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = FindObjectOfType&lt;PlayerInfo&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 PlayerPosition</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> transform.position;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HitPlayer</span>(<span class="params"><span class="built_in">float</span> damage, Vector3 enemyPosition</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invincible)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Vector3 moveDirection = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(enemyPosition.x &gt; transform.position.x)</span><br><span class="line">        &#123;</span><br><span class="line">            moveDirection.x = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            moveDirection.x = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gameObject.GetComponent&lt;CharacterController&gt;().Move(moveDirection);</span><br><span class="line">        Health -= damage;</span><br><span class="line">        currentInvincibleTime = invincibleTime;</span><br><span class="line">        currentBlinkTime = blinkTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(currentInvincibleTime &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            invincible = <span class="literal">true</span>;</span><br><span class="line">            currentInvincibleTime -= Time.deltaTime;</span><br><span class="line">            currentBlinkTime -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(currentBlinkTime &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                currentBlinkTime = blinkTime;</span><br><span class="line">                blinkVisible = !blinkVisible;</span><br><span class="line">                playerRenderer.enabled = blinkVisible;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            invincible = <span class="literal">false</span>;</span><br><span class="line">            playerRenderer.enabled = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建敌人">创建敌人</h4><p>创建脚本<code>EnemyInfo.cs</code>，并挂到敌人身上，此外敌人身上同时挂在Character Controller、Animator、Behaviour（这个稍后再讲）、BoxCollider（这个碰撞盒是用于被攻击的）</p><p>添加碰撞层Enemy，并将敌人设为Enemy（在项目设置中，设置Enemy和玩家不发生碰撞）</p><img src="/images/敌人信息2.png" class="lazyload" data-srcset="/images/敌人信息2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="敌人信息2" style="zoom:50%;" /><img src="/images/敌人信息.png" class="lazyload" data-srcset="/images/敌人信息.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="敌人信息" style="zoom:50%;" /><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyInfo</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxHealth = <span class="number">30.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentHealth;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> findPlayerDistance = <span class="number">10.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmos</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.color = Color.red;</span><br><span class="line">        Gizmos.DrawWireSphere(transform.position, findPlayerDistance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.tag == <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth -= other.GetComponent&lt;Bullet&gt;().damage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建敌人攻击碰撞球">创建敌人攻击碰撞球</h4><blockquote><p>我们将敌人受攻击（Box）、敌人和场景的碰撞（CC）、敌人攻击玩家的碰撞（Sphere）分开了</p></blockquote><p>为敌人创建一个子物体叫HitSphere，拥有一个球形碰撞盒和一个碰撞处理脚本，该碰撞球用于攻击玩家</p><p>添加碰撞层EnemyHit，该碰撞层仅和玩家碰撞</p><img src="/images/HitSphere.png" class="lazyload" data-srcset="/images/HitSphere.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="HitSphere" style="zoom:50%;" /><p>创建脚本<code>EnemyHitCube.cs</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyHitCube</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> playerInfo = other.GetComponent&lt;PlayerInfo&gt;();</span><br><span class="line">        <span class="keyword">if</span> (playerInfo != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            playerInfo.HitPlayer(<span class="number">10</span>, transform.position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建行为树">创建行为树</h4><p>寻找敌人后打开Behaviour Designer面板，添加任意行为后敌人身上会出现一个Behaviour Tree组件</p><p><img src="/images/%E8%A1%8C%E4%B8%BA%E6%A0%91.png" class="lazyload" data-srcset="/images/%E8%A1%8C%E4%B8%BA%E6%A0%91.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="行为树"></p><p>行为树是由一个个节点组成，当这些节点被执行时，会向其父节点返回执行成功、失败、正在执行等结果</p><ul><li><p>Repeater表示循环执行（我开启了无限循环）</p></li><li><p>Selector是一个或组件，其子节点从左向右开始执行，只要有一个为成功，则返回成功</p></li><li><p>Sequence表示顺序执行，其子节点从左向右执行，直到一个节点返回失败</p></li></ul><p>我为怪物添加了三个行为：</p><ol><li>血量小于0时<code>IsHealthUnder</code>，播放死亡动画，并销毁GameObject</li><li>否则<ol><li>若敌人周围有玩家<code>IsFindPlayer</code>，则追逐玩家<code>EnemyPursuit</code></li><li>否则在周围徘徊<code>EnemyMove</code></li></ol></li></ol><h4 id="创建敌人行为和条件基类">创建敌人行为和条件基类</h4><p>创建脚本<code>EnemyAction.cs</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyAction</span> : <span class="title">Action</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Animator animator;</span><br><span class="line">    <span class="keyword">protected</span> EnemyInfo info;</span><br><span class="line">    <span class="keyword">protected</span> CharacterController controller;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnAwake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        info = GetComponent&lt;EnemyInfo&gt;(); </span><br><span class="line">        controller = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建脚本<code>EnemyConditional.cs</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyConditional</span>: <span class="title">Conditional</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> EnemyInfo info;</span><br><span class="line">    <span class="keyword">protected</span> Animator animator;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnAwake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        info = GetComponent&lt;EnemyInfo&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建角色移动、追击、死亡行为">创建角色移动、追击、死亡行为</h4><p>创建脚本<code>EnemyMove.cs</code>，该脚本能使得敌人左右徘徊</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyMove</span> : <span class="title">EnemyAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> SharedBool lookRight;</span><br><span class="line">    <span class="keyword">public</span> SharedFloat currentMoveTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveUseTime = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> rotateUseTime = <span class="number">0.5f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Tween rotateTween;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TaskStatus <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> direction = lookRight.Value ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        currentMoveTime.Value += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (currentMoveTime.Value &gt; moveUseTime)</span><br><span class="line">        &#123;</span><br><span class="line">            lookRight.Value = !lookRight.Value;</span><br><span class="line">            currentMoveTime.Value = <span class="number">0</span>;</span><br><span class="line">            rotateTween = DOVirtual.DelayedCall(<span class="number">0</span>, () =&gt; transform.DORotateQuaternion(Quaternion.LookRotation(Vector3.right * -direction), rotateUseTime), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        controller.Move(Vector3.right * direction * moveSpeed * Time.deltaTime);</span><br><span class="line">        <span class="keyword">return</span> TaskStatus.Success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建脚本<code>EnemyPursuit.cs</code>，该脚本能使得敌人向玩家追击</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyPursuit</span> : <span class="title">EnemyAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> rotateUseTime = <span class="number">0.5f</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TaskStatus <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> direction = PlayerInfo.Instance.PlayerPosition.x &gt; transform.position.x ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        DOVirtual.DelayedCall(<span class="number">0</span>, () =&gt; transform.DORotateQuaternion(Quaternion.LookRotation(Vector3.right * direction), rotateUseTime), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        controller.Move(Vector3.right * direction * moveSpeed * Time.deltaTime);</span><br><span class="line">        <span class="keyword">return</span> TaskStatus.Success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建脚本<code>EnemyDead.cs</code>，该脚本能使敌人死亡</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyDead</span> : <span class="title">EnemyAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> deadDelayTime = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isDeadFinish = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        DOVirtual.DelayedCall(deadDelayTime, () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Object.Destroy(gameObject);</span><br><span class="line">            isDeadFinish = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TaskStatus <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> isDeadFinish ? TaskStatus.Success : TaskStatus.Running;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建敌人行为条件">创建敌人行为条件</h4><p>创建脚本<code>IsFindPlayer.cs</code>，该脚本用于判断敌人周围是否有角色，如果是刚刚发现，会出发一段动画</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IsFindPlayer</span> : <span class="title">EnemyConditional</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> SharedBool firstFindPlayer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TaskStatus <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((transform.position - PlayerInfo.Instance.PlayerPosition).magnitude &lt; info.findPlayerDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstFindPlayer.Value)</span><br><span class="line">            &#123;</span><br><span class="line">                animator.SetTrigger(<span class="string">&quot;FindPlayer&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            firstFindPlayer.Value = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> TaskStatus.Success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            firstFindPlayer.Value = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> TaskStatus.Failure;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建脚本<code>IsHealthUnder.cs</code>，该脚本用于判断角色血量是否低于某个数值</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IsHealthUnder</span> : <span class="title">EnemyConditional</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> underNumber = <span class="number">0f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TaskStatus <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.currentHealth &lt;= underNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TaskStatus.Success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TaskStatus.Failure;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果">效果</h4><p><img src="/images/%E6%80%AA%E7%89%A9AI.gif" class="lazyload" data-srcset="/images/%E6%80%AA%E7%89%A9AI.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="怪物AI"></p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有意思的代码</title>
      <link href="/program/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>/program/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1>有意思的代码</h1><p>记录一下平时遇到的有意思的代码，不定期更新</p><h3 id="在注释中的立方体">在注释中的立方体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="number">001</span>-----<span class="number">-101</span></span><br><span class="line">   / |     / |</span><br><span class="line">  /  |    /  |</span><br><span class="line"><span class="number">011</span>-----<span class="number">-111</span> |</span><br><span class="line"> |  <span class="number">000</span>--|-<span class="number">-100</span></span><br><span class="line"> |  /    |  /</span><br><span class="line"> | /     | /</span><br><span class="line"><span class="number">010</span>-----<span class="number">-110</span></span><br></pre></td></tr></table></figure><h3 id="消除未使用变量">消除未使用变量</h3><blockquote><p>有人会认为C++的警告（Warming）等同于报错，于是会通过一些宏关掉一些警告</p></blockquote><p>将变量转化为void类型，相当于明确告诉编译器我不打算使用这个变量，消除“变量未使用”的警告</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNUSED(x) (void)(x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="built_in">UNUSED</span>(x);<span class="comment">// 不使用x</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SWIG实现Python调用C++</title>
      <link href="/program/python%E8%B0%83%E7%94%A8C++/"/>
      <url>/program/python%E8%B0%83%E7%94%A8C++/</url>
      
        <content type="html"><![CDATA[<h1>SWIG实现Python调用C++</h1><p>在实际项目开发中，我们经常有跨语言交互的需求，比如使用Python/Lua脚本调用引擎代码。常用的方案有很多，我们来介绍SWIG</p><table><thead><tr><th></th><th>语言</th><th>特点</th></tr></thead><tbody><tr><td>C++/CLI</td><td>C++和C#</td><td>微软为.NET平台高度定制的拓展，允许C++调用托管代码</td></tr><tr><td>SWIG</td><td>多语言</td><td>跨平台多语言，需要写<code>.i</code>文件，有一定侵入性</td></tr><tr><td>Boost</td><td>Python和C++</td><td></td></tr><tr><td>JNI</td><td>Java和C++</td><td></td></tr></tbody></table><h2 id="SWIG">SWIG</h2><h3 id="简介">简介</h3><p>SWIG（Simplified Wrapper and Interface Generato）是一种包装器，通过配置<code>.i</code>文件，自动生成Wrapper文件，以实现其他语言调用C++代码</p><h3 id="Interface-file">Interface file</h3><p><code>.i</code>文件格式如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 模块名</span></span><br><span class="line">%<span class="keyword">module</span> example</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 头文件和声明</span></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_controller.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">%&#125;</span><br><span class="line"><span class="comment">// 引用其他.i文件</span></span><br><span class="line">%include &lt;windows.i&gt;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. swig特性</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 代码拓展</span></span><br><span class="line"><span class="comment">// 将C++中的bool数组封装为BoolArray类</span></span><br><span class="line">%<span class="built_in">array_class</span>(<span class="type">bool</span>, BoolArray);</span><br><span class="line"><span class="comment">// 将C++中的std::vector&lt;std::string&gt;封装为StringVector类，所有vector向量都应该像这样封装</span></span><br><span class="line">%<span class="built_in">template</span>(StringVector) std::vector&lt;std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 要包装的内容，可以用头文件全部包装</span></span><br><span class="line"><span class="comment">// 特别注意，.h文件要按依赖顺序从上到下排布！</span></span><br><span class="line">%include <span class="string">&quot;example.h&quot;</span></span><br><span class="line">%include <span class="string">&quot;example_controller.h&quot;</span></span><br></pre></td></tr></table></figure><h3 id="环境安装">环境安装</h3><blockquote><p>我的环境是Mac M1，安装了brew和python3</p></blockquote><ol><li>安装swig</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install swig</span><br></pre></td></tr></table></figure><ol start="2"><li>检测是否安装成功</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swig -version</span><br></pre></td></tr></table></figure><h2 id="样例代码">样例代码</h2><p>实现了在python中调用C++定义的<code>add</code>函数</p><ol><li>C++代码</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>SWIG代码</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.i</span></span><br><span class="line">%<span class="keyword">module</span> example</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%include <span class="string">&quot;example.h&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>执行命令，我们会生成一个<code>.py</code>文件和一个<code>.cxx</code>文件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swig -c++ -python example.i</span><br></pre></td></tr></table></figure><ol start="4"><li>为了方便使用，我们将生成的<code>.py</code>文件构建为<code>.so</code>文件，创建一个setup.py文件，使用<a href="https://docs.python.org/3/library/distutils.html">distutils</a>进行编译</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setup.py</span></span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">example_module = Extension(<span class="string">&#x27;_example&#x27;</span>,</span><br><span class="line">                           sources=[<span class="string">&#x27;example_wrap.cxx&#x27;</span>, <span class="string">&#x27;example.cpp&#x27;</span>],</span><br><span class="line">                           )</span><br><span class="line"> </span><br><span class="line">setup (name = <span class="string">&#x27;example&#x27;</span>,</span><br><span class="line">       version = <span class="string">&#x27;0.1&#x27;</span>,</span><br><span class="line">       author      = <span class="string">&quot;SWIG Docs&quot;</span>,</span><br><span class="line">       description = <span class="string">&quot;&quot;&quot;Simple swig example from docs&quot;&quot;&quot;</span>,</span><br><span class="line">       ext_modules = [example_module],</span><br><span class="line">       py_modules = [<span class="string">&quot;example&quot;</span>],</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><p>执行命令，即会生成一些文件，其中包含一个<code>.so</code>文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><ol start="5"><li>将<code>.so</code>文件放入环境变量中（不推荐），或者放在python脚本同一个目录中（推荐），即可被调用</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example_test.py</span></span><br><span class="line"><span class="keyword">import</span> example</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用C++函数</span></span><br><span class="line">result = example.add(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;3 + 4 =&quot;</span>, result)</span><br></pre></td></tr></table></figure><h2 id="C-包装">C++包装</h2><h3 id="函数">函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.i</span></span><br><span class="line">%<span class="keyword">module</span> example</span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line">%include <span class="string">&quot;example.h&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example_test.py</span></span><br><span class="line"><span class="keyword">import</span> example</span><br><span class="line"><span class="comment"># 调用C++函数</span></span><br><span class="line">result = example.add(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;3 + 4 =&quot;</span>, result)</span><br></pre></td></tr></table></figure><h3 id="常量">常量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.i</span></span><br><span class="line">%<span class="keyword">module</span> example</span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159265358979323846</span></span><br><span class="line">%constant <span class="type">int</span> Foo = <span class="number">42</span>;</span><br><span class="line">%constant <span class="type">const</span> <span class="type">char</span> *path = <span class="string">&quot;/usr/local/include&quot;</span>;</span><br><span class="line"></span><br><span class="line">%include <span class="string">&quot;example.h&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example_test.py</span></span><br><span class="line"><span class="keyword">import</span> example</span><br><span class="line"><span class="built_in">print</span>(example.PI)<span class="comment"># 3.141592653589793</span></span><br><span class="line"><span class="built_in">print</span>(example.path)<span class="comment"># /usr/local/include</span></span><br></pre></td></tr></table></figure><h3 id="结构体">结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example_test.py</span></span><br><span class="line"><span class="keyword">import</span> example</span><br><span class="line"></span><br><span class="line">p = example.Point()</span><br><span class="line">p.x = <span class="number">1</span></span><br><span class="line">p.y = <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="类">类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSize</span><span class="params">(<span class="type">double</span> s)</span> </span>&#123; size = s;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example_test.py</span></span><br><span class="line"><span class="keyword">import</span> example</span><br><span class="line"></span><br><span class="line">s = example.Shape()</span><br><span class="line">s.setSize(<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(s.getSize())</span><br></pre></td></tr></table></figure><h2 id="资料">资料</h2><p><a href="https://www.swig.org/Doc4.1/SWIGDocumentation.html#Python">SWIG 4.1 Doc</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CXX </tag>
            
            <tag> SWIG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FBX SDK入门</title>
      <link href="/dcc/FbxSDK/"/>
      <url>/dcc/FbxSDK/</url>
      
        <content type="html"><![CDATA[<h1>FBX SDK</h1><p>FBX是一种主流的三维模型格式，格式闭源，但可以通过免费的FBX SDK编辑模型</p><h2 id="开发环境">开发环境</h2><ul><li>Visual Studio 2019</li><li>Cmake</li><li>安装<a href="https://www.autodesk.com/developer-network/platform-technologies/fbx-sdk-2020-3-4">FBX SDK</a>，我根据环境安装的是2020 VS2019</li></ul><h2 id="样例">样例</h2><p>VS项目中使用FBX SDK需要配置大量的头文件dll，比较复杂，可以参考<a href="https://help.autodesk.com/view/FBX/2020/ENU/?guid=FBX_Developer_Help_getting_started_installing_and_configuring_configuring_the_fbx_sdk_for_wind_html">配置FBX SDK</a></p><p>个人建议直接使用cmake构建官方样例，在官方代码上进行修改</p><img src="/images/FBX样例.PNG" class="lazyload" data-srcset="/images/FBX样例.PNG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="FBX样例"  /><p>在FBX SDK的安装文件夹中找到samples文件夹，选择一个样例进入，在有CMakeLists.txt的路径打开cmd，输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -G <span class="string">&quot;Visual Studio 16&quot;</span></span><br></pre></td></tr></table></figure><p>即会生成一个VS2019项目，打开构建、运行即可</p><h2 id="资料">资料</h2><p><a href="https://help.autodesk.com/view/FBX/2020/ENU/?guid=FBX_Developer_Help_welcome_to_the_fbx_sdk_html">FBX SDK 2020 文档</a></p>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FBX </tag>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Physically Based Shading at Disney</title>
      <link href="/graphics/DisneyBRDF/"/>
      <url>/graphics/DisneyBRDF/</url>
      
        <content type="html"><![CDATA[<h1>《Physically Based Shading at Disney》阅读笔记</h1><p>2012年SIGGRAPH，迪士尼提出了迪士尼规则的基于物理的渲染，立刻成为行业标准，被各大游戏厂商和游戏引擎所采用</p><blockquote><p>本文采用第一人称，我们是指迪士尼</p></blockquote><h2 id="介绍">介绍</h2><p>当时场景渲染还在使用ad-hoc着色模型和punctual灯光，我们渴望一套<strong>一致性</strong>的、美术友好的着色模型。受毛发渲染启发，我们推出了符合迪士尼规则的PBR模型。</p><p>迪士尼PBR模型提供了多种不同的渲染方程，但美术不需要关心渲染的底层逻辑，不需要针对不同的方程调整参数。</p><h2 id="微表面模型">微表面模型</h2><p>BRDF（双向反射分布函数）表示反射光与入射光的能量关系，是某方向出射光辐射率（Radiance）和入射光辐照度（Irradiance）的比值。</p><p>微表面模型认为材质表面由无数个理想镜面排列组成，如果某个观察方向上能观察到反射光，那么必然有一些微表面，他们的法线能平分入射光方向和观察方向（几何光学），我们将这些微表面的法线方向称为半向量（half vector）。顾名思义，半向量是入射光和观察方向的一半。<br>$$<br>\mathbf{h}=\frac{\mathbf{l}+\mathbf{v}}{|\mathbf{l}+\mathbf{v}|}<br>$$<br><img src="/images/microfacet.png" class="lazyload" data-srcset="/images/microfacet.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="microfacet" style="zoom:50%;" /></p><p>一个各向同性的BRDF模型如下，由菲涅尔项、微表面法线分布项、几何遮挡项组成<br>$$<br>\rho\left(\mathbf{l}, \mathbf{v} \right)= \mathrm{diffuse} +  \frac{F\left( \theta_d \right) D\left( \theta_h \right) G\left( \theta_l,\theta_v \right) }{ 4\cos\theta_l\cos\theta_v}<br>$$</p><ul><li>$\theta_d$是入射光和半向量的夹角，d是difference的意思</li><li>$\theta_h$是半向量和法线的夹角</li><li>$\theta_l$是入射光和法线的夹角</li><li>$\theta_v$是观察方向和法线的夹角</li></ul><h2 id="BRDF可视化">BRDF可视化</h2><p>我们制作了一个BRDF可视化工具，并将扫描材质转化为Image slice</p><img src="/images/image-slice.png" class="lazyload" data-srcset="/images/image-slice.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-slice" style="zoom:50%;" /><ul><li>在最底侧$\theta_d=0$，入射光和视线重合</li><li>在最左侧$\theta_h=0$，视线位于反射最强烈的部分，是高光项</li><li>在最上侧$\theta_d$最大，模拟光线射到材质边缘是的菲涅尔现象</li></ul><h2 id="观察材质">观察材质</h2><h3 id="漫反射项">漫反射项</h3><p>漫反射是灯光进入材质后经过折射、散射后重新发散到材质外部的过程。BRDF并没有考虑光线进出材质的位置变化，没有模拟次表面散射。</p><p>下图为随着$\theta_h$的增大，反射强度的衰减程度，光滑材质反射强度衰减的极快。而粗糙材质就比较慢，甚至有些材质的反射强度与方向无关。部分粗糙材质在掠射角有菲涅尔现象</p><p><img src="/images/%E5%85%89%E6%BB%91%E4%B8%8E%E7%B2%97%E7%B3%99%E6%9D%90%E8%B4%A8%E7%9A%84D%E9%A1%B9.png" class="lazyload" data-srcset="/images/%E5%85%89%E6%BB%91%E4%B8%8E%E7%B2%97%E7%B3%99%E6%9D%90%E8%B4%A8%E7%9A%84D%E9%A1%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="光滑与粗糙材质的D项"></p><p>微表面理论认为材质表面由大量理想镜面组成，光线呈掠射角入射时，入射光线与模型边缘的一些“竖直的”微表面相遇，使许多光发生了反射，形成了菲涅尔效应，更多的能量被用于反射，而非散射。</p><h3 id="微表面法线分布项">微表面法线分布项</h3><p>微表面项描述了沿着半向量方向的微表面占总面积的比例。对于光滑材质，大多数微表面法线与宏观法线方向一致，随着$\theta_h$增大，面积会迅速减少，而粗糙材质减少就很慢，有着更长的尾部。</p><p>下图左为GGX（红）、Beckmann（绿）、Blinn Phong（蓝，注意和绿重叠了）、chrome（黑）四种D项的描述，右图从左到右分别为点光照射chrome、GGX、Beckmann项的结果。</p><p><img src="/images/%E8%A7%82%E5%AF%9FD%E9%A1%B9.png" class="lazyload" data-srcset="/images/%E8%A7%82%E5%AF%9FD%E9%A1%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="观察D项"></p><h3 id="高光菲涅尔项">高光菲涅尔项</h3><p>菲涅尔项描述了光线发生反射和折射的比例，当光线由光疏材质射向光密材质时，随着入射角的增大，反射会越来越强。对于光滑材质，掠射角时菲涅尔项接近100%，对于粗糙材质，尽管无法达到100%，但也增长迅速。</p><img src="/images/air-to-glass.png" class="lazyload" data-srcset="/images/air-to-glass.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="air-to-glass" style="zoom: 50%;" /><img src="/images/高光菲涅尔.png" class="lazyload" data-srcset="/images/高光菲涅尔.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="高光菲涅尔" style="zoom:50%;" /><p>人们发现有些材质的菲涅尔曲线在掠射角处比菲尼尔方程预测的更陡峭，为此引入了几何遮挡项，该项将方法菲涅尔效应。</p><h3 id="几何遮挡项">几何遮挡项</h3><p>实践中难以测量出几何遮挡项，于是是通过先测量出F项和D项，再计算出G项。</p><p>Smith根据D项推导出了一种G项，不过Smith的G项仅再某些情况下有解析式，大部分情况下使用预积分+图表的方式近似。</p><h2 id="迪士尼BRDF">迪士尼BRDF</h2><h3 id="材质参数">材质参数</h3><p>参数直观、数量少，参数范围通常在0~1但允许超出范围，所有参数组合都是鲁棒合理的</p><table><thead><tr><th>参数名称</th><th>含义</th></tr></thead><tbody><tr><td>baseColor</td><td>基础色</td></tr><tr><td>subsurface</td><td>通过次表面控制漫反射形状</td></tr><tr><td>metallic</td><td>金属度，所有材质是金属和非电介质根据金属度的混合，0为非金属，1为金属</td></tr><tr><td>specular</td><td>incident specular amount.  This is in lieu of an explicit index-of-refraction</td></tr><tr><td>specularTint</td><td>美术可以通过该参数将高光色调向基础色</td></tr><tr><td>roughness</td><td>粗糙度</td></tr><tr><td>anisotropic</td><td>各项异性比，用于控制高光形状，0为各项同性，1为各项异性</td></tr><tr><td>sheen</td><td>光泽，用于布料渲染</td></tr><tr><td>sheenTint</td><td>美术可以通过该参数将光泽调向基础色</td></tr><tr><td>clearcoat</td><td>薄膜图层的高光色</td></tr><tr><td>clearcoatGloss</td><td>薄膜图层的粗糙度</td></tr></tbody></table><img src="/images/迪士尼材质.png" class="lazyload" data-srcset="/images/迪士尼材质.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="迪士尼材质" style="zoom:67%;" /><h3 id="漫反射模型">漫反射模型</h3><p>漫反射的本质是光线进入材质后重新射出，因此至少发生了两次折射，于是有两个菲涅尔项。这两个菲涅尔还能让材质边缘变亮。<br>$$<br>\rho_d=\frac{baseColor}{\pi}(1+(F_{D90}-1)(1-\cos \theta_l)^5)(1+(F_{D90}-1)(1-\cos \theta_v)^5)<br>$$</p><p>$$<br>F_{D90}=0.5+2roughness\cos^2\theta_d<br>$$</p><h3 id="高光D项">高光D项</h3><p>我们认为目前最流行的GGX拖尾仍不够长，最后选择了GTR<br>$$<br>D_{GTR}=c/(\alpha^2\cos^2\theta_h+\sin^2\theta_h)^{\gamma}<br>$$</p><ul><li>$c$：缩放常数</li><li>$\alpha$：粗糙度参数，0为光滑，1为完全粗糙</li></ul><img src="/images/GTR.png" class="lazyload" data-srcset="/images/GTR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GTR" style="zoom:50%;" /><h3 id="高光F项">高光F项</h3><p>$$<br>F_{\mathrm{Schlick}}=F_0+(1-F_0)(1-\cos\theta_d)^5<br>$$</p><h3 id="高光G项">高光G项</h3><p>使用GGX模型作为G项，但对粗糙度进行映射<br>$$<br>\alpha_g=(0.5+roughness/2)^2<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PBR </tag>
            
            <tag> SIGGRAPH 2012 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法线切线次切线的计算</title>
      <link href="/graphics/%E6%B3%95%E7%BA%BF%E5%88%87%E7%BA%BF%E6%AC%A1%E5%88%87%E7%BA%BF/"/>
      <url>/graphics/%E6%B3%95%E7%BA%BF%E5%88%87%E7%BA%BF%E6%AC%A1%E5%88%87%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1>法线切线次切线的计算</h1><h3 id="顶点法线的计算">顶点法线的计算</h3><p>模型顶点构成了多个三角面，使用三角面的顶点坐标等得到两条边的向量，求两个向量的叉积能够得到（归一化的）<strong>面法线</strong>。<br>$$<br>\mathbf{N}=\frac{(\mathbf{P}_1-\mathbf{P}_0)\times(\mathbf{P}_2-\mathbf{P}_0)}{||(\mathbf{P}_1-\mathbf{P}_0)\times(\mathbf{P}_2-\mathbf{P}_0)||}<br>$$<br>点的顺序与法线方向满足右手螺旋定则，点呈顺逆时针时法线垂直直面向外。</p><img src="/images/triangle.png" class="lazyload" data-srcset="/images/triangle.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="triangle" style="zoom:50%;" /><p>顶点法线可以在DCC中手动指定，也可以用面法线做平滑着色。一般来说某个顶点会参与构成多个三角面，选取这些三角面的面法线做算术平均值，这个过程被称为平滑着色。</p><blockquote><p>硬边上的点属于不同的平滑组，在计算法线时不能平均，在导出时会被拆分为互相重叠的点，各自拥有一个法线、纹理坐标。</p></blockquote><p>如果对未经过归一化的面法线求均值，能实现含权重的顶点法线，三角面面积越大，影响越强。</p><h3 id="切线空间">切线空间</h3><p>为了得到更高精度的法线，我们会使用切线空间的法线贴图，对顶点法线进行扰动。</p><p>切线空间由三个基向量组成，分别为切线$X$、次切线$Y$、法线$Z$，这三个基向量不一定正交，但视为正交。</p><p>在不进行扰动时，切线空间的法线为$(0,0,1)$，是顶点法线的方向。切线和次切线所形成的平面与物体表面相切，方向与UV有关，但存在偏差。</p><img src="/images/切线空间.png" class="lazyload" data-srcset="/images/切线空间.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="切线空间" style="zoom:50%;" /><p>三个向量可以构成TBN矩阵，该矩阵能将切线空间法线转化为物体空间/世界空间<br>$$<br>\begin{bmatrix}T_{x}&amp;B_{x}&amp;N_{x}\\ T_{y}&amp;B_{y}&amp;N_{y}\\ T_{z}&amp;B_{z}&amp;N_{z}\end{bmatrix}<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">float3 normalValue = normalTexture.<span class="built_in">sample</span>(textureSampler, uv * params.tiling).xyz * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">        normal = <span class="built_in">float3x3</span>(tangentWS, bitangentWS, normalWS) * normalValue;</span><br></pre></td></tr></table></figure><h3 id="计算切线和次切线">计算切线和次切线</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> triangleCount = indices.Count / <span class="number">3</span>;</span><br><span class="line">List&lt;float3&gt; sDirList;</span><br><span class="line">List&lt;float3&gt; tDirList;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; triangleCountl; ++i)&#123;</span><br><span class="line">  <span class="comment">// 三角形的三个顶点</span></span><br><span class="line">  <span class="type">int</span> vertexID0 = indices[i * <span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> vertexID1 = indices[i * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">  <span class="type">int</span> vertexID2 = indices[i * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 顶点UV</span></span><br><span class="line">  float2 uv0 = uvs[vertexID0];</span><br><span class="line">  float2 uv1 = uvs[vertexID1];</span><br><span class="line">  float2 uv2 = uvs[vertexID2];</span><br><span class="line">  <span class="comment">// 顶点坐标</span></span><br><span class="line">  float3 pos0 = positions[vertexID0];</span><br><span class="line">  float3 pos1 = positions[vertexID1];</span><br><span class="line">  float3 pos2 = positions[vertexID2];</span><br><span class="line">  <span class="comment">// UV差值</span></span><br><span class="line">  float2 s = <span class="built_in">float2</span>(uv1.x - uv0.x, uv2.x - uv0.x);</span><br><span class="line">  float2 t = <span class="built_in">float2</span>(uv1.y - uv0.y, uv2.y - uv0.y);</span><br><span class="line">  <span class="comment">// 坐标差值</span></span><br><span class="line">  float3 deltaPos0 = pos1 - pos0;</span><br><span class="line">  float3 deltaPos1 = pos2 - pos0;</span><br><span class="line">  <span class="type">float</span> r = <span class="number">1.0f</span> / (s.x * t.y - s.y * t.x);</span><br><span class="line">  float3 sDir = <span class="built_in">float3</span>(</span><br><span class="line">    r* (t.y * deltaPos0.x - t.x * deltaPos1.x),</span><br><span class="line">    r* (t.y * deltaPos0.y - t.x * deltaPos1.y),</span><br><span class="line">    r* (t.y * deltaPos0.z - t.x * deltaPos1.z)</span><br><span class="line">  );</span><br><span class="line">  float3 tDir = <span class="built_in">float3</span>(</span><br><span class="line">  r* (-s.y * deltaPos0.x + s.x * deltaPos1.x),</span><br><span class="line">    r* (-s.y * deltaPos0.y + s.x * deltaPos1.y),</span><br><span class="line">    r* (-s.y * deltaPos0.z + s.x * deltaPos1.z)</span><br><span class="line">  );</span><br><span class="line">  tDirList[vertexID0] += tDir;</span><br><span class="line">  tDirList[vertexID1] += tDir;</span><br><span class="line">  tDirList[vertexID2] += tDir;</span><br><span class="line">  sDirList[vertexID0] += sDir;</span><br><span class="line">  sDirList[vertexID1] += sDir;</span><br><span class="line">  sDirList[vertexID2] += sDir;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertexCount; ++i)&#123;</span><br><span class="line">  float3 normal = normals[vertexID0];</span><br><span class="line">  float3 tDir = tDirList[i];</span><br><span class="line">  <span class="comment">// 切线</span></span><br><span class="line">  float3 tangent = tDir - <span class="built_in">dot</span>(normal, tDir);</span><br><span class="line">  <span class="comment">// 次切线</span></span><br><span class="line">  float3 bitangent = <span class="built_in">cross</span>(normal, tangent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="https://zhuanlan.zhihu.com/p/139593847">切线空间（Tangent Space）完全解析</a></p><p>《3D游戏与计算机图形学中的数学方法》</p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac开发环境配置</title>
      <link href="/program/mac%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/program/mac%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1>Mac开发环境配置</h1><blockquote><p>前几天遇到一个问题，某个VPN软件开启后无法正常关闭，而强行关闭后并没有还原网络配置，导致我只有开着VPN才能连接网络，一时间没有好的办法，于是将Mac重装了系统，记录一下环境配置，没准以后还会用到</p></blockquote><blockquote><p>我的设备是Macbook Air M1，主要用于Metal开发和写博客</p></blockquote><h2 id="Mac重装系统">Mac重装系统</h2><ol><li>重要文件注意备份（放在iCloud最方便）</li><li>在关机状态下长按电源键，此时会提示你继续长按进入启动选项</li><li>你会看到两个启动选项，一个是当前系统的启动盘，一个是齿轮形状的选项</li><li>进入选项，进入磁盘工具，选择要抹除的内容盘，点右上角的抹除</li><li>回到齿轮选项界面，点击重装macOS，这个过程需要联网</li><li>等待即可</li></ol><h2 id="基础开发环境">基础开发环境</h2><h3 id="brew">brew</h3><p>MacOS最常用的包管理器，用于下载各种开发环境、软件、三方库</p><p>出于网络原因，建议使用国内镜像安装，打开终端输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure><p>按输出操作即可</p><h3 id="Python3">Python3</h3><p>安装brew后输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install python3</span><br></pre></td></tr></table></figure><p>不仅仅是python，可以说大部分的环境都可以用<code>brew install xxx</code>安装</p><h2 id="常用工具">常用工具</h2><h3 id="Xcode">Xcode</h3><blockquote><p>免费使用，但是打包需要付费账户</p></blockquote><p>无需多说，Mac上开发必备环境，可以直接去App Store安装，值得注意的是，商店里的Xcode是最新版，需要你的系统保持最新</p><h3 id="Typora">Typora</h3><blockquote><p>付费，15刀永久</p></blockquote><p>一款所见即所得的markdown编辑器，界面简洁优美，而且对latex等支持非常好</p><img src="/images/typora2.png" class="lazyload" data-srcset="/images/typora2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="typora" style="zoom:50%;" /><p>安装激活后打开某个markdown文件，选中后按<code>command+i</code>打开简介，配置该类文件的打开方式</p><img src="/images/typora.png" class="lazyload" data-srcset="/images/typora.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="typora" style="zoom:50%;" /><p>此外最好也配置一下图片的引用方式，比如使用相对路径，自动复制到文件夹之类的</p><h3 id="GitKraken">GitKraken</h3><blockquote><p>学生免费，公共仓库免费，商用私有仓库订阅收费</p></blockquote><p>最好的图形界面，功能齐全，看diff也十分方便</p><p><img src="/images/gitkraken.png" class="lazyload" data-srcset="/images/gitkraken.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="gitkraken"></p><p>LFS功能需要单独安装，在终端输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install git-lfs</span><br></pre></td></tr></table></figure><h3 id="VS-Code">VS Code</h3><blockquote><p>免费</p></blockquote><p>无需多说，一个完美的文本编辑器，如果你不安装VS Code，很有可能用Xcode打开一些文件</p><h4 id="Github-Copilot">Github Copilot</h4><blockquote><p>学生免费</p></blockquote><p>强烈建议安装，编程效率提升数倍，不会使用AI的程序员必然被AI取代</p><p>在一个Python脚本中，我刚输入md5，就帮我写好了代码</p><img src="/images/CopilotMD5.png" class="lazyload" data-srcset="/images/CopilotMD5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CopilotMD5" style="zoom:50%;" /><h3 id="右键助手">右键助手</h3><blockquote><p>免费，App Store搜索即可</p></blockquote><p>我只使用了少量功能，比如新建文件，在当前路径打开终端</p><img src="/images/右键助手.png" class="lazyload" data-srcset="/images/右键助手.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="右键助手" style="zoom:50%;" /><h3 id="Hidden-Bar">Hidden Bar</h3><blockquote><p>免费，App Store搜索即可</p></blockquote><p>用于折叠顶部图标，眼不见心不烦</p><p><img src="/images/HiddenBar.png" class="lazyload" data-srcset="/images/HiddenBar.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="HiddenBar"></p><h3 id="ClashX">ClashX</h3><blockquote><p>免费，开源，当然订阅需要自己去找</p></blockquote><p>一个非常好用的VPN软件</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Character Creator 插件开发</title>
      <link href="/dcc/Character%20Creator/"/>
      <url>/dcc/Character%20Creator/</url>
      
        <content type="html"><![CDATA[<h1>Character Creator 插件开发</h1><blockquote><p>最近在CC 4/iClone 8开发Python插件，真的是小刀拉屁股，开了眼了，都不知道该从哪里开始吐槽，如果说maya脚本开发叫恶心，CC脚本开发就是阴间</p><ul><li>去年CC 4发布，改动了大量API，大部分API都变成Experimental API，之前（指五六年前）的样例代码大多失效，并不不再维护（不会改你可以不改）</li><li>官方文档简陋无比，大部分函数和参数没有用法和解释，写满了<code># No example</code></li><li>给官方发邮件（这是花了钱的）问Python相关的东西，官方只会复读“脚本还在开发，可能有功能不全，你可以尝试去论坛问”</li><li>官方论文发言需要审核，我提了两个问题都被拒绝发布（我发邮件你让我去论坛，我去论坛你堵我嘴）</li><li>脚本功能不全，有些功能可以读写，有些是只读（像maya你的每一步操作都是由命令实现的，甚至会在窗口将当前命令输出出来）</li></ul></blockquote><h2 id="介绍">介绍</h2><p>Character Creator是reallusion推出的一款商业捏脸软件，可以制作表情动作、动作捕捉等。使用成本比较高，大部分公司都不会使用，网上的信息远少于Maya、3DMax这类DCC。</p><p><img src="/images/cc.png" class="lazyload" data-srcset="/images/cc.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cc"></p><p>CC支持使用Python编写脚本、插件，可以通过顶部导航栏中<code>Script--Load Python</code>加载脚本，通过<code>Script--Console Log </code>打开Log面板，不过这个Log面板远不如Maya的面板信息齐全。</p><p>iClone是该公司的另一款软件，用于制作动画，功能与CC十分接近，可以参考<a href="https://wiki.reallusion.com/IC8_Python_API:Modules">iClone的文档</a>编写插件</p><h2 id="环境配置">环境配置</h2><blockquote><p>可以参考maya python脚本的环境配置，当时使用的是PyCharm，这里我们使用VS Code</p></blockquote><ol><li>VS Code安装Python插件</li></ol><p><img src="/images/vscode-python.PNG" class="lazyload" data-srcset="/images/vscode-python.PNG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="vscode-python"></p><ol start="2"><li>选择Python解释器（按<code>ctrl+shift+p</code>打开命令界面）</li></ol><p><img src="/images/python%E8%A7%A3%E9%87%8A%E5%99%A8.PNG" class="lazyload" data-srcset="/images/python%E8%A7%A3%E9%87%8A%E5%99%A8.PNG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="python解释器"></p><p><img src="/images/python%E8%A7%A3%E9%87%8A%E5%99%A82.PNG" class="lazyload" data-srcset="/images/python%E8%A7%A3%E9%87%8A%E5%99%A82.PNG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="python解释器2"></p><h2 id="编写脚本">编写脚本</h2><blockquote><p>脚本本身不难写，主要是文档和论坛信息太少，某些API的使用可以参考<a href="https://wiki.reallusion.com/IC8_Python_API:Modules">iClone的文档</a>，下面是我认为值得处理的东西</p></blockquote><h3 id="创建带有按钮的窗口">创建带有按钮的窗口</h3><p>加载脚本后会出现一个对话框，对话框中有一个Label和一个按钮，当按按钮时可以输出”Hello World“</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RLPy</span><br><span class="line"><span class="keyword">from</span> shiboken2 <span class="keyword">import</span> wrapInstance</span><br><span class="line"><span class="keyword">from</span> PySide2 <span class="keyword">import</span> QtWidgets</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似于main函数，是脚本的入口，加载脚本时自动执行该函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_script</span>():</span><br><span class="line">    <span class="comment"># 创建一个对话框</span></span><br><span class="line">    rl_dialog = RLPy.RUi.CreateRDialog()</span><br><span class="line">    <span class="comment"># 设置对话框名称</span></span><br><span class="line">    rl_dialog.SetWindowTitle(<span class="string">&quot;Main Dialog&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pyside_dialog = wrapInstance(<span class="built_in">int</span>(rl_dialog.GetWindow()), QtWidgets.QDialog)</span><br><span class="line">    <span class="comment"># 设置对话框宽度</span></span><br><span class="line">    pyside_dialog.setFixedWidth(<span class="number">200</span>)</span><br><span class="line">    sample_layout = pyside_dialog.layout()</span><br><span class="line"><span class="comment"># 一个Label</span></span><br><span class="line">    label_hello = QtWidgets.QLabel(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="comment"># 一个Button</span></span><br><span class="line">    button_run = QtWidgets.QPushButton(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    <span class="comment"># Button绑定事件函数 run</span></span><br><span class="line">    button_run.clicked.connect(run)</span><br><span class="line"></span><br><span class="line">    sample_layout.addWidget(label_hello)</span><br><span class="line">    sample_layout.addWidget(button_run)</span><br><span class="line"></span><br><span class="line">    rl_dialog.Show()</span><br></pre></td></tr></table></figure><p><img src="/images/cc_dialog.jpg" class="lazyload" data-srcset="/images/cc_dialog.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cc_dialog"></p><h3 id="定时任务">定时任务</h3><p>定时任务十分重要，通过开启计时，就会定时执行<code>Timeout()</code>内到操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计时器回调</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimerCallback</span>(RLPy.RPyTimerCallback):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        RLPy.RPyTimerCallback.__init__(self)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Timeout</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="comment"># 类似于Update</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Timeout&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># timer，计时器应当放在全局</span></span><br><span class="line">timer = RLPy.RPyTimer()</span><br><span class="line"><span class="comment"># 设置间隔为 1000 ms</span></span><br><span class="line">timer.SetInterval(<span class="number">1000</span>) </span><br><span class="line"><span class="comment"># 定时器设为可以重复触发</span></span><br><span class="line">timer.SetSingleShot(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 注册事件</span></span><br><span class="line">timer_callback = TimerCallback()</span><br><span class="line">timer.RegisterPyTimerCallback(timer_callback)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply</span>():</span><br><span class="line">    <span class="comment"># 开始计时</span></span><br><span class="line">    timer.Start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cancel</span>():</span><br><span class="line">    <span class="comment"># 暂停计时</span></span><br><span class="line">    timer.Stop()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_script</span>():</span><br><span class="line">    <span class="comment"># menu</span></span><br><span class="line">    rl_dialog = RLPy.RUi.CreateRDialog()</span><br><span class="line">    rl_dialog.SetWindowTitle(<span class="string">&quot;main_dialog&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pyside_dialog = wrapInstance(<span class="built_in">int</span>(rl_dialog.GetWindow()), QtWidgets.QDialog)</span><br><span class="line">    pyside_dialog.setFixedWidth(<span class="number">200</span>)</span><br><span class="line">    sample_layout = pyside_dialog.layout()</span><br><span class="line"></span><br><span class="line">    button_apply = QtWidgets.QPushButton(<span class="string">&quot;Apply&quot;</span>)</span><br><span class="line">    button_apply.clicked.connect(apply)</span><br><span class="line">    button_cancel = QtWidgets.QPushButton(<span class="string">&quot;Cancel&quot;</span>)</span><br><span class="line">    button_cancel.clicked.connect(cancel)</span><br><span class="line"></span><br><span class="line">    sample_layout.addWidget(button_apply)</span><br><span class="line">    sample_layout.addWidget(button_cancel)</span><br><span class="line"></span><br><span class="line">    rl_dialog.Show()</span><br></pre></td></tr></table></figure><h3 id="导出当前模型">导出当前模型</h3><blockquote><p>官网甚至还在用iClone7的老东西误导你，太可恶了！</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">export</span>():</span><br><span class="line">  <span class="comment"># 获取当前场景所有的人物模型（一般只有一个）</span></span><br><span class="line">    all_avatars = RLPy.RScene.GetAvatars(RLPy.EAvatarType_All)</span><br><span class="line">    avatar_name = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> _iter_avatar <span class="keyword">in</span> all_avatars:</span><br><span class="line">        avatar_name = _iter_avatar.GetName()</span><br><span class="line">    avatar = RLPy.RScene.FindObject(RLPy.EObjectType_Avatar, avatar_name)</span><br><span class="line">    <span class="comment"># 导出选项</span></span><br><span class="line">    export_option = RLPy.EExportFbxOptions__None</span><br><span class="line">    export_option2 = RLPy.EExportFbxOptions2__None</span><br><span class="line">    export_option3 = RLPy.EExportFbxOptions3__None</span><br><span class="line">    export_option = export_option | RLPy.EExportFbxOptions_AutoSkinRigidMesh</span><br><span class="line">    export_option2 = export_option2 | RLPy.EExportFbxOptions2_ResetBoneScale</span><br><span class="line">    original_size = RLPy.EExportTextureSize_Original</span><br><span class="line">    default_format = RLPy.EExportTextureFormat_Default </span><br><span class="line"></span><br><span class="line">    setting = RLPy.RExportFbxSetting()</span><br><span class="line">    setting.SetOption(export_option)</span><br><span class="line">    setting.SetOption2(export_option2)</span><br><span class="line">    setting.SetOption3(export_option3)</span><br><span class="line">    setting.SetTextureSize(original_size)</span><br><span class="line">    setting.SetTextureFormat(default_format)</span><br><span class="line">    setting.EnableExportMotion(<span class="literal">True</span>)<span class="comment"># 开启动画导出，启动后默认导出当前Pose</span></span><br><span class="line">setting.SetExportMotionFps(RLRy.RFps(<span class="number">60</span>))<span class="comment"># 设置导出动画的帧率，会影响动画数据的精度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 导出文件</span></span><br><span class="line">    result = RLPy.RFileIO.ExportFbxFile(avatar, <span class="string">f&quot;D://Art/man/<span class="subst">&#123;file_name&#125;</span>.fbx&quot;</span>, setting)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Success export fbx&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Export error&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银河战士like</title>
      <link href="/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike/"/>
      <url>/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike/</url>
      
        <content type="html"><![CDATA[<h1>银河战士like</h1><h2 id="银河战士">银河战士</h2><p>我接触银河战士比较晚，还是NS OLED发售时才了解这款游戏，结果上手后立即爱不释手，连续玩了三四天才把普通难度打通。这个游戏的关卡设计给了我极其深刻的印象，我就像做理综试卷一样，揣摩设计者的意图，在没有明确引导的情况下也能找到下一步的目标。</p><p>自此一直想做一个类似的游戏，但做了一两年引擎TA后，对策划和GamePlay已经一窍不通了，最近发现Mix-Jim做过Metroid的教程，于是燃起了我做独立游戏的热情，在这里记录一下（2023.4.5），等到毕设做完后就着手开发。</p><p>我玩银河战士的心态变化就是：</p><p>初始关卡玩家惯性思维向右走，结果发现走到了头，走不动了，然而他惊奇地发现，人物居然能往左走！</p><p>走到左边发现还是走不到，有一个小台阶，台阶上面有个宝箱，然后玩家惊讶得发现，人物居然能跳！</p><p>打开宝箱后你获得了一个能力，但你还不知道是什么，你继续往左走，看到一个房间，房间门太矮了，你过不去，然后你发现，你刚刚获得的能力是变成球！</p><p>靠这种润物细无声的方式，你最后得到了一切，打败了boss，游戏通关，然后告诉你主角是一个比基尼美女，你通关越快，她游戏结束时穿的越裸露！</p><p>你想看裸体吗？赶快二周目吧！</p><h2 id="剧情">剧情</h2><h3 id="游戏剧情">游戏剧情</h3><p>【逆熵科技】宣布打破了能量守恒定律，发明了【无尽能源】，并在某地建造了全球最大的发电厂。奇怪的是，这个发电厂没有人类员工，也不需要输送原材料，更没有污染排放，就能为全世界提供电力，仿佛他们真的发明了无尽能源。随着时间的推移，该发电厂成为地球上最重要也最神秘的设施。</p><p>你是一名特警，你在调查一系列【超自然现象】引发的事件，这个事件已经导致多个城市的毁灭，大量生物的绝种，绝症发病率的倍增。经过多年的研究，你发现自从发电厂出现后，超自然事件的发生频率大幅提高，并且事件发生地仿佛以电厂为中心放射分布，于是你申请调查电厂。</p><p>不出意外，电厂的调查令并没有批准，你的调查进入僵局，有人暗示你放弃调查。然而一天晚上，电厂出现了事故，收到了求救信号，你作为最近的警官到达了现场，结果却看到非常诡异的画面，电厂的外观变成了【xxx】</p><p>你进入电厂后电厂大门立刻锁死，随即又遇到了机械怪物，手枪子弹完全无法伤害他们。你逃到一个房间里，发现了【xxx】，你的手枪接触后形状发生改变，能无需弹药发射脉冲子弹，可以对怪物造成伤害。</p><p>你在电厂不断探索，获得了多种【超自然力量】，最后找到求救信息的来源，结果你发现信号来自一扇门，而这个门一直在向外输送能量。</p><h3 id="背景">背景</h3><p>门的那头连接着一个平行世界，那个世界是一个魔法的世界，构成世界的基础物质中有【魔力】的存在，而那个世界正面临着【魔力短缺】的现象。</p><p>【魔力】有高能和低能之分，就像我们世界的能量一样，【魔力】由高到低，可以对现实产生影响，被称为【魔法】，而随着【魔法】的普及与滥用，他们世界的【魔力】质量越来越差，他们越来越难以使用魔法。</p><p>为了缓解【魔力短缺】，他们向我们这个世界开启了一道门，这个门在将我们世界的物质搬运到他们世界。这个过程影响了双方世界的稳定，我们的世界沉默的【魔力】得到苏醒，引发了基础粒子的分裂，【魔力】吸收了原子释放的部分核能，而其他能量被【逆熵科技】用于发电。传送门将被激化的【魔力】送至他们世界，。</p><p>看似双赢，我们得到了能量，他们得到了【魔力】，实则双输。</p><ul><li><p>对于我们</p><ul><li>部分【魔力】停留在我们世界中，引起了【超自然现象】，产生了大量次生灾害。</li><li>由于我们世界的生物、环境在演变过程中没有【魔力】，因此这些【魔力】无法被我们所使用，反而像辐射一样在破坏我们的细胞结构，影响了人类生存。</li></ul></li><li><p>对于他们</p><ul><li>吸收核能的【魔力】强度过高，而且传送门的位置不像我们这样集中在一个门中，现在他们世界任意一个地方都有可能发生一场小型核爆，可能在天空，可能在地底，也可能在某个人肚子里。他们的世界就像经历核战争一样，到处都是废墟和坑洞。</li></ul></li></ul><p>他们世界大部分设施被摧毁，没有能力关闭传送门，于是他们只能向我们世界发送消息，希望我们可以关闭或改善这个流程，拯救两个世界</p><h3 id="设定">设定</h3><p>电厂被魔化为活物，于是方块被破环后会修复</p><p>电厂具有自我保护意识，当核心被抢夺/破环时会召唤boss杀死入侵者（角色拿到一个增强时会进入boss战）</p><h2 id="开发计划">开发计划</h2><h3 id="角色">角色</h3><ul><li>跑</li><li>跳<ul><li>快跳（跑起来跳）</li><li>慢跳（原地起跳，横向移动速度比跑跳慢一半）</li></ul></li><li>抓墙（差一点点就能跳上的平台，如果手能抓住平台上部，可以抓在墙上）<ul><li>上平台（抓在墙上按跳跃能上平台）</li></ul></li><li>瞄准射击（按做肩键开启瞄准设计模式，用红线瞄准）<ul><li>射击为红色激光</li><li>按右肩键开启畏缩射击模式，伤害能低，但小怪被击中后会畏缩</li></ul></li><li>近战攻击（两段光剑挥砍，一次从下向上，一次从上向下，第二段后期可以解锁剑气）<ul><li>近战为蓝色光剑</li></ul></li><li>跟随镜头</li><li>无敌时间<ul><li>被攻击时会触发，角色有菲涅尔描边，此时角色和敌人不会有碰撞</li></ul></li></ul><h3 id="场景物体">场景物体</h3><ul><li>普通方块（白色方块）</li><li>可被设计破环的方块<ul><li>破环前不可通行，破环后可以通行，方块被破环后20秒会复原，恢复时有融解恢复特效</li><li>射击破环方块（红色方块）<ul><li>破环时有粒子溅射特效</li></ul></li><li>近战破环方块（蓝色方块）<ul><li>方块破环时播放破碎动画</li></ul></li></ul></li></ul><h3 id="敌人">敌人</h3><ul><li>小怪<ul><li>怪物与角色接触时会向后击飞角色，并给角色0.5秒的无敌时间</li><li>飞行怪物<ul><li>一次仅会有一个飞行怪物攻击角色，并有明显的攻击前摇</li><li>前摇攻击时能被近战一击必杀</li><li>被畏缩畏缩后会变成一个垫脚石，不再移动，可以被踩踏，20秒后复原</li></ul></li><li>地面怪物<ul><li>地面角色有一个出生点，平时在出生点左右移动，看到角色后会向角色方向追击</li><li>当追击失去视线后，会回到出生点附近，并恢复所有生命</li><li>当被畏缩射击后会停止移动一段时间，但角色踩上仍会扣血</li></ul></li></ul></li><li>Boss<ul><li>当角色每拿到一个强化，镜头、手柄开始震动，然后boss出现</li><li>boss总是可以被刚刚拿到的强化克制</li><li>击败boss后会增强角色的最大生命值</li></ul></li></ul><h3 id="场景管理">场景管理</h3><ul><li>以（0，0，0）为原点，并设为二维平面的左下角，将场景切分为一个个1x1x1方块组成的世界</li><li>分层管理</li><li>场景要能导出为scriptableobject</li></ul><h3 id="场景编辑">场景编辑</h3><ul><li>Gizmos绘制场景网格，其中每五格加粗（id % 5 == 0）</li><li>摆放吸附</li><li>根据起始和终止位置批量生成物体</li></ul><h3 id="地图">地图</h3><ul><li>地图作为单独的全屏界面，目前不打算在游戏屏幕上绘制小地图</li><li>地图包含两级缩放<ul><li>全局地图（展示的是关卡间的关系）</li><li>局部地图（展示的是当前关卡的信息，每一个方块都要被绘制）</li></ul></li></ul><h3 id="渲染">渲染</h3><ul><li><p>尽量使用URP内置的功能</p></li><li><p>角色要单独写Shader，支持开关菲涅尔描边</p></li><li><p>全局动态Light Probe，均匀摆放Probe，可以用odin写一个批量摆放插件，注意不要进墙</p></li><li><p>色调映射和Lut调色</p></li><li><p>SSAO</p></li><li><p>抗锯齿</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Simplygon插件尝鲜</title>
      <link href="/dcc/Simplygon/"/>
      <url>/dcc/Simplygon/</url>
      
        <content type="html"><![CDATA[<h1>Simplygon插件尝鲜</h1><blockquote><p>出于性能等考虑，大型项目往往会使用LOD功能，根据相机距离切换模型精度。而海量的3D模型靠人力拆分LOD显然过于昂贵，因此非常有必要使用模型减面工具，所幸业界已经有非常成熟的商业插件，比如InstaLOD和Simplygon，对于个人开发者，Simplygon提供每日200次的免费使用次数，足够用了</p></blockquote><h2 id="安装">安装</h2><blockquote><p>环境为Windows系统+支持Vulkan的显卡</p></blockquote><ol><li>安装<a href="https://aka.ms/vs/17/release/vc_redist.x64.exe">VC Redist</a>，这个组件包含了Visual C++的运行时库，VC项目正常运行需要该组件</li><li>安装<a href="https://sdk.lunarg.com/sdk/download/latest/windows/vulkan-sdk.exe">Vulkan SDK</a></li><li>下载<a href="https://downloads.simplygon.com/SimplygonSDK_10.1.8000.0.exe">Simplygon</a></li><li>选择Free License激活，每个微软账号能有一个Seat，每日200次使用次数</li></ol><img src="/images/simplygon.png" class="lazyload" data-srcset="/images/simplygon.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="simplygon" style="zoom:50%;" /><h2 id="第一个项目">第一个项目</h2><blockquote><p>以C#控制台实现模型减面为例</p></blockquote><ol><li>Visual Studio创建一个.Net控制台项目</li></ol><p><img src="/images/%E6%96%B0%E5%BB%BACSharp%E9%A1%B9%E7%9B%AE.png" class="lazyload" data-srcset="/images/%E6%96%B0%E5%BB%BACSharp%E9%A1%B9%E7%9B%AE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="新建CSharp项目"></p><ol start="2"><li>添加COM依赖，引入转义文件<code>SimplygonDotNetWapper.dll</code></li></ol><img src="/images/添加COM依赖.png" class="lazyload" data-srcset="/images/添加COM依赖.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="添加COM依赖" style="zoom: 80%;" /><p><img src="/images/Simplygon%E4%BE%9D%E8%B5%96.png" class="lazyload" data-srcset="/images/Simplygon%E4%BE%9D%E8%B5%96.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Simplygon依赖"></p><ol start="3"><li>在项目中添加<code>SimplygonLoader.cs</code>和减面用的模型</li></ol><p><img src="/images/Loader%E4%BD%8D%E7%BD%AE.png" class="lazyload" data-srcset="/images/Loader%E4%BD%8D%E7%BD%AE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Loader位置"></p><p><img src="/images/%E6%B7%BB%E5%8A%A0Loader.png" class="lazyload" data-srcset="/images/%E6%B7%BB%E5%8A%A0Loader.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="添加Loader"></p><ol start="4"><li>编写代码，实现模型按比例减面</li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查是否Load Simplygon</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> sg = Simplygon.Loader.InitSimplygon(<span class="keyword">out</span> <span class="keyword">var</span> errorCode, <span class="keyword">out</span> <span class="keyword">var</span> errorMessage);</span><br><span class="line">    <span class="keyword">if</span> (errorCode != Simplygon.EErrorCodes.NoError)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Failed to initialize Simplygon: ErrorCode(<span class="subst">&#123;(<span class="built_in">int</span>)errorCode&#125;</span>) <span class="subst">&#123;errorMessage&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">int</span>)errorCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 运行减面程序</span></span><br><span class="line">    RunReduction(sg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunReduction</span>(<span class="params">Simplygon.ISimplygon sg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 加载模型/场景         </span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Load scene to process.&quot;</span>);</span><br><span class="line">    Simplygon.spScene sgScene = LoadScene(sg, <span class="string">&quot;../../../SimplygonMan.obj&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">using</span> Simplygon.spReductionProcessor sgReductionProcessor = sg.CreateReductionProcessor();</span><br><span class="line">    sgReductionProcessor.SetScene(sgScene);</span><br><span class="line">    <span class="keyword">using</span> Simplygon.spReductionSettings sgReductionSettings = sgReductionProcessor.GetReductionSettings();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减面设置</span></span><br><span class="line">    sgReductionSettings.SetReductionTargets(Simplygon.EStopCondition.All, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 三角面变为50%</span></span><br><span class="line">    sgReductionSettings.SetReductionTargetTriangleRatio(<span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行        </span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Start the reduction process.&quot;</span>);</span><br><span class="line">    sgReductionProcessor.RunProcessing();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存模型，通过修改后缀可以实现导出obj, fbx, usd等类型的模型         </span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Save processed scene.&quot;</span>);</span><br><span class="line">    SaveScene(sg, sgScene, <span class="string">&quot;Output.obj&quot;</span>);</span><br><span class="line">       </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Check log for any warnings or errors.&quot;</span>);</span><br><span class="line">    CheckLog(sg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Simplygon.<span class="function">spScene <span class="title">LoadScene</span>(<span class="params">Simplygon.ISimplygon sg, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create scene importer </span></span><br><span class="line">    <span class="keyword">using</span> Simplygon.spSceneImporter sgSceneImporter = sg.CreateSceneImporter();</span><br><span class="line">    sgSceneImporter.SetImportFilePath(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run scene importer. </span></span><br><span class="line">    <span class="keyword">var</span> importResult = sgSceneImporter.Run();</span><br><span class="line">    <span class="keyword">if</span> (Simplygon.Simplygon.Failed(importResult))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.Exception(<span class="string">&quot;Failed to load scene.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Simplygon.spScene sgScene = sgSceneImporter.GetScene();</span><br><span class="line">    <span class="keyword">return</span> sgScene;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveScene</span>(<span class="params">Simplygon.ISimplygon sg, Simplygon.spScene sgScene, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create scene exporter. </span></span><br><span class="line">    <span class="keyword">using</span> Simplygon.spSceneExporter sgSceneExporter = sg.CreateSceneExporter();</span><br><span class="line">    <span class="built_in">string</span> outputScenePath = <span class="built_in">string</span>.Join(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;output\\&quot;</span>, <span class="string">&quot;Reduction&quot;</span>, <span class="string">&quot;_&quot;</span>, path &#125;);</span><br><span class="line">    sgSceneExporter.SetExportFilePath(outputScenePath);</span><br><span class="line">    sgSceneExporter.SetScene(sgScene);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run scene exporter. </span></span><br><span class="line">    <span class="keyword">var</span> exportResult = sgSceneExporter.Run();</span><br><span class="line">    <span class="keyword">if</span> (Simplygon.Simplygon.Failed(exportResult))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.Exception(<span class="string">&quot;Failed to save scene.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckLog</span>(<span class="params">Simplygon.ISimplygon sg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check if any errors occurred. </span></span><br><span class="line">    <span class="built_in">bool</span> hasErrors = sg.ErrorOccurred();</span><br><span class="line">    <span class="keyword">if</span> (hasErrors)</span><br><span class="line">    &#123;</span><br><span class="line">        Simplygon.spStringArray errors = sg.CreateStringArray();</span><br><span class="line">        sg.GetErrorMessages(errors);</span><br><span class="line">        <span class="keyword">var</span> errorCount = errors.GetItemCount();</span><br><span class="line">        <span class="keyword">if</span> (errorCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Errors:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">uint</span> errorIndex = <span class="number">0</span>; errorIndex &lt; errorCount; ++errorIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> errorString = errors.GetItem((<span class="built_in">int</span>)errorIndex);</span><br><span class="line">                Console.WriteLine(errorString);</span><br><span class="line">            &#125;</span><br><span class="line">            sg.ClearErrorMessages();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No errors.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if any warnings occurred. </span></span><br><span class="line">    <span class="built_in">bool</span> hasWarnings = sg.WarningOccurred();</span><br><span class="line">    <span class="keyword">if</span> (hasWarnings)</span><br><span class="line">    &#123;</span><br><span class="line">        Simplygon.spStringArray warnings = sg.CreateStringArray();</span><br><span class="line">        sg.GetWarningMessages(warnings);</span><br><span class="line">        <span class="keyword">var</span> warningCount = warnings.GetItemCount();</span><br><span class="line">        <span class="keyword">if</span> (warningCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Warnings:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">uint</span> warningIndex = <span class="number">0</span>; warningIndex &lt; warningCount; ++warningIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> warningString = warnings.GetItem((<span class="built_in">int</span>)warningIndex);</span><br><span class="line">                Console.WriteLine(warningString);</span><br><span class="line">            &#125;</span><br><span class="line">            sg.ClearWarningMessages();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No warnings.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error out if Simplygon has errors. </span></span><br><span class="line">    <span class="keyword">if</span> (hasErrors)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.Exception(<span class="string">&quot;Processing failed with an error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行，检查减面效果</li></ol><p>减面前：</p><p><img src="/images/%E5%87%8F%E9%9D%A2%E5%89%8D.png" class="lazyload" data-srcset="/images/%E5%87%8F%E9%9D%A2%E5%89%8D.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="减面前"></p><p>50%减面</p><p><img src="/images/%E5%87%8F%E9%9D%A2%E5%90%8E.png" class="lazyload" data-srcset="/images/%E5%87%8F%E9%9D%A2%E5%90%8E.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="减面后"></p><p>10%减面</p><p><img src="/images/%E5%87%8F%E9%9D%A210.png" class="lazyload" data-srcset="/images/%E5%87%8F%E9%9D%A210.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="减面10"></p><p>能看出三角面和顶点数按比例减少了</p><blockquote><p>在使用过程中，发现相同精度的模型，fbx顶点数比obj小，是两者顶点buffer组织的差异导致的吗？还是Win11自带的模型预览器统计方式有问题</p></blockquote><h2 id="其他功能">其他功能</h2><p>Simplygon还提供了许多功能，除了基础的静态模型减面生成LOD外，还支持人物模型LOD（保留权重），骨骼缩减，远景、树草替代物生成（如Billboard），遮蔽物减面，详情可以参考<a href="https://documentation.simplygon.com/SimplygonSDK_10.1.8000.0/api/examples/gettingstarted.html#prerequisites">官方文档</a>，这里仅抛砖引玉</p>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blender MMD Tools安装</title>
      <link href="/dcc/BlenderMMD/"/>
      <url>/dcc/BlenderMMD/</url>
      
        <content type="html"><![CDATA[<h1>Blender MMD Tools</h1><blockquote><p>尽管实际工作中不会使用MMD，甚至也很少使用Blender，但对于自学的同学来说，MMD可能是网上资源最丰富的模型资源，尤其是国内二次元手游厂商，十分乐于分享人物模型</p></blockquote><h2 id="安装">安装</h2><ol><li>安装Blender</li><li>下载<a href="https://github.com/UuuNyaa/blender_mmd_tools/releases">blender_mmd_tools插件</a>，下载压缩包即可</li><li>安装插件</li></ol><p><img src="/images/blenderMMD1.jpg" class="lazyload" data-srcset="/images/blenderMMD1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blenderMMD1"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Edit &gt; Perferences &gt; Add-ons &gt; Install &gt; 选择第二步下载的压缩包</span><br></pre></td></tr></table></figure><ol start="4"><li>激活插件，找到导入的插件，点亮左边的checkbox即可</li></ol><p><img src="/images/blenderMMD2.jpg" class="lazyload" data-srcset="/images/blenderMMD2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blenderMMD2"></p><ol start="5"><li>当你看到如下内容，说明安装成功（这个小箭头确实不明显，容易找不到）</li></ol><p><img src="/images/blenderMMD3.jpg" class="lazyload" data-srcset="/images/blenderMMD3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blenderMMD3"></p><ol start="6"><li>点击下图的Import即可导入模型和动画，在mmd面板可以导出mmd信息，使用blender的File可以导出obj、fbx等模型</li></ol><p><img src="/images/blenderMMD4.jpg" class="lazyload" data-srcset="/images/blenderMMD4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blenderMMD4"></p><h2 id="资料">资料</h2><ul><li><a href="https://polyhaven.com/hdris">HDRIs</a>：高清天空盒贴图、3D模型</li><li><a href="https://www.mixamo.com/#/">Mixamo</a>：人物模型、动画</li><li><a href="https://www.aplaybox.com/">模之屋</a>：国产二游MMD模型</li><li><a href="https://quixel.com/megascans/home">Quixel</a>：高清材质扫描贴图</li></ul><h2 id="参考">参考</h2><p><a href="https://mmd-blender.fandom.com/wiki/MMD_Tools/Manual">Blender MMD Tool Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C与C++的DLL</title>
      <link href="/program/C++DLL/"/>
      <url>/program/C++DLL/</url>
      
        <content type="html"><![CDATA[<h1>C与C++的DLL</h1><blockquote><p>今天中午跟同事吃饭时，有人分享他在清理项目中的Warming，其中包括C++风格的DLL，我才知道，DLL建议写C风格的</p></blockquote><p>根本原因是，C++功能复杂，更依赖Name Mangling，而三大编译器具体实现不尽相同，使得ABI不确定</p><h2 id="DLL">DLL</h2><blockquote><p>我们都知道，代码到可执行文件，要先代码<strong>编译</strong>得到目标文件，目标文件<strong>链接</strong>得到可执行文件。但其实可执行文件在执行时，还会进行<strong>装载</strong></p></blockquote><p>DLL的本质其实是<strong>目标文件</strong>的打包，由目标文件和三张表组成</p><h3 id="编译">编译</h3><p>代码会编译为目标文件<code>.obj</code>，目标文件中包含<strong>导出符号表</strong>，这些符号会有明确的地址</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test1.cpp</span></span><br><span class="line"><span class="type">int</span> a;<span class="comment">// 在test1.obj文件中a有明确的地址</span></span><br></pre></td></tr></table></figure><p>有的文件中会有只声明，没有实现的符号，放在<strong>未解决符号表</strong>中。在这些符号没有明确的地址，需要去其他目标文件中寻找</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;<span class="comment">// 在test2.obj文件中a没有明确的地址</span></span><br></pre></td></tr></table></figure><h3 id="链接与装载">链接与装载</h3><p>若程序为<strong>静态链接</strong>，编译器会在链接阶段扫描导出符号表中的符号地址，将计算后的地址写给未解决符号表中的符号，这个过程被称为重定位</p><p>也就是说，从<code>test1.obj</code>中得到<code>a</code>的地址，经过计算，写给<code>test2.obj</code>中的<code>a</code>，这个过程会记录在<strong>地址重定向表</strong>中</p><p>若程序为<strong>动态链接</strong>，程序会在装载阶段做地址重定向</p><h2 id="ABI">ABI</h2><blockquote><p>ABI（Application binary interface）</p><p>API（Application Programming Interface）</p></blockquote><p>为了保证动态库的版本兼容性，大部分平台会要与DLL函数编写时，要符合ABI</p><p>ABI包含了二进制的结构布局、访问方法，应用程序可以通过ABI访问库中的二进制数据，代码编译出的ABI与编程语言、操作系统、编译器有关，通常是不确定的</p><h3 id="二进制文件格式">二进制文件格式</h3><p>不同操作系统的二进制可执行文件格式不同，因此无法兼容</p><p>ELF（Executable and Linkable Format），可执行可链接格式，是Linux系统的二进制可执行文件格式</p><p>PE（Portable Executable），可移植可执行格式，是Windows系统的二进制可执行文件格式</p><h3 id="Name-Mangling">Name Mangling</h3><p>Name Mangling会对名字进行重新编码，以实现名字的唯一性</p><p>C++支持函数重载、类、命名空间、模版，一个类中可以有多个重名函数、重名成员变量，这些名称编译后本质是不同的二进制，因此要做更复杂的Name Mangling</p><p>很不幸的是，C++没有对Name Mangling做硬性规定，于是三大编译器g++、MSVC、clang的实现不同，相同的代码可能编出不同的ABI，当你使用跨编译器的dll时，很容易出现错误</p><h3 id="C的DLL">C的DLL</h3><p>和C++相比，C就简单得多</p><p>大多数语言都提供了一些简单的方法调用C的DLL，而且C++编译器也支持导出C语言的DLL</p><h2 id="生成DLL">生成DLL</h2><p>Windows下生成DLL会得到三个产物：include头文件，dll文件，import library文件</p><blockquote><p>注意import library文件的后缀是<code>.lib</code>，但这个文件只是存储了符号表，并不是其他平台的静态库</p></blockquote><h3 id="MT与MD">MT与MD</h3><blockquote><p>操作系统将一些高频使用的代码写成DLL，并永远加载在内存中，称为CRT库</p></blockquote><p>在VS生成DLL时，有MT和MD两个选项</p><p>MD指动态C运行时，程序执行时依赖于操作系统提供的CRT</p><p>MT指静态C运行时，程序会将操作系统的一些CRT静态链接到程序中，运行时就不需要从操作系统那里装载</p><p>值得注意的是，如果一个程序混用MT和MD，很容易出现版本不兼容的错误（尤其是在使用编译好的第三方库时）</p><h3 id="C-生成DLL">C++生成DLL</h3><p>CMakeList.txt</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIB_SRC ./<span class="keyword">Math</span>.h ./<span class="keyword">Math</span>.cpp)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY ../libMath)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(MathDLL SHARED <span class="variable">$&#123;LIB_SRC&#125;</span>)</span><br><span class="line"><span class="keyword">INSTALL</span>(TARGETS MathDLL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(MathDLL PROPERTIES LINKER_LANGUAGE C</span><br><span class="line">        RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span></span><br><span class="line">        LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span></span><br><span class="line">        OUTPUT_NAME <span class="string">&quot;MathDLL&quot;</span></span><br><span class="line">        PREFIX <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>Math.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_EXPORT extern <span class="string">&quot;C&quot;</span> __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="type">int</span> <span class="title">MathAdd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>Math.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MathAdd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态加载DLL">动态加载DLL</h2><p>windows下DLL加载：</p><ol><li>分析可执行文件的导入符号表，查找所需要的dll文件</li><li>为dll文件开辟虚拟地址空间</li><li>当dll被真正调用时，将dll文件加载到内存中</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pfnAdd)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HINSTANCE handle = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;../lib/libMath/MathDLL.dll&quot;</span>));</span><br><span class="line">    pfnAdd pAdd = (pfnAdd) <span class="built_in">GetProcAddress</span>(handle, <span class="string">&quot;MathAdd&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">pAdd</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="https://stackoverflow.com/questions/16730284/dll-written-in-c-vs-the-same-written-in-c">DLL written in C vs the same written in C++</a></p><p><a href="https://stackoverflow.com/questions/2171177/what-is-an-application-binary-interface-abi">What is an application binary interface (ABI)?</a></p><p><a href="https://github.com/JasonkayZK/cpp-learn/tree/dll">使用CMake生成动态链接库DLL</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：前缀和</title>
      <link href="/program/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/program/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1>前缀和</h1><blockquote><p>本人没有算法基础，以下均为春招刷Leetcode的笔记，仅用于记录，侵权勿喷</p></blockquote><p>前缀和本质是一种预积分手段，运行时只需要得到边界值，就能快速、无损地获得区间积分值，二维的前缀和SAT在图形学中也有重要的运用</p><ul><li>注意数组越界，尤其是前缀乘</li><li>明确索引的含义，这关系着数组的长度是否需要+1</li><li>前缀和可以使用哈希表加速查找</li></ul><h3 id="除自身以外数组的乘积">除自身以外数组的乘积</h3><p><a href="https://leetcode.cn/problems/product-of-array-except-self/">leetcode</a></p><blockquote><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p><p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p><p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p></blockquote><h4 id="特点">特点</h4><p>使用左右两个前缀和</p><h4 id="思路">思路</h4><blockquote><p>最简单的方法自然是求所有数的总乘积，<code>ans[i] = total / nums[i]</code>，不过这道题让我们不要用除法（如果数中有0，这种做法也是错的）</p></blockquote><ol><li><p>我们从左做一次前缀乘，<code>left[i]</code>表示以<code>0~i</code>的前缀乘，从右开始做一次前缀乘，<code>right[i]</code>表示以<code>i~n-1</code>的前缀乘</p></li><li><p><code>ans[i]</code>将数组切分为三个部分，他自己，左边和右边，左边等于<code>0~i-1</code>的总乘积，右边等于<code>i+1～n-1</code>的总乘积，左右相乘即可得到最终结果</p></li><li><p>对于边界做特殊处理</p></li></ol><h4 id="实现">实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        right[n<span class="number">-1</span>] = nums[n<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 求左右前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>] * nums[i];</span><br><span class="line">            right[n-i<span class="number">-1</span>] = right[n-i] * nums[n-i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="comment">// 边界处理</span></span><br><span class="line">        ans[<span class="number">0</span>] = right[<span class="number">1</span>];</span><br><span class="line">        ans[n<span class="number">-1</span>] = left[n<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            ans[i] = left[i<span class="number">-1</span>] * right[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="和为k的子数组">和为k的子数组</h3><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">leetcode</a></p><blockquote><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em></p><p><code>-1000 &lt;= nums[i] &lt;= 1000</code></p></blockquote><h4 id="特点-2">特点</h4><p>数组有正有负，因此前缀和不递增</p><h4 id="思路-2">思路</h4><p>固定右端点，向左找左端点，若存在和为<code>k</code>的连续子数组，我们能找到一个左端点，使得左右端点前缀和之差为<code>k</code></p><p>由于数组中包含负数，因此左端点可能有多个</p><p>于是问题转化为从右端点出发，寻找值为<code>ps[j] - k</code>的左端点</p><p>当遍历完<code>i</code>后，当前右端点<code>preSum[i]</code>未来也可能是左端点，于是加入哈希表中</p><h4 id="实现-2">实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preSum</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">// value：key出现过的次数</span></span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            preSum[i+<span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            ans += mp[preSum[i]-k];</span><br><span class="line">            ++mp[preSum[i]];<span class="comment">// 在遍历完i之前，我们还没遇到过i</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：区间重叠</title>
      <link href="/program/%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/"/>
      <url>/program/%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<h1>区间重叠</h1><blockquote><p>本人没有算法基础，以下均为春招刷Leetcode的笔记，仅用于记录，侵权勿喷</p></blockquote><p>今天刷题时发现一类区间重叠题，思路很巧妙，理解后做起来非常简单</p><p>这类题的特点就是给你一组区间，求最多多少个区间重叠</p><h3 id="会议室Ⅱ">会议室Ⅱ</h3><p><a href="https://leetcode.cn/problems/meeting-rooms-ii/submissions/">leetcode</a></p><blockquote><p>给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间，返回 所需会议室的最小数量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[0,30],[5,10],[15,20]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure></blockquote><h4 id="思路">思路</h4><p>我们将区间转化为两次操作，对于每一个区间，区间开始会申请一个会议室，区间结束会释放一个会议室</p><p>将操作按发生时间排序，依次执行，记录占用会议室的最大数量</p><h4 id="实现">实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : intervals)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;i[<span class="number">0</span>], <span class="number">1</span>&#125;);<span class="comment">// 区间开始申请一个会议室</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;i[<span class="number">1</span>], <span class="number">-1</span>&#125;);<span class="comment">// 区间结束释放一个会议室</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">// 将操作按发生时刻排序，对于同时发生的操作，先释放再申请</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sort(v.begin(), v.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)-&gt;bool&#123;</span></span><br><span class="line"><span class="comment">            if(a[0] == b[0])&#123;</span></span><br><span class="line"><span class="comment">                return a[1] &lt; b[1];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return a[0] &lt; b[0];</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            cur += v[i][<span class="number">1</span>];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拼车">拼车</h3><p><a href="https://leetcode.cn/problems/car-pooling/">leetcode</a></p><blockquote><p>车上最初有 capacity 个空座位。车只能向一个方向行驶（也就是说，不允许掉头或改变方向）</p><p>数组每一项包含三个数，上车人数，上车时刻，下车时刻</p><p>当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：trips = [[2,1,5],[3,3,7]], capacity = 4</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure></blockquote><h4 id="思路-2">思路</h4><p>与上题基本相同，不过每次操作的数量改变了</p><h4 id="实现-2">实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">carPooling</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trips, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t: trips)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;t[<span class="number">1</span>], t[<span class="number">0</span>]&#125;);</span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;t[<span class="number">2</span>], -t[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            cur += v[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cur &gt; capacity)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google C++代码规范</title>
      <link href="/program/GoogleC++/"/>
      <url>/program/GoogleC++/</url>
      
        <content type="html"><![CDATA[<h1>Google C++ 代码规范</h1><p><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></p><p>Google提出的一套代码规范，能提高代码的可读性，减少出错。建议配合<a href="/2023/01/31/program/Effective%20C++/">Effective C++</a>阅读</p><h2 id="头文件">头文件</h2><h3 id="所有头文件都应该自给自足（self-contained）">所有头文件都应该自给自足（self-contained）</h3><blockquote><p>self-contained : compile on their own</p></blockquote><p>确保你的header files包含了你需要的所有东西，而不是假设你#include进来的某个（些）headers帮你包含了你需要的东西。</p><p>A.h包含了B.h和C.h，而B.h也包含了C.h，那么在A.h中使用C.h时，会难以判断到底该用哪一个</p><h3 id="define-保护">#define 保护</h3><p>每个头文件都要使用<code>#pragma once</code>保护</p><h3 id="前置声明">前置声明</h3><p>我个人理解的前置声明，是指在一个<code>.h</code>文件中开头声明另一个<code>.h</code>文件中的类，以此来实现类似<code>#include</code>某个文件的某一部分</p><p>与之对应的是直接使用<code>#include</code>引入文件，但这样实际会增加编译工作量，降低编译速度，于是我们非必要不<code>#include</code></p><blockquote><p>Google建议要避免使用前置声明，因为使用前置声明会影响类的修改，也容易产生错误</p><p>但使用前置声明可以提高编译速度，因此需要按情况选择</p></blockquote><p>优点</p><ul><li>节省编译时间，避免很多不必要的（因为头文件改动而导致的）重新编译</li></ul><p>缺点</p><ul><li>隐藏了依赖关系</li><li>头文件改动时会破坏后续，影响开发者改动API（比如当你要添加一个形参时）<ul><li>但这个是不是可以通过宏的方法避免？<code>#define Func Func</code></li></ul></li></ul><h4 id="两个类互相引用">两个类互相引用</h4><p>前置声明（Forward Declarations）基本仅用于两个类互相引用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    B b;<span class="comment">//A中使用了B，因此</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">A* a;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="失去依赖关系">失去依赖关系</h4><p>前置声明最大的问题是失去依赖关系</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B &#123;&#125;;<span class="comment">//这里的D继承自B</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="comment">// 如果使用前置声明替换掉#include，就会出现错误</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(D* x)</span> </span>&#123; <span class="built_in">f</span>(x); &#125;  <span class="comment">// Calls f(B*)</span></span><br></pre></td></tr></table></figure><h3 id="内联函数">内联函数</h3><p>除非是极其高频调用，确定是性能瓶颈的地方，不然不用内联函数</p><p>不要内敛超过十行的函数</p><p>析构函数远比表面要长，因为他隐式调用着成员和基类的析构函数</p><h3 id="include路径">#include路径</h3><p>按照源码目录树结构排列，避免使用UNIX的快捷目录，比如<code>.</code>（当前目录）和<code>..</code>（上级目录）</p><h3 id="include顺序">#include顺序</h3><ol><li>C头文件</li><li>C++头文件</li><li>第三方库头文件</li><li>本项目头文件</li></ol><h2 id="作用域">作用域</h2><p>命名空间将全局作用域细分为独立具体的作用域，可以有效防止全局命名冲突</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyNamespace</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;    <span class="comment">//namespace MyNamespace</span></span><br></pre></td></tr></table></figure><h3 id="请在命名空间最后注释出命名空间的名字">请在命名空间最后注释出命名空间的名字</h3><h3 id="不要污染命名空间">不要污染命名空间</h3><ul><li>不要在std命名空间中声明任何东西</li><li>不要使用<code>using namespace xxx</code></li><li>不要在头文件中使用命名空间别名，如<code>namespace bbb = ::Foo::Bar::Baz</code></li></ul><h3 id="静态变量">静态变量</h3><p>不要在.h文件中声明静态变量，至少不能用全裸的静态变量</p><p>不要定义静态存储周期<strong>非</strong>POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中静态变量的构造和析构顺序不确定，会导致bug（除非你使用constexpr）</p><p>原生数据类型（POD，Olain Old Data），如int、char、float，int*、int[]、结构体</p><p>在同一编译单元，静态初始化会优先于动态初始化，并按照声明顺序初始化，以逆序销毁</p><p>但是不同编译单元，初始化、销毁顺序是未定义行为</p><h2 id="类">类</h2><h3 id="构造函数不要调用虚函数">构造函数不要调用虚函数</h3><p>在类被完全初始化前，这个类其实是基类+其他部分，此时调用虚函数不一定会指向子类的重载，可能会报错、出错</p><p>优点</p><ul><li>不需要考虑类是否被完全初始化</li><li>初始化的对象可以为const类型</li></ul><p>如果你想进行有意义的non-trivial初始化，可以使用明确的Init()方法，或者工厂模式</p><blockquote><p>与之对应，析构函数要设为虚函数</p></blockquote><h3 id="不要隐式类型转换">不要隐式类型转换</h3><p>不要使用隐式类型转换</p><ul><li>隐式转换会降低代码可读性，由于是存在函数重载时，让人难以判断到底在用哪一个函数</li><li>隐式转化可能会导致类型不匹配的错误</li></ul><p>使用explict关键词（常用于<strong>单参数</strong>构造函数和类型转化操作符），可以使当前类型只能被显示类型转换，如果使用隐式转化，会报错</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;    <span class="comment">//这个类型不能被隐式转化，调用Func(&#123;42, 3.14&#125;)会报错</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(Foo f)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="拷贝和移动">拷贝和移动</h3><p>如果你的类型需要拷贝和支持，就请实现它，否则禁用它（<code>=delete</code>）</p><p><code>std::unique_ptr&lt;int&gt; </code>可移动，但是不能复制</p><ul><li>可拷贝类型，可以使用相同类型的另一对象进行初始化，当前对象会得到相同的值，同时不改变源对象。<ul><li>用户通过定义拷贝构造函数、拷贝赋值操作符实现</li></ul></li><li>可移动对象，可以使用相同类型的临时对象进行初始化，当前对象会得到相同的值<ul><li>用户通过定义移动构造函数、移动赋值操作符实现</li></ul></li></ul><p>不要为任何有可能有子类的类型提供拷贝和移动，可能会导致对象割裂</p><h3 id="除了数据成员，其他一律用class">除了数据成员，其他一律用class</h3><p>C++的class和struct很像，大部分功能相同，不过</p><ul><li>struct可以拥有成员变量，但不能拥有成员函数（你可以写非成员函数+引用）</li><li>struct成员为public，而class可以拥有private成员</li><li>struct的继承方式为public，比class少（尽管全世界C++项目99%的继承都是public继承）</li></ul><h3 id="struct与pairs、tuples">struct与pairs、tuples</h3><p>struct的字段名更具可读性，当数据有意义时，尽量使用struct</p><p>不过pairs和tuples更适用于泛型编程</p><h3 id="组合与继承">组合与继承</h3><p>组合很好用，能用接口用接口，如果非要用继承，请public继承</p><p>对于虚函数进行重载时，用override、final标记，尽管这个关键字没有什么作用，但能提高代码可读性</p><blockquote><p>全世界C++项目99%的继承都是public继承</p><p>public、protected、private继承你可以理解为设限</p><p>如果是public继承，那么子类访问父类成员的存取类型都不会超高public（废话），父类的public、protected、private成员，对于子类为public、protected、private</p><p>如果是protected继承，那么子类访问父类成员的存取类型都不会超高protected，父类的public、protected、private成员，对于子类为protected、protected、private</p></blockquote><p>请不要使用多重继承，不过你能继承多个接口</p><p>关于接口</p><ul><li>接口是用interface标记的类，只有纯虚数和静态函数，没有非静态成员</li><li>接口不能被直接实例化，也不需要定义构造函数</li><li>请为接口实现虚析构函数</li><li>请不要为其添加函数实现或非静态成员数据</li></ul><h3 id="操作符重载">操作符重载</h3><p>尽量别重载</p><h3 id="访问控制">访问控制</h3><p>类的数据成员应该为private，除非是一个常量</p><blockquote><p>数据成员设为private，然后编写public的访问函数，不过感觉不如C#的属性优雅</p></blockquote><h3 id="声明顺序">声明顺序</h3><blockquote><p>随便找个<code>.h</code>文件，看看类的声明是怎么写的</p></blockquote><ul><li>相似的声明放在一起，并按以下顺序<ul><li>类型及类型别名（<code>typedef, using, enum </code>，嵌套的结构体和类）</li><li>静态常量</li><li>工厂函数</li><li>构造函数和赋值运算符</li><li>析构函数</li><li>其他函数</li><li>数据成员</li></ul></li><li>先写public，再写protected、private</li></ul><p>不要将大段的函数定义写在类定义中，建议<code>.h</code>声明，<code>.cpp</code>定义</p><h2 id="函数">函数</h2><h3 id="参数">参数</h3><blockquote><p>见名知意，知行合一</p><p>看到函数名就能知道这是干什么的，比如Get、Set，如果一个函数是Get，那就做Get的事</p></blockquote><ul><li>优先使用返回值而非输出参数，这能提高可读性和性能</li><li>不要返回空指针（除非你是这样设计的）</li><li>输入参数、不需要改变的参数可以用const引用</li><li>输出参数、可以被修改的参数可以用指针</li><li>参数需要排序，输入先于输出，无默认值先于有默认值</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::string&amp; in_str, std::string* out_str)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="简短的函数">简短的函数</h3><blockquote><p>个人感觉完全没必要，尤其是对于C#、Java，40行好干什么</p></blockquote><p>简短的函数能提高代码可读性，提高调试效率，在函数式编程很常用</p><h3 id="函数重载">函数重载</h3><p>函数重载能够使同一作用域中，有一组相同函数名、不同参数列表的函数，常用于命名一组功能相似的函数</p><p>不过如果函数仅靠参数类型进行重载，就会涉及匹配、派生类之类的问题，让人感受困惑</p><blockquote><p>如果要重载Append()，其实可以在函数名上添加类型信息，比如AppendInt()、AppendString()</p></blockquote><h3 id="缺省参数">缺省参数</h3><blockquote><p>写缺省不如写重载</p></blockquote><p>缺省本质上就是一种函数重载，所有不适合使用重载的地方，都不适合使用缺省</p><p>由于缺省参数会干扰函数指针，因此一定不要在虚函数中使用缺省参数</p><h3 id="函数返回值的后置写法">函数返回值的后置写法</h3><blockquote><p>后置写法本身没问题，swift、js等语言都是这样写的，但是对于C++来说是一种“很新的东西”，容易让人感到困惑</p></blockquote><p>C++11后，C++的函数可以使用后置返回类型，不过除了lambda表达式，一般不这样写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置写法</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> -&gt; <span class="type">int</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda只能后置写法</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br></pre></td></tr></table></figure><p>在泛型编程中，当返回类型依赖于模版参数时，也可以使用后置写法，能提高可读性</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置写法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;())</span> <span class="title">add</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置写法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="所有权和智能指针">所有权和智能指针</h3><blockquote><p>关于所有权和智能指针，可以参考<a href="https://reubensun.com/engine/GC/">垃圾回收</a>中引用计数法</p><p>C++标准鼓励我们使用智能指针管理资源</p></blockquote><p>对于一个动态的对象，我们更倾向于让其拥有单一、固定所有权（ownership），并使用指南指针做所有权转换</p><ul><li><code>std::unique_ptr</code>，独占资源<ul><li>当指针离开作用域，资源就会被销毁</li><li>无法复制（copy），但能转移（move）所有权</li></ul></li><li><code>std::shared_ptr</code>，共享资源<ul><li>当资源失去所有引用时，资源被销毁</li><li>可以复制，共享所有权（无需转移）</li></ul></li></ul><p>好处</p><ul><li>有的对象甚至没法复制，只能转移</li><li>转移通常比复制更高效，尤其是一些const对象，转移比深拷贝高效得多</li><li>使用智能指针能提高可读性，也减少了内存泄漏</li></ul><h2 id="其他">其他</h2><h3 id="右值引用">右值引用</h3><blockquote><p>关于左右值，建议阅读<a href="https://reubensun.com/program/C++11/">C++11</a></p></blockquote><p>只在定义移动构造函数和移动赋值操作时使用右值引用</p><p>推荐使用<code>std::move</code>，不要使用<code>std::forward</code>（除非你在模版编程）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> string &amp; var1, <span class="type">const</span> string &amp; var2)</span></span>&#123;</span><br><span class="line">  m_var1 = var1;</span><br><span class="line">  m_var2 = var2;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// move</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(string &amp;&amp; var1, string &amp;&amp; var2)</span></span>&#123;</span><br><span class="line">  m_var1 = std::<span class="built_in">move</span>(var1);  </span><br><span class="line">  m_var2 = std::<span class="built_in">move</span>(var2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// forward</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(T1 &amp;&amp; var1, T2 &amp;&amp; var2)</span></span>&#123;</span><br><span class="line">  m_var1 = std::forward&lt;T1&gt;(var1);</span><br><span class="line">  m_var2 = std::forward&lt;T2&gt;(var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>forward的作用是什么？</p><p>如果不使用forward，我们需要同时定义copy和move函数，在处理左值时调用copy，处理右值调用move，这增加了代码量，如果使用forward，我们只需要写一份</p><p>但forward让一个函数能干两种事，这不符合“知行合一”，为了代码可读性，我们通常不会使用。如果我们明确这个函数要move，那就用move</p></blockquote><h3 id="友元">友元</h3><p>友元：在定义一个类时，可以将一些（定义在外部的）函数声明为友元，这些友元函数可以访问该类的private、protected成员</p><ul><li>友元扩大了类的封装，在OOP中很忌讳，但只要合理，还是可以用的<ul><li>原本是private的成员，对于友元类、函数，都是public的</li><li>友元类似一种许可，当一个类设置友元后，相当于给友元开了管理员权限，能随意访问原本受保护的成员</li></ul></li><li>如果你要用，请写在同一个文件中</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Child</span>() &#123; name = <span class="string">&quot;default name&quot;</span>; &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Mother</span>;<span class="comment">// 母亲有权利修改孩子的名字，尽管setName是private的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string nn)</span> </span>&#123; name = nn; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mother</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Child child;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">renameChild</span><span class="params">(string nn)</span></span>&#123; child.<span class="built_in">setName</span>(nn); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mother mother;</span><br><span class="line">    Child child;</span><br><span class="line">    mother.child = child;</span><br><span class="line"><span class="comment">// child.setName()的访问控制为private，你没法在这里调用</span></span><br><span class="line">    cout &lt;&lt; mother.child.<span class="built_in">getName</span>() &lt;&lt; endl;<span class="comment">// default name</span></span><br><span class="line">    mother.<span class="built_in">renameChild</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    cout &lt;&lt; mother.child.<span class="built_in">getName</span>() &lt;&lt; endl;<span class="comment">// Tom</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常">异常</h3><blockquote><p>谷歌不使用C++异常，让异常Let it crash。不过异常在C#、Java、Swift中很常用，</p></blockquote><p>抛异常可能会导致一些未定义行为，比如不要在析构函数中使用异常</p><p>不使用异常，如果出错常用方法为：</p><ul><li>直接<code>abort()</code></li><li>吞异常，Let it crash</li></ul><h3 id="RTTI">RTTI</h3><p>不使用运行时类型识别，不使用<code>typeid</code>和<code>dynamic_cast</code></p><p>运行时类型识别会使代码难以维护，如果你需要用RTTI（除了单元测试），说明你的类设计的不好</p><h3 id="类型转化">类型转化</h3><p>使用C++风格的类型转化（而非C风格的）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> double_value;</span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(double_value);</span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="type">float</span> f2 = (<span class="type">float</span>)double_value;</span><br></pre></td></tr></table></figure><ul><li>使用<code>static_cast</code>做值转换、子类指针转父类指针</li><li>使用<code>const_cast</code>去掉const限定符</li><li>使用<code>reinterpret_cast</code>做指针和整型、指针和指针间的转换（仅在你会用时使用）</li><li>不使用<code>dynamic_cast</code></li></ul><h4 id="严格别名">严格别名</h4><blockquote><p>C++的<code>reinterpret_cast</code>不会编译为任何CPU指令，会编译为纯汇编，于是你可以像汇编一样操作指向内存的指针地址，破坏了C++对汇编对抽象</p></blockquote><p>严格别名（strict aliasing）规定：只有同一种类型的指针，才可以出现别名，总之没事别做不相干类型的指针转化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span>* f;</span><br><span class="line"><span class="type">int</span>* i;</span><br><span class="line"><span class="comment">// 编译器优化时会假定 f != i</span></span><br><span class="line"><span class="comment">// 若你的代码让 f == i （比如使用reinterpret_cast），那就是未定义行为，违反严格别名规则</span></span><br></pre></td></tr></table></figure><p>当你通过指针，将一个struct塞到一个buffer中，或者将一个buffer塞到struct中，在这个过程中，指针的类型发生转换，从buffer转化为struct</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; Msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* p = x;</span><br><span class="line"></span><br><span class="line">    Msg* msg = (Msg*)p;<span class="comment">// Msg* msg = reinterpret_cast&lt;Msg*&gt;(p);</span></span><br><span class="line">    cout &lt;&lt; msg-&gt;a &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; msg-&gt;b &lt;&lt; endl;<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个过程干了什么？你知道这个buffer的内存地址、长度，你想直接用这些信息访问内存，这是对的，但是某些情况下这就是未定义行为</p><h3 id="流">流</h3><p>谷歌认为除了日志接口需要，不要使用流</p><p>说实话我感觉流挺方便的，只要能保持输出的一致性就行，而且C++的Stream类型安全，用起来十分方便，尤其是输出字符串和对象时</p><h3 id="自增与自减">自增与自减</h3><p>谷歌建议一律使用前置自增自减，尤其是迭代器</p><p>一般而言，使用前置自增<code>++i</code>能提高性能，后置会生成临时对象和拷贝复制</p><blockquote><p>不过，如果自增自减后变量并没有被用到，仅仅是用于记录迭代次数，编译器会对后置自增自减进行优化，性能一样，而且后置更像自然语言，可读性更强</p></blockquote><h3 id="const">const</h3><p>在任何能使用const的地方使用const或constexpr</p><h3 id="整型">整型</h3><p>C++内置的整型只，只使用<code>int</code></p><p>如果需要明确长度，那就用<code>&lt;cstdint</code>中的<code>int16_t</code>、<code>int64_t</code></p><p>如果你不确定用何种大小的int，那么用最大的</p><h3 id="可移植性">可移植性</h3><p>代码应该对32位和64位系统友好，在处理打印、比较、结构体对齐时要注意</p><p>不是所有人都在用64位系统（不过iOS这种封闭平台确实做到了完全禁用32位）</p><h3 id="预处理宏">预处理宏</h3><blockquote><p>尽管在图形Shader中，用宏进行条件变异很常用，但这其实是因为GPU对分支的处理不好，因此我们通过编译多份代码来避免运行时使用分支。不过这对CPU代码纯属是提高包体，降低可读性，增加调试难度，不推荐使用</p></blockquote><ul><li><p>宏具有全局作用域，使你看到的和编译器看到的内容不同，尽量用内联、const进行替换</p></li><li><p>不要使用宏做条件编译</p></li><li><p>不要在<code>.h</code>文件中定义宏</p></li><li><p>使用完<code>#define</code>后要立刻<code>#undef</code></p></li><li><p>不要使用展开后让C++构造不稳定的宏</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">max</span>(++x, ++y);<span class="comment">// 本质为 int n = (++x &gt; ++y ? ++x : ++y)，和预期不一致</span></span><br></pre></td></tr></table></figure><ul><li>不要在宏后面写单行注释</li><li>不要用<code>##</code>处理函数、类、变量的名字，可读性很差</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用##将两个宏拼起来，很trick的写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONS(a,b)   int(a##e##b)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">CONS</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;<span class="comment">// 输出2000，因为CONS宏将2和3拼成了2e3</span></span><br></pre></td></tr></table></figure><h3 id="nullptr">nullptr</h3><p>空指针用nullptr，数值用0（或者0.0），<code>std::string</code>用<code>\0</code></p><p>绝对不要用NULL</p><h3 id="sizeof">sizeof</h3><p>sizeof用于获取类型的大小，不过不建议对类型使用，而是对varname使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyStruct data;</span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(MyStruct));<span class="comment">// 对类型使用，不推荐</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data));<span class="comment">// 对varname使用，推荐</span></span><br><span class="line"><span class="comment">// 如果有人改动了data的类型，比如改成了MyStruct2，第二种方法不会出错</span></span><br></pre></td></tr></table></figure><h3 id="类型推断">类型推断</h3><h4 id="函数模版参数类型推断">函数模版参数类型推断</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">// f&lt;int&gt;(0)</span></span><br></pre></td></tr></table></figure><h4 id="类模版类型推断">类模版类型推断</h4><p>Class Template Argument Deduction（CTAD）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">// a is a std::array&lt;int, 3&gt;</span></span><br></pre></td></tr></table></figure><h4 id="auto变量类型推断">auto变量类型推断</h4><p>若一个变量被声明为auto，那么它的类型会自动匹配成初始化表达式的类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">42</span>;<span class="comment">// a is an int</span></span><br><span class="line"><span class="keyword">auto</span>&amp; b = a;<span class="comment">// b is an int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> d &#123;<span class="number">42</span>&#125;;<span class="comment">// d is an int, not a std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">// il is a std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>有的变量类型巨长（尤其是使用模版和命名空间时），而且一次初始化要写两遍，使用auto能提高可读性</p><ul><li>仅在局部变量中使用auto，比如for循环</li><li>仅在一眼能看出类型的地方使用auto</li><li>不要列表初始化auto变量</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: list)&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="函数返回值类型推断">函数返回值类型推断</h4><p>不要用于函数返回值，除非你是lambda使用后置返回值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="指定的初始化">指定的初始化</h3><blockquote><p>C++20才加入的新东西，感觉大家的项目基本都没法用吧</p></blockquote><p>可以方便的生成高可读性高聚合的初始化表达式，尤其对一些字段顺序不明显的结构</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="type">float</span> x = <span class="number">0.0</span>;</span><br><span class="line">  <span class="type">float</span> y = <span class="number">0.0</span>;</span><br><span class="line">  <span class="type">float</span> z = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p = &#123;</span><br><span class="line">  .x = <span class="number">1.0</span>,</span><br><span class="line">  .y = <span class="number">2.0</span>,</span><br><span class="line">  <span class="comment">// z will be 0.0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式">Lambda表达式</h3><ul><li>将所有的捕获显示写出来</li><li>只有lambda声明周期很短时，才使用<code>[&amp;]</code></li><li>使用<code>[=]</code>显式捕获</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[=](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;<span class="comment">// 默认捕获方式，不好</span></span><br><span class="line">[n](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;<span class="comment">// 显式捕获方式，好</span></span><br><span class="line"></span><br><span class="line">[&amp;] &#123; foo.<span class="built_in">doSomething</span>(); &#125;<span class="comment">// 不好</span></span><br><span class="line">[&amp;foo] &#123; foo.<span class="built_in">doSomething</span>(); &#125;<span class="comment">// 好</span></span><br></pre></td></tr></table></figure><h3 id="泛型编程">泛型编程</h3><p>避免复杂的泛型编程，这东西可读性相当差，调试难度相当高</p><h3 id="别名">别名</h3><p>别名（Aliases）能让复杂类型的名字变简单，尤其是那些带有命名空间的类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Foo Bar;<span class="comment">// 传统方法</span></span><br><span class="line"><span class="keyword">using</span> Bar = Foo;<span class="comment">// C++11后推荐的用法</span></span><br></pre></td></tr></table></figure><ul><li>不要在公共区域使用别名，除非你写对其写详细注释</li><li>不要在公共区域引入命名空间别名</li></ul><h2 id="命名规范">命名规范</h2><blockquote><p>命名规范因项目而异，只要保持一致性即可，谷歌的命名规范我个人不习惯，可能我C#、Swift写的比较多，感觉好奇怪</p></blockquote><h3 id="通用规范">通用规范</h3><p>命名别嫌长，要见名知意</p><blockquote><p>你看看人家Java的方法名长度</p></blockquote><p>不要用汉语拼音</p><blockquote><p>你要记住，英语是表音文字，因此可以靠读音/26个字母排列明确意义，而汉字是象形文字，形状才能明确意义，只靠汉语拼音无法明确区分同音字词。</p><p>而且汉语拼音是新中国扫盲、普及普通话的工具，不仅外国人看不懂，甚至一些说方言的人也看不懂</p></blockquote><p>慎用缩写</p><blockquote><p>日本人用假名翻译“龙”，还省去了几个词，结果/ˈdræɡən/硬是读成了“多拉贡”</p></blockquote><h2 id="注释">注释</h2><blockquote><p>见名知意，自文档的代码确实好，但有时你还是需要写注释，以提高可读性</p></blockquote><ul><li>每个文件开头写入版权公告（不要轻易删除原作者的信息）</li><li>代码段行前注释，描述类行后注释，行后注释要对齐</li><li>假设读代码的人水平比你高，有些过于明显的API解释，不要写（不会有人给<code>i++</code>写注释吧）</li><li>标点、换行（对于python，yml很重要）建议依赖IDE，统一即可</li><li>写TODO（比如Xcode就支持<code>TODO:</code>和<code>MARK:</code>，很多IDE都能检查）</li><li>如果一个接口被弃用，可以写弃用注释<code>DEPRECATED</code></li></ul><h2 id="格式">格式</h2><blockquote><p>个人建议格式依赖IDE，如果你有自己的坚持，那么先配置IDE</p></blockquote><ul><li>一行不能太长，不然别人要缩放屏幕或者拖动水平滚动条，<code>#include</code>语句除外</li><li>使用UTF-8编码（GB-2312的中文注释用UTF-8打开就是乱码）</li><li>只使用空格而非制表符，IDE都支持将制表符替换为空格，建议一个制表符=4个空格</li><li>返回类型，函数名，前几个参数都放在头一行</li><li>空行不要超过两行</li></ul>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学复习</title>
      <link href="/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
      <url>/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>光学复习</h1><h2 id="复习重点">复习重点</h2><ul><li>[x] 相速度</li><li>[x] 偏振态</li><li>[x] 费马原理</li><li>[x] 横向放大率</li><li>[x] 薄透镜成像</li><li>[ ] 透镜组成像（做图法）</li><li>[ ] 反射过程中的相移</li><li>[ ] 布鲁斯特角</li><li>[ ] 反射光与折射光的偏振态</li><li>[x] 全反射</li><li>[x] 相干条件</li><li>[x] 杨氏双缝干涉</li><li>[x] 时间、空间相干性</li><li>[x] 等倾干涉</li><li>[x] 等厚干涉</li><li>[ ] 迈克尔逊干涉仪</li><li>[ ] 多光束干涉</li><li>[x] 增反膜与增透膜</li><li>[x] 惠更斯-菲涅尔原理</li><li>[x] 衍射的分类</li><li>[ ] 衍射与傅立叶变换</li><li>[ ] 单缝衍射</li><li>[x] 圆孔衍射</li><li>[ ] Airy斑</li><li>[ ] 瑞丽判据</li><li>[ ] 多缝衍射</li><li>[x] 光栅方程</li><li>[ ] Abbe成像原理</li><li>[ ] 最小分辨距离、角度</li><li>[x] 光栅</li><li>[x] 双折射</li><li>[x] 惠更斯作图法</li><li>[ ] 波片</li><li>[x] 光偏振态的改变与检测</li><li>[x] 黑体辐射与光量子</li></ul><h2 id="作业解析">作业解析</h2><h3 id="3-32">3.32</h3><blockquote><p>一个4.0 v白炽手电筒灯泡消耗0.25 A，将约1.0%的耗散功率转化为光(λ≈550 nm)。如果梁的截面积是10平方厘米，近似圆柱形</p><p>(a)每秒发射多少光子?(b)每米光束中有多少光子?©光束离开手电筒时的通量密度是多少?</p></blockquote><h4 id="a">a</h4><p>根据功率和光的能量公式<br>$$<br>P=UI<br>$$</p><p>$$<br>n\hslash c/\lambda=0.01P<br>$$</p><p>求出n</p><h4 id="b">b</h4><p>每米光子数=光子总数/长度<br>$$<br>nt=ct<br>$$</p><p>$$<br>c=3.0\times 10^8<br>$$</p><h4 id="c">c</h4><p>$$<br>密度=0.01P/S<br>$$</p><h3 id="8-4">8.4</h3><blockquote><p>描述下列光的偏振态</p></blockquote><img src="/images/求下列偏振态.png" class="lazyload" data-srcset="/images/求下列偏振态.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="求下列偏振态" style="zoom:50%;" /><p>根据xy的振幅和相位判断偏振态<br>$$<br>\delta=(E_x/E_y)\Delta \varphi<br>$$</p><h4 id="ab">ab</h4><p>$$<br>E_x/E_y=-1<br>$$</p><p>$$<br>phase(E_x)=phase(E_y)<br>$$</p><p>偏振方向为<br>$$<br>-\pi/4<br>$$</p><h4 id="c-2">c</h4><p>$$<br>E_x/E_y=1<br>$$</p><p>$$<br>phase(E_x)=phase(E_y)+\pi/4<br>$$</p><p>偏振方向为<br>$$<br>\pi/4<br>$$</p><h4 id="d">d</h4><p>$$<br>E_x/E_y=1<br>$$</p><p>$$<br>phase(E_x)=phase(E_y)-\pi/2<br>$$</p><p>偏振方向为<br>$$<br>-\pi/2<br>$$</p><h4 id="记偏振态的技巧">记偏振态的技巧</h4><p>$\delta = 0$时，是一个左下到右上的线偏振，随着$\delta$增大，偏振的形状呈正弦形状，左顺右逆</p><p><img src="/images/%E5%B7%A6%E9%A1%BA%E5%8F%B3%E9%80%86.png" class="lazyload" data-srcset="/images/%E5%B7%A6%E9%A1%BA%E5%8F%B3%E9%80%86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="左顺右逆"></p><h3 id="7-36">7.36</h3><blockquote><p>证明组速度可以写成</p></blockquote><p>$$<br>v_g=\frac{c}{n}+\frac{\lambda c}{n^2}\frac{\mathrm{d}n}{\mathrm{d}\lambda}<br>$$</p><p>证明</p><img src="/images/求证组速度表示.png" class="lazyload" data-srcset="/images/求证组速度表示.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="求证组速度表示" style="zoom: 33%;" /><h3 id="5-5">5.5</h3><h2 id="考试例题">考试例题</h2><h3 id="求反射光偏振">求反射光偏振</h3><img src="/images/求反射光偏振.png" class="lazyload" data-srcset="/images/求反射光偏振.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="求反射光偏振" style="zoom:50%;" /><ol><li>根据shell公式求折射角</li></ol><p>$$<br>1 \times \sin \theta = n\sin \gamma<br>$$</p><p>$$<br>\gamma = 18.7^{\circ}<br>$$</p><ol start="2"><li>根据菲涅尔公式求出反射光ps偏振比</li></ol><p>$$<br>r_p=\frac{\tan (\alpha - \gamma)}{\tan (\alpha + \gamma)}=0.176<br>$$</p><p>$$<br>r_s=-\frac{\sin (\alpha - \gamma)}{\sin (\alpha + \gamma)}=-0.261<br>$$</p><ol start="3"><li>得到反射光ps分量</li></ol><p>$$<br>E_p=r_pE_0\cos 45^\circ<br>$$</p><p>$$<br>E_s=r_sE_0\sin 45^\circ<br>$$</p><ol start="4"><li>求反射光的偏振和入射面的夹角$\theta’$</li></ol><p>$$<br>\theta’=\arctan|\frac{r_s}{r_p}|=\arctan 1.483=56^\circ<br>$$</p><ol start="5"><li>由于入射角小于布鲁斯特角</li></ol><p>$$<br>\alpha_B = \arctan n=57.3^\circ<br>$$</p><p>所以ps都有相位移，合成后仍在13象限</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：光源</title>
      <link href="/optics/%E5%85%89%E6%BA%90/"/>
      <url>/optics/%E5%85%89%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1>十一：光源</h1><h2 id="内容概述">内容概述</h2><ul><li>黑体辐射</li><li>光电效应</li><li>波粒二象性</li></ul><h2 id="黑体辐射">黑体辐射</h2><blockquote><p>室温下的铁是黑灰色，高温下是暗红色，极高温下是橙色</p></blockquote><p>任何温度大于绝对零度的物体，都会发出热辐射（Thermal radiation），这是由带电粒子随机运动产生的</p><p>处于平衡状态的物体，能量吸收率等于释放率，高吸收伴随着高释放</p><h3 id="基尔霍夫辐射定律">基尔霍夫辐射定律</h3><p>将一个物体置于一个等温真空室中，物体会吸收真空室中的热辐射，达到相同的温度（无论物体和环境的材质）</p><p>处于热平衡的物体满足<br>$$<br>R/\alpha=I<br>$$</p><ul><li>$R$，Radiation，物体的辐射率</li><li>$I$：Irradiance，真空室的辐照度</li><li>$\alpha$：吸收率</li></ul><p>基尔霍夫辐射定律：在热平衡状态下，光谱辐照度和光谱吸收系数之间的比值仅与辐射波长和温度有关，与辐射物体本身的性质无关。<br>$$<br>f(\lambda, T)=\frac{r(\lambda, T)}{\alpha(\lambda, T)}<br>$$<br>联系两个方程可得：好的吸收器是好的发光器（A good absorber is a good emitter）</p><h3 id="黑体">黑体</h3><p>黑体：在任何温度和波长下，吸收率$\alpha$都为1的材质<br>$$<br>\alpha \equiv 1<br>$$<br>黑体辐射实验</p><img src="/images/黑体辐射.png" class="lazyload" data-srcset="/images/黑体辐射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="黑体辐射" style="zoom: 33%;" /><img src="/images/黑体辐射曲线.png" class="lazyload" data-srcset="/images/黑体辐射曲线.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="黑体辐射曲线" style="zoom:50%;" /><h2 id="光电效应">光电效应</h2><h3 id="光量子假说">光量子假说</h3><p>爱因斯坦提出光量子假说，成功解释了光电效应的实验现象</p><img src="/images/光电效应.png" class="lazyload" data-srcset="/images/光电效应.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="光电效应" style="zoom:50%;" /><h3 id="康普顿散射">康普顿散射</h3><blockquote><p>1923年，康普顿发现，当x射线穿过石墨和金属等材料时，除了波长不变的散射外，还存在散射光子，随着散射角的增大，其波长也会变大。</p></blockquote><img src="/images/康普孙散射.png" class="lazyload" data-srcset="/images/康普孙散射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="康普孙散射" style="zoom:50%;" /><h2 id="波粒二象性">波粒二象性</h2><h2 id="激光">激光</h2><p>原子能级跃迁，从高能态到低能态，会发射激光</p><p>激光（Laser，<strong>L</strong>ight <strong>A</strong>mplification by <strong>S</strong>timulated <strong>E</strong>mission of <strong>R</strong>adiation）</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：各项异性</title>
      <link href="/optics/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7/"/>
      <url>/optics/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1>十：各向异性</h1><h2 id="内容概述">内容概述</h2><ul><li>光在各向异性的介质中的传播</li><li>偏振</li></ul><h2 id="双折射晶体">双折射晶体</h2><p>透过双折射晶体（比如方解石晶体），在某些角度只有一个像，在某些角度会有两个像</p><h3 id="双折射">双折射</h3><p>现象：一束光经过晶体后被分为了两束光</p><p>我们称之为o光和e光</p><ul><li>o光：按折射定律传播的光</li><li>e光：不按折射定律传播的光</li></ul><p>光轴：光束沿着光轴传播时，o光和e光不分开（这个方向两个折射率是相同的）</p><img src="/images/方解石.png" class="lazyload" data-srcset="/images/方解石.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="方解石" style="zoom:50%;" /><ul><li><p>主截面：界面法线和光轴构成的平面</p></li><li><p>主平面：晶体内光线和光轴构成的平面</p></li></ul><p>o光和e光都是线偏振光，o光的振动方向与主平面垂直，e光的振动方向与主平面平行</p><ul><li>单轴晶体：只有一个光轴的晶体，比如方解石、石英</li><li>双轴晶体：有两个光轴方向的晶体，比如云母、蓝宝石、硫磺</li></ul><p>o光和e光的光速不同，波面形状也不同</p><ul><li>o光沿各个方向的传播速度相同，于是波面是一个球</li><li>e光沿着不同方向传播速度不同，我们特别的选取垂直于光轴的面作为e光的波面，这个波面是一个椭圆<ul><li>这两个椭圆是相切的，但大小不确定</li><li>若o光比e光大，那么是正晶体</li><li>若o光比e光小，那么是负晶体</li></ul></li></ul><img src="/images/正负晶体.png" class="lazyload" data-srcset="/images/正负晶体.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="正负晶体" style="zoom:50%;" /><h2 id="惠更斯作图法">惠更斯作图法</h2><img src="/images/惠更斯绘图.png" class="lazyload" data-srcset="/images/惠更斯绘图.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="惠更斯绘图" style="zoom:50%;" /><ul><li>偏振态：我们在光线上各距离绘制短线和圆点，用来表示偏振<ul><li>短线表示偏振沿着纸面</li><li>点表示偏振垂直纸面</li><li>自然光横线和点的数量应该一样多</li></ul></li></ul><h3 id="绘制折射光">绘制折射光</h3><ol><li>过A点做边缘光线的垂线AB，垂足为B</li><li>我们能求出光线的传播时间$t=\overline{BB’}/c $</li><li>以A为圆心，做一个半径为$\mathrm{v}_o t$的圆，这是o光波面</li><li>以A为中心，做一个半轴为$\mathrm{v}_o t 和 \mathrm{v}_e t$的椭圆，椭圆要和圆在光轴处相切</li><li>从B’出发做圆和椭圆的切线，切点为$A’_o,A’_e$</li><li>o光折射光为$AA’_o$</li><li>e光折射光为$AA’_e$</li></ol><h2 id="光的偏振">光的偏振</h2><p>由于晶体可以分离o光和e光，因此可以做成偏振器</p><h3 id="光的偏振状态">光的偏振状态</h3><blockquote><p>回忆一下</p></blockquote><p>光有五种偏振状态</p><ul><li>自然光</li><li>部分偏振光</li><li>线偏振光</li><li>圆偏振光</li><li>椭圆偏振光</li></ul><p>光偏振状态的检验：将光通过检偏器，旋转检偏器，通过光强的变化判断</p><ul><li>无变化：自然光、圆偏振光</li><li>有变化但没有消光：部分偏振光、椭圆偏振光</li><li>有变化且有消光，线偏振光</li></ul><p>仅通过检偏，只能简单分出三类光，无法更近一步区分偏振态，而<strong>使用晶体可以明确知道偏振态</strong></p><p><strong>马吕斯定律</strong>：线偏振光经过检偏器，光强满足<br>$$<br>I=I_0\cos^2\varphi<br>$$<br><strong>布鲁斯特定律</strong>：光线以大于布鲁斯特角入射，反射光是线偏振光<br>$$<br>\tan i_B=\frac{n_2}{n_1}<br>$$</p><h3 id="光在晶体中的传播">光在晶体中的传播</h3><h4 id="洛匈棱镜">洛匈棱镜</h4><p>由两块冰洲石构成</p><ul><li>左侧光轴平行纸平面和入射光，光线进入时不会发生双折射</li><li>右侧光轴垂直纸平面，光线进入后o光变e光，e光变o光</li></ul><img src="/images/洛匈棱镜.png" class="lazyload" data-srcset="/images/洛匈棱镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="洛匈棱镜" style="zoom:50%;" /><h4 id="沃拉斯顿棱镜">沃拉斯顿棱镜</h4><img src="/images/沃拉斯顿棱镜.png" class="lazyload" data-srcset="/images/沃拉斯顿棱镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="沃拉斯顿棱镜" style="zoom:50%;" /><ul><li>光线进入左侧，o光和e光方向不变，速度改变，e光会比o光快</li></ul><h4 id="尼科尔棱镜">尼科尔棱镜</h4><p><img src="/images/niker.gif" class="lazyload" data-srcset="/images/niker.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="niker"></p><h3 id="偏振光的获取和检验">偏振光的获取和检验</h3><p>核心思想为<strong>垂直振动和合成</strong>，任何一个偏振态，都是两个垂直振动的合成</p><p>所有偏振态都是由两垂直的线偏振光合成，两者的相位差$\delta$将决定合成的是何种偏振光</p><p>$\lambda/4$波晶片能带来$\pi/2$的相位差</p><img src="/images/偏振光的相位差.png" class="lazyload" data-srcset="/images/偏振光的相位差.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="偏振光的相位差" style="zoom:50%;" /><p>光通过晶体时，o光和e光可能方向不变，相位差改变，通过调整两者间相位差，就能得到圆偏振、椭圆偏振</p><h4 id="求出射光偏振态">求出射光偏振态</h4><p>出射光相位差=入射光相位差+波晶片相位差</p><img src="/images/出射偏振态.png" class="lazyload" data-srcset="/images/出射偏振态.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="出射偏振态" style="zoom:50%;" /><h3 id="偏振光检验">偏振光检验</h3><ol><li>使用偏振片将五种偏振光变为三组</li><li>对于自然光和圆偏振光那一组<ol><li>光线继续通过$\lambda/4$波晶片，如果变为线偏振光，则为圆偏振光</li></ol></li><li>对于部分偏振光和椭圆偏振光那一组<ol><li>将偏振片旋转至光强最强处</li><li>将$\lambda/4$波晶片光轴旋转至与偏振片透振方向平行</li><li>去除偏振片，光线继续通过$\lambda/4$波晶片</li><li>此时o光和e光与椭圆主轴一致，若变为线偏振光，则为椭圆偏振光</li></ol></li></ol><img src="/images/偏振光检验.png" class="lazyload" data-srcset="/images/偏振光检验.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="偏振光检验" style="zoom: 67%;" /><h3 id="左右旋检验">左右旋检验</h3><p>一个圆偏振片，通过$\lambda/4$波晶片，再通过透振方向为斜对角线的偏振片</p><ol><li>旋转偏振片，若发现有消光位置，则停止旋转（圆偏振通过波晶片变线偏振，透过偏振片会有消光），此时透振方向和线偏振光偏振方向垂直</li><li>若透振方向为一三象限，入射光为右旋</li><li>若透振方向为二四象限，入射光为左旋</li></ol><img src="/images/区分左右旋.png" class="lazyload" data-srcset="/images/区分左右旋.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="区分左右旋" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：傅立叶变化光学</title>
      <link href="/optics/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E5%8C%96%E5%85%89%E5%AD%A6/"/>
      <url>/optics/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E5%8C%96%E5%85%89%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1>八：傅立叶变换光学</h1><h2 id="内容概述">内容概述</h2><ul><li>衍射系统的屏函数</li><li>夫朗禾费衍射的傅立叶频谱分析</li><li>阿贝成像原理和相衬显微镜</li></ul><h2 id="变换光学">变换光学</h2><p>前面几章，我们使用波的叠加来分析描述干涉衍射，而傅立叶变化光学中，我们使用光场变换的观点来看待干涉衍射</p><p>傅立叶光学的本质就是将复杂的光学现象切分为多个不同频率、不同取向的正弦光栅之和</p><blockquote><p>傅立叶展开的本质是将复杂的函数切分为多个三角函数之和</p></blockquote><h3 id="屏函数">屏函数</h3><p>衍射屏左侧的空间叫照明空间，其中的场被称为入射场$\tilde{U}_1$</p><p>衍射屏右侧的空间叫衍射空间，其中的场被称为衍射场$\tilde{U}_2$</p><p>接收屏处的场叫接收场$\tilde{U}$</p><img src="/images/傅立叶衍射.png" class="lazyload" data-srcset="/images/傅立叶衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="傅立叶衍射" style="zoom:50%;" /><p>使用<strong>屏函数</strong>$\tilde{t}$来描述衍射屏对入射光的波前的改变</p><p>$$<br>\tilde{t}(x,y)=\frac{\tilde{U}_1}{\tilde{U}_2}=t(x,y)\exp [i\varphi_t(x,y)]<br>$$</p><ul><li>$t(x,y)$是屏函数的模，若模为固定值，则该衍射屏为相位型。比如透镜、棱镜</li><li>$\varphi_t$是屏函数的相位，若相位为固定值，则该衍射屏为振幅型。比如单孔、圆孔</li></ul><h3 id="相因子判断法">相因子判断法</h3><h2 id="正弦光栅衍射">正弦光栅衍射</h2><p>正弦光栅从数学上，就是傅立叶级数的基函数</p><h3 id="光栅">光栅</h3><p>光栅：具有周期性的空间结构或光学性能的衍射屏统称为光栅</p><p>光栅的种类：</p><ul><li>透射光栅、反射光栅</li><li>平面光栅、凹面光栅</li><li>黑白光栅、正弦光栅</li><li>一维、二维、三维光栅</li></ul><h2 id="阿贝成像原理">阿贝成像原理</h2><p>衍射屏的屏函数可以展开为傅立叶级数</p><img src="/images/傅立叶屏函数.png" class="lazyload" data-srcset="/images/傅立叶屏函数.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="傅立叶屏函数" style="zoom:50%;" /><h2 id="相衬显微镜">相衬显微镜</h2><p>显微镜看的切片都很薄，对光的吸收很小，如果不染色，很难引起透射光振幅的变化，因此显微镜是相位型的</p><p>如果我们想要显微镜看东西更清楚，可以通过增加相位移的方式增大图像的反衬度（衬比度）</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：衍射</title>
      <link href="/optics/%E8%A1%8D%E5%B0%84/"/>
      <url>/optics/%E8%A1%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1>七：衍射</h1><h2 id="内容概述">内容概述</h2><ul><li>衍射（Diffraction），光在传播途中偏移直线传播，强度重新分布的过程</li><li>惠更斯-菲涅尔原理</li><li>定量分析衍射</li><li>统一衍射和直线传播</li></ul><h2 id="衍射">衍射</h2><p>衍射是光在传播途中偏移直线传播，强度重新分布的过程</p><blockquote><p>物体遮挡光线，就会产生阴影</p><p>在几何光学中，平行光只会被完全遮挡/完全不遮挡，因此阴影应该是清晰的</p><p>但现实中的平行光阴影是软阴影，其实就是发生了衍射</p><p>点、面光源的软阴影是由于光源由尺寸</p></blockquote><img src="/images/光的衍射.png" class="lazyload" data-srcset="/images/光的衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="光的衍射" style="zoom:50%;" /><p>一组平行的波阵面通过小孔，会变成圆形</p><img src="/images/衍射.png" class="lazyload" data-srcset="/images/衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="衍射" style="zoom:50%;" /><p>波长越长，越容易观测到衍射</p><ul><li>小孔尺寸在波长的1000倍左右时衍射现象不明显</li><li>小孔尺寸在波长的10倍左右时衍射十分明显</li><li>小孔尺寸和波场相近时会发生散射</li></ul><h3 id="衍射的分类">衍射的分类</h3><ul><li>菲尼尔衍射（近场衍射）：光源和接收屏距离有限</li><li>夫朗禾费衍射（远场衍射）：光源和接收屏距离无限（也就是入射光是平行光）</li></ul><p>夫朗禾费衍射需要用透镜将平行光汇聚</p><img src="/images/三种衍射.png" class="lazyload" data-srcset="/images/三种衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="三种衍射" style="zoom:50%;" /><h3 id="光栅衍射">光栅衍射</h3><p>多光束干涉和单缝衍射的混合</p><p>多光束干涉决定明条纹位置<br>$$<br>d\sin \theta=k\lambda<br>$$<br>缺级<br>$$<br>k=\frac{d}{a}k’<br>$$</p><h3 id="干涉与衍射的关系">干涉与衍射的关系</h3><p>相同：</p><ul><li>干涉和衍射都是相干叠加</li></ul><p>不同：</p><ul><li>干涉是离散点光源叠加求和，衍射是连续次波源叠加积分</li><li>干涉满足几何光学规律，衍射不满足几何光学规律</li></ul><h2 id="惠更斯-菲涅尔原理">惠更斯-菲涅尔原理</h2><h3 id="惠更斯">惠更斯</h3><p>惠更斯：波阵面上每一个点，本质上是一个球面次级小波的发射源，下一个波阵面实际上是这些球面的包络线（envelope）</p><img src="/images/惠更斯原理.png" class="lazyload" data-srcset="/images/惠更斯原理.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="惠更斯原理" style="zoom: 33%;" /><p>理论的作用</p><ul><li>根据这个理论，给定一个波阵面，我们可以画出下一个波阵面</li><li>解释了光在各向同性介质中的传播原理</li><li>解释了反射和折射公式</li></ul><p>局限性</p><ul><li>无法区分光沿直线传播和发生衍射的条件</li><li>无法定量分析衍射强度</li><li>根据该理论，应该会有反转波</li></ul><h3 id="菲涅尔">菲涅尔</h3><p>菲涅尔修正了惠更斯的理论</p><ul><li>波阵面上每一个（无阻塞）点都是球面波的发射源，频率与主波相同</li><li>不在波阵面上的点，都是由小波相干叠加得到的</li></ul><p><strong>衍射是无数干涉的叠加</strong></p><h4 id="倾斜因子">倾斜因子</h4><p>惠更斯的理论会应该会存在向后的波，菲涅尔引入了倾斜因子（Tilt factor）<br>$$<br>F(\theta_0, \theta)=\frac{1}{2}(\cos\theta_0+\cos \theta)<br>$$<br><img src="/images/倾斜因子.png" class="lazyload" data-srcset="/images/倾斜因子.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="倾斜因子" style="zoom:50%;" /></p><p>倾斜因子的引入使得向后的波强度为0，自然就不会出现反转波</p><p>不过倾斜因子的引入是纯经验，这也是菲涅尔理论的局限性</p><h3 id="基尔霍夫积分定律">基尔霍夫积分定律</h3><p>基尔霍夫在倾斜因子的基础上添加了一个常数K，提供了一个$-\pi/2$的相位差<br>$$<br>K=\frac{e^{-i\pi/2}}{\lambda}<br>$$<br>于是衍射积分公式转化为：</p><img src="/images/基尔霍夫求解波动方程.png" class="lazyload" data-srcset="/images/基尔霍夫求解波动方程.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="基尔霍夫求解波动方程" style="zoom:50%;" /><h3 id="巴俾涅原理">巴俾涅原理</h3><p>两个互补的衍射屏叠加，效果等同于自由传播</p><h2 id="半波带法">半波带法</h2><p>下图为单缝夫朗禾费衍射，计算方法为半波带法</p><img src="/images/单缝夫朗禾费.png" class="lazyload" data-srcset="/images/单缝夫朗禾费.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="单缝夫朗禾费" style="zoom:50%;" /><img src="/images/夫朗禾费衍射.png" class="lazyload" data-srcset="/images/夫朗禾费衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="夫朗禾费衍射" style="zoom: 33%;" /><p>波带数<br>$$<br>\frac{a \sin \theta}{\lambda/2}<br>$$</p><ul><li>a是衍射屏孔径</li></ul><p>暗纹位置（暗纹准确，明纹不准确）<br>$$<br>a \sin \theta = \pm k \lambda<br>$$<br>中央明纹宽度<br>$$<br>\Delta x_0=2f\frac{\lambda}{a}<br>$$</p><h2 id="衍射图样">衍射图样</h2><h3 id="单缝衍射">单缝衍射</h3><h3 id="圆孔衍射">圆孔衍射</h3><p>圆孔衍射：亮暗相间的同心圆环，中心可能是暗也可能是亮的</p><p>中心强度与孔径明暗，与屏幕距离不敏感</p><img src="/images/圆孔衍射.jpeg" class="lazyload" data-srcset="/images/圆孔衍射.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="圆孔衍射" style="zoom:60%;" /><p>Airy斑：中心圆斑</p><p>瑞丽判据：如果一个物点的Airy斑的边缘在另一个Airy斑中心上，那么这两个物点恰好可分辨</p><h3 id="圆屏衍射">圆屏衍射</h3><p>圆屏衍射：亮暗相间的同心圆环，但中心总是一个亮点</p><p>亮点与物体大小、屏幕距离都无关，这个亮点我们称为柏松亮斑</p><img src="/images/圆屏衍射.png" class="lazyload" data-srcset="/images/圆屏衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="圆屏衍射" style="zoom:50%;" /><blockquote><p>一个圆球的影子，中心居然会有一个亮点，衍射，很神奇吧</p></blockquote><h3 id="光栅衍射-2">光栅衍射</h3><h2 id="菲涅尔波带片">菲涅尔波带片</h2><p>根据菲尼尔衍射原理，将偶数个半波带遮挡住，就能得到菲涅尔波带片（就是对一个平整的圆形玻璃，将其表面部分图黑一个个同心圆环）</p><img src="/images/菲涅尔波带片.png" class="lazyload" data-srcset="/images/菲涅尔波带片.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="菲涅尔波带片" style="zoom:50%;" /><p>若一个波带片有20个半波带，遮挡偶数个半波带，轴上中心点的光强为<br>$$<br>A’=A_1+A_2+A_3+A_4+A_{19}\approx 10A_1=20A_0<br>$$</p><p>$$<br>I’=A’^2=400A_0^2=400I<br>$$<br>我们发现中心点的光强变强，因此菲涅尔波带片相当于透镜，可以汇聚光强</p><h3 id="涂黑半径">涂黑半径</h3><p>$$<br>\rho_K=\sqrt{k}\rho_1<br>$$</p><ul><li>k取1,2,3…</li></ul><h3 id="成像公式">成像公式</h3><p>$$<br>\frac{1}{R}+\frac{1}{b}=\frac{1}{f}<br>$$</p><ul><li>R：点光源到波带片的距离</li><li>b：波带片到汇聚点到距离</li></ul><h3 id="波带片与透镜">波带片与透镜</h3><ul><li>相同<ul><li>都能汇聚能量</li></ul></li><li>不同<ul><li>透镜只有一个汇聚点，波带片有多个实汇聚点和虚汇聚点</li><li>透镜满足等光程性，波带片相邻波带片间有一个波长的光程差</li><li>波带片面积大、轻便、可折叠</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：干涉</title>
      <link href="/optics/%E5%B9%B2%E6%B6%89/"/>
      <url>/optics/%E5%B9%B2%E6%B6%89/</url>
      
        <content type="html"><![CDATA[<h1>六：干涉</h1><h2 id="内容概述">内容概述</h2><ul><li>干涉（Interference），光的叠加不满足线性叠加，证明了光的波性</li><li>干涉条件</li><li>干涉方法与装置</li><li>干涉仪</li></ul><h2 id="干涉">干涉</h2><p>干涉让光学从线性光学变成非线性光学</p><h3 id="线性光学">线性光学</h3><p>在几何光学中，我们认为光是独立传播的</p><p>光是一种横波，光在介质中传播会引起介质粒子振动，若独立传播成立，那么两束光的交叉区域，粒子的振动是两个振动的叠加，这就是<strong>叠加原理</strong></p><p>光的叠加实际上是介质的性质（因为描述的是介质粒子振动的叠加）</p><ul><li>线性介质：在该介质中，波满足叠加原理</li><li>非线性介质：在该介质中，波不满足叠加原理</li></ul><p>违反叠加原理的介质是非线性介质，现象是非线性现象，学科是非线性光学</p><p>此外，叠加原理只有在低强度光下才成立，因此激光发明后，非线性光学才蓬勃发展</p><h3 id="复振幅叠加法">复振幅叠加法</h3><p>求解相干光强有三种方法，实际分析时通常使用复振幅法</p><ul><li>三角函数法：波可以由三角函数表示，对三角函数做恒等变化，即可求相干光强</li><li>矢量图解法</li><li>复振幅法</li></ul><p>首先将三角函数表示为复振幅<br>$$<br>\tilde{\mathbf{E}_i}=\mathbf{A}_i e^{i\varphi <em>i}<br>$$<br>复振幅的叠加<br>$$<br>\tilde{\mathbf{E}}=\sum</em>{i=1}^n\tilde{\mathbf{E}_i}<br>$$<br>合光强<br>$$<br>I = \tilde{\mathbf{E}}\cdot \tilde{\mathbf{E}}^*<br>$$</p><h3 id="相干叠加">相干叠加</h3><p>现在有两个相同频率（frequency）相同偏振（polarization）的光波，下面是他们电场强度随时间的变化（用复数表示三角函数）<br>$$<br>\mathbf{E_1}=\mathbf{A_1} e^{i(kr_1-\omega t+\varphi _{01})}<br>$$</p><p>$$<br>\mathbf{E_2}=\mathbf{A_2} e^{i(kr_2-\omega t+\varphi _{02})}<br>$$</p><p>他们相交于点P，根据叠加原理，P点点电场强度为<br>$$<br>\mathbf{E}=\mathbf{E_1}+\mathbf{E_2}=[\mathbf{A_1}e^{i(kr_1+\varphi_{01})} + \mathbf{A_2}e^{i(kr_2+\varphi_{02})}]e^{-i\omega t}<br>$$<br>显然，振幅为<br>$$<br>\tilde{\mathbf{E}}=\mathbf{A_1}e^{i(kr_1+\varphi_{01})} + \mathbf{A_2}e^{i(kr_2+\varphi_{02})}<br>$$<br>由于光过于高频，我们没法实时进行光电场强度的检测，于是我们使用光强（intensity，$I$）来进行推导</p><p>$$<br>I \propto \tilde{\mathbf{E}}\cdot \tilde{\mathbf{E}}^*=\mathbf{A_1}^2+\mathbf{A_2}^2+2\mathbf{A_1A_2}\cos(kr_1-kr_2+\varphi_{01}-\varphi_{02})<br>$$</p><p>$$<br>I = I_1+ I_2 + 2\sqrt{I_1I_2}\cos \delta<br>$$</p><p>$$<br>\delta=kr_1-kr_2+\varphi_{01}-\varphi_{02}<br>$$</p><p>我们发现，两个光波进行叠加，光强不只是简单叠加，还有一个尾巴，这个尾巴就是<strong>干涉</strong></p><p>干涉：因波的叠加引起强度重新分布的现象</p><p>并且我们发现：</p><ul><li><p>干涉强度与时间无关，与空间位置有关，且保持不变</p></li><li><p>当$\delta=2m\pi$，干涉强度最大，我们称之为构造干涉（constructive interference）</p></li></ul><p>$$<br>I=(\mathbf{A_1}+\mathbf{A_2})^2<br>$$</p><ul><li>当$\delta=(2m+1)\pi$，干涉强度最小，我们称之为相消干涉（destructive interference）</li></ul><p>$$<br>I=(\mathbf{A_1}-\mathbf{A_2})^2<br>$$</p><h3 id="非相干叠加">非相干叠加</h3><p>一般而言，两个光频率和偏振不一样，经过推导<br>$$<br>I_{12}=2\mathbf{A_1}\cdot \mathbf{A_2} \cos [(\omega_2 - \omega_1)t + \theta_1 - \theta_2]<br>$$<br>我们到处干涉强度为0的条件</p><ul><li>两个光频率不同，$\cos[…]$的均值为0</li><li>两个光光矢量垂直，$\mathbf{A_1}\cdot \mathbf{A_2}=0$</li><li>两个光夹角（相位差）迅速且无序变化，$\cos[…]$的均值为0</li></ul><h3 id="干涉条件">干涉条件</h3><p>因此我们总结出发生干涉的条件</p><ul><li>频率相同</li><li>相同的平行分量</li><li>固定的相位差</li></ul><p>如果不满足干涉条件，那么平均下来<br>$$<br>I=I_1+I_2<br>$$</p><h2 id="杨氏干涉">杨氏干涉</h2><p>普通光源：普通光源的发光单位为原子、分子，不同原子间的发光是独立的，他们的频率、偏振、相位都是不同的，因此他们的光是不会发生干涉的</p><p>有干涉条件我们可以得出两种获得干涉光的方法：</p><ul><li>分波前法（杨氏干涉）</li><li>分振幅法（薄膜等厚干涉）</li></ul><p>使用杨氏干涉实验、菲涅尔双棱镜、劳埃德镜可以将普通光源变成干涉光</p><p><img src="/images/%E6%99%AE%E9%80%9A%E5%85%89%E6%BA%90%E7%9B%B8%E5%B9%B2%E5%85%89.png" class="lazyload" data-srcset="/images/%E6%99%AE%E9%80%9A%E5%85%89%E6%BA%90%E7%9B%B8%E5%B9%B2%E5%85%89.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="普通光源相干光"></p><p>杨氏干涉，两束光的出相相同，因此干涉光的相位差只取决于光程差<br>$$<br>\Delta \varphi= \frac{2\pi  }{\lambda}\Delta OPL=k\delta<br>$$</p><ul><li>k：波数，$k=\frac{2\pi}{\lambda}$</li><li>$\delta$：光程差</li></ul><h3 id="衬比度">衬比度</h3><blockquote><p>衬比度，也可以叫做可见度</p></blockquote><p>干涉条纹的衬比度（constrast）定义为<br>$$<br>\gamma = \frac{I_\max-I_\min}{I_\max + I_\min}<br>$$<br>用于描述条纹的反差程度，当可见性为1时最清晰，当为0时完全不可分辨</p><h3 id="杨氏双缝干涉实验">杨氏双缝干涉实验</h3><p>杨氏实验是通过两个点波光源进行干涉实验的典型</p><p>如果光是一种波，那么光在传播过程中应该会有波前（传播最靠前的波阵面），提取一个波前，并将其分为两部分，就能得到两个相干光</p><p>现在有一个非常窄的单色光源，经过两个带缝平面，会生成两个相干光，进而发生衍射现象，在平面留下明暗条纹</p><p><img src="/images/%E6%9D%A8%E6%B0%8F%E5%8F%8C%E7%BC%9D%E5%B9%B2%E6%B6%89.png" class="lazyload" data-srcset="/images/%E6%9D%A8%E6%B0%8F%E5%8F%8C%E7%BC%9D%E5%B9%B2%E6%B6%89.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="杨氏双缝干涉"></p><p>$$<br>I=A^2=4I_1\cos^2\frac{\pi \Delta}{\lambda}<br>$$</p><ul><li>若$\Delta=m\lambda, I=I_{max}=4I_1$，呈现亮条纹</li><li>若$\Delta=(2m-1)\lambda/2, I=I_{min}=0$，呈现暗条纹</li></ul><p>杨氏干涉实验的衬比度为<br>$$<br>\gamma = \frac{2(A_1/A_2)}{1+(A_1/A_2)^2}<br>$$<br><img src="/images/杨氏干涉.png" class="lazyload" data-srcset="/images/杨氏干涉.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="杨氏干涉" style="zoom: 50%;" /></p><p>当间距不大时，角度比较小，缝间距是相同的，间距为<br>$$<br>\Delta x=\frac{D}{d}\lambda<br>$$</p><h3 id="判断一点的暗亮">判断一点的暗亮</h3><blockquote><p>看上图</p></blockquote><p>在杨氏干涉实验中，给定$d,D,x$，判断点在明条纹中还是暗条纹中</p><p>核心思想就是：判断光程差是半波长的偶数倍还是奇数倍，偶数为明条纹，基数为暗条纹</p><ol><li>以P点为圆心，$S_1P$为半径画一个圆，圆和$S_2P$相交于点$S’$，那么$S_2S’$就是光程差</li><li>不过$S_2S’$很难求，于是我们进行近似，我们从$S_1$出发做$S_2P$的垂线，垂足可以近似为点$S’$</li><li>我们知道斜边长度为d，只要知道$\angle S_2S_1S’$，就能求出光程差</li><li>不过$\angle S_2S_1S’$还是太难求了，我们用角$\theta$来近似</li><li>$\sin \theta \approx \tan \theta = x/D$</li><li>有了光程差，就能知道这是几个波长，是明是暗</li></ol><h3 id="可见条纹的最大级数">可见条纹的最大级数</h3><p>$$<br>j_\max= d/\lambda<br>$$</p><h3 id="求P点光强">求P点光强</h3><p>$$<br>I=A_1^2+A_2^2+2A_1A_2\cos \Delta\varphi<br>$$</p><p>$$<br>\Delta \varphi = k \cdot \delta<br>$$</p><h3 id="干涉条纹的移动">干涉条纹的移动</h3><p>我们不仅观测到明暗条纹，还观测到条纹的移动和变化</p><ul><li><p>移动光源，对于屏幕上一点，求多少个条纹经过该点</p><ul><li>对于屏幕上点P，经过点P的条纹数取决于两条相干光线的光程差（OPL）</li><li>当光程差增减一个$\lambda$时，就会经过一条条纹</li></ul></li><li><p>移动光源，对于特定的一个条纹，求其移动了多长距离</p><ul><li>杨氏双缝中</li></ul></li></ul><p>$$<br>\delta x = -\frac{D}{R}\delta s<br>$$</p><img src="/images/条纹移动.png" class="lazyload" data-srcset="/images/条纹移动.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="条纹移动" style="zoom:50%;" /><h3 id="其他干涉仪器">其他干涉仪器</h3><p>本质都是杨氏双缝干涉，条纹间距都满足<br>$$<br>\Delta x=\frac{D}{d}\lambda<br>$$</p><p>这些干涉仪器相比起杨氏干涉，不使用狭缝过滤光，因此光线强度更高</p><h4 id="菲涅尔双平面镜">菲涅尔双平面镜</h4><img src="/images/菲尼尔双平面镜.png" class="lazyload" data-srcset="/images/菲尼尔双平面镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="菲尼尔双平面镜" style="zoom:50%;" /><h4 id="劳埃德镜">劳埃德镜</h4><img src="/images/劳埃德镜.png" class="lazyload" data-srcset="/images/劳埃德镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="劳埃德镜" style="zoom:67%;" /><h4 id="菲涅尔双棱镜">菲涅尔双棱镜</h4><img src="/images/菲涅尔双棱镜.png" class="lazyload" data-srcset="/images/菲涅尔双棱镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="菲涅尔双棱镜" style="zoom:50%;" /><h4 id="彩色光杨氏双缝">彩色光杨氏双缝</h4><p>如果传入的是白光，条纹将为彩色</p><img src="/images/杨氏干涉彩色条纹.png" class="lazyload" data-srcset="/images/杨氏干涉彩色条纹.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="杨氏干涉彩色条纹" style="zoom:50%;" /><h2 id="时空相干性">时空相干性</h2><p>现实中的普通光源的发光单元为原子、分子，靠自发辐射发光（激光光源靠受激辐射），这是一个随机过程，产生的光是随机、无规律、不相干的。看起来我们无法用普通光源做干涉实验，但实际上杨氏双缝是可以使用普通光源的，因为杨氏双缝中两个光都是由同一束光分割而成的</p><p>尽管普通光源的相位随机，但是杨氏双缝两束光的相位差与原光源相位无关，仅与空间位置有关</p><p>不过，光源的尺寸和光谱尺寸仍然会对杨氏干涉产生影响</p><p>在杨氏干涉中，我们使用了很窄的单色光源，然而现实中光源总是有尺寸，其颜色也不是单色而是光谱中一小段</p><p>空间相干性：光源尺寸对干涉强度的影响</p><p>时间相干性：光谱尺寸对干涉强度的影响（也就是说光不是真的纯色）</p><h3 id="空间相干性">空间相干性</h3><p>任何光源都有一定的宽度，我们将其视为多个不相干的点光源排布，屏幕上的总强度为各个光源的干涉条纹的线性叠加</p><p>我们发现沿着x轴方向的长度会让条纹模糊</p><p>沿着y轴方向的长度会让亮纹和亮纹重叠，于是条纹更清晰</p><p>我们在做杨氏双缝时常常使用平行于y轴方向的光</p><img src="/images/光源宽度.png" class="lazyload" data-srcset="/images/光源宽度.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="光源宽度" style="zoom:50%;" /><img src="/images/空间相干性.JPG" class="lazyload" data-srcset="/images/空间相干性.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="空间相干性" style="zoom:50%;" /><h3 id="时间相干性">时间相干性</h3><p>现实中光不是纯色光，光的波长不同，干涉条纹长度不同，于是不同波长的干涉条纹就会发生重叠，进而降低条纹的衬比度</p><h2 id="薄膜干涉">薄膜干涉</h2><p>薄膜（film）一种透明介质，将空间划分三个折射率不同的区域，其中中间的区域不能过厚</p><p>薄膜干涉（Thin film interference）：光在薄膜表面发生反射和折射，下表面的反射光和上表面的折射光发生干涉</p><blockquote><p>比如彩色太阳眼镜和阳光下的七彩肥皂泡</p></blockquote><p>光线在射向薄膜后会发生反射和透射，透射光可能会再次反射透射，返回薄膜表面，进而和入射光相遇，发生干涉</p><ul><li>等厚干涉：发散的入射光（点光）和透射光干涉，干涉发生在薄膜表面</li><li>等倾干涉：平行的透射光干涉，干涉发生在无穷远，需要用透镜汇聚，形状为同心条纹</li></ul><p>特别注意！等厚和等倾是指的条纹间距，而不是薄膜形状，等厚的条纹需要上下不平行的薄膜</p><h3 id="等厚度干涉">等厚度干涉</h3><img src="/images/薄膜干涉.png" class="lazyload" data-srcset="/images/薄膜干涉.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="薄膜干涉" style="zoom:50%;" /><p>等厚干涉发生在薄膜表面</p><p>厚度不均匀的薄膜发生的干涉，入射光为<strong>平行光</strong>，决定条纹间距的是因厚度不均带来的光程差<br>$$<br>\delta = 2nh\sqrt{n^2-n_0^2\sin^2 i_1} +\lambda/2<br>$$</p><ul><li>$i$是折射角</li></ul><p>常见的等厚干涉有</p><ul><li>劈尖：光线垂直入射<ul><li>角度越大，条纹数量越多</li><li>折射率越大，条纹间距越大</li></ul></li></ul><p><img src="/images/%E7%A9%BA%E6%B0%94%E5%8A%88%E5%B0%96.png" class="lazyload" data-srcset="/images/%E7%A9%BA%E6%B0%94%E5%8A%88%E5%B0%96.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="空气劈尖"></p><ul><li>牛顿环</li></ul><p><img src="/images/%E7%89%9B%E9%A1%BF%E7%8E%AF.png" class="lazyload" data-srcset="/images/%E7%89%9B%E9%A1%BF%E7%8E%AF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="牛顿环"></p><h3 id="增透膜与高反膜">增透膜与高反膜</h3><blockquote><p>汽油膜，肥皂泡，昆虫翅膀</p></blockquote><p>厚度均匀的薄膜发生的干涉，入射光为<strong>平行光</strong>，各个方向的干涉增强被分离出去</p><h4 id="增透膜">增透膜</h4><p>n2的反射光被干涉相消，根据能量守恒，透射光会更多</p><p>折射率<br>$$<br>n=\sqrt{n_1n_2}<br>$$<br>$$<br>n_1 &lt; n &lt; n_2<br>$$</p><p>厚度<br>$$<br>h=\frac{\lambda_0}{4n}<br>$$</p><img src="/images/增透膜.png" class="lazyload" data-srcset="/images/增透膜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="增透膜" style="zoom:50%;" /><h4 id="增反膜">增反膜</h4><p>反射被干涉增强，透射光会减少</p><p>折射率<br>$$<br>n &gt; n_1 且 n &gt; n_2<br>$$<br>厚度<br>$$<br>h=\frac{\lambda_0}{4n}<br>$$</p><h3 id="等倾斜角干涉">等倾斜角干涉</h3><img src="/images/等倾干涉.png" class="lazyload" data-srcset="/images/等倾干涉.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="等倾干涉" style="zoom:50%;" /><p>等倾干涉发生在无穷远处</p><p>上下表面平行的薄膜发生的干涉，入射光为<strong>点光源</strong><br>$$<br>\delta = 2nh\cos i_2<br>$$</p><h4 id="半波损失">半波损失</h4><p>波从光疏射向光密，在反射过程中会产生$\pi$个相位跃变，我们称之为<strong>半波损失</strong></p><p>由于半波损失的存在，薄膜干涉明暗条纹的产生条件实际上与杨氏双缝相反<br>$$<br>\delta = 2nh\cos i_2 + \lambda/2<br>$$</p><h4 id="等倾图样">等倾图样</h4><p>内高外低，内疏外密</p><img src="/images/等倾图样.png" class="lazyload" data-srcset="/images/等倾图样.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="等倾图样" style="zoom: 67%;" /><h2 id="干涉仪">干涉仪</h2><h3 id="多光束干涉">多光束干涉</h3><img src="/images/多光束干涉.png" class="lazyload" data-srcset="/images/多光束干涉.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="多光束干涉" style="zoom:50%;" />$$\Delta L=2nh\cos i$$光在介质内不断反射折射，新的反射折射光强度成等比数列<h3 id="迈克耳孙干涉仪">迈克耳孙干涉仪</h3><p>使用分振幅法将两个相互垂直的平面镜等效为空气薄膜，空气薄膜可以等倾，也可以等厚</p><img src="/images/迈克耳孙.png" class="lazyload" data-srcset="/images/迈克耳孙.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="迈克耳孙" style="zoom:50%;" /><h3 id="法布里-珀罗干涉仪">法布里-珀罗干涉仪</h3><p>由两个梯形透镜组成，用于生成等倾干涉条纹</p><img src="/images/法布里-珀罗.png" class="lazyload" data-srcset="/images/法布里-珀罗.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="法布里-珀罗" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的智慧</title>
      <link href="/program/AskQuestion/"/>
      <url>/program/AskQuestion/</url>
      
        <content type="html"><![CDATA[<h1>提问的智慧</h1><p>提问的方式，可能会很大程度影响你是否能得到有用的回答</p><h3 id="树立好的形象">树立好的形象</h3><p>当你想问问题，一定要树立你的形象：我已经做了努力，我不是一个不劳而获且浪费别人时间的提问者</p><p>你可以做的努力有</p><ul><li>网上搜素</li><li>查看文档、手册、issuse</li><li>看看源码</li><li>自己先做试验</li></ul><h3 id="问题不要带有错误的预设">问题不要带有错误的预设</h3><p>草率的发问只会得到草率的回答，如果你的预设错了，下面的尝试和思考都是无用功</p><blockquote><p>很多民科认为自己推翻了相对论、微积分，很有可能是使用了一个错误的预设</p></blockquote><blockquote><p>not even wrong</p><p>Q：你是哪个省的</p><p>Right：四川省</p><p>Wrong：西藏省</p><p>Not even wrong：妈妈生的</p></blockquote><h3 id="不要明知故问">不要明知故问</h3><p>特别要批评哪些为了“耍存在感”而明知自问，列举了一大串知识试图诱导他人的思路，然后在最后向别人进行提问</p><h3 id="不要认为自己够格得到回答">不要认为自己够格得到回答</h3><p>如果你没有为这个问题付费，那你不要期待自己一定能得到好的回答，你需要通过靠提出有内涵的、有趣的、有思维激励作用的问题<strong>挣得</strong>回答</p><h3 id="选择正确的提问地点">选择正确的提问地点</h3><p>不要在主题不和的论坛贴出你的问题</p><blockquote><p>比如在NS吧问原神好不好玩，在A9问XGPU是否值得购买</p></blockquote><p>不要在进阶的论坛中问低级问题，反之亦然</p><blockquote><p>比如你认为火箭燃料应该用水洗煤，在太空应该用铅笔替代</p></blockquote><p>不要在不同的论坛反复问同一件事</p><blockquote><p>这让人感觉你在大喊大叫</p></blockquote><p>不要向陌生人发私人邮件</p><blockquote><p>你没有付费，别人就没有必要回答，更不要说私聊对方让他“加班”</p></blockquote><p>可以试一试在Stack Overflow问程序相关的问题</p><h3 id="向一个群体提问，而非个人">向一个群体提问，而非个人</h3><p>个人没有义务回答你的问题</p><p>向群体问一个好问题能对整个群体有益，你的提问可以被后来者看到</p><p>向群体问问题能减轻某个个人的压力</p><h3 id="描述问题">描述问题</h3><h4 id="使用有意义的标题">使用有意义的标题</h4><p>使用<code>目标-差异</code>做标题</p><blockquote><p><a href="http://X.org">X.org</a> 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形</p></blockquote><h4 id="言之有物">言之有物</h4><p>低声下气不如清晰地说明情况</p><p>不要使用</p><blockquote><p>大佬，求救</p><p>在线等，很急</p><p>我是一个菜鸡，呜呜呜</p><p>有人能帮帮我吗</p></blockquote><p>如果你真的很菜，你可以去一些更入门的论坛去搜寻答案（菜的远远不止你一个人，因此你遇到的问题很可能其他人也会遇到）</p><h4 id="不要擅自声称找到bug">不要擅自声称找到bug</h4><p>如果你没有非常明确的根据，不要擅自声称找到了bug（很可能是因为你不会用导致的）</p><p>如果你对该软件还没有足够的了解，就声称自己遇到的困难是bug，这可能会惹恼软件作者</p><p>即使真的有bug，你最好要写的像是你做错了什么，给开发者一个台阶下，他可能反过来给你说抱歉</p><h4 id="不要进行猜测">不要进行猜测</h4><p>如果你的猜测有效，那还用向别人求助吗？</p><p>你认为问题是怎么来的并不重要，重要地是描述问题本身，你的错误推测甚至可能会影响回答者的思路</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下…</p></blockquote><h4 id="按时间顺序描述问题症状">按时间顺序描述问题症状</h4><h4 id="描述目标而非过程">描述目标而非过程</h4><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。</p></blockquote><h3 id="问题解决后">问题解决后</h3><p>问题解决后你应该感谢帮助你的人</p><p>将标题修改为<strong>已解决</strong>，并在最后补充说明，你是如何解决问题的</p><h3 id="参考">参考</h3><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">How to Ask Question</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSSR</title>
      <link href="/graphics/SSSR/"/>
      <url>/graphics/SSSR/</url>
      
        <content type="html"><![CDATA[<h1>《Stochastic Screen Space Reflections》阅读笔记</h1><p>2015年SIGRAPH，EA提出了SSSR，用于《镜之边缘》中镜面反射</p><p>需求有</p><ul><li>支持清晰（sharp）和模糊（blurry）反射</li><li>邻接性，越近反射越清晰（contact hardening）</li><li>高光拉伸</li><li>逐像素的粗糙度和法线</li></ul><h2 id="相关工作">相关工作</h2><h3 id="mirror-only-SSR">mirror-only SSR</h3><p>我们先回顾传统的SSR</p><ol><li>从屏幕像素开始RayMarching（需要View空间的世界坐标和法线）</li><li>根据深度可以很轻松找到第一个落点，根据法线很容易求出反射光线的角度</li><li>使用简单的线性步进，求反射光线的命中点<ol><li>反射光线向前步进一段距离，到达C点</li><li>通过三角形边角性质，可以求出C点距离镜头的距离，这其实就是View空间的深度</li><li>若C点距离镜头的距离小于等于深度，则说明命中</li></ol></li><li>将命中位置进行透视投影，使用上一帧的渲染结果作为反射颜色</li></ol><img src="/images/SSR.png" class="lazyload" data-srcset="/images/SSR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SSR" style="zoom:50%;" /><h3 id="glossy-SSR">glossy SSR</h3><h4 id="模糊滤波">模糊滤波</h4><p>杀戮尖塔提供了一种glossy SSR，就是对反射像素做一次卷积模糊，但这种模糊是一视同仁的模糊，没有实现越近越清晰</p><h4 id="重要性采样">重要性采样</h4><p>相对于普通的SSR，这里根据法线求反射光线方向时，加入一些随机偏差，反射光线形成了一个锥形，进而实现了模糊的SSR</p><p>当物体离反射面比较近时，根据正弦定理，滤波的像素数量更少，于是清晰度更高</p><p>但是在光线数量比较少的情况下，会有大量噪点，效果很差</p><img src="/images/SSR噪点.png" class="lazyload" data-srcset="/images/SSR噪点.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SSR噪点" style="zoom:50%;" /><h2 id="作者的算法">作者的算法</h2><img src="/images/SSSR.png" class="lazyload" data-srcset="/images/SSSR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SSSR" style="zoom: 67%;" /><ol><li>将屏幕划分为Tile，进行一次低分辨率的光线步进，评估Tile的重要性，需要多少射线</li><li>根据材质粗糙度判断使用何种的RayMarching<ul><li>昂贵的射线：借助Hi-Z的精确tracing，能得到准确的命中点<ul><li>用于smooth表面</li></ul></li><li>便宜的射线：简单的线性步进<ul><li>用于粗糙表面（反正会做严重的滤波，不需要高精度）</li></ul></li></ul></li><li>使用BRDF重要性采样决定射线方向</li><li>使用邻居的采样信息进行模糊</li><li>TAA</li></ol><h2 id="Tile评估">Tile评估</h2><ol><li>对于每一个Tile以1/8分辨率发射射线</li><li>判断射线（的反射光线）是否击中<ol><li>若所有光线都没命中，则跳过这个Tile的步进</li><li>根据命中的比例和命中信息的差异，判断这个Tile中的像素需要多少个光线</li></ol></li></ol><h2 id="Hi-Z-tracing">Hi-Z tracing</h2><blockquote><p>详情可以去看《GPU Pro 5》</p></blockquote><p>Hi-Z使用四叉树组织屏幕深度，将层次关系存储在MipMap层级中，用于加速反射光线的求交</p><p>Hi-Z的构建时，对屏幕尺寸的深度进行滤波，每次保存2x2像素中最浅的像素，也就是说最高级别的Hi-Z存储着整张图中最浅的深度</p><p>用C点表示光线在步进过程中的头坐标，我们射线求交的原理就是判断C点距离相机的距离和该点深度图的深度关系，相交处必然是一侧比C点深，一侧比C点浅</p><p>此外还有几条经验：</p><ul><li>从相机出发的射线，落点位置是View空间该方向最浅的位置</li><li>从相机出发的射线，与落点位置的法线夹角应该大于$45^{\circ}$<ul><li>若夹角小于$45^{\circ}$，那么反射信息来自相机身后的内容，屏幕空间没有这些信息（可以用Cubemap补充信息）</li><li>若夹角大于$45^{\circ}$，那么我们基本可以认为，反射光线在步进过程中，深度在不断变深</li></ul></li><li>我们实际寻找的是，光线在步进过程中，比C点要深的最浅位置（更深，但只能深一点点）</li><li>由于起初我们位于最浅的位置，而步进的光线越来越深，因此第一个min-Z小于C点深度的位置，就是交点位置，我们只需要一直向右，不用回头<ul><li>这样得到的Mip等级比较高，我们通过降低Mip等级，每次取比C深中最浅的那一个，直到Mip为0</li></ul></li></ul><img src="/images/HiZTrace.png" class="lazyload" data-srcset="/images/HiZTrace.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="HiZTrace"  /><p>算法复杂度为$O(\log n)$</p><h2 id="重要性采样-2">重要性采样</h2><blockquote><p>重要性采样是蒙特卡洛积分中用于减少方差的算法，详情可以去看PBRT</p><p>简单来说就是我们有一个积分，我们不得不实时求这个积分，于是我们将这个积分很多项分离出去，最后变成了 复杂离散项 x 一段简单函数的积分</p></blockquote><h3 id="蒙特卡洛积分">蒙特卡洛积分</h3><img src="/images/三角形积分.png" class="lazyload" data-srcset="/images/三角形积分.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="三角形" style="zoom: 33%;" /><p>这是一个三角形，如果我们想求三角形的面积，可以对三角形的高度函数做积分</p><ul><li>第一种切分方法：均匀切分，三角形被分为等宽的长方形，每个长方形长$\Delta x$，高$\sqrt{1-x^2}$</li></ul><p>$$<br>S=\sum _{i=0}^N \Delta x \times h_i<br>$$</p><ul><li>第二种切分方法：重要性切分，左侧长方形更窄，右侧更宽</li></ul><p>$$<br>S=\sum _{i=0}^N x_i \times h_i<br>$$</p><p>三角形切被分为一个个长方形，长方形的面积代表贡献。很显然，左侧的长方形高度越高，相同宽度面积越大，贡献越多。也就是说，相同的x轴变化，左侧部分对积分的影响越明显，越高频</p><p>能看出（在同等误差下）重要性采样所需要的采样次数比均匀采样要小</p><p>重要性采样的思想就是，在高频处我们进行更多次的采样，低频处进行更少的采样，最后根据权重合并，就能在采样次数比较少的情况下，得到最精确的积分值</p><ul><li>高度函数$h_i$就是采样值</li><li>宽度函数$x_i$就是重要性权重</li><li>面积$S$就是在当前概率分布下的采样期望</li></ul><h3 id="概率密度函数">概率密度函数</h3><p>详情可以去看<a href="/2023/01/31/math/%E6%A6%82%E7%8E%87%E8%AE%BA/">概率论</a></p><p>在上一步，我们将连续函数的积分，转化为离散的采样值 x 重要性权重，然后我们发现，这个重要性权重怎么求？</p><p>还是上面的三角形，我们发现横坐标可以取[0, r]中任意值（r为三角形边长）</p><p>因此具体到某个点（随机变量），被取到的概率为$\frac{\mathrm{d}x}{r}$（这里其实不怎么精确，概率论中点取到的概率为0，这里实际上是一段很小的区域被取到的概率）</p><p>对于一个区域[a, b]，我们进行积分，得到随机变量取到该区域的概率P<br>$$<br>P(a &lt; X \le b)=F(b)-F(a)=\int_a^b \frac{1}{r}\mathrm{d}x=\frac{b-a}{r}<br>$$</p><ul><li><p>分布函数：$F(x)$</p></li><li><p>概率密度函数：$1/r$，我们用$p(x)$表示</p></li><li><p>概率：$P(a &lt; X \le b)$</p></li></ul><p>哦，现在我们知道了这个重要性权重有多大了<br>$$<br>x_i=\Delta x/P=1/p(x)<br>$$<br>进而我们可以写出这个三角形面积的期望<br>$$<br>S=\sum _{i=0}^N x_i \times h_i=\lim <em>{N \rightarrow \infty}\frac{1}{N}\sum</em>{k=1}^{N}\frac{f(x_k)}{p(x)}<br>$$</p><p>不过，值得注意的是，我们上面使用的PDF是均匀的，其实并能很好地加速收敛，实际会使用一个和原函数形状类似的PDF来加速收敛（PDF的选择不会影响最终结果，但是会影响收敛速度）</p><img src="/images/重要性采样.png" class="lazyload" data-srcset="/images/重要性采样.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="重要性采样" style="zoom:67%;" /><h3 id="BRDF生成射线方向">BRDF生成射线方向</h3><p>BRDF，双向反射分布函数，用于描述光线进出材质后能量的变化</p><p>我们在实现BRDF时，通常会实现以下接口</p><ul><li>eval：给定入射光方向和视线方向，求BRDF值</li><li>sample：生成射线方向</li><li>pdf：返回sample生成的射线的PDF</li></ul><p>我们以最简单的phong着色为例</p><p>在<a href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html">RTOW</a>中，我们朝着随机半球方向生成向量，该向量就是新射线的方向，同时求出该方向的PDF</p><blockquote><p>我个人理解，射线方向是随机生成的，每个方向出现的可能性相同，但是他们的PDF不同，你可以理解为重要性采样求三角形面积时，每个大长方形是由内部多个（数量相同）等高的小长方形拼成的，但是小长方形的宽度不一致，1/PDF就是小长方形的宽度。越重要的地方，长方形宽度越小，越密集，于是实现了重要性采样</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; alb, ray&amp; scattered, <span class="type">double</span>&amp; pdf)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">            <span class="comment">// Catch degenerate scatter direction</span></span><br><span class="line">            <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">                scatter_direction = rec.normal;</span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">unit_vector</span>(scatter_direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">            alb = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">            pdf = <span class="built_in">dot</span>(rec.normal, scattered.<span class="built_in">direction</span>()) / pi;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面生成新射线方向时，使用法线+球面向量，最后的形状就类似下图红色</p><img src="/images/法线+球.png" class="lazyload" data-srcset="/images/法线+球.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="法线+球" style="zoom:80%;" /><p>还清除了朝下（射向材质内部的）的射线</p><h3 id="随机数">随机数</h3><p>作者使用了<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/The_Halton_Sampler">Halton Sequences</a>生成随机数，并引入了截断，角度有最大值，这样能减弱BRDF的长尾巴（Tail）对结果的影响（这些尾巴会带来很多噪点）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">float2 u = <span class="built_in">halton</span>(sampleIdx);</span><br><span class="line">u.x = <span class="built_in">lerp</span>(u.x, <span class="number">1.0</span>, bias);</span><br><span class="line"><span class="built_in">importanceSample</span>(u);</span><br></pre></td></tr></table></figure><img src="/images/截断.png" class="lazyload" data-srcset="/images/截断.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="截断" style="zoom:67%;" /><h3 id="过滤重要性采样">过滤重要性采样</h3><p>一种基于预计算的光追，我们假设射线是圆锥形，我们可以根据MipMap层级得到滤波结果</p><img src="/images/coneRayTrace.png" class="lazyload" data-srcset="/images/coneRayTrace.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="coneRayTrace" style="zoom:67%;" /><h2 id="复用邻居光线">复用邻居光线</h2><h3 id="复用">复用</h3><p>上面提到glossy ssr会导致严重的噪点问题，即使使用重要性采样，每个像素仍需要大量光线才能得到低噪点的结果</p><p>我们注意到，相邻像素，他们的位置相近，可见性应该也是接近的，那么邻居像素朝某方向发射的光线，其实也可以被当前像素复用</p><p>当然直接做模糊（比如用高斯滤波）会导致很多光斑，经过很多数学推导和近似后，给出了以下公式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">result = <span class="number">0.0</span>;</span><br><span class="line">weightSum = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pixel : neighborhood)&#123;</span><br><span class="line">    weight = <span class="built_in">localBRDF</span>(pixel.hit) / pixel.hitPDF;</span><br><span class="line">    result += <span class="built_in">color</span>(pixel.hit) * weight;</span><br><span class="line">    weightSum += weight;</span><br><span class="line">&#125;</span><br><span class="line">result /= weightSum;</span><br></pre></td></tr></table></figure><h3 id="稀疏">稀疏</h3><p>受邻居光线的启发，我们完全没必要每个像素都做射线，只需要在低分辨率下某些点做多次射线，其邻居使用这个射线结果就可以</p><h3 id="TAA">TAA</h3><p>我们不仅在空间上做射线的复用，也可以在时间上及逆行复用</p><h2 id="参考">参考</h2><p><a href="https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html">SSR</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> GI </tag>
            
            <tag> SIGGRAPH 2015 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Probe-based Lighting in Unity Enemies</title>
      <link href="/graphics/UnityEnemies/"/>
      <url>/graphics/UnityEnemies/</url>
      
        <content type="html"><![CDATA[<h1>《Probe-based Lighting in Unity Enemies》阅读笔记</h1><p>2022年SIGGRAPH，Unity发布了一个数字人项目，在头发、眼球、GI方面效果非常好，我们来分析一下他的Probe-based GI</p><p><a href="http://advances.realtimerendering.com/s2022/SIGGRAPH2022-Advances-Enemies-Ciardi%20et%20al.pdf">论文地址</a></p><blockquote><p>感觉原理上就是在Volume GI的基础上，存了遮罩信息用于偏移采样点，使用紧凑哈希提高了空间利用率，感觉手游大世界完全可以上这个</p></blockquote><img src="/images/Enemies.png" class="lazyload" data-srcset="/images/Enemies.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Enemies" style="zoom:50%;" /><h3 id="不用Lightmap">不用Lightmap</h3><ul><li>难以处理复杂的集合体，难以处理LOD</li><li>烘焙速度慢，严重制约开发效率</li><li>无法处理动态物体，无法提供统一的光照</li><li>无法处理人物</li><li>Worse directional quality</li></ul><h3 id="Adaptive-Probe-Volumes">Adaptive Probe Volumes</h3><p>将空间划分为相同大小的cell，将cell作为分块烘焙、分块加载的最小单位</p><p>cell被细分为brick，在几何体密集的地方，brick越细分</p><img src="/images/adaptive.png" class="lazyload" data-srcset="/images/adaptive.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="adaptive" style="zoom:50%;" /><img src="/images/cell.png" class="lazyload" data-srcset="/images/cell.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cell" style="zoom:50%;" /><img src="/images/稀疏网格.png" class="lazyload" data-srcset="/images/稀疏网格.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="稀疏网格" style="zoom:67%;" /><h4 id="细分">细分</h4><blockquote><p>可以参考Lumen中Build Voxel Faces，本质就是推箱子</p></blockquote><p>细分的原理是使用Raycast判断一个区域有没有物体（命中点），我们使用SDF加速射线检测</p><img src="/images/SDF推箱子.png" class="lazyload" data-srcset="/images/SDF推箱子.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SDF推箱子" style="zoom:50%;" /><ol><li>我们将一个cell划分为4x4的brick，这样就有16条起始边界，这些边界构成了一个正方形</li><li>每一条边界向内发射一条长度为一的射线（使用SDF加速），若没有命中，则向内移动一格</li><li>直到所有边界都命中后，我们得到右图所示的brick</li></ol><h4 id="数据结构">数据结构</h4><p>感觉很类似与VolumeGI，由索引buffer和3DTexture组成，通过紧凑哈希来降低存储</p><ul><li>An indirection buffer存储了cell信息，cell索引→SH指针</li><li>Spherical Harmonics Pool中存储SH信息，SH指针→SH系数</li></ul><img src="/images/IndirectionBuffer.png" class="lazyload" data-srcset="/images/IndirectionBuffer.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IndirectionBuffer" style="zoom:50%;" /><h4 id="采样">采样</h4><p>采样流程：World Position → Cell Indirection → Per-Cell Brick Indirection→ Brick UVW →Trilinear Sample SH Data</p><ol><li>基于着色点posWS生成cellPos</li><li>加载cell信息</li><li>找到该着色点位于cell中哪一个brick（brick的最低层级可能是由相机距着色点距离决定的）</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> localBrickIndex = <span class="built_in">floor</span>(residualPosWS / (_MinBrickSize * <span class="built_in">pow</span>(<span class="number">3</span>, minFoundBrickLevel)));<span class="comment">//若minFoundBrickLevel=1，那么cell被细分为3x3个brick</span></span><br><span class="line">localBrickIndex -= validArea.min;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>加载brick信息</p></li><li><p>通过brick信息+offset采样3DTexture</p></li></ol><h3 id="接缝">接缝</h3><p>我们根据场景几何体密度构建空间八叉树，对于稀疏空间使用精度更低的高Subdiv Level存储Probe信息，在Level交界处有时会有明显的接缝问题</p><p>解决方法：采样时加入抖动</p><h3 id="黑斑">黑斑</h3><p>当我们做Probe摆放时，由于按网格和brick摆放，经常会出现Probe放在墙内的情况，这会导致墙面、地板发黑</p><p>Unity的做法是一种辐照度驱动的摆放，通过判断Probe位置处四周backface比例，来判断这个Probe的有效性</p><img src="/images/Probe评分.png" class="lazyload" data-srcset="/images/Probe评分.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Probe评分" style="zoom:50%;" /><p>对于有效性低/无效的Probe，Unity给出的解决方案就是，<strong>让墙内的Probe变亮</strong></p><h4 id="Post-Bake">Post-Bake</h4><ol><li>烘焙后遍历Probe，找到在墙内的无效Probe</li><li>搜索其邻居Probe，使用其中<strong>有效</strong>Probe进行加权插值，权重是距离的平方反比</li><li>于是墙内的Probe就成功变亮了</li></ol><img src="/images/Dilation2.png" class="lazyload" data-srcset="/images/Dilation2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Dilation2" style="zoom:67%;" /><h4 id="Pre-Bake">Pre-Bake</h4><blockquote><p>参考《The lighting technology of Detroit Become Human》</p></blockquote><p>使用Post-Bake后，确实黑斑少了，但是我们发现墙体出现了漏光，为此我们加入了Virtual Offset（bake阶段的offset），在烘焙时，将Probe移至墙外，最后再将墙外烘焙的信息写入墙内Probe中，于是既没有破坏网格结构，也实现了墙内Probe变亮</p><img src="/images/probeoffset.png" class="lazyload" data-srcset="/images/probeoffset.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="probeoffset" style="zoom:50%;" /><h3 id="漏光">漏光</h3><blockquote><p>我感觉防漏光的本质就是让墙体“变厚”，无论是摆放层面上的遮光板，烘焙时期的Virtual Offset，还是是采样层面的偏移</p></blockquote><p>传统的Probe采样，薄墙体由于使用了墙壁另一面的Probe信息发生漏光。为了避免漏光，采样时通常对采样位置进行偏移（Biases）</p><ul><li>Normal Bias，采样点沿着法线方向偏移<ul><li>这样做实际上让物体沿着法线方向变大了</li><li>偏移的过多/过少，都会影响效果</li><li>难以调优</li></ul></li><li>View Bias，采样点朝着相机方向偏移<ul><li>依赖于相机</li><li>难以调优</li></ul></li></ul><h4 id="Validity-Based-Weighting">Validity Based Weighting</h4><p>而Unity使用了Validity Based Weighting技术来减弱漏光，本质还是对采样点进行偏移</p><p>原理上是通过标记遮罩得出偏移方向，使得偏移方向基于辐照度，而非模型法线、视线，</p><ul><li>每一个Probe存储者8bit的遮罩，用于记录其八个方向（2x2x2）的邻居是否有效</li><li>若某个邻居无效，则推动采样点远离那个邻居（计算偏移的方向和大小）</li></ul><p>但我们现在其实只得到了偏移的方向，不知道偏移的距离</p><h4 id="遮光板">遮光板</h4><p>美术可以手动摆放一个遮光板，使得某些位置上的Probe失效</p><img src="/images/遮光板.png" class="lazyload" data-srcset="/images/遮光板.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="遮光板" style="zoom:50%;" /><p>这确实让房顶下面不再漏光，但是这让房顶上面的物体过黑了</p><p>Unity的做法是对遮光板内Probe的邻居进行判断</p><ul><li>若邻居Probe都不在室内（Occluding objects），那么不会使用遮光板，使用原本的数据</li><li>若邻居有在室内的，室内物体用到该Probe时才会变黑</li></ul><h3 id="场景管理">场景管理</h3><p>将球偕信息编码在3DTexture中比较好做Streaming</p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> GI </tag>
            
            <tag> SIGGRAPH 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metal：TBDR</title>
      <link href="/graphics/TiledDeferred/"/>
      <url>/graphics/TiledDeferred/</url>
      
        <content type="html"><![CDATA[<h1>Tile Base Deferred Rendering</h1><p>基于Apple M1和Metal图形库</p><h3 id="移动端GPU渲染架构">移动端GPU渲染架构</h3><p><img src="/images/%E7%A7%BB%E5%8A%A8%E7%AB%AFGPU.png" class="lazyload" data-srcset="/images/%E7%A7%BB%E5%8A%A8%E7%AB%AFGPU.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="移动端GPU"></p><ul><li>IMR（Immediate Mode Rending），即时模式渲染，按drawcall顺序绘制</li><li>TBR（Tile Base Rendering）<ul><li>将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上</li><li>FS读信息，渲染每一个tile</li><li>当FS将所有的tile渲染完毕后，将完成的frame信息写入System Memory中</li></ul></li></ul><p>TBR相较于IMR能省带宽，而移动端的性能瓶颈在于带宽</p><p>值的注意的是，TBR产生带宽优势的核心是片上存储，而非Tile</p><blockquote><p>我个人感觉为什么要使用Tile，可能是因为移动端GPU规模太小，难以放下整张RT。毕竟理论上使用一张大RT的采样成本更低，比如将一组TextureArray转化为VSM，能很明显提高滤波速度</p><p>我在实际测试中发现当你隐式使用TBR时也会自动切分Tile，手动指定Tile尺寸反而增大了带宽和GPU时间（我也不清楚为什么，希望有人能给我解释一些）</p></blockquote><h3 id="On-Chip-Memory">On-Chip Memory</h3><p>片上存储（on-chip memory），是集成在GPU上的存储空间</p><p>GPU中有多种存储数据的结构，访问速度从快到慢排依次是</p><ol><li>Register Memory（RMEM）<ul><li>访问极快，不需要消耗时钟周期（除非发生了冲突或者先写后读）</li><li>只对负责对其进行读写的线程可见</li></ul></li><li>Shared Memory（SMEM）<ul><li>对处于同一个block所有的线程都是可见的，所以常用与数据交换</li></ul></li><li>Constant Memory（CMEM）<ul><li>用于存储常量数据</li></ul></li><li>Texture Memory（TMEM）<ul><li>用于存储常量数据</li></ul></li><li>Local Memory（LMEM）和Global Memory（GMEM）<ul><li>LMEM只是对GMEM的一个抽象，两者存取速度上一样的</li><li>只对负责对其进行读写的线程可见</li><li>一般用来存储automatic变量<ul><li>automatic变量是一种大尺寸的数据结构/数组</li></ul></li><li>有缓存机制（类比cache）</li></ul></li></ol><p>其中<strong>RMEM与SMEM是集成在GPU芯片上的</strong>，其他的则是存储在显存中的（你可以类比寄存器，cache和内存）</p><h4 id="Metal使用On-Chip-Mem">Metal使用On-Chip Mem</h4><p>Metal使用On-Chip Mem最大的变化就是，你不再需要在RenderPass中读取上一个Pass的贴图，传递给下一个Pass，Shader的输入值可以直接替换为上一个Pass的输出结果，并直接使用</p><blockquote><p>上一个Pass的结果你也可以通过<code>imageblock&lt;GBufferOut&gt; img_blk_gBuffer</code>访问</p></blockquote><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-fragment float4 fragment_deferredSun(VertexOut in [[stage_in]],</span></span><br><span class="line"><span class="addition">+fragment float4 fragment_tiled_deferredSun(VertexOut in [[stage_in]],</span></span><br><span class="line">        constant Params &amp;params [[buffer(ParamsBuffer)]],</span><br><span class="line">        constant Light *lights [[buffer(LightBuffer)]],</span><br><span class="line"><span class="deletion">-        texture2d&lt;float&gt; albedoTexture [[texture(BaseColor)]],</span></span><br><span class="line"><span class="deletion">-        texture2d&lt;float&gt; normalTexture [[texture(NormalTexture)]],</span></span><br><span class="line"><span class="deletion">-        texture2d&lt;float&gt; positionTexture [[texture(NormalTexture + 1)]])</span></span><br><span class="line"><span class="addition">+GBufferOut gBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint2 coord = uint2(in.position.xy);</span><br><span class="line"><span class="deletion">-    float4 albedo = albedoTexture.read(coord);</span></span><br><span class="line"><span class="addition">+ float4 albedo = gBuffer.albedo;</span></span><br><span class="line"><span class="deletion">-    float3 normal = normalTexture.read(coord).xyz;</span></span><br><span class="line"><span class="addition">+ float3 normal = gBuffer.normal.xyz;</span></span><br><span class="line"><span class="deletion">-    float3 position = positionTexture.read(coord).xyz;</span></span><br><span class="line"><span class="addition">+ float3 position = gBuffer.position.xyz;</span></span><br><span class="line">    Material material &#123;</span><br><span class="line">        .baseColor = albedo.xyz,</span><br><span class="line">        .specularColor = float3(0),</span><br><span class="line">        .shininess = 500</span><br><span class="line">    &#125;;</span><br><span class="line">    float3 color = phongLighting(normal,</span><br><span class="line">                                 position,</span><br><span class="line">                                 params,</span><br><span class="line">                                 lights,</span><br><span class="line">                                 material);</span><br><span class="line">    color *= albedo.a;</span><br><span class="line">    return float4(color, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Single-RednerPass">Single RednerPass</h3><blockquote><p>类比Vulkan的SubPass</p></blockquote><p>传统的延迟渲染，是一个多Pass渲染。GBufferPass生成MRT，传递给LightingPass着色输出，这个过程中会有大量的贴图IO带宽</p><img src="/images/传统延迟.png" class="lazyload" data-srcset="/images/传统延迟.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="传统延迟" style="zoom:50%;" /><p>TBDR（Tile Base Deferred Rendering）利用了Metal图形库Single RenderPass的特性</p><ul><li>在一个Single Pass中有多个小Pass，小Pass共享一组片上存储</li><li>一个Pass运行后，会在片上生成一些临时贴图，其他Pass可以直接访问这些贴图</li></ul><img src="/images/MetalTBDR.png" class="lazyload" data-srcset="/images/MetalTBDR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="MetalTBDR" style="zoom:50%;" /><blockquote><p>TBDR是Apple芯片的功能，对于安卓GPU</p><p>Adreno：frameBuffer fetch deferred，提前绑定（开辟）好MRT，使用时RT不动，Pass动</p><p>Mali：pixel loacl storage deferred，将GBuffer存在on-clip mem上，于是就减少了IO消耗</p></blockquote><h3 id="drawable">drawable</h3><p>当我们使用MTKView呈现渲染结果时，需要指定currentDrawable</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">unc draw(cullingResult: <span class="type">CullingResult</span>, <span class="keyword">in</span> view: <span class="type">MTKView</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> commandBuffer <span class="operator">=</span> <span class="type">RHI</span>.commandQueue.makeCommandBuffer(),</span><br><span class="line">              <span class="keyword">let</span> descriptor <span class="operator">=</span> view.currentRenderPassDescriptor <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        updateUniforms(cullingResult: cullingResult)</span><br><span class="line">        updateParams(cullingResult: cullingResult, options: options)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阴影投射</span></span><br><span class="line">        shadowRenderPass.draw(commandBuffer: commandBuffer,</span><br><span class="line">                              cullingResult: cullingResult,</span><br><span class="line">                              uniforms: uniforms,</span><br><span class="line">                              params: params,</span><br><span class="line">                              options: options)</span><br><span class="line">        <span class="comment">// TBDR</span></span><br><span class="line">        tiledDeferredRenderPass.skyboxCube <span class="operator">=</span> cullingResult.skybox</span><br><span class="line">        tiledDeferredRenderPass.shadowTexture <span class="operator">=</span> shadowRenderPass.shadowTexture</span><br><span class="line">        tiledDeferredRenderPass.descriptor <span class="operator">=</span> descriptor</span><br><span class="line">        tiledDeferredRenderPass.draw(commandBuffer: commandBuffer,</span><br><span class="line">                                     cullingResult: cullingResult,</span><br><span class="line">                                     uniforms: uniforms,</span><br><span class="line">                                     params: params,</span><br><span class="line">                                     options: options)</span><br><span class="line">        <span class="comment">// Post-Process</span></span><br><span class="line">        postProcessRenderPass.drawableTexture <span class="operator">=</span> view.currentDrawable<span class="operator">?</span>.texture</span><br><span class="line">        postProcessRenderPass.preTexture <span class="operator">=</span> tiledDeferredRenderPass.finalTexture</span><br><span class="line">        postProcessRenderPass.draw(commandBuffer: commandBuffer,</span><br><span class="line">                                   cullingResult: cullingResult,</span><br><span class="line">                                   uniforms: uniforms,</span><br><span class="line">                                   params: params,</span><br><span class="line">                                   options: options)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> drawable <span class="operator">=</span> view.currentDrawable <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        commandBuffer.present(drawable)</span><br><span class="line">        commandBuffer.commit()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们在TBDR时，将GBuffer和Depth设为<code>.messoryless</code>，并不保存，这些RT将放置在Color1～4中</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">albedoTexture <span class="operator">=</span> <span class="keyword">Self</span>.makeTexture(</span><br><span class="line">            size: size,</span><br><span class="line">            pixelFormat: .bgra8Unorm,</span><br><span class="line">            label: <span class="string">&quot;Albedo Texture&quot;</span>,</span><br><span class="line">            storageMode: .memoryless)</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">for</span> (index, texture) <span class="keyword">in</span> textures.enumerated() &#123;</span><br><span class="line">            <span class="keyword">let</span> attachment <span class="operator">=</span></span><br><span class="line">            descriptor.colorAttachments[<span class="type">RenderTarget0</span>.index <span class="operator">+</span> index]</span><br><span class="line">            attachment<span class="operator">?</span>.texture <span class="operator">=</span> texture</span><br><span class="line">            attachment<span class="operator">?</span>.loadAction <span class="operator">=</span> .clear</span><br><span class="line">            attachment<span class="operator">?</span>.storeAction <span class="operator">=</span> .dontCare</span><br><span class="line">            attachment<span class="operator">?</span>.clearColor <span class="operator">=</span></span><br><span class="line">            <span class="type">MTLClearColor</span>(red: <span class="number">0.73</span>, green: <span class="number">0.92</span>, blue: <span class="number">1</span>, alpha: <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>GBuffer Pass不输出Color0，Light Pass输出Color0，保存后传递给Post-Process Pass</p><p>其实你也可以直接将Light Pass的Color0设置为<code>view.currentDrawable?.texture</code>，这样Light Pass的结果会直接呈现在View上</p><blockquote><p>之前在这一步卡了很久，如果你不显式保存Color0，那么最后一个Pass的Color0就会成为drawable</p><p>但如果你将Color0保存，你会发现屏幕变品红色，没有报错，截帧会崩溃，其实就是你保存Color0后没有显式指定view.currentDrawable?.texture = Color0，View没有东西可以显示</p></blockquote><img src="/images/IMRtoTBDR.png" class="lazyload" data-srcset="/images/IMRtoTBDR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMRtoTBDR" style="zoom:50%;" /><h3 id="参考">参考</h3><p><a href="https://developer.apple.com/videos/play/wwdc2020/10632/">WWDC 2020</a></p><p><a href="https://github.com/kodecocodes/met-materials">Metal by Tutorials</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Render </tag>
            
            <tag> Metal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPH：入门</title>
      <link href="/graphics/SPH/"/>
      <url>/graphics/SPH/</url>
      
        <content type="html"><![CDATA[<h1>SPH入门</h1><p>SPH（Smoothed Particle Hydrodynamics）光滑粒子流体力学</p><blockquote><p>A mesh-free method for the discretization of functions and partial differential operators</p></blockquote><p>SPH是一种基于拉格朗日视角的算法，是一种空间离散化的算法，常用于连续介质的数值模拟</p><ul><li><p>材质导数的坐标</p><ul><li><p>拉格朗日坐标：视角随着介质移动而移动（粒子模拟）</p></li><li><p>欧拉坐标：视角是固定的，检测穿过视角的介质流速（网格模拟）</p></li></ul></li></ul><p><img src="/images/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5.png" class="lazyload" data-srcset="/images/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="拉格朗日"></p><p>SPH进行简单流体模拟，简单来说就是</p><ol><li>介质离散化，使用多个质点来表示流体（离散化）</li><li>对于每一个粒子，找到它附近的粒子（临域搜索）</li><li>计算密度（质量密度估计）</li><li>计算压强（控制方程，如理想气体状态方程+动量守恒），压强差、粘滞力等</li><li>更新运动状态</li><li>水体渲染（Marching Cube）</li></ol><h2 id="离散化">离散化</h2><h3 id="狄拉克函数">狄拉克函数</h3><p>狄拉克$\delta$函数，这是一个广义函数，其在整个定义域中积分值都集中在原点<br>$$<br>\delta (\mathbf{r})= \begin{cases}<br>\infty &amp; |\mathbf{r}|=0 \\<br>0 &amp; otherwise<br>\end{cases}<br>$$<br>该函数仅在积分中有意义，可以通过高斯钟形函数（正态分布）逼近</p><p><img src="/images/%E9%AB%98%E6%96%AF%E9%92%9F%E5%BD%A2.png" class="lazyload" data-srcset="/images/%E9%AB%98%E6%96%AF%E9%92%9F%E5%BD%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="高斯钟形"></p><p>在物理学中我们常用质点表示物体，但是因此使得密度函数失去了意义（因为质点没有空间），此时密度函数就塌缩成了狄拉克函数</p><p>空间中任何标量场函数，都可以用狄拉克函数表示：<br>$$<br>A(\mathbf{x})=(A*\delta)(\mathbf{x})=\int A(\mathbf{x}‘)\delta (\mathbf{x}-\mathbf{x}’)dv’<br>$$</p><ul><li>$dv’$是$\mathbf{x}'$对应的体积积分变量</li><li>$A(\mathbf{x}): \mathbb{R}^d \rightarrow \mathbb{R}$，d是维度，意思就是这是一个空间函数</li></ul><blockquote><p>$\mathbb{R}$是实数集</p><p>$\mathbb{R}^+$是正实数集（不含0）</p><p>$\mathbb{R}^d$是d维实数集</p></blockquote><h3 id="光滑核函数">光滑核函数</h3><p>我们有了狄拉克函数，想要把连续函数来离散表示</p><p>核函数（kernel functions，smoothing kernels）是一种随着距离而衰减的函数，与高斯函数要在整个作用域积分不同，核函数是有最大影响半径的，最大影响半径用$h$表示</p><img src="/images/核函数.png" class="lazyload" data-srcset="/images/核函数.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="核函数" style="zoom:50%;" /><p>核函数满足</p><ol><li>归一化</li><li>狄拉克条件</li><li>非负性</li><li>对称性</li><li>有界性</li></ol><p><img src="/images/%E6%A0%B8%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8.png" class="lazyload" data-srcset="/images/%E6%A0%B8%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="核函数性质"></p><p>一个经典的核函数是三次样条器（cubic spline kernel）</p><p><img src="/images/%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%99%A8.png" class="lazyload" data-srcset="/images/%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%99%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="三次样条器"></p><ul><li>其中$q=\frac{1}{h}||\mathbf{r}||$</li></ul><h3 id="离散化-2">离散化</h3><blockquote><p>有个数学大佬告诉我，这里就是“在某个i点处求所有其他j点按核函数加权的平均值，只不过离散化的时候划成了区块赋予了密度和体积”</p><p>换句话说，这其实就是一次卷积（数学家真是不讲人话）</p></blockquote><p>参考上面那张核函数的图，离散化就是对于$i$点，我们求该点附近场密度函数值和核函数（一堆$j$点）的加权平均值</p><img src="/images/离散化.png" class="lazyload" data-srcset="/images/离散化.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="离散化" style="zoom:50%;" /><p>在数学上，$\langle A(x)\rangle $表示平均值</p><h3 id="质量密度估计">质量密度估计</h3><p>粒子不需要携带质量密度函数，对于空间中任意位置的点，都可以通过离散化求出该点密度</p><p>对于$\mathbf{x}_i$位置处的点，其密度为：</p><p>$$<br>\rho_{i} =\sum_{j} m_{j}W_{ij}<br>$$<br>不过在流体边界，这样求密度会导致数据偏小，需要做边界处理</p><p>下图绿色点临域完整，得到正确的密度，而红色点只能得到一个较小的密度</p><img src="/images/流体边界.png" class="lazyload" data-srcset="/images/流体边界.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="流体边界" style="zoom:50%;" /><h3 id="微分算子的离散化">微分算子的离散化</h3><p>上面我们已经实现场函数的离散化，实现了质量密度估计。但除此之外，还有一些空间微分算子（导数）值得离散化<br>$$<br>\nabla A_{i}\approx \sum_{j} A_{j}\frac{m_{j}}{\rho_{j} } \nabla W_{ij}<br>$$</p><blockquote><p>关于拉普拉斯算符，可以去看<a href="/2023/01/31/math/Nabla%E7%AE%97%E5%AD%90/">Nabla算子</a>，简单来说这东西是将标量场转化为向量场，一阶算符就是梯度，二阶是散度，用于得到数据变化最快的方向。文中也实现了拉普拉斯算符的离散化</p></blockquote><p>文章介绍了两种最常用的梯度的近似方法，并给了适用范围</p><ul><li>差分公式（Difference Formula）：用于近似速度的散度</li><li>对称公式（Symmetric Formula）：用于近似力、脉冲的梯度</li></ul><h4 id="差分公式">差分公式</h4><p>在高中学微积分时，我们用两个相邻的点组成的线来逼近切线，以此引入了极限、导数的概念。在实际应用中，这两个点不可能无穷近，于是存在误差</p><p>使用差分表示导数（导数就是），我们只能把$h$取到一个很小的值，而不是无穷小，因此这个导数是有误差的<br>$$<br>f’(x)=\lim_{h \rightarrow0}\frac{f(x+h/2)-f(x-h/2)}{h}<br>$$<br>我们需要衡量这个误差的大小，于是我们将$f(x\pm h/2)$泰勒展开后带入上式，得到<br>$$<br>f’(x)=\lim_{h \rightarrow0}\frac{f’(x)h+O(h^3)}{h}=f’(x)+O(h^2)<br>$$<br>误差大小为$O(h^2)$</p><blockquote><p>经计算，二阶导数的误差也是$O(h^2)$</p></blockquote><h4 id="对称公式">对称公式</h4><h2 id="临域搜索">临域搜索</h2><p>这里介绍最简单的，不做空间优化的临域搜索，进阶内容可以看<a href="2023/02/06/graphics/%E9%82%BB%E5%9F%9F%E6%90%9C%E7%B4%A2/">临域搜索</a></p><p>由于核函数存在作用范围，我们在积分时，只需要遍历核半径内其他粒子的信息。这样相较于nxn的全遍历，能大幅减少计算，为此我们需要构建临域表</p><h3 id="网格化">网格化</h3><p>临域搜索是一种基于网格（grid）构建粒子拓扑关系的算法，找到该粒子所在位置和其相邻位置有哪些粒子</p><p>我们将整个（粒子作用的）场景均匀切分为一个个三维网格，每个网格为立方体，边长等于核半径$\hslash $，</p><p>每个网格拥有一个坐标$(i,j,k)$，用于表示网格在场景中的位置</p><p>对于任意一个粒子，其核函数的作用范围是一个球，临域搜索就是计算球内有哪些粒子</p><img src="/images/grid.png" class="lazyload" data-srcset="/images/grid.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="grid" style="zoom: 33%;" /><ol><li>空间网格化</li><li>遍历粒子，记录每个网格中有多少个粒子，有哪些粒子</li><li>遍历粒子，建立临域表<ol><li>求该粒子的核函数球位于哪些网格中</li><li>遍历那些网格，取出网格中所有粒子，计算距离</li><li>将距离小于核半径的粒子id存储在临域表中</li></ol></li></ol><h3 id="数据结构">数据结构</h3><table><thead><tr><th>名称</th><th>Key</th><th>Value</th></tr></thead><tbody><tr><td>_neighbourList</td><td>id.x * maximumParticlesPerCell * 8 + _neighbourTracker[id.x]++</td><td>临居的id</td></tr><tr><td>_neighbourTracker</td><td>id.x</td><td>当前粒子有多少个临居</td></tr><tr><td>_hashGrid</td><td>hashCellIdx * maximumParticlesPerCell + previousCount</td><td>id.x</td></tr><tr><td>_hashGridTracker</td><td>hashCellIdx</td><td>该网格中的粒子数</td></tr></tbody></table><ul><li>id.x：当前粒子id</li><li>hashCellIdx：网格坐标的Hash值</li><li>maximumParticlesPerCell：每个网格的的粒子最大数量（提前留好空）</li><li>previousCount：空里有几个粒子</li></ul><h3 id="球作用于哪些网格">球作用于哪些网格</h3><p>我们发现核函数球最少位于8个网格中（一个2x2x2的立方体），最多位于27个网格中（一个3x3x3的立方体），我们只需要找出核函数球位于哪些网格中，就能减少很多便利</p><p>在这里，我们只使用8个网格作为临域（舍弃那些不重要的网格），很显然，球心向哪个方向靠，我们就使用哪8个网格</p><ol><li>找到球心所在网格坐标，构建临域坐标表，临域坐标初始均设为球心位置</li><li>判断中心网格的中心坐标与球心的坐标位置关系</li><li>存储临域Hash Key</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNearbyKeys</span><span class="params">(int3 originIndex, float3 position, out <span class="type">int</span> nearbyKeys[<span class="number">8</span>])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int3 nearbyBucketIndices[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[i] = originIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((originIndex.x + <span class="number">0.5f</span>) * CellSize &lt;= position.x) </span><br><span class="line">    &#123;        </span><br><span class="line">        nearbyBucketIndices[<span class="number">4</span>].x += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">5</span>].x += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">6</span>].x += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].x += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[<span class="number">4</span>].x -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">5</span>].x -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">6</span>].x -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].x -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((originIndex.y + <span class="number">0.5f</span>) * CellSize &lt;= position.y) </span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[<span class="number">2</span>].y += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">3</span>].y += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">6</span>].y += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].y += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[<span class="number">2</span>].y -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">3</span>].y -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">6</span>].y -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].y -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((originIndex.z + <span class="number">0.5f</span>) * CellSize &lt;= position.z) </span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[<span class="number">1</span>].z += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">3</span>].z += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">5</span>].z += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].z += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[<span class="number">1</span>].z -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">3</span>].z -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">5</span>].z -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].z -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) </span><br><span class="line">    &#123;</span><br><span class="line">        int3 nbcellIndex = nearbyBucketIndices[j];</span><br><span class="line">        <span class="keyword">if</span> (nbcellIndex.x &lt; <span class="number">0</span> || nbcellIndex.x &gt;= Dimensions || nbcellIndex.y &lt; <span class="number">0</span> || nbcellIndex.y &gt;= Dimensions || nbcellIndex.z &lt; <span class="number">0</span> || nbcellIndex.z &gt;= Dimensions) </span><br><span class="line">        &#123;</span><br><span class="line">            nearbyKeys[j] = <span class="number">-1</span>;<span class="comment">//出界了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            nearbyKeys[j] = <span class="built_in">Hash</span>(nearbyBucketIndices[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将三维坐标转化为一维hash key</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(int3 cell)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cell.x + Dimensions * (cell.y + Dimensions * cell.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建临域表">构建临域表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">numthreads</span>(<span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildNeighbourList</span><span class="params">(uint3 id : SV_DispatchThreadID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _neighbourTracker[id.x] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> int3 cell = <span class="built_in">GetCell</span>(_particles[id.x].position);</span><br><span class="line">    <span class="type">int</span> cells[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">GetNearbyKeys</span>(cell, _particles[id.x].position, cells);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cells[j] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// Grid does not contain cell.</span></span><br><span class="line">        <span class="type">const</span> uint numberOfParticlesInCell = <span class="built_in">min</span>(_hashGridTracker[cells[j]], maximumParticlesPerCell); ;</span><br><span class="line">        <span class="keyword">for</span> (uint index = <span class="number">0</span>; index &lt; numberOfParticlesInCell; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> uint potentialNeighbour = _hashGrid[cells[j] * maximumParticlesPerCell + index];</span><br><span class="line">            <span class="keyword">if</span> (potentialNeighbour == id.x) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">const</span> float3 v = _particles[potentialNeighbour].position - _particles[id.x].position;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dot</span>(v, v) &lt; radius2) <span class="comment">// Use squared length (= dot) instead of length for performance.</span></span><br><span class="line">            &#123;</span><br><span class="line">                _neighbourList[id.x * maximumParticlesPerCell * <span class="number">8</span> + _neighbourTracker[id.x]++] = potentialNeighbour;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制方程">控制方程</h2><p>尽管物体在微观层面（比如原子）是离散的，但在宏观层面上，流体、固体表现为连续介质</p><blockquote><p>continuum, a region of continuously distributed mass</p></blockquote><p>根据定义，一个连续介质可以被切分为多个小的连续介质（类比实数的稠密性，任意两个实数间总存在第三个实数），而不影响其性质</p><p>材料粒子（material particle）：a portion of matter contained in an infinitesimal volume</p><h3 id="连续性方程">连续性方程</h3><p>连续性方程描述了物体的密度与时间的关系<br>$$<br>\frac{D\rho}{Dt}=-\rho(\nabla \cdot \mathbf{v})<br>$$</p><h3 id="随体导数">随体导数</h3><p>随体导数（material derivative）：$\frac{D(\cdot)}{Dt}$</p><p>随体导数描述了材质点的场量随着时间的变化率</p><p>在制作不可压缩的介质中，必须始终保持<br>$$<br>\frac{D\rho}{Dt}=0<br>$$<br>随体导数与坐标系有关，常见的坐标系有：拉格朗日坐标系和欧拉坐标系</p><h3 id="线性动量守恒定律">线性动量守恒定律</h3><p>高中物理就学过的碰撞时动量守恒，力作用在物体上，会改变物体的动量</p><p>将运动公式（equation of motion）用积分的形式写出来就是<br>$$<br>\rho \frac{D^2\mathbf{x}}{Dt^2}=\nabla \cdot \mathbf{T}+\mathbf{f}_{ext}<br>$$</p><ul><li>$\mathbf{T}$：应力张量（stress tensor）</li><li>$\mathbf{f}_{ext}$：体积力（body forces），穿越空间作用在所有流体元上的非接触力，例如重力、惯性力、电磁力</li></ul><h4 id="理解应力张量">理解应力张量</h4><p>对于材质内部一个微小平面，这个平面会受材质中其他点的作用力，这个力可能不与平面垂直。其中垂直于平面的力叫正向应力，平行于平面的力叫剪应力</p><p>矢量是一种一维张量，由大小和一个方向组成。然而对于应力，我们没法使用矢量进行表示，于是改用二维张量来表示，一个方向是应力的指向，一个方向是应力所在的平面方向</p><p>对于材质内一个点，它可能处于无数个平面中，我们需要用一种平面无关的方式来表示其受力状态。在三维空间中，我们选择了三组正交基底$(\mathbf{e}_1,\mathbf{e}_2,\mathbf{e}_3)$构建坐标系，应用中给定一个方向$\mathbf{e}$，就能求出该方向的应力矢量</p><img src="/images/应力张量.png" class="lazyload" data-srcset="/images/应力张量.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="应力张量" style="zoom:50%;" /><p>其中$\mathbf{T}$为应力矢量，$\sigma $为柯西应力张量（一个3x3的矩阵）</p><p>$\sigma_{xy}$的意思是，处于yz平面，指向y方向</p><img src="/images/柯西应力张量.png" class="lazyload" data-srcset="/images/柯西应力张量.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="柯西应力张量" style="zoom:50%;" /><img src="/images/三维应力.png" class="lazyload" data-srcset="/images/三维应力.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="三维应力" style="zoom:50%;" /><blockquote><p>柯西应力张量只适用于材料微小变形的情况</p></blockquote><h4 id="Navier-Stokes方程">Navier-Stokes方程</h4><p>一个经典的不可压缩流体的张力表示方法<br>$$<br>\mathbf{T}=-p+\mu (\nabla \mathbf{v}+\nabla  \mathbf{v}^T)<br>$$</p><ul><li>$p$：压强</li><li>$\mu$：粘度（viscosity ）</li></ul><p>我们将该液体的应力张量公式带入牛顿运动公式，得到速度的公式<br>$$<br>\rho \frac{D\mathbf{v}}{Dt}=-\nabla p + \mu \nabla^2 \mathbf{v}+\mathbf{f}_{ext}<br>$$<br>压强可以由密度表示，根据理想气体压强公式，我们得知压强与密度呈线性关系，于是我们取一个静止状态下的密度$\rho_0$，通过与当前状态密度做差值，就能得出压强</p><blockquote><p>理想气体压强公式，初中就学了，$pV=nRT$</p></blockquote><p>$$<br>p=B((\frac{\rho}{\rho_0})^{\gamma}-1)<br>$$</p><ul><li>$B$：体积模量（bulk modulus）</li></ul><h4 id="弹力">弹力</h4><p>拥有弹力的固体，应力张量来自于固体的形变，之后会展开讲</p><h2 id="积分求解">积分求解</h2><h3 id="混合初始边界值问题">混合初始边界值问题</h3><p>我们上面给出了控制方程，但是想要求解运动问题，必须给定初始位置和速度（场）</p><p>一般而言，混合初始边界值问题（Mixed Initial-Boundary Value Problem）没有解析解，只有数值解</p><blockquote><p>得嘞，这一节就这一句话，这一句话一个字都看不懂</p></blockquote><h4 id="混合边界">混合边界</h4><blockquote><p>简单来说，就是要想求解运动问题，必须既要给初始位置，也要给初始速度（场）</p></blockquote><p>边界条件也叫定解条件，是微分方程里的概念，给定初始值才能求控制方程、偏微分方程的解（比如带入解中的未知数）</p><p>放在物理学中叫临界条件，就是物体处于某两种状态间的交界处，比如冰水混合物</p><p>边界条件对于解决物理问题（比如求极值）十分重要</p><p>有三类边界条件</p><ul><li>第一类边界条件（迪利克雷边界条件，Dirichlet boundary condition）<ul><li>直接告诉你边界值，比如热传递中告诉你边界处温度</li></ul></li><li>第二类边界（若依曼边界条件，Neumann boundary condition）<ul><li>告诉你边界处的梯度，比如热传递中告诉你热流密度（温度的梯度）</li></ul></li><li>混合边界条件<ul><li>第一二类边界的混合，比如热对流微分公式，公式中既有温度，也有梯度，只有同时给出两者，才能求解</li></ul></li></ul><p>$$<br>q=h(T_0-T_a)<br>$$</p><h4 id="解析解与数值解">解析解与数值解</h4><ul><li>解析解（analytic solution），形如一个函数，给定变量就能得出任意位置的解</li><li>数值解（numerical solution），这是一个数，是采用有限元、数值逼近、插值等方法得到的解</li></ul><blockquote><p>据说在数学家和物理学家眼里，解析解才是真正的解，更高贵，美丽</p><p>让我突然想到三体力魏成想要求出三体问题的解析解，结果最后发现这个问题只有数值解</p></blockquote><h3 id="算子分裂">算子分裂</h3><p>就是使用分治的算法，将一个复杂的偏微分方程（PDE），分解为几个连续的子问题</p><img src="/images/算子分解.png" class="lazyload" data-srcset="/images/算子分解.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="算子分解"  /><p>在实践中证明，像这样每步操作依赖于上一步，一步一步操作，能提高系统的稳定性</p><h3 id="时间积分">时间积分</h3><p>在实时渲染中，和精度相比，性能、稳定性和鲁棒性更重要</p><p>在GAMES201开篇讲弹簧质点模型时，关于质点的运动方程，给出了两种积分器：显式积分器和隐式积分器</p><h4 id="显式积分器">显式积分器</h4><p>从过去的状态得到现在的状态，表示简单容易实现</p><p>$$<br>\mathbf{v}_{t+1}=\mathbf{v}_t+\Delta t \frac{\mathbf{f}_t}{m}<br>$$</p><!----><p>$$<br>\mathbf{x}_{t+1}=\mathbf{x}<em>t+\Delta t \mathbf{v}</em>{t+1}<br>$$</p><p>但是显式积分器有一个问题，就是容易爆炸，于是$\Delta t$不能太大，应满足<br>$$<br>\Delta t \le c\sqrt{\frac{m}{k}} \ \ (c \sim 1)<br>$$</p><h5 id="CFL条件">CFL条件</h5><p>这是CFL条件（Courant–Friedrichs–Lewy condition），是某些偏微分方程的收敛条件，它决定了显式积分器中粒子在单位时间内走过的距离，必须小于粒子大小（或者说质点间的间距）<br>$$<br>\Delta t \le \lambda \frac{\tilde{h}}{|\mathbf{v}^{\max}|}<br>$$</p><ul><li>$\tilde{h}$：粒子大小（质点间的间距）</li><li>$\lambda$：一个常量</li><li>$\mathbf{v}^{\max}$：粒子运动的最快速度</li></ul><h4 id="隐式积分器">隐式积分器</h4><p>现在的状态依赖于现在的状态（求$t+1$时刻的信息，结果需要$t+1$时刻的信息），难以实现，但鲁棒性强</p><!----><p>$$<br>\mathbf{v}_{t+1}=\mathbf{v}<em>t+\Delta t \mathbf{M}^{-1}\mathbf{f}(\mathbf{x}</em>{t+1})<br>$$</p><!----><p>$$<br>\mathbf{x}_{t+1}=\mathbf{x}<em>t+\Delta t \mathbf{v}</em>{t+1}<br>$$</p><ul><li>$\mathbf{M}$：质量矩阵</li></ul><h2 id="Marching-Cube">Marching Cube</h2><h2 id="符号表">符号表</h2><p><img src="/images/%E7%AC%A6%E5%8F%B7.png" class="lazyload" data-srcset="/images/%E7%AC%A6%E5%8F%B7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="符号"></p><h2 id="参考">参考</h2><p><a href="https://interactivecomputergraphics.github.io/physics-simulation/">Physics Simulation in Visual Computing</a></p><p><a href="https://www.bilibili.com/video/BV1ZK411H7Hc">GAMES201</a></p><p><a href="https://zhuanlan.zhihu.com/p/426566636">MrKill的知乎</a></p><p><a href="https://github.com/alen-cell/PhysicsEngine">alen-cell</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPH </tag>
            
            <tag> Physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是谁</title>
      <link href="/%E6%88%91%E6%98%AF%E8%B0%81/"/>
      <url>/%E6%88%91%E6%98%AF%E8%B0%81/</url>
      
        <content type="html"><![CDATA[<h1>一个渴望得到认同的怪兽</h1><h3 id="过去">过去</h3><p>感觉我做啥都三分钟热度，换了好多次道路</p><p>我从小就喜欢游戏，在小学的时候就在班级“发售”了一款桌游，赚了5块钱，最后被班主任没收了😂</p><p>初高中时特别喜欢科幻和物理，当时想着去做<strong>可控核聚变</strong>，认为这才是有意义有价值的工作，那时候我的梦想就是做一名学者</p><p>在高三时期学校给我们开大会，在讲华为被制裁、卡脖子，然后我就被忽悠着去报考计算机</p><p>刚上大学时想做嵌入式和芯片，但在一次大作业中用嵌入式+触摸屏做了一款游戏，那是一个打地鼠和五子棋结合的游戏，没有游戏引擎，没有图形API，画面绘制是靠着在屏幕上绘制点阵，属实是有些拙劣</p><p>这次经历让我又想做游戏了，于是我开始做<strong>游戏策划</strong></p><p>最初的策划生涯还蛮顺利的，每天都在玩游戏做反拆，加了学校的游戏开发社团，做独立游戏，参加Gamejam。然后在腾讯策划公开课拿了金奖，又在字节朝夕光年Gamejam拿到了策划offer。但很快字节上海人事调整（裁员），我被毁了offer</p><p>只不过我当时才大二上学期，感觉挺无所谓的。不过在字节Gamejam中看到一个队伍做的平台跳跃，当跳跃时屏幕会有振动和RGB通道分离，我十分好奇这是什么原理，经社团学长介绍，这是shader</p><p>然后我开始搞图形了，自学shader三四个月，到了大二下学期我又拿到了字节朝夕光年的offer，只不过这次是TA，然后就在这边实习了十个月。只不过当我大三下学期快要秋招的时候，又遇到了人事调整，整个项目被砍了，mentor离职，于是没继续待</p><p>不过这次实习改变了我的技术栈，我现在在做引擎，只不过资质尚浅，能力不足</p><h3 id="现在">现在</h3><p>引擎实在是太复杂了，我的编程能力也不是很强，图形知识大多都停留在应用层面（比如如何用Unity做手游图形效果），算法基础也不是很牢固，看到身边的大佬，感觉好卑微</p><p>但是我又是一个渴望得认同的怪兽，不积跬步无以至千里，于是就有了这个博客，用于记录那些<strong>想让别人看，但又不敢发知乎贻笑大方的内容</strong></p><p>希望我能在引擎道路上坚持下去</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11特性</title>
      <link href="/program/C++11/"/>
      <url>/program/C++11/</url>
      
        <content type="html"><![CDATA[<h1>C++11特性</h1><p>都什么年代了，还在整C++11？八股害人啊</p><h2 id="一：C-11的“新”特性">一：C++11的“新”特性</h2><h3 id="nullptr">nullptr</h3><p>一个新关键字，用于表示指针指向no value，可以被自动转化为各种指针类型，但是不会被转化为整数</p><p><em>比NULL好，因为NULL的本质就是整数0</em></p><h3 id="auto">auto</h3><p>通过auto声明变量、对象，可以自动推到其类型，在处理表达式时有奇效</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> l = [](<span class="type">int</span> x) -&gt; &#123;...&#125;;</span><br></pre></td></tr></table></figure><h3 id="一致性初始化">一致性初始化</h3><p>一致性初始化（Uniform Initiallization），简单来说就是可以用大括号来做初始化</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> v[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c&#123;<span class="number">4.0</span>, <span class="number">3.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>但是这个操作不支持<strong>窄化（narrowing）</strong>，即</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5.3</span>;<span class="comment">//x == 5</span></span><br><span class="line"><span class="type">int</span> y &#123;<span class="number">5.3</span>&#125;;<span class="comment">//Error</span></span><br></pre></td></tr></table></figure><h3 id="新的for循环">新的for循环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item: lists)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="左值右值">左值右值</h3><p>左值：占用一定内存，具有可辨认的地址的对象（表达式结束后仍然存在的持久对象），C++中绝大多数变量都是左值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;<span class="comment">// i 是左值</span></span><br><span class="line"><span class="type">int</span> *p = &amp;i;<span class="comment">// i 的地址是可辨认的</span></span><br><span class="line">i = <span class="number">2</span>; <span class="comment">// i 在内存中的值可以改变</span></span><br><span class="line">A a; <span class="comment">// 用户自定义类实例化的对象也是左值</span></span><br></pre></td></tr></table></figure><p>右值：左值以外的所有对象（表达式结束后就消失的对象）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">2</span>;<span class="comment">// 2 是右值</span></span><br><span class="line"><span class="type">int</span> x = i + <span class="number">2</span>; <span class="comment">// (i + 2) 是右值</span></span><br><span class="line">A a = <span class="built_in">A</span>(); <span class="comment">// A() 是右值，是一个临时对象，在a构造完成后会被销毁</span></span><br><span class="line">A&amp;&amp; a = <span class="built_in">A</span>();<span class="comment">// a是一个右值引用，引用的就是A()所创建的对象，这个对象的生命周期和a一致</span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// sum(1, 2) 是右值</span></span><br></pre></td></tr></table></figure><p>不能对右值赋值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i + <span class="number">2</span> = <span class="number">4</span>; <span class="comment">// 错误，不能对右值赋值</span></span><br></pre></td></tr></table></figure><p>不能对右值取地址</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;(i + <span class="number">2</span>);<span class="comment">// 错误，不能对右值取地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">square1</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;<span class="keyword">return</span> a * a;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span> </span>&#123;<span class="keyword">return</span> a * a;&#125; </span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">square1</span>(i); <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">square1</span>(<span class="number">2</span>); <span class="comment">// 错误，不能对右值取地址</span></span><br><span class="line"><span class="built_in">square2</span>(<span class="number">2</span>);<span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>为什么可以<code>const int &amp;a = 2;</code>呢？可以视为一个例外，const引用 指向了一个 临时左值的引用，其值为2</p><h3 id="转移语意">转移语意</h3><p>转移语意（move semantic），本质是所有权的转移，将即将销毁的对象转移给他人，避免非必要的拷贝和临时对象</p><p>比如一个函数定义为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> T&amp; v)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>当我们调用时</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T t;</span><br><span class="line"><span class="built_in">fun</span>(t);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">fun</span>(t+<span class="number">1</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>我们发现，第一种调用时，直接传了引用，没有拷贝和临时变量，而第二种，实际上是</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T temp = t+<span class="number">1</span>;<span class="comment">//T temp(t+1)或者 T temp.T(t+1)</span></span><br><span class="line"><span class="built_in">fun</span>(temp);</span><br></pre></td></tr></table></figure><p>总之是调用了拷贝构造函数和生成了临时变量，这不是我们想要的，于是引入了左右值和转移语意的概念，然后就诞生了一种新的调用方式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fun</span>(std::<span class="built_in">move</span>(t+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><code>std::move</code>的作用是将其参数<code>t+1</code>变成一个<strong>右值引用（rvalue reference）</strong>，是一个<code>T&amp;&amp;</code>的类型</p><p>一旦一个类型被“标记”为右值，就意味着这是一个临时对象，你可以随意使用它的内容和资源</p><p>然后我们可以优化一下这个函数的定义</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">T</span> (<span class="type">const</span> T&amp; lvalue);<span class="comment">// 通过左值拷贝构造（根传统C++一样）</span></span><br><span class="line">  <span class="built_in">T</span> (T&amp;&amp; rvalue);<span class="comment">// 通过右值move构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; v)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>右值被move以后，就变成有效但不确定的状态</p><h3 id="字符串字面量">字符串字面量</h3><h4 id="Raw-String-Literal">Raw String Literal</h4><p>以R开头的字符串，可以换行，不需要转义，用于正则表示式有奇效</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">R&quot;(\\n)&quot;</span>;<span class="comment">//等于 &quot;\\\\n&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Encoded-String-Literal">Encoded String Literal</h4><p>用于国际化</p><h3 id="noexcept">noexcept</h3><p>让函数无法抛出异常，遇到未定义事件会直接<code>abort</code></p><p>noexcept后面可以跟一个bool条件，为true时就不抛异常</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(T&amp; x, T&amp; y)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(x.swap(y)))</span></span>&#123;</span><br><span class="line">    x.<span class="built_in">swap</span>(y);</span><br><span class="line">    <span class="comment">//这个函数意味着，只要xy交换不抛异常，那么下面这些函数体做任何事都不会抛异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constexpr">constexpr</h3><p>用于让表达式核定与编译期，能助力TMP编程</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> a[<span class="built_in">square</span>(<span class="number">9</span>)];</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前的写法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++11写法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value&#123; n * Factorial&lt;n - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="新的模板">新的模板</h3><h4 id="不定个数的参数">不定个数的参数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T , <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; first, <span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; first &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">f</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板别名">模板别名</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;<span class="comment">//等价于std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll;</span></span><br></pre></td></tr></table></figure><h3 id="Lambda">Lambda</h3><p>允许函数的定义式被用作一个参数、local对象</p><h4 id="定义与调用">定义与调用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;<span class="comment">//这是一个lambda表达式</span></span><br><span class="line"></span><br><span class="line">[]&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;();<span class="comment">//定义并直接调用表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> l = []&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">l</span>();<span class="comment">//调用表达式</span></span><br></pre></td></tr></table></figure><h4 id="含参">含参</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> l2 = [](<span class="type">const</span> std::string&amp; s)&#123;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">l</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="返回值">返回值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部作用域">外部作用域</h4><p>分值传递和引用传递两种，值传递不能进行修改</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> l = [x, &amp;y] &#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    ++y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">l</span>();<span class="comment">//调用，注意xy不是参数，不需要写在括号里</span></span><br></pre></td></tr></table></figure><h4 id="mutable">mutable</h4><p>这个关键词是const的反义词，意思是可变的，于是让值传递也可变</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> l = [x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">l</span>();</span><br></pre></td></tr></table></figure><h3 id="decltype">decltype</h3><p>自动推导表达式的类型，大号typeof</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) b = <span class="number">2</span>; <span class="comment">// b是const int&amp;</span></span><br></pre></td></tr></table></figure><h4 id="推断返回类型">推断返回类型</h4><p>可以将返回类型的声明放在参数列之后</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带领域的枚举">带领域的枚举</h3><h3 id="promise与future">promise与future</h3><p><code>std::promise</code>意思为共享状态，是C++11提供的在两个异步任务间传递数据的方式，常与<code>std::future</code>一起使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生产者端</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Producer\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 设置共享数据为 42</span></span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="comment">// 将 promise 与 future 绑定</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = p.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer, std::ref(p))</span></span>;</span><br><span class="line">    <span class="comment">// 分离执行线程</span></span><br><span class="line">    producer_thread.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="type">int</span> result = f.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>std::thread</code>用于表示一个执行线程，这个线程可以选择在主线程执行<code>join()</code>或者另一个线程中执行<code>detach()</code>。</p><p>若使用<code>join()</code>，则主线程会等待子线程执行完毕后再继续执行，若使用<code>detach()</code>，则主线程会直接执行，而子线程会在后台执行，两者不会相互影响。</p></blockquote><h2 id="二：一般概念">二：一般概念</h2><h3 id="可被调用的对象">可被调用的对象</h3><p>Callable Object，一种对象，可以通过某些方式调用其某些函数，它可以是</p><ul><li>函数</li><li>指向成员函数的指针</li><li>函数对象</li><li>lambda表达式</li></ul><h2 id="三：通用工具">三：通用工具</h2><h3 id="pair">pair</h3><p>本质是一个struct</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.first + p.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">42</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tuple">tuple</h3><p>大号pair，可以有多个值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t) + <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t) + <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能指针">智能指针</h3><p>智能指针智能在，它能知道自己是不是指向某物的最后一个指针</p><ul><li>shared_ptr：共享式拥有<ul><li>多个指针可以指向一个资源，通过引用计数法GC</li><li>为了解决引用计数法的缺点（比如循环引用），提供weak_ptr等辅助类</li></ul></li><li>unique_ptr：独占式拥有<ul><li>同一时间只能有一个unique_ptr指向某个资源，可以进行拥有权的移交</li></ul></li></ul><h3 id="极值">极值</h3><p>Numeric Limit</p><p>用于得到当前平台下，一些数值类型的长度（大小）</p><h3 id="Trait">Trait</h3><p>是一种技术方案，用来为同一类数据提供统一的操作函数，核心就是使用另外的模版类<code>type_traits</code>存储不同数据类型的<code>type</code>，这样就可以兼容各种数据类型</p><h3 id="外覆器">外覆器</h3><h4 id="Reference-Wrapper">Reference Wrapper</h4><p>允许函数模板可以操作引用，不需要写特化版本</p><p>具体有两个函数</p><ul><li>ref：隐式转化为<code>T&amp;</code></li><li>cref：隐式转化为<code>const T &amp;</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">fun</span>(std::<span class="built_in">ref</span>(x));<span class="comment">//此时T为int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">fun</span>(std::<span class="built_in">cref</span>(x));<span class="comment">//此时T为const int&amp;</span></span><br></pre></td></tr></table></figure><h4 id="Function-Type-Wrapper">Function Type Wrapper</h4><p>允许将可调用对象当作最高级对象（first-class object）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; tasks;<span class="comment">//一个存储多个可调用对象的vector</span></span><br><span class="line">tasks.<span class="built_in">push_back</span>(func);<span class="comment">//void func(int x, int y);</span></span><br><span class="line">tasks.<span class="built_in">push_back</span>([] (<span class="type">int</span> x, <span class="type">int</span> y) &#123;...&#125;);<span class="comment">//添加一个lambda表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(function&lt;<span class="built_in">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f : tasks)&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">36</span>, <span class="number">36</span>);<span class="comment">//遍历所有的可调用对象，并调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辅助函数">辅助函数</h3><ul><li>min</li><li>max</li><li>swap</li><li>operator<ul><li><code>==</code></li><li><code>!=</code></li><li><code>&gt;</code></li><li><code>&lt;</code></li><li><code>&gt;=</code></li><li><code>&lt;=</code></li></ul></li></ul><h3 id="编译期分数运算">编译期分数运算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ratio&lt;<span class="number">5</span>, <span class="number">5</span>&gt; one;</span><br><span class="line">cout &lt;&lt; one.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; one.den &lt;&lt; endl;<span class="comment">// 1/1</span></span><br><span class="line"></span><br><span class="line">ratio&lt;<span class="number">5</span>, <span class="number">3</span>&gt; two;</span><br><span class="line">cout &lt;&lt; two.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; two.den &lt;&lt; endl;<span class="comment">// 5/3</span></span><br></pre></td></tr></table></figure><h2 id="四：STL">四：STL</h2><p>STL是C++标准库的核心，是一个泛型（generic）程序库，由三部分组成</p><ul><li>容器（Container）</li><li>迭代器（Iterator）</li><li>算法（Algorithm）</li></ul><h3 id="容器">容器</h3><h4 id="有序容器">有序容器</h4><p>顺序与插入顺序有关，与元素值无关，常常通过array、linked list实现</p><ul><li>array</li><li>vector</li><li>deque</li><li>list</li><li>forward_list</li></ul><h4 id="关联式容器">关联式容器</h4><p>在内部进行排序的集合，位置取决于value，常常通过二叉树实现</p><ul><li>set</li><li>multiset（mult的意思是元素可以重复）</li><li>map</li><li>multimap（mult的意思是key可以重复）</li></ul><h4 id="无序容器">无序容器</h4><p>元素位置无关紧要，重要的是元素是否在容器内，常常通过哈希表实现</p><ul><li>unordered_set</li><li>unordered_multiset</li><li>unordered_map</li><li>unordered_multmap</li></ul><h4 id="其他容器">其他容器</h4><ul><li>string</li><li>寻常的数组（一种type，而非class）</li></ul><h3 id="迭代器">迭代器</h3><p>迭代器是一个可以遍历STL容器全部、部分元素的对象</p><h4 id="操作">操作</h4><ul><li><code>*</code>：取元素</li><li><code>++</code>：迭代器前进至下一个元素<ul><li>注意，<code>++i</code>比<code>i++</code>效率高一点点，因为后者要创建临时对象</li></ul></li><li><code>==</code>、<code>!=</code>：判断两个迭代器是否指向同一个位置</li><li><code>=</code>：赋值</li></ul><h3 id="种类">种类</h3><table><thead><tr><th></th><th>R/W</th><th>读写次数</th><th>跳转</th><th>举例</th></tr></thead><tbody><tr><td>输入/输出迭代器</td><td>只读/只写</td><td>能且仅能读写一次</td><td>i++</td><td>istream_iterators、ostream_iterators</td></tr><tr><td>前向/双向迭代器</td><td>读写</td><td>能读写多次</td><td>i++</td><td>STL的set、map</td></tr><tr><td>随机访问迭代器</td><td>读写</td><td>能读写多次</td><td>i += n</td><td>vector、deque、string、array</td></tr></tbody></table><p>从上到下，迭代器能力越来越强（他们间有继承关系，前向 is a 输入）</p><h3 id="算法">算法</h3><p>大多为非成员函数，思想是泛型编程（而不是OOP）</p><h3 id="函数对象">函数对象</h3><p>一个行为像函数的对象，思想是泛型编程</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">X fo;</span><br><span class="line"><span class="built_in">fo</span>(arg1, arg2);<span class="comment">//等同于fo.operator()(arg1, arg2);</span></span><br></pre></td></tr></table></figure><ul><li>函数对象是一个带状态的函数</li><li>函数对象有自己的类型</li><li>函数对象速度通常比普通函数快（编译期间有更好的优化）</li></ul>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>profile工具</title>
      <link href="/graphics/profile%E5%B7%A5%E5%85%B7/"/>
      <url>/graphics/profile%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1>Profile工具</h1><p>工具手册</p><table><thead><tr><th>工具</th><th>优点</th><th>评价</th></tr></thead><tbody><tr><td>Unity profiler</td><td>用起来最简单，可以网络远程测试</td><td>功能不是很全</td></tr><tr><td>Xcode</td><td>功能全，而且使用简单</td><td>只能iOS，而且iOS打包很折磨</td></tr><tr><td>RenderDoc</td><td></td><td>安卓利器</td></tr><tr><td>snapdragon</td><td></td><td>只能用于高通骁龙soc，使用时注意有无adb</td></tr><tr><td>Nsight</td><td></td><td>贼难用（可能是Unity图形API的锅）</td></tr><tr><td>PIX</td><td></td><td>调试DX12也就这个好使</td></tr></tbody></table><h3 id="Xcode">Xcode</h3><h4 id="配置Xcode项目">配置Xcode项目</h4><p>Xcode想要截帧需要依赖Xcode源项目</p><ul><li><p>签名配置（略，这玩意贼恶心，尤其是别人的项目）</p></li><li><p>配置截帧</p><ul><li>Edit Scheme</li></ul></li></ul><p><img src="/images/EditScheme.png" class="lazyload" data-srcset="/images/EditScheme.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Edit Scheme"></p><ul><li>CaptureMetal</li></ul><p><img src="/images/CaptureMetal.png" class="lazyload" data-srcset="/images/CaptureMetal.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CaptureMetal"></p><ul><li>API Validation</li></ul><p><img src="/images/APIValidation.png" class="lazyload" data-srcset="/images/APIValidation.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="API Validation"></p><h4 id="截帧">截帧</h4><p><img src="/images/Metal%E6%88%AA%E5%B8%A7.png" class="lazyload" data-srcset="/images/Metal%E6%88%AA%E5%B8%A7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Metal截帧"></p><h4 id="截帧信息分析">截帧信息分析</h4><ul><li>GPU时间（首页就有）</li><li>带宽</li></ul><p><img src="/images/Xcode%E5%B8%A6%E5%AE%BD.png" class="lazyload" data-srcset="/images/Xcode%E5%B8%A6%E5%AE%BD.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Xcode带宽"></p><h4 id="截帧分享">截帧分享</h4><p>找到这个文件，分享给其他人</p><p><img src="/images/Xcode%E6%88%AA%E5%B8%A7%E5%88%86%E4%BA%AB.png" class="lazyload" data-srcset="/images/Xcode%E6%88%AA%E5%B8%A7%E5%88%86%E4%BA%AB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Xcode截帧分享"></p><h3 id="Nsight">Nsight</h3><h4 id="连接Unity-Editor">连接Unity Editor</h4><ul><li><p>以管理员身份打开</p></li><li><p>配置</p><ul><li><p>Application Executable：Unity.exe所在的绝对路径</p></li><li><p>Command Line Arguements：-projectPath ”项目根路径“</p><ul><li>项目根路径：文件夹内有Asset、Package的那个文件夹</li></ul></li></ul></li><li><p>启动</p><ul><li>点击Launch Frame Debugger</li><li>注意，请将Unity和Unity Hub都关掉</li></ul></li></ul><p><img src="/images/NSight_Unity.png" class="lazyload" data-srcset="/images/NSight_Unity.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="NSight_Unity"></p><h4 id="注意">注意</h4><p>Unity HDRP使用了<code>D3D11On12</code>，在使用NSight时会报Warm，暂时先别管</p><h3 id="Snapdragon">Snapdragon</h3><h4 id="连接安卓APP">连接安卓APP</h4><ul><li>Connect to a device<ul><li>如果找不到设备，检查有无adb命令，或者直接用adb连接</li></ul></li><li>Realtime看带宽<ul><li>从左下角Process中挑</li></ul></li><li>Trace Capture看GPU时间</li></ul><h3 id="RenderDoc">RenderDoc</h3><h4 id="连接安卓APP-2">连接安卓APP</h4><ul><li>手机连接电脑，电脑打开RenderDoc</li><li>Connect</li><li>打开Launch Application窗口<ul><li>Program——Executable Path——选择要截帧的APP</li></ul></li></ul><p><img src="/images/RenderDoc%E5%AE%89%E5%8D%93.jpg" class="lazyload" data-srcset="/images/RenderDoc%E5%AE%89%E5%8D%93.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RenderDoc安卓"></p><h4 id="连接Unity-Editor-2">连接Unity Editor</h4><ul><li>右键Scene，Load RenderDoc</li><li>按小相机截帧</li></ul><h3 id="PIX">PIX</h3><h4 id="权限配置">权限配置</h4><ul><li>开启Window开发者模式</li></ul><img src="/images/开发者模式.png" class="lazyload" data-srcset="/images/开发者模式.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="开发者模式" style="zoom: 80%;" /><ul><li>开启英伟达开发者模式（以管理员身法打开英伟达控制面板）<ul><li>注意，更换模式时，请注意关闭、保存Unity（和显卡相关的软件会崩掉）</li></ul></li></ul><p><img src="/images/%E8%8B%B1%E4%BC%9F%E8%BE%BE%E8%AE%BE%E7%BD%AE.png" class="lazyload" data-srcset="/images/%E8%8B%B1%E4%BC%9F%E8%BE%BE%E8%AE%BE%E7%BD%AE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="英伟达设置"></p><h4 id="连接Unity-Editor-3">连接Unity Editor</h4><ul><li><p>以管理员身份打开PIX</p></li><li><p>Attach Unity Editor（配置方式同NSight）</p></li></ul><p><img src="/images/PIX.jpg" class="lazyload" data-srcset="/images/PIX.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PIX"></p><ul><li>按GPU Capture截帧</li></ul>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>骨骼动画</title>
      <link href="/graphics/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"/>
      <url>/graphics/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h1>骨骼动画</h1><ul><li>序列帧动画：记录动作的每一帧<ul><li>非矢量动画：每一帧是固定不可复用的，新的一帧本质上是完全重画一次物体，没有发生形态上的改变</li></ul></li><li>关键帧动画：记录动作的始末和轨迹曲线，运行时根据曲线进行插值（很显然，这是一种矢量动画）<ul><li>每个关键帧被称为姿势</li></ul></li></ul><h2 id="顶点动画">顶点动画</h2><p>骨骼动画的本质是顶点动画</p><ul><li>刚体动画：在渲染中网格不发生改变，刚体的变化矩阵发生改变</li><li>顶点动画：在渲染中网格顶点发生了直接的变化（位移旋转缩放）<ul><li>骨骼动画：一种对顶点动画的压缩算法</li><li>流体动画</li><li>粒子动画</li><li>变形动画：常用于制作表情，捏脸</li></ul></li></ul><p>根据顶点动画的实现方式，分为CPU和GPU</p><table><thead><tr><th></th><th>CPU动画</th><th>GPU动画</th></tr></thead><tbody><tr><td>顶点位置改变时机</td><td>CPU应用阶段</td><td>GPU几何阶段</td></tr><tr><td>数据流</td><td>CPU传递给GPU的顶点数组发生改变</td><td>顶点着色器输出发生改变</td></tr></tbody></table><h3 id="骨骼动画">骨骼动画</h3><p>骨骼动画的模型整体不是刚体，同时为了避免旋转、移动时发生断裂，也不能将物体拆分为多个小刚体，因此只能选择顶点动画。</p><p>然而顶点动画带来的顶点移动，如果全部交由vertex着色器处理，过于昂贵，实时渲染不可接受</p><p>而且骨骼动画的顶点受更高层次的骨骼节点控制</p><ul><li>同一根骨骼的顶点要保持相对位置不变</li><li>骨骼间顶点要进行平滑</li><li>顶点的大体形状受骨骼形状制约，顶点变化时要保持和骨骼的联系</li></ul><h4 id="实现">实现</h4><p>矩阵调色板蒙皮技术（Matrix Palette Skinning）：</p><ul><li>骨骼为近似刚体，其变化矩阵按顺序存储在数组中（我们称这个数组为骨骼）</li><li>顶点缓冲中会存储其骨骼ID和权重信息（一个顶点通常会受1～4个骨骼影响，可以用两个Vector存储）</li><li>进行变化时，顶点可以根据骨骼ID和权重查询变化矩阵，并通过插值的方式实现顶点动画（我们称查询矩阵为蒙皮）</li><li>CPU通过姿势间插值，以获得每一帧骨骼的位置及矩阵，GPU根据顶点信息查询矩阵进而实现运动</li></ul><h2 id="坐标系">坐标系</h2><p><img src="/images/%E5%9D%90%E6%A0%87%E7%B3%BB.png" class="lazyload" data-srcset="/images/%E5%9D%90%E6%A0%87%E7%B3%BB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><h3 id="骨骼树">骨骼树</h3><p>三维骨骼本质上是一系列Bone组成的树状结构</p><p>在骨骼动画中，我们更关心骨骼的相对位置，于是我们选择本地坐标系（A物体的本地坐标就是以A物体中心为原点，相对于中心的偏移），并让坐标系层次嵌套</p><blockquote><p>比如大臂移动时也会带动小臂移动，我们就把小臂的本地坐标系定义在大臂的本地坐标系之下，我们称大臂是小臂的父物体，小臂是大臂的子物体。而小臂在大臂的本地坐标系的坐标被称为局部坐标系（可以参考Unity的GO组织）</p></blockquote><p>顺着嵌套关系向根部搜索，就可以获得物体的世界坐标系</p><p>下图为树节点的数据结构</p><p><img src="/images/%E7%A9%BA%E9%97%B4%E6%A0%91%E8%8A%82%E7%82%B9.png" class="lazyload" data-srcset="/images/%E7%A9%BA%E9%97%B4%E6%A0%91%E8%8A%82%E7%82%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><ul><li>本地坐标系就是object space transform</li></ul><p>在播放动画时，会从空间树的根节点（一般为盆骨节点或者root节点）开始向下递归变化，以保证父物体的local transform总是先于子物体刷新</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//对关键帧进行插值 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OnAnimated</span>(<span class="params">CoordinateTreeNode Key0, CoordinateTreeNode Key1, <span class="built_in">float</span> t</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    Position = Vector3.Lerp(Key0.Position, Key1.Position, t); </span><br><span class="line">    Rotation = Quaternion.Lerp(Key0.Rotation, Key2.Rotation, t); </span><br><span class="line">    Scale = Vector3.Lerp(Key0.Scale, Key1.Scale, t); </span><br><span class="line">    </span><br><span class="line">    localTransform = <span class="keyword">new</span> TransformMatrix(Position, Rotation, Scale); </span><br><span class="line">    combinedTransform = parent.localTransform * <span class="keyword">this</span>.localTransform; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="骨骼">骨骼</h3><ul><li>盆骨：选盆骨作为根节点（或者是空根节点的第一也是唯一的子节点），是因为盆骨在运动时相对匀速，且位置居中，可以避免骨骼树过深</li><li>脊椎骨：模拟躯干运动，一般有2～3块</li><li>捻度骨骼：Twist Bone，生物学中像小臂这类骨骼不是一块骨骼，而是两条并排的骨骼，以此实现肘关节不动而手掌可以旋转</li></ul><p><img src="/images/%E4%BA%BA%E4%BD%93%E9%AA%A8%E9%AA%BC.png" class="lazyload" data-srcset="/images/%E4%BA%BA%E4%BD%93%E9%AA%A8%E9%AA%BC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><h3 id="坐标变化">坐标变化</h3><ul><li>位移矩阵</li><li>缩放矩阵</li><li>旋转矩阵</li><li>齐次坐标</li><li>仿射变换：缩放–旋转–平移</li><li>列矩阵左乘</li><li>手性变换：只需要对所有的矩阵任选一维进行取反即可（哪个维度不重要，只要统一即可）</li></ul><h2 id="旋转">旋转</h2><p>骨骼动画是矢量动画，是关键帧动画，因此会用到大量的插值，这决定了旋转的表达<strong>必须便于插值</strong></p><p>三维空间中的点可以由三个正交向量插值表示，根据嵌套关系，一个物体发生旋转，其实就是其基向量相对于父节点基向量发生改变</p><h3 id="双向量法">双向量法</h3><p>既然旋转可以由基向量的朝向表示，那么我们就直接基向量表示旋转吧！</p><p>正好三个基向量正交，而且对长度不敏感，那么我们还可以将三个向量压缩为两个向量</p><p>更进一步，这些向量都在球面上，那么用球坐标系替代直角坐标系</p><p>问题：</p><ul><li>需要时刻保证两个向量垂直</li><li>不好插值</li></ul><h3 id="欧拉角">欧拉角</h3><p>在航空业应用广泛，本质是一种过程量，描述了从初始位置沿着xyz轴旋转指定角度的过程，使用时需要明确旋转顺序（即顺规）</p><table><thead><tr><th></th><th>直角坐标系</th><th>欧拉角</th></tr></thead><tbody><tr><td>前进方向</td><td>Z</td><td>Roll 桶滚角</td></tr><tr><td>上方向</td><td>Y</td><td>Yaw 偏航角</td></tr><tr><td>右方向</td><td>X</td><td>Pitch 俯仰角</td></tr></tbody></table><p>问题：</p><ul><li>没有统一标准，而欧拉角强依赖于顺规</li><li>某些情况下会有两个轴平行，以至于失去一个自由度，导致万向节死锁</li><li>不能线性插值</li></ul><h3 id="轴角与四元数">轴角与四元数</h3><p>轴角（x, y, z, w）指沿着轴（x, y, z）旋转w度，也可以压缩为三维向量（wx’, wy’, wz’），轴角可以通过对轴向量和旋转角度分别插值对方法进行插值</p><p>四元数是一种超复数，可以用来表示旋转</p><p><a href="https://www.bilibili.com/video/BV1SW411y7W1">四元数的可视化_哔哩哔哩_bilibili</a></p><h2 id="蒙皮解算">蒙皮解算</h2><p>Mesh中的顶点缓存中会存储骨架、骨骼索引，骨骼权重，将用于蒙皮解算</p><p><img src="/images/Mesh.png" class="lazyload" data-srcset="/images/Mesh.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Mesh"></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake入门</title>
      <link href="/program/CMake%E5%85%A5%E9%97%A8/"/>
      <url>/program/CMake%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>CMake</h1><h2 id="快速入门">快速入门</h2><p>一个大项目（Project）内嵌多个子项目（SubProject）</p><p>一个子项目内有src、include、CMakeLists.txt，其中有一个子项目中有main.cpp</p><img src="/images/C++项目结构.png" class="lazyload" data-srcset="/images/C++项目结构.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="C++项目结构" style="zoom:50%;" /><p>最外面的CMakeLists.txt，负责连接所有子项目：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">Project</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(subProject1)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(subProject2)</span><br></pre></td></tr></table></figure><p>subProject1（main.cpp所在的子项目）下面的CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_executable</span>(subProject1 <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(subProject1 PUBLIC <span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(subProject1 PUBLIC subProject2)</span><br></pre></td></tr></table></figure><p>subProject2下面的CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_library</span>(subProject2 STATIC <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(subProject2 PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p>生成sln项目</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cmake</span> -G <span class="string">&quot;Visual Studio 16 2019&quot;</span></span><br></pre></td></tr></table></figure><p>用vs打开sln项目能看到2+n个项目，其中</p><ul><li><code>ALL_BUILD</code>：编译该项目会编译整个工程</li><li><code>ZERO_CHECK</code>：监视<code>CMakeLists.txt</code>的变化，一旦改变会告诉编译器重新构建工程</li></ul><p>或者可以用make构建项目</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cmake</span> -H. -Bbuild</span><br></pre></td></tr></table></figure><h2 id="一：CMake基础语法">一：CMake基础语法</h2><h3 id="CMakeLists-txt">CMakeLists.txt</h3><p>我们将CMake指令放在<code>CMakeLists.txt</code>文件中</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置CMake所需最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="comment">#设置项目名称为CMakeStudy，支持的语言为C++（CXX表示C++）</span></span><br><span class="line"><span class="keyword">project</span>(CMakeStudy LANGUAGES CXX)</span><br><span class="line"><span class="comment">#设置创建的新目标名称：一个名叫CMakeStudy的可执行文件</span></span><br><span class="line"><span class="comment">#这个可执行文件是通过编译和链接源文件main.cpp生成的</span></span><br><span class="line"><span class="keyword">add_executable</span>(CMakeStudy main.cpp)</span><br></pre></td></tr></table></figure><ul><li>CMake语言不区分大小写，但参数区分大小写</li><li>CMake的缺省默认语言为C++</li></ul><h3 id="构建">构建</h3><p>写好<code>CMakeLists.txt</code>文件后，在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">cmake -H. -Bbuild</span></span><br></pre></td></tr></table></figure><p>这个命令会搜索当前目录下的根<code>CMakeLists.txt</code>文件，创建一个<code>build</code>目录，在其中生成所有的代码</p><p>然后再build目录中输入命令，以完成编译</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">cmake --build .</span></span><br></pre></td></tr></table></figure><p>一般我们不会在源码内部构建，因为这会污染源码的目录树</p><h3 id="链接">链接</h3><p>如果项目中有多个文件，如</p><p><img src="/images/%E9%93%BE%E6%8E%A5.png" class="lazyload" data-srcset="/images/%E9%93%BE%E6%8E%A5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="链接"></p><p>可以改目标生成</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello main.cpp <span class="keyword">Message</span>.cpp <span class="keyword">Message</span>.h)</span><br></pre></td></tr></table></figure><p>但是这种改法太麻烦了，每添加一个文件就要在后面添一端，最后这东西会特别长</p><p>我们可以把这个类编译成一个（静态）库，然后再将库链接到可执行文件中（你还记得c++编译器的编译步骤吗？）</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(CMakeStudy LANGUAGES CXX)</span><br><span class="line"><span class="comment">#将两个文件编译成库</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span> STATIC <span class="keyword">Message</span>.h <span class="keyword">Message</span>.cpp)</span><br><span class="line"><span class="comment">#目标不变</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp)</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello <span class="keyword">message</span>)</span><br></pre></td></tr></table></figure><p>此外，我们能在buid目录中找到一个名为/形如<code>libmessage.a</code>的文件，这就是编译得到的静态库</p><h4 id="add-library">add_library</h4><p>生成一个名叫<code>message</code>的库</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span> STATIC <span class="keyword">Message</span>.h <span class="keyword">Message</span>.cpp)</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是目标名，后续可以使用该名来引用库</p></li><li><p>第二个参数是库的种类</p><ul><li>STATIC：静态库</li><li>SHARED：动态库</li><li>OBJECT：对象库（将代码编译到可执行文件内部的静态库）</li><li>MODULE：一种不会链接到项目中任何目标的动态共享对象（DSO），可以运行时动态加载</li></ul></li></ul><p>此外CMake还有一些不会出现在构建系统里的库</p><ul><li>IMPORTED：项目外部的库，用于对现有依赖项进行构建，认为是不可变的</li><li>INTERFACE：也是项目之外的库，但是可变</li><li>ALIAS：对已有的库做别名</li></ul><h4 id="条件语句">条件语句</h4><p>在讲链接时，我们给出了两种编译方法，我们希望能在两种方式间切换</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(CMakeStudy LANGUAGES CXX)</span><br><span class="line"><span class="comment">#引入一个新变量USE_LIBRARY，设置为OFF</span></span><br><span class="line"><span class="keyword">set</span>(USE_LIBRARY <span class="keyword">OFF</span>)</span><br><span class="line"><span class="comment">#打印信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Compile sources into a library? $&#123;USE_LIBRARY&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="comment">#引入一个list变量: _sources，包含两个文件</span></span><br><span class="line"><span class="keyword">list</span>(APPEND _sources <span class="keyword">Message</span>.h <span class="keyword">Message</span>.cpp)</span><br><span class="line"><span class="comment">#判断，若USE_LIBRARY为真，则编译成库</span></span><br><span class="line"><span class="keyword">if</span>(USE_LIBRARY)</span><br><span class="line">    <span class="keyword">add_library</span>(<span class="keyword">message</span> <span class="variable">$&#123;_sources&#125;</span>)</span><br><span class="line">    <span class="keyword">add_executable</span>(hello main.cpp)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(hello <span class="keyword">message</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">add_executable</span>(hello main.cpp <span class="variable">$&#123;_sources&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h4 id="逻辑变量">逻辑变量</h4><ul><li>true：<code>1</code>、<code>ON</code>、<code>YES</code>、<code>true</code>、<code>Y</code>、非零数</li><li>false：<code>0</code>、<code>OFF</code>、<code>NO</code>、<code>false</code>、<code>N</code>、<code>IGNORE</code>、<code>NOTFOUND</code>、空字符串、以<code>-NOTFOUND</code>为后缀</li></ul><h4 id="全局变量">全局变量</h4><p>CMake有一些全局变量，修改他们可以起到配置作用，这里设置的</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">OFF</span>)</span><br></pre></td></tr></table></figure><p>当设置为OFF时，可以使<code>add_library</code>不用传递第二个参数</p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>CMAKE_RUNTIME_OUTPUT_DIRECTORY</td><td>.exe、.dll文件的输出路径</td></tr><tr><td>CMAKE_ARCHIVE_OUTPUT_DIRECTORY</td><td>.a文件的输出路径</td></tr><tr><td>CMAKE_LIBRARY_OUTPUT_DIRECTORY</td><td>.so文件的输出路径</td></tr><tr><td>CMAKE_CURRENT_SOURCE_DIR</td><td>当前CMakeLists.txt所在路径</td></tr><tr><td>PROJECT_NAME</td><td>项目名字</td></tr><tr><td>CMAKE_MODULE_PATH</td><td>cmake模块所在路径</td></tr></tbody></table><h3 id="用户选项">用户选项</h3><p>在上面我们引入了一个条件语句，但是是硬编码的。我们希望用户可以控制<code>USE_LIBRARY</code>，于是可以使用<code>option</code></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#set(USE_LIBRARY OFF)</span></span><br><span class="line"><span class="keyword">option</span>(USE_LIBRARY <span class="string">&quot;Compile sources into a library&quot;</span> <span class="keyword">OFF</span>)</span><br></pre></td></tr></table></figure><p>将上面下面的<code>set</code>替换为<code>option</code>，运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">cmake -D USE_LIBRARY=ON</span></span><br></pre></td></tr></table></figure><p>如果是Clion可以配置</p><p><img src="/images/Clion-Option.png" class="lazyload" data-srcset="/images/Clion-Option.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Clion-Option"></p><h3 id="构建类型">构建类型</h3><table><thead><tr><th>类型</th><th>有无优化</th></tr></thead><tbody><tr><td>Debug</td><td>没有优化，带调试符号</td></tr><tr><td>Release</td><td>有优化，没有调试符号</td></tr><tr><td>RelWithDebInfo</td><td>有少量优化，带调试符号</td></tr><tr><td>MinSizeRel</td><td>不增加代码大小来优化</td></tr></tbody></table><h3 id="编译选项">编译选项</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(CMakeStudy LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(APPEND flags <span class="string">&quot;-fPIC&quot;</span> <span class="string">&quot;-Wall&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> WIN32)</span><br><span class="line">    <span class="keyword">list</span>(APPEND flags <span class="string">&quot;-Wextra&quot;</span> <span class="string">&quot;-Wpedantic&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment">#添加一个库</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span></span><br><span class="line">    STATIC</span><br><span class="line">        <span class="keyword">Message</span>.h</span><br><span class="line">        <span class="keyword">Message</span>.cpp</span><br><span class="line">)</span><br><span class="line"><span class="comment">#为库设置编译选项</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(<span class="keyword">message</span></span><br><span class="line">    PRIVATE</span><br><span class="line">        <span class="variable">$&#123;flags&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">#添加可执行目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp)</span><br><span class="line"><span class="comment">#为可执行目标设置编译选项</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(hello</span><br><span class="line">    PRIVATE</span><br><span class="line">        <span class="string">&quot;-fPIC&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello <span class="keyword">message</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>可见性</th><th>含义</th></tr></thead><tbody><tr><td>PRIVATE</td><td>编译选项仅对目标生效，不会传递（hello链接了message，但不会接受message的编译选项）</td></tr><tr><td>INTERFACE</td><td>编译选项对目标生效，并传递给相关目标</td></tr><tr><td>PUBLIC</td><td>编译选项对目标和使用它的目标生效</td></tr></tbody></table><p><code>-Wall</code>、<code>-Wextra</code>等是警告标志</p><blockquote><p>如果A模块链接了core模块，B模块链接了A模块，如果B模块想用core的头文件，A在链接core时需要是PUBLIC</p></blockquote><h4 id="MSVC">MSVC</h4><p>配置MSVC编译选项</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(my_executable PRIVATE /EHs-c-)  <span class="comment"># 禁用异常处理</span></span><br><span class="line">    <span class="keyword">target_compile_options</span>(my_executable PRIVATE /W4 /WX)  <span class="comment"># 设置警告级别为 4，并将警告视为错误</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h3 id="循环">循环</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(_source <span class="variable">$&#123;sources_with_lower_optimization&#125;</span>)</span><br><span class="line">  <span class="keyword">get_source_file_property</span>(_flags <span class="variable">$&#123;_source&#125;</span> COMPILE_FLAGS)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Source $&#123;_source&#125; has the following extra COMPILE_FLAGS: $&#123;_flags&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><h3 id="命令">命令</h3><p>cmake中可以添加一些自定义命令，常用于实现编译前文件拷贝操作，比如将第三方<code>.dll</code>文件复制到可执行文件到项目根路径</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span> </span><br><span class="line">                   POST_BUILD </span><br><span class="line">                   <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E </span><br><span class="line">                   copy “<span class="variable">$&#123;xxx.dll&#125;</span>” $&lt;TARGET_FILE_DIR:<span class="variable">$&#123;PROJECT_NAME&#125;</span>&gt;</span><br><span class="line">                   )</span><br></pre></td></tr></table></figure><p>命令执行时机：</p><ul><li><code>POST_BUILD</code>：生成目标文件后</li><li><code>PRE_BUILD</code>：编译前</li><li><code>PRE_LINK</code>：链接前</li></ul><p>执行的命令是Linux Command，比如<code>copy $&#123;source&#125; $&#123;target&#125;</code>，<code>echo $&#123;output_string&#125;</code></p><h3 id="搜索">搜索</h3><p>我们不可能将每一个文件都以单文件的形式写进<code>CMakeLists.txt</code>中，于是我们需要按照某种规则搜索所有的文件</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SRC_FILES_H <span class="string">&quot;$&#123;SOURCE_DIR&#125;/*.h&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SRC_FILES_CPP <span class="string">&quot;$&#123;SOURCE_DIR&#125;/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(ALL_FILES <span class="variable">$&#123;SRC_FILES_H&#125;</span> <span class="variable">$&#123;SRC_FILES_CPP&#125;</span>)</span><br></pre></td></tr></table></figure><p>排除SRC中部分文件</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(FILTER SRC EXCLUDE REGEX <span class="string">&quot;/ui/*&quot;</span>)</span><br><span class="line"><span class="keyword">list</span>(FILTER SRC EXCLUDE REGEX <span class="string">&quot;/core/+&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="二：环境检查">二：环境检查</h2><h3 id="检查平台">检查平台</h3><p>我们要处理如下的C++源码（hello-world.cpp）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IS_WINDOWS</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from Windows!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_LINUX</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from Linux!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_MACOS</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from macOS!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from an unknown system!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMake可以加入</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询操作系统</span></span><br><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line"><span class="comment">#设置宏</span></span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_LINUX&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Darwin&quot;</span>)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_MACOS&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_WINDOWS&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h3 id="检查编译器">检查编译器</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> Intel)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> GNU)</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="检查处理器架构">检查处理器架构</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_SIZEOF_VOID_P <span class="keyword">EQUAL</span> <span class="number">8</span>)</span><br><span class="line"><span class="comment">#64bits</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line"><span class="comment">#32bits</span></span><br><span class="line">endlf()</span><br></pre></td></tr></table></figure><h2 id="三：链接外部库">三：链接外部库</h2><h3 id="语法">语法</h3><h4 id="find-package">find_package</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找名为OpenCV的包，如果没找到就报错</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br></pre></td></tr></table></figure><p>该函数的本质就是去（先去标准路径）寻找一个<code>包名-config.cmake</code>文件</p><p>在mac，找OpenCV找的可能就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/cmake/OpenCV/OpenCVConfig.cmake</span><br></pre></td></tr></table></figure><p>如果你安装的位置不是标准路径，你可以</p><ul><li>在build时手动指定<code>-xxx_DIR=&quot;aaa/lib/cmake/xxx&quot;</code><ul><li>只有第一次指定，只要不删掉build目录，就不需要重新指定</li></ul></li><li>可以在CMakeLists.txt<strong>最开头</strong>写<code>set(xx_DIR &quot;aaa/lib/cmake/xxx&quot;)</code>、</li><li>可以给<code>xxx_DIR</code>设置环境变量</li></ul><h3 id="链接静态库">链接静态库</h3><ol><li>在项目根目录新建lib文件夹</li><li>将要链接的静态库（<code>test_library.a</code>）复制到lib文件夹中</li><li>找包</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_library</span>(TEXT_LIBRARY test_library lib)</span><br></pre></td></tr></table></figure><ol start="4"><li>链接</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(testapp LINK_PUBLIC &amp;&#123;TEST_LIBRARY&#125;)</span><br></pre></td></tr></table></figure><h3 id="链接动态库">链接动态库</h3><h3 id="常用库">常用库</h3><h4 id="Eigen">Eigen</h4><p>Eigen是一个纯头文件实现的线性代数库，在mac上可以使用brew安装</p><ol><li>安装（记住eigen的版本）</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">brew install eigen</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将Eigen链接到系统文件夹（brew一般会自动链接）</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">brew <span class="built_in">link</span> --overwrite eigen</span></span><br></pre></td></tr></table></figure><ol start="3"><li>链接</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#寻找Eigen包，并附带包版本</span></span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 <span class="number">3.4</span> REQUIRED CONFIG)</span><br><span class="line"><span class="comment">#若找到，则打印信息</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">TARGET</span> Eigen3::Eigen)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Eigen3 $&#123;EIGEN3_VERSION_STRING&#125; found in $&#123;EIGEN3_INCLUDE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"><span class="comment">#目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(path-info main.cpp)</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(path-info</span><br><span class="line">        PUBLIC</span><br><span class="line">        Eigen3::Eigen</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dim = std::<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    Eigen::MatrixXd A = Eigen::MatrixXd::<span class="built_in">Random</span>(dim, dim);</span><br><span class="line">    std::cout &lt;&lt; A;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="brew的用法">brew的用法</h3><p>这里提一嘴Homebrew，这是一个mac上非常好用的包管理器，可以非常“优雅”地安装软件</p><p>brew会把软件安装在<code>/usr/local/Cellar</code>目录</p><ul><li>安装目录软链接到<code>/usr/local/opt</code></li><li>bin目录执行文件链接到<code>/usr/local/bin</code>中（opt也有可能在根目录）</li></ul><p>常用命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew -v     <span class="comment"># 安装完成后可以查看版本</span></span><br><span class="line">$ brew --<span class="built_in">help</span> <span class="comment"># 简洁命令帮助</span></span><br><span class="line">$ man brew    <span class="comment"># 完整命令帮助</span></span><br><span class="line"></span><br><span class="line">$ brew search git    <span class="comment"># 搜索软件包</span></span><br><span class="line">$ brew info git      <span class="comment"># 查看软件包信息</span></span><br><span class="line">$ brew home git      <span class="comment"># 访问软件包官方站(用浏览器打开)</span></span><br><span class="line"></span><br><span class="line">$ brew install git   <span class="comment"># 安装软件包(这里是示例安装Git版本控制)</span></span><br><span class="line">$ brew uninstall git <span class="comment"># 卸载软件包</span></span><br><span class="line">$ brew list          <span class="comment"># 显示已经安装的所有软件包</span></span><br><span class="line">$ brew list --versions <span class="comment"># 查看你安装过的包列表（包括版本号）</span></span><br><span class="line"></span><br><span class="line">$ brew update        <span class="comment"># 同步远程最新更新情况，对本机已经安装并有更新的软件用*标明</span></span><br><span class="line">$ brew outdated      <span class="comment"># 查看已安装的哪些软件包需要更新</span></span><br><span class="line">$ brew upgrade git   <span class="comment"># 更新单个软件包</span></span><br><span class="line">$ brew deps php      <span class="comment"># 显示包依赖</span></span><br><span class="line"></span><br><span class="line">$ brew cleanup       <span class="comment"># 清理所有已安装软件包的历史老版本</span></span><br><span class="line">$ brew cleanup git   <span class="comment"># 清理单个已安装软件包的历史版本</span></span><br><span class="line">$ brew cleanup -n    <span class="comment"># 查看哪些软件包要被清除</span></span><br></pre></td></tr></table></figure><h3 id="拷贝动态库">拷贝动态库</h3><p>有时为了可拓展性和编译速度，我们会将一个项目切分为多个模块，这些模块编译为dll，然后拷贝到主程序（exe）所在的目录</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 OptickCore.dll拷贝到 client.exe所在路径</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> client POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different</span><br><span class="line">    $&lt;TARGET_FILE:OptickCore&gt;</span><br><span class="line">    $&lt;TARGET_FILE_DIR:client&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="四：项目">四：项目</h2><h3 id="模块">模块</h3><p>我们可以将一个大的CMake源码分成一个个模块，将这些模块放在<code>cmake</code>文件夹里，后缀为<code>.cmake</code></p><p>如下的项目结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmake</span><br><span class="line">│     └── colors.cmake</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><p><code>cmake/colors.cmake</code>文件内包含了一个色彩输出的定义</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">macro</span>(define_colors)</span><br><span class="line">  <span class="keyword">if</span>(WIN32)</span><br><span class="line">    <span class="comment"># has no effect on WIN32</span></span><br><span class="line">    <span class="keyword">set</span>(ColourReset <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(ColourBold <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Red <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Green <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Yellow <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Blue <span class="string">&quot;&quot;</span>)</span><br><span class="line">   ...</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">string</span>(ASCII <span class="number">27</span> Esc)</span><br><span class="line">    <span class="keyword">set</span>(ColourReset <span class="string">&quot;$&#123;Esc&#125;[m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(ColourBold <span class="string">&quot;$&#123;Esc&#125;[1m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Red <span class="string">&quot;$&#123;Esc&#125;[31m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Green <span class="string">&quot;$&#123;Esc&#125;[32m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Yellow <span class="string">&quot;$&#123;Esc&#125;[33m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Blue <span class="string">&quot;$&#123;Esc&#125;[34m&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure><p>在<code>CMakeLists.txt</code>引用</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将/cmake目录添加到路径列表</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"><span class="comment">#引入colors.cmake</span></span><br><span class="line"><span class="keyword">include</span>(colors)</span><br><span class="line"><span class="comment">#使用定义</span></span><br><span class="line">define_colors()</span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(函数名 参数<span class="number">1</span> 参数<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p><a href="https://www.jetbrains.com/help/clion/quick-cmake-tutorial.html?keymap=secondary_macos#seealso">Clion CMake</a></p><p><a href="https://www.bookstack.cn/read/CMake-Cookbook/content-preface-preface-chinese.md">CMake菜谱</a></p><p><a href="https://www.bilibili.com/video/BV1V84y117YU">小鹏老师</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WPF中的C#</title>
      <link href="/program/Csharpe/"/>
      <url>/program/Csharpe/</url>
      
        <content type="html"><![CDATA[<h1>WPF中的C#</h1><h2 id="C-语法">C#语法</h2><h3 id="容器">容器</h3><blockquote><p>C#容器和其他语言接近，这里只列出一些我感觉很有意思的写法</p></blockquote><h4 id="ConcurrentDictionary">ConcurrentDictionary</h4><p>线程安全地修改key所对应的List，若Key不存在，则新建一个，</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">object</span>&gt;&gt; instanceDictionary = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">object</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">string</span> key ,<span class="built_in">object</span> instance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instanceDictionary.AddOrUpdate(key, </span><br><span class="line">        k =&gt; <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt; &#123; instance &#125;, </span><br><span class="line">        (k, exitingList)=&gt; &#123; exitingList.Add(instance); <span class="keyword">return</span> exitingList; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式">正则表达式</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> source = <span class="string">&quot;building.lod0.mesh&quot;</span></span><br><span class="line"><span class="built_in">string</span> pattern = <span class="string">@&quot;lod(\d).mesh&quot;</span>;</span><br><span class="line">Match match = Regex.Match(source, pattern);</span><br><span class="line"><span class="keyword">if</span>(match.Success)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> ans = match.Value;<span class="comment">// &quot;lod0.mesh&quot;</span></span><br><span class="line">    <span class="built_in">string</span> level = match.Groups[<span class="number">1</span>].Value;<span class="comment">// &quot;0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="委托">委托</h3><p>C#的委托类似于C++的函数指针，C#中，将参数<code>a,b</code>委托给了对象adder的Add方法，委托本质上是一种支持<code>()</code>运算符的<strong>对象</strong>。既然是对象，就可以有自己的成员和状态</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Adder</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> c = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Adder</span>(<span class="params"><span class="built_in">int</span> c</span>)</span>&#123; <span class="keyword">this</span>.c = c; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123; <span class="keyword">return</span> a+b+c; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Main()&#123;...</span></span><br><span class="line">Adder adder = <span class="keyword">new</span> Adder(<span class="number">1</span>);</span><br><span class="line">Fun f = adder.Add;</span><br><span class="line">f(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//return 6</span></span><br></pre></td></tr></table></figure><p>C#委托支持匿名委托和lambda表达式</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line"><span class="comment">//Main()&#123;...</span></span><br><span class="line">Fun f = <span class="built_in">delegate</span>(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">  cout &lt;&lt; a+b &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">Fun f2 = (<span class="built_in">int</span> a, <span class="built_in">int</span> b)=&gt;&#123;</span><br><span class="line">  cout &lt;&lt; a+b &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="C-的函数指针">C++的函数指针</h4><p>C/C++的函数指针是一个指向函数入口的指针，不具有对象的性质，只能指向非成员函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*Func)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    Func func = Add;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//cout 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果加上类型限制符，还是可以指向成员函数的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Multiple</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(Multiple::*Fm)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    Multiple multiple;</span><br><span class="line">    Fm f = &amp;Multiple::Mul;</span><br><span class="line">    std::cout &lt;&lt; (multiple.*f)(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想让C++对委托具有对象的性质，我们可以重载<code>()</code>操作符</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> c)&#123; <span class="keyword">this</span>-&gt;c = c; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="function">Adder <span class="title">adder</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">adder</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Action泛型委托">Action泛型委托</h4><p>C#一种无返回值的泛型委托</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;</span><br></pre></td></tr></table></figure><p>无参数<code>Action xxx = 函数</code></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Name</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> InstanceName&#123; <span class="keyword">private</span> <span class="keyword">set</span>; <span class="keyword">get</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Name</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    InstanceName = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayName</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;I&#x27;m <span class="subst">&#123;InstanceName&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Name testName = <span class="keyword">new</span> Name(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">  Action showName = testName.DisplayName;</span><br><span class="line">  showName();</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure><p>有参数<code>Action&lt;参数类型&gt; xxx = 函数</code></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Name</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> InstanceName&#123; <span class="keyword">private</span> <span class="keyword">set</span>; <span class="keyword">get</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Name</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    InstanceName = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayName</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;I&#x27;m <span class="subst">&#123;InstanceName&#125;</span>, <span class="subst">&#123;str&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Name testName = <span class="keyword">new</span> Name(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">  Action&lt;<span class="built_in">string</span>&gt; showName = testName.DisplayName;</span><br><span class="line">  showName(<span class="string">&quot;HHH&quot;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h4 id="Func泛型委托">Func泛型委托</h4><p>C#一种有返回值的泛型委托</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">out</span> <span class="title">TResult</span>&gt;()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Adder</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> c;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Adder</span>(<span class="params"><span class="built_in">int</span> c</span>)</span> &#123; <span class="keyword">this</span>.c = c; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Adder adder = <span class="keyword">new</span> Adder(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//第一个参数是返回值类型，后面的参数是输入参数类型</span></span><br><span class="line">  Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; method = adder.Add;</span><br><span class="line">  <span class="comment">//使用时不需要写返回值参数</span></span><br><span class="line">  Console.WriteLine(method(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件">事件</h3><p><em>这里的事件指CLR事件模型，详细内容见下文</em></p><p>委托：把工作委托给了某个函数，可以直接调用</p><p>事件：订阅者侦听发行者，发行者可以通过回调函数间接让订阅者干事（而且订阅者具体干什么，要看订阅者心情，发行者无权过问）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEventArgs</span>: <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Args</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">    <span class="keyword">get</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyEventArgs</span>(<span class="params"><span class="built_in">string</span> args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    Args = args;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件发行者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSource</span></span><br><span class="line">&#123;</span><br><span class="line">  MyEventArgs eventArgs;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EventSource</span>(<span class="params"><span class="built_in">string</span> args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    eventArgs = <span class="keyword">new</span> MyEventArgs(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">handlerEvent</span>(<span class="params">Object sender, MyEventArgs args</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">event</span> handlerEvent m_handler_event;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handler</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_handler_event?.Invoke(<span class="keyword">this</span>, eventArgs);</span><br><span class="line">    <span class="comment">//也可以写成 m_handler_event(this, eventArgs);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    EventSource source = <span class="keyword">new</span> EventSource(<span class="string">&quot;Event had been raised!&quot;</span>);</span><br><span class="line">    source.Name = <span class="string">&quot;Tim&quot;</span>;</span><br><span class="line">    source.m_handler_event += <span class="keyword">new</span> EventSource.handlerEvent(writeHello);</span><br><span class="line">    <span class="comment">//也可以写成 source.m_handler_event += writeHello;</span></span><br><span class="line">    source.Handler();<span class="comment">//输出：Hello Tim, Event had been raised!</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeHello</span>(<span class="params">Object sender, MyEventArgs args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    EventSource source = sender <span class="keyword">as</span> EventSource;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Hello <span class="subst">&#123;source.Name&#125;</span>, <span class="subst">&#123;args.Args&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初我很好奇，我们注册了一个处理函数，<code>source.m_handler_event += writeHello</code>，但是好像没看到怎么传参进去。</p><p>其实是因为C#的委托本质是一个支持<code>()</code>运算符的对象，所有处理函数形式上跟委托一致，参数是委托对象的成员变量</p><p>一个事件可以注册多个处理函数，于是事件也称为多重委托</p><h2 id="WPF客户端">WPF客户端</h2><p>WPF客户端的入口是一个继承了<code>Application</code>的类，通常是<code>App.xaml</code>和<code>App.xaml.cs</code></p><h3 id="App-xaml">App.xaml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Application</span> <span class="attr">x:Class</span>=<span class="string">&quot;WpfApp1.App&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:x</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:local</span>=<span class="string">&quot;clr-namespace:WpfApp1&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">StartupUri</span>=<span class="string">&quot;MainWindow.xaml&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--定义全局的资源、样式、主题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若<code>App.xaml</code>中配置了<code>StartupUri=&quot;MainWindow.xaml&quot;</code>，程序开始时打开窗口<code>MainWindow.xaml</code></p><h3 id="App-xaml-cs">App.xaml.cs</h3><p><code>App.xaml.cs</code>内定义了一个类<code>App</code>，这个类继承自<code>Application</code></p><p>可以重载函数，以控制程序开始、结束时的行为</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WpfApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStartup</span>(<span class="params">StartupEventArgs e</span>)</span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params">ExitEventArgs e</span>)</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如<code>App.xaml</code>中不配置<code>StartupUri</code>，也可以在此手动创建窗口</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStartup</span>(<span class="params">StartupEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnStartup(e);</span><br><span class="line">        <span class="built_in">string</span>[] commandLineArgs = e.Args;</span><br><span class="line">        <span class="comment">// parser commandLineArgs</span></span><br><span class="line">        MainWindow mainWindow = <span class="keyword">new</span> MainWindow();</span><br><span class="line">        mainWindow.Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行WPF项目">运行WPF项目</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> exePath = <span class="string">&quot;WpfApp1.exe&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> arguments = <span class="string">&quot;/param1 value1 /param2 value2&quot;</span>;</span><br><span class="line">ProcessStartInfo startInfo = <span class="keyword">new</span> ProcessStartInfo</span><br><span class="line">&#123;</span><br><span class="line">    FileName = exePath,</span><br><span class="line">    Arguments = arguments,</span><br><span class="line">    UseShellExecute = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">Process.Start(startInfo);</span><br></pre></td></tr></table></figure><h2 id="Binding">Binding</h2><h3 id="逻辑层与UI层">逻辑层与UI层</h3><p>程序 = 数据 + 算法</p><p>三层结构：存储、逻辑、展示（UI）</p><p>逻辑层可以访问UI层的数据，但展示层不能访问逻辑层，UI层能显示信息，靠的是绑定逻辑层数据</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.textBoxName.SetBinding(TextBox.TextProperty, <span class="keyword">new</span> Binding(<span class="string">&quot;Name&quot;</span>) &#123; Source = stu = <span class="keyword">new</span> Student() &#125;);</span><br></pre></td></tr></table></figure><p>UI层不仅可以绑定逻辑层数据，也可以绑定UI层数据</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为 Text属性设置 Binding为 slider1的...</span></span><br><span class="line">&lt;TextBox x:Name=<span class="string">&quot;textBox2&quot;</span> Text=<span class="string">&quot;&#123;Binding Value, ElementName=slider1&#125;&quot;</span> BorderBrush=<span class="string">&quot;Black&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>在XAML中加入</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">xmlns:local=<span class="string">&quot;clr-namespace:BindingStudy&quot;</span></span><br></pre></td></tr></table></figure><p>即可在XAML中使用BindingStudy命名空间里C#定义的类</p><h3 id="绑定的实现">绑定的实现</h3><p>绑定实现的机制：源对象的属性（Property）发生改变时，会Invoke一个事件，Binding负责侦听这个事件</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">INotifyPropertyChanged</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.PropertyChanged != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.PropertyChanged.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Path">Path</h3><p>源对象往往会有多个属性，我们可以使用Path，设置绑定那些属性，而且Path支持多级路径（简单说就是一直点下去）和索引器（Indexer）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;TextBox x:Name=<span class="string">&quot;textBoxName&quot;</span> BorderBrush=<span class="string">&quot;Black&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br><span class="line">&lt;TextBox x:Name=<span class="string">&quot;textBox1&quot;</span> Text=<span class="string">&quot;&#123;Binding Path=Text.Length, ElementName=textBoxName, Mode=OneWay&#125;&quot;</span> BorderBrush=<span class="string">&quot;Black&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;          </span><br><span class="line">&lt;TextBox x:Name=<span class="string">&quot;textBox2&quot;</span> Text=<span class="string">&quot;&#123;Binding Path=Text.[3], ElementName=textBoxName, Mode=OneWay&#125;&quot;</span> BorderBrush=<span class="string">&quot;Black&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/Path.png" class="lazyload" data-srcset="/images/Path.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Path"></p><p>此外Path也支持多级斜线（也是可以一直斜线下去，其中&quot;/&quot;就是自身）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.textBoxName.SetBinding(TextBox.TextProperty, <span class="keyword">new</span> Binding(<span class="string">&quot;/Length&quot;</span>) &#123; Source = stringList &#125;);</span><br></pre></td></tr></table></figure><p>当源数据本身就是数据（比如int、string类型），我们可以不写Path，或者将Path省略为&quot;.&quot;</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.textBlock1.SetBinding(TextBlock.TextProperty, <span class="keyword">new</span> Binding(<span class="string">&quot;.&quot;</span>) &#123; Source = str &#125;);</span><br></pre></td></tr></table></figure><h3 id="集合">集合</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">StackPanel</span> <span class="attr">x:Name</span>=<span class="string">&quot;stackPanel&quot;</span> <span class="attr">Background</span>=<span class="string">&quot;LightBlue&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;Student ID:&quot;</span> <span class="attr">FontWeight</span>=<span class="string">&quot;Bold&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBox</span> <span class="attr">x:Name</span>=<span class="string">&quot;textBoxId&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;Student List:&quot;</span> <span class="attr">FontWeight</span>=<span class="string">&quot;Bold&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListBox</span> <span class="attr">x:Name</span>=<span class="string">&quot;listBoxStudents&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;110&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ListBox.ItemTemplate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">StackPanel</span> <span class="attr">Orientation</span>=<span class="string">&quot;Horizontal&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Path=Id&#125;&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Path=Name&#125;&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;60&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Path=Age&#125;&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ListBox.ItemTemplate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ListBox</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">public MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    List<span class="tag">&lt;<span class="name">Student</span>&gt;</span> stuList = new List<span class="tag">&lt;<span class="name">Student</span>&gt;</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        new Student()&#123;Id=0, Name=&quot;赵&quot;, Age=21&#125;,</span><br><span class="line">        new Student()&#123;Id=1, Name=&quot;钱&quot;, Age=22&#125;,</span><br><span class="line">        new Student()&#123;Id=2, Name=&quot;孙&quot;, Age=11&#125;,</span><br><span class="line">        new Student()&#123;Id=3, Name=&quot;李&quot;, Age=50&#125;,</span><br><span class="line">        new Student()&#123;Id=4, Name=&quot;周&quot;, Age=44&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    this.listBoxStudents.ItemsSource = stuList;</span><br><span class="line">    //this.listBoxStudents.DisplayMemberPath = &quot;Name&quot;;</span><br><span class="line"></span><br><span class="line">    Binding binding = new Binding(&quot;SelectedItem.Id&quot;) &#123; Source = this.listBoxStudents &#125;;</span><br><span class="line">    this.textBoxId.SetBinding(TextBox.TextProperty, binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E9%9B%86%E5%90%88.png" class="lazyload" data-srcset="/images/%E9%9B%86%E5%90%88.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="集合"></p><h3 id="XML">XML</h3><p>SOAP（Simple Object Access Protocel，简单对象访问协议）：一种基于XML的数据交换协议</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">StudentList</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Name</span>&gt;</span>赵<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Name</span>&gt;</span>钱<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Name</span>&gt;</span>孙<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Name</span>&gt;</span>李<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Name</span>&gt;</span>周<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">StudentList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ListView</span> <span class="attr">x:Name</span>=<span class="string">&quot;listViewStudents&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;130&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView.View</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">GridView</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">GridViewColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Id&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;80&quot;</span> <span class="attr">DisplayMemberBinding</span>=<span class="string">&quot;&#123;Binding XPath=@Id&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">GridViewColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Name&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;120&quot;</span> <span class="attr">DisplayMemberBinding</span>=<span class="string">&quot;&#123;Binding XPath=Name&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">GridView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ListView.View</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">Content</span>=<span class="string">&quot;Load Click&quot;</span> <span class="attr">Click</span>=<span class="string">&quot;Button_Click&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;25&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5,0&quot;</span>/&gt;</span></span><br><span class="line"> private void Button_Click(object sender, RoutedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    XmlDataProvider xdp = new XmlDataProvider();</span><br><span class="line">    xdp.Source = new Uri(@&quot;D:\code\BindingStudy\BindingStudy\RawData.xml&quot;);</span><br><span class="line">    xdp.XPath = @&quot;/StudentList/Student&quot;;</span><br><span class="line"></span><br><span class="line">    this.listViewStudents.DataContext = xdp;</span><br><span class="line">    this.listViewStudents.SetBinding(ListView.ItemsSourceProperty, new Binding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/xml.png" class="lazyload" data-srcset="/images/xml.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="xml"></p><h3 id="LINQ">LINQ</h3><p>LINQ（Language-Integrated Query，语言集成查询）：一种对象查询机制，查询的结果为IEnumerable<T>类型</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">StudentList</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Class</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;0&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Tim&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;29&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Tom&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Mess&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;9&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Class</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Tony&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;4&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Viv&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;5&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Oio&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;88&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">StudentList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ListView</span> <span class="attr">x:Name</span>=<span class="string">&quot;listViewStudents&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;130&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView.View</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">GridView</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">GridViewColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Id&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;80&quot;</span> <span class="attr">DisplayMemberBinding</span>=<span class="string">&quot;&#123;Binding Id&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">GridViewColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Name&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;120&quot;</span> <span class="attr">DisplayMemberBinding</span>=<span class="string">&quot;&#123;Binding Name&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">GridViewColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Age&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;80&quot;</span> <span class="attr">DisplayMemberBinding</span>=<span class="string">&quot;&#123;Binding Age&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">GridView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ListView.View</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></span><br><span class="line">private void Button_Click(object sender, RoutedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    XDocument doc = XDocument.Load(@&quot;D:\code\BindingStudy\BindingStudy\RawData.xml&quot;);</span><br><span class="line">    this.listViewStudents.ItemsSource =</span><br><span class="line">        from element in doc.Descendants(&quot;Student&quot;)</span><br><span class="line">        where element.Attribute(&quot;Name&quot;).Value.StartsWith(&quot;T&quot;)</span><br><span class="line">        select new Student()</span><br><span class="line">        &#123;</span><br><span class="line">            Id = int.Parse(element.Attribute(&quot;Id&quot;).Value),</span><br><span class="line">            Name = element.Attribute(&quot;Name&quot;).Value,</span><br><span class="line">            Age = int.Parse(element.Attribute(&quot;Age&quot;).Value)</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public int Age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/LINQ.png" class="lazyload" data-srcset="/images/LINQ.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="LINQ"></p><h3 id="校验">校验</h3><p>“你永远不能相信来自前端的数据”</p><p>我们认为Source的数据一定是正确的，但Target的数据是有可能出现问题的</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        Binding binding = <span class="keyword">new</span> Binding(<span class="string">&quot;Value&quot;</span>) &#123; Source = <span class="keyword">this</span>.slider1 &#125;;</span><br><span class="line">        binding.UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged;    <span class="comment">//当源数据改变时进行校验</span></span><br><span class="line">        RangeValidationRule rvr = <span class="keyword">new</span> RangeValidationRule();</span><br><span class="line">        rvr.ValidatesOnTargetUpdated = <span class="literal">true</span>;    <span class="comment">//当Target数据改变时进行校验</span></span><br><span class="line">        binding.ValidationRules.Add(rvr);</span><br><span class="line">        binding.NotifyOnValidationError = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.textBox1.SetBinding(TextBox.TextProperty, binding);</span><br><span class="line">        <span class="keyword">this</span>.textBox1.AddHandler(Validation.ErrorEvent, <span class="keyword">new</span> RoutedEventHandler(<span class="keyword">this</span>.ValidationError));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若校验失败，将失败信息添加到 ToolTip上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ValidationError</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Validation.GetErrors(<span class="keyword">this</span>.textBox1).Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.textBox1.ToolTip = Validation.GetErrors(<span class="keyword">this</span>.textBox1)[<span class="number">0</span>].ErrorContent.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.textBox1.ToolTip = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;StackPanel x:Name=<span class="string">&quot;stackPanel&quot;</span> Background=<span class="string">&quot;LightBlue&quot;</span>&gt;</span><br><span class="line">    &lt;TextBox x:Name=<span class="string">&quot;textBox1&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br><span class="line">    &lt;Slider x:Name=<span class="string">&quot;slider1&quot;</span> Minimum=<span class="string">&quot;-10&quot;</span> Maximum=<span class="string">&quot;110&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">RangeValidationRule</span> : <span class="title">ValidationRule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对数据范围进行校验，仅当在[0,100]时校验通过，校验失败时返回信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ValidationResult <span class="title">Validate</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, CultureInfo cultureInfo</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">double</span>.TryParse(<span class="keyword">value</span>.ToString(), <span class="keyword">out</span> d))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d &gt;= <span class="number">0</span> &amp;&amp; d &lt;= <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ValidationResult(<span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValidationResult(<span class="literal">false</span>, <span class="string">&quot;Validation Failed!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%A0%A1%E9%AA%8C.png" class="lazyload" data-srcset="/images/%E6%A0%A1%E9%AA%8C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="校验"></p><h3 id="数据转换">数据转换</h3><p>Slider的Value是double类型，TextBox的Text是string类型，但是Binding后数据往来自如，是因为数据转化机制</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ClassAToClassBConverter</span> : <span class="title">IValueConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Convert</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">ConvertBack</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;Window x:Class=<span class="string">&quot;BindingStudy.MainWindow&quot;</span></span><br><span class="line">        ...</span><br><span class="line">    &lt;Window.Resources&gt;</span><br><span class="line">        &lt;local:ClassAToClassBConverter x:Key=<span class="string">&quot;atb&quot;</span>/&gt;</span><br><span class="line">    &lt;/Window.Resources&gt;</span><br><span class="line">    &lt;StackPanel x:Name=<span class="string">&quot;stackPanel&quot;</span> Background=<span class="string">&quot;LightBlue&quot;</span>&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;../../images Width=<span class="string">&quot;20&quot;</span> Height=<span class="string">&quot;20&quot;</span> Source=<span class="string">&quot;&#123;Binding Path=A, Converter=&#123;StaticResource atb&#125;&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/StackPanel&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><h2 id="属性">属性</h2><h3 id="英语中的属性">英语中的属性</h3><p>Property是物体自带的属性</p><p>Attribute是物体的描述属性</p><p>张三是中国人，身上有一百块钱。中国人是张三的Attribute, 100块钱是张三的property</p><h3 id="C-中的属性">C#中的属性</h3><p>将字段设为private，使用一对非private的方法来包装它，以实现<strong>高内聚</strong></p><p>C#中提供语法糖，将Get和Set合并为了属性（Property），这种属性也被称为CLR（Common Language Runtime）属性</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外反编译后发现，属性的本质是两个函数，并不会增加字段数量（不额外占内存）</p><h3 id="依赖属性">依赖属性</h3><p>（WPF属性加强版）</p><p>依赖属性（Dependency Property）可以自己没有值，通过Binding从数据源获得值</p><p>拥有依赖属性的对象被称为依赖对象</p><p>传统开发中，对象所占用的内存在进行实例化时就确定（分配）了，而依赖属性可以允许对象不分配部分空间</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//依赖对象的 CLR封装</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="built_in">string</span>)GetValue(NameProperty); &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; SetValue(NameProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//依赖对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty NameProperty = DependencyProperty.Register(<span class="string">&quot;Name&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Student));  </span><br><span class="line">    <span class="comment">//Binding封装</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BindingExpressionBase <span class="title">SetBinding</span>(<span class="params">DependencyProperty dp, BindingBase binding</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingOperations.SetBinding(<span class="keyword">this</span>, dp, binding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>“Name”：指明使用哪一个 CLR属性作为这个依赖属性的包装器 (Wrapper)</li><li>typeof(string)：指明此依赖属性用来储存什么类型的值</li><li>typeof(Student))：指明此依赖属性要注册关联到谁身上</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">StackPanel</span> <span class="attr">x:Name</span>=<span class="string">&quot;stackPanel&quot;</span> <span class="attr">Background</span>=<span class="string">&quot;LightBlue&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBox</span> <span class="attr">x:Name</span>=<span class="string">&quot;textBox1&quot;</span> <span class="attr">BorderBrush</span>=<span class="string">&quot;Black&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBox</span> <span class="attr">x:Name</span>=<span class="string">&quot;textBox2&quot;</span> <span class="attr">BorderBrush</span>=<span class="string">&quot;Black&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">public partial class MainWindow : Window</span><br><span class="line">&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    public MainWindow()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        stu = new Student();</span><br><span class="line">        stu.SetBinding(Student.NameProperty, new Binding(&quot;Text&quot;) &#123; Source = textBox1 &#125;);</span><br><span class="line">        textBox2.SetBinding(TextBox.TextProperty, new Binding(&quot;Name&quot;) &#123; Source = stu &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还发现，依赖对象并没有实现INotifyPropertyChanged接口，但是当期值发生改变时，与之相关的Binding对象依然可以得到通知，于是依赖对象是天生的合格源数据</p><p>在VS中，输入propdp并按两次tab，就能得到一个依赖属性模板</p><h4 id="依赖属性的注册">依赖属性的注册</h4><p>前文我们获得依赖对象的实例时，是通过<code>DependencyProperty.Register</code>注册得到：</p><ol><li>创建DependencyProperty实例，并使用其CLR属性名的哈希异或宿主类型的哈希，得到key（通过其他算法，保证唯一）</li><li>将key和实例存储到一张全局的HashTable上</li></ol><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GlobalIndex = CLR属性名的HaseCode XOR 宿主类型HashCode</span><br></pre></td></tr></table></figure><p>于是运行时只要知道CLR属性名和宿主，就能找到依赖对象实例</p><h4 id="依赖属性的读写">依赖属性的读写</h4><p>依赖属性对象的作用是检索真正的属性值，而非存储属性值</p><p>每个DependencyObject实例都自带一个数组，当某个依赖属性的值要被读取时，算法会在这个数组中检索。而用于检索的键值，实际上就是依赖属性的GlobalIndex</p><p>也就是说，这个被static readonly修饰的属性，它的作用是一个“标记”，当你需要找某个东西时，就来这里拼一个id，用id查数组</p><h3 id="附加属性">附加属性</h3><p>附加属性（Attached Properties）：一个属性本不属于某个对象，但由于某种需求后来附加上。换句话说，将对象放入一个特定环境后，才会具有出来的属性</p><p>举个例子，比如Human这个类，它可以有很多很多种属性，现在我们想在里面加入一个新的需求，如果我们直接改动这个类，过于繁琐。而如果提前留好空，那么有时候又会空间浪费</p><p>附加属性的作用就是让宿主和属性解耦，让宿主的设计更为灵活</p><h2 id="事件-2">事件</h2><h3 id="消息">消息</h3><p>事件的前身是消息（Message），Windows系统就是一个消息驱动的操作系统，后来微软为了降低开发难度，将消息系统封装为了事件模型</p><h3 id="CLR事件模型">CLR事件模型</h3><p>CLR事件模型由三部分组成</p><ul><li>事件的拥有者：即消息的发送者</li><li>事件的响应者：即消息的接收者，它可以使用事件处理器（Event Handler）对事件做相应</li><li>事件的订阅关系：事件的拥有者可以随时激发事件，但只有关注（订阅）了这个事件的响应者会对此产生反应</li></ul><p>事件本质上就是一个使用event关键字修饰的委托（Delegate）类型成员变量，事件处理器是一个函数</p><p>A订阅了B，实际上就是让B.Event和A.EventHandler关联起来</p><p>事件激发就是B.Event被调用</p><h4 id="举例">举例</h4><p>Windows Form按按钮</p><table><thead><tr><th>事件的拥有者</th><th>button</th></tr></thead><tbody><tr><td>事件</td><td>button.Click</td></tr><tr><td>事件的响应者</td><td>窗体</td></tr><tr><td>事件处理器</td><td>this.button_Click()</td></tr><tr><td>订阅关系</td><td>this.button.Click += new System.EventHandler(this.button_Click)</td></tr></tbody></table><h3 id="路由事件">路由事件</h3><p>（WPF事件加强版）</p><p>路由事件没有显示订阅关系</p><ul><li>事件拥有者只负责激发事件，至于谁会倾听，他并不知道</li><li>事件响应者装有事件倾听器，若有事件传递于此，可以决定事件是否可以继续传递<ul><li>如果事件不归他管，那就踢给下一个人，继续传播</li><li>若事件归他管，那就进行处理，并判断是否还需要传给下一个人</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ButtonBase</span> : <span class="title">ContentControl</span>, <span class="title">ICommandSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明并注册路由事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> RoutedEvent ClickEvent = EventManager.RegisterRoutedEvent(<span class="string">&quot;Click&quot;</span>, </span><br><span class="line">        RoutingStrategy.Bubble, <span class="keyword">typeof</span>(RoutedEventHandler), <span class="keyword">typeof</span>(ButtonBase));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为路由事件添加 CLR事件包装器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> RoutedEventHandler Click</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">add</span> &#123; <span class="keyword">this</span>.AddHandler(ClickEvent, <span class="keyword">value</span>); &#125;</span><br><span class="line">        <span class="keyword">remove</span> &#123; <span class="keyword">this</span>.RemoveHandler(ClickEvent, <span class="keyword">value</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//激活路由事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        RoutedEventArgs newEvent = <span class="keyword">new</span> RoutedEventArgs(ButtonBase.ClickEvent, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.RaiseEvent(newEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WPF路由事件有三种策略</p><ul><li>Bubble：冒泡式，激发者向其上级一层一层路由，直到到根，路径是确定且唯一</li><li>Tunnel：隧道式，激发者向其下级一层一层路由，路径有很多，但朝向响应者移动，就像形成一个隧道</li><li>Direct：直达式，类似CLR事件，直接向响应者发送事件</li></ul><h2 id="命令">命令</h2><p>事件不具有约束力，事件接收者使用自己的行为响应事件</p><p>命令具有约束力，当命令到达某个组件时，会主动调用组件的某个方法</p><h3 id="命令系统">命令系统</h3><ul><li>命令（Command）：实现ICommand接口</li><li>命令源（Command Source）：实现ICommandSource接口</li><li>命令目标（Command Target）：实现IInputElement接口</li><li>命令关联（Command Binding）</li></ul><h2 id="其他功能">其他功能</h2><h3 id="获取当前应用程序域的基础目录">获取当前应用程序域的基础目录</h3><blockquote><p>获得.exe文件所在的文件夹目录</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> path = System.AppDomain.CurrentDomain.BaseDirectory；</span><br></pre></td></tr></table></figure><h3 id="动态加载程序集">动态加载程序集</h3><blockquote><p>加载一个C# DLL文件，然后就可以使用反射来调用API</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个库项目，将被构建为 MathUtils.DLL</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MathUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MathUtils</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载DLL</span></span><br><span class="line"><span class="built_in">string</span> dllPath = <span class="string">&quot;MathUtils.dll&quot;</span>;</span><br><span class="line"><span class="built_in">byte</span>[] buffer = File.ReadAllBytes(dllPath);</span><br><span class="line">Assembly assembly = Assembly.Load(buffer);</span><br><span class="line"><span class="comment">// 获得类型</span></span><br><span class="line">Type mathType = assembly.GetType(<span class="string">&quot;MathUtils.MathUtils&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(mathType != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得方法</span></span><br><span class="line">    MethodInfo method = mathType.GetMethod(<span class="string">&quot;Add&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (method != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行函数</span></span><br><span class="line">        <span class="built_in">object</span>[] parameters = <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="built_in">object</span> result = method.Invoke(<span class="literal">null</span>, parameters);</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Activator">Activator</h3><p>这是一个动态创建对象实例的类型，可以实现泛型</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FirstName = firstName;</span><br><span class="line">        LastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;FirstName&#125;</span> <span class="subst">&#123;LastName&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于 Activator的泛型工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">CreateInstance</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">object</span>[] constructorArgs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 Activator.CreateInstance 创建泛型类型的实例</span></span><br><span class="line">            <span class="keyword">return</span> (T)Activator.CreateInstance(<span class="keyword">typeof</span>(T), constructorArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Failed to create instance: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">default</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用样例</span></span><br><span class="line">ObjectFactory&lt;Person&gt; personFactory = <span class="keyword">new</span> ObjectFactory&lt;Person&gt;();</span><br><span class="line">Person person = personFactory.CreateInstance(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line">person.DisplayInfo();</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的时，C#的泛型类型也是在编译期确定的（与C++相同），这样可以提供编译检查等功能</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pro-TBB</title>
      <link href="/program/Pro-TBB/"/>
      <url>/program/Pro-TBB/</url>
      
        <content type="html"><![CDATA[<h1>Pro TBB</h1><p>在摩尔定律逐渐失效的今日，CPU主频和单核性能提升越来越不明显，为了得到跟高的性能，我们走向了并行计算的道路</p><h2 id="概念">概念</h2><h3 id="并发和并行">并发和并行</h3><ul><li><p>并发（Concurrent）：happening during the same time span，处理器在两件事间快速切换，宏观上看，就像是同时发生的（下图AB）</p></li><li><p>并行（Parallel）：happening at the same time，多个处理器一起做事（下图CD）</p></li></ul><p><img src="Image/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C.png" class="lazyload" data-srcset="Image/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="并发和并行"></p><h2 id="TBB基础">TBB基础</h2><p>TBB（Threading Building Blocks）是一个非常流行的C++并行编程（parallel programming）方案</p><ul><li><p>使用Task而非Thread</p><ul><li>Thread与硬件相关，直接编写难以跨平台，而且线程间通信过于频繁，过于繁琐</li><li>TBB使用Task编程，运行时会将程序映射到硬件上（该方法对嵌套并行的支持很不错）</li><li>TBB任务调度使用<strong>工作窃取</strong>，当一个任务队列执行完毕后，核心会去其他任务队列中窃取任务，于是可以提高核心的利用率</li></ul></li><li><p>TBB实现了可组合性（Composability）</p><ul><li>简单来说就是支持for循环</li></ul></li><li><p>方便移植（portable）</p></li></ul><h3 id="Mac上安装使用TBB">Mac上安装使用TBB</h3><ol><li>安装tbb</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$brew</span> install tbb</span><br></pre></td></tr></table></figure><ol start="2"><li>链接tbb</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#寻找tbb包</span></span><br><span class="line"><span class="keyword">find_package</span>(TBB REQUIRED)</span><br><span class="line">...</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(TimeStudy TBB::tbb)</span><br></pre></td></tr></table></figure><ol start="3"><li>引用头文件</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="在Ubuntu上安装TBB">在Ubuntu上安装TBB</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> apt-get install libtbb-dev</span><br></pre></td></tr></table></figure><h3 id="调用函数">调用函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func0, [...,] <span class="keyword">typename</span> FuncN&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_invoke</span><span class="params">(<span class="type">const</span> Func0&amp; f0, [...,] <span class="type">const</span> FuncN&amp; fN)</span></span>;</span><br></pre></td></tr></table></figure><p>一个简单的TBB示例，并行输出两行字符串</p><p>通过<code>tbb::parallel_invoke</code>实现任务、函数粒度的并行</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_invoke</span>(</span><br><span class="line">            []()&#123;std::cout &lt;&lt; <span class="string">&quot;TBB!&quot;</span> &lt;&lt; std::endl;&#125;,</span><br><span class="line">            []()&#123;std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里使用lambda表达式创建了匿名（anonymous）函数，可以大幅简化TBB编写</p><h4 id="快排示例">快排示例</h4><p>传统快排算法（升序）</p><ol><li>在数列中取一个数作为基准数</li><li>比基准小的放在基准左边，大的放在右边</li><li>对左右两边分别快排，直到只剩一个数（左右重合）</li></ol><p>能看出，这个算法采用了分治的思想，很适合并行</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> QV = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="comment">//传统快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(QV::iterator left, QV::iterator right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="type">int</span> pivot_value = *left;</span><br><span class="line">    QV::iterator i = left, j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i != j &amp;&amp; pivot_value &lt; *j) --j;    <span class="comment">//从右向左找，直到找到一个比基准小的</span></span><br><span class="line">        <span class="keyword">while</span>(i != j &amp;&amp; pivot_value &gt;= *i) ++i;   <span class="comment">//从左往右找，直到找到一个比基准大的</span></span><br><span class="line">        std::<span class="built_in">iter_swap</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">iter_swap</span>(left, i);</span><br><span class="line">    <span class="built_in">quickSort</span>(left, i);</span><br><span class="line">    <span class="built_in">quickSort</span>(j+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并行快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallelQuicksort</span><span class="params">(QV::iterator left, QV::iterator right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="type">int</span> pivot_value =  *left;</span><br><span class="line">    QV::iterator i = left, j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i != j &amp;&amp; pivot_value &lt; *j) --j;</span><br><span class="line">        <span class="keyword">while</span> (i != j &amp;&amp; pivot_value &gt;= *i) ++i;</span><br><span class="line">        std::<span class="built_in">iter_swap</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">iter_swap</span>(left, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call</span></span><br><span class="line">    tbb::<span class="built_in">parallel_invoke</span>(</span><br><span class="line">      <span class="comment">//lambda表达式[=]表示传入当前函数所有的成员</span></span><br><span class="line">            [=]() &#123; <span class="built_in">parallelQuicksort</span>(left, i); &#125;,</span><br><span class="line">            [=]() &#123; <span class="built_in">parallelQuicksort</span>(i + <span class="number">1</span>, right); &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用cutoff</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallelCutoffQuicksort</span><span class="params">(QV::iterator left, QV::iterator right)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cutoff = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; cutoff) &#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(right, left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> pivot_value =  *left;</span><br><span class="line">        QV::iterator i = left, j = right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i != j &amp;&amp; pivot_value &lt; *j) --j;</span><br><span class="line">            <span class="keyword">while</span> (i != j &amp;&amp; pivot_value &gt;= *i) ++i;</span><br><span class="line">            std::<span class="built_in">iter_swap</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">iter_swap</span>(left, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call</span></span><br><span class="line">        tbb::<span class="built_in">parallel_invoke</span>(</span><br><span class="line">                [=]() &#123; <span class="built_in">parallelQuicksort</span>(left, i); &#125;,</span><br><span class="line">                [=]() &#123; <span class="built_in">parallelQuicksort</span>(i + <span class="number">1</span>, right); &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; ++i)&#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//warmup</span></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="number">10</span>, [](<span class="type">int</span>) &#123;</span><br><span class="line">        tbb::tick_count t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">while</span> ((tbb::tick_count::<span class="built_in">now</span>() - t0).<span class="built_in">seconds</span>() &lt; <span class="number">0.01</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums2 = nums;</span><br><span class="line">    tbb::tick_count t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Normal Time=&quot;</span> &lt;&lt; (tbb::tick_count::<span class="built_in">now</span>() - t0).<span class="built_in">seconds</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    tbb::tick_count t1 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">parallelQuicksort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Parallel Time=&quot;</span> &lt;&lt; (tbb::tick_count::<span class="built_in">now</span>() - t1).<span class="built_in">seconds</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果，当数组比较大的时候，并行快排速度会更快一点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Normal Time=0.0023285</span><br><span class="line">Parallel Time=0.00110846</span><br></pre></td></tr></table></figure><p>此外tbb进行任务分配也会有开销，因此我们往往将大任务分成若干个小任务后，让小任务串型执行，上文中的cutoff就是起到这个作用，这样往往能得到更高的性能</p><h3 id="时刻查询">时刻查询</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//t0时刻</span></span><br><span class="line">tbb::tick_count t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//当前时刻-t0时刻=经过了多长时间段（并转化为秒）</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; (tbb::tick_count::<span class="built_in">now</span>() - t0).<span class="built_in">seconds</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>并行开发中动态内存管理十分复杂、危险（内存泄漏），这里推荐使用C++11的智能指针（自带GC）</p><h3 id="Flow-Graph">Flow Graph</h3><p>将函数执行制作成Graph，实现消息驱动的并行（有些类似FrameGraph）</p><p><img src="Image/FlowGraph.jpeg" class="lazyload" data-srcset="Image/FlowGraph.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="FlowGraph"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fig1_10</span><span class="params">(<span class="type">const</span> std::vector&lt;ImagePtr&gt;&amp; image_vector)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> tint_array[] = &#123;<span class="number">0.75</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    tbb::flow::graph g;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意，source_node已经失效</span></span><br><span class="line">    tbb::<span class="function">flow::input_node&lt;ImagePtr&gt; <span class="title">src</span><span class="params">(g,</span></span></span><br><span class="line"><span class="params"><span class="function">        [&amp;i, &amp;image_vector](tbb::flow_control &amp;fc) -&gt; ImagePtr &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span>(i &lt; image_vector.size())&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> image_vector[i++];</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">else</span>&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                fc.stop();</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> &#123;&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    tbb::<span class="function">flow::function_node&lt;ImagePtr, ImagePtr&gt; <span class="title">gamma</span><span class="params">(g,</span></span></span><br><span class="line"><span class="params"><span class="function">        tbb::flow::unlimited, [] (ImagePtr img) -&gt; ImagePtr&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> applyGamma(img, <span class="number">1.4</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    tbb::<span class="function">flow::function_node&lt;ImagePtr, ImagePtr&gt; <span class="title">tint</span><span class="params">(g,</span></span></span><br><span class="line"><span class="params"><span class="function">        tbb::flow::unlimited, [tint_array] (ImagePtr img) -&gt; ImagePtr&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> applyTint(img, tint_array);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    tbb::<span class="function">flow::function_node&lt;ImagePtr&gt; <span class="title">write</span><span class="params">(g,</span></span></span><br><span class="line"><span class="params"><span class="function">         tbb::flow::unlimited, [] (ImagePtr img)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                writeImage(img);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line">    tbb::flow::<span class="built_in">make_edge</span>(src, gamma);</span><br><span class="line">    tbb::flow::<span class="built_in">make_edge</span>(gamma, tint);</span><br><span class="line">    tbb::flow::<span class="built_in">make_edge</span>(tint, write);</span><br><span class="line">    src.<span class="built_in">activate</span>();</span><br><span class="line">    g.<span class="built_in">wait_for_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后该程序会以<strong>流水线</strong>的形式执行，当第一张图片完成gamma矫正，去执行tint着色时，第二张图片开始执行gamma矫正（每张图片间互不影响）</p><p>相比于TimeStudy的串型执行，流水线执行效率会更快</p><h3 id="循环">循环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Index, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">Func <span class="title">parallel_for</span><span class="params">(Index frist, Index last, [Index step,] <span class="type">const</span> Func&amp; f)</span></span>;</span><br></pre></td></tr></table></figure><p>上面的代码，我们将图片处理切分为几个小块，但小块内部仍然是单线程</p><p>我们注意到，在图片处理时，有一个很大的循环在遍历图片上的像素点，那么能不能并行做这件事？</p><p>我们并行处理每一行</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, height,</span><br><span class="line">                  [&amp;in_rows, &amp;out_rows, width, gamma](<span class="type">int</span> i)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; ++j)&#123;</span><br><span class="line">                      <span class="type">const</span> ImageLib::Image::Pixel&amp; p = in_rows[i][j];</span><br><span class="line">                      <span class="type">double</span> v = <span class="number">0.3</span> * p.bgra[<span class="number">2</span>] + <span class="number">0.59</span> * p.bgra[<span class="number">1</span>] + <span class="number">0.11</span> * p.bgra[<span class="number">0</span>];</span><br><span class="line">                      <span class="type">double</span> res = <span class="built_in">pow</span>(v, gamma);</span><br><span class="line">                      <span class="keyword">if</span>(res &gt; ImageLib::MAX_BGR_VALUE)&#123;</span><br><span class="line">                        res = ImageLib::MAX_BGR_VALUE;</span><br><span class="line">                      &#125;</span><br><span class="line">                      out_rows[i][j] = ImageLib::Image::<span class="built_in">Pixel</span>(res, res, res);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                 );</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, height,</span><br><span class="line">                  [&amp;in_rows, &amp;out_rows, width, tints](<span class="type">int</span> i)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; ++j)&#123;</span><br><span class="line">                      <span class="type">const</span> ImageLib::Image::Pixel&amp; p = in_rows[i][j];</span><br><span class="line">                      std::<span class="type">uint8_t</span> b = (<span class="type">double</span>)p.bgra[<span class="number">0</span>] + (ImageLib::MAX_BGR_VALUE - p.bgra[<span class="number">0</span>]) * tints[<span class="number">0</span>];</span><br><span class="line">                      std::<span class="type">uint8_t</span> g = (<span class="type">double</span>)p.bgra[<span class="number">0</span>] + (ImageLib::MAX_BGR_VALUE - p.bgra[<span class="number">1</span>]) * tints[<span class="number">1</span>];</span><br><span class="line">                      std::<span class="type">uint8_t</span> r = (<span class="type">double</span>)p.bgra[<span class="number">0</span>] + (ImageLib::MAX_BGR_VALUE - p.bgra[<span class="number">2</span>]) * tints[<span class="number">2</span>];</span><br><span class="line">                      out_rows[i][j] = ImageLib::Image::<span class="built_in">Pixel</span>(</span><br><span class="line">                        (b &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : b,</span><br><span class="line">                        (g &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : g,</span><br><span class="line">                        (r &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : r</span><br><span class="line">                      );</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                 );</span><br></pre></td></tr></table></figure><p>M1 Mac Xcode Clang至今不支持C++17的std::execution，对OpenMP的支持也相当差</p><h3 id="归约">归约</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Func, <span class="keyword">typename</span> Reduction&gt;</span></span><br><span class="line"><span class="function">Value <span class="title">parallel_reduce</span><span class="params">(<span class="type">const</span> Range&amp; range, <span class="type">const</span> Value&amp; identity, <span class="type">const</span> Func&amp; func, <span class="type">const</span> Reduction&amp; reduction)</span></span>;</span><br></pre></td></tr></table></figure><p>树形规约</p><img src="Image/树形归并.png" class="lazyload" data-srcset="Image/树形归并.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="树形归并" style="zoom:50%;" /><p><img src="Image/reduce.png" class="lazyload" data-srcset="Image/reduce.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="reduce"></p><h4 id="求最大值">求最大值</h4><p>下面是一个vector求最大值的示例，实现机制就是将整个数组分成一个个小块（chunks），分别对小块求最值，然后将小块归约（reduce），最后求得最值（形成了一个树型结构）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pmax</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> max_value = tbb::<span class="built_in">parallel_reduce</span>(</span><br><span class="line">      <span class="comment">//range，扫描范围</span></span><br><span class="line">            tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, arr.<span class="built_in">size</span>()),</span><br><span class="line">      <span class="comment">//identity，小块数据的初始值，这里赋值为int类型的最小值-2147483648</span></span><br><span class="line">            std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>(),</span><br><span class="line">      <span class="comment">//func，每个小块的处理方式</span></span><br><span class="line">            [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">int</span>&gt; &amp;r, <span class="type">int</span> init) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">                    init = std::<span class="built_in">max</span>(init, arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> init;</span><br><span class="line">            &#125;,</span><br><span class="line">      <span class="comment">//reduction，小块间合并的处理方式</span></span><br><span class="line">            [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">max</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> max_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这是一个求PI的示例</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">calcPI</span><span class="params">(<span class="type">int</span> degree)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = <span class="number">1.0</span> / degree;</span><br><span class="line">    <span class="type">double</span> sum = tbb::<span class="built_in">parallel_reduce</span>(</span><br><span class="line">      <span class="comment">//range，扫描范围</span></span><br><span class="line">            tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, degree),</span><br><span class="line">      <span class="comment">//identity，小块数据的初始值，这里赋值为0</span></span><br><span class="line">            <span class="number">0.0</span>,</span><br><span class="line">      <span class="comment">//func，每个小块的处理方式</span></span><br><span class="line">            [=](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">int</span>&gt; &amp;r, <span class="type">double</span> init) -&gt; <span class="type">double</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">                    <span class="type">double</span> x = (i + <span class="number">0.5</span>)*dx;</span><br><span class="line">                    <span class="type">double</span> h = std::<span class="built_in">sqrt</span>(<span class="number">1</span> - x*x);  <span class="comment">//勾股定理</span></span><br><span class="line">                    init += h * dx;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> init;</span><br><span class="line">            &#125;,</span><br><span class="line">      <span class="comment">//reduction，小块间合并的处理方式</span></span><br><span class="line">            [](<span class="type">double</span> x, <span class="type">double</span> y) -&gt; <span class="type">double</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x+y;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扫描">扫描</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Scan, <span class="keyword">typename</span> Combine&gt;</span></span><br><span class="line"><span class="function">Value <span class="title">parallel_scan</span><span class="params">(<span class="type">const</span> Range&amp; range, <span class="type">const</span> Value&amp; identity, <span class="type">const</span> Scan&amp; scan, <span class="type">const</span> Combine&amp; combine)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="前缀和">前缀和</h4><p><em>前缀和在图形领域也有很大的用处</em></p><p>对于一个数组，我们将其分为三个小块ABC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A.init=0, B.init=0</span><br><span class="line">scan(A), scan(B)</span><br><span class="line"></span><br><span class="line">B.init = A.ans</span><br><span class="line">C.init = A.ans + B.ans</span><br><span class="line">scan(B), scan(C)</span><br></pre></td></tr></table></figure><p>最后我们只用了串行2/3的扫描时间，但是多做了1/3的扫描工作，时间减少了，但是工作量变大了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">parallelPrefix</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;v, std::vector&lt;<span class="type">int</span>&gt; &amp;psum)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N = v.<span class="built_in">size</span>();</span><br><span class="line">    psum[<span class="number">0</span>] = v[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> final_sum = tbb::<span class="built_in">parallel_scan</span>(</span><br><span class="line">      <span class="comment">//range</span></span><br><span class="line">            tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, N),</span><br><span class="line">      <span class="comment">//identity</span></span><br><span class="line">            (<span class="type">int</span>)<span class="number">0</span>,</span><br><span class="line">      <span class="comment">//scan body</span></span><br><span class="line">            [&amp;v, &amp;psum](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">int</span>&gt; &amp;r, <span class="type">int</span> sum, <span class="type">bool</span> is_final_scan) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">                    sum += v[i];</span><br><span class="line">                    <span class="keyword">if</span>(is_final_scan)&#123;</span><br><span class="line">                        psum[i] = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;,</span><br><span class="line">      <span class="comment">//combine body</span></span><br><span class="line">            [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;</span><br><span class="line">                <span class="keyword">return</span> x+y;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> final_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可见性">可见性</h4><p>如图，等间距摆放一个个薄板（厚度忽略不计），从最右上角向左看，能看到哪些薄板？</p><img src="Image/sight.png" class="lazyload" data-srcset="Image/sight.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="sight" style="zoom:50%;" /><p>解题的本质就是比较夹角大小，只要夹角一直递增，就能看到</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">visibility</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;heights, std::vector&lt;<span class="type">bool</span>&gt; &amp; visible, <span class="type">double</span> dx)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">double</span> max_angle = std::<span class="built_in">atan2</span>(dx, heights[<span class="number">0</span>] - heights[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> final_max_angle = tbb::<span class="built_in">parallel_scan</span>(</span><br><span class="line">      <span class="comment">//range</span></span><br><span class="line">            tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, N),</span><br><span class="line">      <span class="comment">//identity</span></span><br><span class="line">            <span class="number">0.0</span>,</span><br><span class="line">      <span class="comment">//scan body</span></span><br><span class="line">            [&amp;heights, &amp;visible, dx](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">int</span>&gt; &amp;r, <span class="type">double</span> max_angle, <span class="type">bool</span> is_final_scan) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">                    <span class="type">double</span> my_angle = <span class="built_in">atan2</span>(i * dx, heights[<span class="number">0</span>] - heights[i]);</span><br><span class="line">                    <span class="keyword">if</span>(my_angle &gt;= max_angle)&#123;</span><br><span class="line">                        max_angle = my_angle;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(is_final_scan)&#123;</span><br><span class="line">                        visible[i] = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> max_angle;</span><br><span class="line">            &#125;,</span><br><span class="line">      <span class="comment">//combine body</span></span><br><span class="line">            [](<span class="type">double</span> a, <span class="type">double</span> b)&#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">max</span>(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parallel-for-each">parallel_for_each</h3><p>parallel_for在使用时必须指定range，但如果要处理的item数量不确定（比如在执行过程中修改itemList），那么就不能使用，这个时候我们可以使用parallel_for_each</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typaname InputIterator, <span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_for_each</span><span class="params">( InputIterator first, InputIterator last, Body body )</span></span>;</span><br></pre></td></tr></table></figure><p>下面是一个遍历树的示例，若一个节点的<code>v.first</code>为prime，将其<code>v.second</code>修改为true。我们不知道树有多大，于是采用递归遍历</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(PrimesTreeElement::Ptr root)</span></span>&#123;</span><br><span class="line">  PrimesTreeElement::Ptr tree_arry[] = &#123;root&#125;;</span><br><span class="line">  <span class="comment">//tbb::parallel_do已经废弃</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(</span><br><span class="line">        tree_array,</span><br><span class="line">        [](PrimesTreeElement::Ptr e, </span><br><span class="line">        <span class="comment">//tbb::parallel_do_feeder已被废弃</span></span><br><span class="line">        tbb::feeder&lt;PrimesTreeElement::Ptr&gt;&amp; feeder)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e)&#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">isPrime</span>(e-&gt;v.first)) e-&gt;v.second = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span>(e-&gt;left) feeder.<span class="built_in">add</span>(e-&gt;left);</span><br><span class="line">          <span class="keyword">if</span>(e-&gt;right) feeder.<span class="built_in">add</span>(e-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;                 </span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前向替换">前向替换</h4><p>前向替换（Forward Substitution）是线性代数中一种求解线性方程组的方法</p><p>一般解线性方程组有两种方法：</p><ul><li>直接法<ul><li>高斯消元法</li><li>LU分解法</li></ul></li><li>迭代法</li></ul><p>高斯消元法：初中就学了，就是两个方程变化后相加减（也可以换元），消除变量，直到得到解。这个方法可以拓展到矩阵中，就是把线性方程转化为行阶梯矩阵（中间那个矩阵），然后简化为简化行阶梯矩阵（右边那个矩阵）</p><p>$$<br>\left[<br>\begin{matrix}<br>2 &amp; 1 &amp; -1 &amp;|&amp; 8\\<br>-3 &amp; -1 &amp; 2 &amp; | &amp; -11 \\<br>-2 &amp; 1 &amp; 2 &amp; | &amp; -3<br>\end{matrix}<br>\right]<br>=&gt;<br>\left[<br>\begin{matrix}<br>2 &amp; 1 &amp; -1 &amp;|&amp; 8\\<br>0 &amp; 1/2 &amp; 1/2 &amp; | &amp; 1 \\<br>0 &amp; 0 &amp; -1 &amp; | &amp; 1<br>\end{matrix}<br>\right]<br>=&gt;<br>\left[<br>\begin{matrix}<br>1 &amp; 0 &amp; 0 &amp;|&amp; 2\\<br>0 &amp; 1 &amp; 0 &amp; | &amp; 3 \\<br>0 &amp; 0 &amp; 1 &amp; | &amp; -1<br>\end{matrix}<br>\right]<br>$$</p><p>前向替换法就是得到行阶梯矩阵后</p><img src="/images/前向替换.png" class="lazyload" data-srcset="/images/前向替换.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="前向替换" style="zoom:50%;" /><p>能写出以下式子</p><p>$$<br>\begin{cases}<br>x_1 = b_1/a_{11} \\<br>x_2 = (b_2-a_{21}x_1)/a_{22}\\<br>\ \vdots\\<br>x_n = (b_n -a_{n1}x_1-a_{n2}x_2 - \cdots -a_{nn-1}x_{n-1})/a_{nm}<br>\end{cases}<br>$$</p><p>于是我们只需要从第一个式子开始，逐步向下替换，就能求出方程的解</p><p><em>如果是下三角矩阵，那就是后向替换</em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a是一个下三角矩阵，x、b是向量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serialFS</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt;&amp; x, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; a, std::vector&lt;<span class="type">double</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            b[i] -= a[j + i*N] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">        x[i] = b[i] / a[i + i*N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入分块和并行后：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallelFS</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt; &amp;x, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;a,</span></span></span><br><span class="line"><span class="params"><span class="function">                std::vector&lt;<span class="type">double</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = x.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> block_size = <span class="number">512</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> num_blocks = N / block_size;</span><br><span class="line">  <span class="comment">//tbb::atomic已经废弃</span></span><br><span class="line">  std::vector&lt;std::atomic&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">ref_count</span>(num_blocks * num_blocks);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; num_blocks; ++r) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= r; ++c) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line">        ref_count[r * num_blocks + c] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span> || r == c)</span><br><span class="line">        ref_count[r * num_blocks + c] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ref_count[r * num_blocks + c] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> BlockIndex = std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt;;</span><br><span class="line">  <span class="function">BlockIndex <span class="title">top_left</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="comment">//tbb::parallel_do已经废弃</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(&amp;top_left, &amp;top_left + <span class="number">1</span>,</span><br><span class="line">                         [&amp;](<span class="type">const</span> BlockIndex &amp;bi, tbb::feeder&lt;BlockIndex&gt; &amp;feeder) &#123;</span><br><span class="line">                           <span class="type">size_t</span> r = bi.first;</span><br><span class="line">                           <span class="type">size_t</span> c = bi.second;</span><br><span class="line">                           <span class="type">int</span> i_start = r * block_size, i_end = i_start + block_size;</span><br><span class="line">                           <span class="type">int</span> j_start = c * block_size, j_max = j_start + block_size - <span class="number">1</span>;</span><br><span class="line">                           <span class="keyword">for</span> (<span class="type">int</span> i = i_start; i &lt; i_end; ++i) &#123;</span><br><span class="line">                             <span class="type">int</span> j_end = (i &lt;= j_max) ? i : j_max + <span class="number">1</span>;</span><br><span class="line">                             <span class="keyword">for</span> (<span class="type">int</span> j = j_start; j &lt; j_end; ++j) &#123;</span><br><span class="line">                               b[i] -= a[j + i * N] * x[j];</span><br><span class="line">                             &#125;</span><br><span class="line">                             <span class="keyword">if</span> (j_end == i) &#123;</span><br><span class="line">                               x[i] = b[i] / a[i + i * N];</span><br><span class="line">                             &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// add successor to right if ready</span></span><br><span class="line">                           <span class="keyword">if</span> (c + <span class="number">1</span> &lt;= r &amp;&amp; --ref_count[r * num_blocks + c + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                             feeder.<span class="built_in">add</span>(<span class="built_in">BlockIndex</span>(r, c + <span class="number">1</span>));</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// add succesor below if ready</span></span><br><span class="line">                           <span class="keyword">if</span> (r + <span class="number">1</span> &lt; (<span class="type">size_t</span>) num_blocks &amp;&amp; --ref_count[(r + <span class="number">1</span>) * num_blocks + c] == <span class="number">0</span>) &#123;</span><br><span class="line">                             feeder.<span class="built_in">add</span>(<span class="built_in">BlockIndex</span>(r + <span class="number">1</span>, c));</span><br><span class="line">                           &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流水线">流水线</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_pipeline</span><span class="params">( <span class="type">size_t</span> max_number_of_live_tokens, <span class="type">const</span> filter&lt;<span class="type">void</span>,<span class="type">void</span>&gt;&amp; filter_chain )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="type">filter_t</span>&lt;T, U&gt; <span class="title">make_filter</span><span class="params">(filter::mode mode, <span class="type">const</span> Func&amp; f)</span></span>;</span><br></pre></td></tr></table></figure><p>管线（pipeline）是过滤器（filters）的线性序列，物体（items）在通过过滤器时，会被处理</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并行 将字符串中大写变小写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fig_2_27</span><span class="params">(<span class="type">int</span> num_tokens, std::ofstream &amp;caseBeforeFile, std::ofstream &amp;caseAfterFile)</span> </span>&#123;</span><br><span class="line">  tbb::<span class="built_in">parallel_pipeline</span>(</span><br><span class="line">    <span class="comment">//tokens</span></span><br><span class="line">    num_tokens,</span><br><span class="line">    <span class="comment">//第一个filter，负责创建字符串</span></span><br><span class="line">    tbb::<span class="built_in">make_filter</span>&lt;<span class="type">void</span>, CaseStringPtr&gt;(</span><br><span class="line">        <span class="comment">//tbb::filter::serial_in_order已经废弃</span></span><br><span class="line">        tbb::filter_mode::serial_in_order,</span><br><span class="line">        <span class="comment">//filter body</span></span><br><span class="line">        [&amp;](tbb::flow_control &amp;fc) -&gt; CaseStringPtr &#123;</span><br><span class="line">            CaseStringPtr s_ptr = <span class="built_in">getCaseString</span>(caseBeforeFile);</span><br><span class="line">            <span class="keyword">if</span> (!s_ptr)</span><br><span class="line">              fc.<span class="built_in">stop</span>();</span><br><span class="line">            <span class="keyword">return</span> s_ptr;</span><br><span class="line">        &#125;) </span><br><span class="line">    </span><br><span class="line">    &amp; <span class="comment">// 链接</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二个filter，负责修改字符串</span></span><br><span class="line">    tbb::<span class="built_in">make_filter</span>&lt;CaseStringPtr, CaseStringPtr&gt;(</span><br><span class="line">        <span class="comment">//filter node</span></span><br><span class="line">        tbb::filter_mode::parallel,</span><br><span class="line">        <span class="comment">//filter body</span></span><br><span class="line">        [](CaseStringPtr s_ptr) -&gt; CaseStringPtr &#123;</span><br><span class="line">        std::<span class="built_in">transform</span>(s_ptr-&gt;<span class="built_in">begin</span>(), s_ptr-&gt;<span class="built_in">end</span>(), s_ptr-&gt;<span class="built_in">begin</span>(),</span><br><span class="line">                       [](<span class="type">char</span> c) -&gt; <span class="type">char</span> &#123;</span><br><span class="line">                         <span class="keyword">if</span> (std::<span class="built_in">islower</span>(c))</span><br><span class="line">                           <span class="keyword">return</span> std::<span class="built_in">toupper</span>(c);</span><br><span class="line">                         <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">isupper</span>(c))</span><br><span class="line">                           <span class="keyword">return</span> std::<span class="built_in">tolower</span>(c);</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                           <span class="keyword">return</span> c;</span><br><span class="line">                       &#125;);</span><br><span class="line">        <span class="keyword">return</span> s_ptr;</span><br><span class="line">      &#125;) </span><br><span class="line">    </span><br><span class="line">      &amp; <span class="comment">//链接</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第三个filter，负责写字符串</span></span><br><span class="line">    tbb::<span class="built_in">make_filter</span>&lt;CaseStringPtr, <span class="type">void</span>&gt;(</span><br><span class="line">          <span class="comment">//filter node</span></span><br><span class="line">          tbb::filter_mode::serial_in_order,</span><br><span class="line">          <span class="comment">//filter body</span></span><br><span class="line">          [&amp;](CaseStringPtr s_ptr) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="built_in">writeCaseString</span>(caseAfterFile, s_ptr);</span><br><span class="line">          &#125;)</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flow-Graphs">Flow Graphs</h2><p>并行编程另一个问题是混乱，传统并行编程为了避免程序混乱（messy），我们需要事无巨细地管理每一件事。但在上一节简单提到的Flow Graphs，提供了一个简单的管理方法</p><p>Flow Graphs允许我们用图（DAG）来描述程序，相比于<code>parallel_do</code>和<code>parallel_pipeline</code>，FlowGraphs自由度更高，推荐使用。</p><ul><li>每个节点是一个并行函数，箭头代表数据的流向/消息传递，我们将这个图称为数据流向图（data flow graphs）</li><li>图也可以描述操作的前后顺序，进而可以构建一些传统方法难以表示的独立结构体，这种图被称为依赖图（dependency graphs）</li></ul><h3 id="预热">预热</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">warmupTBB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tbb::task_scheduler_init::default_num_threads()已经弃用</span></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, tbb::this_task_arena::<span class="built_in">max_concurrency</span>(), [](<span class="type">int</span>) &#123;</span><br><span class="line">        tbb::tick_count t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">while</span> ((tbb::tick_count::<span class="built_in">now</span>() - t0).<span class="built_in">seconds</span>() &lt; <span class="number">0.01</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是web服务器、CPU/GPU并行计算，深度学习，都有warmup的概念</p><p>对于一个项目，如果采用冷启动的方式，从零瞬间增加计算量，可能会把系统压垮，于是我们可以使用warmup，逐步提高项目负荷。</p><h3 id="数据流图">数据流图</h3><ol><li>构建图对象</li><li>创建节点，填充节点信息</li><li>链接节点</li><li>发送消息</li><li>等待图完成</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">graphSample</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建图对象</span></span><br><span class="line">    tbb::flow::graph g;</span><br><span class="line">    <span class="comment">//创建节点</span></span><br><span class="line">    tbb::<span class="function">flow::function_node&lt;<span class="type">int</span>, std::string&gt; <span class="title">my_first_node</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            g, tbb::flow::unlimited,</span></span></span><br><span class="line"><span class="params"><span class="function">            [](<span class="type">const</span> <span class="type">int</span> &amp;in) -&gt; std::string&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;first node received: &quot;</span> &lt;&lt; in &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> std::to_string(in);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    tbb::<span class="function">flow::function_node&lt;std::string&gt; <span class="title">my_second_node</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            g, tbb::flow::unlimited,</span></span></span><br><span class="line"><span class="params"><span class="function">            [](<span class="type">const</span> std::string &amp;in)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;second node received: &quot;</span> &lt;&lt; in &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    <span class="comment">//链接</span></span><br><span class="line">    tbb::flow::<span class="built_in">make_edge</span>(my_first_node, my_second_node);</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    my_first_node.<span class="built_in">try_put</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//等待图完成</span></span><br><span class="line">    g.<span class="built_in">wait_for_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节点">节点</h4><p>Flow Graphs有三种节点</p><ul><li>functional</li><li>control flow</li><li>buffering</li></ul><h5 id="function-node">function_node</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body&gt;</span></span><br><span class="line"><span class="function"><span class="title">function_node</span><span class="params">(graph&amp; g, <span class="type">size_t</span> concurrency, Body body)</span></span>;</span><br></pre></td></tr></table></figure><p>函数节点，当消息传递到该节点，会被函数处理，并将输出值传递给后继者</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入一个int类型，输出一个std::string类型</span></span><br><span class="line">tbb::<span class="function">flow::function_node&lt;<span class="type">int</span>, std::string&gt; <span class="title">my_first_node</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//图对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">            g, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//节点的并发限制，0是无限制(unlimited)，1是串行(serial)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  tbb::flow::unlimited,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//body</span></span></span></span><br><span class="line"><span class="params"><span class="function">            [](<span class="type">const</span> <span class="type">int</span> &amp;in) -&gt; std::string&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;first node received: &quot;</span> &lt;&lt; in &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> std::to_string(in);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br></pre></td></tr></table></figure><p>函数节点可以从他所连接（edges）其他节点获取消息，也可以使用<code>try_put</code>手动向其传递消息</p><h5 id="join-node">join_node</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body, <span class="keyword">typename</span>... Bodies&gt;</span><br><span class="line"><span class="built_in">join_node</span>(graph&amp;, Body, Bodies...)-&gt;join_node&lt;std::tuple&lt;std::<span class="type">decay_t</span>&lt;<span class="type">input_t</span>&lt;Body&gt;&gt;, std::<span class="type">decay_t</span>&lt;<span class="type">input_t</span>&lt;Bodies&gt;&gt;...&gt;, key_matching&lt;<span class="type">output_t</span>&lt;Body&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure><p>流控制节点，当消息传递到该节点，会创建一个消息元组（tuple），然后将元组广播给所有后继者</p><p><img src="Image/join.jpg" class="lazyload" data-srcset="Image/join.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="join"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//my_node，输入int，输出std::string</span></span><br><span class="line">tbb::flow::function_node&lt;<span class="type">int</span>, std::string&gt; my_node&#123;...&#125;;</span><br><span class="line"><span class="comment">//my_other_node，输入int，输出double</span></span><br><span class="line">tbb::flow::function_node&lt;<span class="type">int</span>, <span class="type">double</span>&gt; my_other_node&#123;...&#125;;</span><br><span class="line"><span class="comment">//join节点，这里的作用是将两个节点的输出整合，传递给my_final_node</span></span><br><span class="line">tbb::flow::join_node&lt;std::tuple&lt;std::string, <span class="type">double</span>&gt;,</span><br><span class="line">            tbb::flow::queueing&gt; my_join_node&#123;g&#125;;</span><br><span class="line"><span class="comment">//my_final_node，输入一个元组</span></span><br><span class="line">tbb::flow::function_node&lt;std::tuple&lt;std::string, <span class="type">double</span>&gt;, <span class="type">int</span>&gt; my_final_node&#123;g,</span><br><span class="line">                   tbb::flow::unlimited,</span><br><span class="line">                   [](<span class="type">const</span> std::tuple&lt;std::string, <span class="type">double</span>&gt;&amp; in) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">                     std::cout &lt;&lt; <span class="string">&quot;final: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(in)</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(in) &lt;&lt; std::endl;</span><br><span class="line">                     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                  &#125;;</span><br></pre></td></tr></table></figure><p>有的时候，我们需要保证<code>join_node</code>的输入的对应的。比如我想将两张照片拼成一张，我开两个节点并行读项目，再用<code>join_node</code>整合后传入merge函数节点，然而在这个过程中，我必须保证传入的两个像素点在同一位置，为此，我们可以添加一个frameNumber做标记（tags）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用函数对象作为tags，可以用input_port&lt;i&gt;读出来</span></span><br><span class="line">tbb::flow::join_node&lt;std::tuple&lt;Image, Image&gt;, tbb::flow::tag_matching &gt;</span><br><span class="line">    <span class="built_in">join_images_node</span>(g, [] (Image left) &#123; <span class="keyword">return</span> left.frameNumber; &#125;,</span><br><span class="line">                        [] (Image right) &#123; <span class="keyword">return</span> right.frameNumber; &#125; );</span><br><span class="line">...</span><br><span class="line">tbb::flow::<span class="built_in">make_edge</span>(increase_left_node, tbb::flow::<span class="built_in">input_port</span>&lt;<span class="number">0</span>&gt;(join_images_node));</span><br><span class="line">tbb::flow::<span class="built_in">make_edge</span>(increase_right_node, tbb::flow::<span class="built_in">input_port</span>&lt;<span class="number">1</span>&gt;(join_images_node));</span><br><span class="line">tbb::flow::<span class="built_in">make_edge</span>(join_images_node, merge_images_node);</span><br></pre></td></tr></table></figure><h4 id="链接">链接</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Message&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_edge</span><span class="params">( sender&lt;Message&gt; &amp;p, receiver&lt;Message&gt; &amp;s )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MultiOutputNode, <span class="keyword">typename</span> MultiInputNode &gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_edge</span><span class="params">( MultiOutputNode&amp; output, MultiInputNode&amp; input )</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>make_edge</code>链接两个节点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的input_port是一种sender，跟节点差不多，都能互相链接</span></span><br><span class="line"><span class="built_in">make_edge</span>(my_node, tbb::flow::<span class="built_in">input_port</span>&lt;<span class="number">0</span>&gt;(my_join_node));</span><br><span class="line"><span class="built_in">make_edge</span>(my_other_node, tbb::flow::<span class="built_in">input_port</span>&lt;<span class="number">1</span>&gt;(my_join_node));</span><br><span class="line"><span class="built_in">make_edge</span>(my_join_node, my_final_node);</span><br></pre></td></tr></table></figure><h4 id="激活">激活</h4><p>为了激活图，我们需要向图中传递消息，除了前文的<code>try_put</code>，我们也可以使用<code>input_port</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//my_node是一个input_node</span></span><br><span class="line">my_node.<span class="built_in">activate</span>();<span class="comment">//将其设为活动状态，启用消息生成</span></span><br></pre></td></tr></table></figure><h4 id="等待">等待</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g.<span class="built_in">wait_for_all</span>();</span><br></pre></td></tr></table></figure><h3 id="性能限制">性能限制</h3><p>Flow Graphs是一个基于Task的并行框架，当消息到达一个节点时，根据节点的并发限制，创建Task。生成的Task会进一步映射为线程（跟上一节讲的循环、算法的机制一样）</p><p>真正限制Flow Graphs性能的有</p><ul><li>串行节点（serial node）</li><li>工作线程数</li><li>任务复杂度</li></ul><h3 id="依赖图">依赖图</h3><p><em>很像RenderGraph</em></p><table><thead><tr><th></th><th>数据流向图</th><th>依赖图</th></tr></thead><tbody><tr><td>Edges含义</td><td>表示数据流向</td><td>表示节点的先后顺序</td></tr><tr><td>信息传递方式</td><td>消息</td><td>shared memory</td></tr><tr><td>节点类型</td><td>function_node</td><td>continue_node</td></tr></tbody></table><ul><li><p>节点的先后顺序，描述的是依赖关系，只有前面节点执行结束后，后面节点才能安全、正确地执行</p></li><li><p>依赖图不使用函数节点，而是继续节点<code>continue_node</code>，节点间的消息传递使用，当传入<code>continue_node</code>的消息（<code>continue_msg</code>）数量等于该节点需要的消息数量，节点内的函数会开始执行</p></li><li><p><code>continue_node</code>只关心传入的消息数量，不关心消息源。这导致依赖图必须是非循环的（acyclic），因为一个物体循环发出两次消息，（在这里）等同于两个物体各发出一次消息</p></li></ul><p>构建依赖图</p><ol><li>创建图对象</li><li>创建节点</li><li>链接</li><li>发送信息</li><li>等待图完成</li></ol><h4 id="前向替换-2">前向替换</h4><p>之前我们使用<code>parallel_for_each</code>实现了一份前向替换，我们现在用依赖图再实现一次</p><p><img src="Image/%E5%89%8D%E5%90%91%E6%9B%BF%E6%8D%A2.jpg" class="lazyload" data-srcset="Image/%E5%89%8D%E5%90%91%E6%9B%BF%E6%8D%A2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="前向替换"></p><p>经观察，我们发现辅对角线的块/迭代器是相互独立的，他们之间没有依赖关系（上图(b)，块BC间没有依赖，他们只需要在A之后执行就可以正确运算）</p><p>经观察，同时并行计算的最大块数为辅对角线的长度，也就是图中标注的 a set of independent blocks</p><p>经观察，上图(b)中每一个块需要接受两个msg，正好与block_sizes大小相等</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Node = tbb::flow::continue_node&lt;tbb::flow::continue_msg&gt;;</span><br><span class="line"><span class="keyword">using</span> NodePtr = std::shared_ptr&lt;Node&gt;;</span><br><span class="line"><span class="function">NodePtr <span class="title">createNode</span><span class="params">(tbb::flow::graph &amp;g, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> block_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::vector&lt;<span class="type">double</span>&gt; &amp;x, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;a, std::vector&lt;<span class="type">double</span>&gt; &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdges</span><span class="params">(std::vector&lt;NodePtr&gt; &amp;nodes, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> block_size, <span class="type">int</span> num_blocks)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dependencyGraphFS</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt; &amp;x, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;a, std::vector&lt;<span class="type">double</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> block_size = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_blocks = N / block_size;</span><br><span class="line"><span class="comment">//创建num_blocks * num_blocks个节点，只不过我们只会用到下半部分</span></span><br><span class="line">    <span class="function">std::vector&lt;NodePtr&gt; <span class="title">nodes</span><span class="params">(num_blocks * num_blocks)</span></span>;</span><br><span class="line">    <span class="comment">//创建图对象</span></span><br><span class="line">    tbb::flow::graph g;</span><br><span class="line">  <span class="comment">//我们从最下面一行开始向上构建</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r = num_blocks<span class="number">-1</span>; r &gt;= <span class="number">0</span>; --r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c = r; c &gt;= <span class="number">0</span>; --c)&#123;</span><br><span class="line">            <span class="comment">//创建图节点</span></span><br><span class="line">            nodes[r * num_blocks + c] = <span class="built_in">createNode</span>(g, r, c, block_size, x, a, b);</span><br><span class="line">            <span class="comment">//链接</span></span><br><span class="line">            <span class="built_in">addEdges</span>(nodes, r, c, block_size, num_blocks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入消息</span></span><br><span class="line">    nodes[<span class="number">0</span>]-&gt;<span class="built_in">try_put</span>(tbb::flow::<span class="built_in">continue_msg</span>());</span><br><span class="line">    <span class="comment">//等待完成</span></span><br><span class="line">    g.<span class="built_in">wait_for_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NodePtr <span class="title">createNode</span><span class="params">(tbb::flow::graph &amp;g, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> block_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::vector&lt;<span class="type">double</span>&gt; &amp;x, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;a, std::vector&lt;<span class="type">double</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Node&gt;(</span><br><span class="line">            g,</span><br><span class="line">            [r, c, block_size, N, &amp;x, &amp;a, &amp;b](<span class="type">const</span> tbb::flow::continue_msg &amp; msg)&#123;</span><br><span class="line">                <span class="type">int</span> i_start = r * block_size, i_end = i_start + block_size;</span><br><span class="line">                <span class="type">int</span> j_start = c * block_size, j_max = j_start + block_size <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">//对于每个块，串行进行正向替换计算</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = i_start; i &lt; i_end; ++i)&#123;</span><br><span class="line">                    <span class="type">int</span> j_end = (i &lt;= j_max) ? i : j_max+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = j_start; j &lt; j_end; ++j)&#123;</span><br><span class="line">                        b[i] -= a[j + i*N] * x[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j_end == i)&#123;</span><br><span class="line">                        x[i] = b[i] / a[i + i*N];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> msg;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdges</span><span class="params">(std::vector&lt;NodePtr&gt; &amp;nodes, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> block_size, <span class="type">int</span> num_blocks)</span></span>&#123;</span><br><span class="line">    NodePtr np = nodes[r * num_blocks + c];</span><br><span class="line">  <span class="comment">//每个块链接自己的下面和右边，最下面和最右边不链接</span></span><br><span class="line">    <span class="keyword">if</span>(c + <span class="number">1</span> &lt; num_blocks &amp;&amp; r != c)&#123;</span><br><span class="line">        tbb::flow::<span class="built_in">make_edge</span>(*np, *nodes[r * num_blocks + c + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r + <span class="number">1</span> &lt; num_blocks)&#123;</span><br><span class="line">        tbb::flow::<span class="built_in">make_edge</span>(*np, *nodes[(r+<span class="number">1</span>) * num_blocks + c]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PSTL">PSTL</h2><p>parallel_sort</p><h2 id="同步">同步</h2><p>在并行编程中，我们要极力避免同步（Synchronization）和互斥（exclusion），这会严重影响性能</p><p>但是很多情况下，我们不得不同步，书中称其为“必要之恶”（necessary evil）</p><h3 id="写冲突">写冲突</h3><p>比如我们想要统计一张图中各种颜色出现的次数，如果是串行处理，我们就遍历每一个像素，用一个数组存储统计值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">  hist[image[i]]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但当我们想要并行处理遍历像素时，就会出现问题。如果两个线程同时读到了同一种颜色，于是都想执行<code>hist[p]++</code>，而如果该操作不支持原子（atomic）操作，就会出现写冲突</p><h4 id="RMW">RMW</h4><p>现代操作系统将很多操作设置为原子操作，该操作被视为一个完成的操作，不可分割，因此是线程安全的。比如对齐读（Aligned Read），对齐写（Aligned Write）</p><p><em>原子的本意就是不可分割的意思，当年化学家和物理学家认为原子是最小的粒子（尽管并非如此）</em></p><p>Read-Modify-Write（RMW）设计原则，可以让复杂操作原子化，当多个线程想要对某个内存进行修改时，保证线程安全并只执行一次</p><p>windows原子操作的实现原理（_InterlockedIncrement）</p><ol><li>读内存</li><li>计算得到新值</li><li>若内存位置仍然是原始值，则将新值写入该内存位置<ul><li>若不是原始值，则在下一个循环周期中重新操作</li></ul></li></ol><h4 id="锁">锁</h4><p>解决并行写冲突最简单的方法就是加锁，我们给对象加一个互斥锁（mutex），写之前上锁，写完解锁，其他线程无法操作锁住的对象。而上锁解锁操作中间的代码被称为临界区（critical section），是被锁保护的部分。</p><p>锁会影响性能</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tbb::task_scheduler_init init&#123;nth&#125;已经弃用，用于设置最大线程数</span></span><br><span class="line"><span class="function">tbb::global_control <span class="title">global_limit</span><span class="params">(tbb::global_control::max_allowed_parallelism, nth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="type">my_mutex_t</span>=tbb::spin_mutex;</span><br><span class="line"><span class="type">my_mutex_t</span> my_mutex;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">hist_p</span><span class="params">(num_bins)</span></span>;</span><br><span class="line"><span class="built_in">parallel_for</span>(tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&#123;<span class="number">0</span>, image.<span class="built_in">size</span>()&#125;,</span><br><span class="line">             [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//这种写法比my_lock.acquire(my_mutex)、my_lock.release()好</span></span><br><span class="line">                 <span class="type">my_mutex_t</span>::scoped_lock my_lock&#123;my_mutex&#125;;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">                   hist_p[image[i]]++;</span><br><span class="line">             &#125;);</span><br></pre></td></tr></table></figure><h4 id="原子操作">原子操作</h4><p>锁过于消耗性能，原子操作效果会好一些，只不过这样还是比线性慢，而且不是真共享（Sharing）</p><p>什么是原子？原子的原意就是不可分割的基本粒子，我们在实现<code>a++</code>时，本质是分了三步</p><ol><li>取a</li><li>加法运算</li><li>写a</li></ol><p>由于并行计算，其他线程可能在你完整完成这三步期间进行操作，于是就会出现冲突。而原子操作就是将这三步视为一步，不可分割，在完整完成这三部之前，其他线程无权访问，等到操作结束</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::atomic&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">hist_p2</span>(num_bins);</span><br><span class="line"><span class="built_in">parallel_for</span>(tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&#123;<span class="number">0</span>, image.<span class="built_in">size</span>()&#125;, </span><br><span class="line">             [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">                 &#123;</span><br><span class="line">                     hist_p2[image[i]]++;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">            );</span><br></pre></td></tr></table></figure><h3 id="Thread-Local-Storage">Thread Local Storage</h3><p>一个较好的解决方案是私有化（Privatization）和归并（Reduction）</p><p>我感觉这个的设计理念就是：如果不得不同步，那就尽可能让更多更复杂的计算并行执行，最后对统一、规范、简单的数据进行同步</p><p>前面并行统计Image像素信息时，会出现多个线程写冲突。但如果让每个线程都有一个Image副本，线程对自己的副本进行操作（私有化），最后将这些副本进行归并。</p><p>私有化确实不会出现写冲突了，尽管归并仍然存在同步问题，但这个归并更简单，毕竟归并几个数，远远比处理几个线程冲突要简单，性能开销小</p><p>TBB提供了多种私有化+归并的的方案，其中归并模板（parallel_reduce）在TBB基础时就讲了</p><ul><li>Thread Local Storage（TLS）：让每一个线程拥有一份副本，只不过存储开销过大，不宜过多使用<ul><li>enumerable_thread_specific（ETS）</li><li>combinable</li></ul></li></ul><h4 id="ETS">ETS</h4><p><code>tbb::enumerable_thread_specific&lt;T&gt;</code>对象是一个大容器，容器内包含者每一个线程所对应的副本，我们可以使用迭代器进行访问</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">vector_t</span> = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="type">priv_h_t</span> = tbb::enumerable_thread_specific&lt;<span class="type">vector_t</span>&gt;;</span><br><span class="line"><span class="type">priv_h_t</span> priv_h&#123;num_bins&#125;;</span><br><span class="line"><span class="comment">//私有化</span></span><br><span class="line"><span class="built_in">parallel_for</span>(tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&#123;<span class="number">0</span>, image.<span class="built_in">size</span>()&#125;,</span><br><span class="line">             [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//若该线程第一次使用local，那么会创建一个新的vector&lt;int&gt;，初始值为0</span></span><br><span class="line">                 <span class="type">priv_h_t</span>::reference my_hist = priv_h.<span class="built_in">local</span>();</span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">                     <span class="comment">//my_hist是引用，实际上是在修改priv_h[xxx]，以此将数据传递到线程外</span></span><br><span class="line">                     my_hist[image[i]]++;</span><br><span class="line">                 &#125;     </span><br><span class="line">             &#125;);</span><br><span class="line"><span class="comment">//归并</span></span><br><span class="line"><span class="function"><span class="type">vector_t</span> <span class="title">hist_p3</span><span class="params">(num_bins)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i=priv_h.<span class="built_in">begin</span>(); i!=priv_h.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;num_bins; ++j) &#123;</span><br><span class="line">    hist_p3[j]+=(*i)[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用STL算法替代循环，进行归并</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以使用transform替代循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i: priv_h) &#123; <span class="comment">// i traverses all private vectors</span></span><br><span class="line">    std::<span class="built_in">transform</span>(hist_p3.<span class="built_in">begin</span>(),    <span class="comment">// source 1 begin</span></span><br><span class="line">                   hist_p3.<span class="built_in">end</span>(),      <span class="comment">// source 1 end</span></span><br><span class="line">                   i.<span class="built_in">begin</span>(),          <span class="comment">// source 2 begin</span></span><br><span class="line">                   hist_p3.<span class="built_in">begin</span>(),    <span class="comment">// destination begin</span></span><br><span class="line">                   std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;() ); <span class="comment">// binary operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于归并过于常用，TBB也对归并做了封装</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用combine_each</span></span><br><span class="line">priv_h.<span class="built_in">combine_each</span>([&amp;](<span class="type">vector_t</span> i)&#123;</span><br><span class="line">        std::<span class="built_in">transform</span>(hist_p3.<span class="built_in">begin</span>(),   <span class="comment">// source 1 begin</span></span><br><span class="line">                   hist_p3.<span class="built_in">end</span>(),      <span class="comment">// source 1 end</span></span><br><span class="line">                   i.<span class="built_in">begin</span>(),         <span class="comment">// source 2 begin</span></span><br><span class="line">                   hist_p3.<span class="built_in">begin</span>(),    <span class="comment">// destination begin</span></span><br><span class="line">                   std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;() );<span class="comment">// binary operation</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//或者使用combine</span></span><br><span class="line"><span class="type">vector_t</span> hist_p = priv_h.<span class="built_in">combine</span>([](<span class="type">vector_t</span> a, <span class="type">vector_t</span> b) -&gt; <span class="type">vector_t</span> &#123;</span><br><span class="line">      std::<span class="built_in">transform</span>(a.<span class="built_in">begin</span>(),         <span class="comment">// source 1 begin</span></span><br><span class="line">                     a.<span class="built_in">end</span>(),           <span class="comment">// source 1 end</span></span><br><span class="line">                     b.<span class="built_in">begin</span>(),         <span class="comment">// source 2 begin</span></span><br><span class="line">                     a.<span class="built_in">begin</span>(),         <span class="comment">// destination begin</span></span><br><span class="line">                     std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;() );<span class="comment">// binary operation</span></span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="combinable">combinable</h4><p><code>combinable&lt;T&gt;</code>对象也是一个容器，每一个线程对应一个instance</p><p>但是与ETS不同，<code>combinable&lt;T&gt;</code>并不能使用迭代器访问，这样设计的目的是不向外暴露对象，这样归并结束后大容器和其中的数据都释放了，以此节省局部空间</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//combinable</span></span><br><span class="line">tbb::combinable&lt;<span class="type">vector_t</span>&gt; priv_h2&#123;[num_bins]()&#123;<span class="keyword">return</span> <span class="built_in">vector_t</span>(num_bins);&#125;&#125;;</span><br><span class="line"><span class="comment">//私有化</span></span><br><span class="line"><span class="built_in">parallel_for</span>(tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&#123;<span class="number">0</span>, image.<span class="built_in">size</span>()&#125;,</span><br><span class="line">             [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="type">vector_t</span>&amp; my_hist = priv_h2.<span class="built_in">local</span>();</span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">                     my_hist[image[i]]++;</span><br><span class="line">             &#125;);</span><br><span class="line"><span class="comment">//归并</span></span><br><span class="line"><span class="function"><span class="type">vector_t</span> <span class="title">hist_p4</span><span class="params">(num_bins)</span></span>;</span><br><span class="line">priv_h2.<span class="built_in">combine_each</span>([&amp;](<span class="type">vector_t</span> i)</span><br><span class="line">                     &#123; <span class="comment">// for each priv histogram a</span></span><br><span class="line">                         std::<span class="built_in">transform</span>(hist_p4.<span class="built_in">begin</span>(),     <span class="comment">// source 1 begin</span></span><br><span class="line">                                        hist_p4.<span class="built_in">end</span>(),      <span class="comment">// source 1 end</span></span><br><span class="line">                                        i.<span class="built_in">begin</span>(),          <span class="comment">// source 2 begin</span></span><br><span class="line">                                        hist_p4.<span class="built_in">begin</span>(),    <span class="comment">// destination begin</span></span><br><span class="line">                                        std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;() ); <span class="comment">// binary operation</span></span><br><span class="line">                     &#125;);</span><br></pre></td></tr></table></figure><p>最终性能比较，能看出TLS能大幅提高性能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Serial:       0.399203</span><br><span class="line">Parallel:     2.01466</span><br><span class="line">Atomic:       0.500326</span><br><span class="line">ETC:          0.0348115</span><br><span class="line">combinable:   0.0339478</span><br></pre></td></tr></table></figure><h3 id="parallel-reduce">parallel_reduce</h3><p>最简单的归并，还是给用tbb封装好的模板，该算法的本质是树形规约</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parallel_reduce</span></span><br><span class="line"><span class="keyword">using</span> image_iterator = std::vector&lt;<span class="type">uint8_t</span>&gt;::iterator;</span><br><span class="line">t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">vector_t</span> hist_p5 = <span class="built_in">parallel_reduce</span> (</span><br><span class="line">    <span class="comment">/*range*/</span>    </span><br><span class="line">    tbb::blocked_range&lt;image_iterator&gt;&#123;image.<span class="built_in">begin</span>(), image.<span class="built_in">end</span>()&#125;,</span><br><span class="line">    <span class="comment">/*identity*/</span> </span><br><span class="line">    <span class="built_in">vector_t</span>(num_bins),</span><br><span class="line">    <span class="comment">// 1st Lambda: Parallel computation on private histograms</span></span><br><span class="line">    [](<span class="type">const</span> tbb::blocked_range&lt;image_iterator&gt;&amp; r, <span class="type">vector_t</span> v) &#123;</span><br><span class="line">        std::for_each(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>(),</span><br><span class="line">                      [&amp;v](<span class="type">uint8_t</span> i) &#123;v[i]++;&#125;);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 2nd Lambda: Parallel reduction of the private histograms</span></span><br><span class="line">    [num_bins](<span class="type">vector_t</span> a, <span class="type">const</span> <span class="type">vector_t</span> &amp; b) -&gt; <span class="type">vector_t</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num_bins; ++i) a[i] += b[i];</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="并发容器">并发容器</h2><p>在上一节我们遇到了同步问题，处理同步会大幅降低性能，为此我们使用了TLS等方法实现了高效的显式同步，而这一节，我们将介绍TBB的核心，并发（Concurrent）</p><p>TBB提供了一些高效、线程安全的并发容器，他们大多是使用细粒度的锁或者无锁设计</p><ul><li>细粒度锁：指锁定真正需要锁定的地方（其实还是挺低效的），比如一个数组我们只锁我们需要的某一个元素，其他线程如果不访问我这个元素，就能正常并行</li><li>无锁：有的线程负责操作，有的线程负责纠错</li></ul><p>TBB的并发容器并发性能很好，但串行性能不如STL</p><ul><li>顺序表（Sequences）<ul><li><code>concurrent_vector</code></li></ul></li><li>队列（Queues）<ul><li><code>concurrent_queue</code></li><li><code>concurrent_bounded_queue</code></li><li><code>concurrent_priority_queue</code></li></ul></li><li>无序关联容器（Unordered associative containers）<ul><li><code>concurrent_hash_map</code></li><li><code>map/multimap</code></li><li><code>set/multiset</code></li></ul></li><li>有序关联容器（Ordered associative containers）<ul><li><code>map/multimap</code></li><li><code>set/multiset</code></li></ul></li></ul><h3 id="concurrent-hash-map">concurrent_hash_map</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T,</span><br><span class="line">                 <span class="keyword">typename</span> HashCompare = tbb_hash_compare&lt;Key&gt;,</span><br><span class="line">                 <span class="keyword">typename</span> Allocator = tbb_allocator&lt;std::pair&lt;<span class="type">const</span> Key, T&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> concurrent_hash_map &#123;..&#125;</span><br></pre></td></tr></table></figure><p>这是一个字符串-Int的哈希表</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashCompare必须有hash函数和equal函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyHashCompare</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">hash</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)&#123;</span><br><span class="line">            h = (h*<span class="number">17</span>)^c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> std::string&amp; x, <span class="type">const</span> std::string&amp; y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//hash map</span></span><br><span class="line"><span class="keyword">typedef</span> tbb::concurrent_hash_map&lt;std::string, <span class="type">int</span>, MyHashCompare&gt; StringTable;</span><br><span class="line"><span class="comment">//一个函数对象，用于记录table内元素数量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tally</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StringTable&amp; table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tally</span>(StringTable&amp; table_): <span class="built_in">table</span>(table_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> tbb::blocked_range&lt;std::string*&gt; range)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(std::string* p = range.<span class="built_in">begin</span>(); p != range.<span class="built_in">end</span>(); ++p)&#123;</span><br><span class="line">          <span class="comment">//accessor类似于锁、智能智能，在accessor完成前，其他线程不能lookup这个key</span></span><br><span class="line">            StringTable::accessor a;</span><br><span class="line">            table.<span class="built_in">insert</span>(a, *p);</span><br><span class="line">            a-&gt;second += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringTable table;</span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>( tbb::<span class="built_in">blocked_range</span>&lt;std::string*&gt;( Data, Data+N, <span class="number">1000</span> ), <span class="built_in">Tally</span>(table) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( StringTable::iterator i=table.<span class="built_in">begin</span>();</span><br><span class="line">         i!=table.<span class="built_in">end</span>();</span><br><span class="line">         ++i )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,i-&gt;first.<span class="built_in">c_str</span>(),i-&gt;second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存分配">内存分配</h2><p>内存分配最重要的是正确，TBB提供了一套可拓展的内存分配</p><p>现代C++推荐使用智能指针进行内存管理，不推荐使用malloc和new。TBB完全适配所有版本的C++标准，也推荐使用智能指针进行内存分配</p><p>TBB动态内存分配的核心是线程内存池（memory pooling by threads），该内存池可以避免内存分配带来的性能下降，也不苛求“避免cache间不必要的数据移动”</p><p>TBB还提供了可拓展的缓存对齐，比<code>std::aligned_alloc</code>使用更简单方便。只不过滥用缓存对齐可能会带了巨大的内存浪费</p><p>在并行编程中，内存分配的主要问题是：分配器的争用，缓存效果</p><ul><li>分配器争用：C++内存分存储在两个位置，堆和栈。传统的非线程分配器只能在单个全局堆中分配和释放内存，这个过程配合锁以实现互斥，很低效</li><li>缓存效应：某些操作可能会把缓存中的数据移动到缓存的另一处，这是很无效的行为，要避免</li></ul><h3 id="缓存填充（对齐）">缓存填充（对齐）</h3><p>用于解决假共享（我们在同步那一节解决了真共享带来的问题）</p><p>基于局部性原则，当CPU查询某个数据时：</p><ol><li>若cache中没有找到，就会去内存中寻找</li><li>找到后会将该数据写入cache（时间局部性，刚刚被引用过的一个内存位置容易再次被引用）</li><li>并将其相邻元素也写入cache（空间局部性，一个内存位置被引用，其相邻位置很可能马上被引用）</li></ol><p><img src="Image/%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7.png" class="lazyload" data-srcset="Image/%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="空间局部性"></p><p>如上图，CPU访问a时，先去cache去找，如果cache中没有，就会去内存中寻找，找到后将a和相邻的b写入cache的<strong>同一行</strong>。但问题出现了，如果当前cache的其他行里，已经有b了呢？</p><p>另一个线程也拥有一缓存行，里面存储了b，结果b却被移动到a那一行了，于是这个线程要访问b，又要去内存中找，增加了cache miss。此外多线程中，a那个线程多半是不会用到b的，于是平白做了cache位置的移动。</p><p>这个现象被称为假共享（false sharing），a和b并不是共享对象，但是由于他们靠的太近了，以至于在一个缓存行中，其中一个对象的更新，会强制另一个对象更新。</p><p>在多线程中，假共享可以通过缓存填充（cache padding）解决。缓存填充，就是在缓存中两个变量中间填充一些没有意义的数据，于是导致这两个变量不会处于同一个缓存行中，于是避免了假共享。</p><p>我们还是以统计图片像素为例，我们发现这种方法比直接用原子操作要快一些</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bin</span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; count; <span class="comment">//4 bytes</span></span><br><span class="line">    <span class="type">uint8_t</span> padding[<span class="number">64</span> - <span class="built_in">sizeof</span>(count)];    <span class="comment">//60 bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//cache padding</span></span><br><span class="line">std::vector&lt;bin, tbb::cache_aligned_allocator&lt;bin&gt;&gt; <span class="built_in">hist_p6</span>(num_bins);</span><br><span class="line">t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line"><span class="built_in">parallel_for</span>(tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&#123;<span class="number">0</span>, image.<span class="built_in">size</span>()&#125;,</span><br><span class="line">             [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">             &#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">               &#123;</span><br><span class="line">                 hist_p6[image[i]].count++;</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">            );</span><br></pre></td></tr></table></figure><p>我们可以用C++特性来创建结构体：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bin</span>&#123;</span><br><span class="line">    <span class="comment">//C++17后，可以用std::hardware_destructive_interference_size替代64</span></span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;<span class="type">int</span>&gt; count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代理">代理</h3><p>TBB的TBBmalloc库使用代理方法，可以实现在不同操作系统，不改变代码，只需要配置一些动态库、代理库、环境变量，就可以实现全局替换new、malloc等分配函数，这对跨平台真的很重要</p><h2 id="Task调度">Task调度</h2><p>Chapter10</p><h2 id="资料">资料</h2><p><a href="https://github.com/Apress/pro-TBB">Pro TBB</a></p><p><a href="https://spec.oneapi.io/versions/latest/elements/oneTBB/source/nested-index.html">API Document</a></p><p><a href="https://github.com/Reuben-Sun/TBB--Programing-Sample">代码仓库</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
            <tag> 并行计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya插件开发</title>
      <link href="/dcc/maya%E6%8F%92%E4%BB%B6/"/>
      <url>/dcc/maya%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1>Maya</h1><p>maya，老东西，行业标准，真难用（不是）</p><p><a href="https://zhuanlan.zhihu.com/p/76957745">腾讯巨神级TA</a>、<a href="http://www.zt-page.com/?p=109">碧血红天的blog</a>、<a href="https://www.cnblogs.com/3lina/p/11672415.html">Pycharm环境搭建</a></p><h3 id="创建一个python工具">创建一个python工具</h3><p>Python插件和Unity Editor那种工具不太一样，这个其实本质就是一个嵌入式的脚本，通过命令调用maya指令，就算有UI也是现绘制的，也不需要什么项目结构，就一个py文件</p><h4 id="创建一个python文件">创建一个python文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> maya.cmds <span class="keyword">as</span> cmds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createWindow</span>():</span><br><span class="line">    <span class="keyword">if</span> cmds.window(<span class="string">&#x27;mywindow&#x27;</span>, exists=<span class="literal">True</span>):</span><br><span class="line">        cmds.deleteUI(<span class="string">&#x27;mywindow&#x27;</span>)</span><br><span class="line">    windowvar = cmds.window(<span class="string">&#x27;mywindow&#x27;</span>)</span><br><span class="line">    cmds.columnLayout()</span><br><span class="line">    checkButton = cmds.button(l=<span class="string">&#x27;Test&#x27;</span>, command=<span class="string">&#x27;testFunc()&#x27;</span>)</span><br><span class="line">    cmds.showWindow(<span class="string">&#x27;mywindow&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testFunc</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">createWindow()</span><br></pre></td></tr></table></figure><h4 id="添加到工具栏">添加到工具栏</h4><p>当你的代码完成后，可以将其固定到工具架上</p><p><img src="/images/maya%E4%BF%9D%E5%AD%98%E5%B7%A5%E5%85%B7%E6%A0%8F.png" class="lazyload" data-srcset="/images/maya%E4%BF%9D%E5%AD%98%E5%B7%A5%E5%85%B7%E6%A0%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="maya保存工具栏"></p><h4 id="怎么写">怎么写</h4><p>这应该是很多人写maya插件最大的疑惑，我的建议是先学美术，开着脚本编辑器，按照美术流程走一遍，你会发现你每一次操作，脚本编辑器都会输出一个指令，这个应该能让你深受启发</p><p><img src="/images/maya%E8%84%9A%E6%9C%AC.png" class="lazyload" data-srcset="/images/maya%E8%84%9A%E6%9C%AC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="maya脚本"></p><p>如果你的脚本编辑器没有显示，那么在脚本编辑器中设置<strong>显示二者</strong></p><p><img src="/images/%E6%98%BE%E7%A4%BA%E4%BA%8C%E8%80%85.png" class="lazyload" data-srcset="/images/%E6%98%BE%E7%A4%BA%E4%BA%8C%E8%80%85.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="显示二者"></p><h3 id="常用API">常用API</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> maya.cmds <span class="keyword">as</span> cmds<span class="comment">#这是一个将MEL指令用python封装的库，适合面向过程编程</span></span><br><span class="line"><span class="keyword">import</span> maya.OpenMaya <span class="keyword">as</span> om<span class="comment">#拥有cmd没有的功能，运行效率更高</span></span><br></pre></td></tr></table></figure><ul><li><p>删除：<code>cmds.delete(p)</code></p></li><li><p>选中：<code>p = cmds.ls('Name')</code></p></li><li><p>创建</p><ul><li>Cube：<code>pCube = cmds.polyCube(w=10, h=10, d=10, name='myCube')</code></li></ul></li><li><p>移动（到指定位置）</p><ul><li>平移：<code>cmds.move(0, 10, 0, pCube)</code></li><li>缩放：<code>cmds.scale(2, 2, 2, pCube)</code></li><li>旋转：<code>cmds.rotate(45, 45, 0, pCube)</code></li></ul></li><li><p>选择（得到的是对象数组）</p><ul><li>当前选择：<code>list = cmds.ls(selection=True)</code></li></ul></li><li><p>读参数</p><ul><li>位置：<code>cmds.getAttr('%s.translate ' % (p))</code></li><li>位置（某一维）：<code>y = cmds.getAttr('%s.translateY ' % (p))</code></li></ul></li><li><p>写参数</p><ul><li>位置（某一维）：<code>cmds.setAttr('%s.translateX' % (p), 10)</code></li></ul></li></ul><p>想知道maya物体的参数，可以通过表达式编辑器查看（窗口-动画编辑器-表达式编辑器）</p><p><img src="/images/maya%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8.png" class="lazyload" data-srcset="/images/maya%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="maya表达式编辑器"></p><ul><li>得到顶点数据</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printVertexPos</span>():</span><br><span class="line">    selectObjectList = cmds.ls(selection=<span class="literal">True</span>)</span><br><span class="line">    VertexArray = cmds.ls(<span class="string">&#x27;&#123;&#125;.vtx[:]&#x27;</span>.<span class="built_in">format</span>(selectObjectList[<span class="number">0</span>]), fl = <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> VertexArray:</span><br><span class="line">        <span class="built_in">print</span> cmds.xform(v, query = <span class="literal">True</span>, translation = <span class="literal">True</span>, worldSpace = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="工具实例">工具实例</h3><h4 id="平滑法线">平滑法线</h4><p><a href="https://github.com/Reuben-Sun/Note-of-Graphics/blob/main/Code/MayaPython/SmoothNormal.py">平滑法线</a></p><h4 id="模型展2UV">模型展2UV</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个名称为sph的多边形</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createFunc</span>():</span><br><span class="line">   cmds.polySphere(n=<span class="string">&#x27;sph&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除除了map1以外所有的uvmap</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deleteUVs</span>():</span><br><span class="line">    au = cmds.polyUVSet(query=<span class="literal">True</span>, allUVSets=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(au)-<span class="number">1</span>):</span><br><span class="line">        cmds.polyUVSet(delete=<span class="literal">True</span>, uvSet=au[j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#自动展选中物体的2UV，并命名为map2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pickUV2</span>():</span><br><span class="line">    <span class="built_in">list</span> = cmds.ls(dag=<span class="number">1</span>, selection=<span class="literal">True</span>)</span><br><span class="line">    au = cmds.polyUVSet(query=<span class="literal">True</span>, allUVSets=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(au) == <span class="number">1</span>):</span><br><span class="line">        cmds.polyAutoProjection(<span class="built_in">list</span>[<span class="number">1</span>] + <span class="string">&#x27;.f[*]&#x27;</span>, cm = <span class="number">1</span>, uvs= <span class="string">&#x27;map2&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;map2 has been exited&quot;</span></span><br></pre></td></tr></table></figure><h4 id="动画clip">动画clip</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输出选中的动画片段的开始帧和结束帧</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printClip</span>():</span><br><span class="line"><span class="built_in">list</span> = cmds.ls(selection=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        start = cmds.getAttr(<span class="string">&#x27;%s.clipStart &#x27;</span> % (p))</span><br><span class="line">        end = cmds.getAttr(<span class="string">&#x27;%s.clipStart &#x27;</span> % (p)) + cmds.getAttr(<span class="string">&#x27;%s.clipDuration &#x27;</span> % (p))</span><br><span class="line">        <span class="built_in">print</span> start</span><br><span class="line">        <span class="built_in">print</span> end</span><br></pre></td></tr></table></figure><h4 id="打开文件">打开文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">openFile</span>():</span><br><span class="line">   path = <span class="string">&#x27;C:/Users/Admin/Desktop/多边形.fbx&#x27;</span></span><br><span class="line">   cmds.file(path, i=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="开关UV编辑器">开关UV编辑器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">openUVPanel</span>():</span><br><span class="line">   <span class="keyword">if</span> cmds.window(<span class="string">&#x27;polyTexturePlacementPanel1Window&#x27;</span>, ex=<span class="number">1</span>):</span><br><span class="line">        cmds.deleteUI(<span class="string">&#x27;polyTexturePlacementPanel1Window&#x27;</span>)</span><br><span class="line">        mel.<span class="built_in">eval</span>(<span class="string">&#x27;toggleUVToolkit;&#x27;</span>)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">        mel.<span class="built_in">eval</span>(<span class="string">&#x27;texturePanelShow;&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收</title>
      <link href="/engine/GC/"/>
      <url>/engine/GC/</url>
      
        <content type="html"><![CDATA[<h1>垃圾回收</h1><h3 id="前言">前言</h3><p>《垃圾回收的算法与实现》读书笔记，其中的代码大多为伪代码</p><h3 id="一：概念">一：概念</h3><p>GC，Garbage Collection，垃圾回收</p><p>功能</p><ul><li>找到内存中的垃圾</li><li>回收垃圾</li></ul><h4 id="为什么需要GC">为什么需要GC</h4><p>如果没有GC，程序员需要手动进行内存管理，开发麻烦，容易引发内存泄漏、野指针，而且因此导致的BUG很难被定位，修复麻烦</p><p>如果有GC，就可以避免这些问题</p><h4 id="GC的种类">GC的种类</h4><ul><li>保守式GC：不能识别指针和非指针时，一律视为非指针</li><li>准确式GC</li></ul><h4 id="GC的算法">GC的算法</h4><ul><li>标记清除法：标记活动对象，其他的都回收</li><li>引用计数法：回收引用值为0的对象</li><li>GC复制法：复制活动对象，其他的都回收</li></ul><h4 id="GC的选取">GC的选取</h4><ul><li>最大暂停时间短：游戏</li><li>整体处理时间短：音频编码</li></ul><h4 id="对象">对象</h4><p>这里的对象并不是OOP里的Object，而是<strong>被应用程序使用的数据的集合</strong>，对象由<strong>头</strong>和<strong>域</strong>构成</p><ul><li><p>头（header）：包含对象的大小和种类</p></li><li><p>域（field）：参考OOP里的成员</p></li></ul><p>对象分为活动对象和非活动对象，GC会保留活动对象，销毁非活动对象</p><h4 id="mutator">mutator</h4><p>可以简单理解为应用程序，在程序运行过程中，会分配/调用/改变对象（只能操作活动对象），伴随着mutator运行，会产生垃圾</p><h4 id="GC算法的评估标准">GC算法的评估标准</h4><ul><li>吞吐量（throughput）：单位时间的处理能力</li><li>最大暂停时间（在进行GC时，mutator会被暂停）</li><li>堆使用效率</li><li>访问局部性</li></ul><h3 id="二：标记清除法">二：标记清除法</h3><p><em>学这一节之前想想操作系统里文件系统</em></p><p>该算法分为两步</p><ol><li>标记阶段：将所有活动对象做上标记</li><li>清除阶段：将所有没被标记的对象回收</li></ol><h4 id="标记阶段">标记阶段</h4><ol><li>通过根，找到直接引用的对象，标记</li><li>递归标记所有能访问到的对象（常用深搜，因为内存使用量更少）</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mark</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!obj.mark) </span><br><span class="line">        obj.mark = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(child: obj.children) </span><br><span class="line">        <span class="built_in">mark</span>(*child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清除阶段">清除阶段</h4><p>遍历堆，回收所有没有被标记的对象，并将其放入空闲链表，以备分配</p><h4 id="分配策略">分配策略</h4><p>在创建新对象<code>obj</code>时，遍历空闲链表，寻找合适的块，这里使用First-fit算法（因为快）</p><ul><li>First-fit：找到第一个能放下<code>obj</code>的块</li><li>Best-fit：找到最小的能放下<code>obj</code>的块</li><li>Worst-fit：找到最大的能放下<code>obj</code>的块</li></ul><h4 id="合并策略">合并策略</h4><p>分配和回收会导致大量小的分块，于是需要合并，在这里直接遍历堆，将连续的空闲块合并</p><h4 id="评价">评价</h4><p>优点</p><ul><li>实现简单</li><li>与保守式GC兼容（因为对象不会被移动）</li></ul><p>缺点</p><ul><li>碎片化，导致空间浪费，访问性能降低</li><li>不支持<strong>写时复制</strong>（比如UNIX中的<code>fork()</code>）</li></ul><h4 id="优化方案">优化方案</h4><h5 id="分级空闲链表">分级空闲链表</h5><p>使用多个空闲链表，分别只连接不同大小的分块，分配时先找所对应的区间，可以提高性能</p><h5 id="BiBOP（Big-Bag-Of-Pages）">BiBOP（Big Bag Of Pages）</h5><p>将大小相近的对象整理成固定大小的块进行管理</p><ul><li>碎片化的原因之一是杂乱散布的大小各异的对象，如果将堆固定分割，就可以减缓碎片化</li></ul><h5 id="位图标记">位图标记</h5><p>不直接堆对象进行标记，而是记录对象的标志位，存储在一个表格中</p><ul><li>与写时复制技术兼容（因为不会修改对象本身，可以复用）</li><li>清除标志位更高效（只需要把表中要清除的对象的标志位改成一个特殊值）</li></ul><h5 id="延迟标记清除法">延迟标记清除法</h5><ul><li>分配时，先调用清除，如果能清出足够的空间来分配，则直接分配，否则进行普通的标记操作</li><li>清除时，同样是First-fit遍历堆，但遍历的起点是上次开始的地点的右侧</li><li>延迟的内核是不主动清除，而是等到要分配时再清除</li></ul><h3 id="三：引用计数法">三：引用计数法</h3><p><em>学这一节前，想想智能指针</em></p><p>引用计数法中，对象会记录自己被引用次数，主要分为两个阶段</p><ol><li>创建新对象：分配内存，将对象引用次数设为1</li><li>更新指针：先增后减计数器值，若引用次数为0则回收</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新指针ptr，让其指向obj</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_ptr</span><span class="params">(ptr, obj)</span></span>&#123;</span><br><span class="line"><span class="built_in">inc_ref_cnt</span>(obj);<span class="comment">//obj要被ptr引用了，所以obj计数值++</span></span><br><span class="line">    <span class="built_in">dec_ref_cnt</span>(*ptr);<span class="comment">//ptr之前引用的东西不再被引用</span></span><br><span class="line">    *ptr = obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dec_ref_cnt</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    obj.ref_cnt--;<span class="comment">//obj不再被引用，所以计数值--</span></span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)&#123;<span class="comment">//如果obj没人用了，obj就要被清除</span></span><br><span class="line">        <span class="keyword">for</span>(child: obj.children)&#123;<span class="comment">//obj被清除了，那obj引用的对象，被引用次数要--</span></span><br><span class="line">            <span class="built_in">dec_ref_cnt</span>(*child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reclaim</span>(obj);<span class="comment">//执行回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="评价-2">评价</h4><p>优点：</p><ul><li>对象变成垃圾时立刻被回收（延迟标记清除算法要等到分块用尽后才开始回收垃圾）</li><li>最大暂停时间短（只有在更新指针的时候才会打断mutator）</li><li>减少延根指针遍历所有子节点的次数（尤其在分布式系统中，效果显著）</li></ul><p>缺点</p><ul><li>频繁进行计数值的操作</li><li>计数器本身空间比较大（32位系统的计数器就要32位大小）</li><li><strong>循环引用无法回收</strong><ul><li>如果两个物体互相引用，并不和其他对象有联系，于是他们成为了一座“孤岛”，成为了事实意义上的垃圾，但是却无法被回收（因为只要被引用，就不算垃圾）</li></ul></li></ul><h4 id="优化方案-2">优化方案</h4><h5 id="延迟引用计数法">延迟引用计数法</h5><p>解决频繁操作</p><ul><li>使用ZCT表（Zero Count Table），记录所有执行<code>dec_ref_cnt</code>后计数值变成0的对象（也就是说计数值变成0，不会立刻被视为垃圾回收），当ZCT表满了以后，开始回收表中的对象</li><li>优点：延迟了根引用的计数（只有要回收时才会一起操作），降低了计数值的操作频率</li><li>缺点<ul><li>不再能即刻回收垃圾（你可以理解为以前有垃圾就仍，现在要先堆一波垃圾再扔）</li><li>最大暂停时间延长（<code>scan_zct()</code>要访问整个ZCT，这个过程muator是被中断的）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dec_ref_cnt</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    obj.ref_cnt--;</span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)&#123;<span class="comment">//计数值变为0，可能会变成垃圾</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_full</span>($zct))&#123;</span><br><span class="line">            <span class="built_in">scan_zct</span>();<span class="comment">//如果zct表满了，就扫描zct，并回收</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push</span>($zct, obj);<span class="comment">//将obj放入zct表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scane_zct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fot</span>(r: $root)&#123;</span><br><span class="line">        (*r).ref_cnt++;<span class="comment">//根直接引用的对象的计数器++，直接引用计数时，根会极频繁改动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(obj: $zct)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">remove</span>($zct, obj);</span><br><span class="line">            <span class="built_in">delete</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fot</span>(r: $root)&#123;</span><br><span class="line">        (*r).ref_cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Sticky引用计数法">Sticky引用计数法</h5><p>解决空间浪费</p><p>32位电脑意味着可以有$2^{32}$个对象，这些对象可能都会引用<code>obj</code>，所以<code>obj</code>的计数位应当可以记录被引用$2^{32}$次，所以计数位要有32位</p><p>如果计数位太少，一些比较大的对象就无法正常表示（直接做饱和运算，汽车速度超过速度计的最大值会停在最大值处），一旦出现这种情况，我们可以</p><ul><li>什么都不做<ul><li>这会导致如果一个物体被引用的次数特别多，超出了目前表示的范围，即使他变成了垃圾也无法回收</li><li>但是，事实上绝大多数对象计数值一直在0和1间变化（生成后立刻回收），所以很少出现溢出</li><li>而且一个对象被频繁引用，说明他十分重要，十分重要的东西被回收的概率并不大</li><li>很多时候不需要保证内存永不泄露，只需要保证一段时间内不泄露就行，很多软件，用户不会一直开着的</li></ul></li><li>结合使用标记清除算法<ul><li>什么都不做，可能会导致内存耗尽，如果耗尽，那就用标记清除法清一次（相当于垃圾太多了，管不来了，就干脆来一次大扫除）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mark</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(r: $roots)&#123;</span><br><span class="line">        <span class="built_in">push</span>(*r, $stack);<span class="comment">//将所有根直接引用对象入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!$stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        obj = <span class="built_in">pop</span>($stack);</span><br><span class="line">        obj.ref_cnt++;</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt == <span class="number">1</span>)&#123;<span class="comment">//这说明obj只进栈一次</span></span><br><span class="line">            <span class="keyword">for</span>(child: obj.children)&#123;</span><br><span class="line">                <span class="built_in">push</span>(*child, $stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sweep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    index = $heap_top;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; $heap_end)&#123;<span class="comment">//遍历整个堆</span></span><br><span class="line">        <span class="keyword">if</span>(index.ref_cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">reclaim</span>(index);<span class="comment">//回收计数值为0的对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        index += index.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一位引用计数法">一位引用计数法</h5><p>是Sticky的极端，计数位只有一位（两个tag，一个MULTIPLE，一个UNIQUE），而且将计数位放在指针上，而非放在对象上</p><p><img src="/images/%E4%B8%80%E4%BD%8D%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.png" class="lazyload" data-srcset="/images/%E4%B8%80%E4%BD%8D%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="一位引用计数"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy_ptr</span><span class="params">(dest_ptr, src_ptr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">delete_ptr</span>(dest_ptr);</span><br><span class="line">    *dest_ptr = *src_ptr;</span><br><span class="line">    <span class="built_in">set_tag</span>(dest_ptr, MULTIPLE);</span><br><span class="line">    <span class="keyword">if</span>(src_ptr.tag == UNIQUE)&#123;</span><br><span class="line">        <span class="built_in">set_tag</span>(src_ptr, MULTIPLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_ptr</span><span class="params">(ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr.tag == UNIQUE)</span><br><span class="line">        <span class="built_in">reclaim</span>(*ptr);<span class="comment">//如果对象以前只被引用一次，那么这次就要被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点</p><ul><li>cache命中率高</li></ul><p>缺点</p><ul><li>同Sticky，而且更严重</li></ul><h5 id="部分标记清除法">部分标记清除法</h5><p>解决循环引用</p><p>只对可能会有循环引用的对象使用标记清除法，其他对象使用引用计数法</p><p>每个对象会有两个状态位（于是就有四个状态），分别为</p><ul><li>BLACK：绝对不是垃圾的对象（初始值）</li><li>WHILE：绝对是垃圾的对象</li><li>GRAY：搜索完毕的对象</li><li>HATCH：可能是循环垃圾的对象</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dec_ref_cnt</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    obj.ref_cnt--;</span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">delete</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(obj.color != HATCH)&#123;</span><br><span class="line">        obj.color = HATCH;</span><br><span class="line">        queue.<span class="built_in">push</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对放入队列的对象进行标记清除算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">new_obj</span><span class="params">(size)</span></span>&#123;</span><br><span class="line">    obj = <span class="built_in">pickup_chunk</span>(size);<span class="comment">//分配内存</span></span><br><span class="line">    <span class="keyword">if</span>(obj != null)&#123;<span class="comment">//如果分配成功</span></span><br><span class="line">        obj.color = BLACK;</span><br><span class="line">        obj.ref_cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!queue.<span class="built_in">empty</span>())&#123;<span class="comment">//说明现在空间不足，要回收垃圾，先看是否存在HATCH物体</span></span><br><span class="line">        <span class="built_in">scan_hatch_queue</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new_obj</span>(size);<span class="comment">//回收queue内后重新尝试分配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">allocation_fall</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scan_hatch_queue</span><span class="params">()</span></span>&#123;<span class="comment">//循环扫描队列，直至队列为空</span></span><br><span class="line">    obj = queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(obj.color == HATCH)&#123;</span><br><span class="line">        <span class="built_in">paint_gray</span>(obj);<span class="comment">//把obj和其孩子变为GRAY，孩子们引用值--</span></span><br><span class="line">        <span class="built_in">scan_gray</span>(obj);<span class="comment">//引用值&gt;0涂黑，等于0涂白</span></span><br><span class="line">        <span class="built_in">collect_while</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">scane_hatch_queue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paint_gray</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == (BLACK | HATCH))&#123;</span><br><span class="line">        obj.color = GRAY;</span><br><span class="line">        <span class="keyword">for</span>(child: obj.children)&#123;</span><br><span class="line">            (*child).ref_cnt--;</span><br><span class="line">            <span class="built_in">paint_gray</span>(*child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scan_gray</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == GRAY)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">paint_black</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            obj.color = WHITE;</span><br><span class="line">            <span class="keyword">for</span>(child: <span class="built_in">children</span>(obj))&#123;</span><br><span class="line">                <span class="built_in">scan_gray</span>(*child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paint_black</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">     obj.color = BLACK;</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))&#123;</span><br><span class="line">(*child).ref_cnt++</span><br><span class="line"><span class="keyword">if</span>((*child).color != BLACK)&#123;</span><br><span class="line"><span class="built_in">paint_black</span>(*child)            </span><br><span class="line">        &#125;          </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">collect_while</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == WHILE)&#123;</span><br><span class="line">        obj.color = BLACK;</span><br><span class="line">        <span class="keyword">for</span>(child: obj.children)&#123;</span><br><span class="line">            <span class="built_in">collect_while</span>(*child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reclaim</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点</p><ul><li>可以回收循环引用</li></ul><p>缺点</p><ul><li>一个对象要被查找三次，导致最大暂停时间+++</li></ul><h3 id="四：GC复制法">四：GC复制法</h3><p><em>想一下渲染中的双缓冲</em></p><p>先把整个空间分为等大的两部分，From和To，我们用From空间分配活动对象</p><p>GC时，把所有活动对象（递归）复制到其他空间（To空间），然后把原空间（From空间）所有对象回收，然后把空间互换</p><h4 id="评价-3">评价</h4><p>优点</p><ul><li>吞吐量大</li><li>分配速度快（Frist-fit）</li><li>不会发生碎片化（每次回收时，都会把所有对象重新排在From空间的开头，这个操作被称为<strong>压缩</strong>）</li><li>兼容缓存</li></ul><p>缺点</p><ul><li>堆效率低（因为二等分后，只能利用其中一半）</li><li>不兼容保守式GC</li><li>复制对象时要递归复制，会消耗栈，可能导致栈溢出</li></ul><h4 id="优化方案-3">优化方案</h4><h5 id="Cheney-GC复制法">Cheney GC复制法</h5><p>从递归复制改为迭代复制（基于队列的广度优先搜索）</p><p>下图搜索顺序：A BC DEFG HIJKLMNO</p><p>![Cheney GC](/images/Cheney GC.png)</p><p>优点</p><ul><li>从递归变成迭代，降低栈压力</li></ul><p>缺点</p><ul><li>不利于缓存（在上图，我们假设每个页最多存放三个块，我们发现有引用关系的对象很可能不在同一个块中）</li></ul><h5 id="近似深度优先搜索方法">近似深度优先搜索方法</h5><p>在页间做深度优先搜索，在页内做广度优先搜索</p><p>下图搜索顺序：ABC DHI EJK FLM GNO</p><p><img src="/images/%E8%BF%91%E4%BC%BC%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88.png" class="lazyload" data-srcset="/images/%E8%BF%91%E4%BC%BC%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="近似深度优先"></p><h5 id="多空间复制法">多空间复制法</h5><p>把空间分成十份，一个From，一个To，八个标记清除法</p><h3 id="五：标记压缩法">五：标记压缩法</h3><p>结合了标记清除法的标记+GC复制法的压缩</p><h4 id="Lisp2算法">Lisp2算法</h4><p><em>类比原地删除数组中某个元素</em></p><p>标记方法和标记清除法一样，标记后遍历堆，将所有活动对象压缩到左侧</p><p><img src="/images/Lisp2%E6%A0%87%E8%AE%B0.png" class="lazyload" data-srcset="/images/Lisp2%E6%A0%87%E8%AE%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Lisp2标记"></p><p><img src="/images/Lisp2%E5%8E%8B%E7%BC%A9.png" class="lazyload" data-srcset="/images/Lisp2%E5%8E%8B%E7%BC%A9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Lisp2压缩"></p><p><img src="/images/Lisp2%E7%BB%93%E6%9D%9F.png" class="lazyload" data-srcset="/images/Lisp2%E7%BB%93%E6%9D%9F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Lisp2结束"></p><p>优点</p><ul><li>比GC复制法堆效率高，比标记压缩法碎片少</li></ul><p>缺点</p><ul><li>三次遍历堆，效率过低</li></ul><h4 id="Two-Finger算法">Two-Finger算法</h4><p>这个算法优缺点很明显，所以先说优缺点，再谈实现</p><p>优点</p><ul><li>只需要两次遍历堆</li><li>不需要额外的forward指针（Lisp2的对号）</li></ul><p>缺点</p><ul><li>对象大小必须一致（可以与BiBOP结合使用）</li><li>压缩时破坏排序（一般有引用关系的对象会放在一起），于是不适合缓存</li></ul><p>在Lisp2算法中，可以说几乎每一个活动对象都需要移动，一般来说越靠近左边，移动的概率、距离越小，而越后面则越大（可以类比幽灵堵车）</p><p>我们能不能固定前面的对象，只移动后面的对象，从而实现压缩呢？（如果后面的对象和前面的对象大小一致，完全可以）</p><p><img src="/images/Two-Finger.png" class="lazyload" data-srcset="/images/Two-Finger.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Two-Finger"></p><h4 id="表格算法">表格算法</h4><p>算法分为三部：移动对象群，构建间隙表格，更新指针</p><ul><li>移动对象群（Lisp2一次移动一个对象，这个一次移动所有相邻对象）</li></ul><p><img src="/images/%E8%A1%A8%E6%A0%BC%E7%AE%97%E6%B3%95%E7%A7%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1%E7%BE%A4.png" class="lazyload" data-srcset="/images/%E8%A1%A8%E6%A0%BC%E7%AE%97%E6%B3%95%E7%A7%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1%E7%BE%A4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="表格算法移动对象群"></p><ul><li>构建间隙表格（设一个小格子尺寸为50）<ul><li>a到b：live在B开头，scan在D开头，于是将B的初始位置和B向左移动的距离$(100,100)$写到D处</li><li>b到c：<ul><li>先把间隙表格向后移动，移到FG之后，于是H处写入$(100,100)$</li><li>FG的初始位置和向左移动的距离为$(550,300)$，写入H之后（后是左边的G）</li></ul></li></ul></li></ul><p><img src="/images/%E6%9E%84%E5%BB%BA%E9%97%B4%E9%9A%99%E8%A1%A8%E6%A0%BC.png" class="lazyload" data-srcset="/images/%E6%9E%84%E5%BB%BA%E9%97%B4%E9%9A%99%E8%A1%A8%E6%A0%BC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="构建间隙表格"></p><ul><li>更新指针</li></ul><h4 id="ImmixGC算法">ImmixGC算法</h4><h3 id="六：保守式GC">六：保守式GC</h3><p>把疑似指针的一律视为指针</p><h4 id="不明确的根">不明确的根</h4><p>常见的根有</p><ul><li>寄存器</li><li>调用栈</li><li>全局变量空间</li></ul><p>在c++等语言里，<code>int</code>这种内置变量（非指针）和<code>void*</code>指针都存放在栈里，GC无法区分两者的区别，保守式GC就干脆不区分两者</p><p>存储着不确定对象的根，称为不明确的根，而基于这些根的GC算法，被称为保守式GC（ambiguous GC）</p><h4 id="检查内容">检查内容</h4><ul><li>是否<strong>位对齐</strong>（32位CPU，指针是4的倍数，64位CPU，指针是8的倍数）<ul><li>不对齐的一定是非指针</li></ul></li><li>是否指向堆内<ul><li>对象放在堆中，所以指针一定指向堆</li></ul></li><li>是否指向对象开头</li></ul><p>我们发现，有的时候我们会遇到一些格式与指针一致的非指针，我们称之为<strong>貌似指针的非指针（false pointer）</strong></p><p>在标记清除算法中，遇到这种貌似指针的非指针，会胡乱找到一个对象，我们不知道这个对象是活动对象还是非活动对象，所以<strong>一律视为活动对象</strong>，进行标记</p><p>注意：保守GC是只有当判断不出来到底是不是指针时才将其视为指针，而不是把所有对象都视为指针（迫不得已，凑合凑合用）</p><h4 id="评价-4">评价</h4><p>优点</p><ul><li>开发容易，程序员不需要意识到GC的存在</li></ul><p>缺点</p><ul><li>识别指针和非指针需要付出代价（检查内容）</li><li>将false pointer指向的错误对象视为活动对象，这些东西不会被用到，却进栈了</li><li>支持保守GC的算法不多</li></ul><h4 id="准确式GC">准确式GC</h4><p>正确的根（exact roots）可以精确地识别指针和非指针</p><p>基于正确的根的GC被称为<strong>准确式GC</strong></p><h5 id="构建正确的根的方法：打标签">构建正确的根的方法：打标签</h5><ul><li>32位CPU指针的值是4的倍数，那么其<strong>低2位</strong>一定是0</li><li>我们可以将所有非指针左移1位，然后将其<strong>低1位</strong>置为1</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打标签</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addTag</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    a = a &lt;&lt; <span class="number">1</span>;<span class="comment">//小心溢出，如果会溢出，就用一个更大的数据结构</span></span><br><span class="line">a = a|<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去标签（在使用时需要恢复成正常数值），而且使用完后还有再次打标签</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    a  = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了打标签，还可以专门构建一个只存放指针的根，比如一些使用虚拟机（VM）的语言</p><h5 id="评价-5">评价</h5><p>优点</p><ul><li>不需要判断是否为指针，没有判断带来的性能代价</li><li>堆中只会存在指针，可以适用于一些移动对象的GC算法</li></ul><p>缺点</p><ul><li>构建准确的根需要性能成本</li><li>语言使用时更麻烦</li></ul><h4 id="间接引用">间接引用</h4><p>为什么保守式GC不能移动对象？因为一个false pointer可能是一个非指针，移动会导致问题</p><h5 id="句柄">句柄</h5><p>如图，即使我们移动了堆中的对象，也却不会改变根内的内容</p><img src="/images/句柄.jpeg" class="lazyload" data-srcset="/images/句柄.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="句柄" style="zoom:50%;" /><p>优点：</p><ul><li>可以使用复制算法</li></ul><p>缺点：</p><ul><li>访问一个对象需要访问两次内存</li></ul><h4 id="MostlyCopyingGC">MostlyCopyingGC</h4><p>保守式GC复制算法</p><h4 id="黑名单">黑名单</h4><p>有的false pointer即使是非指针，错把他当指针用也可以找到一个对象（尽管这个过程是未定义的），如果这个非指针可以做到这个事，拿我们就把这个非指针指向的地址存放到<strong>黑名单</strong>中</p><p>黑名单中存放的是地址，如果在这些地址中分配空间，可能会导致未定义事件</p><p>所以在这些地址上分配对象时要十分小心，比如只能分配小对象、只能分配没有子对象的小对象，因为这些对象比较小，即使变成垃圾，被错误识别了，危害也比较小</p><h3 id="七：分代垃圾回收">七：分代垃圾回收</h3><p>引入了年龄这一概念，优先回收那些容易成为垃圾的对象</p><h4 id="年龄">年龄</h4><p>我们在引用计数法中提到过，绝大多数的对象生成后立刻会被回收，而被引用次数多多对象很难变成垃圾</p><p>于是我们引入年龄这一概念，初始为0，每经历一次GC算法，如果没有被回收，则年龄+1</p><p>我们发现年龄越大，说明对象越重要，越不容易被回收，于是年龄越大，参与回收的频率就越低</p><h4 id="评价-6">评价</h4><p>优点</p><ul><li>提高吞吐量</li></ul><p>缺点</p><ul><li>很多对象出生立刻回收只是一个经验，不适合所有程序，一旦某程序对象比较“长寿”，会起反作用</li></ul><h3 id="八：增量式垃圾回收">八：增量式垃圾回收</h3><p><em>想一想单核CPU并行的本质，就是将线程切分，来回切换</em></p><p>通过逐步推进垃圾回收来控制最大暂停时间，不一次执行完GC，而是执行一会mutator，执行一会GC</p><img src="/images/增量式GC.jpeg" class="lazyload" data-srcset="/images/增量式GC.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="增量式GC" style="zoom:50%;" /><ul><li>三色标记法</li></ul><h4 id="评价-7">评价</h4><p>优点</p><ul><li>降低最大暂停时间</li></ul><p>缺点</p><ul><li>降低了吞吐量</li></ul><h3 id="九：RC-Immix算法">九：RC Immix算法</h3><p><em>这是一个2013年的算法，听懂掌声</em></p><p>将合并型引用计数法和Immix组合到一起，改善了引用计数法的吞吐量</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大象无形UE笔记</title>
      <link href="/engine/%E5%A4%A7%E8%B1%A1%E6%97%A0%E5%BD%A2UE%E7%AC%94%E8%AE%B0/"/>
      <url>/engine/%E5%A4%A7%E8%B1%A1%E6%97%A0%E5%BD%A2UE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>UE学习笔记</h1><h2 id="基类">基类</h2><h3 id="UObject">UObject</h3><p>一切对象的基类。UE为UObject类提供了</p><ul><li>垃圾回收GC<ul><li>被<code>UProperty</code>标记的变量会自动进行生命周期管理</li><li>非UObject可以使用C++标准推荐的智能指针</li></ul></li><li>引用计数</li><li>反射</li><li>序列化<ul><li>资源的存储与加载</li></ul></li><li>自动检测默认变量的更改</li><li>自动变量初始化</li><li>与Editor的交互</li><li>运行时类型识别<ul><li>UE禁用了C++的<code>dynamic_cast</code>，你可以使用<code>Cast&lt;&gt;</code>替代</li></ul></li><li>网络复制</li></ul><h4 id="反射">反射</h4><p>反射分为静态反射和动态反射，C++没有该机制（尽管C++可以在编译时进行类型推导，但远不如Java那种<strong>Class对象</strong>的机制好用），于是UE自己做了一套</p><ul><li><p>功能</p><ul><li><p>运行时知道类、函数的所有相关信息（属性表，函数表），进而实现可视化编程（蓝图，面板）</p></li><li><p>通过函数名/类名+连续数据块访问对应函数/类</p></li></ul></li></ul><p>反射说白了就是将类、函数的信息（用哈希表）存储，运行时根据函数名、类名（key）查找信息，UE的反射是通过UBT和UHT实现的</p><ul><li>通过宏标记C++代码</li><li>UHT生成<code>.generated.h</code>和<code>.generated.cpp</code>文件</li><li>引擎初始化时注册反射信息</li></ul><h3 id="Actor">Actor</h3><p>一切实体的基类。能够被挂载组件（U）</p><h4 id="Component">Component</h4><p>基类：<code>UActorComponent</code></p><p>Component是一种属性+行为的集合</p><p><img src="/images/UEComponent.png" class="lazyload" data-srcset="/images/UEComponent.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UEComponent"></p><h4 id="通讯">通讯</h4><p>Actor之间要进行通讯，Unity可以通过获得GO引用、获得GO的组件的方式进行通讯</p><p>UE Actor的通讯方式有</p><ul><li>获取引用</li><li>Cast</li><li>接口</li><li>事件</li></ul><h3 id="Pawn">Pawn</h3><p>英语意思为棋子，指可以被操控的兵卒（可以被玩家操控，也可以被AI操控）</p><h4 id="Charactor">Charactor</h4><p>继承自Pawn，是一个更复杂的可操控角色，该角色的特点是有一种特殊的组件，Charactor Movement</p><h3 id="Controller">Controller</h3><p>控制器，负责控制Pawn、Charactor的行为</p><h2 id="命名原则">命名原则</h2><p>通过类的前缀来区分类的类型</p><table><thead><tr><th>前缀</th><th>意义</th></tr></thead><tbody><tr><td>F</td><td>纯C++类，通常为功能类</td></tr><tr><td>U</td><td>继承自UObject，但不继承自Actor</td></tr><tr><td>A</td><td>继承自Actor</td></tr><tr><td>S</td><td>Slate控件</td></tr><tr><td>H</td><td>HitResult相关类</td></tr><tr><td>T</td><td>模版类</td></tr><tr><td>E</td><td>枚举类</td></tr></tbody></table><h2 id="对象">对象</h2><h3 id="创建对象">创建对象</h3><ul><li>F类，使用new</li><li>U类，使用NewObject</li><li>A类，使用SpawnActor</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">FClass</span>();</span><br><span class="line"><span class="built_in">NewObject</span>&lt;UxxxClass&gt;();</span><br><span class="line"><span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AxxxClass&gt;();</span><br></pre></td></tr></table></figure><h3 id="UObject-2">UObject</h3><p>生命周期</p><h4 id="创建">创建</h4><ul><li>内存分配，返回一个分配好尺寸但没有初始化的指针（你steam下游戏也是先清出一片区域，再正式下载）</li><li>对象构建<ul><li>创建<code>FObjectInitializer</code></li><li>将<code>FObjectInitializer</code>作为参数传递给函数指针<code>ClassConstructor</code>，得到对象</li></ul></li></ul><h4 id="反序列化">反序列化</h4><ul><li>获取类信息<code>GetClass</code></li><li>判断类信息是否载入，若没有载入则进行预载</li><li>载入名字、Outer、类信息（类信息保存在ObjClass对象中，感觉和Java的类对象机制很接近）</li><li>载入脚本成员变量信息</li></ul><p>反序列化的规则：</p><ul><li>只反序列化<code>UPROPERTY</code>标记，且不等于默认值的数据</li><li>先创建出对象，再反序列化（还原数据）</li><li>对象具有所属关系</li><li>若一个对象所有信息和原始对象相同，尽管他们在内存的位置不同（指针值不同），该对象就是原始对象</li></ul><h4 id="释放消亡">释放消亡</h4><p>UObject无法手动释放，但是可以被请求，将其标记后等待引擎将其释放</p><p>GC分为两步，析构、回收</p><h2 id="蓝图">蓝图</h2><ul><li>UPROPERTY：注册成员变量到蓝图</li><li>UFUNCTION：注册函数到蓝图</li></ul><h2 id="引擎基础功能">引擎基础功能</h2><h3 id="正则表达式">正则表达式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Regex.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function">FString <span class="title">TextStr</span><span class="params">(<span class="string">&quot;This is a string&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">FRegexPattern <span class="title">TestPattern</span><span class="params">(TEXT(<span class="string">&quot;C.+H&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">FRegexMatcher <span class="title">TestMatcher</span><span class="params">(TestPattern, TextStr)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(TestMatcher.<span class="built_in">FindNext</span>())&#123;</span><br><span class="line">  <span class="built_in">UE_LOG</span>(MyLog, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;找到匹配内容 %d -%d&quot;</span>), </span><br><span class="line">        TestMatcher.<span class="built_in">GetMatchBeginning</span>(),</span><br><span class="line">        TestMatcher.<span class="built_in">GetMatchEnding</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径">路径</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取xxx目录路径</span></span><br><span class="line"><span class="function">FString <span class="title">FPaths::xxxDir</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断文件是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FPaths::FileExists</span><span class="params">(<span class="type">const</span> FString&amp; InPath)</span></span>;</span><br><span class="line"><span class="comment">//相对路径转化为绝对路径</span></span><br><span class="line"><span class="function">FString <span class="title">ConvertRelativePathToFull</span><span class="params">(<span class="type">const</span> FString&amp; BasePath, FString&amp;&amp; InPath)</span>；</span></span><br></pre></td></tr></table></figure><h3 id="XML">XML</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">name</span>=<span class="string">&quot;Ami&quot;</span> <span class="attr">age</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">line</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span>&gt;</span>world<span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>FXmlFile</code>或者<code>FastXML</code>操作xml文件</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FString xmlFilePath = <span class="built_in">TEXT</span>(<span class="string">&quot;xxx/Test.xml&quot;</span>);</span><br><span class="line">FXmlFile* xml = <span class="keyword">new</span> <span class="built_in">FXmlFile</span>();</span><br><span class="line">xml-&gt;<span class="built_in">LoadFile</span>(xmlFilePath);</span><br><span class="line">FXmlNode* RootNode = xml-&gt;<span class="built_in">GetRootNode</span>();</span><br><span class="line">FString from_content = RootNode-&gt;<span class="built_in">FindChildNode</span>(<span class="string">&quot;from&quot;</span>)-&gt;<span class="built_in">GetContent</span>();</span><br><span class="line">FString note_name  = RootNode-&gt;<span class="built_in">GetAttribute</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">TArray&lt;FXmlNode*&gt; list_node = RootNode-&gt;<span class="built_in">FindChildNode</span>(<span class="string">&quot;list&quot;</span>)-&gt;<span class="built_in">GetChildrenNodes</span>();</span><br></pre></td></tr></table></figure><h3 id="JSON">JSON</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FString JsonStr = <span class="string">&quot;[&#123;\&quot;author\&quot;: \&quot;Tim\&quot;&#125;, &#123;\&quot;age\&quot;: \&quot;100\&quot;&#125;]&quot;</span>;</span><br><span class="line">TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParsed;</span><br><span class="line">TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::<span class="built_in">Create</span>(JsonStr);</span><br><span class="line"><span class="type">bool</span> BFlag = FJsonSerializer::<span class="built_in">Deserialize</span>(JsonReader, JsonParsed);</span><br><span class="line">&#123;</span><br><span class="line">  FString FStringAutor = JsonParsed[<span class="number">0</span>]-&gt;<span class="built_in">AsObject</span>()-&gt;<span class="built_in">GetStringField</span>(<span class="string">&quot;autor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件">文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FPlatformFileManager::<span class="built_in">Get</span>()-&gt;<span class="built_in">GetPlatformFile</span>();</span><br></pre></td></tr></table></figure><h3 id="GConfig">GConfig</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//写配置</span><br><span class="line">GConfig-&gt;SetString(TEXT(&quot;Section&quot;), TEXT(&quot;Key&quot;), TEXT(&quot;Value&quot;), FPaths::xxxDir()/&quot;Config.ini&quot;);</span><br><span class="line">//读配置</span><br><span class="line">FString Result;</span><br><span class="line">GConfig-&gt;GetString(TEXT(&quot;Section&quot;), TEXT(&quot;Key&quot;), Result, FPaths::xxxDir()/&quot;Config.ini&quot;);</span><br></pre></td></tr></table></figure><h3 id="UE-LOG">UE_LOG</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UE_LOG</span>(log分类，log类型，log内容)；</span><br></pre></td></tr></table></figure><h3 id="字符串">字符串</h3><table><thead><tr><th></th><th>能否修改</th><th>大小写敏感</th><th>语意</th></tr></thead><tbody><tr><td>FName</td><td>无法修改</td><td>不敏感</td><td>名字，在整个字符串表只出现一次</td></tr><tr><td>FText</td><td>无法修改</td><td>敏感</td><td>被显示的字符串</td></tr><tr><td>FString</td><td>能够修改</td><td>敏感</td><td>普通字符串</td></tr></tbody></table><h3 id="图片">图片</h3><p><code>../../imagesrWrapper</code></p><h2 id="模块">模块</h2><h3 id="模块-2">模块</h3><p>模块就像Unity的Package，用于整理文件结构，便于编译</p><p>一个模块包含</p><ul><li><code>Public</code>文件夹<ul><li><code>.h</code>文件</li></ul></li><li><code>Private</code>文件夹<ul><li><code>.cpp</code>文件</li></ul></li><li><code>模块名.build.cs</code>文件（继承自<code>ModuleRules</code>类）</li></ul><h3 id="UBT">UBT</h3><p><code>Unreal Build Tool.cs</code>中有Main函数，主要做三个功能</p><ol><li>收集信息：环境变量、目录信息等</li><li>确定生成的目标类型</li><li>生成构建</li></ol><h3 id="UHT">UHT</h3><p><code>Unreal Header Tool</code>，一个基于引擎代码，但不需要引擎完全启动，编译后得到一个<code>.exe</code>文件的程序</p><h2 id="引擎核心">引擎核心</h2><p><a href="https://dev.epicgames.com/community/learning/paths/0w/beginplay">UE Begin Play</a></p><h3 id="内存分配">内存分配</h3><p>提供了多套内存分配器，其中包含TBB（TBB的内存分配一大特点就是可以通过代理的方式全局替换new、malloc等操作符），TBB见《高性能C+++》笔记，那边有详细介绍</p><p>TBB内存分配主要包括</p><ul><li>LTS，线程内存池，每个线程会独立拥有一个局部的内存池，互不影响，但最后需要归约</li><li>缓存对齐，通过在变量间填充大量无效信息，使得不同变量处于不同缓存行中，于是避免了假共享问题</li></ul><h3 id="引擎初始化">引擎初始化</h3><ul><li>PreInit<ul><li>接收cmd命令，判断启动模式</li><li>初始化游戏主线程（将当前线程当作主线程）</li><li>初始化随机数</li><li>初始化TaskGraph系统，设置线程数量，启动线程池</li><li>调用<code>LoadCoreModules</code>，启动<code>CoreUObject</code>模块</li><li>启动引擎、渲染、动画蓝图、Slate、贴图压缩、地形模块</li></ul></li><li>Init<ul><li>各个模块初始化，并执行所有<code>PostEngineInit</code>函数</li><li>进入主循环</li></ul></li></ul><h3 id="主循环">主循环</h3><p>UE是一个多线程引擎，将游戏逻辑、渲染、声音、IO等系统分离</p><p>主线程是游戏逻辑线程，内含一个while循环，循环内有一个<code>Trick</code>，可以类比Unity的Update</p><p>渲染线程数游戏逻辑线程的从属，接收来自主线程的命令，进行渲染绘制。渲染线程比逻辑线程慢一帧</p><h3 id="并发并行">并发并行</h3><ul><li><p>线程</p></li><li><p>并行</p></li><li><p>并发</p></li><li><p>Task Graph</p><ul><li>UE最强大的多线程框架，将任务抽象为Task</li><li>UE内部使用了TBB，感觉这部分内容和TBB基本一致</li><li>详情见<code>FBaseGraphTask</code>、<code>FTaskThreadBase</code></li></ul></li><li><p><code>FRunnableThread+FRunnable</code></p><ul><li>详情见<code>QueuedThreadPoolWrapper.h</code>，并不是很好用</li></ul></li></ul><h2 id="渲染">渲染</h2><h3 id="渲染线程">渲染线程</h3><p>UE的游戏线程和渲染线程分离（事实上现在基本所有引擎都这样），渲染线程是游戏线程的“附庸”</p><p>在引擎Init时，会调用<code>StartRenderingThread</code>函数，启动渲染线程</p><p>该函数主要做：</p><ol><li>创建渲染线程</li><li>从TaskGraph中取任务</li><li>注册渲染线程</li><li>注册Trick</li></ol><h3 id="运行">运行</h3><p>渲染线程的主要执行内容在<code>RenderingThreadMain</code>中，游戏线程可以通过<code>EQUEUE_Render_COMMAND</code>等宏命令向渲染线程的TaskMap中添加渲染任务，渲染线程提取这些命令后将其添加到<code>RHICommandList</code>中，最后传递到GPU中</p><p><img src="/images/%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E4%B8%8ERHI.png" class="lazyload" data-srcset="/images/%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E4%B8%8ERHI.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="渲染线程与RHI"></p><h3 id="RHI">RHI</h3><p>RHI（Render Hardware Interface），对图形库的一种封装，以供上层使用</p><table><thead><tr><th></th><th>UE5中含义</th></tr></thead><tbody><tr><td>FRenderResource</td><td>渲染线程中的资源，如贴图、顶点buffer、顶点id</td></tr><tr><td>FRHIResource</td><td>GPU侧的资源，如Texture2D、3D、Cube</td></tr><tr><td>DynamicRHI</td><td>所有图形API适配器的基类</td></tr><tr><td>RHI</td><td></td></tr><tr><td>RHIContext</td><td>RHI命令上下文</td></tr><tr><td>RHICommandList</td><td>RHI指令队列</td></tr><tr><td>FRHICommandListExecutor</td><td>将RHI指令翻译为图形API</td></tr></tbody></table><h3 id="多线程">多线程</h3><h4 id="DX11">DX11</h4><p>DX11尝试从硬件层面解决多线程渲染，提供了两种设备上下文：即时上下文（Immediate Context）和延迟上下文（Deferred Context）</p><p>延迟上下文多线程并行，最后将生成的CommandList归约到即时上下文中，由即时上下文Execute</p><p>对于某些支持硬件级加速的驱动，延迟上下文可以将CommandList也直接提交给图形驱动</p><p><img src="/images/DX11%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" class="lazyload" data-srcset="/images/DX11%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DX11多线程"></p><p>DX11的多线程，感觉就是一种简单的异步，仅仅是加速了指令录制，减少了等待</p><h4 id="DX12">DX12</h4><p>取消了DX11的渲染上下文，不再使用DrawCall，而是直接使用CommandList来调用图形驱动</p><ol><li>DX12渲染线程并行进行指令录制，生成一些命令列表（CommandList）</li><li>然后将这些命令列表提交给命令队列（CommandQueue）中</li><li>命令队列根据指令类型，将指令放入不同的GPU引擎中</li></ol><p>命令队列有三种：复制队列（Copy Queue）、计算队列（Compute Queue）、3D队列</p><p>GPU引擎有三种：复制引擎、计算引擎、3D引擎</p><p>命令队列和GPU引擎都可以并行执行</p><img src="/images/DX12多线程.png" class="lazyload" data-srcset="/images/DX12多线程.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DX12多线程" style="zoom: 50%;" /><h3 id="渲染管线">渲染管线</h3><p><img src="/images/UE5RenderingPipeline.jpg" class="lazyload" data-srcset="/images/UE5RenderingPipeline.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UE5RenderingPipeline"></p><h2 id="物理">物理</h2><p>UE5使用Chaos替代PhysX作为新的物理引擎</p><table><thead><tr><th>Chaos</th><th>PhysX</th></tr></thead><tbody><tr><td>基于位置（PBD）</td><td>基于速度</td></tr><tr><td>支持大世界坐标（LWC）</td><td>不支持</td></tr><tr><td>支持网络同步</td><td>不支持</td></tr></tbody></table><h3 id="异步">异步</h3><p>UE5可以启用异步物理模拟，物理线程会作为单独的线程运行（类似渲染线程）</p><p>由于是独立线程，物理模拟可以以固定的间隔运行，既可以提高精确度，也方便C/S网络同步</p><p>但开启异步后物理线程无法即时获取游戏线程的输入，有可能影响游戏逻辑</p><h3 id="功能">功能</h3><ul><li>布料</li><li>破坏</li><li>载具</li><li>场</li></ul><h3 id="PBD">PBD</h3><p><a href="https://matthias-research.github.io/pages/publications/PBDBodies.pdf">论文</a></p><h3 id="大世界">大世界</h3><p>World partition</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DX12龙书（一）</title>
      <link href="/graphics/DX12%E7%AC%94%E8%AE%B01/"/>
      <url>/graphics/DX12%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1>DX12</h1><h3 id="环境搭建">环境搭建</h3><p>Windows 10/11系统</p><p>安装<a href="https://devblogs.microsoft.com/pix/download/">PIX</a></p><p>安装Visual Studio 2019</p><h3 id="Windows应用程序">Windows应用程序</h3><p>Windows应用程序使用事件驱动（详情可以去看WPF）</p><p>Windows应用程序的入口点是<code>WinMain</code>函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE, LPSTR, <span class="type">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">LearnDX::D3D12HelloWindow <span class="title">sample</span><span class="params">(<span class="number">1280</span>, <span class="number">720</span>, <span class="string">L&quot;D3D12 Hello Window&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> LearnDX::Win32Application::<span class="built_in">Run</span>(&amp;sample, hInstance, nCmdShow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序会创建一个窗口，并进入消息循环，检索处理操作系统发来的消息，并对其进行相应</p><table><thead><tr><th>message</th><th>发送时机</th></tr></thead><tbody><tr><td>WM_CHAR</td><td>键盘输入一个字符</td></tr><tr><td>WM_COMMAND</td><td>使用菜单栏、控件</td></tr><tr><td>WM_CREATE</td><td>创建一个窗口</td></tr><tr><td>WM_DESTROY</td><td>一个窗口被摧毁</td></tr><tr><td>WM_LBUTTONDOWN</td><td>按下鼠标左键</td></tr><tr><td>WM_LBUTTONUP</td><td>鼠标左键被释放</td></tr><tr><td>WM_MOUSEMOVE</td><td>鼠标指针被移动</td></tr><tr><td>WM_PAINT</td><td>一个窗口需要重新粉刷</td></tr><tr><td>WM_QUIT</td><td>应用程序即将终止，WinMain返回</td></tr><tr><td>WM_SIZE</td><td>调整窗口大小</td></tr></tbody></table><p>当接收到<code>WM_QUIT</code>消息时（比如用户关闭窗口），会退出消息循环，应用程序即将结束，<code>WinMain</code>函数返回</p><h3 id="COM">COM</h3><h4 id="为什么要使用COM">为什么要使用COM</h4><blockquote><p>我们在编写C++时，经常会生成dll文件，这是一种动态库，保存了许多通用的数据和函数，运行时软件可以通过函数指针的方式导出dll的函数，从而实现运行时动态链接</p><p>当我们在同一操作系统、同一编译器环境写构建C++项目，可以复用这个dll文件。然而当你使用其他语言时，如果这个语言读不懂dll的二进制，不知道如何与之沟通，这个语言就不能使用这个dll文件。</p><p>或者另一种情况，当你更新了这个dll文件，而应用还在用老办法调用dll，很有可能也会出错</p></blockquote><p>为了解决上述问题，微软提出了<strong>组件对象模型</strong>（Component Object Model，COM），一套软件组件的二进制接口，可以实现跨编程语言的进程间通信、创建动态对象，在二进制层面打破了代码依赖</p><h4 id="COM的优点">COM的优点</h4><ul><li>软件（apps）使用抽象接口访问服务器（servers，这里指dll文件），可以使用接口指针调用COM类的成员函数</li><li>软件无需知道COM的内部实现，COM对象的创建与释放由COM自行完成</li><li>COM可能同时被多个软件使用，使用引用计数法进行GC</li><li>每个COM类都有独一无二的ID，因此内存中可以同时加载多个拥有相同接口的COM类，软件可以自行选择使用哪一个COM类</li><li>COM规定了一种特殊的layout，可以被任何支持COM的语言所解析（但可惜的是，支持COM的语言并不多，因此你还是只能用C++去写DX）</li><li>COM实际上是由指针和函数表组成（就像C++的虚函数）</li></ul><h4 id="COM的实现">COM的实现</h4><p>COM中所有接口都继承于<code>IUnknown</code>，该接口提供了三个操作</p><ul><li><code>AddRef</code>：增加引用计数的次数，每次拷贝接口指针时都会执行</li><li><code>Release</code>：减少引用计数的次数，当次数为0，释放对象</li><li><code>QueryInterface</code>：返回指向该对象的指针</li></ul><p>不过显式控制COM对象的引用过于困难，C++推荐使用智能指针</p><h3 id="DXGI">DXGI</h3><p>DirectX Graphics Infrastructure (DXGI)，负责管理一些low-level的任务，比如如何将frame呈现在显示器上，gamma矫正，屏幕刷新，交换链等</p><img src="/images/DXGI.png" class="lazyload" data-srcset="/images/DXGI.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DXGI" style="zoom:67%;" /><h3 id="依赖">依赖</h3><p>VS添加DX12依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开VS--项目--属性--配置属性--链接器--输入--附加依赖项</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%B7%BB%E5%8A%A0DX%E4%BE%9D%E8%B5%96.png" class="lazyload" data-srcset="/images/%E6%B7%BB%E5%8A%A0DX%E4%BE%9D%E8%B5%96.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230112010632277"></p><p>cmake添加依赖</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(DXEngine)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp src/*.h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(DXEngine WIN32 <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(DXEngine PUBLIC <span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 比较重要的是d3d12.lib dxgi.lib</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(DXEngine PRIVATE</span><br><span class="line">        d3d12.lib dxgi.lib dxguid.lib uuid.lib</span><br><span class="line">        kernel32.lib user32.lib</span><br><span class="line">        comdlg32.lib advapi32.lib shell32.lib</span><br><span class="line">        ole32.lib oleaut32.lib</span><br><span class="line">        runtimeobject.lib</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id="批注">批注</h3><p>VS提供了一套批注系统，SAL（Source code annotation language）</p><h3 id="字符串">字符串</h3><p>Windows的字符串是一大噩梦</p><p>代码的字符编码主要有两种，<code>ASCII</code>和<code>UNICODE</code>，Windows内部使用了utf-16存储字符串，并支持两种API，用以支持<code>ASCII</code>和<code>UNICODE</code>，他们分布以<code>A</code>和<code>W</code>结尾</p><p>为了支持两种API，于是推出了一种新的字符类型<strong>宽字符</strong>：<code>wchat_t</code>，微软将其重命名为<code>WCHAR</code></p><p>宽字符在使用时要在前面加<code>L</code>，比如<code>L'a'</code></p><p>微软又将字符串进行重命名，提出了窄字符串STR和宽字符串WSTR，并给出了他们的指针<code>LPSTR</code>和<code>LPWSTR</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LPSTR = <span class="type">const</span> <span class="type">char</span>*</span><br><span class="line">LPWSTR = <span class="type">const</span> <span class="type">wchar_t</span>*</span><br></pre></td></tr></table></figure><p>如果你用VS开发，可以设置整个项目使用<code>UNICODE</code>，但我不建议这样做</p><p>强烈推荐当你要使用字符串函数时，明确使用后缀是<code>A</code>还是<code>W</code>，并且要注意你<code>WindowProc</code>的类型（是使用<code>DefWindowProcW</code>还是<code>DefWindowProcA</code>）</p><h3 id="d3dx12-h">d3dx12.h</h3><p>这是一个<code>.h</code>文件，内含许多DX开发常用函数，将该文件复制到项目中</p><p>这个文件中使用了大量Windows SDK，因此你最好用VS2019的Toolchains（Clion的用户使用内置的MinGW可能会报一堆错）</p><p>至于为什么要求是VS2019，是因为这个文件与Windows10 SDK版本强相关，VS2019的SDK直接就是对应版本，2017需要手动下载，2015直接没法用</p><p><a href="https://stackoverflow.com/questions/65294611/d3dx12-h-gives-a-bunch-of-errors">详情</a></p><h3 id="创建第一个窗体">创建第一个窗体</h3><p>这个窗体啥也没有，就输出一个蓝色屏幕，下面是创建这个窗体的过程</p><p><img src="/images/DX%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3.png" class="lazyload" data-srcset="/images/DX%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DX创建窗口"></p><ul><li><p>WindowProc是一个回调函数，用于处理传给窗口的消息</p></li><li><p><code>OnInt()</code>是<code>D3D12HelloWindow</code>的生命周期函数，包含两个部分，加载管线和加载资源</p></li></ul><p><img src="/images/OnInit.png" class="lazyload" data-srcset="/images/OnInit.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="OnInit"></p><ul><li><p>描述符堆（Descriptor Heap），用于CPU向GPU传递资源（比如数组、贴图），告诉GPU去哪里访问这些资源</p><ul><li>描述资源的类型、维度、GPU虚拟地址、硬件信息</li><li>我们将描述符绑定在<strong>slots</strong>上，GPU可以通过访问slots上的描述符找到资源</li></ul></li><li><p>栅栏（Fence），可以将其插入命令队列以实现同步</p></li></ul><p>DX12支持多线程渲染，命令队列和命令列表的关系如下</p><p><img src="/images/DX12%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" class="lazyload" data-srcset="/images/DX12%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DX12多线程"></p><h3 id="硬件架构">硬件架构</h3><ul><li>CPU<ul><li>Cache占绝大部分面积</li><li>ALU、控制单元少，但复杂强大</li></ul></li><li>GPU<ul><li>计算核心占绝大部分面积</li><li>计算核心数量极多，个头小，可编程，支持并行</li></ul></li></ul><p><img src="/images/CPU%E5%92%8CGPU.png" class="lazyload" data-srcset="/images/CPU%E5%92%8CGPU.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CPU和GPU"></p><h3 id="渲染管线">渲染管线</h3><p><img src="/images/rendering-pipeline.png" class="lazyload" data-srcset="/images/rendering-pipeline.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="rendering-pipeline"></p><h4 id="输入汇编器">输入汇编器</h4><p>输入汇编器（Input Assembler）</p><ul><li>输入：顶点索引和顶点缓冲</li><li>行为：组装成图元</li><li>输出：传给顶点着色器</li></ul><p>网格（Mesh）是由图元（通常为三角形）组成的几何体</p><p>顶点缓冲区（vertex buffers）存储了顶点相关的数据</p><p>输入布局（Input layout）描述了顶点缓冲区的布局，为顶点属性指定语意，使得输入汇编器能读懂顶点缓冲区</p><p>索引缓冲（index buffers）内含顶点索引，通过指向顶点缓冲区来组成图元</p><p><img src="/images/Mesh.png" class="lazyload" data-srcset="/images/Mesh.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Mesh"></p><p>原始拓扑（Primitive topologies），描述了图元间的连接、邻接关系</p><p><img src="/images/topology.png" class="lazyload" data-srcset="/images/topology.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="topology"></p><p>特别的，Triangle Strip的三个顶点满足公式<br>$$<br>\Delta_i={i, i+(1+i%2), i+(2-i%2)}<br>$$</p><h4 id="光栅器">光栅器</h4><p>光栅器（Rasterizer），发生在片元着色器之前</p><ul><li>输入：NDC空间的2D图元</li><li>行为：<ul><li>剔除：裁剪掉视口外的图元，剔除背面（可选）</li><li>画线：获得图元所覆盖的像素区域</li><li>插值：根据重心坐标和顶点属性进行插值</li></ul></li><li>输出：传给片元着色器</li></ul><h3 id="资源管理">资源管理</h3><h4 id="内存">内存</h4><p>GPU可以访问四种内存</p><ul><li>专用视频内存（Dedicated video memory）：我们分配GPU资源最常用的地方</li><li>专用系统内存（Dedicated system memory）：GPU内部专用内存，应用程序不能使用</li><li>共享系统内存（Shared system memory）：CPU可见的显存，常用于CPU向GPU传递数据</li><li>CPU系统内存（CPU system memory）：CPU可以任意访问，但GPU要通过PCI-e总线访问，速度极慢</li></ul><h4 id="视图和描述符">视图和描述符</h4><p>视图=描述符≈资源指针</p><table><thead><tr><th>简称</th><th>全称</th><th>意义</th></tr></thead><tbody><tr><td>CBV</td><td>Constant buffer view</td><td>描述常量缓冲区</td></tr><tr><td>UAV</td><td>Unordered access view</td><td>常用于多线程读写</td></tr><tr><td>SRV</td><td>Shader resource view</td><td>描述只读纹理和缓冲区</td></tr><tr><td>Samplers</td><td></td><td>采样器</td></tr><tr><td>RTV</td><td>Render Target View</td><td>描述渲染目标</td></tr><tr><td>DSV</td><td>Depth Stencil View</td><td>描述深度缓冲区</td></tr><tr><td>IBV</td><td>Index Buffer View</td><td>描述顶点索引缓冲区</td></tr><tr><td>VBV</td><td>Vertex Buffer View</td><td>描述顶点缓冲区</td></tr><tr><td>SOV</td><td>Stream Output View</td><td>描述流输出缓冲区</td></tr></tbody></table><h4 id="资源状态">资源状态</h4><p>资源的多线程读写是冲突的，于是要通过资源状态实现互斥</p><p>GPU使用转化资源的状态来指定资源的预期用途，比如要读一张贴图，该贴图必须处于读取状态</p><p>DX12使用<code>ResourceBarrier</code>管理资源状态</p><h4 id="根签名">根签名</h4><p>在HLSL中，我们可以声明一个变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Texture2D g_texture : register(t0);</span><br></pre></td></tr></table></figure><p>该变量的类型是SRV，绑定到<code>t</code>的第0槽</p><ul><li><code>t</code>：SRV</li><li><code>s</code>：Samplers</li><li><code>u</code>：UAV</li><li><code>b</code>：CBV</li></ul><h3 id="管道状态">管道状态</h3><p>管道状态（pipeline state object ，PSO）定义了渲染管线的每个阶段的行为，PSO创建后不可变</p><p><img src="/images/PSO.png" class="lazyload" data-srcset="/images/PSO.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PSO"></p><h3 id="Bundles">Bundles</h3><p>捆绑包（Bundles），用于将少量命令组合在一起，方便使用</p><p>Bundles只能提交给CommandList，不能直接提交给命令队列</p><h3 id="常量缓冲区">常量缓冲区</h3><p>就是CBuffer，是一种访问延迟更低，适合CPU高频更新的缓冲区</p><p>在着色器程序执行期间，常量缓冲区不会发送改变</p><p>常量缓冲区需要256字节<strong>对齐</strong>，一般使用4KB或者64KB（关于为什么要对齐、什么是假引用、缓存行，可以去看《高性能C++》笔记）</p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DX12 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TA面试题</title>
      <link href="/graphics/TA%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/graphics/TA%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>TA面试题</h1><p>这里面不少答案都是我自己凭感觉答的，不保真</p><h4 id="什么是渲染管线">什么是渲染管线</h4><p><strong>渲染管线</strong>是通过安排CPU发出Draw Call的内容以及顺序，指导GPU进行一系列操作，并协同将开发者期待的图像渲染在屏幕上</p><ul><li>剔除</li><li>渲染</li><li>后处理</li></ul><h4 id="什么是Draw-Call">什么是Draw Call</h4><p>Draw Call是CPU为GPU准备渲染数据，并指令GPU进行一次渲染的操作，是重量级的</p><h4 id="什么是Batching">什么是Batching</h4><p>将多个简单、使用同一材质的物体合并渲染的方式叫Batching</p><p><em>batch是批的意思</em></p><h4 id="渲染管线的渲染流程">渲染管线的渲染流程</h4><ul><li><p>延迟着色阶段（光栅化）Deferred Shading (rasterization)</p></li><li><p>直接阴影阶段（光线追踪或光栅化）Direct shadows (ray trace or rasterization)</p></li><li><p>光照阶段（计算着色器+光线追踪）Lighting (compute + ray trace)</p></li><li><p>反射阶段（光线追踪或计算着色器）Reflections(ray trace or compute)</p></li><li><p>全局光照阶段（计算着色器+光线追踪）Global Illumination (compute and ray trace)</p></li><li><p>环境光遮蔽阶段（光线追踪或计算着色器） Ambient occlusion (ray trace or compute)</p></li><li><p>透明与半透明渲染阶段（光线追踪+计算着色器）Transparency &amp; Translucency (ray trace and compute)</p></li><li><p>后处理阶段（计算着色器）Post processing (compute)</p></li></ul><h4 id="渲染流水线的基本流程">渲染流水线的基本流程</h4><p>渲染就是从一个三维场景出发，获得一个二维图像的过程。分为四个过程，应用阶段、几何阶段、光栅化阶段、像素处理阶段，其中几何阶段光栅化阶段主要在GPU中进行。</p><p>几何阶段分为五个步骤：顶点着色器、曲面细分着色器、几何着色器、裁剪、屏幕映射</p><p>光栅化阶段分为四个步骤：三角形设置、三角形遍历、片元着色器、逐片元操作</p><img src="/images/pipeline.png" class="lazyload" data-srcset="/images/pipeline.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1" style="zoom:33%;" /><h5 id="什么是顶点着色器">什么是顶点着色器</h5><ul><li><p>输入值是CPU通过Draw Call发出的顶点数组（没有索引）</p></li><li><p>输出值是齐次裁剪空间坐标（如果不使用细分着色器和几何着色器）</p></li></ul><h5 id="什么是细分着色器">什么是细分着色器</h5><ul><li><p>在显卡中**视口变换器(Viewport Transform)**中实现</p></li><li><p>将复杂的曲面转化为简单的点、线、三角形，可以增加网格细度，并在细分后的顶点上生成插值属性</p></li><li><p>如果使用了曲面细分着色器，顶点着色器就不会处理空间变化（如果没有顶点动画的需求，顶点着色器只负责传递数据），而是交给曲面着色器和几何着色器</p></li><li><p>在不改变网格外形的情况下，对网格进行平滑操作</p></li></ul><h5 id="什么是几何着色器">什么是几何着色器</h5><ul><li>在视口变换器中实现，输出值是齐次裁剪空间</li><li>能改变顶点数量</li><li>能按索引访问顶点</li></ul><h5 id="什么是网格着色器">什么是网格着色器</h5><ul><li>新一代三合一着色器，用于整合顶点、细分、几何着色器</li><li>可以实现无矩式渲染</li></ul><h5 id="屏幕映射">屏幕映射</h5><ul><li>输入齐次裁剪空间</li><li>（通过透视除法）转化到<strong>归一化设备坐标(NDC)</strong>，最后输出屏幕空间坐标</li></ul><h4 id="什么是渲染路径">什么是渲染路径</h4><p><strong>渲染路径</strong>是一系列对光照和着色(尤其是光照)的控制选项的集合</p><p>主流引擎支持前向渲染，延迟渲染，和自定义渲染</p><ul><li>前向渲染<ul><li>批次数=相机数x对象数x（除了主有向平行光外的逐片元光照数+1）</li><li>随着片元光照数量增多，性能大幅下降</li></ul></li><li>延迟渲染<ul><li>类似一种后处理</li><li>批次数=相机数x（网格数+逐片元光照数）</li><li>将几何通路和光照渲染通路分开，几何通道结果输送到G-Buffer中，然后对每个像素只进行一次光照计算</li></ul></li><li>自定义渲染<ul><li>屏幕后处理、天空盒、透明物体</li></ul></li></ul><h4 id="延迟渲染">延迟渲染</h4><h5 id="为什么延迟渲染不支持透明度混合">为什么延迟渲染不支持透明度混合</h5><p>因为半透明网格在G-Buffer中会被其他片元覆盖</p><h5 id="为什么延迟渲染不支持真的对抗锯齿">为什么延迟渲染不支持真的对抗锯齿</h5><p>因为G-Buffer需要的带宽远远大于帧缓冲，在多重抗锯齿下难以满足负载</p><h4 id="前向渲染">前向渲染</h4><p>前向渲染的渲染通路（Pass）有两种，分布是<strong>基本通路（forwardbase）<strong>和</strong>附加通路（forwardadd）</strong></p><p><strong>forwardbase</strong></p><ul><li>对所有的默认的<strong>有向平行光源</strong>及其产生的阴影进行逐片元计算，同时对其它基于顶点的和基于球谐光照的光源，以及物体的自发光、统一环境光和光照贴图进行计算</li><li>只对一个有效灯光执行一次，所以只会执行一次</li></ul><p><strong>forwardadd</strong></p><ul><li>对剩下的<strong>使用逐片元光照的光源</strong>进行光照计算</li><li>必须和forwardbase一同使用，不然会被忽略掉</li><li>对forwardbase外所有有效灯光都执行一次，所以会执行多次</li></ul><h4 id="向量">向量</h4><h5 id="向量点乘叉乘的几何意义">向量点乘叉乘的几何意义</h5><p>点乘是投影，叉乘是法向量（方向符合右手定则，沿大拇指方向）</p><h5 id="向量点乘叉乘的数学意义">向量点乘叉乘的数学意义</h5><p>$\mathbf{a} =\left( x_{1},y_{1},z_{1}\right)  $</p><p>$\mathbf{b} =\left( x_{2},y_{2},z_{2}\right)  $</p><p>$\mathbf{a} \cdot \mathbf{b} =|\mathbf{a} ||\mathbf{b} |\cos \theta =x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}$</p><img src="/images/叉积.png" class="lazyload" data-srcset="/images/叉积.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="叉积" style="zoom: 67%;" /><h5 id="求向量-mathbf-a-关于向量-mathbf-b-的对称向量-mathbf-c">求向量$\mathbf{a}$关于向量$\mathbf{b}$的对称向量$\mathbf{c}$</h5><p>$\mathbf{a} \cdot \mathbf{b}=\mathbf{c} \cdot \mathbf{b}$</p><p>$|\mathbf{a} |=|\mathbf{c} |$</p><h5 id="求点M关于直线l的对称点N">求点M关于直线l的对称点N</h5><p>M和N的中点在直线上</p><p>$\overrightarrow{MN} $与直线垂直</p><h4 id="欧拉角是什么？有何优缺点">欧拉角是什么？有何优缺点</h4><p>欧拉角是一个直观利用三维向量表达旋转的方法</p><p>优点：占用的空间小，不会遇到非法输入</p><p>缺点：没有统一标准、不能跨平台；三个分量可能不正交，可能有无法表示的角度；不能插值运算</p><h4 id="图形渲染用到哪些空间">图形渲染用到哪些空间</h4><ul><li>顶点着色器：模型空间–M–世界空间–V–观察空间–P–齐次裁剪空间----屏幕空间</li></ul><h4 id="什么是模版测试">什么是模版测试</h4><p>将屏幕的部分像素通过一个通道盖住，在渲染时剔除通道上不满足条件的值</p><h4 id="如何渲染半透明物体">如何渲染半透明物体</h4><ul><li>透明度测试</li><li>透明度混合</li></ul><h4 id="如何优化着色器代码">如何优化着色器代码</h4><ul><li>复杂计算放在顶点着色器中</li><li>简化等式，比如说：p = sqrt(2*(X+1))可以改写成1.414*sqrt(X+1)等</li><li>尽量使用内建函数</li><li>重复度低的操作可以交给CPU</li><li>使用顺序结构代替分支</li><li>丢弃片元时直接将alpha设为0</li><li>纹理图尽量使用2的n次方大小</li><li>将许多小纹理拼成一个大纹理</li><li>近点采样能满足要求就不要使用线性采样</li></ul><h4 id="如何判断多边形是凸多边形">如何判断多边形是凸多边形</h4><ul><li>角度法：内角是否小于180°</li><li>凸包法：如果凸包和原始多边形点数一样多，那么就是凸多边形</li><li>顶点凹凸性：本质上还是角度法，就是相邻顶点组成向量叉乘</li></ul><h4 id="相交测试">相交测试</h4><p><em>见图形学笔记</em></p><h4 id="法线贴图">法线贴图</h4><p>纹理就是贴图</p><p>法线纹理用RGB三个通道分布存储法向量在XYZ轴上分量大小</p><p>由于法线贴图大部分文素的方向都是朝向法线方向，于是法线贴图大多是蓝色的</p><h4 id="如何渲染阴影">如何渲染阴影</h4><ul><li>体积阴影法</li><li>深度阴影法</li></ul><h4 id="什么是HDR">什么是HDR</h4><p>高动态范围，一种颜色缓冲技术，使用更高的精度来表示亮度，能更真实的反应光照</p><p>HDR通过色调映射转到LDR</p><h4 id="什么是伽马矫正">什么是伽马矫正</h4><p>早期摄像机通过伽马加码，将实际亮度存储为更亮的值，显示时通过该骂解码获得正确的功率</p><h4 id="什么是色调映射">什么是色调映射</h4><p>就是利用显示器有限的亮度范围来近似实现HDR，就是将亮度映射到[0,1]的范围内，并压缩到8位的渲染目标上</p><h4 id="什么是PBR">什么是PBR</h4><p>基于物理的渲染</p><h4 id="正交投影和透视投影的区别">正交投影和透视投影的区别</h4><ul><li>都是源于对针孔摄像机对数学建模</li><li>视锥形状不一样</li></ul><h4 id="什么是齐次坐标">什么是齐次坐标</h4><p>为了实现仿射变换，将三维顶点引入四维空间，这个空间叫做齐次坐标空间</p><h4 id="旋转平移矩阵">旋转平移矩阵</h4><p><em>见图形学笔记</em></p><h4 id="高光模型">高光模型</h4><p>漫反射模型</p><ul><li>Lambert模型：反射光强度和 表面法线和光源的夹角的 余弦值成正比</li><li>半Lambert模型：光照有一个保底值，于是没有黑面</li><li>Minnaert模型：用于模拟丝绒</li><li>Oren-Nayar模型：风之旅人的沙子</li></ul><p>高光反射模型</p><ul><li>Phong模型：纯几何的经验模型，就是在Lambert漫反射上加了一点高光，强度与 视角方向和反射光方向的夹角的 余弦值成正比</li><li>Blinn-Phong模型：Phong的改进，不计算反射光，而是计算视角方向和光源方向的角平分矢量h，用h替代反射方向计算高光</li><li>Schlick模型：对BP模型的优化，简化一些运算，能获得更类似于油漆的效果</li></ul><p>基于物理的模型</p><ul><li>Cook-Torrance模型</li></ul><h4 id="什么是光栅化">什么是光栅化</h4><p>是渲染流水线的一个重要阶段</p><p>三角形设置和三角形遍历可以合成光栅化，计算三角网格，并进行线性插值</p><h4 id="阴影，软阴影">阴影，软阴影</h4><h4 id="什么是抗锯齿">什么是抗锯齿</h4><p>锯齿是走样的一种，指在渲染三角形、线的时候，像素要么存在，要么不存在，于是出现锯齿现象</p><ul><li>SSAA，超级采样抗锯齿，翻倍渲染向下采样</li><li>MSAA，多重采样抗锯齿，每个像素内有多个采样点，渲染时以点数加权获得（性能好，不支持延迟渲染）</li><li>FXAA/TXAA，放弃精度，让边缘模糊</li></ul><h4 id="延时渲染">延时渲染</h4><p>场景中有大量实时光源时，前向渲染效率会下降，使用两个Pass，一个不计算光照，只计算片元是否可见</p><p>不支持抗锯齿，不能处理透明物体</p><h4 id="故障检测">故障检测</h4><h4 id="后处理">后处理</h4><ul><li>亮度饱和度对比度</li><li>边缘检测</li><li>高斯模糊</li><li>动态模糊</li><li>Bloom效果</li></ul><h4 id="贴图技术">贴图技术</h4><p>贴图就是纹理</p><h4 id="BRDF">BRDF</h4><p>双向反射分布函数</p><h4 id="作品集里实现原理">作品集里实现原理</h4><p>ezy-slice原理：网格中存储了顶点数据、三角形数据、法线数据，使用MeshFilter获得sharemesh（mesh是新网格，sharemesh是原始网格）</p><p>物体的节点和三角形被分为三个部分（上下和切割面），相交处的三角形做分割操作，然后让原始网格不可见</p><h4 id="如何区分位置和方向">如何区分位置和方向</h4><p>齐次坐标，w==0就是位置，w==1就是方向</p><h4 id="SSAO">SSAO</h4><p>SS（Screen Space），都是后处理</p><p>SSGI屏幕空间全局光照</p><p>SSAO屏幕空间环境光遮蔽，对屏幕空间上每一个片元，在其法线范围的半球体中进行采样，采样点在深度纹理采样，从而判断该点是否被遮蔽</p><p>一般来说使用SSAO后还要在进行一次模糊，还需要进行时域平滑来避免闪动</p><h4 id="SSR">SSR</h4><p>SSR屏幕空间反射，在相机中发射出n条光线，然后根据物体的法向量和摄像机的射线方向计算出这条光线的反射方向。再对他进行raymarch（光线步进）计算。</p><h4 id="动态模糊">动态模糊</h4><p>种类</p><ul><li>相机动态模糊</li><li>对象动态模糊</li></ul><p>原理</p><ul><li>保存多帧数据进行混合</li><li>速度映射图，图中存储了每一个像素的速度，沿着这个速度采集像素，进行加权混合，得到模糊效果</li></ul><h4 id="线框">线框</h4><h5 id="方法1-深度偏移（这玩意不是线框，是描边）">方法1:深度偏移（这玩意不是线框，是描边）</h5><p>使用两个Pass渲染，一个正常渲染，一个在深度偏移的情况下渲染一遍线</p><ul><li>两个Pass有性能损失</li><li>深度偏移是为了防止线条被遮挡，这会导致多边形和线框在相同位置的片元的深度值不一样</li></ul><h5 id="方法2-几何着色器（这才是线框）">方法2:几何着色器（这才是线框）</h5><p>几何着色器可以使用索引数组访问顶点的拓扑结构</p><p>线框渲染可以使用几何着色器访问三角形，并计算每个顶点到对边的垂线长度，于是通过插值获得三角形中每个点到三角形三个边的最短距离</p><p>我们知道在光栅化阶段要插值上色，那么我们可以在插值的时候进行判断，当垂线距离符合条件时（离三角形边特别近）就染上线框的颜色</p><h4 id="片元着色器和像素着色器的区别">片元着色器和像素着色器的区别</h4><p><em>在大部分情况下没有区别</em></p><p>在极个别情况下（大概是OpenGL那边）我门认为如果片元着色器中的输入数据是恰好覆盖屏幕的四边形时，这个片元着色器被称为像素着色器</p><h4 id="SDF">SDF</h4><p>距离函数</p><p>shadertoy的本质就是通过编写（2D）距离函数来绘制物体</p><h4 id="为什么shader中少用分支和循环">为什么shader中少用分支和循环</h4><p>因为在gpu中，分支的实现原理是两个分支都执行，然后丢弃不需要的分支，这个增长是指数级的（2^n^）</p><h4 id="什么是Cubemap">什么是Cubemap</h4><p>立方体纹理，是实现环境映射的一种方法</p><h4 id="什么是光照探针">什么是光照探针</h4><p>是一组封装后的Cubemap，在烘培或预计算时，对空间中的一些采样点（光照探针）采集Cubemap，在运行环境渲染运动物体时，CPU会从离物体最近的光照探针中获取Cubemap，按照距离进行插值。</p><p>这个过程实现了CPU和GPU的解耦，CPU只需要维护一组固定的光照探针组，GPU只需要处理与这个物体相关的临近Cubemap</p><p>通过光照探针获取环境景象需要对场景进行六次渲染（毕竟有六个面）</p><h4 id="什么是球偕函数">什么是球偕函数</h4><p>将真实环境中连续的光照方程进行离散化，通过球形坐标系分解简化反射方程，通过球偕变换获得球偕系数，在运行时根据球偕系数重建方程</p><p>采样-分解-变换-重构</p><h4 id="参数和分量">参数和分量</h4><p>参数是黑盒，分量是白盒（你可以理解的是，别人在unity面板上拖动的属性多半是参数，一种东西的组成是分量，比如颜色可能就有由高光、漫反射等分量）</p><h4 id="为什么次表面散射用漫反射做高斯模糊">为什么次表面散射用漫反射做高斯模糊</h4><p>因为lambert的光照强度与入射光线和法线夹角有关，而折射和反射的比例也与这个夹角有关（菲涅尔）</p><p>折射光是次表面散射的入射光，折射的光越强，散射的光也会越强</p><h4 id="什么是光线步进">什么是光线步进</h4><p><strong>光线步进（raymarching）</strong>：从摄像机位置向屏幕每一个像素点发射一条光线，光线按照一定步长前进，并检测当前光线是否位于物体表面，据此调整光线前进幅度，直到抵达物体表面，再按照一般光线追踪的方法计算颜色值。</p><h4 id="什么是MC算法">什么是MC算法</h4><p>**步进立方体算法（Marching Cube）**是一种在密度场中采样来生成多边形的算法，在生成多边形之后再依照多边形渲染的过程进行正常的渲染。 相比射线扫描算法，步进立方体算法可以生成并保存多边形，所以在密度场的修改频率不高的情况下，使用步进立方体算法可以节省很多不必要的性能消耗。</p><p>核心：确定等值面</p><h4 id="什么是屏幕空间阴影纹理">什么是屏幕空间阴影纹理</h4><p>对于多光源的情况，每个光源都可以产生一个深度阴影纹理。在着色器中对这些深度阴影纹理逐个进行处理，可以得到若干个屏幕空间的阴影纹理，将这些屏幕空间下的阴影纹理混合就可得到一个总的屏幕空间阴影纹理，它表示了在屏幕空间中某个片元接受到的来自所有光源产生的阴影强度的总和</p><h4 id="什么是URP">什么是URP</h4><p>unity内的**渲染管线（Render pipelines）**包括</p><ul><li>内置渲染管线（Build-in）</li><li>可编程渲染管线（Scriptable Render Pipeline，SRP）<ul><li>高清渲染管线（High Definition Render Pipeline，HDRP）</li><li>通用渲染管线（Universal Render Pipeline，URP）</li></ul></li></ul><h4 id="什么是滤波模式">什么是滤波模式</h4><p>纹素坐标是整数值，但UV坐标不是，所以要有一种方法由UV坐标获得纹素值</p><h5 id="最近相邻滤波-Nearest-neighbor-filtering，或者Point-sampling">最近相邻滤波(Nearest neighbor filtering，或者Point sampling)</h5><ul><li><p>UV坐标 x 纹理大小，然后四舍五入取最近的纹素</p></li><li><p>有明显的像素块</p></li></ul><h5 id="双线性滤波-Bilinear-filtering，或者liner-filtering">双线性滤波(Bilinear filtering，或者liner filtering)</h5><ul><li>根据一个坐标到其附近最近的四个像素点的距离进行加权平均，得到一个混合的颜色</li></ul><img src="/images/双线性滤波.png" class="lazyload" data-srcset="/images/双线性滤波.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="双线性滤波" style="zoom: 33%;" /><h5 id="三线性滤波-Trilinear-filtering">三线性滤波(Trilinear filtering)</h5><ul><li>在相邻的两个Mipmap层次上分别进行双线性滤波，再对得到的两个值进行线性插值</li><li>当距离非常大或非常小的时候，三线性滤波会退化为双线性滤波</li></ul><h5 id="各项异性滤波-Anisotropic-filtering">各项异性滤波(Anisotropic filtering)</h5><p>当一个目标表面和透视摄像机之间的角度较大时，纹理的填充面积实际上并不是正方形，这引入了模糊和闪烁等瑕疵</p><ul><li>需要在一个非正方形区域内采样和混合</li><li>有的使用长方形，有的使用梯形</li></ul><h4 id="什么是纹理映射">什么是纹理映射</h4><p><em>就是将三维的空间坐标点转化为二维的纹理坐标点</em></p><p><strong>步骤</strong>：</p><ol><li>投影映射</li><li>变换函数</li><li>纹理采样</li><li>纹理转换</li></ol><h4 id="什么是纹理压缩">什么是纹理压缩</h4><p>这是一种有损压缩，对于一张原始纹理，会创建两张小纹理A和B，同时还有一个矩阵M，M的行列和原始纹理的长宽一致，里面的值类似于调色板中的索引，实现纹理A和纹理B的混合</p><h4 id="GPU的寻址方式">GPU的寻址方式</h4><h5 id="集成显卡">集成显卡</h5><p>对集成显卡来说，GPU使用CPU专门划分出来的一份内存空间**UMA（Unified Memory Architecture，一致性储存架构）**作为显存，GPU和CPU使用不同的虚拟地址对UMA中同一个物理地址进行寻址，两者共享总线。</p><p>在渲染时，CPU将顶点数据存储到主存中，然后GPU通过**GART(Graphic Address Remapping Table，显存地址重定位表)**访问UMA</p><h5 id="独立显卡">独立显卡</h5><p>独立显卡中CPU和显卡的沟通是使用异步的**DMA(Direct Memory Access，内存直接访问)**实现的。</p><ol><li>CPU将DMA命令从内存中读取，并写入DMA控制器</li><li>DMA控制器直接操控内存总线，在不依赖CPU的情况下将数据传输给显卡驱动</li><li>显卡驱动给DMA控制器发送信息（握手）</li><li>DMA占用内存总线，向内存请求地址，向显卡发送信号</li><li>显卡接受信号后将数据传输到内存，并清除DMA请求信号</li><li>沟通结束，触发一次CPU中断</li></ol><h4 id="CPU和GPU分支预测方式有何差别">CPU和GPU分支预测方式有何差别</h4><h5 id="CPU">CPU</h5><p>CPU在流水线中进行分支预测</p><ul><li>静态分支预测</li><li>动态分支预测</li><li>协同分支预测</li></ul><h5 id="GPU">GPU</h5><p>将两个结果都运行一次，然后丢弃不需要的分支，这样会严重影响性能（指数级），这个现象被称为<strong>线路分歧</strong></p><h4 id="纹理数据在GPU中是如何排列的">纹理数据在GPU中是如何排列的</h4><p>纹理存储器中的数据以一维/二维/三维数组的形式存储在显存中，可以通过缓存加速访问</p><p>在kernel中访问纹理存储器的操作称为<strong>纹理拾取(texture fetching)</strong></p><p>将显存中的数据与纹理参照系关联的操作，称为将数据与<strong>纹理绑定(texture binding)</strong></p><h4 id="shader中的变量类型（OpenGL）">shader中的变量类型（OpenGL）</h4><h5 id="uniform">uniform</h5><p>在顶点着色器和片元着色器中的声明方式完全一样，可以视为被双方共享的全局变量</p><h5 id="attribute">attribute</h5><p>只能在顶点着色器中使用的变量，一般用于存储顶点的位置、法线、uv、颜色信息</p><h5 id="varying">varying</h5><p>顶点着色器和片元着色器之间做数据传输用的变量，必须保证在两者中声明保持一致</p><h4 id="如何保证顶点着色器传入片元着色器的数据一致性">如何保证顶点着色器传入片元着色器的数据一致性</h4><p>varying变量声明一致？</p><h4 id="矩阵乘法">矩阵乘法</h4><p>两条直线的交点就是C的位置</p><img src="/images/矩阵乘法.png" class="lazyload" data-srcset="/images/矩阵乘法.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="矩阵乘法" style="zoom:50%;" /><p>x左乘A</p><p><img src="/images/x%E5%B7%A6%E4%B9%98A.png" class="lazyload" data-srcset="/images/x%E5%B7%A6%E4%B9%98A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="x左乘A"></p><p>x右乘A</p><img src="/images/x右乘A.png" class="lazyload" data-srcset="/images/x右乘A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="x右乘A" style="zoom:50%;" /><h4 id="直线扫描转化法">直线扫描转化法</h4><h5 id="数值微分法DDA">数值微分法DDA</h5><p>思想：步进和通过舍入选择像素</p><p>$P_{0}(0,0)$到$P_{1}(5,2)$</p><p>k=0.4</p><table><thead><tr><th>$i$</th><th>$x_{i}=x_{i-1}+1$</th><th>$y_{i}=y_{i-1}+k$</th><th>$round(y_{i})$</th><th>坐标</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>(0,0)</td></tr><tr><td>1</td><td>1</td><td>0+0.4=0.4</td><td>0</td><td>(1.0)</td></tr><tr><td>2</td><td>2</td><td>0.4+0.4=0.8</td><td>1</td><td>(2,1)</td></tr><tr><td>3</td><td>3</td><td>0.8+0.4=1.2</td><td>1</td><td>(3,1)</td></tr><tr><td>4</td><td>4</td><td>1.2+0.4=1.6</td><td>2</td><td>(4,2)</td></tr><tr><td>5</td><td>5</td><td>1.6+0.4=2.0</td><td>2</td><td>(5,2)</td></tr></tbody></table><h5 id="中点画线法">中点画线法</h5><p>相比于DDA算法，省去了浮点数运算</p><p>直线方程$F(x,y)=Ax+By+C=0$，若$F(x,y)&gt;0$则位于直线上方，若$&lt;0$则位于直线下方，若$=0$则在点上</p><p>使用步进思想，根据<strong>中点误差项</strong>判断是向右移动还是向右上移动（如果0&lt;k&lt;1)</p><img src="/images/中点画线.png" class="lazyload" data-srcset="/images/中点画线.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="中点画线" style="zoom: 33%;" /><p>直线已经经过点$P$，下一步经过了点$P_{u}$和$P_{d}$，他们的中点是M，我们将M带入直线方程，通过判断大小来决定是不是</p><p>为了进一步降低消耗，使用步进，每一次就将点$P(x_{i}+1,y_{i}+0.5)$带入直线方程$Ax+By+C=0$</p><ul><li><p>d&lt;0就取右边的点，$d_{i+1}=d_{i}+A+B$</p></li><li><p>d&gt;0就取右上的点，$d_{i+1}=d_{i}+A$</p></li></ul><p>只不过我们只关心符号，所以可以用2d代替d</p><ul><li><p>d&lt;0就取右边的点，$d_{i+1}=d_{i}+2A+2B$</p></li><li><p>d&gt;0就取右上的点，$d_{i+1}=d_{i}+2A$</p></li></ul><h5 id="Bresenham画线法">Bresenham画线法</h5><p>本质上和中点画线一样</p><ul><li><p>$d_{i}&lt;0$就取右边的点，$d_{i+1}=d_{i}+2\Delta y$</p></li><li><p>$d_{i}\geqslant 0$就取右上的点，$d_{i+1}=d_{i}+2\Delta y-2\Delta x$</p></li><li><p>$d_{1}=2\Delta y-\Delta x$</p></li></ul><p>$P_{0}(0,0)$到$P_{1}(5,2)$</p><p>k=0.4</p><p>$\Delta y=2$</p><p>$\Delta x=5$</p><table><thead><tr><th>$i$</th><th>$d_{i}$</th><th>$x_{i}$</th><th>$y_{i}$</th><th>坐标</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>(0,0)</td></tr><tr><td>1</td><td>$d_{1}=2\Delta y-\Delta x=-1&lt;0$</td><td>1</td><td>0</td><td>(1.0)</td></tr><tr><td>2</td><td>$d_{2}=d_{1}+2\Delta y=3&gt;0$</td><td>2</td><td>1</td><td>(2,1)</td></tr><tr><td>3</td><td>$d_{3}=d_{2}+2\Delta y-2\Delta x=-3&lt;0$</td><td>3</td><td>1</td><td>(3,1)</td></tr><tr><td>4</td><td>$d_{4}=d_{3}+2\Delta y=1&gt;0$</td><td>4</td><td>2</td><td>(4,2)</td></tr><tr><td>5</td><td>$d_{5}=d_{4}+2\Delta y-2\Delta x=-5&lt;0$</td><td>5</td><td>2</td><td>(5,2)</td></tr></tbody></table><h4 id="构建贝塞尔曲线">构建贝塞尔曲线</h4><h5 id="一阶">一阶</h5><p>两个点$P_{0},P_{1}$</p><p>直接坐标线形插值</p><p>$B_{1}(t)=(1-t)P_{0}+tP_{1}$</p><h5 id="二阶">二阶</h5><p>三个点$P_{0},P_{1},P_{2}$</p><p>先求$P_{0}P_{1}$和$P_{1}P_{2}$的一阶贝塞尔，然后再对两个一阶进行线性插值</p><h5 id="n阶">n阶</h5><p>$$<br>B_{i,n}\left( t\right)  =\frac{n!}{i!\left( n-i\right)  !} t^{i}\left( 1-t\right)^{n-i}<br>$$</p><ul><li>$i$是第几项，从0开始</li><li>$n$是控制点总数</li></ul><h4 id="线段的裁剪">线段的裁剪</h4><h5 id="Cohen-Sutherland">Cohen-Sutherland</h5><p>尽量避免求交运算</p><p>编码，把空间分为九个部分，其中中间部分是屏幕，其outcode编码为</p><img src="/images/裁剪.png" class="lazyload" data-srcset="/images/裁剪.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="裁剪" style="zoom:50%;" /><p>判断时，两个端点的outcode值为$o_{1}和o_{2}$</p><ul><li>若$o_{1}=o_{2}=0（其实是0000）$：说明两个点都在屏幕中间</li><li>若$o_{1}\neq 0,o_{2}=0（12顺序可以颠倒）$：说明一个在屏幕内，一个在屏幕外，而非零端点的编码说明了线段与裁剪窗口哪一个边（或者两个边）相交，需要计算交点</li><li>若$o_{1}&amp;o_{2}\neq 0$：说明两个点在裁剪窗口的同一侧，可以直接丢弃</li><li>若$o_{1}&amp;o_{2}= 0$：需要计算交点</li></ul><h5 id="Liang-Barsky">Liang-Barsky</h5><img src="/images/梁友栋.png" class="lazyload" data-srcset="/images/梁友栋.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="梁友栋" style="zoom: 25%;" /><p>窗口$Wx_{l}=0,Wx_{r}=4,Wy_{b}=0,Wy_{t}=3$</p><p>直线：<br>$$<br>\begin{cases}x=-2+u\left( 7+2\right)  &amp;\ y=6+u(-2-6)&amp;\end{cases}<br>$$</p><p>$$<br>\begin{cases}u_{1}=2/9&amp;\ u_{2}=2/3&amp;\ u_{3}=3/4&amp;\ u_{4}=3/8&amp;\end{cases}<br>$$</p><p>$u_{max}=\max(0,2/9,3/8)=3/8$</p><p>$u_{min}=\min(1,2/3,3/4=2/3)$</p><p>所以保留$u_{2}u_{4}$，其中$u_{2}=(4,2/3)\ u_{4}=(11/8,3)$</p><h3 id="Early-z">Early-z</h3><p>在vertex后，fragment前做一次深度测试，如果失败，则不进行fragment（如果成功，还是要在fragment中做ZTest），这样可以大幅提高性能</p><p>开启AlphaTest需要关闭Early-Z，因为AlphaTest通过会写入深度值，而新写入的深度值无法通过Early-Z，于是本该输出的颜色被剔除了（现在硬件做了优化，可以更智能的自动开关Early-Z）</p><h3 id="什么是球面度">什么是球面度</h3><p><strong>球面度sr</strong>是立体角的国际单位（平面角的单位是<strong>角度/弧度</strong>），可以理解为三维的弧度</p><ul><li><p>弧度</p><ul><li>在一个圆上切一个扇形，弧长等于$r$所对应的角为1弧度</li><li>一个完整的圆的弧度为$2\pi$</li></ul></li><li><p>球面度</p><ul><li>在一个球上切一个“锥形”，锥形的底面积等于$r^2$所对应的角为1球面度</li><li>一个完整的球的球面度为$4\pi$</li></ul></li></ul><img src="/images/球面度.png" class="lazyload" data-srcset="/images/球面度.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球面度" style="zoom:50%;" /><h3 id="为什么BRDF-函数的单位是-1-sr">为什么BRDF 函数的单位是 1/sr</h3><p>BRDF，双向反射分布函数，是材质表面某一点出射**辐射率（Radiance）<strong>和入射</strong>辐照度（Irradiance）**的比值<br>$$<br>BRDF=\frac{dL\left( \omega_{o} \right)  }{dE\left( \omega_{i} \right)  }<br>$$</p><ul><li>辐射率$L$：每单位面积每单位**投影固体角（projected solid angle）**上的能量</li><li>辐照度$E$：每单位面积上的能量</li></ul><h4 id="为什么BRDF不直接用出射辐射率-入射辐射率呢？">为什么BRDF不直接用出射辐射率/入射辐射率呢？</h4><h5 id="原因一：因为入射辐射率很难测量">原因一：因为入射辐射率很难测量</h5><p>测量**出射辐射率$L_{0}$**很简单，只要我在出射方向上放一个下面的仪器，对准该点就可以了</p><img src="/images/测量辐射率.png" class="lazyload" data-srcset="/images/测量辐射率.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="测量辐射率" style="zoom: 33%;" /><p>测量<strong>入射辐射率</strong>很麻烦，需要要求光源很小，没有其他光的干扰，所以实际测量的时候不可行，于是不使用，最后BRDF就是出射辐照度/入射辐射率，这两个</p><p>而测量<strong>辐照度$E_{i}$<strong>只需要一个面积较小的平面，接收半球方向的</strong>光通量$\Phi $</strong>，$E=\Phi /S $</p><img src="/images/测量辐照度.png" class="lazyload" data-srcset="/images/测量辐照度.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="测量辐照度" style="zoom:50%;" /><h5 id="原因二：数学">原因二：数学</h5><p>如果是辐射率/辐射率，当出射立体角$\omega_{o}$趋近为0时，两者比值为0（上面是无穷小），没有意义<br>$$<br>\lim_{\omega_{o} \rightarrow 0} \frac{dL_{o}}{L_{i}} =0<br>$$<br>但辐射率/辐照度不等于零，因为上面下面都有无穷小，所以是不定式/等价无穷小，有意义<br>$$<br>\lim_{\omega_{o} \rightarrow 0} \frac{dL_{o}}{dE_{i}} \neq 0<br>$$</p><h3 id="什么是万向节死锁">什么是万向节死锁</h3><p>Gimbal Lock （万向节死锁，或叫 环向锁节）</p><p>在传统的欧拉坐标系，相机可以沿着xyz三个方向旋转，这三个轴有旋转的先后顺序，可以理解为父母层级关系，父轴旋转时子轴也会跟着旋转</p><ul><li>Y轴<ul><li>X轴<ul><li>Z轴</li></ul></li></ul></li></ul><p>相邻两个轴始终保持垂直，但有的时候，第一个轴会和第三个轴重合，于是你就会失去一个自由度，你无法朝向某一个方向旋转了，如果要旋转，就需要同时旋转两个轴，这个旋转很不流畅，会出现抽搐，被称为<strong>万向节死锁</strong></p><p>可以通过引入四元数解决</p><img src="/images/万向节锁.png" class="lazyload" data-srcset="/images/万向节锁.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="万向节锁" style="zoom:50%;" /><h3 id="有什么常见的遮挡算法">有什么常见的遮挡算法</h3><ul><li>画家算法<ul><li>后画覆盖新画</li><li>这是剔除的核心，下面几个都是对其的加速和优化</li></ul></li><li>沃诺克算法（Warnock）<ul><li>不停地四分屏幕<ul><li>当前子空间没有多边形：完成！</li><li>当前子空间只有一个多边形：画！</li><li>当前子空间有简单的前后关系：画前面的！</li><li>当前子空间只有一个像素那么大了：画离该像素点距离最近的多边形！</li><li>否则，继续递归细分</li></ul></li></ul></li><li>BSP-Tree（二维空间分割树）<ul><li>不停地二分空间，在每一个只有简单前后关系的子空间里使用画家算法</li></ul></li><li>Z-Buffer<ul><li>写入颜色时也写入Z值，绘制时根据Z值判断是否覆盖</li><li>有overdraw，只能处理不透明物体，多使用了一个Z-Buffer</li></ul></li></ul><h3 id="如何判断点在三角形内">如何判断点在三角形内</h3><h4 id="同侧法">同侧法</h4><p>若点P在三角形ABC内部，则</p><ul><li>点P和点A在直线BC同侧</li><li>点P和点B在直线AC同侧</li><li>点P和点C在直线AB同侧</li></ul><p>判断是否同侧都方法是叉积同号</p><h4 id="叉积法">叉积法</h4><p>PA、PB、PC两两叉积，如果三者同号则为内部</p><h4 id="重心公式">重心公式</h4><p>平面内两个不平行的非零向量可以表示任何向量<br>$$<br>\overrightarrow{AP} =u\overrightarrow{AB} +v\overrightarrow{AC}<br>$$<br>两边点积<br>$$<br>\overrightarrow{AP}\cdot \overrightarrow{AC}  =u\overrightarrow{AB}\cdot \overrightarrow{AC} +v\overrightarrow{AC}\cdot \overrightarrow{AC}<br>$$</p><p>$$<br>\overrightarrow{AP}\cdot \overrightarrow{AB}  =u\overrightarrow{AB}\cdot \overrightarrow{AB} +v\overrightarrow{AC}\cdot \overrightarrow{AB}<br>$$</p><p>两个变量两个公式，可以求出u和v</p><h3 id="什么是MIS">什么是MIS</h3><p>多重重要性采样（multiple importance sampling，MIS），在光追中，当光源和物体表面材质都接近$\delta$分布时，无论在光源上采样还是按BSDF采样都会带来很高的方差，使用MIS可以提高效果</p><p>思路就是结合不同种采用方法，分布采用被积函数的不同部分，讲这些部分结合起来，以达到最优效果</p><h4 id="什么是德尔塔分布">什么是德尔塔分布</h4><p>$\delta$函数（狄拉克函数）：除了零点以外的点都等于零，但在其整一个定义域内的积分为1的函数（这种函数本身并不存在）</p><p>$\delta$分布：符合$\delta$函数的分布</p><h3 id="已知UV和深度如何重建世界坐标">已知UV和深度如何重建世界坐标</h3><h4 id="使用逆矩阵">使用逆矩阵</h4><p>用uv和深度重建NDC坐标，乘以VP矩阵的逆矩阵以重建世界坐标</p><h4 id="线性深度">线性深度</h4><h5 id="正交投影">正交投影</h5><p>uvz线性映射回视锥长方体</p><h5 id="透视投影">透视投影</h5><p>通过z确定投影面大小，然后uv线性映射</p><h3 id="草地弯曲是怎么实现的">草地弯曲是怎么实现的</h3><p>顶点偏移？</p><h3 id="离角色很近的树叶如何保持性能">离角色很近的树叶如何保持性能</h3><h3 id="是不是每一次draw-call都需要重新传一次顶点数据">是不是每一次draw call都需要重新传一次顶点数据</h3><h3 id="贴花">贴花</h3><p>前向：绘制几何体</p><p>延迟：Gbuffer中绘制</p><h3 id="SSR会丢失信息，可以怎么处理">SSR会丢失信息，可以怎么处理</h3><p>用cubemap补一下？</p><h3 id="为什么有法线贴图还需要顶点法线信息">为什么有法线贴图还需要顶点法线信息</h3><p>为了构建TBN矩阵</p><p>在片元着色器中采集切线空间法线贴图信息，然后使用TBN矩阵恢复成世界空间法线，那么TBN是怎么来的呢？</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">half3x3 tangentToWorld = half3x3(i.tangentWS.xyz, bitangent.xyz, i.normalWS.xyz);</span><br></pre></td></tr></table></figure><p>是使用顶点着色器传入的世界空间切线、次切线、法线构建的</p><h3 id="Forward">Forward+</h3><p>和传统的前向渲染比添加了一个光源剔除阶段</p><p>着色分三个阶段：</p><ol><li>depth prepass（可选）</li><li>Light culling</li><li>shading</li></ol><p>将光源信息存储在一个线性布局的缓冲区中，方便查找</p><p>light culling阶段和延迟渲染中光照累计很相似，对于每一个像素，先找其所在的tile，求能照射到这个tile的光源列表，然后进行着色</p><p>理论上对每一个像素找灯光是效果最好的，现在这种找tile很显然是会计算一些多余的灯光，但是大幅减少了查找灯光的计算量，在查找和着色间寻找一个平衡</p><h3 id="移动端GPU渲染架构">移动端GPU渲染架构</h3><h4 id="IMR">IMR</h4><p>Immediate Mode Rending，即时模式渲染，按drawcall顺序绘制</p><img src="/images/IMR.png" class="lazyload" data-srcset="/images/IMR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMR" style="zoom:50%;" /><h4 id="TBR">TBR</h4><p>Tile Base Rendering</p><p>将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上，然后FS读信息，渲染每一个tile</p><img src="/images/TBR.png" class="lazyload" data-srcset="/images/TBR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TBR" style="zoom:50%;" /><p>作用：<strong>省带宽</strong>，每次传一个小tile，对带宽的压力会比IMR小很多（IMR一次传一整张屏幕）</p><h4 id="TBDR">TBDR</h4><p>Tile Base Deferred Rendering</p><p>上面我们在FS对每一个tile做渲染时，完全可以记录哪些灯光会影响这个tile，使用这些光做计算</p><p>思路</p><p>TBR省带宽了，但是没减少overdraw，而TBDR处理了剔除问题，降低了overdraw</p><h4 id="TBR的其他应用">TBR的其他应用</h4><ul><li><p>MSAA：MSAA是对一个像素多采几个点，原本采样很费，因为要加载卸载贴图</p><ul><li>但是由于TBR每一个tile都是片上的，相当于省了加载卸载，性能好很多</li><li>只不过虽然采样变便宜了，采样结果一多，就要处理更多的采样数据，所以也不能无限制的使用</li><li>此外这会让多边形覆盖更多的像素</li></ul><p>如图，只有一个采样点时（红点），红圈所在的像素不会被算进去，但MSAA时就会被算进去</p><img src="/images/TBR的MSAA.png" class="lazyload" data-srcset="/images/TBR的MSAA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TBR的MSAA" style="zoom:50%;" /></li></ul><h3 id="视差贴图">视差贴图</h3><p>视差贴图（Parallax Mapping）效果类似法线贴图，其原理是对纹理采样uv做偏移，不修改顶点信息</p><img src="/images/视差贴图.jpeg" class="lazyload" data-srcset="/images/视差贴图.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="视差贴图" style="zoom: 33%;" /><p>原本平坦的表面，如果变成如图的凹凸形状，原本视线会与平面在B处相交，现在则在A处相交，我们采集$A’$点的信息</p><p>从B到$A’$做了什么呢？本质就是采样点从B点出发，沿着<strong>视线在平面的投影</strong>做了一次偏移，偏移的长度可以通过三角形相似求得</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入B的uv，得到A‘的uv</span></span><br><span class="line"><span class="function">float2 <span class="title">ParallaxMapping</span>(<span class="params">float2 texCoords,float3 viewDir</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">float</span> height = texture(depthMap, texCoords).r;    </span><br><span class="line">    float2 p = viewDir.xy / viewDir.z * (height * height_scale);</span><br><span class="line">    <span class="keyword">return</span> texCoords - p;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果按深度步进，通过从上到下找第一个深度小于A的平面，来求$A’$的位置，就是陡峭视差映射(Steep Parallax Mapping)的思想</p><h3 id="virtual-texture">virtual texture</h3><p>根据是否实时生成（合并）virtual texture，该技术分为VT和RVT，该技术主要用于大世界地形上</p><p>在说VT前，要先谈texture splatting。大世界的地表纹理通常是使用多张纹理混合而成的（比如沙子、草、岩石、雪），而混合这些贴图的技术称为<strong>texture splatting</strong></p><p>该技术很简单，比如要混合四张图，那么生成一个新的RGBA贴图，在某一点的混合图为</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">blenderTex = Texture1 * map.r + Texture2 * map.g + Texture3 * map.b + Texture4 * map.a;</span><br><span class="line"><span class="comment">//其中 map.r + map.g + map.b + map.a 恒等于1</span></span><br></pre></td></tr></table></figure><img src="/images/texture splatting.png" class="lazyload" data-srcset="/images/texture splatting.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="texture splatting"  /><p>我们发现这种混合技术要频繁采样，混合四张图，要采9张图（四个材质图，四个法线图，一个splat图），而我们知道采一张大图会比采多个小图性能高很多，那么我们能不能把这九张小图拼成一张大图呢？这就是VT</p><p>但我们没必要一次把这九张完整的图合并，这也存在浪费，那么我们只需要合并需要被采样的图</p><p>我们把原图做预处理，分割成一个个小tile，并维护一个映射表，当我们要采样某个范围内的贴图时，先根据映射表找到所有相关的tile（回传给CPU，让CPU去加载tile），再把tile合并</p><h3 id="帕尼尼投影">帕尼尼投影</h3><p>一种屏幕后效，画面中心凸起，镜头左右两边在垂直方向上保留画面原样</p><p><img src="/images/%E5%B8%95%E5%B0%BC%E5%B0%BC%E6%8A%95%E5%BD%B1.jpeg" class="lazyload" data-srcset="/images/%E5%B8%95%E5%B0%BC%E5%B0%BC%E6%8A%95%E5%BD%B1.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="帕尼尼投影"></p><h3 id="SSBO">SSBO</h3><p>Shader Storage Buffer Object，该对象可以在不同shader间共享数据，功能类似UBO（Uniform Buffer Object）</p><p>两者（SSBO和UBO）区别</p><ul><li>SSBO更大</li><li>SSBO的大小可以在运行时确定</li><li>UBO在显卡的常量区（CMEM），SSBO在全局区（SMEM）</li><li>SSBO更灵活，能支持更多种的数据类型</li></ul><h3 id="计算任意多边形面积">计算任意多边形面积</h3><h4 id="凸多边形">凸多边形</h4><p>一多边形某个点为顶点，将多边形划分为多个三角形，计算每个三角形的面积（可以用向量叉积），再加起来</p><h4 id="凹多边形">凹多边形</h4><p>向量的叉积是有方向的<br>$$<br>S_{OAB}=0.5*(\overrightarrow{OA} \times \overrightarrow{OB})<br>$$</p><p>$$<br>S_{ABCDE}=S_{OBC}+S_{OCD}+S_{ODE}+S_{OEA}+S_{OAB}<br>$$</p><p><img src="/images/%E5%87%B9%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" class="lazyload" data-srcset="/images/%E5%87%B9%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="凹多边形面积"></p><h3 id="OBB包围盒">OBB包围盒</h3><p>常见的包围盒有AABB和OBB，AABB是轴向的，生成简单，但当物体旋转时效果并不好，OBB是有向的，沿着物体的主成分方向生成最小的一个矩形包围盒，可以随物体旋转</p><p><img src="/images/OBB%E4%B8%8EAABB.jpeg" class="lazyload" data-srcset="/images/OBB%E4%B8%8EAABB.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="OBB与AABB"></p><p>OBB2D的生成思路是：通过主成分分析（PCA）获得特征向量，作为OBB的主轴，然后将所有点包含</p><h4 id="主成分分析">主成分分析</h4><p>主成分分析是一种通过正交变换，将一组可能相关的变量集合变换成一组线性不相关的变量集合，即主成分</p><p>简单来说就是根据所有顶点生成协方差矩阵，对其对角化</p><h3 id="BS变形器">BS变形器</h3><p>blendshape</p><p>将一个mesh变化为另一个mesh（顶点数不变）的规则，就是一个BS，其最重要的功能是做表情</p><h3 id="什么是灭点">什么是灭点</h3><p>在透视投影中，不平行于投影平面的平行线会聚集到一点，改点就是灭点</p><h4 id="用途">用途</h4><p>在制作屏幕后效时（比如雨水），在相机的双锥体上渲染（而不是直接对屏幕四边形），可以得到一种雨水向远处收拢的感觉</p><img src="/images/灭点.jpg" class="lazyload" data-srcset="/images/灭点.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="灭点" style="zoom:67%;" /><h3 id="选人界面的打光与镜头">选人界面的打光与镜头</h3><ul><li><p>打光</p><ul><li><p>环境光：用HDRI贴图提供</p></li><li><p>直接光：打在人物正面斜上方，提供主要亮度，开启阴影</p></li><li><p>虚拟光：用于模拟反光板的提供的光源，亮度较弱，方向和相机一个位置（卡渲中常用，可以减弱光照对比，减弱阴影问题）</p></li></ul></li><li><p>镜头</p><ul><li><p>使用长焦镜头，也就是提高FOV，这样可以减少面部崎变，让人显得更瘦（反其道而行之，就是大头猪鼻特效）</p></li><li><p>开启景深</p><ul><li>深度景深：没法处理半透明物体，人物头发也会会出问题（因为深度变化太小）</li><li>Circle Blur：效果更好，美颜相机大多使用这个，原理就是把人抠出来，把人以外的背景模糊</li></ul></li></ul></li></ul><h3 id="眼球渲染的要点">眼球渲染的要点</h3><ul><li><p>眼白</p><ul><li>血丝<ul><li>可以直接画在贴图上</li></ul></li><li>次表面散射<ul><li>将散射函数预积分到LUT图上</li></ul></li></ul></li><li><p>眼睛</p><ul><li>镜面反射<ul><li>颗粒状眼白法线，来表现眼白的粘液</li></ul></li><li>AO<ul><li>在眼球外层做一个用来遮蔽的半透明模型</li></ul></li></ul></li><li><p>虹膜</p><ul><li>缩放<ul><li>uv采样缩放</li></ul></li><li>视差</li><li>焦散（猫的眼睛发亮）<ul><li>双层法线，圆滑的法线计算高光，平整的法线计算漫反射</li></ul></li><li>虹膜对光线的吸收（眼珠旁边有黑圈）<ul><li>根据uv画圆</li></ul></li><li>瞳孔收缩</li></ul></li><li><p>泪腺</p></li></ul><h3 id="移动端Deferred">移动端Deferred</h3><p>移动端延迟与GPU架构强相关</p><ul><li><p>iOS：one pass deferred</p></li><li><p>Adreno：frameBuffer fetch deferred</p><ul><li>提前绑定（开辟）好MRT，使用时RT不动，Pass动</li></ul></li><li><p>Mali：pixel loacl storage deferred</p><ul><li>将GBuffer存在on-clip mem上，于是就减少了IO消耗</li></ul></li></ul><h4 id="移动端SubPass">移动端SubPass</h4><p>Unity移动端使用Metal和Vulkan API时，都可以使用SubPass，但略有不同</p><p>在同一个RenderPass的不同SubPass间切换，是不会带来带宽消耗的</p><ul><li>Metal<ul><li>支持FrameBufferFetch，即可以在一个SubPass中对RT读写</li><li>不支持在Tile上读取深度</li></ul></li><li>Vulakn<ul><li>不支持FrameBufferFetch</li><li>支持在Tile读深度（mali设备读浮点纹理比读tile的深度更高效）</li></ul></li></ul><p>由于Metal不支持读深度，而mali Vulkan读深度效率比读RT差，所以Metal和Vulkan都在GBuffer Pass时额外生成一张深度RT，在LightingPass里用</p><h3 id="角色灯光术语">角色灯光术语</h3><h4 id="光比">光比</h4><p>指物体受光面亮度与阴影面亮度的比值，比值越大，明暗对比越强</p><p>常出现在黑暗空间爆炸光效照亮角色</p><h4 id="二值化光">二值化光</h4><p>照明时，灯光颜色在固定好的暗部颜色和亮部颜色之间插值</p><h3 id="抗锯齿">抗锯齿</h3><p>抗锯齿有两大类，时间层面和空间层面，但本质都是增加采样点数</p><ul><li>空域抗锯齿<ul><li>MSAA（MultiSampling Anti-Aliasing）：一个像素采多个点<ul><li>On-Clip MSAA</li></ul></li><li>FXAA（Fast Approximately -Aliasing）：卷积模糊</li><li>SMAA（Enhanced Subpixel Morphological）：边缘检测–矢量化–像素混合</li></ul></li><li>时域抗锯齿<ul><li>TAA（Temporal Antialiasing），一帧采一下，几帧后就等于采了很多点<br><img src="/images/TAA.png" class="lazyload" data-srcset="/images/TAA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TAA"></li></ul></li></ul><h3 id="svoGI">svoGI</h3><p>Sparse Voxel Octree（稀疏体素八叉树） GI，是VXGI的进阶版本</p><h3 id="无偏渲染">无偏渲染</h3><h3 id="SST">SST</h3><p>Sparse Shadow Tree，一种大范围阴影渲染方案</p><p><a href="https://www.activision.com/cdn/research/SparseShadowTree.pdf">论文地址</a></p><h3 id="ShadowCache">ShadowCache</h3><p>对静态物体和动态物体使用两套CSM，一套只绘制动态物体，每帧刷新，一套只绘制静态物体，低频刷新</p><p>低频刷新的CSM被称为ShadowCache</p><h3 id="TressFX">TressFX</h3><p>一种实时毛发渲染系统</p><h3 id="XGen">XGen</h3><p>一个maya的头发制作工具</p><p><a href="https://knowledge.autodesk.com/zh-hans/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/CHS/Maya-CharEffEnvBuild/files/GUID-C0470142-600B-4615-8110-EC779934DF5F-htm.html">maya文档</a></p><h3 id="Vulkan的基本概念">Vulkan的基本概念</h3><p>Vulkan对象主要分为三个部分，每个部分都有一个主对象</p><h4 id="Instance">Instance</h4><p>第一个Vulkan对象，用于连接应用程序和Vulkan运行时</p><h4 id="PhysicalDevice">PhysicalDevice</h4><p>显卡</p><ul><li>可以枚举图形队列</li><li>可以枚举内存堆和内存类型</li></ul><h4 id="Device">Device</h4><p>逻辑设备</p><ul><li>Queue：用于向GPU传递命令（类比SRP的上下文）</li><li>CommandPool：用于创建CommandBuffer</li><li>CommandBuffer：命令缓冲区，可以通过<code>vkQueueSubmit</code>提交到Queue中</li><li>Sampler：一组采样器状态，用于设置滤波模式、寻址模式等</li><li>Buffer&amp;Image：资源，渲染时不会直接使用</li><li>BufferView&amp;ImageView：对资源的解释（Buffer&amp;Image中，我们所需要的部分），渲染时直接使用（类比SRP的RT）</li><li>SurfaceKHR：控制屏幕窗口，与平台相关</li><li>SwapchainKHR：交换链，内含一组图片，用于实现显示交换<ul><li>立即渲染</li><li>双缓冲</li><li>多重缓冲</li></ul></li><li>Descriptor：描述符，用于访问资源（顶点信息，缓冲区，图像，采样器）<ul><li>DescriptorSet</li><li>DescriptorSetLayout</li><li>DescriptorPool</li></ul></li><li>FrameBuffer：ImageView的集合（RT、MRT）<ul><li>Attachment：附件（类比SRP的RenderTarget）<ul><li>Attachment初始化：Load Action</li><li>Attachment写回内存：Save Action</li></ul></li></ul></li><li>RenderPass：一次渲染流水线的执行，将信息输出到FBO的Attachments中<ul><li>SubPass：渲染的中间Pass，他们的目标不是FBO，而是一些临时的目标</li></ul></li><li>Pipeline：管线<ul><li>ComputePipeline</li><li>GraphicsPipeline<ul><li>PipelineLayout</li><li>ShaderModule：使用SPIR-V进行着色器编译</li><li>PipelineCache</li></ul></li></ul></li><li>Query：查询，用于得到某指令的执行情况</li><li>Fence&amp;Semaphore<ul><li>Fence：栅栏，用于CPU和GPU同步</li><li>Semaphore：信号量：用于GPU内部的同步（对客户端黑盒）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ddx与ddy</title>
      <link href="/graphics/ddx%E4%B8%8Eddy/"/>
      <url>/graphics/ddx%E4%B8%8Eddy/</url>
      
        <content type="html"><![CDATA[<h1>ddx与ddy</h1><p>在OpenGL中叫dFdx和dFdy，在HLSL中叫ddx和ddy</p><p><a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/deriv-rtx--sm4---asm-">HLSL deriv_rtx</a></p><p>ddx和ddy是一个求偏导的过程，依赖于硬件光栅化，只能用于fragment着色器，意思为计算blocks内相邻片元间value的变化（value可以是任意参数，比如uv、color、position、normal），注意不要在分支中使用偏导<br>$$<br>\mathrm{ddx}=\frac{\mathrm{p}(x+1,y)-\mathrm{p}(x,y)}{1}<br>$$<br>三角形光栅化时，fragment着色器一次处理2x2个像素，其中左上角的像素$(x,y)$始终为偶数坐标</p><p><img src="/images/ddx.png" class="lazyload" data-srcset="/images/ddx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ddx"></p><p>如果一个几何体不够大，使用抗锯齿算法后渲染分辨率仍然比2x2要小，那么这个几何体在光栅化前就会被剔除，以此不必担心像素不够的情况</p><h3 id="mipmap（UV）">mipmap（UV）</h3><p>使用mipmap会增加贴图存储，但是能提高性能和效果，在对mipmap贴图进行采样时，我们可以手动指定采样层级</p><p>我们需要一种方法能求mipmap层级（如果层级不对，会导致纹素比异常，产生摩尔纹等）</p><p>ddx和ddy一个应用是求贴图mipmap层级</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> mip_map_level(<span class="keyword">in</span> <span class="type">vec2</span> texture_coordinate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span>  dx_vtc        = <span class="built_in">dFdx</span>(texture_coordinate);</span><br><span class="line">    <span class="type">vec2</span>  dy_vtc        = <span class="built_in">dFdy</span>(texture_coordinate);</span><br><span class="line">    <span class="type">float</span> delta_max_sqr = <span class="built_in">max</span>(<span class="built_in">dot</span>(dx_vtc, dx_vtc), <span class="built_in">dot</span>(dy_vtc, dy_vtc));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">log2</span>(delta_max_sqr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在OpenGL4.x提供了mipmap函数<code>textureQueryLod()</code></p></blockquote><h3 id="面法线（坐标）">面法线（坐标）</h3><p>我们在fragment着色器中对世界坐标做ddx和ddy，就能得到三角面上两个向量（这俩向量还是垂直的），而平面上两个非平行向量就能确定一个平面，他们的叉积就是面法线（注意手系和法线正负）</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec3</span> faceNormal = <span class="built_in">normalize</span>( <span class="built_in">cross</span>(<span class="built_in">dFdx</span>(pos), <span class="built_in">dFdy</span>(pos)) );</span><br></pre></td></tr></table></figure><p><img src="/images/%E9%9D%A2%E6%B3%95%E7%BA%BF.png" class="lazyload" data-srcset="/images/%E9%9D%A2%E6%B3%95%E7%BA%BF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="面法线"></p><p>该技术常用于平面着色（Flat Shading），让物体有一种低面感，法线没有插值，是ground着色、phong着色以前的东西（老古董前的老古董）</p><h3 id="高度图（法线）">高度图（法线）</h3><p>与面法线原理类似，给定一张单通道的灰度图当作高度图，通过ddx、ddy就能得到高度的变化，进而得到法线的变化</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">fixed h = tex2D(_HightMap, i.uv).r;</span><br><span class="line"><span class="type">float</span> offsetU = -ddx(h); </span><br><span class="line"><span class="type">float</span> offsetV = ddy(h);</span><br><span class="line">float3 n = <span class="built_in">normalize</span>(i.normal.xyz + float3(offsetU, offsetV, <span class="number">0</span>) * _Intensity);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nabla算子</title>
      <link href="/math/Nabla%E7%AE%97%E5%AD%90/"/>
      <url>/math/Nabla%E7%AE%97%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1>Nabla算子</h1><p><a href="https://www.bilibili.com/video/BV1a541127cX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a72e0e57d1aa2c57c64020832e1cde7e">参考</a></p><p>$\nabla$：Nabla算子，将数量场变成向量场</p><ul><li><p>当其作用于函数，如$\nabla F(x)$，意思为求该函数梯度</p></li><li><p>当其点乘函数，如$\nabla \cdot F(x)$，意思为求该函数的散度</p></li><li><p>当其叉乘（三维）函数，如$\nabla \times F(x)$，意思为求该函数的旋度</p></li></ul><h3 id="函数可视化">函数可视化</h3><p>对于函数$f(x,y)=x^2+y^2$，我们有两种可视化方法，第一种叫做图像：<br>$$<br>{(\vec{x}, f(\vec{x}))|\vec{x} \in D}<br>$$<br><img src="/images//%E5%9B%BE%E5%83%8F.png" class="lazyload" data-srcset="/images//%E5%9B%BE%E5%83%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图像"></p><p>第二种叫做等值面:<br>$$<br>{\vec{x}|f(\vec{x})=c}<br>$$<br><img src="/images//%E7%AD%89%E5%80%BC%E9%9D%A2.png" class="lazyload" data-srcset="/images//%E7%AD%89%E5%80%BC%E9%9D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="等值面"></p><p>等值面只需要二维空间就能表示三维数据</p><h3 id="梯度">梯度</h3><p>Nabla算子其实是一个向量：<br>$$<br>\nabla =\left[</p><p>\frac{\partial }{\partial x_1}, \frac{\partial }{\partial x_2 },\cdots,\frac{\partial }{\partial x_n }</p><p>\right]^{T}<br>$$<br>Nabla算子作用于函数（标量场），可以将标量场转化为向量场，我们称该向量场为<strong>梯度</strong><br>$$<br>\nabla f=<br>\left[<br>\begin{array}{c}<br>\frac{\partial f}{\partial x_1}\\<br>\frac{\partial f}{\partial x_2}\\<br>\vdots\\<br>\frac{\partial f}{\partial x_n}\\<br>\end{array}<br>\right]<br>$$<br><img src="/images//%E6%A2%AF%E5%BA%A6.png" class="lazyload" data-srcset="/images//%E6%A2%AF%E5%BA%A6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="梯度"></p><p>梯度垂直于等值面，意义为变化最快的方向（图中黄色箭头）</p><h3 id="散度">散度</h3><p>我们知道向量和向量间可以进行点乘，其结果为一个标量，那么Nabla算子和向量相乘，我们称所得到的标量为<strong>散度</strong><br>$$<br>\vec{f}=\left[<br>\begin{array}{c}<br>f_1\\<br>f_2\\<br>\vdots\\<br>f_n\\<br>\end{array}<br>\right]<br>$$</p><p>$$<br>\nabla \cdot \vec{f}=\frac{\partial f_1}{\partial x_1}+\frac{\partial f_2}{\partial x_2}+\cdots +\frac{\partial f_n}{\partial x_n}<br>$$</p><p><img src="/images//%E6%95%A3%E5%BA%A6.png" class="lazyload" data-srcset="/images//%E6%95%A3%E5%BA%A6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="散度"></p><p>上图的白色箭头表示一个向量，我们发现这些箭头都是在朝外扩散，而散度就是用来衡量箭头向外扩散的程度</p><p>散度的物理意义是通量的局部描述。我们在图上画一个圈，我们发现会有向量进入这个圈，也有向量离开这个圈，那么进出之合，我们就称之为通量（比如磁通量），我们将通量除以圈的面积，就得到了通量的体密度。若这个圆取无穷小，那么体密度的极限值就是该点的散度</p><p>是不是突然很好理解麦克斯韦方程中$\nabla \cdot \mathbf{E}=0$的原因了？</p><p><img src="/images//%E7%94%B5%E8%8D%B7%E5%9C%BA%E6%BA%90.png" class="lazyload" data-srcset="/images//%E7%94%B5%E8%8D%B7%E5%9C%BA%E6%BA%90.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="电荷场源"></p><p>其实这个公式就是高斯公式</p><p><img src="/images//Gauss%E5%85%AC%E5%BC%8F.png" class="lazyload" data-srcset="/images//Gauss%E5%85%AC%E5%BC%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Gauss公式"></p><h3 id="旋度">旋度</h3><p>向量不仅可以点乘，其实也可以叉乘，两个三维向量叉乘，能得到一个3x3的行列式。最后得到一个矩阵，我们称为<strong>旋度</strong></p><p><img src="/images//%E6%97%8B%E5%BA%A6.png" class="lazyload" data-srcset="/images//%E6%97%8B%E5%BA%A6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="旋度"></p><p>旋度的物理意义就是环量的面密度。现在有一个在旋转的场，我们在场上画一个圈，场在这个圈内会做功，这个功就是环量，我们求出单位面积上环量，这个极限值描述了漩涡的强度。旋度就是旋转最快的方向</p><p><img src="/images//%E6%97%8B%E5%BA%A62.png" class="lazyload" data-srcset="/images//%E6%97%8B%E5%BA%A62.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="旋度2"></p><p><img src="/images//%E6%96%AF%E6%89%98%E5%85%8B%E6%96%AF%E5%85%AC%E5%BC%8F.png" class="lazyload" data-srcset="/images//%E6%96%AF%E6%89%98%E5%85%8B%E6%96%AF%E5%85%AC%E5%BC%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="斯托克斯公式"></p><h3 id="梯度的散度">梯度的散度</h3><p>nabla算子和自己做内积，于是会得到一个数量场，意义为求梯度的散度</p><p>这个操作为$\nabla\cdot \nabla$，也可以写作$\nabla^2、\nabla^T \nabla$，但为了避免歧义，我们引入了一个新的符号，拉普拉斯算子<br>$$<br>\Delta=\nabla \cdot\nabla<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复变函数</title>
      <link href="/math/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"/>
      <url>/math/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>复变函数</h1><h2 id="复变函数">复变函数</h2><h3 id="复数">复数</h3><p>复数可以表示为实数和纯虚数的和</p><p>代数式：<br>$$<br>z=x+\mathrm{i}y<br>$$</p><ul><li>x：实部，记为Re z</li><li>y：虚部，记为Im z</li></ul><p>复平面：</p><p><img src="/images/%E5%A4%8D%E5%B9%B3%E9%9D%A2.png" class="lazyload" data-srcset="/images/%E5%A4%8D%E5%B9%B3%E9%9D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="复平面"></p><p>极坐标下<br>$$<br>\begin{cases}<br>\rho=\sqrt{x^2+y^2} \<br>\varphi=\arctan (y/x)<br>\end{cases}<br>$$</p><p>$$<br>\begin{cases}<br>x=\rho \cos \varphi  \<br>y=\rho \sin \varphi<br>\end{cases}<br>$$</p><p>于是复数可以表示为三角式<br>$$<br>z=\rho (\cos \varphi+ \mathrm{i}\sin \varphi )=\rho e^{\mathrm{i}\varphi}<br>$$</p><ul><li><p>$\rho$：模，记为$|z|$</p></li><li><p>$\varphi$：辐角，记为Arg z</p></li><li><p>复数的辐角有无穷多个，彼此间差$2k\pi$，于是我们约定在$[0,2\pi)$的辐角为主辐角</p></li><li><p>复数<strong>零</strong>的辐角没有意义</p></li></ul><h4 id="复数的运算">复数的运算</h4><p>加减（满足交换律、结合律）<br>$$<br>z_1\pm z_2=(x_1 \pm x_2)+\mathrm{i}(y_1\pm y_2)<br>$$<br>乘（满足交换律、结合律、分配律）<br>$$<br>z_1z_2=(x_1x_2-y_1y_2)+\mathrm{i}(x_1y_2-x_2y_1)<br>$$</p><p>$$<br>z_1z_2=\rho_1 \rho_2 e^{\mathrm{i}(\varphi_1+\varphi_2)}<br>$$</p><p>除（是乘的逆运算）<br>$$<br>\frac{z_1}{z_2}=\frac{x_1x_2+y_1y_2}{x_2^2+y_2^2}+\mathrm{i}\frac{x_2y_1+x_1y_2}{x_2^2+y_2^2}<br>$$</p><p>$$<br>\frac{z_1}{z_2}=\frac{\rho_1}{\rho_2} e^{\mathrm{i}(\varphi_1-\varphi_2)}<br>$$</p><p>n次幂<br>$$<br>z^n=\rho^n e^{\mathrm{i}n\varphi}<br>$$<br>n次根式<br>$$<br>\sqrt[n]{z}=\sqrt[n]{\rho}\ e^{\mathrm{i}\frac{\varphi}{n}}<br>$$</p><h3 id="复变函数-2">复变函数</h3><p>$$<br>\omega=f(z)<br>$$</p><ul><li>z为$\omega$的宗量，$z\in E$</li></ul><h4 id="区域">区域</h4><p>在解析函数论中，函数的定义域不是一般的点集，而是满足一定条件的点击，称为区域，用B表示</p><ul><li>邻域：以复数$z_0$为圆心，画一个半径为任意小正实数的圆，圆内所有点被称为$z_0$的邻域</li><li>内点：若某点及其邻域都属于点集E，那么该点是点集E的内点</li><li>外点：若某点及其邻域都不属于点集E，那么该点是点集E的外点</li><li>边界点：若某点及其邻域既有属于点集E的点，也有不属于的点，那么该点是点集E的边界点</li><li>边界线：全体边界点构成边界线</li></ul><p>区域是满足以下两条件的点集</p><ul><li>全由内点组成</li><li>具有连通性，点集内任意两点都联通，且路径上的点都在该点集</li></ul><p>闭区域：区域+边境线组成的点集</p><h4 id="连续">连续</h4><p>$$<br>当z\rightarrow z_0时，f(z)\rightarrow f(z_0)<br>$$</p><h3 id="导数">导数</h3><p>实变数$\Delta x$只能沿着实轴趋近0，但复变数$\Delta z$可以沿着复平面上任意一曲线逼近0</p><p>若极限<br>$$<br>\lim _{\Delta z \rightarrow 0}\frac{f(z+\Delta z)-f(z)}{\Delta z}<br>$$<br>存在，且与$\Delta z \rightarrow 0$的方式无关，则称函数$\omega=f(z)$在$z$点可导（也称单演），这个极限被称为函数在该点的导数（也叫微商）</p><ul><li>若$\Delta z$沿着平行于实轴方向逼近0，$\Delta y \equiv 0,\Delta z=\Delta x \rightarrow 0$</li></ul><p>$$<br>\lim _{\Delta z \rightarrow 0}\frac{\Delta\omega}{\Delta z}=\frac{\partial v}{\partial x}+\mathrm{i}\frac{\partial u}{\partial x}<br>$$</p><ul><li>若$\Delta z$沿着平行于虚轴方向逼近0，$\Delta x \equiv 0,\Delta z=\mathrm{i}\Delta y \rightarrow 0$</li></ul><p>$$<br>\lim _{\Delta z \rightarrow 0}\frac{\Delta\omega}{\Delta z}=\frac{\partial v}{\partial y}-\mathrm{i}\frac{\partial u}{\partial y}<br>$$</p><p>要想让在该点可导，这两个极限必须同时存在且相等，于是<br>$$<br>\begin{cases}<br>\frac{\partial u}{\partial x}=\frac{\partial v}{\partial y} \<br>\frac{\partial v}{\partial x}=-\frac{\partial u}{\partial y}<br>\end{cases}<br>$$<br>这个方程被称为<strong>柯西-黎曼方程</strong>，或者<strong>柯西-黎曼条件（C-R条件）</strong>，这个方程是复变函数可导的<strong>必要条件</strong></p><p>充要条件为：函数的偏导存在且连续，且满足C-R条件</p><h3 id="解析函数">解析函数</h3><p>若函数$f(z)$在点$z_0$及其邻域上处处可导，则称$f(z)$在$z_0$点<strong>解析</strong></p><p>若$f(z)$在区域B上处处解析，那么称$f(z)$是区域B上的解析函数</p><p>解析函数是一类具有特殊性质的复变函数</p><h4 id="正交性">正交性</h4><p>若函数$f(z)=u+\mathrm{i}v$在区域B上解析，则<br>$$<br>u(x,y)=C_1,v(x,y)=C_2<br>$$<br>是B上的两组正交曲线族，即梯度$\nabla u$（其直角坐标分量为$\frac{\partial u}{\partial x}$和$\frac{\partial u}{\partial y}$）与梯度$\nabla v$（其直角坐标分量为$\frac{\partial v}{\partial x}$和$\frac{\partial v}{\partial y}$）正交</p><h4 id="调和函数">调和函数</h4><p>若函数$f(z)=u+\mathrm{i}v$在区域B上解析，则$u,v$均为B上的<strong>调和函数</strong></p><ul><li>若函数$H(x,y)$存在二阶连续偏导数，且满足拉普拉斯方程$\nabla^2H=0$，则该函数为调和函数</li></ul><h4 id="应用">应用</h4><p>给定一个二元的调和函数，将其看作某个解析函数的实部，利用C-R条件求出对应的虚部，于是就构建了一个解析函数</p><ul><li>曲线积分法</li><li>凑全微分显式法</li><li>不定积分法</li></ul><h3 id="多值函数">多值函数</h3><p>根式函数、对数函数就是一种多值函数</p><p>黎曼面</p><h2 id="傅里叶变换">傅里叶变换</h2><h3 id="傅里叶级数">傅里叶级数</h3><p>我们已经学过，周期函数可以唯一展开为以三角函数为基本函数族的级数</p><p>这些三角函数满足任意两个函数的乘积在一个周期内的积分为0，即正交性</p><p>利用三角函数的正交性，我们求出展开系数，这个系数被称为傅里叶系数</p><p>这个三角函数族是<strong>完备</strong>的</p><ul><li>完备的充要条件：任意一平方可积函数的傅里叶级数均值收敛于它本身</li></ul><h4 id="傅里叶级数收敛定理">傅里叶级数收敛定理</h4><p>若一周期函数$f(x)$满足<strong>狄里希利条件</strong>，则函数的傅里叶级数收敛（也就是函数可以用傅里叶级数表示），且收敛值为</p><ul><li>当$x$是$f(x)$的连续点时，级数收敛于$f(x)$</li><li>当$x$是$f(x)$的间断点时，级数收敛于$\frac{1}{2}[f(x-0)+f(x+0)]$</li></ul><h4 id="傅里叶级数的复数表示">傅里叶级数的复数表示</h4><p>$$<br>\sum^{\infty}_{n=-\infty}c_ne^{\mathrm{i}\frac{n\pi x}{l}}<br>$$</p><p>$$<br>c_n=\frac{1}{2l}\int^l_{-l}f(x)e^{-\mathrm{i}\frac{n\pi x}{l}}\mathrm{d}x<br>$$</p><h3 id="傅里叶积分">傅里叶积分</h3><p>一般来说非周期函数不能展开为傅里叶级数，但是如果我们将这个函数视为周期趋近于无穷的函数<br>$$<br>f(x)=\int_0^{\infty}A(\omega)\cos \omega \mathrm{d}\omega+\int_0^{\infty}B(\omega)\sin \omega \mathrm{d}\omega<br>$$<br>其中<br>$$<br>A(\omega)=\frac{1}{\pi}\int^{\infty}_{-\infty}f(\xi)\cos \omega\xi\mathrm{d}\xi<br>$$</p><p>$$<br>B(\omega)=\frac{1}{\pi}\int^{\infty}_{-\infty}f(\xi)\sin \omega\xi\mathrm{d}\xi<br>$$</p><p>上面的公式是<strong>傅里叶积分</strong>，这两个参数函数称为<strong>傅里叶变换式</strong></p><h4 id="傅里叶积分定理">傅里叶积分定理</h4><p>若函数$f(x)$在区间$(-\infty,\infty)$满足</p><ul><li>$f(x)$在任意一有限区间内满足<strong>狄里希利条件</strong></li><li>在$(-\infty,\infty)$绝对可积（即$\int^{\infty}_{-\infty}|f(x)|\mathrm{d}x$收敛）</li></ul><p>则$f(x)$可以用傅里叶积分表示，且积分值为$\frac{1}{2}[f(x-0)+f(x+0)]$</p><h4 id="傅里叶积分的复数表示">傅里叶积分的复数表示</h4><p>$$<br>f(x)=\int^{\infty}<em>{-\infty}F(\omega)e^{\mathrm{i}\omega x}\mathrm{d}\omega<br>=\frac{1}{\sqrt{2\pi}}\int^{\infty}</em>{-\infty}F(\omega)e^{\mathrm{i}\omega x}\mathrm{d}\omega<br>$$</p><p>$$<br>F(\omega)=<br>\begin{cases}<br>\frac{1}{2}[A(\omega)-\mathrm{i}B(\omega)] &amp; (\omega\ge 0) \<br>\frac{1}{2}[A(|\omega|)+\mathrm{i}B(|\omega|)] &amp; (\omega&lt; 0)<br>\end{cases}<br>$$</p><p>$$<br>F(\omega)=\frac{1}{\sqrt{2\pi}}\int^{\infty}_{-\infty}f(x)[e^{\mathrm{i}\omega x}]^{*}\mathrm{d}\omega<br>$$</p><ul><li>这里的$[]^*$是复数的共轭的意思，实际上就是直接给虚部加一个符号</li></ul><p>我们称$f(x)$为<strong>原函数</strong>，$F(\omega)$为<strong>像函数</strong></p><h5 id="例题">例题</h5><p>求矩阵脉冲函数$f(t)=h \ rect (t/2T)$的傅里叶变换<br>$$<br>\mathscr F[h \ rect (t/2T)]<br>=\frac{1}{\sqrt{2\pi}}\int^{\infty}<em>{-\infty}h \ rect (t/2T)e^{-\mathrm{i}\omega t}\mathrm{d}t \<br>=\frac{h}{2\pi}\int^{T}</em>{-T}e^{-\mathrm{i}\omega t}\mathrm{d}t \<br>=-\frac{h}{2\pi \mathrm{i}\omega}e^{-\mathrm{i}\omega t}|^{T}_{-T} \<br>=\frac{h}{\pi}\frac{\sin \omega T}{\omega}<br>$$</p><h4 id="傅里叶变化的基本性质">傅里叶变化的基本性质</h4><p>导数定理<br>$$<br>\mathscr F[f’(x)]=\mathrm{i}\omega F(\omega)<br>$$<br>积分定理<br>$$<br>\mathscr F[\int^{(x)}f(\xi)\mathrm{d}\xi]=\frac{1}{\mathrm{i}\omega} F(\omega)<br>$$<br>相似性定理<br>$$<br>\mathscr F[f(ax)]=\frac{1}{a} F(\frac{\omega}{a})<br>$$<br>延迟定理<br>$$<br>\mathscr F[f(x-x_0)]=e^{-\mathrm{i}\omega x_0} F(\omega)<br>$$<br>位移定理<br>$$<br>\mathscr F[e^{\mathrm{i}\omega_0 x} f(x)]=f(\omega-\omega_0)<br>$$<br>卷积定理<br>$$<br>\mathscr F[f_1(x)*f_2(x)]=2\pi F_1(\omega)F_2(\omega)<br>$$</p><h2 id="拉普拉斯变换">拉普拉斯变换</h2><h3 id="拉普拉斯变换-2">拉普拉斯变换</h3><p>傅里叶积分和傅里叶变换存在的条件是原函数在任意一有限区间满足狄里希利条件，且在$(-\infty,\infty)$上绝对可积，这实际上是一个相当苛刻的条件，导致很多常见函数都不满足</p><p>而拉普拉斯变换是一种条件更宽泛的变换</p><p>拉普拉斯变换常用于初始值问题，即知道某个物理量在初始时刻$t=0$的值$f(0)$，求一段时刻后的情况$f(t)$</p><p>我们置$f(t)=0$，构造一个函数$g(t)$，使得</p><p>$$<br>g(t)=e^{-\sigma t}f(t)<br>$$</p><ul><li>其中$e^{-\sigma t}$为收敛因子，正实数$\sigma$取特别大，以保证$g(t)$在$(-\infty,\infty)$绝对可积</li></ul><p>于是我们对$g(t)$进行傅里叶变换，得到<br>$$<br>G(\omega)=\frac{1}{2\pi}\int^{\infty}<em>{0}f(t)e^{-(\sigma +\mathrm{i}\omega )t}\mathrm{d}t<br>$$<br>令$p=\sigma +\mathrm{i}\omega$，$G(\omega)=\overline{f}(p)/2\pi$，则<br>$$<br>\mathscr L[f(t)]=\overline{f}(p)=\int^{\infty}</em>{0}f(t)e^{-pt}\mathrm{d}t<br>$$<br>我们称这个积分为<strong>拉普拉斯积分</strong>，而函数$\overline{f}(p)$为$f(t)$的<strong>拉普拉斯变换函数</strong>，这个变化过程称为拉普拉斯变换，$e^{pt}$称为<strong>核</strong></p><h4 id="变换条件">变换条件</h4><ul><li>在$[0,\infty)$的任意有限区间上，除了有限个第一类间断点外，函数及其导数是处处连续的</li><li>存在常数$M&gt;0$，$\sigma \ge0$，使得对任意$t\in [0,\infty)$有</li></ul><p>$$<br>|f(t)|&lt;Me^{\sigma t}<br>$$</p><p>其中$\sigma$的下界称为<strong>收敛横标</strong>，记为$\sigma_0$</p><p>在实际应用中，大部分函数都满足这个条件</p><h4 id="性质">性质</h4><ul><li><p>$\overline{f}(p)$是$Re p=\sigma &gt; \sigma_0$的半平面上的解析函数</p></li><li><p>当$|p|\rightarrow \infty$，且$|Arg p|\le \frac{\pi}{2}-\varepsilon(\varepsilon &gt; 0)$，$\overline{f}(p)$存在且满足</p></li></ul><p>$$<br>\lim_{p\rightarrow \infty}\overline{f}(p)=0<br>$$</p><ul><li>线性定理</li><li>导数定理</li><li>积分定理</li><li>相似性定理</li><li>位移定理</li><li>延迟定理</li><li>卷积定理</li></ul><h3 id="拉普拉斯变换的反演">拉普拉斯变换的反演</h3><p>由像函数转化为原函数的步骤称为<strong>反演</strong></p><ul><li>有理分式反演法</li><li>查表法</li><li>黎曼-梅林反演公式</li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微积分</title>
      <link href="/math/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
      <url>/math/%E5%BE%AE%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1>微积分</h1><h2 id="无穷级数">无穷级数</h2><p>从<strong>有限项之和</strong>拓展到<strong>无限项之和</strong></p><p>一根绳子，日取其半，万世不竭。但无论截取多少次，最后总长应该还是这跟绳子，即<br>$$<br>1=\frac{1}{2}+\frac{1}{2^2}+\frac{1}{2^3}+…+\frac{1}{2^n}+…<br>$$<br>另一个例子<br>$$<br>1+(-1)+1+(-1)+1+(-1)…<br>$$<br>等于多少呢？</p><p>到底是<br>$$<br>1+[(-1)+1]+[(-1)+1]…=1+0+0…<br>$$<br>还是<br>$$<br>(1-1)+(1-1)+…(1-1)+…=0+0+0…<br>$$<br>这里出现了矛盾，为此我们建立了无穷级数的概念</p><h3 id="常数项级数">常数项级数</h3><h4 id="常数项无穷级数">常数项无穷级数</h4><p>给定一个数列${u_n}$，由它构成的表达式<br>$$<br>u_1+u_2+…+u_n+…<br>$$<br>被称为<strong>常数项无穷级数</strong>，简称级数，其中$u_n$被称为该级数的通项</p><p>该级数的前n项和称为<strong>部分和</strong>，记为$s_n$</p><p>当n依次取1,2,3…时，部分和构成一个新数列${s_n}$，被称为<strong>部分和数列</strong></p><p>当n无限增大时，若部分和存在极限，即<br>$$<br>\lim_{n \rightarrow \infty}s_n=s<br>$$<br>则称该级数<strong>收敛</strong>，并称极限$s$为该级数的<strong>和</strong></p><p>若不存在极限，则称该级数<strong>发散</strong></p><h4 id="讨论级数收敛-发散">讨论级数收敛/发散</h4><ul><li>部分和公式好求，可以求公式，判断其有无极限</li><li>不好求，可以反证<ul><li>先假设收敛，然后化简公式，最后得出形如$s+x&gt;s$的结论，证否</li></ul></li></ul><p>$$<br>\lim_{n \rightarrow \infty}s_n=\lim_{n \rightarrow \infty}s_{2n}=s<br>$$</p><h4 id="余项">余项</h4><p>去掉级数A前n项，得到一级数<br>$$<br>u_{n+1}+u_{n+2}+…+u_{n+k}+…=\sum^{\infty}_{k=n+1}u_k<br>$$<br>称该级数为级数A的<strong>余项</strong></p><p>若级数A收敛，则余项的前m项之和$s_m’$满足<br>$$<br>s_m’=s-s_n<br>$$<br>一般，我们将n项后余项和记为$r_n$<br>$$<br>s=s_n+r_n<br>$$</p><h4 id="性质">性质</h4><ul><li><p>级数中去掉/加上有限个项，不改变级数的收敛性</p></li><li><p>若一级数收敛，则其通项<strong>乘</strong>以一个常数$k$，仍然收敛，且和为$ks$</p></li><li><p>若两级数收敛，则两通项<strong>相加或相减</strong>，对应的级数仍然收敛，且和为$s+\sigma$</p></li><li><p>若一级数收敛，在其中加任意个括号，仍然收敛</p></li><li><p>级数收敛的<strong>必要条件</strong>是通项在无穷大处有极限，且为0</p></li></ul><h4 id="柯西收敛准则">柯西收敛准则</h4><p>级数收敛的<strong>充要条件</strong></p><h3 id="正项级数">正项级数</h3><p>若级数中各项非负，则称该级数为<strong>正项级数</strong></p><ul><li>正项级数的<strong>部分和</strong>必然是递增的</li></ul><p>正项级数收敛的充要条件：其<strong>部分和数列</strong>有上界</p><h4 id="比较审敛法">比较审敛法</h4><p>对于两个正项级数A，B，其通项分别为$u_n,v_n$</p><ul><li>自某项起，$u_n\ge v_n$，若B发散，则A发散（大于发散则发散）</li><li>自某项起，$u_n\le v_n$，若B收敛，则A收敛（小于收敛则收敛）</li></ul><h5 id="比较审敛法的极限形式">比较审敛法的极限形式</h5><p>对于两个正项级数A，B，其通项分别为$u_n,v_n$，若<br>$$<br>\lim_{n \rightarrow \infty}\frac{u_n}{v_n}=\lambda<br>$$<br>有意义（极限存在或者为无穷大）</p><ul><li>$0&lt;\lambda&lt;\infty$：两级数收敛性相同</li><li>$lambda=0$：若B收敛，则A收敛（小于收敛则收敛）</li><li>$\lambda=\infty$：若B发散，则A发散（大于发散则发散）</li></ul><h4 id="比值审敛法">比值审敛法</h4><p>也称达朗贝尔判别法</p><p>对于一正向级数A，其通项为$u_n$，若<br>$$<br>\lim_{n \rightarrow \infty}\frac{u_{n+1}}{u_n}=\rho<br>$$<br>有意义</p><ul><li>$\rho &lt;1$：A收敛</li><li>$\rho &gt;1$：A发散</li><li>$\rho =1$：A可能收敛也可能发散</li></ul><h4 id="根值审敛法">根值审敛法</h4><p>也称柯西判别法</p><p>对于一正向级数A，其通项为$u_n$，若<br>$$<br>\lim_{n \rightarrow \infty}\sqrt[n]{u_n}=\rho<br>$$<br>有意义</p><ul><li>$\rho &lt;1$：A收敛</li><li>$\rho &gt;1$：A发散</li><li>$\rho =1$：A可能收敛也可能发散</li></ul><h4 id="积分审敛法">积分审敛法</h4><p>对于一正向级数A，其通项为$u_n$，若存在$[1, \infty)$上单调递减的非负连续函数$f(x)$，使得$u_n=f(n)$，则级数A与反常积分$\int^{\infty}_1 f(x)\mathrm{d}x$收敛性相同</p><ul><li>反常积分就是积分域包含无穷上/下限，或者被积函数有瑕点的积分<ul><li>瑕点：函数值区域无穷的点</li><li>奇点：函数值未定的点（比如间断点、无定义点）</li></ul></li></ul><h3 id="任意项级数">任意项级数</h3><h4 id="交错级数">交错级数</h4><p>形如<br>$$<br>u_1-u_2+u_3-u_4…(-1)^{n-1}u_n+…<br>$$<br>或者<br>$$<br>-u_1+u_2-u_3+u_4…(-1)^{n}u_n+…<br>$$<br>的级数，称为<strong>交错级数</strong></p><ul><li>其中$u_n &gt; 0$</li></ul><p><strong>交错级数审敛法</strong></p><p>若$u_n \ge u_{n+1}$ ，且$\lim_{n \rightarrow \infty}u_n=0$</p><p>则级数 $\sum^{\infty}_{n=1}(-1)^{n-1}u_n$ 收敛</p><p>且其和 $s \le u_1$ ，其余项 $|r_n|\le u_{n+1}$</p><h4 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h4><p>对于一级数$A=\sum^{\infty}_{n=1}u_n$，其各项取绝对值</p><p>得到新正项级数$B=\sum^{\infty}_{n=1}|u_n|$</p><p>定理：若B收敛，则A收敛（所以这就是我们为什么要研究正项级数）</p><ul><li>若B收敛，A必收敛，此时称A为<strong>绝对收敛</strong></li><li>若B发散，而A却收敛，此时称A为<strong>条件收敛</strong></li></ul><h5 id="性质-2">性质</h5><ul><li>绝对级数的更序级数仍为绝对级数<ul><li>更序级数：对某级数的项进行重排后得到的新级数</li></ul></li><li>两个绝对级数的柯西乘积仍然绝对收敛，且其和为$s\times \sigma$<ul><li>柯西乘积：参考向量相乘，$(a_1, a_2)(b_1,b_2)=(a_1b_1,a_2b_2)$</li></ul></li></ul><h3 id="函数项级数">函数项级数</h3><p>前面讨论的常数项级数用于表示无穷多个<strong>数</strong>的和，当其收敛时，其和为<strong>一个常数</strong></p><p>而函数项级数用于表示无穷多个<strong>函数</strong>的和</p><p>设定义在集合$D\subseteq \mathbf{R}$的一系列函数（称为函数列）<br>$$<br>u_1(x),u_2(x),u_3(x)…u_n(x)…<br>$$<br>称<br>$$<br>\sum^{\infty}_{n=1}u_n(x)<br>$$<br>为<strong>函数项级数</strong>，$u_n(x)$为通项，前n项和称为部分和</p><h4 id="极限函数">极限函数</h4><ul><li><p>若对于某个点$x_0 \in D$，${ u_n(x_0)}$收敛，则称点$x_0$为该函数列的一个<strong>收敛点</strong></p></li><li><p>所有收敛点构成的集合称为<strong>收敛域</strong></p></li><li><p>若${ u_n(x)}$处处收敛（或逐点收敛），那么就形成了一个定义在D上的函数$f(x)$，D上每一个x都有该函数列一个极限值与之相对应，并称函数$f(x)$为该函数列的<strong>极限函数</strong></p></li></ul><p>$$<br>f(x)=\lim_{n \rightarrow \infty}f_n(x)<br>$$</p><h4 id="极限函数与函数项级数">极限函数与函数项级数</h4><ul><li><p>若点$x_0 \in D$是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的<strong>收敛点</strong></p></li><li><p>若点$x_0 \in D$不是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的<strong>发散点</strong></p></li><li><p>收敛点的集合称为该级数的<strong>收敛域</strong></p></li><li><p>若级数在D上处处收敛，于是形成了一个定义在D上的<strong>和函数</strong>$s(x)$</p></li></ul><p>$$<br>s(x)=\lim_{n \rightarrow \infty}s_n(x)<br>$$</p><h4 id="收敛性">收敛性</h4><p>略</p><h3 id="幂级数">幂级数</h3><p>幂级数是一种特殊的，也是最常用的函数项级数</p><p>我们把形如<br>$$<br>a_0(x-x_0)^0+a_1(x-x_0)^1+a_2(x-x_0)^2+…a_n(x-x_0)^n+…<br>$$<br>的函数项级数称为$x-x_0$的<strong>幂级数</strong></p><p>其中$x_0$是一个常数，$a_0,a_1,…a_n,…$是<strong>幂级数的系数</strong></p><ul><li>对任意幂级数总有，当$x=0$时，幂级数收敛，即0是收敛点</li></ul><h4 id="阿贝尔定理">阿贝尔定理</h4><ul><li>若$x=x_0 \ne 0$且幂级数收敛，则当$|x|&lt;|x_0|$时，幂级数绝对收敛</li><li>若$x=x_0 \ne 0$且幂级数发撒，则当$|x|&gt;|x_0|$时，幂级数发散</li></ul><h4 id="收敛半径">收敛半径</h4><p>幂级数$\sum^{\infty}_{n=1}a_nx^n$的收敛域K是以原点为中心的一个区间，在区间内绝对收敛，在区间外发散，区间界可能收敛也可能发散，于是我们称这个收敛域的半径R为<strong>收敛半径</strong></p><p>对于某个幂级数，若$a_n \ne 0$，且<br>$$<br>\lim_{n \rightarrow \infty}|\frac{a_{n+1}}{a_n}|=\rho<br>$$</p><ul><li>若$0&lt;\rho &lt;\infty$，收敛半径$R=\frac{1}{\rho}$</li><li>若$\rho =0$，收敛半径$R=\infty$</li><li>若$\rho =\infty$，收敛半径$R=0$</li></ul><h4 id="运算">运算</h4><p>对于两个幂级数A、B，他们的收敛半径分别为$R_1$、$R_2$</p><p>$R=\min(R_1, R_2)$，则在$(-R, R)$上</p><ul><li>幂级数乘以一个常数仍然收敛</li><li>A和B的线性组合仍然收敛</li><li>A和B的乘积仍然收敛</li></ul><h4 id="和函数的性质">和函数的性质</h4><p>在收敛区间内，和函数$s(x)$满足</p><ul><li>连续性</li><li>可微性</li></ul><p>$$<br>s’(x)=\sum^{\infty}_{n=1}na_nx^{n-1}<br>$$</p><ul><li>可积性</li></ul><p>$$<br>\int^x_0s(t)\mathrm{d}t=\sum^{\infty}_{n=0}\frac{a_n}{n+1}x^{n+1}<br>$$</p><h3 id="函数展开为幂级数">函数展开为幂级数</h3><p>在前面几节，我们讨论了函数项级数（尤其是幂级数）在收敛区间内可以得到一个和函数</p><p>那么，能不能给定一个（和）函数，将其展开为幂级数呢？</p><p>幂级数可以视为多项式的推广，那么我们能不能用多项式来逼近（和）函数呢？</p><h4 id="泰勒级数">泰勒级数</h4><p>若$f(x)$在区间$(x_0-R, x_0+R)$能展开成幂级数，$f(x)$在$x=x_0$处有任意阶导数，那么幂级数有且仅有一个展开形式，且幂级数的系数为<br>$$<br>a_n=\frac{1}{n!}f^{(n)}(x_0)<br>$$</p><ul><li>n取0，1，2…</li></ul><p>我们称这个幂级数为函数$f(x)$在$x_0$处的<strong>泰勒级数</strong>，记作<br>$$<br>f(x)\sim f(x_0)+\frac{f’(x_0)}{1!}(x-x_0)+\frac{f’'(x_0)}{2!}(x-x_0)^2+…+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+…<br>$$</p><h4 id="展开条件">展开条件</h4><p>若$f(x)$在区间$(x_0-R, x_0+R)$处有任意阶导数，那么$f(x)$在该区间内能展开称泰勒级数的<strong>充要条件</strong>为<br>$$<br>\lim _{n \rightarrow \infty}R_n(x)=0<br>$$</p><ul><li>$R_n(x)$：n以后的余项</li></ul><p>推论</p><p>若存在一个常数$M&gt;0$，使得任意x属于区间$(x_0-R, x_0+R)$，都有当n趋近于无穷时，余项的绝对值小于M，则函数可以在该区间展开成泰勒级数</p><h4 id="麦克劳林展开式">麦克劳林展开式</h4><p>泰勒公式的特例，$x_0=0$<br>$$<br>f(x)=f(0)+\frac{f’(0)}{1!}x+\frac{f’'(0)}{2!}x^2+…++\frac{f^{(n)}(0)}{n!}x^n+…<br>$$</p><h4 id="经典展开">经典展开</h4><p>$$<br>e^x=1+\frac{x}{1!}+\frac{x^2}{2!}+…+\frac{x^n}{n!}+…<br>$$</p><p>$$<br>\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-…+(-1)^{n-1}\frac{x^{2n-1}}{(2n-1)!}+…<br>$$</p><h3 id="傅里叶级数">傅里叶级数</h3><p>使用三角函数来拟合一个已知函数</p><h4 id="三角级数">三角级数</h4><p>一般来说，形如<br>$$<br>\frac{a_0}{2}+\sum^{\infty}_{n=1}(a_n\cos nx+b_n \sin nx)<br>$$<br>的级数被称为三角级数</p><h4 id="正交性">正交性</h4><p>函数系<br>$$<br>{1,\cos x, \sin x, \cos 2x, \sin 2x, …,\cos nx, \sin nx,…}<br>$$<br>被称为<strong>基本三角函数系</strong></p><p><strong>正交性</strong>：该函数系任意两个不同的函数的乘积，在区间$[-\pi,\pi]$上的积分等于0</p><h4 id="三角级数的系数">三角级数的系数</h4><p>$$<br>a_n=\frac{1}{\pi}\int^{\pi}_{-\pi}f(x)\cos nx \ \mathrm{d}x<br>$$</p><p>$$<br>b_n=\frac{1}{\pi}\int^{\pi}_{-\pi}f(x)\sin nx \ \mathrm{d}x<br>$$</p><p>这两个式子被称为欧拉-傅里叶公式，由这个公式确定的系数被称为<strong>傅里叶系数</strong></p><p>对任意在区间$[-\pi,\pi]$上可积函数$f(x)$都可以求出其傅里叶级数，但这个级数不一定收敛，即使收敛也不一定收敛于$f(x)$</p><p>于是我们需要知道什么时候$f(x)$可以被展开成收敛在$f(x)$的傅里叶级数</p><h4 id="收敛定理（狄里希利充分条件）">收敛定理（狄里希利充分条件）</h4><p>对于一个周期为$2\pi$的周期函数，如果它满足<strong>狄里希利条件</strong>：</p><ul><li><p>在一个周期内连续，或者只有有限个第一类间断点</p><ul><li>第一类间断点：左右极限都存在，但该点函数值或该点无定义</li></ul></li><li><p>在一个周期内之多有有限个严格极值点</p></li></ul><p>则$f(x)$的傅里叶级数收敛，且</p><ul><li>当$x$是$f(x)$的连续点时，级数收敛于$f(x)$</li><li>当$x$是$f(x)$的间断点时，级数收敛于$\frac{1}{2}[f(x-0)+f(x+0)]$</li></ul><h4 id="其他概念">其他概念</h4><ul><li>周期延拓</li><li>正弦级数（奇函数）</li><li>余弦级数（偶函数）</li><li>奇延拓</li><li>偶延拓</li></ul><h4 id="复数表示">复数表示</h4><p>欧拉公式<br>$$<br>\sin z=\frac{e^{iz}-e^{-iz}}{2i}<br>$$</p><p>$$<br>\cos z=\frac{e^{iz}+e^{-iz}}{2}<br>$$</p><p>记<br>$$<br>\frac{a_0}{2}=c_0<br>$$</p><p>$$<br>\frac{a_n-ib_n}{2}=c_n<br>$$</p><p>$$<br>\frac{a_n+ib_n}{2}=c_{-n}<br>$$</p><p>则傅里叶级数简化为<br>$$<br>\sum^{\infty}_{n=-\infty}c_ne^{i\frac{n\pi x}{l}}<br>$$</p><p>$$<br>c_n=\frac{1}{2l}\int^l_{-l}f(x)e^{-i\frac{n\pi x}{l}}\mathrm{d}x<br>$$</p><h2 id="多元函数">多元函数</h2><h3 id="方向导数">方向导数</h3><p>设点$P_0(x_0,y_0)\in \mathbf{R}^2$，$l$是平面上的一非零向量，其单位向量为$e_i=\cos \alpha \mathbf {i}+\cos \beta \mathbf {j}$，函数$z=f(x,y)$在点$P_0$的某邻域内有定义，$P_0$为直线L上的一个定点（直线L平行于向量$l$），若极限<br>$$<br>\lim_{t\rightarrow 0}\frac{f(x_0+t\cos \alpha,y_0+t\cos \beta)-f(x_0,y_0)}{t}<br>$$<br>存在，则称此极限为函数$z=f(x,y)$在直线L上点$P_0$处，延方向$l$的<strong>方向导数</strong></p><h4 id="梯度">梯度</h4><p>方向导数刻画了函数在点$P_0$处沿着方向$l$的变化快慢程度，我们希望知道在该点，哪一个方向变化最快，于是引入了梯度</p><p>设函数$z=f(x,y)$在点$P_0(x_0,y_0)$处可偏导，则称向量<br>$$<br>f_x(x_0,y_0)\mathbf{i}+f_y(x_0, y_0)\mathbf{j}<br>$$<br>为函数$z=f(x,y)$在点$P_0(x_0,y_0)$处的<strong>梯度</strong>，记作$\mathbf{grad}f(x_0,y_0)$，或$\nabla f(x_0,y_0)$</p><ul><li>当方向为$(\frac{\partial z}{\partial x}|_P,\frac{\partial z}{\partial y}|_P)$时，变化速度最快</li></ul><h4 id="物理意义">物理意义</h4><ul><li>梯度方向=法线方向</li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论</title>
      <link href="/math/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
      <url>/math/%E6%A6%82%E7%8E%87%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1>概率论</h1><h2 id="一：随机事件与概率">一：随机事件与概率</h2><h3 id="事件">事件</h3><h4 id="事件的概念">事件的概念</h4><ul><li>样本空间$\Omega$<ul><li>其单元素子集：基本事件</li><li>其最大子集：必然事件</li><li>最小子集：即空集$\empty$，不可能事件</li></ul></li><li>事件域$F$</li></ul><h4 id="事件的关系">事件的关系</h4><ul><li>包含<ul><li>$A\subset B$：A被包含在B、B包含A、A发生时B一定发生</li></ul></li><li>相等<ul><li>$A=B$：A等于B，两事件是同一个集合、描述的是同一件事</li></ul></li><li>互不相容<ul><li>A和B不能同时发生</li></ul></li></ul><h4 id="事件的运算">事件的运算</h4><h5 id="基本运算">基本运算</h5><ul><li>并<ul><li>$A \cup B$：A和B至少有一个会发生</li></ul></li><li>交<ul><li>$A \cap B$：A和B同时发生</li></ul></li><li>差<ul><li>$A-B$：A发生，但B不发生</li></ul></li><li>对立<ul><li>$\overline{A}$：即$\Omega - A$</li></ul></li></ul><h5 id="运算性质">运算性质</h5><ul><li>交换律</li><li>结合律</li><li>分配律</li><li>对偶律（德摩根公式）<ul><li>$\overline{A \cup B} = \overline{A} \cap \overline{B}$：并的对立等于对立的交</li><li>$\overline{A \cap B} = \overline{A} \cup \overline{B}$：交的对立等于对立的并</li></ul></li></ul><h3 id="概率">概率</h3><h4 id="公理化表示">公理化表示</h4><p>设$\Omega$为一个样本空间，$F$为$\Omega$的某些子集组成的一个事件域，对任意事件$A \in F$，有一个定义在$F$上的实值函数$P(A)$，满足：</p><ul><li>非负<ul><li>$P(A) \ge 0$</li></ul></li><li>正则<ul><li>$P(\Omega) = 1$</li></ul></li><li>可列可加<ul><li>若$A_1,A_2,A_3,…A_n$互不相容，则<strong>和的概率等于概率的和</strong></li></ul></li></ul><p>则称$P(A)$为事件$A$的概率，$(\Omega, F, P)$为概率空间</p><h4 id="排列">排列</h4><p>n中取r，考虑顺序<br>$$<br>P^r_n = \frac{n!}{(n-r)!}<br>$$<br>全排列<br>$$<br>P_n = n!<br>$$</p><ul><li>注意，这里的P是方案数的意思</li></ul><h4 id="组合">组合</h4><p>n中取r，不考虑顺序<br>$$<br>C^r_n=\binom{n}{r}=\binom{n}{n-r}=\frac{n!}{r!(n-r)!}<br>$$<br>并规定<br>$$<br>C^0_n=1<br>$$</p><h4 id="频率">频率</h4><ul><li><p>$n(A)$：频数，n次重复实验中事件A出现的次数</p></li><li><p>$f_n(A)$：频率=频数/n</p></li><li><p>我们认为频率的稳定值就是概率</p></li></ul><h4 id="古典概率">古典概率</h4><p>通过样本数进行估计<br>$$<br>P(A)=\frac{事件A所含样本数}{\Omega 所含样本总数}<br>$$</p><h4 id="几何概率">几何概率</h4><p>通过面积、体积进行估计<br>$$<br>P(A)=\frac{S_A}{S_{\Omega}}<br>$$</p><ul><li>蒙特卡洛方法</li></ul><h4 id="概率的性质">概率的性质</h4><ul><li>$P(\Omega)=1$</li><li>$P(\empty)=0$</li><li>有限可加性：和的概率等于概率之和</li><li>$P(\overline{A}) = 1-P(A)$</li><li>若$A\sub B$<ul><li>$P(B-A) = P(B)-P(A) =P(B) - P(AB)$</li><li>$P(B) \ge P(A)$</li></ul></li><li>$P(A\cup B)=P(A)+P(B)-P(AB)$</li></ul><h3 id="条件概率">条件概率</h3><ul><li>条件概率：在B发生的情况下，A发生的概率</li></ul><p>$$<br>P(A|B) = \frac{P(AB)}{P(B)}<br>$$</p><ul><li>乘法公式</li></ul><p>$$<br>P(A_1…A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1…A_n-1)<br>$$</p><ul><li>全概率公式</li></ul><p>$$<br>P(A) = \sum^{n}_{i=1}P(B_i)P(A|B_i)<br>$$</p><p>$$<br>P(A)=P(B)P(A|B)+P(\overline{B})P(A|\overline{B})<br>$$</p><ul><li>贝叶斯公式（用于计算后验概率）</li></ul><p>$$<br>P(B|A)=\frac{P(B)P(A|B)}{P(B)P(A|B)+P(\overline{B})P(A|\overline{B})}<br>$$</p><h3 id="独立性">独立性</h3><p>若$P(AB)=P(A)P(B)$，则称AB两事件相互独立</p><ul><li>独立重复试验</li></ul><h2 id="二：随机变量及其分布">二：随机变量及其分布</h2><h3 id="随机变量">随机变量</h3><p>定义在样本空间$\Omega$上的实值函数$X=X(\omega)$称为随机变量，$\omega$是样本点</p><ul><li>当$\omega$变化时，$X$会变化，这东西更像一个函数，不要被“变量”给迷惑了</li></ul><h4 id="随机事件">随机事件</h4><p>随机事件是随机变量的集合</p><p>若$B$是某些实数组成的集合，$B\sub R$，则${X \in B}$表示随机事件：<br>$$<br>{\omega:X(\omega) \in B} \sub \Omega<br>$$<br>特别的，${X \in B}$可以写成类似${X \le a }$、${ a &lt; X &lt; b}$</p><h4 id="分布列">分布列</h4><p>$$<br>p(x_i) = P(X=x_i)<br>$$</p><table><thead><tr><th>X</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>P</td><td>1/2</td><td>1/4</td><td>1/8</td><td>1/8</td></tr></tbody></table><h4 id="分布函数">分布函数</h4><p>设$X$是一个连续随机变量，对于任意实数$x$，称<br>$$<br>F(x) = P(X \le x)<br>$$<br>为随机变量$X$的分布函数，并称$X$服从$F(x)$，记为$X \sim F(x) $</p><ul><li><p>$F(x)$定义域$(-\infty， \infty)$，值域$[0, 1]$</p></li><li><p>$F(x)$满足</p><ul><li>单调非减</li><li>有界</li><li>右连续，即$F(x_0+0)=F(x_0)$</li></ul></li></ul><h4 id="概率密度函数">概率密度函数</h4><p>设随机变量$X$的分布函数为$F(x)$，如果存在实数轴上一个非负可积函数$p(x)$，使得对任意实数$x$有<br>$$<br>F(x) = \int^x_{-\infty}p(t)\mathrm{d}t<br>$$<br>则称$p(x)$为$X$的概率密度函数</p><p>在$F(x)$可导的点上，$F’(x)=p(x)$</p><ul><li>非负性</li><li>正则性</li></ul><h3 id="期望">期望</h3><h4 id="离散">离散</h4><p>对于离散随机变量$X$，其分布列为$p(x_i), i=1,2,3…n,…$</p><p>若级数不收敛，即<br>$$<br>\sum^n_{i=1}|x_i|p(x_i) &lt; \infty<br>$$<br>则称<br>$$<br>E(X) = \sum^{\infty}_{i = 1}x_i p(x_i)<br>$$<br>为随机变量$X$、或者该分布的数学期望</p><h4 id="连续">连续</h4><p>设连续随机变量$X$的概率密度函数为$p(x)$</p><p>若<br>$$<br>\int^{\infty}<em>{-\infty}|x|p(x)\mathrm{d}x &lt; \infty<br>$$<br>则称<br>$$<br>E(X) = \int^{\infty}</em>{-\infty}xp(x)\mathrm{d}x<br>$$<br>为$X$的数学期望</p><ul><li>数学期望的物理解释是重心</li></ul><h4 id="性质">性质</h4><p>$$<br>E[g(X)]=\sum_{i}g(x_i)p(x_i)<br>$$</p><p>$$<br>E©=c<br>$$</p><p>$$<br>E(aX)=aE(X)<br>$$</p><p>$$<br>E[g_1(X) + g_2(X)]=E[g_1(X)]+E[g_2(X)]<br>$$</p><h3 id="方差">方差</h3><p>$$<br>Var(X)=E(X-E(X))^2<br>$$</p><p>标准差<br>$$<br>\sigma(X) = \sqrt{Var(X)}<br>$$</p><h4 id="性质-2">性质</h4><p>$$<br>Var(X)=E(X^2)-[E(X)]^2<br>$$</p><p>$$<br>Var© = 0<br>$$</p><p>$$<br>Var(aX+b)=a^2Var(X)<br>$$</p><h4 id="切比雪夫不等式">切比雪夫不等式</h4><p>出现大偏差的概率的上下界，与方差呈正比<br>$$<br>P(|X-E(X)| \ge \epsilon) \le \frac{Var(X)}{\epsilon^2}<br>$$<br>若方差为0，则<br>$$<br>P(X=E(X))=1<br>$$</p><h3 id="常见分布">常见分布</h3><ul><li><p>离散</p><ul><li><p>二项分布</p></li><li><p>两点分布</p></li><li><p>泊松分布</p></li><li><p>超几何分布</p></li></ul></li><li><p>连续</p><ul><li>正态分布</li><li>均匀分布</li><li>指数分布</li><li>伽马分布</li><li>贝塔分布</li></ul></li></ul><h2 id="三：多维随机变量及其分布">三：多维随机变量及其分布</h2><h3 id="多维随机变量">多维随机变量</h3><p>如果$X_1(\omega),X_2(\omega),X_3(\omega)…X_n(\omega)$是定义在同一样本空间$\Omega = {\omega}$上的n个随机变量，则称<br>$$<br>X(\omega)=(X_1(\omega),X_2(\omega),X_3(\omega)…X_n(\omega))<br>$$<br>为N维随机变量</p><ul><li>必须为同一样本空间</li></ul><p>N个小孩中，身高是一个随机变量，体重也是一个随机变量，（身高，体重）是一个二维随机变量</p><h4 id="联合分布函数">联合分布函数</h4><p>$$<br>F(x_1, x_2,…,x_n)=P(X_1\le x_1, X_2 \le x_2, …, X_n \le x_n)<br>$$</p><p>为n维随机变量$(X_1, X_2, …,X_n)$的联合分布函数</p><h4 id="独立性-2">独立性</h4><p>若<br>$$<br>F(x_1, x_2,…,x_n)=\prod^n_{i=1}F_i(x_i)<br>$$<br>则称$X_1, X_2, …,X_n$相互独立（充要条件）</p><ul><li>简单说，独立的随机变量，联合概率密度可以直接相乘</li></ul><h4 id="期望-2">期望</h4><p>$$<br>E(Z)=\sum_i \sum_j g(x_i, y_j)P(X=x_i, Y=y_j)<br>$$</p><p>$$<br>E(Z)=\int^{\infty}<em>{-\infty} \int^{\infty}</em>{-\infty} g(x,y)p(x,y)\mathrm{d}x\mathrm{d}y<br>$$</p><h4 id="重期望公式">重期望公式</h4><p>$$<br>E(X)=E(E(X|Y))<br>$$</p><h2 id="四：大数定律与中心极限定理">四：大数定律与中心极限定理</h2><h3 id="收敛性">收敛性</h3><ul><li>依概率收敛：大数定律</li><li>按分布收敛：中心极限定理</li></ul><h4 id="依概率收敛">依概率收敛</h4><p>有的随机变量X的概率非常难求，如果可以找到一个简单的随机变量Y的分布来拟合X，可以大幅简化计算</p><p>设${X_n}$为以随机变量序列，$X$为一随机变量，对任意$\varepsilon &gt; 0$，有<br>$$<br>P(|X_n - X| \ge \varepsilon)\rightarrow 0 \ \ (n\rightarrow \infty)<br>$$<br>则称序列${X_n}$<strong>依概率收敛于X</strong>，记作$X_n \xrightarrow{P} X$</p><ul><li>简单来说，就是概率集中在某个X处</li></ul><h4 id="弱收敛">弱收敛</h4><p>若<br>$$<br>\lim_{n \rightarrow \infty}F_n(x)=F(x)<br>$$<br>则称${F_n(x)}$弱收敛于$F(x)$，记作$F_n(x) \xrightarrow{W} F(x)$</p><p>也称序列${X_n}$<strong>按分布收敛于X</strong>，记作$X_n \xrightarrow{L} X$</p><ul><li>依概率收敛比按分布收敛，收敛性更强</li></ul><h3 id="特征函数">特征函数</h3><p>设X是一个随机变量，称<br>$$<br>\varphi(t)=E(e^{itX})<br>$$<br>为X的特征函数</p><ul><li>任一随机变量的特征函数总是存在</li></ul><h3 id="大数定理">大数定理</h3><h4 id="伯努利大数定理">伯努利大数定理</h4><p>$$<br>\lim_{n \rightarrow \infty}P(|\frac{S_n}{n} - p| &lt; \varepsilon)=1<br>$$</p><p>意义为：随着n次数的增多，频率会越来越接近概率（随机变量序列的算数平均 依概率收敛到 其均值的算数平均）</p><h3 id="中心极限定理">中心极限定理</h3><p>在某些情况下，<strong>随机变量和</strong> 的分布函数收敛于正态分布</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>球函数</title>
      <link href="/math/%E7%90%83%E5%87%BD%E6%95%B0/"/>
      <url>/math/%E7%90%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>球函数</h1><p>三大偏微分方程</p><ul><li>拉普拉斯方程（椭圆）</li><li>热方程（抛物线）</li><li>波方程（双曲线）</li></ul><h3 id="常微分方程">常微分方程</h3><p>含有未知函数的导数（含高阶导数）或微分的等式，称为<strong>微分方程</strong></p><p>若未知函数是一元函数，则该函数为<strong>常微分方程</strong></p><p>若导数的阶数为1，那么称为<strong>一阶微分方程</strong></p><h3 id="球坐标系">球坐标系</h3><p>讨论常微分方程时，边界是记为重要的，而当边界是球形时，球坐标系会更好用</p><img src="/images//球坐标系.webp" class="lazyload" data-srcset="/images//球坐标系.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球坐标系" style="zoom: 67%;" /><p>直角坐标系上点$P(x,y,z)$，也可以用三个有次序的数$(r,\theta,\varphi)$表示<br>$$<br>\begin{cases}<br>x=r \sin \theta \cos \varphi \<br>y=r \sin \theta \sin \varphi \<br>z=r\cos \theta<br>\end{cases}<br>$$</p><p>$$<br>\begin{cases}<br>r=\sqrt{x^2+y^2+z^2} \<br>\theta=\arccos \frac{z}{r}\<br>\varphi=\arctan \frac{y}{x}<br>\end{cases}<br>$$</p><h3 id="拉普拉斯方程">拉普拉斯方程</h3><h4 id="拉普拉斯算符">拉普拉斯算符</h4><p>多元函数用梯度表示不同方向函数值变化的速度，拉普拉斯算符$\nabla$就是对多元函数求梯度</p><p>对梯度再次做拉普拉斯算符$\nabla ^2$，就是求<strong>梯度的散度</strong></p><p>在直角坐标系下，二阶拉普拉斯算符为<br>$$<br>\nabla^2=\frac{\partial ^2}{\partial x^2}+\frac{\partial ^2}{\partial y^2}+\frac{\partial ^2}{\partial z^2}<br>$$<br>在球坐标下，二阶拉普拉斯算法为（将xyz带入，化简得到）<br>$$<br>\nabla^2=\frac{1}{r^2}\frac{\partial}{\partial r}(r^2\frac{\partial}{\partial r})<br>+\frac{1}{r^2\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial}{\partial \theta})<br>+\frac{1}{r^2\sin^2 \theta }\frac{\partial^2}{\partial \varphi^2}<br>$$</p><h4 id="拉普拉斯方程-2">拉普拉斯方程</h4><p><strong>拉普拉斯方程</strong>$\nabla^2 u=0$，表示的物理含义是：在各个方向上（比如二维直角坐标系，就是x和y方向）加速度合为0</p><p>这意味着什么？一个不与外界进行能量交换的系统，其拉普拉斯方程为0</p><ul><li>一个不受外力的系统，其整体加速度为0</li><li>一个不与外界传热的系统，其整体能量传播为0</li><li>一个理想的简谐振动</li><li>闭合磁场、电场</li></ul><p>我们称拉普拉斯方程为0的函数叫做<strong>Harmonic</strong></p><h4 id="球坐标系下的拉普拉斯方程">球坐标系下的拉普拉斯方程</h4><p>函数$u(r,\theta,\varphi)$的拉普拉斯方程为<br>$$<br>\nabla^2u=\frac{1}{r^2}\frac{\partial}{\partial r}(r^2\frac{\partial u}{\partial r})<br>+\frac{1}{r^2\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial u}{\partial \theta})<br>+\frac{1}{r^2\sin^2 \theta }\frac{\partial^2 u}{\partial \varphi^2}=0<br>$$<br>我们将距离和方向分离，得到<br>$$<br>u(r,\theta,\varphi)=R®Y(\theta,\varphi)<br>$$</p><ul><li>$R®$表示距离</li><li>$Y(\theta,\varphi)$表示方向，被称为球函数</li></ul><p>带入可得<br>$$<br>\frac{Y}{r^2}\frac{\mathrm{d}}{\mathrm{d} r}(r^2\frac{\mathrm{d} R}{\mathrm{d} r})<br>+\frac{R}{r^2\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial Y}{\partial \theta})<br>+\frac{R}{r^2\sin^2 \theta }\frac{\partial^2 Y}{\partial \varphi^2}=0<br>$$<br>移项、化简可得<br>$$<br>\frac{1}{R}\frac{\mathrm{d}}{\mathrm{d} r}(r^2\frac{\mathrm{d} R}{\mathrm{d} r})<br>=-\frac{1}{\sin \theta Y}\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial Y}{\partial \theta})<br>-\frac{1}{Y}\frac{1}{\sin^2 \theta }\frac{\partial^2 Y}{\partial \varphi^2}<br>$$<br>我们发现，这个方程左边是与$R$有关的函数，右边是与$\theta,\varphi$有关的函数，显然两者不可能相等，除非他们同时等于一个常数</p><p>我们令这个常数为$l(l+1)$，于是得到两个方程<br>$$<br>\frac{\mathrm{d}}{\mathrm{d} r}(r^2\frac{\mathrm{d} R}{\mathrm{d} r})-l(l+1)R=0<br>$$</p><p>$$<br>\frac{1}{\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial Y}{\partial \theta})<br>+\frac{1}{\sin^2 \theta }\frac{\partial^2 Y}{\partial \varphi^2}<br>+l(l+1)Y=0<br>$$</p><p>第二个方程叫做<strong>球函数方程</strong></p><p>如果我们进一步分离变量，令<br>$$<br>Y(\theta,\varphi)=\Theta(\theta)\Phi(\varphi)<br>$$<br>带入球函数方程，化简得到两个常微分方程<br>$$<br>\Phi’'+\lambda \Phi=0<br>$$</p><p>$$<br>\sin \theta \frac{\mathrm{d}}{\mathrm{d} \theta}(\sin \theta \frac{\mathrm{d \Theta}}{\mathrm{d} \theta})+[l(l+1)\sin^2\theta-\lambda]\Theta=0<br>$$</p><h4 id="连带勒让德方程">连带勒让德方程</h4><p>上一步我们得到了两个常微分方程，第一个方程和<strong>自然周期条件</strong>构成本征值问题，在经过很多步的推导化简（感觉这些内容对我来说有些超纲），可以把第二个式子改写为<br>$$<br>(1-x^2)\frac{\mathrm{d}^2\Theta}{\mathrm{d}x^2}-2x\frac{\mathrm{d}\Theta}{\mathrm{d}x}+[l(l+1)-\frac{m^2}{1-x^2}]\Theta=0<br>$$<br>这个式子被称为$l$阶<strong>连带勒让德方程</strong></p><p>这个式子的解，即函数$\Theta$的表达式为<strong>连带勒让德函数</strong></p><h3 id="级数解法">级数解法</h3><p>用球坐标系对拉普拉斯方程进行分离变数，得到了连带勒让德方程等特殊的函数方程，这些方程大多都是线性二阶常微分方程，很难用常规办法解，但可以用<strong>级数解法</strong>解出</p><h4 id="常点与奇点">常点与奇点</h4><p>对于一个复变函数的线性二阶常微分方程<br>$$<br>\frac{\mathrm{d}^2w}{\mathrm{d}z^2}+p(z)\frac{\mathrm{d}w}{\mathrm{d}z}+q(z)w=0<br>$$<br>若系数函数$p(z)$、$q(z)$在点$z_0$的邻域中是解析的，则点$z_0$叫做该方程的<strong>常点</strong>，若点$z_0$是奇点，则点$z_0$叫做该方程的<strong>奇点</strong></p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>线性代数</h1><h2 id="一：线性方程组">一：线性方程组</h2><h3 id="概念">概念</h3><ul><li>线性方程</li><li>线性方程组</li><li>系数</li><li>解：一组能让方程左右相等的数</li><li>解集：方程组的所有解的集合</li><li>等价：若两个线性方程组拥有相同解集，则两者等价</li><li>相容：方程组有一个或无穷多个解</li><li>不相容：方程组无解</li></ul><h3 id="矩阵">矩阵</h3><p>方程组<br>$$<br>\begin{gathered}<br>x_1-2x_2+x_3=0 \\<br>2x_2-8x_3=8 \\<br>5x_1-5x_3=10<br>\end{gathered}<br>$$<br>的<strong>系数矩阵</strong>为<br>$$<br>\left[ \begin{matrix}1&amp;-2&amp;1\\ 0&amp;2&amp;-8\\ 5&amp;0&amp;-5\end{matrix} \right]<br>$$<br><strong>增广矩阵</strong>为<br>$$<br>\left[ \begin{matrix}1&amp;-2&amp;1&amp;0\\ 0&amp;2&amp;-8&amp;8\\ 5&amp;0&amp;-5&amp;10\end{matrix} \right]<br>$$<br>这个增广矩阵，3行4列，是一个3x4的矩阵</p><p>我们对增广矩阵进行多次矩阵运算，于是得到<br>$$<br>\left[ \begin{matrix}1&amp;0&amp;0&amp;1\\ 0&amp;1&amp;0&amp;0\\ 0&amp;0&amp;1&amp;-1\end{matrix} \right]<br>$$<br>于是原方程有且仅有一个解$(1,0,-1)$</p><h4 id="初等行变换">初等行变换</h4><p>也就是行简化</p><ul><li><p>倍加：<code>a=a+nb</code>，把某行加上某一行的倍数</p></li><li><p>对换：<code>swap(a,b)</code>，把某两行对换</p></li><li><p>倍乘：<code>a *= n (n!=0)</code>，把某行所有元素乘以一个非零的数</p></li></ul><h4 id="阶梯矩阵">阶梯矩阵</h4><p>形如<br>$$<br>\left[ \begin{matrix}x&amp;<em>&amp;</em>&amp;<em>\\ 0&amp;x&amp;</em>&amp;<em>\\ 0&amp;0&amp;x&amp;</em>\end{matrix} \right]<br>$$<br>的矩阵，被称为<strong>阶梯形</strong></p><ul><li>$x$为先导元素，非零<ul><li>若先导元素均为1，而且该<strong>列</strong>只有先导元素非零，则矩阵被称为<strong>简化阶梯形</strong></li><li>$x$所在的位置被称为主元位置，拥有主元的列被称为<strong>主元列</strong></li></ul></li><li>$*$取任意值</li></ul><h4 id="行简化">行简化</h4><ul><li>任何非零矩阵都可以行简化为阶梯形矩阵</li><li>简化阶梯形具有唯一性</li></ul><h4 id="线性方程的解">线性方程的解</h4><p>对增广矩阵运用行简化，得到一个简化阶梯形<br>$$<br>\left[ \begin{matrix}1&amp;0&amp;-5&amp;1\\ 0&amp;1&amp;1&amp;4\\ 0&amp;0&amp;0&amp;0\end{matrix} \right]<br>$$<br>对应的线性方程组为<br>$$<br>\begin{gathered}<br>x_1-5x_3=1 \\<br>x_2+x_3=4 \\<br>0=0<br>\end{gathered}<br>$$</p><ul><li>其中$x_1,x_2$为基本变量，$x_3$为自由变量</li></ul><p>于是可以得到线性方程组的<strong>通解</strong><br>$$<br>\begin{cases}<br>x_1=1+5x_3&amp;\\<br>x_2=4-x_3&amp;\\<br>x_3是自由变量<br>\end{cases}<br>$$</p><h3 id="向量方程">向量方程</h3><h4 id="向量">向量</h4><p>n维向量可以写成nx1列矩阵的形式<br>$$<br>\mu=\begin{bmatrix}<br>1\\ 1\\ \vdots \\ 1<br>\end{bmatrix}<br>$$</p><ul><li>所有元素为0的向量称为零向量</li><li>当且仅当两个向量对应元素全相等时，两向量<strong>相等</strong></li></ul><p>为了方便书写，我们会将n维向量横着写（注意！用的是括号，并且相邻元素间用逗号隔开）<br>$$<br>(1,1,…,1)<br>$$</p><h4 id="向量方程-2">向量方程</h4><p>向量方程：<br>$$<br>x_1\mathbf{a_1}+x_2\mathbf{a_2}+…+x_n\mathbf{a_n}=\mathbf{b}<br>$$<br>的解，等同于增广矩阵为<br>$$<br>\begin{bmatrix}\mathbf{a_1}&amp;\mathbf{a_2}&amp;…&amp;\mathbf{a_n}\end{bmatrix}<br>$$<br>的线性方程组的解</p><ul><li><p>$Span{\nu}$</p></li><li><p>$Span{\nu_1,\nu_2,…,\nu_n }$</p></li></ul><h3 id="矩阵运算">矩阵运算</h3><p>$$<br>A\mathbf{x}=<br>\begin{bmatrix}\mathbf{a_1}&amp;\mathbf{a_2}&amp;…&amp;\mathbf{a_n}\end{bmatrix}<br>\begin{bmatrix}x_1\\ x_2\\ \vdots \\ x_n\end{bmatrix}<br>=x_1\mathbf{a_1}+x_2\mathbf{a_2} + …+x_n\mathbf{a_n}<br>$$</p><ul><li>当且仅当左边的列数等于右边的行数，才可以运算（横乘竖）</li></ul><img src="/images/横乘竖.png" class="lazyload" data-srcset="/images/横乘竖.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="横乘竖" style="zoom:50%;" /><h4 id="矩阵方程">矩阵方程</h4><p>$$<br>A\mathbf{x}=\mathbf{b}<br>$$</p><h3 id="齐次线性方程组">齐次线性方程组</h3><p>若线性方程的常数项为0，则称该线性方程为齐次的，可以写成<br>$$<br>A\mathbf{x}=\mathbf{0}<br>$$<br>的形式</p><ul><li>齐次线性方程必有一个平凡解，即$\mathbf{x}=\mathbf{0}$</li><li>齐次线性方程有非平凡解，当且仅当方程组至少有一个自由变量</li></ul><p>要判断$A\mathbf{x}=\mathbf{0}$有无非平凡解</p><ol><li>写出方程组的增广矩阵$[A, \mathbf{0}]$</li><li>将矩阵化简为简化阶梯形</li><li>若存在某一行全为0（该行对应的变量就是<strong>自由变量</strong>），则有非平凡解<ol><li>哪些不全为0的行所对应的变量称为<strong>基本变量</strong></li></ol></li></ol><h3 id="线性无关">线性无关</h3><p>若线性方程仅有平凡解，则该组向量（矩阵各列）线性无关</p><h4 id="矩阵-2">矩阵</h4><p>要判断某个<strong>矩阵</strong>各列是否线性无关：</p><ol><li>写出矩阵的增广矩阵$[A, \mathbf{0}]$</li><li>对矩阵进行行简化</li><li>若矩阵没有自由变量，则说明各列线性无关</li></ol><h4 id="向量的集合">向量的集合</h4><ul><li><p><strong>一个向量</strong>的集合线性无关的条件：当且仅当向量不是零向量</p></li><li><p><strong>两个向量</strong>的集合线性相关的条件：当且仅当某个（非零）向量是另一个（非零）向量的倍数</p></li><li><p><strong>多个向量</strong>的集合线性相关的条件：当且仅当至少有一个向量是其他向量的线性组合</p><ul><li>若一个向量组中向量个数多于每个向量的元素个数，那么这个向量组线性相关（充分条件）</li></ul></li></ul><p>能看出，两个向量属于多个向量</p><h3 id="线性变换">线性变换</h3><h4 id="变换">变换</h4><p>$$<br>A\mathbf{x}=\mathbf{b}<br>$$</p><p>一个n维向量左乘一个m行n列的矩阵，会得到一个m维的向量</p><p>我们称$\mathrm{R}^n \rightarrow \mathrm{R}^m$这个过程为一个<strong>变换</strong>，也可以叫做函数、映射</p><p>变化的规则为$T$，$\mathrm{R}^n$被称为$T$的<strong>定义域</strong>，$\mathrm{R}^m$被称为$T$的<strong>余定义域</strong></p><p>对于$\mathrm{R}^n$中的一个向量$x$，其在$\mathrm{R}^m$中的向量$T(x)$被称为$x$的<strong>像</strong>，所有的像的集合被称为<strong>值域</strong></p><p><img src="/images/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" class="lazyload" data-srcset="/images/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线性变换"></p><h4 id="线性变换-2">线性变换</h4><p>若定义域中的一切向量满足</p><ul><li>$T(\mathbf{u}+\mathbf{v})=T(\mathbf{u})+T(\mathbf{v}) $</li><li>$T(c\mathbf{u})=cT(\mathbf{u})$</li></ul><p>则称该变换为<strong>线性变换</strong></p><p>线性变换的性质：</p><ul><li>$T(\mathbf{0})=\mathbf{0}$</li><li>$T(c\mathbf{u}+d\mathbf{v})=cT(\mathbf{u})+dT(\mathbf{v}) $</li></ul><p>若n等于m，$T(\mathbf{x})=r \ \mathbf{x}$</p><ul><li>若<code>r &gt; 1</code>，则称为拉伸变换</li><li>若<code>0 &lt; r &lt; 1</code>，则称为压缩变化</li></ul><h4 id="变化矩阵">变化矩阵</h4><p>二维空间的变化矩阵为，$(x_1, y_1)$为变化后单位正方形右下角的位置，$(x_2, y_2)$为变化后单位正方形左上角的位置<br>$$<br>\left[ \begin{matrix}x_1&amp;x_2\\ y_1&amp;y_2\end{matrix} \right]<br>$$<br><img src="/images/%E5%8D%95%E4%BD%8D%E6%AD%A3%E6%96%B9%E5%BD%A2.png" class="lazyload" data-srcset="/images/%E5%8D%95%E4%BD%8D%E6%AD%A3%E6%96%B9%E5%BD%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="单位正方形"></p><p><img src="/images/%E5%AF%B9%E7%A7%B0.png" class="lazyload" data-srcset="/images/%E5%AF%B9%E7%A7%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="对称"></p><h2 id="二：矩阵代数">二：矩阵代数</h2><h3 id="矩阵-3">矩阵</h3><p>对于一个mxn的矩阵，也就是m行n列的矩阵，我们可以写作<br>$$<br>A=[\mathbf{a}_1 \ \mathbf{a}_2\ \cdots \mathbf{a}_n]<br>$$</p><!----><p>其中</p><img src="/images/矩阵的列.png" class="lazyload" data-srcset="/images/矩阵的列.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="矩阵的列" style="zoom:50%;" /><p>矩阵A的对角元素为$a_{11}, a_{22}, \cdots$，他们组成了矩阵A的<strong>主对角线</strong></p><p><strong>对角矩阵</strong>：非对角线元素全为0的矩阵</p><p><strong>零矩阵</strong>：元素全为0的矩阵，根据其尺寸，可以写为$\mathbf{0}_{m \times n}$</p><h3 id="矩阵运算-2">矩阵运算</h3><p>矩阵相等：维数相同且对应元素均相同</p><p>矩阵相加：维数相同的矩阵才能相加，结果为对应元素相加</p><p>矩阵标量乘：矩阵所有元素乘一个标量</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：几何光学</title>
      <link href="/optics/%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6/"/>
      <url>/optics/%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1>四：几何光学</h1><p>几何光学，也被称为射线光学（Ray optics），忽略光的波动性，以几何方法来研究光在均匀介质中的传播</p><h2 id="基本定律">基本定律</h2><p>几何光学包含两个部分，一个是光学三定律，定性描述了几何光学中光的传递，一个是费马原理，定量计算了光的传播（通常为光学元件间近轴传播）</p><h3 id="光学三定律">光学三定律</h3><ul><li>光在均匀介质中沿直线传播</li><li>光的反射、折射定律<ul><li>反射角等于入射角</li><li>入射角与折射角的正弦值之比等于折射率之比（Snell定律）</li></ul></li><li>光独立传播，光路可逆</li></ul><p>Shell定律<br>$$<br>n_i\sin \theta_i= n_t \sin \theta_t<br>$$</p><p><img src="/images/Snell.png" class="lazyload" data-srcset="/images/Snell.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snell"></p><p>反射光线是最短路径（亚历山大）</p><img src="/images/亚历山大.png" class="lazyload" data-srcset="/images/亚历山大.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="亚历山大" style="zoom:50%;" /><h3 id="光程">光程</h3><p>由于光在介质中移动速度不同，为了方便描述光在介质中移动某段距离要花费的时间，我们引入了光程长度。于是我们在计算时就可以认为光速永远不变，只是光的传播距离与现实距离不同</p><p>光程长度（Optical path length，OPL）：光在介质中传播长度与介质的折射率的乘积<br>$$<br>[l]=ns<br>$$<br>光程描述的是：光在该介质中移动真实距离所花费的时间，如果在真空中能运动多远的距离</p><h3 id="费马原理">费马原理</h3><blockquote><p>开创了以“路径积分，变分原理“来描述物理规律的思维方式</p></blockquote><p>费马原理（也叫最短时间原则）：</p><ul><li>光在两点间的传播路径是最短路径（最短路径可以由多条，但是其光程相同）</li><li>两点间的光程恒定（光程函数的导数为0）</li></ul><blockquote><p>费马原理可以推导出光学三定律</p><p>在均匀介质中折射率为常数，光在两点间的传播路径为最短距离，又由于两点间直线距离最短，因此光沿着直线传播</p><p>由于反射点、折射点都在交线OO‘上，因此他们在同一平面内（在交线上距离最短）</p><p>由于两点间直线最短，沿着反射轴做反射光线的对称直线，发现当反射角等于入射角时，入射光线和对称光线为一条直线</p><p>用折射率和三角形长度表示折射光线的光程，该光程应该是最小值，因而导数为0，求导化简得出Shell公式</p></blockquote><h4 id="透镜成像">透镜成像</h4><p>根据费马原理，两点间光沿着光程最短的路径传播，这说明凸透镜成像中每一条光线的光程都相等</p><img src="/images/费马原理透镜.png" class="lazyload" data-srcset="/images/费马原理透镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="费马原理透镜" style="zoom:50%;" /><p>实际上，凹透镜散射光光线的反向延长线与入射光组成的总光程也是根根相等的</p><h4 id="等光程">等光程</h4><p>等光程：如果一个光学器械每条光线都是等光程的（比如透镜），我们称之为等光程，他们可以严格成像</p><p>不等光程的器械不能成像，近似光程的器械能成模糊的像</p><h4 id="费马原理的应用">费马原理的应用</h4><p>反曲椭球面生成平行光：从椭球面焦点发生灯光，会生成平行光，由于平型光不会汇聚，因此他们的光程为无穷大</p><p>光在椭球面内反射：在椭球面内，两个焦点间光程为恒定值（毕竟椭圆上的点到两个焦点距离的和为焦距）</p><p>双曲透镜将平行光汇聚到一点</p><p>半球面反射</p><p><img src="/images/%E5%8D%8A%E7%90%83%E9%9D%A2.png" class="lazyload" data-srcset="/images/%E5%8D%8A%E7%90%83%E9%9D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="半球面"></p><h2 id="成像">成像</h2><p>光学系统（Optical system）：一个包含一个或多个光学元器件的系统</p><p>物体空间（Object space）：入射光线所在的区域</p><p>图像空间（…/…/images space）：出射光线所在的区域</p><p>理想光学系统（ideal optical system）：物体能被完美地成像，比如平面镜反射</p><p>共轭点（conjugate points）：物体点和图像点组成共轭点</p><p>对于一个理想光线系统，每对共轭点的光程（后面以OPL指代）均相同</p><p>实像：物体发出的光经过反射、折射后，汇聚成新的像，被称为实像（比如凸透镜）</p><p>虚像：物体发出的光经过反射、折射后，变成了发散光线，将其反向延长得到的像，被称为虚像（比如凹透镜、平面镜）</p><h3 id="单心性">单心性</h3><p>从一点发射光源，经过光学系统后，仍然汇聚为一点，那么这个光学系统满足单心性</p><p>平面镜反射满足单心性，折射不满足</p><p>不满足单心性，物像和图像不共轭，不能完美成像</p><h3 id="全反射">全反射</h3><p>当光从光密射入光疏，且角度大于某个值后，只发生反射，不发生折射</p><blockquote><p>光导纤维</p></blockquote><p>不过光疏介质介质中并没有没有透射波，但这些透射波与界面平行，且振幅在垂直界面方向按指数衰减，于是很快就没了，这个波被称为<strong>隐失波</strong></p><h3 id="人眼为什么能看到虚像">人眼为什么能看到虚像</h3><p>人为什么能看到东西？是因为物体经过眼睛，在视网膜上成了像，在这里，眼睛是成像系统</p><p>我们在讨论实像虚像时，提到的光学系统那些透镜们，于是虚像的全称应该是“某物体在xxx光学系统的虚像”，人眼并不是看到了“某物体在xxx光学系统的虚像”，而是在该处，经由人眼，看到了一个实像</p><h3 id="理想光学系统">理想光学系统</h3><ul><li>共轭性：物像种每个点、线、面都能在图像上找到对应的点、线、面</li><li>等光程</li></ul><h2 id="棱镜成像">棱镜成像</h2><img src="/images/偏向角.JPG" class="lazyload" data-srcset="/images/偏向角.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="偏向角" style="zoom:50%;" /><h3 id=""></h3><h2 id="球面成像">球面成像</h2><p>尽管球面不是一个很好的光学器械，但比较好加工（其实现在加工技术已经很好了，很多人的眼镜都是非球面的），于是球面成像是几何光学很重要的一块</p><p>光轴：若一个光学系统由球面组成，各球心的连线在一条直线上，该光学系统被称为共轴球面系统，这条直线被称为光轴</p><h3 id="球差">球差</h3><p>我们上面提到球面不是一个很好的光学器械，因为透镜成像有球差</p><p>透镜成像，靠近光轴的光会被汇聚在靠后的位置，远离光轴的光会被汇聚在靠前的位置，也就是透射光经过球面成像后不再汇聚为一点，单心性被破坏</p><img src="/images/球差.png" class="lazyload" data-srcset="/images/球差.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球差" style="zoom:50%;" /><h3 id="近轴条件">近轴条件</h3><p>由于球差的存在，我们假设光只在近轴处传播，于是“消除”了球差</p><p>近轴条件（paraxial condition）：入射角与光轴（optical axis）的夹角（用$u$表示）小于等于$5^{\circ}$</p><img src="/images/近轴条件.png" class="lazyload" data-srcset="/images/近轴条件.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="近轴条件" style="zoom:50%;" /><p>此时，三角函数可以近似<br>$$<br>\cos u \approx 1 \<br>\sin u \approx u \<br>\tan u \approx \sin u<br>$$</p><p>消球差平面（Aplanatic Surface）：允许所有光线在两点之间以相等的OPL传播的表面</p><img src="/images/消球差.png" class="lazyload" data-srcset="/images/消球差.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="消球差" style="zoom:50%;" /><h3 id="符号法则">符号法则</h3><blockquote><p>简单来说，若左侧的光射向一个左凸的球面在右侧汇聚，距离都是正的</p></blockquote><p>设入射光从左向右</p><ul><li>若入射点在顶点（球面和光轴的交点）左侧，那么入射点到顶点的距离为正，反之为负</li><li>若汇聚点在顶点右侧，那么汇聚点到顶点的距离为正，反之为负</li><li>若球心在顶点左侧，则半径为负，反之为正</li></ul><h3 id="绘图标准">绘图标准</h3><ul><li>基准点：球面顶点(单球面系统)、焦点</li><li>基准线：光轴、各折射点的法线</li><li>长度量：由指定原点量起<strong>顺光线传播方向为正</strong>，反之为负。</li><li>高度量：垂直向上为正，反之为负。</li><li>角度量规定：以锐角衡量，以主光轴<strong>顺时针转到光线为正</strong>。</li><li>规定：图上只标绝对值。</li></ul><h3 id="球面反射">球面反射</h3><p>Reflection at spherical surfaces</p><img src="/images/球面反射.png" class="lazyload" data-srcset="/images/球面反射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球面反射" style="zoom:50%;" /><p>$$<br>\frac{1}{-s}+\frac{1}{-s’}=-\frac{2}{r}<br>$$</p><ul><li>光轴（QA这条线）</li><li>焦点（image focus，图中$\mathrm{F’}$）：平行于光轴的光线打到球面上，会汇集到一点，这个个点被称为焦点</li><li>物体焦距（Object focal length，用$f$表示）</li><li>图像焦距（…/…/images focal length，用$f’$表示）</li></ul><p>在球面反射，物体焦距和图像焦距是相等的<br>$$<br>f= \lim_{s’ \rightarrow \infty}s<br>\<br>f’= \lim_{s \rightarrow \infty}s’<br>\<br>\frac{1}{s}+\frac{1}{s’}=\frac{1}{f}<br>$$</p><h3 id="球面折射">球面折射</h3><p>Refraction at spherical surfaces</p><p><img src="/images/%E7%90%83%E9%9D%A2%E6%8A%98%E5%B0%84.png" class="lazyload" data-srcset="/images/%E7%90%83%E9%9D%A2%E6%8A%98%E5%B0%84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球面折射"><br>$$<br>\frac{n_1}{-s}+\frac{n_2}{s’}=\frac{n_2-n_1}{r} \equiv \Phi<br>$$</p><ul><li>光焦度（用$\Phi$表示）：用与描述光线系统对光线的曲折能力</li></ul><p><strong>高斯透镜公式</strong>（Gaussian Lens Formula）<br>$$<br>\frac{f}{s}+\frac{f’}{s’}=1<br>$$<br>牛顿透镜公式（Newton form of Lens Formula）<br>$$<br>x_0x_i=ff’<br>$$<br><img src="/images/%E7%89%9B%E9%A1%BF%E6%88%90%E5%83%8F%E5%85%AC%E5%BC%8F.png" class="lazyload" data-srcset="/images/%E7%89%9B%E9%A1%BF%E6%88%90%E5%83%8F%E5%85%AC%E5%BC%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="牛顿成像公式"></p><h3 id="离轴点成像">离轴点成像</h3><p>Imaging for off-axis points</p><p>就是y比较大，导致不能使用三角函数近似</p><p><img src="/images/%E7%A6%BB%E8%BD%B4%E6%88%90%E5%83%8F.png" class="lazyload" data-srcset="/images/%E7%A6%BB%E8%BD%B4%E6%88%90%E5%83%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="离轴成像"></p><h2 id="薄透镜成像">薄透镜成像</h2><p>透镜：由两个同轴折射球组成的镜子，根据球心位置，分为凸透镜（convex lens）和凹透镜（concave lens）</p><p>薄透镜（Thin lens）：中心半径和曲率厚度可以忽略不记的透镜</p><p>光轴（Optic axis）：连接两个曲面中心的轴</p><p>光学中心（Optic center）：两个球面的基准点（vertex）视为重合，重合点就是光学中心</p><p>凸透镜分为双凸、平凸、弯凸三种</p><p>凹透镜分为双凹、平凹、弯凹三种</p><h3 id="透镜公式">透镜公式</h3><p>$$<br>\frac{n_1}{-s_1}+\frac{n_2}{s_2’}=\frac{n_0-n_1}{r_1}+\frac{n_2-n_0}{r_2}\equiv \Phi<br>$$</p><p><img src="/images/%E9%80%8F%E9%95%9C%E5%85%AC%E5%BC%8F.png" class="lazyload" data-srcset="/images/%E9%80%8F%E9%95%9C%E5%85%AC%E5%BC%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="透镜公式"></p><h3 id="焦平面">焦平面</h3><p>焦平面（Focal plane）：垂直于光轴且经过焦点的平面</p><p>前焦平面（front focal plane）：光射入透镜的面</p><p>后焦平面（back focal plane）：光从透镜射出的面</p><p>透镜使得光的落点与入射角有关，且满足<br>$$<br>y=f \cdot \tan\theta \approx f\cdot \theta<br>$$<br><img src="/images/%E8%90%BD%E7%82%B9.png" class="lazyload" data-srcset="/images/%E8%90%BD%E7%82%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="落点"></p><p><em>用透镜成像等于两倍的傅里叶变换</em></p><h3 id="光阑">光阑</h3><p>光阑（stop）：限制（limit）成像光束的器件，比如透镜（lens）、光圈（aperture）、窗口片（the frame of windows）</p><h4 id="光圈">光圈</h4><p>光圈（aperture stop，下图DD’）：用于限制光线宽度的期间</p><p><img src="/images/%E5%85%89%E5%9C%88.png" class="lazyload" data-srcset="/images/%E5%85%89%E5%9C%88.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="光圈"></p><p>Field stop：用于限制成像区域和方位</p><p><img src="/images/field-stop.png" class="lazyload" data-srcset="/images/field-stop.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="field-stop"></p><h4 id="景深">景深</h4><p>景深（Depth of field/focus）：聚焦深度，入射点P在光轴方向移动，移动距离$\Delta x$在景深范围内，图像是清晰的</p><p><img src="/images/%E6%99%AF%E6%B7%B1.png" class="lazyload" data-srcset="/images/%E6%99%AF%E6%B7%B1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="景深"></p><p>能看出图中$P_1$过早聚焦，$P_2$过晚聚焦，他们相对于$P$，都显得比较模糊</p><p>在物体空间的最大$\Delta x$被称为Depth of field</p><p>在图像空间的最大$\Delta x$被称为Depth of focus</p><h4 id="相对孔径">相对孔径</h4><p>相对孔径（Relative aperture）：光圈的直径（用$D$表示）和焦距（focal length，用$f$表示）的比值</p><p>$D/f$越大，说明光学系统收集光的能力越强</p><h4 id="f-number">f-number</h4><p>相对孔径的倒数，意义为焦距是直径的多少倍</p><p>比如一个光学系统，焦距160nm，光圈直径20nm，那么它的f-number等于160/20=8，记作$f/8$</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：反射和折射</title>
      <link href="/optics/%E5%8F%8D%E5%B0%84%E5%92%8C%E6%8A%98%E5%B0%84/"/>
      <url>/optics/%E5%8F%8D%E5%B0%84%E5%92%8C%E6%8A%98%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1>五：反射与折射</h1><h2 id="内容概述">内容概述</h2><ul><li>光在单层各项同性表面的反射与折射</li><li>菲涅尔方程</li><li>全内反射</li><li>相位突变，布鲁斯特角</li></ul><h2 id="菲涅尔方程">菲涅尔方程</h2><h3 id="菲涅尔方程-2">菲涅尔方程</h3><p>各项同性介质（Isotropic medium）：折射率处处相同的材质</p><p>光密介质：折射率高的介质（这是一个相对概念）</p><p>光疏介质：折射率低的介质（这是一个相对概念）</p><p>在几何光学中的那些反射方程，只能得到入射光、反射光、折射光间的方向关系</p><p>而菲涅尔方程（Fresnel Equations）可以求出反射光、折射光的振幅、相位、偏振</p><p>菲涅尔方程的边界条件表明：磁场和电场在边界处连续，也就是入射光的电场磁场=反射光+折射光的电场磁场</p><img src="/images/菲涅尔.png" class="lazyload" data-srcset="/images/菲涅尔.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="菲涅尔" style="zoom:50%;" /><p>我们将入射光的电场分为两个部分，方向满足右手正交系</p><ul><li>平行（parallel）于平面的电场$E_p$</li><li>垂直（senkrecht）与平面<strong>向外</strong>的电场$E_s$</li></ul><p>经过复杂的推导，我们能得到<br>$$<br>r_p=\frac{E_{1p}’}{E_{1p}}=\frac{\tan(\mathrm{i_1}-\mathrm{i_2})}{\tan(\mathrm{i_1}+\mathrm{i_2})}\\<br>r_s=\frac{E_{1s}’}{E_{1s}}=-\frac{\sin(\mathrm{i_1}-\mathrm{i_2})}{\sin(\mathrm{i_1}+\mathrm{i_2})}\\<br>t_p=\frac{E_{2p}}{E_{1p}}=\frac{2\cos \mathrm{i_1}\sin \mathrm{i_2}}{\sin(\mathrm{i_1}+\mathrm{i_2}) \cos (\mathrm{i_1}-\mathrm{i_2})}\\<br>t_s=\frac{E_{2s}}{E_{1s}}=\frac{2\cos \mathrm{i_1}\sin \mathrm{i_2}}{\sin(\mathrm{i_1}+\mathrm{i_2})}<br>$$</p><ul><li>$r$：反射光</li><li>$t$：折射光（透射光，Transmission）</li></ul><p>于是我们能得出几个结论</p><ul><li>反射光、折射光与入射角、折射率有关</li><li>$p$与$s$是独立的</li></ul><h2 id="菲涅尔方程的含义">菲涅尔方程的含义</h2><h3 id="外反射">外反射</h3><p>外反射（External reflection）：从折射率低射向折射率高，比如从空气射向玻璃</p><img src="../../Document/Markdown/ImageLib/外反射.png" class="lazyload" data-srcset="../../Document/Markdown/ImageLib/外反射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="外反射" style="zoom:50%;" /><p>我们发现，随着入射角的增加</p><ul><li><p>折射一直是正数，并且两个方向没有明显差异</p></li><li><p>$r_s$一直是负数，而$r_p$先正后负</p></li><li><p>布鲁斯特角（Brewster’s angle，图中$i_B$），在此处$r_p$发生了一个$180^{\circ}$的相变</p></li><li><p>当入射角为$90^{\circ}$时，也就是掠射角（grazing angles），我们发现此时完全不发生折射，只发生反射</p><ul><li>对于一个湿表面，远看发现很亮，近看却发现变暗了</li><li>远看水面，大部分光来自反射，于是波光粼粼；近看水面，折射部分加强，于是清澈见底</li></ul></li><li><p>让入射角为$0^{\circ}$，也就是垂直入射时，$r_p$完全反向反射回来，折射很微弱</p></li></ul><h3 id="内反射">内反射</h3><p>内反射（Internal reflection）：从折射率高射向折射率低，比如从玻璃射向空气</p><img src="/images/内反射.png" class="lazyload" data-srcset="/images/内反射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内反射" style="zoom: 50%;" /><ul><li>$t_p=t_s$，两者没有相位差</li><li>当$i=i_c$，此时$r_p=r_s=1$，我们称之为全内反射（Total Internal Reflection，TIR），$i_c$被称为临界角（critical angle）</li></ul><h3 id="相位移">相位移</h3><p>相位移（Phase shift）</p><p><img src="/images/%E7%9B%B8%E4%BD%8D%E7%A7%BB.png" class="lazyload" data-srcset="/images/%E7%9B%B8%E4%BD%8D%E7%A7%BB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="相位移"></p><ul><li><p>从低折射率到高折射率，会有一次$\pi$相位移</p></li><li><p>从高折射率到低折射率，没有相位移</p></li></ul><p>薄膜相位移：光线在薄膜内发生多次反射，可能会附加一段相位移</p><p><img src="/images/%E8%96%84%E8%86%9C%E7%9B%B8%E4%BD%8D%E7%A7%BB.png" class="lazyload" data-srcset="/images/%E8%96%84%E8%86%9C%E7%9B%B8%E4%BD%8D%E7%A7%BB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="薄膜相位移"></p><h3 id="简化菲涅尔方程">简化菲涅尔方程</h3><p>反射比（Reflectance，用$R$表示）：反射光占入射光的能量</p><p>折射比（Transmittance，用$T$表示）：透射光（折射光）占入射光的能量</p><p>能流（Energy flow）：单位时间内通过单位横截面积的能量</p><p>能流 = 辐照度 x 横截面积<br>$$<br>R=r^2<br>$$</p><p>$$<br>T=\frac{n_2\cos i_2}{n_1\cos i_1}t^2<br>$$</p><p>根据能量守恒定律（Energy conservation law）：$R+T=1$</p><p>当垂直入射时，带入菲涅尔方程，得到<br>$$<br>\begin{cases}<br>r_p=\frac{n_2-n_1}{n_2+n_1}\\<br>r_s=-r_p\\<br>t_p=\frac{2n_1}{n_1+n_2}\\<br>t_s=t_p<br>\end{cases}<br>$$<br>于是得到<br>$$<br>R_p=R_s=\left( \frac{n_2-n_1}{n_2+n_1}\right)^2<br>$$</p><p>$$<br>T_p=T_s=\frac{4n_1n_2}{(n_1+n_2)^2}<br>$$</p><p>对于空气（$n_1=1$）和玻璃（$n_2=1.5$），$R=0.04，T=0.96$</p><p><em>这也是为什么图形学中取 0.04为F0的基准值</em></p><p><strong>为什么晚上室内玻璃像镜子一样？</strong></p><ol><li>晚上的玻璃，$R\approx 0.08$，室内的光线大部分都会反射回来，而室外的光线只有很少才会透射进来，看到的光绝大多数都来自室内的反射光，因此像镜子一样</li><li>此外，夜晚室内光线本身也比室外光线强</li></ol><p><strong>为什么白天从黑暗的房间看外面看，看的很清楚，而从室外向里看，却看不清</strong>？</p><p><strong>单透玻璃的原理是什么？</strong></p><h3 id="金属">金属</h3><p>金属（电介质）表面存在大量自由电荷，在外部电场的作用下，自由电子在固体表面（相对固定的金属阳离子）间不断弹跳</p><h4 id="德鲁德模型">德鲁德模型</h4><p>德鲁德模型（Drude model）是一种描述金属表面自由电子运动的模型（很复杂，看一下，图一乐）<br>$$<br>P=-nex<br>$$</p><p>$$<br>m\frac{\partial^2 x}{\partial t^2}+m \gamma \frac{\partial x}{\partial t}=eEe^{-\mathrm{i}\omega t}<br>$$</p><ul><li>偏振度（用$P$表示，在电磁波那一章在介绍洛伦兹震荡时有一个极其类似的公式）</li><li>阻尼率（damping rate，用$\gamma$表示）</li><li>电荷密度（density of electron，用$n$表示）</li></ul><p>这个推导很复杂，又涉及复变函数之类的，直接给结论：当平面波垂直射向金属时，$R \approx 1$</p><h4 id="布鲁斯特角">布鲁斯特角</h4><p>布鲁斯特角（Brewster’s angle），在外反射那一节提到过，当$i_1=i_B,r_p=0$</p><img src="/images/布鲁斯特角.png" class="lazyload" data-srcset="/images/布鲁斯特角.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="布鲁斯特角" style="zoom:50%;" /><p>一个应用是测量不透明介质的折射率<br>$$<br>\tan i_B=\frac{n_2}{n_1}<br>$$</p><p>另一个一个应用是制作偏振器，激光经过偏振器后，射出的光线是线偏振的</p><p><img src="/images/%E5%81%8F%E6%8C%AF%E5%99%A8.png" class="lazyload" data-srcset="/images/%E5%81%8F%E6%8C%AF%E5%99%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="偏振器"></p><p>自然光（非偏振光）的反射光、折射光是偏振光，但如果给镜头安装偏振器，并适当旋转偏振片，使偏振片的透振方向与反射光的透振方向垂直，此时$i_1=i_B,r_p=0$，不发生反射，只发生透射，于是会看得更清晰</p><p><img src="/images/%E9%80%8F%E6%8C%AF.png" class="lazyload" data-srcset="/images/%E9%80%8F%E6%8C%AF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="透振"></p><h3 id="偏振">偏振</h3><p>线偏振光的反射、折射光仍为线偏振光，但其光矢量方向会发生改变（上为入射光，下为反射光）</p><img src="/images/线偏振的反射光.png" class="lazyload" data-srcset="/images/线偏振的反射光.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线偏振的反射光" style="zoom:50%;" /><p>圆偏振/椭圆偏振光的反射折射光一般为椭圆偏振光</p><h2 id="全内反射">全内反射</h2><p>从折射率高射向折射率低，当入射角满足$i_1 \ge i_c$时，就会发生全内反射（Total internal reflection）</p><img src="/images/全内反射.png" class="lazyload" data-srcset="/images/全内反射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="全内反射" style="zoom:50%;" /><p>此时$R\equiv 1$，也就是所有能量都被反射，不发生透射，于是低折射率那一侧看不到任何光，物体变黑了，这个现象就是全内反射</p><p>全内反射的应用：棱镜（Prisms）、光纤</p><h3 id="隐失波">隐失波</h3><p>隐失波（Evanescent wave） ：光从光密介质入射光疏介质时，如果发生全内反射，光疏介质那一侧产生的电磁波</p><p>隐失波的振幅随着穿透深度（Depth of penetration）的增加而呈现指数衰减，随切线方向而改变相位，因此是一种表面波</p><p>$$<br>d=\frac{\lambda_2}{2\pi \Omega}<br>$$</p><ul><li>穿透深度：与分界面的垂直深度，用$d$表示</li><li>$\sqrt{1-\sin ^2 i_2} \equiv \mathrm{i}\Omega$</li></ul><p>隐失波沿着z轴衰减，沿着x轴传播<br>$$<br>E_2=E_{02}e^{-z/d}e^{\mathrm{i}(k_xx-\omega t)}<br>$$<br><img src="/images/隐失波.png" class="lazyload" data-srcset="/images/隐失波.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="隐失波" style="zoom:67%;" /></p><p>隐失波不是横波</p><p>隐失波的一个应用是制作分光镜，如果只有一个棱镜（下图黑色三角形），会发生全内反射，光线全部反射</p><img src="/images/单棱镜.png" class="lazyload" data-srcset="/images/单棱镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="单棱镜" style="zoom: 33%;" /><p>如果将两个棱镜靠近，通过控制两者间空气的间隙，在隐失波的作用下，能实现分光</p><p><img src="/images/%E5%88%86%E5%85%89%E9%95%9C.jpg" class="lazyload" data-srcset="/images/%E5%88%86%E5%85%89%E9%95%9C.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="分光镜"></p><p>其他应用：</p><ul><li>光子隧穿</li><li>近场扫描显微镜</li><li>指纹检测</li></ul><img src="/images/指纹检测.png" class="lazyload" data-srcset="/images/指纹检测.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="指纹检测" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：波动光学</title>
      <link href="/optics/%E6%B3%A2%E5%8A%A8%E5%85%89%E5%AD%A6/"/>
      <url>/optics/%E6%B3%A2%E5%8A%A8%E5%85%89%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1>二：波动光学</h1><h2 id="内容概述">内容概述</h2><ul><li>简谐波（simple harmonic waves）</li><li>傅里叶变换（Fourier Transform）</li><li>波的物理量</li></ul><h2 id="数学基础">数学基础</h2><h3 id="常用函数">常用函数</h3><h4 id="三角函数">三角函数</h4><p>欧拉公式<br>$$<br>e^{\mathrm{i}x}=\cos x + \mathrm{i}\sin x<br>$$<br>三角函数的复数表示<br>$$<br>\sin z=\frac{e^{\mathrm{i}z}-e^{-\mathrm{i}z}}{2\mathrm{i}}<br>$$</p><p>$$<br>\cos z=\frac{e^{\mathrm{i}z}+e^{-\mathrm{i}z}}{2}<br>$$</p><h4 id="delta-函数">$\delta$函数</h4><p><em>德尔塔函数，冲击函数</em></p><p>整体积分为1，除了0点以外，其他点函数值都为0<br>$$<br>\delta(x)=0,(x\ne0)<br>$$</p><p>$$<br>\int^{\infty}_{-\infty}\delta(x)dx=1<br>$$</p><h4 id="高斯函数">高斯函数</h4><p><em>概率论里的正态分布</em><br>$$<br>f(x)=ae^{-(x-b)^2/2c^2}<br>$$</p><ul><li>a&gt;0</li></ul><p><img src="/images/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0.jpg" class="lazyload" data-srcset="/images/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="高斯函数"></p><h4 id="洛伦兹函数">洛伦兹函数</h4><p><em>概率论里的柯西分布</em><br>$$<br>f(x)=\frac{A}{B^2+x^2}<br>$$</p><h4 id="矩形脉冲函数">矩形脉冲函数</h4><p>$$<br>f(t)=E[u(t+\frac{\tau}{2})-u(t-\frac{\tau}{2})]<br>$$</p><h2 id="波的数学表示">波的数学表示</h2><p>定态波：空间中各点均为同频率的简谐振荡，各点振幅不随时间改变</p><p>震荡（Vibration）：物理量围绕其平衡位置进行周期性变化</p><p>简谐震荡（Harmonic vibration）：物理量随着时间以三角函数的形式进行震荡<br>$$<br>U(t)=A\cos(\omega t+\varphi_0)<br>$$</p><ul><li>振幅（amplitude，用$A$表示）</li><li>角频率（angular frequency，用$\omega$表示）</li></ul><p>$$<br>\omega=\frac{2\pi}{T}<br>$$</p><ul><li>相位（phase，用$\varphi$表示）</li><li>初相（initial phase，用$\varphi_0$表示）</li></ul><p>波（waves）：震荡在空间中的传播</p><p>简谐波（simple harmonic waves）：进行简谐震荡的波</p><p>单色平面波可以视为简谐波</p><p>波阵面（wave surface）：波在介质中传播，经过相同时间所到达的各点所连成的线/面</p><p>波前（wave front）：最前面的波阵面</p><p>相速度（phase velocity，用$v_p$表示）：波传递的速度<br>$$<br>v_p=\frac{\omega}{k}<br>$$</p><h2 id="傅立叶变换">傅立叶变换</h2><p>将一个满足条件的函数，转化为三角函数（或他们积分）的线性组合<br>$$<br>\hat{f}=&lt;f,E_k&gt;=\int f(x)e^{-2\pi i k\cdot x}\mathrm{d}x<br>$$<br>其傅里叶级数为<br>$$<br>\sum\hat{f}(k)E_k<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：电磁波</title>
      <link href="/optics/%E7%94%B5%E7%A3%81%E6%B3%A2/"/>
      <url>/optics/%E7%94%B5%E7%A3%81%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<h1>三：电磁波</h1><h2 id="内容概述">内容概述</h2><ul><li>横波的性质（nature），强度（intensity），能量流动（energyflow）</li><li>偏振态（Polarization states），琼斯矩阵（Jones matrix/vector）</li><li>吸收（Absorption），色散（dispersion），折射率（refractive index）</li><li>微小粒子导致的散射（Scattering）</li></ul><h2 id="波">波</h2><p>构成波的条件：</p><ul><li>波源</li><li>介质</li><li>能量来源</li></ul><p>波的性质：</p><ul><li>时间周期性</li><li>空间周期性</li><li>能量传播</li></ul><p>波的分类</p><ul><li>标量波</li><li>矢量波</li></ul><h2 id="光的基本性质">光的基本性质</h2><ul><li><p>光是电磁波</p></li><li><p>可见光的波长在400nm~760nm</p><ul><li>在做干涉衍射计算时，经常去白光的平均波长550nm</li></ul></li><li><p>人眼对550nm的黄绿光最敏感</p></li><li><p>单色光（Monochromatic light），指仅有一种波长的光，仅存在于理论中</p></li></ul><h3 id="光速">光速</h3><p>光在真空（vacuum）中的速度（简称光速，用c表示）为<br>$$<br>c=\frac{1}{\sqrt{\varepsilon_0 \mu_0}}=2.997 924 58 \times10^8 m/ s<br>$$<br>光在介质（medium）中的速度（也叫做相速度，用v表示）为<br>$$<br>v=\frac{1}{\sqrt{\varepsilon_0 \varepsilon_r\mu_0\mu_r}}=\frac{c}{\sqrt{\varepsilon_r \mu_r}}<br>$$<br>很显然光在介质中的速度比在真空中慢，我们用折射率（Refractive index，用n表示）来描述这一性质<br>$$<br>n=\frac{c}{v}<br>$$<br>光穿过线性介质（linear medium）时，其频率不会发生改变</p><p>光的波长（用$\lambda$表示）<br>$$<br>\lambda=\frac{c}{v}<br>$$</p><h3 id="波粒二象性">波粒二象性</h3><h4 id="波-2">波</h4><p>如果光是波，那么光应该有波的性质：<br>$$<br>\mathbf{k}=\frac{2\pi}{\lambda}\hat{\mathbf{k}}<br>$$</p><p>$$<br>v=\frac{\lambda}{T}=\lambda \nu<br>$$</p><p>$$<br>\omega=2\pi \nu =\frac{2\pi}{T}=\frac{2\pi}{\lambda}v=kv=k_0c<br>$$</p><ul><li>波长（wavelength，用$\lambda$表示）</li><li>波向量（wave vector，用$\mathbf{k}$表示）</li><li>频率（frequency，用$\nu$表示）</li><li>周期（temporal period，用$T$表示）</li><li>角频率（angular frequency，用$\omega$表示）</li><li>速度（velocity，用$v$表示）</li></ul><p>光是电磁波，其电矢量和磁矢量在做简谐振动，一般情况下，我们只讨论电场强度的变化</p><h4 id="粒">粒</h4><p>如果光是粒子，那么光应该有粒子的性质：<br>$$<br>E=h\nu=\hbar \omega<br>$$</p><p>$$<br>\mathbf{p}=\hbar \mathbf{k}=\frac{h}{\lambda}\hat{\mathbf{k}}<br>$$</p><ul><li>能量（Energy，用$E$表示）</li><li>动量（Momentum，用$\mathbf{p}$表示）</li><li>普朗克常量（Plank constant，用$h$表示，$h=6.626\times 10^{-34}\mathrm{J}\cdot\mathrm{s}$</li><li>约化普朗克常量（用$\hbar$表示）</li></ul><h4 id="波粒二象性-2">波粒二象性</h4><p>光具有波粒二象性（Wave-particle duality），光在传播过程中体现出明显的波性，在光与物质交互（light-matter interaction）中粒性更明显</p><h4 id="光子与电子">光子与电子</h4><p>不同之处</p><table><thead><tr><th></th><th>电子</th><th>光子</th></tr></thead><tbody><tr><td>静止质量（Rest mass）</td><td>$m_0$</td><td>0</td></tr><tr><td>运动质量（Motion mass）</td><td>$m$</td><td>$hv/c^2$</td></tr><tr><td>运动速度（Motion velocity）</td><td>$&lt;c$</td><td>$c$</td></tr><tr><td>自旋（Spin）</td><td>1/2</td><td>1</td></tr><tr><td>分布定律</td><td>费力（Fermion）</td><td>玻色（Boson）</td></tr></tbody></table><p>相同之处</p><ul><li>满足波粒二象性</li></ul><h4 id="向量波与标量波">向量波与标量波</h4><p>向量波（Vector wave），波函数是向量的波，比如电磁波（EM wave）</p><p>标量波（Scalar wave），波函数是标量的波，比如声波（Acoustic wave）</p><p>光波（Lightwaves）是一种向量波，但为了方便，我们在讨论干涉衍射时，会认为光是标量波，仅仅在讨论偏振时，才认为光是向量波</p><h3 id="电磁波">电磁波</h3><h4 id="物理量">物理量</h4><ul><li>电场强度（用$\mathrm{E}$表示）：单位电荷在电场中受到的力</li><li>磁场强度（用$\mathrm{H}$表示）：通电导线周围有磁场，其强度与电流大小、距离远近有强度（但实际被后世推翻，无实际意义）</li><li>电场通量密度（用$\mathrm{D}$表示）：单位面积的电场通量</li><li>磁场通量/感应密度（用$\mathrm{B}$表示）：经过一个曲面的磁力线的数量</li></ul><h4 id="电磁学三定律">电磁学三定律</h4><p>库伦定律，真空中两个静止的点电荷间作用力满足<br>$$<br>F=k\frac{q_1q_2}{r^2}<br>$$</p><ul><li>静电力常量（$k=9.0\times 10^9 \mathrm{N} \cdot\mathrm{m^2}/\mathrm{C^2}$）</li></ul><p>安培环路定律（Ampère’s Circuital Law），也叫右手螺旋定则，载流导线能生磁</p><p>法拉第电磁感应定律（Faraday’s Induction Law），磁场变化能产生电场，感应电动势大小与磁通量变化率成正比，电场方向符合楞次定律（由于磁通量的改变而产生的感应电流，其方向为抗拒磁通量改变的方向）</p><h4 id="麦克斯韦方程">麦克斯韦方程</h4><p>真空中麦克斯韦方程：</p><p>法拉第<br>$$<br>\nabla \times \mathbf{E}=-\frac{\partial \mathbf{B}}{\partial t}<br>$$</p><p>安培<br>$$<br>\nabla \times \mathbf{B}=\mu_0 \varepsilon_0 \frac{\partial \mathbf{E}}{\partial t}<br>$$</p><ul><li>真空磁导率（也称为磁常数，用$\mu_0$表示，$\mu_0=4\pi \times 10^{-7}\mathrm{H}/\mathrm{m}$）</li><li>真空电容率（也称为电常数，用$\varepsilon_0$表示，$\varepsilon_0=8.854…\times10^{-12}\mathrm{F}/\mathrm{m}$）</li></ul><p>高斯电场<br>$$<br>\nabla \cdot \mathbf{E}=0<br>$$</p><p>高斯磁场<br>$$<br>\nabla \cdot \mathbf{B}=0<br>$$</p><p>自由空间的波动方程（wave equations，由麦克斯韦方程推出）：<br>$$<br>\nabla^2\mathbf{E}=\mu_0 \varepsilon_0 \frac{\partial^2 \mathbf{E}}{\partial t^2}<br>$$</p><p>$$<br>\nabla^2\mathbf{B}=\mu_0 \varepsilon_0 \frac{\partial^2 \mathbf{B}}{\partial t^2}<br>$$</p><h4 id="平面波">平面波</h4><p>三维的电磁波很难分析，我们可以分解变量，将其转化为两个垂直的平面波</p><p>平面波（Plane waves）：传播时波面在一个平面的电磁波</p><p>平面波的电场方向和磁场方向，与波矢方向垂直，如图，$\mathbf{k}$为波矢方向（推导过程略），从这里也能看出，平面波是横波，方向满足右手定则</p><p><img src="/images/%E5%B9%B3%E9%9D%A2%E6%B3%A2%E6%B3%A2%E7%9F%A2.png" class="lazyload" data-srcset="/images/%E5%B9%B3%E9%9D%A2%E6%B3%A2%E6%B3%A2%E7%9F%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="平面波波矢"></p><p>平面波的磁感应强度B和电场强度E的比值等于波速<br>$$<br>\frac{|E|}{|B|}=\sqrt{\frac{1}{\mu \varepsilon}}=v<br>$$<br>电场强度和磁场强度的关系为（注意，这里不是磁感应强度）<br>$$<br>\sqrt{\varepsilon_0 \varepsilon_r}|\mathrm{E}|=\sqrt{\mu_0\mu_r}|\mathrm{H}|<br>$$<br>自由空间阻抗（单位和电阻相同，用$Z_0$表示）<br>$$<br>Z_0=\sqrt{\frac{\mu_0}{\varepsilon_0}}=376.73\Omega<br>$$<br>波能传递能量，我们引入坡印廷向量（Poynting vector，用$\mathrm{S}$来表示）来描述能量流动，其方向为电磁能传递方向，大小为能流密度（单位面积的能量传输速率）<br>$$<br>\mathrm{S}=\mathrm{E}\times \mathrm{H}<br>$$<br>平面波$\mathrm{E}\times \mathrm{H} // \mathrm{k}$</p><h4 id="傍轴条件">傍轴条件</h4><p>当$\rho \ll z，r \approx z$</p><img src="../../images/傍轴条件.png" class="lazyload" data-srcset="../../images/傍轴条件.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="傍轴条件" style="zoom:50%;" /><h4 id="远场条件">远场条件</h4><h4 id="辐照度">辐照度</h4><p>电磁波的辐照度（Irradiance，用$\mathrm{I}$表示，也称为Intensity），是坡印廷向量在时间上的平均值<br>$$<br>\mathrm{I}=\left&lt; \mathrm{S} \right&gt;=\frac{nc\varepsilon_0}{2}\mathrm{E_0}^2<br>$$</p><ul><li>$c$是真空中光速</li><li>$\mathrm{E_0}$是电磁波电场强度的振幅（电场强度是一个三角周期函数）</li></ul><p>从这里可以看出，辐照度与$\mathrm{E_0}$的平方成正比</p><h2 id="偏振">偏振</h2><p>偏振（Polarization）：光矢量在垂直于传播方向的平面上的震动状态，我们这里提的是电场强度$\mathrm{E}$的震动</p><ul><li><p>根据是否发生偏振</p><ul><li>不偏振光（Unpolarizedlight）</li><li>完全偏振光（Completely polarized light）</li><li>部分偏振光（Partially polarized  light）</li></ul></li><li><p>根据向量$\mathrm{E}$的终点（endpoint）轨迹</p><ul><li>线偏振（Linearly polarized light）</li><li>圆偏振（Circularly polarized light）</li><li>椭圆偏振（Elliptically polarized light）</li></ul></li></ul><p>若光线沿着z轴传播，其方程满足<br>$$<br>(\frac{E_x}{E_{0x}})^2+(\frac{E_y}{E_{0y}})^2-2(\frac{E_x}{E_{0x}})(\frac{E_y}{E_{0y}})\cos \delta = \sin ^2 \delta<br>$$</p><h3 id="线偏振">线偏振</h3><p>当$\delta=2m\pi$时，方程变为<br>$$<br>(\frac{E_x}{E_{0x}})^2+(\frac{E_y}{E_{0y}})^2-2(\frac{E_x}{E_{0x}})(\frac{E_y}{E_{0y}}) = 0 \<br>(\frac{E_x}{E_{0x}}-\frac{E_y}{E_{0y}})^2=0<br>$$<br>于是得到线偏振的方程（一三象限）<br>$$<br>\frac{E_x}{E_{0x}}=\frac{E_y}{E_{0y}} \equiv \cot \alpha<br>$$<br><img src="/images/线偏振.png" class="lazyload" data-srcset="/images/线偏振.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线偏振" style="zoom: 67%;" /></p><p>同理，当$\delta=2(m+1)\pi$时，方程等于（二四象限）<br>$$<br>\frac{E_x}{E_{0x}}=-\frac{E_y}{E_{0y}}<br>$$<br>用虚数将两个方程合并，得到<br>$$<br>\frac{E_x}{E_{y}}=\frac{E_{0x}}{E_{0y}}e^{\mathrm{i}m’\pi}<br>$$</p><ul><li>当$m’$为偶数（0 or even）时，一三象限</li><li>当$m’$为奇数（odd）时，二四象限</li></ul><h3 id="椭圆偏振与圆偏振">椭圆偏振与圆偏振</h3><p>当$\delta=(2m+1)\frac{\pi}{2}$时，方程变为<br>$$<br>(\frac{E_x}{E_{0x}})^2+(\frac{E_y}{E_{0y}})^2=1<br>$$<br>这是一个椭圆方程，我们称之为椭圆偏振</p><p>倘若$E_{0x}=E_{0y}=E_{0}$，方程退化为<br>$$<br>E_x^2+E_y^2=E_0^2<br>$$<br>我们称之为圆偏振</p><img src="/images/椭圆偏振.png" class="lazyload" data-srcset="/images/椭圆偏振.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="椭圆偏振" style="zoom:50%;" /><ul><li><p>当$\delta=\pi / 2$时，y轴驱动x轴移动，此时为顺时针，称为RCP</p></li><li><p>当$\delta=-\pi / 2$时，x轴驱动y轴移动，此时为逆时针，称为LCP</p></li></ul><p><img src="/images/RCP.png" class="lazyload" data-srcset="/images/RCP.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RCP"></p><h3 id="琼斯矢量">琼斯矢量</h3><p>将偏振光的状态以向量的形式写出，方便运算（只适合完全极化光）<br>$$<br>\mathrm{E}=\left[<br>\begin{array}{c}<br>E_x(t)\<br>E_y(t)\<br>\end{array}<br>\right]<br>$$<br>琼斯向量左乘一个2x2矩阵，可以得到一个新的琼斯向量，这个矩阵被称为琼斯矩阵</p><h3 id="偏振度">偏振度</h3><p>偏振度（Degree of polarization，用$P$表示）：用来衡量偏振程度的物理量<br>$$<br>P=\frac{I_p}{I_t}=\frac{I_p}{I_p+I_n}<br>$$</p><ul><li>$I_p$：完全偏振光部分的辐照度</li><li>$I_n$：不偏振光部分（自然光）的辐照度</li></ul><h2 id="吸收">吸收</h2><h3 id="兰伯特定律">兰伯特定律</h3><p>兰伯特定律（Lambert law）：光在气体介质中传播，光强（intensity）随着传播深度增加而递减，满足<br>$$<br>I=I_0 e^{-\alpha x}<br>$$</p><ul><li>吸收系数（用$\alpha$表示）</li><li>传播深度（用$x$表示）</li></ul><h3 id="贝尔定律">贝尔定律</h3><p>贝尔定律（Beer law）：光在溶剂中传播，光强满足<br>$$<br>I=I_0 e^{-ACL}<br>$$</p><ul><li>浓度（用$C$表示）</li><li>常数$A$，与溶质性质有关，与浓度无关</li></ul><p>该公式满足有两个条件</p><ul><li>溶液浓度不能过高，以免出现分子间作用力（这也能解释为什么常数$A$为什么和浓度无关，因为浓度一高，公式就不成立了）</li><li>光强不能过高</li></ul><h2 id="色散">色散</h2><p>色散（Dispersion）：光波的相速度随着频率的改变而改变的现象</p><p><img src="/images/%E8%89%B2%E6%95%A3.png" class="lazyload" data-srcset="/images/%E8%89%B2%E6%95%A3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="色散"></p><p>正常色散（Normal dispersion）：折射率随着波长的增加而减小</p><p>柯西公式：<br>$$<br>n=A+B/\lambda^2+C/\lambda^4<br>$$<br>反常色散（Anomalous dispersion）：折射率随着波长的增加而增加</p><p>反常色散通常发生在吸收带（absorption band）附近，反常色散并不是异常的，叫这个名字只是历史问题</p><h3 id="洛伦兹震荡模型">洛伦兹震荡模型</h3><p>洛伦兹震荡模型（Lorentz oscillator model）：在一个尺寸为$\Delta V$的空间内有一个电子（电荷量为$1.6\times10^{-19}C$），在光的电场作用下，让该电子相对于稳定位置偏离x</p><p>偏振度（单位体积电偶极矩的振幅，用$P$表示）写作<br>$$<br>P=\frac{1}{\Delta V}ex=n_0ex<br>$$</p><ul><li>电荷密度（density of charge，用$n_0$表示）</li><li>$x$是电子的运动方程，如下</li></ul><p>$$<br>x(\omega)=-\frac{eE(\omega)}{m_0}\frac{1}{\omega^2+\mathrm{i}\omega \gamma-\omega_0^2}<br>$$</p><p>将$x$带入，得到<br>$$<br>P=-\frac{n_0e^2}{m_0}\frac{1}{\omega^2+\mathrm{i}\omega \gamma-\omega_0^2}E(\omega)<br>\equiv \varepsilon_0 \chi(\omega)E(\omega)<br>$$<br>根据定义<br>$$<br>\varepsilon=\varepsilon_0[1+\chi(\omega)]<br>$$<br>带入得<br>$$<br>n^2=\varepsilon/\varepsilon_0=1-\frac{n_0e^2}{m_0}\frac{1}{\omega^2+\mathrm{i}\omega \gamma-\omega_0^2}<br>$$<br><img src="/images/洛伦兹模型.png" class="lazyload" data-srcset="/images/洛伦兹模型.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="洛伦兹模型" style="zoom:67%;" /></p><p>如图，洛伦兹模型解释了为什么在靠近吸收带时，会发生反常色散</p><h3 id="组速度">组速度</h3><p>在介质中不同波长的光速度不同，红光波长大，跑的更快</p><p>那么如果一个光，包含了多种波长的光，我们用组速度（Group velocity，用$v_g$表示）来描述其速度<br>$$<br>v_g=\frac{\mathrm{d}\omega}{\mathrm{d}k}<br>$$</p><h2 id="散射">散射</h2><p>一般我们在讨论光在介质中传播，认为是没有损失的，但实际上光在介质中传播是存在吸收的</p><p>吸收：光强度随着穿进介质深度而减弱的现象</p><p>原因：</p><ul><li>光能转化为其他能，比如热量、化学能、电能</li><li>发生散射，光向四面八方传播（丁达尔效应）</li></ul><h3 id="瑞丽散射">瑞丽散射</h3><p>瑞丽散射（Rayleigh scattering）：光在细小粒子间散射<br>$$<br>I_{scat}\propto 1/\lambda^4<br>$$</p><p>$$<br>I_{\theta}\propto I_{\pi/2}(1+\cos^2 \theta)<br>$$</p><h3 id="米氏散射">米氏散射</h3><p>米氏散射（Mie scattering）：光在大型粒子内部散射</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++</title>
      <link href="/program/Effective%20C++/"/>
      <url>/program/Effective%20C++/</url>
      
        <content type="html"><![CDATA[<h1>Effective C++</h1><h2 id="一：C-基础">一：C++基础</h2><h3 id="C-很成熟，很NB">C++很成熟，很NB</h3><p>C++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）</p><p>其核心是四个部分</p><ul><li>C<ul><li>区块block</li><li>语句statements</li><li>预处理器preprocessor</li><li>内置数据类型</li><li>数组arrays</li><li>指针pointers</li></ul></li><li>Object-Orientend C++<ul><li>类classes（构造函数，析构函数）</li><li>封装encapsulation</li><li>继承inheritance</li><li>多态polymorphism</li><li>虚函数virtual（动态绑定）</li></ul></li><li>Template C++</li><li>STL</li></ul><h3 id="替换-define">替换#define</h3><p>使用编译器替代预处理器</p><p>尽量使用const、enum定义常量，使用inlines定义函数宏</p><h4 id="const">const</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br></pre></td></tr></table></figure><p>因为<code>#define</code>不是语言的一部分，在编译器开始工作前，<code>PI</code>就会被处理掉，所以一旦报错，你无法追踪到<code>PI</code>，只能看到<code>3.1415926</code>，这会<strong>浪费你的时间</strong></p><p>应该改为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> Pi <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><p>值得注意的事</p><ul><li>定义常量指针指向char*-based字符串</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> authorName = <span class="string">&quot;Reuben&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GemePlayer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns = <span class="number">5</span>;<span class="comment">//这只是一个声明式</span></span><br><span class="line"><span class="type">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> GamePlayer::NumTurns;<span class="comment">//这是定义式，因为在声明时已经赋值，所以这里就不赋值了</span></span><br></pre></td></tr></table></figure><p>C++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式</p><p>从这里可以看出，<strong>const可以封装</strong>，而#define不行</p><h4 id="enum">enum</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GemePlayer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="const指针">const指针</h3><p>const在星号左边，被指物是常量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = greeting;</span><br></pre></td></tr></table></figure><p>const在星号右边，指针本身是常量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;</span><br></pre></td></tr></table></figure><p>const在星号两边，被指物和指针都是常量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;</span><br></pre></td></tr></table></figure><h3 id="确认对象在使用前已经被初始化">确认对象在使用前已经被初始化</h3><p>C++初始化顺序</p><ul><li>基类比子类先初始化</li><li>成员变量根据其声明次序初始化</li></ul><h2 id="二：构造-析构-赋值">二：构造/析构/赋值</h2><h3 id="空类的默认函数">空类的默认函数</h3><p>一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数</p><p>一个类，如果没有构造函数，也会自动声明一个default构造函数</p><p>这些函数都是public且inline的</p><h3 id="禁用自动生成的函数">禁用自动生成的函数</h3><p>如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）</p><ul><li>你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">HomeForSale</span>(<span class="type">const</span> HomeForSale&amp;);</span><br><span class="line">  HomeForSale&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HomeForSale&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以制作一个不可被copy的类，让子类继承</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">  ~<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">  Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span>: <span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="为多态基类声明virtual析构函数">为多态基类声明virtual析构函数</h3><h4 id="一定要有一个virtual析构函数">一定要有一个virtual析构函数</h4><ul><li>如果这个类要成为一个基类，那么一定要有一个virtual析构函数</li></ul><p>在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicClock</span>: <span class="keyword">public</span> TimeKeeper &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterClock</span>: <span class="keyword">public</span> TimeKeeper &#123;...&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TimeKeeper* ptk = <span class="built_in">getTimeKeeper</span>();<span class="comment">//创建一个动态分配对象</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;<span class="comment">//释放对象，避免资源泄漏</span></span><br></pre></td></tr></table></figure><p>上面这个过程的问题其实出在<code>getTimeKeeper()</code>指向一个派生类（derived class）对象（比如<code>AtomicClock</code>），而这个对象却要经由一个基类（base class）指针删除（比如<code>TimeKeeper*</code>）</p><p>如果这个基类的析构函数不是virtual的，就会出现问题：</p><ul><li>如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象</li></ul><p>解决方法就是给基类一个virtual析构函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TimeKeeper</span>();</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="最好不要有virtual析构函数">最好不要有virtual析构函数</h4><ul><li>如果这个类不可能成为基类，那么最好不要有virtual析构函数</li></ul><p>为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由<strong>vptr（virtual table pointer）<strong>指针携带，这个指针指向一个由函数指针构成的数组，称为</strong>vtbl（virtual table）</strong>，每一个带有virtual函数的类都有一个属于自己的vtbl</p><p><strong>这个vtbl会增大对象的体积</strong>，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍</p><p><strong>这个vtbl会让代码失去兼容性</strong>，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性</p><h4 id="请不要继承没有virtual析构函数的类">请不要继承没有virtual析构函数的类</h4><p>比如string、vector、list、set等等</p><p>而且 C++没有像 Java的<code>final classes</code>或者C#的<code>sealed classes</code>的禁止派生机制</p><h3 id="不要在析构函数里抛出异常">不要在析构函数里抛出异常</h3><p>当一个<code>vector v</code>容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为</p><p>有两个不怎么好的解决方法</p><ul><li>遇到异常，直接<code>std::abort()</code>，即遇到异常，宁愿直接强制停止程序，也不要让异常传播</li><li>遇到异常，把异常记录下来，另程序继续运转，即<strong>吞下异常</strong><ul><li>这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好</li></ul></li></ul><p>比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnevtion</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> DBConnevtion <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span><span class="comment">//封装给客户用的,关闭连接的函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//强制关闭程序或者吞下异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不要在构造和析构过程中调用virtual函数">不要在构造和析构过程中调用virtual函数</h3><p>在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果</p><p>可以简单理解为<strong>在C++中，基类构造期间，vritual函数不是vritual函数</strong></p><p>因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数</p><p>同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的</p><h3 id="令operator-返回一个对-this的引用">令operator=返回一个对*this的引用</h3><p>连续赋值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = y = z = <span class="number">15</span>;</span><br><span class="line"><span class="comment">//其实就等于x = (y = (z = 15))；</span></span><br></pre></td></tr></table></figure><p>为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="xxxxxxxxxx-添加要提交的内容-git-add-文件名-文件夹名-提交所有内容（不包含忽略文件），并设置提交信息为“这是一段话”-git-commit-a-m-这是一段话bash">xxxxxxxxxx #添加要提交的内容$git add 文件名/文件夹名#提交所有内容（不包含忽略文件），并设置提交信息为“这是一段话”$git commit -a -m 这是一段话bash</h3><p>如果对象自己赋给自己，我们称之为自我赋值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">w = w;</span><br><span class="line">a[i] = a[j]; <span class="comment">//当i=j时，自我赋值</span></span><br><span class="line">*px = *py;<span class="comment">//px和py指向同一个物体时，自我赋值</span></span><br></pre></td></tr></table></figure><p>在赋值操作中：</p><ol><li>我们会先另左边的操作数先释放掉当前使用的数据</li><li>令其使用右操作数的副本</li><li>最后返回左操作数</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *pb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//!!!这个不安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果自我赋值，即rhs和pb指向同一个对象，那么<code>delete pb</code>后，这个对象就已经被销毁了，下面使用的<code>*rhs</code>就是一个已经被删除的对象</p><p>解决方法1：延后delete</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法2：使用copy and swap技术</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);<span class="comment">//令*this与temp交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制对象的一切">复制对象的一切</h3><p>如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错</p><p>派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）</p><p>所以copy函数需要</p><ul><li>复制所有local变量</li><li>调用所有基类中的适当的copy函数</li></ul><h2 id="三：资源管理">三：资源管理</h2><h3 id="让对象管理资源">让对象管理资源</h3><p>将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源</p><ul><li>申请资源后立即将其放进对象中，<strong>资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）</strong></li><li>在对象的析构函数中释放资源</li></ul><p>C++的<code>auto_ptr</code>是一个<strong>类指针（pointer-like）对象</strong>，也就是<strong>智能指针</strong>，其析构函数会自动delete掉其所指向的对象</p><p>注意：</p><ul><li>不要让多个<code>auto_ptr</code>指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”</li><li><code>auto_ptr</code>如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权</li></ul><p>**RCSP（引用计数型智能指针）**也是一种智能指针（比如<code>tr1::shared_ptr</code>），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源</p><h3 id="小心copy行为">小心copy行为</h3><p>大多数RAII对象的copy函数：</p><ul><li>禁止复制</li><li>采用引用计数法（RCSP）</li><li>复制底部资源（深拷贝）</li><li>转移底层资源所有权（auto_ptr）</li></ul><h3 id="在资源管理类中提供对原始资源的访问">在资源管理类中提供对原始资源的访问</h3><p>有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）</p><h3 id="new与delete一个数组">new与delete一个数组</h3><p>一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？</p><ul><li>如果new了一个数组，就delete一个数组</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string* ptr1 = <span class="keyword">new</span> string[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> [] ptr1;</span><br></pre></td></tr></table></figure><ul><li>如果new了一个对象，就delete一个对象</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string* ptr2 = <span class="keyword">new</span> string;</span><br><span class="line"><span class="keyword">delete</span> ptr2;</span><br></pre></td></tr></table></figure><p>很多时候很难确定当前这个对象是数组还是一个对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string AddressLines[<span class="number">4</span>];</span><br><span class="line">string* pal = <span class="keyword">new</span> AddressLines;</span><br><span class="line"><span class="keyword">delete</span> [] pal;</span><br></pre></td></tr></table></figure><p>最简单的方法是不用数组，使用STL里的容器，如<code>vector&lt;string&gt;</code></p><h3 id="以独立语句将newed对象置入智能指针">以独立语句将newed对象置入智能指针</h3><p>C++中调用一个函数，会先计算每一个传递进去的实参</p><p>如果按下面的写法，将newed对象置入智能指针中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">分配函数(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), 资源访问);<span class="comment">//不要这样写</span></span><br></pre></td></tr></table></figure><p>需要执行一下函数</p><ul><li>调用“资源访问”函数（A）</li><li>执行<code>new Widget</code>（B）</li><li>调用<code>shared_ptr</code>构造函数（C）</li></ul><p>然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）</p><p>如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏</p><p>所以简单的方法是分离语句</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line">分配函数(pw, 资源访问);</span><br></pre></td></tr></table></figure><h2 id="四：设计与声明">四：设计与声明</h2><h3 id="让接口容易被正确使用">让接口容易被正确使用</h3><p>客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）</p><h4 id="限制参数传递">限制参数传递</h4><p>这是一个日期类</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(<span class="type">int</span> month, <span class="type">int</span> day, <span class="type">int</span> year);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">4</span>, <span class="number">20</span>, <span class="number">2022</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>客户很有可能填错顺序，也有可能填入一个无效的参数</p><p>可以使用<strong>外覆类型（wrapper types）</strong>，当然做出类会更好</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span>&#123;</span><br><span class="line">  <span class="function">explict <span class="title">Day</span><span class="params">(<span class="type">int</span> d)</span> : val(d) &#123;</span>&#125;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span>&#123;</span><br><span class="line">  <span class="function">explict <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span> : val(m) &#123;</span>&#125;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Year</span>&#123;</span><br><span class="line">  <span class="function">explict <span class="title">Year</span><span class="params">(<span class="type">int</span> y)</span> : val(y) &#123;</span>&#125;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(<span class="type">const</span> Mouth&amp; month, <span class="type">const</span> Day&amp; day, <span class="type">const</span> Year&amp; year);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">4</span>), Day(<span class="number">20</span>), Year(<span class="number">2022</span>))</span></span>;</span><br></pre></td></tr></table></figure><h4 id="一致性">一致性</h4><p>自定义的行为要与内置类型的行为一致，比如你不能把<code>operator*</code>重载成<code>operator+</code></p><p>或则像STL中，容器的接口都很一致，比如<code>size</code>、<code>push_back</code>等等</p><h3 id="设计class犹如设计type">设计class犹如设计type</h3><ul><li>对象要如何创建和销毁</li><li>对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）</li><li>对象如果被值传递，意味着什么（深浅拷贝）</li><li>约束成员变量的合法值</li><li>是否可以/需要被继承</li><li>能否类型转换，如何类型转换</li><li>支持何种操作符</li><li>成员变量的访问修饰</li><li>成员函数的访问修饰</li><li>未声明接口（undecided interface）</li><li>是否需要定义模版</li><li>真的需要一个新类吗？</li></ul><h3 id="多用引用传递">多用引用传递</h3><p>C++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些<strong>很大的自定义类型</strong>来说性能非常糟糕</p><p>使用const引用传递会好很多</p><ul><li>不会创建新的对象</li><li>不会改变原有对象</li><li>可以避免<strong>对象切割</strong>问题<ul><li>对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了</li></ul></li></ul><p>只不过引用传递是大多是通过指针实现的，在处理一些<strong>简单的内置类型</strong>时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递</p><h3 id="必须返回对象时，不要返回引用">必须返回对象时，不要返回引用</h3><p>如果必须返回对象，请不要返回引用（比如<code>operator*</code>，<code>operator==</code>），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个<strong>右值</strong>的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用</p><h3 id="将成员变量隐藏">将成员变量隐藏</h3><p>成员变量应该为private，而不是public</p><ul><li>客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）</li><li>分离读写权限（这一点C#做的更好？）</li><li>封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）</li><li>便于对成员变量进行约束（更不容易出现异常值）</li><li>protected并不比public更具有封装性</li></ul><h3 id="使用非成员函数">使用非成员函数</h3><ul><li>C#，java选手可以略过</li><li>C++标准库就是这样写的</li></ul><p>这里有一个类，其中有多个成员函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doB</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doC</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在需要令一个函数做ABC三件事，有两种写法</p><ul><li>成员函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doEverything</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">doA</span>();</span><br><span class="line">    <span class="built_in">doB</span>();</span><br><span class="line">    <span class="built_in">doC</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>非成员函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doEverything</span><span class="params">(WebBrowser&amp; wb)</span></span>&#123;</span><br><span class="line">wb.<span class="built_in">doA</span>();</span><br><span class="line">  wb.<span class="built_in">doB</span>();</span><br><span class="line">  wb.<span class="built_in">doC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令人意外的是，第二种方法（使用非成员函数）更好</p><h4 id="什么是封装">什么是封装</h4><p>一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强</p><p>为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物</p><h4 id="为什么第二种比第一种封装性更强">为什么第二种比第一种封装性更强</h4><p>因为第一种给用户两种调用方法，一个是调用成员函数<code>doEverything()</code>，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性</p><ul><li>注意第一种方法中，<code>doEverything()</code>和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利</li></ul><p>那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的<strong>静态成员（static member）函数</strong>即可</p><p>或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doEverything</span><span class="params">(WebBrowser&amp; wb)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可拓展性更强</p><ul><li>客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）</li></ul></li><li><p>可拆分</p><ul><li>用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）</li></ul></li></ul><h3 id="如果所有参数都需要进行类型转换，使用非成员函数">如果所有参数都需要进行类型转换，使用非成员函数</h3><p>令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时</p><p>比如一个有理数乘法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//这个类没有自定义的explict构造函数</span></span><br><span class="line">  <span class="type">const</span> Rational opertaor* (<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf * oneEighth;<span class="comment">//成功</span></span><br><span class="line">result = result * oneEighth;<span class="comment">//成功</span></span><br><span class="line">result = oneHalf * <span class="number">2</span>;<span class="comment">//成功，等价于 result = oneHalf.operator*(2)</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;<span class="comment">//失败，等价于 result = 2.operator*(oneHalf)</span></span><br></pre></td></tr></table></figure><p><code>result = oneHalf * 2;</code>为什么成功，因为这里发生了一次隐式转换，将<code>2</code>转化为了一个<code>Rational</code>类型</p><p>在编译器中可能等价于</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Rational <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">result = oneHalf * temp;</span><br></pre></td></tr></table></figure><ul><li>如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将<code>2</code>转化为一个<code>Rational</code>类型</li></ul><p><code>result = 2 * oneHalf;</code>为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时<code>2</code>就是一个int类型，没有我们所自定义的<code>operator*</code>函数，自然会失败</p><p>可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此外要极力避免使用<strong>友元（friend）函数</strong></li><li>成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数</li></ul><h3 id="写一个不抛异常的swap函数">写一个不抛异常的swap函数</h3><p>swap函数原本是STL的一部分，后来称为了<strong>异常安全性编程</strong>的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要</p><p>std是一个很特殊的命名空间，客户可以<strong>全特化</strong>（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定</p><p>全特化：针对某个类做模板函数的特例，如对<code>std::swap</code>做一个针对<code>Widget</code>的特化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span>&#123;...&#125;;<span class="comment">//这个类的对象中存储着真正的数据</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>&#123;<span class="comment">//这个函数决对不可抛异常</span></span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);<span class="comment">//这是pimpl写法，交换两个对象只需要置换其pImpl指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImple* pImpl;<span class="comment">//这个类有一个指向资源对象的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;<span class="comment">//这个可以抛异常</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，C++的STL容器就是上面这种写法，提供了<code>public swap</code>成员函数和<code>std::swap</code>的特化版本</p><h2 id="五：实现（Implementations）">五：实现（Implementations）</h2><ul><li>随意定义变量可能会导致性能降低</li><li>过度使用转型（casts）可能会导致性能降低，难以维护，可读性低</li><li>返回对象的内部数据的handles，可能会破坏封装</li><li>未考虑异常可能会导致资源泄露和数据败坏</li><li>过度使用inline可能会导致包体膨胀</li><li>过度耦合（coupling）可能会增加构建时间（build times）</li></ul><h3 id="尽量延后变量定义式的出现时间">尽量延后变量定义式的出现时间</h3><h4 id="避免未曾使用的变量">避免未曾使用的变量</h4><p>如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过</p><p>此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、</p><h4 id="避免无意义的默认构造函数">避免无意义的默认构造函数</h4><p>如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好</p><h4 id="循环">循环</h4><p>此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？</p><p><strong>循环内</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">  <span class="function">Widget <span class="title">w</span><span class="params">(...)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>n个构造函数+n个析构函数</p></li><li><p>如果<code>Widget</code>是一个很敏感的类，这样会让其作用域更小，更容易理解和维护</p></li></ul><p><strong>循环外</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">  w = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个构造函数+一个析构函数+n个赋值操作</li><li>如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）</li></ul><h3 id="少做转型">少做转型</h3><p>C++是强类型语言，设计目标应该是保证类型错误绝不发生，然而<strong>类型转换</strong>破坏了类型系统</p><p>Java、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险</p><p>C++的类型转化</p><ul><li>旧式转换<ul><li><code>(T)expression</code></li><li><code>T(expression)</code></li></ul></li><li>新式转换<ul><li><code>const_cast&lt;T&gt;(expression)</code><ul><li>用于将对象的<strong>常量性转除（cast away the constness）</strong></li><li>比如将<code>const</code>转化为<code>non-const</code></li></ul></li><li><code>dynamic_cast&lt;T&gt;(expression)</code><ul><li>用来<strong>安全向下转型</strong></li><li>无法由旧式语句执行</li><li>耗费巨大</li></ul></li><li><code>reinterpret_cast&lt;T&gt;(expression)</code><ul><li>用于低级转型，实际操作取决于编译器，不可移植</li><li>极其少用</li></ul></li><li><code>static_cast&lt;T&gt;(expression)</code><ul><li>用于<strong>强迫隐式转换（implicit conversions）</strong></li><li>比如<code>non-const</code>转化为<code>const</code>，<code>int</code>转化为<code>double</code>，<code>void*</code>转化为<code>typed</code>，基类指针转化为派生类指针</li></ul></li></ul></li></ul><p>避免C++类型转换出问题的核心是<strong>避免使用基类的接口处理派生类</strong></p><h4 id="一个对象多个地址">一个对象多个地址</h4><p>C++很神奇，如果一个基类指针指向一个派生类对象，如</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Dervied d;</span><br><span class="line">Base* b = &amp;d;</span><br></pre></td></tr></table></figure><p>这可能会导致两个指针值不一样，即这个对象有两个地址，一个<code>Derivied*</code>指针一个<code>Base*</code>指针，这派生类指针上往往会有一个<strong>偏移量（offset）</strong>，通过这个偏移量，可以通过派生类指针找到基类指针</p><p>上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以<strong>请不要假定对象在C++中如何布局</strong>，更不应该基于这个假设对对象进行类型转换</p><p>如果你想让当前对象调用基类的函数，如果对<code>*this</code>做强制转化，转换为基类，<code>*this</code>其实是先前产生的<code>*this</code>对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//static_cast&lt;Window&gt;(*this).onResize();//这样不好</span></span><br><span class="line">    Window::<span class="built_in">onResize</span>();<span class="comment">//请用这种方式调用基类的onResize函数（作用到当前对象上）</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dynamic-cast">dynamic_cast</h4><p>这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象</p><p>什么时候使用这个东西？当<strong>你想在</strong>一个你认为是派生类对象的<strong>对象上执行</strong>派生类的操作<strong>函数</strong>，但你手里却只有一个指向基类的引用/指针时</p><p>解决方法：</p><ul><li>使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器</li><li>在基类中提供virtual函数</li></ul><h3 id="避免返回指向对象内部成分的handles">避免返回指向对象内部成分的handles</h3><p>前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便</p><p>但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span>&#123;</span><br><span class="line">  Point ulhc;<span class="comment">//upper left hand corner</span></span><br><span class="line">  Point lrhc;<span class="comment">//lower right hand corner</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;<span class="comment">//这样返回了引用，非常不好</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::tr1::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>);<span class="comment">//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改</span></span><br></pre></td></tr></table></figure><p><code>upperLeft</code>函数本来只是为了提供给客户获得（get）<code>Rectangle</code>的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了<code>Rectangle</code>本身，而且还是一个内部数据<code>RectData</code></p><p>为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）</p><p>解决方法很简单，只要让handles不可以被修改，就可以了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致<strong>dangling handles（空悬的号码牌）</strong>，比如返回了一个对local变量的引用，依然特别危险</p><p>当然，有的时候不得不返回handles，比如<code>operator[]</code></p><h3 id="异常安全性很重要">异常安全性很重要</h3><p>**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：</p><ul><li>不泄漏任何资源</li><li>不允许数据败坏</li></ul><p>不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂</p><p>三个保证：</p><ul><li>基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏</li><li>强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过<code>copy-and-swap</code>实现）</li><li>不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）</li></ul><p><strong>异常安全码</strong>必须提供上述三种保障之一，如果不能保障，则不具备异常安全性</p><h3 id="了解inline函数">了解inline函数</h3><p>内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化</p><p>缺点也很明显，会让包体变大，会导致<strong>换页行为（paging）</strong>，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数</p><p>内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联</p><h3 id="降低文件间的编译依存">降低文件间的编译依存</h3><p>如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译</p><p>为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用）</p><p>这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类</p><p><em>话说应该不会有人不知道implementation是实现的意思吧</em></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;<span class="comment">//pimpl写法，这是Person类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>;<span class="comment">//Data的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">//Address的前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Persion</span>&#123;<span class="comment">//像这样使用pimpl的类，往往被称为Handle classes</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种设计下，<code>Person</code>就与<code>Data</code>、<code>Address</code>以及<code>Persons</code>的实现分离了，改动这些类也不会导致使用<code>Person</code>的客户重新编译，客户无法看到<code>Person</code>的实现细节，真正实现<strong>接口与实现分离</strong></p><p>这个操作的本质是用<strong>声明的依赖性</strong>替换<strong>定义的依赖性</strong></p><p>此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明</p><p>此外还有另一种制作<code>Handle class</code>的方法，就是令<code>Person</code>成为一个特殊的抽象基类，称为<code>Interface class</code>，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;<span class="comment">//Interface class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;<span class="comment">//具现化</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name...)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name...))</span></span>;</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span>: <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, ...): <span class="built_in">theName</span>(name), ...&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">  <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string theName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::string <span class="title">ReakPerson::name</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, ...)</span></span>&#123;</span><br><span class="line">  retrun std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, ...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六：继承与面向对象">六：继承与面向对象</h2><ul><li><code>is-a</code>：是一个</li><li><code>has-a</code>：有一个</li><li><code>is-implemented-in-terms-of</code>：根据xx实现出</li></ul><h3 id="public继承是is-a关系">public继承是is-a关系</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person&#123;...&#125;;<span class="comment">//Student is a Person</span></span><br></pre></td></tr></table></figure><p>每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化</p><p><strong>public继承下，可以把子类当父类用</strong>，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用</p><p>这就出现了一个问题，子类一定要<code>is a</code>父类，不然会出现问题</p><p>错误的继承：</p><ul><li>企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？</li><li>正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？</li></ul><h3 id="避免遮掩父类成员">避免遮掩父类成员</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<strong>作用域</strong>的<strong>名称遮掩规则</strong>，函数内部的local变量x覆盖了全局变量x</p><h4 id="子类名称会遮掩父类名称，在public继承下是错误的">子类名称会遮掩父类名称，在public继承下是错误的</h4><p>在OOP中，如果子类重载了父类的<code>non-virtual</code>函数，就意味着子类使用同名函数遮掩了父类函数，就意味着<strong>这个父类函数没有被子类继承！</strong>，那么在这种情况下，继承就不是<code>is-a</code>关系了</p><p><strong>在public继承下，子类继承了父类的一切</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">f1</span>();<span class="comment">//正确，调用Derived::f1</span></span><br><span class="line">d.<span class="built_in">f1</span>(x);<span class="comment">//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)</span></span><br><span class="line">d.<span class="built_in">f2</span>();<span class="comment">//正确，调用Derived::f2</span></span><br><span class="line">d.<span class="built_in">f2</span>(x);<span class="comment">//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)</span></span><br></pre></td></tr></table></figure><h4 id="将被遮掩的名称重见天日">将被遮掩的名称重见天日</h4><p>解决起来很简单，只需要让父类的函数在子类作用域内可见，可以<strong>使用using关键字</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::f1;</span><br><span class="line">    <span class="keyword">using</span> Base::f2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">f1</span>();<span class="comment">//正确，调用Derived::f1</span></span><br><span class="line">d.<span class="built_in">f1</span>(x);<span class="comment">//正确，调用Base::f1</span></span><br><span class="line">d.<span class="built_in">f2</span>();<span class="comment">//正确，调用Derived::f2</span></span><br><span class="line">d.<span class="built_in">f2</span>(x);<span class="comment">//正确，调用Base::f2</span></span><br></pre></td></tr></table></figure><p>如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以<strong>使用转交函数</strong>，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base::<span class="built_in">f1</span>();<span class="comment">//inline转交函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">f1</span>();<span class="comment">//正确，调用Derived::f1</span></span><br><span class="line">d.<span class="built_in">f1</span>(x);<span class="comment">//错误，因为Derived::f1遮掩了Base::f1</span></span><br></pre></td></tr></table></figure><h3 id="区分接口继承和实现继承">区分接口继承和实现继承</h3><p>public继承分为两个部分</p><ul><li>函数接口继承</li><li>函数实现继承</li></ul><table><thead><tr><th></th><th>接口继承</th><th>实现继承</th></tr></thead><tbody><tr><td>纯虚函数</td><td>具体指定</td><td>不继承</td></tr><tr><td>非纯虚函数</td><td>具体指定</td><td>继承一份缺省实现</td></tr><tr><td>non-virtual函数</td><td>具体指定</td><td>继承一份强制实现</td></tr></tbody></table><h3 id="考虑使用virtual以外的选择">考虑使用virtual以外的选择</h3><h4 id="基于NVI的Template-Method模式">基于NVI的Template Method模式</h4><p>Non-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>healthValue()</code>被称为virtual函数的<strong>外覆器（wrapper）</strong></p><h4 id="基于函数指针的Strategy模式">基于函数指针的Strategy模式</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: healthFunc(hcf)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种模式下，<code>defaultHealthCalc</code>函数不再是<code>GameCharacter</code>体系内的成员函数，通过修改函数指针，就可以让<code>GameCharacter</code>使用不同种类的计算函数，弹性更强，而且可以在运行时变更</p><p>此外<code>defaultHealthCalc</code>函数不需要/不能访问<code>GameCharacter</code>内的<code>non-public</code>部分，</p><h4 id="基于tr1-function的Strategy模式">基于tr1::function的Strategy模式</h4><p>上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如<code>tr1::function</code>对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::tr1::function&lt;<span class="type">int</span> (<span class="type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: healthFunc(hcf)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="古典的Strategy模式">古典的Strategy模式</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span></span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span>: pHealthFunc(phcf)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> phealthFunc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="绝不重新定义继承而来的non-virtual函数">绝不重新定义继承而来的non-virtual函数</h3><ul><li>静态绑定（staticcally bound）：non-virtual就是这种</li><li>动态绑定（dynamically bound）：virtual就是这种</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">D x;</span><br><span class="line">B* pB = &amp;x;</span><br><span class="line">D* pD = &amp;x;</span><br><span class="line">pB-&gt;<span class="built_in">f</span>();<span class="comment">//调用B::f</span></span><br><span class="line">pD-&gt;<span class="built_in">f</span>();<span class="comment">//调用D::f</span></span><br></pre></td></tr></table></figure><h3 id="绝对不重新定义继承而来的缺省参数值">绝对不重新定义继承而来的缺省参数值</h3><p><strong>virtual函数是动态绑定的，缺省参数值是静态绑定的</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cricle</span>: <span class="keyword">public</span> Shape&#123;...&#125;;</span><br><span class="line">...</span><br><span class="line">Shape* p1;<span class="comment">//p1的静态类型是Shape*，没有动态类型</span></span><br><span class="line">Shape* p2 = <span class="keyword">new</span> Circle;<span class="comment">//p2的静态类型是Shape*，动态类型是Circle*</span></span><br></pre></td></tr></table></figure><ul><li>静态类型<ul><li>指针的类型就是<strong>静态类型</strong></li></ul></li><li>动态类型<ul><li>所指向的对象的类型是<strong>动态类型</strong></li><li>动态类型可以通过赋值等操作改变</li></ul></li></ul><p>virtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载</p><p>但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数</p><h3 id="has-a和根据xx实现出">has-a和根据xx实现出</h3><p>一个类中有多个小类，这种关系被称为<strong>复合（composition）</strong>，其中这些小类被称为<strong>合成成分物（composed object）</strong></p><ul><li>在应用域，复合意味着<code>has-a</code><ul><li>人有名字（也不尽然）</li></ul></li><li>在实现域，复合意味着<code>is-implemented-in-terms-of</code><ul><li>队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）</li></ul></li></ul><h3 id="少用private继承">少用private继承</h3><p><em>经典 C++糟粕，请问 C#有这个吗？</em></p><p>本质上是一种<code>is-implemented-in-terms-of</code>关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术</p><ul><li>private继承，编译器无法自动将子类对象转化为父类对象</li><li>private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）</li></ul><p><strong>尽量使用复合来替代pirvate继承</strong>，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数</p><p>此外private继承的对象有可能比复合的对象要小</p><h3 id="少用多重继承">少用多重继承</h3><p><em>经典 C++糟粕，请问 C#有这个吗？</em></p><ul><li>可能会导致歧义<ul><li>当然你可以在调用函数的时候指出是来自哪一个基类</li></ul></li><li>可能会导致菱形继承<ul><li>菱形继承可能会导致变量重复</li></ul></li></ul><h2 id="七：模版与泛型">七：模版与泛型</h2><p>模板（templates）是泛型编程（generic programming）的基础</p><p>模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译</p><h3 id="评价">评价</h3><p>优点：</p><ol><li>模板编程能够实现非常灵活且类型安全的接口</li><li>极好的性能（更小的文件、更短的运行期，更少的内存需求）</li><li>可以将一些运行时才能侦测到的错误，在编译期找出来</li></ol><p>缺点：</p><ol><li>难以编程和维护</li><li>编译报错信息难以理解</li><li>难以重构</li><li>编译时间大幅变长</li></ol><p>因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释</p><h3 id="隐式接口和编译期多态">隐式接口和编译期多态</h3><ul><li>OOP中经常使用显式接口和运行时多态</li><li>泛型编程更多使用隐式接口和编译期多态</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget)&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span></span><br><span class="line"><span class="function">        temp.<span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组<strong>隐式接口</strong></p><p>所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功</p><p>这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是<strong>编译期多态</strong></p><h3 id="Traits">Traits</h3><p>一种约定俗成的技术方案，为同一类数据提供统一的操作函数</p><p>比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">    TYPE_1;</span><br><span class="line">    TYPE_2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FOO</span>&#123;</span><br><span class="line">    Type type = Type::TYPE_1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line">    Type type = Type::TYPE_2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//统一的模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(<span class="type">const</span> T&amp; data, <span class="type">char</span>* buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T::type == Type::TYPE_1)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T::type == Type::TYPE_2)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">    TYPE_1;</span><br><span class="line">    TYPE_2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FOO</span>&#123;</span><br><span class="line">    Type type = Type::TYPE_1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line">    Type type = Type::TYPE_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_traits</span>&#123;</span><br><span class="line">    Type type = T::type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为内置数据类型特化为独有的 type_traits</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_traits</span>&#123;</span><br><span class="line">    Type type = Type::TYPE_1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统一的模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(<span class="type">const</span> T&amp; data, <span class="type">char</span>* buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type_traits&lt;T&gt;::type == Type::TYPE_1)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type_traits&lt;T&gt;::type == Type::TYPE_2)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因</p><h3 id="模板元编程">模板元编程</h3><p>TMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化</p><p>如果一门语言具备以下功能，则称为图灵完全</p><ol><li>数值运算和符号运算</li><li>判断</li><li>递归</li></ol><h4 id="数值运算-递归">数值运算+递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个TMP计算阶乘，而且阶乘的技术发生在编译期</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11TMP这种函数式编程得到了加强，上文也可以这样写</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value&#123; n * Factorial&lt;n - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="判断">判断</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">if_constexpr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">if_constexpr</span>&lt;<span class="literal">false</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; if_constexpr&lt;<span class="literal">true</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; if_constexpr&lt;<span class="literal">false</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typedef">typedef</h3><p>在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名</p><p>下面是一个函数指针的示例</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x+y=&quot;</span> &lt;&lt; x + y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dec</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x-y=&quot;</span> &lt;&lt; x - y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x*y=&quot;</span> &lt;&lt; x*y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*op[<span class="number">3</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123; add, dec, mul &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        （*op[i])(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用typedef</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Func[<span class="number">3</span>])</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">Func f = &#123; add, dec, mul &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        f[i](<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八：定制new和delete">八：定制new和delete</h2><p>Java和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目</p><h3 id="new-handler">new-handler</h3><p>当<code>operator new</code>无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即<code>new-handler</code></p><p>使用<code>set_new_handler</code>来指定<code>new-handler</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;内存不足\n&quot;</span>;</span><br><span class="line">  std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::<span class="built_in">set_new_handler</span>(outOfMem);<span class="comment">//该函数的参数是一个函数指针</span></span><br><span class="line">  <span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10000000L</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>operator new</code>无法满足内存申请时，会不断调用<code>new-handler</code>函数，直到找到足够的内存，所以<code>new-handler</code>函数应该满足</p><ul><li>让更多的内存可被使用<ul><li>实现方法是程序开始时就分配一大块内存，每次调用<code>new-handler</code>时就释放一点点</li></ul></li><li>安装另一个<code>new-handler</code><ul><li>如果现在这个<code>new-handler</code>无法获取更多内存，需要知道哪一个<code>new-handler</code>具备增大内存的实力，然后使用<code>set_new_handler</code>来替换自己</li></ul></li><li>卸除<code>new-handler</code><ul><li>通过<code>set_new_handler</code>赋值<code>null</code>，将<code>new-handler</code>卸载，使得在内存分配不足时，会抛异常</li></ul></li><li>抛出<code>bad_alloc</code>异常<ul><li>这种异常不会被<code>operator new</code>捕获，会被传播至内存索求处</li></ul></li><li>不反回<ul><li>调用<code>abort</code>或者<code>exit</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerHolder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span>: handler(nh) &#123;</span>&#125;<span class="comment">//获取当前的new_handler</span></span><br><span class="line">  ~<span class="built_in">NewHandlerHolder</span>() &#123; std::<span class="built_in">set_new_handler</span>(handler); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::new_handler handler;<span class="comment">//用于记录当前的new_handler</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>&#123;</span><br><span class="line">  <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;<span class="comment">//安装Widget的new-handler</span></span><br><span class="line">  <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);<span class="comment">//分配对象或者抛异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;</span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(outOfMem);</span><br><span class="line">Widget* pwl = <span class="keyword">new</span> Widget;<span class="comment">//内存不足时会调用outOfMem</span></span><br></pre></td></tr></table></figure><p>mixin风格的写法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> std::new_handler_set <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">throw</span>()&#123;</span><br><span class="line">  std::new_handler oldHandler = currentHandler;</span><br><span class="line">  currentHandler = p;</span><br><span class="line">  <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>&#123;</span><br><span class="line">  <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt;&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为<strong>怪异的循环模版模式（curiously recurring template pattern，CRTP）</strong></p><h3 id="替换new和delete的时机">替换new和delete的时机</h3><p>C++中所有的news返回的指针都必须要<strong>地址对齐</strong>，int要4对齐，double要8对齐</p><p>写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换</p><h3 id="编写new和delete的规则">编写new和delete的规则</h3><p>如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则</p><ul><li><p>new</p><ul><li>应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用<code>new-handler</code></li><li>有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）</li><li>new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理<strong>比正确大小更大的（错误）申请</strong></li></ul></li><li><p>delete</p><ul><li>收到null指针时不做任何事</li><li>处理<strong>比正确大小更大的（错误）申请</strong></li></ul></li></ul><h3 id="编写new时也要写对应的delete">编写new时也要写对应的delete</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget* pw = <span class="keyword">new</span> Widget;</span><br></pre></td></tr></table></figure><p>在这里调用了两个函数，一个时用以分配内存的<code>operator new</code>，一个是<code>Widget</code>的构造函数</p><p>如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的</p><p>运行时系统会调用<code>operator new</code>所对应的<code>operator delete</code>来释放地址，对于拥有正常签名式的new和delete来说不成问题</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;<span class="comment">//普通的new</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//global中的普通的new</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory, std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//class中的new</span></span><br></pre></td></tr></table></figure><p>但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//placement new，比普通new多带一个参数</span></span><br><span class="line"></span><br><span class="line">Widget* pw = <span class="built_in">new</span> (std::cerr) Widget;<span class="comment">//调用operator new，并以cerr作为其实参</span></span><br></pre></td></tr></table></figure><p>当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的<code>operator new</code>时如何运作的，所以运行时系统会去寻找<strong>参数个数与类型</strong>都与<code>operator new</code>相同的某个<code>operator delete</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*, std::ostream&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//palcement delete</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemoty, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果此时调用<code>delete pw</code>，只会调用普通的<code>delete</code>，因为只有在构造时发生异常时，运行时系统才会调用placement delete</p><p>最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete</p><h2 id="九：杂项">九：杂项</h2><h3 id="不要忽视编译器警告">不要忽视编译器警告</h3><p>很多人忽视警告，毕竟一个问题如果真的很严重，应该报错</p><p>比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>报警告</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">warning: D::<span class="built_in">f</span>() <span class="function">hides <span class="keyword">virtual</span> <span class="title">B::f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>原本的目的是为了在D中重新定义virtual函数<code>f()</code>，但由于B中<code>f()</code>是const，在D中不是，此时B中的<code>f()</code>并没有在D中重新被声明，而是被整个遮掩了</p><h3 id="去熟悉标准程序库">去熟悉标准程序库</h3><p>尤其是TR1</p><h4 id="C-98有什么">C++98有什么</h4><ul><li>STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器</li><li>Iostream</li><li>国际化支持</li><li>数值处理，包括复数（complex）和纯数值数组（valarray）</li><li>异常阶层体系</li><li>C89标准程序库</li></ul><h4 id="TR1有什么（全在std-tr1中）">TR1有什么（全在<code>std::tr1</code>中）</h4><ul><li>智能指针<code>tr1::shared_ptr</code>和<code>tr1::weak_ptr</code></li><li><code>tr1::function</code></li><li><code>tr1::bind</code></li></ul><p>和（彼此无关的独立组件）</p><ul><li>哈希表</li><li>正则表达式</li><li>Tuple变量组</li><li><code>tr1::array</code></li><li><code>tr1::mem_fn</code></li><li><code>tr1::reference_wrapper</code></li><li>随机数生成工具</li><li>数学特殊函数</li><li>C99兼容</li></ul><p>和（基于template）</p><ul><li>Type traits</li><li><code>tr1::result_of</code></li></ul><h3 id="熟悉Boost">熟悉Boost</h3>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu入门</title>
      <link href="/program/Ubuntu%E5%85%A5%E9%97%A8/"/>
      <url>/program/Ubuntu%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>Ubuntu入门</h1><p>虽说是Ubuntu，实际上是WSL2</p><p>你可以使用neofetch查看系统信息</p><p><img src="/images/neofetch.png" class="lazyload" data-srcset="/images/neofetch.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="neofetch"></p><h3 id="环境搭建">环境搭建</h3><h4 id="VS-Code">VS Code</h4><ol><li>在Windows系统中安装VS Code，并选择添加PATH</li><li>在WSL中如果要打开当前目录，直接输入</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$code</span> .</span><br></pre></td></tr></table></figure><p>推荐安装VS Code的WSL插件</p><p>使用快捷键<code>CTRL+SHIFT+P</code>，打开命令面板，键入<code>WSL</code>，进行一些设置</p><h4 id="Git">Git</h4><p>使用Git前需要先配置git config，可以输命令，也可以无脑用vscode改<code>.gitconfig</code>文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line"><span class="variable">$git</span> config --global user.email <span class="string">&quot;youremail@domain.com&quot;</span></span><br></pre></td></tr></table></figure><h3 id="常用命令">常用命令</h3><table><thead><tr><th>命令</th><th>意义</th><th></th></tr></thead><tbody><tr><td>ls -a</td><td>查看当前目录内容</td><td></td></tr><tr><td>cd 路径名</td><td>路径跳转</td><td></td></tr><tr><td>clear</td><td>清空窗口</td><td></td></tr><tr><td>find 文件名</td><td>找出当前文件夹内符合条件的文件</td><td>支持正则</td></tr><tr><td>whoami</td><td>查看当前用户身份</td><td></td></tr><tr><td>pwd</td><td>查看当前工作目录</td><td></td></tr><tr><td>cat test.txt</td><td>查看文件内容</td><td></td></tr><tr><td>cat &gt; new.txt</td><td>新建文件</td><td></td></tr><tr><td>cat file1 file2 &gt; file</td><td>合并文件</td><td></td></tr><tr><td>mkdir 文件夹名</td><td>创建文件夹</td><td>-p可以创建多级文件夹</td></tr><tr><td>cp src dst</td><td>复制文件</td><td></td></tr><tr><td>kill 进程名</td><td>杀死进程</td><td></td></tr><tr><td>unzip</td><td>解压zip文件</td><td>需要先安装unzip</td></tr><tr><td>rm test.txt</td><td>删除文件</td><td>-r递归删文件夹 -f强删</td></tr></tbody></table><h3 id="文件访问">文件访问</h3><p>Windows访问Linux文件，路径为<code>\\wsl$\Ubuntu-20.04\home\username</code></p><p>Linux访问Windows文件，路径为<code>/mnt/c/Users/username</code></p><h3 id="apt-get">apt-get</h3><p>Linux内置的包管理器，可以非常优雅地安装管理各种包、软件</p><h4 id="安装">安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装git</span></span><br><span class="line"><span class="variable">$sudo</span> apt-get install git</span><br><span class="line"><span class="comment">#安装tbb</span></span><br><span class="line"><span class="variable">$sudo</span> apt-get install libtbb-dev</span><br></pre></td></tr></table></figure><h4 id="查看所有已安装软件">查看所有已安装软件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有已安装软件（这个信息量巨大，而且有重复信息，不简易使用）</span></span><br><span class="line"><span class="variable">$sudo</span> apt-cache search all</span><br><span class="line"><span class="comment">#查看所有已安装软件（去重）</span></span><br><span class="line"><span class="variable">$sudo</span> apt-cache search all | <span class="built_in">wc</span></span><br><span class="line"><span class="comment">#查看所有名字中带gcc的软件</span></span><br><span class="line"><span class="variable">$sudo</span> apt-cache search all | grep gcc</span><br></pre></td></tr></table></figure><h4 id="E-Unable-to-locate-package">E: Unable to locate package</h4><p>如果遇到这个报错，可以执行一次更新</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> apt-get update</span><br></pre></td></tr></table></figure><h4 id="C-安装清单">C++安装清单</h4><table><thead><tr><th>包名</th><th>描述</th></tr></thead><tbody><tr><td>g++</td><td>C++编译器</td></tr><tr><td>libtbb-dev</td><td>tbb并行库</td></tr><tr><td>cmake</td><td>项目构建</td></tr><tr><td>git</td><td>版本管理</td></tr><tr><td>gfortran</td><td>fortran编译器</td></tr><tr><td>liblapack-dev、liblapacke-dev</td><td>BLAS和LAPACK线代库</td></tr><tr><td>gdb</td><td>调试器</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="Git使用">Git使用</h3><h4 id="拉取项目">拉取项目</h4><p>项目拉取有两种常见方法</p><ul><li><p>ssh：需要配置SSH Key，只能拉自己的项目，但不提交时不需要账号密码</p></li><li><p>https：非常方便，只需要git clone，而且可以拉别人的项目，但提交时需要输入账号密码</p><ul><li>其实你也可以在输入一次密码后输入</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> config --global credential.helper store</span><br></pre></td></tr></table></figure><p>我们这里说的密码是token，可以去<a href="https://github.com/settings/tokens">Github</a>生成token</p><h4 id="提交">提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加要提交的内容</span></span><br><span class="line"><span class="variable">$git</span> add 文件名/文件夹名</span><br><span class="line"><span class="comment">#提交所有内容（不包含忽略文件），并设置提交信息为“这是一段话”</span></span><br><span class="line"><span class="variable">$git</span> commit -a -m 这是一段话</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
