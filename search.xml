<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>强化学习与扩散模型</title>
      <link href="/ai/RL/"/>
      <url>/ai/RL/</url>
      
        <content type="html"><![CDATA[<h1>强化学习与扩散模型</h1><p>在不远的过去，强化学习被各种唱衰，环境难以模拟、算法难以泛化、激励难以设计、应用场景有限等等。很多人认为强化学习很酷，但就是“没用”。但随着LLM的兴起，RL可以帮助LLM实现对齐人类偏好、提升生成质量、低成本Post Train，RL瞬间成为了一种杀手级应用。最近一段时间，无论是LLM、Diffusion、具身智能，都开始搞RL了。</p><p>RL这种范式，在Diffusion训练上可能极具潜力，我最近打算使用RL训练Diffusion，以提升美学质量和图文对齐程度，于是从头开始学习RL</p><h2 id="强化学习">强化学习</h2><p>强化学习（reinforcement learning，RL）讨论的是智能体（agent）如何在环境中最大化奖励。智能体一直在与环境交互，智能体会评估当前状态，输出动作，获得奖励。</p><ul><li><p>状态（State）：在生成模型中可以定义为中间图像、latent</p></li><li><p>动作（Action）：在生成模型中可以定义为预测噪声/方向</p></li><li><p>策略（Policy）：扩散模型的参数</p><ul><li>on-policy：边做边学（学下棋时每一步都有老师来评价你下的好不好）</li><li>off-policy：看别人怎么玩（学下棋时看别人的棋谱）</li></ul></li><li><p>环境（Environment）</p></li><li><p>奖励（Reward）</p><ul><li>model free：没有显式的状态转移概率和奖励函数</li><li>model base：有显示的可学习的状态转移函数和奖励模型（Reward model）</li></ul></li></ul><img src="/images/AE_loop.png" class="lazyload" data-srcset="/images/AE_loop.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="AE_loop" style="zoom: 25%;" /><h3 id="传统RL算法">传统RL算法</h3><h4 id="Q-Learning">Q-Learning</h4><p>一种off-policy方法</p><p>Q表格是一张已经训练好的表格，行是状态数，列表示在该状态下该动作的平均总奖励，形如</p><table><thead><tr><th></th><th>动作1</th><th>动作2</th></tr></thead><tbody><tr><td>状态1</td><td>0</td><td>-90</td></tr><tr><td>状态2</td><td>0</td><td>10</td></tr></tbody></table><p>表格型方法：通过查Q表格，我们就可以判断某个状态应该使用什么动作。训练的过程就是将一张空的Q表格填满，用蒙特卡洛采样的方式更新Q表格</p><h4 id="DQN">DQN</h4><blockquote><p>Deep Q-Network</p></blockquote><p>Q-Learning的深度学习版本，用神经网络去模拟Q表格</p><h4 id="策略梯度">策略梯度</h4><blockquote><p>Policy Gradient</p></blockquote><p>策略（policy）是智能体的决策规则，是智能体在状态 $s$ 下采取行动 $a$ 的概率，由参数 $\theta$ 控制<br>$$<br>\pi_\theta(a|s)<br>$$<br>策略是参数化的 $\pi_\theta$，将长期奖励目标视为 $\theta$ 的函数，用梯度上升的方法优化它</p><p>直观含义是：</p><ol><li>如果一个动作回报高，则增加这个动作的概率</li><li>如果一个动作回报低，则降低这个动作的概率</li></ol><p>根据学习策略和环境策略，可以分为</p><ul><li>同策略（on-policy）：学习的策略和与环境交互的策略是同一个，如PPO</li><li>异策略（off-policy）：学习的策略和与环境交互的策略可以不同，如Q-Learning、DQN</li></ul><blockquote><p>以学下棋为例，如果一个人每下一步棋，就有老师给他打分，这个棋局是自己下出来的，就是同策略。而如果是观察他人下棋，老师告诉你哪一步是好棋/坏棋，这就是异策略</p></blockquote><h3 id="PPO">PPO</h3><p>近端策略优化（proximal policy optimization，PPO），目标是做保守的策略更新，用替换目标（surrogate objective）衡量新策略相对旧策略的改进，并用clipping或KL惩罚来防止更新幅度过大，兼顾学习速度和稳定性</p><p>RM负责对策略进行打分</p><blockquote><p>以学下棋为例：</p><p>采样：下棋</p><p>打分：老师评价下的好不好</p><p>比较新旧策略：学生修改下法，并评估新旧策略变化 $r = \frac{\pi_{new}}{\pi_{old}}$</p><p>clipping：从“当头炮”改为“马先跳”，概率改动太大，舍弃这次</p><p>优势函数：老师不仅告诉学生这一步走的好/坏，还要告诉这步棋比平均水准高多少</p><p>更新策略：根据优势函数和概率比 $r$ ，微调自己的策略</p></blockquote><h3 id="DPO">DPO</h3><p>没有显式的RM，而是人工构造成对数据，将对齐问题转化为监督学习问题。在小规模数据上比较方便，不需要RM和复杂的训练流程，但是数据量增大后成本过高不可行</p><h3 id="GRPO">GRPO</h3><p>组相对策略优化（Group Relative Policy Optimization，GRPO），最早源自DeepSeek，用组内相对分数（这个相对分数可以来自Reward Model）来构造优势，省去价值（Critic）网络</p><blockquote><p>以学下棋为例：</p><ol><li><p>对于一个局面，列举了多种下法，如走炮、跳马、拱卒</p></li><li><p>老师评价相对分数，如走炮最好，然后是跳马，最差是拱卒</p></li><li><p>构建相对优势（走炮不需要知道自己具体多少分，只需要知道比平均值高，是正的，而拱卒的优势是负的）</p></li><li><p>用概率比 $r = \frac{\pi_{new}}{\pi_{old}}$ 更新策略</p></li></ol></blockquote><h2 id="Reward-Model">Reward Model</h2><p>Reward Model根据输入输出类别，可以分为</p><ul><li>pointwise：输入一张图，输出标量分数</li><li>pairwise：输入一组图片，输出相对分数</li></ul><p>根据模型架构，可以分为</p><ul><li><p>分类器，输入数据输出标量数字/好坏</p><ul><li><p>CLIP + MLP：CLIP将文本prompt和图像提取feature，用MLP打分</p></li><li><p>VLM + MLP：VLM将文本prompt和图像提取feature，用MLP打分</p></li></ul></li><li><p>生成式VLM：将评价过程视为一个生成任务，先进行一段CoT分析，再给出分数/好坏</p></li><li><p>LLM as Judge：用一个超强的LLM作为Reward Model进行打分</p><ul><li>位置偏见，模型可能会偏向认为第一/二个出现的回答更好，可以通过交换位置多测试克服</li><li>长度偏见，模型可能会认为写的长的回答更好</li><li>自我偏见，模型可能会更喜欢自己模型风格的内容（比如让GPT去评价一组由GPT、Gemini、DeepSeek生成的内容，GPT更喜欢GPT风格的内容）</li></ul></li></ul><table><thead><tr><th>工作</th><th>模型架构</th><th>开源数据集</th><th>数据量</th></tr></thead><tbody><tr><td>HPSv2</td><td>CLIP + MLP</td><td>ymhao/HPDv2</td><td>798k对</td></tr><tr><td>PickScore</td><td>CLIP + MLP</td><td>yuvalkirstain/PickaPic-rankings</td><td>150k对</td></tr><tr><td>ImageReward</td><td>BLIP + MLP</td><td>zai-org/ImageRewardDB</td><td>137k对</td></tr><tr><td>HPSv3</td><td>VLM + MLP</td><td>MizzenAI/HPDv3</td><td>1M 对</td></tr><tr><td>UnifiedReward</td><td>VLM</td><td>CodeGoat24/EvalMuse，CodeGoat24/HPD，CodeGoat24/OIP</td><td>35k对</td></tr><tr><td>UnifiedReward CoT</td><td>VLM</td><td>CodeGoat24/ImageGen-CoT-Reward-5K</td><td>5k对</td></tr><tr><td>RewardDance</td><td>VLM</td><td></td><td></td></tr></tbody></table><h3 id="动机">动机</h3><p>训练Diffusion时，目标常常是MSE（噪声重建损失）和最大似然（log-likehood），但是这些训练目标并不一定符合人类审美</p><ol><li>将人类偏好转化为可优化的信号</li><li>提供可用于RL的Reward</li><li>解决不可微指标的问题（如语义一致性、美学质量、肢体合理性）</li></ol><p>理论上收集满足人类偏好的数据进行SFT，也可以用于优化模型，但是大规模收集人类反馈的成本过高。在有限量的偏好数据中训练Reward Model，在用RM做视觉模型的对齐，效率更高</p><h3 id="挑战">挑战</h3><ul><li>奖励稀疏</li><li>模式坍塌</li><li>Reward Hacking：Diffusion模型学会了最大化奖励函数，但没能真的学会你想要的能力，而是利用奖励函数的漏洞来作弊，取巧没学到真东西</li></ul><blockquote><p>一个经典的Reward Hacking，如果我想要模型生成一个梵高风格的画，结果一些模型生成了带有”梵高“签名的普通作品，这些普通作品可能会得到更高的Reward分数，导致模型没能成功学会生成梵高风格的画，而是学会生成梵高签名</p></blockquote><h3 id="HPSv2">HPSv2</h3><blockquote><p>《Human Preference Score v2: A Solid Benchmark for Evaluating Human Preferences of Text-to-Image Synthesis》2023.9</p></blockquote><h3 id="PickScore">PickScore</h3><blockquote><p>《Pick-a-Pic: An Open Dataset of User Preferences for Text-to-Image Generation》2023.11</p></blockquote><h3 id="ImageReward">ImageReward</h3><blockquote><p>《ImageReward: Learning and Evaluating Human Preferences for Text-to-Image Generation》2023.12</p></blockquote><h4 id="动机-2">动机</h4><p>扩散模型在保真度和多样性上取得非常好的成绩，但是与人类偏好还是有差异</p><ul><li>文本图像对齐：无法准确捕捉提示词中的数量、属性、空间关系（生成错误数量多猫、错误位置的猫）</li><li>人体结构畸形：肢体扭曲、多余、融合、残缺（多/少手指）</li><li>审美偏差：生成结果偏离主流人类审美（如诡异的光影、畸形的脸、廉价的卡通感、AI感）</li><li>毒性和偏见（如NSFW）</li></ul><p>作者希望将RLHF（reinforcement learning from human feedback）的范式引入到视觉生成模型领域</p><h4 id="创新点">创新点</h4><ol><li>基于BLIP的Reward模型</li><li>搭建一套偏好数据标注、处理流程</li><li>ReFL训练Diffusion</li></ol><h4 id="数据">数据</h4><ol><li><p>从DiffusionDB中挑选真实用户prompt，基于图算法和大模型判断prompt相似度，保证了prompt的多样性</p></li><li><p>人工标注了137k pair数据</p></li></ol><p>标注流程：</p><ol><li>提示词标注<ol><li>将prompt进行预分类，如人物肖像类、风景类、动物类、静物 / 食品类、抽象艺术类</li><li>问题识别，剔除模糊不清、含有有害内容的数据</li></ol></li><li>文本图像评分<ol><li>Alignment 对齐度</li><li>Fidelity 逼真度</li><li>Harmlessness 无害性</li></ol></li><li>图像排序</li></ol><h4 id="Reward模型架构">Reward模型架构</h4><p>基于BLIP，将图片和文本提取feature，用cross attention合并，用MLP输出分数</p><h3 id="HPSv3">HPSv3</h3><blockquote><p>《HPSv3: Towards Wide-Spectrum Human Preference Score》2025.8</p></blockquote><h4 id="Reward模型架构-2">Reward模型架构</h4><p>VLM提取文本和图像feature，MLP打分</p><h4 id="Loss设计">Loss设计</h4><p>Loss设计为二选一的偏好建模，希望可以把偏好的样本分数提高，次偏样本分数压低</p><p>作者提供了两个殊途同归的Loss，最小化KL散度和最大化BT似然</p><h5 id="KL-divergence">KL-divergence</h5><p>相对熵/KL散度，用于衡量两个概率分布之间差距的度量</p><h5 id="Bradley–Terry">Bradley–Terry</h5><p>Bradley–Terry 模型是一种用于<strong>建模成对比较偏好概率</strong>的经典统计模型</p><p>它假设每个样本 $i$ 有一个潜在的“实力”或“得分” $s_i$，然后用 softmax 形式建模偏好概率：<br>$$<br>P(i \succ j) = \frac{\exp(s_i)}{\exp(s_i) + \exp(s_j)}=\mathrm{sigmoid}(s_i-s_j)<br>$$</p><p>$$<br>\mathcal{L}<em>{BT} = - \log P</em>\theta(i \succ j)<br>$$</p><h3 id="UnifiedReward">UnifiedReward</h3><blockquote><p>《Unified Reward Model for Multimodal Understanding and Generation》2025.3</p></blockquote><h4 id="动机-3">动机</h4><ol><li>过去的RM往往是单一维度</li><li>视频和图像生成是有联系的，视频RM和图像RM应该可以统一</li></ol><h4 id="创新点-2">创新点</h4><p>支持图像生成、图像理解、视频生成、视频理解的多模态RM</p><h4 id="Prompt">Prompt</h4><p>Pairwise Image Gen</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You are given a text caption and two generated images based on that caption. Your task is to evaluate and compare these images based on two key criteria:</span><br><span class="line">1. Alignment with the Caption: Assess how well each image aligns with the provided caption. Consider the accuracy of depicted objects, their relationships, and attributes as described in the caption.</span><br><span class="line">2. Overall Image Quality: Examine the visual quality of each image, including clarity, detail preservation, color accuracy, and overall aesthetic appeal. </span><br><span class="line">Compare both images using the above criteria and select the one that better aligns with the caption while exhibiting superior visual quality.</span><br><span class="line">Provide a clear conclusion such as &quot;Image 1 is better than Image 2&quot;, &quot;Image 2 is better than Image 1.&quot; and &quot;Both images are equally good.&quot; </span><br><span class="line">Your task is provided as follows:</span><br><span class="line">Text Caption: &#123;caption&#125;</span><br></pre></td></tr></table></figure><h4 id="数据-2">数据</h4><ol><li>CodeGoat24/EvalMuse：pairwise 图片谁比谁好</li><li>CodeGoat24/HPD：pairwise 图片谁比谁好</li><li>CodeGoat24/OIP：pairwise 图片谁比谁好</li><li>CodeGoat24/LLaVA-Critic-113k：</li></ol><h3 id="OneReward">OneReward</h3><blockquote><p>《OneReward: Unified Mask-Guided Image Generation via Multi-Task Human Preference Learning》2025.8</p></blockquote><h3 id="UnifiedReward-Think">UnifiedReward Think</h3><blockquote><p>《Unified Multimodal Chain-of-Thought Reward Model through Reinforcement Fine-Tuning》2025.8</p></blockquote><h4 id="训练流程">训练流程</h4><ol><li>模型使用UnifiedReward为basemodel，经过预训练，有初始的图像好坏判断能力<ol><li>视频、图像的pairwise比较</li><li>视频、图像的pointwise得到绝对分数</li></ol></li><li>使用少量（5k）CoT格式的数据训练，让模型学会输出CoT结构</li><li>拒绝采样：用CoT模型大量清洗GT数据，得到大量CoT数据</li><li>挑出和GT一致的CoT数据，进行大规模训练</li><li>GRPO：准备大量图片和问题，让模型进行GRPO</li></ol><h4 id="Prompt-2">Prompt</h4><p>Q：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Which of the following images is better? Text Caption: [&#123;caption&#125;]</span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">think</span>&gt;</span></span><br><span class="line">1. Semantic consistency:</span><br><span class="line">    - Image 1 (7/10): The man is wearing a cap and is sitting with a dog, but the dog is not black and brown as described. The setting is cozy, but the computer is not clearly visible.</span><br><span class="line">    - Image 2 (9/10): The man is wearing a brown cap and is clearly using a computer. The dog is black and brown, matching the description. The setting is consistent with the caption.</span><br><span class="line">2. Aesthetics:</span><br><span class="line">    - Image 1 (8/10): The image has a warm, inviting color palette and good composition, with a cozy atmosphere.</span><br><span class="line">    - Image 2 (9/10): The image is well-composed with good lighting and focus on the man and the dog, creating a realistic and appealing scene.</span><br><span class="line">3. Authenticity:</span><br><span class="line">    - Image 1 (6/10): The image has a more artistic, illustrative style, which reduces realism.</span><br><span class="line">    - Image 2 (9/10): The image appears realistic and detailed, with attention to the textures of the cap, dog fur, and computer.</span><br><span class="line">Total score: Image 1: 7+8+6=21</span><br><span class="line">Image 2: 9+9+9=27</span><br><span class="line"><span class="tag">&lt;/<span class="name">think</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">answer</span>&gt;</span>Image 2 is better<span class="tag">&lt;/<span class="name">answer</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="数据-3">数据</h4><ul><li>CodeGoat24/ImageGen-CoT-Reward-5K：pairwise CoT 图片谁比谁好，XML格式</li></ul><h3 id="Reward-Dance">Reward Dance</h3><blockquote><p>《RewardDance: Reward Scaling in Visual Generation》2025.9</p></blockquote><p>动机：构建一个统一的、可缩放的的RM</p><p>创新点：</p><ol><li><p>训练一个VLM，输入两张图片和prompt，输出yes/no，判断第一张图是否更好</p><ol><li>作者还验证了RM和RLFT的scaling up，在不同参数量的InternVL上做实验，参数量越大效果越好</li></ol></li><li><p>奖励分数设置为VLM预测yes的概率</p></li><li><p>相较于CLIP等模型，VLM更容易进行scale up，可以使用1B～26B的模型</p></li><li><p>可以引入CoT，除了简单的yes/no，还可以额外生成reason，以提高RM的可解释性</p></li></ol><blockquote><p>Reward Dance是先判断yes/no，再跟CoT数据，这样在实际应用时确实可以通过控制max nexttoken，提高RM的效率，但这是否会导致CoT只是对初次判断的找补、解释？</p></blockquote><h4 id="RM构建">RM构建</h4><p>CoT 数据构建</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">system_prompt = <span class="string">&#x27;&#x27;&#x27;You will act as a professional image quality evaluator.</span></span><br><span class="line"><span class="string">Your task is to be given two images, both of which are generated by the same prompt, and then evaluate which image has a better generation quality.</span></span><br><span class="line"><span class="string">The factors to be considered include</span></span><br><span class="line"><span class="string">&quot;text-image alignment&quot;:</span></span><br><span class="line"><span class="string">(1) Object consistency</span></span><br><span class="line"><span class="string">(2) Text accuracy</span></span><br><span class="line"><span class="string">(3) Style consistency</span></span><br><span class="line"><span class="string">(4) Environment relevance</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">user_prompt = <span class="string">f&quot;Please evaluate two images generated from the prompt: \&quot;<span class="subst">&#123;caption&#125;</span>\&quot;. Is image 2 better than image 1? Please answer \&quot;yes\&quot; or \&quot;no\&quot;, and given the detailed reason&quot;</span></span><br></pre></td></tr></table></figure><h4 id="RM测评">RM测评</h4><ul><li>In-Domain：从数据集中挑选2500对，这部分数据不会送进训练</li><li>Out-Of-Domain：从开源测评集中挑选4000对</li></ul><h4 id="RLFT测评">RLFT测评</h4><h3 id="EditScore">EditScore</h3><blockquote><p>《EditScore: Unlocking Online RL for Image Editing via High-Fidelity Reward Modeling》</p></blockquote><p>一个pointwise的编辑模型reward，输入编辑指令、编辑前后图像，输出CoT和编辑分数（编辑成功率、过度编辑程度）</p><h2 id="RL方法">RL方法</h2><h3 id="Diffusion-DPO">Diffusion DPO</h3><blockquote><p>《Diffusion Model Alignment Using Direct Preference Optimization》2023.11</p></blockquote><p>23年年末，基于RLHF微调LLM已经取得了巨大进步，但微调Diffusion仍为得到足够探索</p><p>Diffusion-DPO使用最简单的DPO方法，构造直接偏好对（85.1对） ，进行微调模型（这里指SDXL）</p><p>策略梯度：RL的目的是给定输入，若输出 $x$ 符合人类偏好的，则增加生成 $x$ 的概率，反之则降低概率。</p><p>相较于监督学习，模型学习输入的数据，RL会让模型进行探索（比如让模型生成一串文本、生成一张图片），然后根据Reward Model动态决定概率的升降。</p><p>而对于DPO而言，我们离线进行了探索（使用参考模型生成大量数据），人工/基于RM进行标注，让模型学习概率的升降</p><h4 id="引入DPO的困难">引入DPO的困难</h4><p>在LLM中，模型生成某段文本序列的概率就是每个单词概率的乘积。但在Diffusion中，生成一个图 $x_0$ 需要经过许多步去噪得到，从原始噪声到最终图像理论上存在无数条路径，于是我们无法计算出Diffusion生成某张特定图像的概率 $p_{\theta}(x_0 | c)$。</p><p>为了绕开这个问题，作者不去计算生成特定图像 $x_0$ 的概率，而是去计算产生这一整条去噪路径 $x_0 … x_T$ 的可能性。在扩散模型中计算 $p(x_{t-1}|x_t)$ 非常简单，我们直接将从0到T所有的 $p(x_{t-1}|x_t)$ 相乘，就得到了 $p(x_{0:T})$</p><p>利用ELBO（证据下界），将整个生成链上的奖励定义为 $R(c,x_{0:T})$ ，优化 $p(x_0)$ 的下界等价于优化每一步的去噪误差，将图像奖励定义为：<br>$$<br>r(c, x_0) = E_{p_\theta(x_{1:T}|x_0, c)} [R(c, x_{0:T})]<br>$$<br>作者还引入了KL 散度正则化项，防止模型为了得高分而走极端，导致模式崩溃</p><p>loss定义为 “新模型生成好图路径的概率比旧模型高了多少” 减去 “新模型生成好图路径的概率比旧模型高了多少”：<br>$$<br>\mathcal{L}<em>{\text{DPO-Diffusion}}(\theta) = -E</em>{(x_0^w, x_0^l) \sim \mathcal{D}} \log \sigma \left( \beta E_{\substack{x_{1:T}^w \sim p_\theta \ x_{1:T}^l \sim p_\theta}} \left[ \log \frac{p_\theta(x_{0:T}^w)}{p_{\text{ref}}(x_{0:T}^w)} - \log \frac{p_\theta(x_{0:T}^l)}{p_{\text{ref}}(x_{0:T}^l)} \right] \right)<br>$$</p><ul><li>$p_{ref}(x)$：当前模型未微调前，生成这张图的概率</li><li>$p_\theta(x)$：模型微调后，生成这张图的概率</li><li>$\sigma$：Sigmoid函数，将差异值转为0～1的概率</li><li>$-\log(p)$：模型判断对了（p接近1），损失接近0，判断错了（p接近0），损失无穷大，模型受到处罚</li></ul><p>对高斯分布取对数，会得到一个二次方程（抛物线）<br>$$<br>p(x) = \frac{1}{\sqrt{2\pi\sigma^2}} \cdot e^{-\frac{(x - \mu)^2}{2\sigma^2}}<br>$$</p><p>$$<br>\log p(x) = \underbrace{\log(\frac{1}{\sqrt{2\pi\sigma^2}})}<em>{\text{常数 C}} + \underbrace{\log(e^{-\frac{(x - \mu)^2}{2\sigma^2}})}</em>{\text{指数消失}}<br>$$</p><p>$$<br>\log p(x) = C - \frac{1}{2\sigma^2}(x - \mu)^2<br>$$</p><p>经过化简，我们发现DPO的loss本质上是两个均方误差（MSE）相减<br>$$<br>Loss = -\log \sigma \left( \beta \left[ (\text{Ref误差}^w - \text{Model误差}^w) - (\text{Ref误差}^l - \text{Model误差}^l) \right] \right)<br>$$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型预测结果，计算MSE，得到 model_losses_w - model_losses_l</span></span><br><span class="line">model_pred = unet(noisy_model_input, timesteps, encoder_hidden_states).sample</span><br><span class="line">model_losses_w, model_losses_l = F.mse_loss(model_pred.<span class="built_in">float</span>(), target.<span class="built_in">float</span>())</span><br><span class="line">model_diff = model_losses_w - model_losses_l</span><br><span class="line"><span class="comment"># 关闭 adapter</span></span><br><span class="line">accelerator.unwrap_model(unet).disable_adapters()</span><br><span class="line"><span class="comment"># 用原模型预测结果，计算MSE，得到 ref_losses_w - ref_losses_l</span></span><br><span class="line">ref_preds = unet(noisy_model_input, timesteps, encoder_hidden_states).sample.detach()</span><br><span class="line">ref_losses_w, ref_losses_l = F.mse_loss(ref_preds.<span class="built_in">float</span>(), target.<span class="built_in">float</span>())</span><br><span class="line">ref_diff = ref_losses_w - ref_losses_l</span><br><span class="line"><span class="comment"># 重新开启 adapter</span></span><br><span class="line">accelerator.unwrap_model(unet).enable_adapters()</span><br><span class="line"><span class="comment"># 根据结合律</span></span><br><span class="line"><span class="comment"># (model_losses_w - model_losses_l) - (ref_losses_w - ref_losses_l) = (model_losses_w - ref_losses_w) - (ref_losses_l - model_losses_l)</span></span><br><span class="line">logits = ref_diff - model_diff</span><br><span class="line">loss = -<span class="number">1</span> * F.logsigmoid(args.beta_dpo * logits).mean()</span><br></pre></td></tr></table></figure><h3 id="ImageReward-2">ImageReward</h3><blockquote><p>《ImageReward: Learning and Evaluating Human Preferences for Text-to-Image Generation》2023.12</p></blockquote><h4 id="ReFL">ReFL</h4><blockquote><p>0 --&gt; t --&gt; 0</p></blockquote><ol><li>按正常流程生成loss、更新LDM模型参数</li><li>随机挑选中后期的timestep（30～40）<ol><li>0到 $t$ 不反传梯度，只前向生成，从图像开始得到一个中间噪声</li><li>在第 $t$ 步，开启梯度，从 $x_t$ 开始不断反向去噪得到潜变量 $x_0$，并解码出图像 $z_i$</li></ol></li><li>将prompt和 $z_i$ 输入到reward模型中，得到reward分数</li><li>根据reward分数更新LDM模型参数</li></ol><p>$$<br>\hat{x}_0 = \frac{x_t - \sqrt{1 - \bar{\alpha}t},\hat{\epsilon}\theta(x_t, y)}{\sqrt{\bar{\alpha}_t}}<br>$$</p><h3 id="Flow-GRPO">Flow-GRPO</h3><blockquote><p>《Flow-GRPO: Training Flow Matching Models via Online RL》2025.7</p></blockquote><p><strong>动机</strong></p><ol><li>基于FlowMatching的图像生成模型（如Flux、SD3.5）占据主导地位，但仍在在复杂组合场景（如精确物体计数、空间关系和属性绑定）以及文本渲染上表现很差。</li><li>online RL 在LLM上取得了巨大成功</li><li>online RL 无法直接用于FlowMatching模型</li></ol><p><strong>创新点</strong></p><p>将FlowMatching的ODE转为等价的SDE，引入随机性，以支持RL探索</p><p><strong>测评集</strong></p><ul><li>GenEval（组合图像生成）</li><li>OCR（文字渲染）</li><li>PickScore（人类偏好对齐）</li><li>DrawBench、DeQA、ImageReward（美学）</li><li>CLIP</li></ul><h3 id="Pref-GRPO">Pref-GRPO</h3><blockquote><p>《Pref-GRPO: Pairwise Preference Reward-Based GRPO for Stable Text-to-Image Reinforcement Learning》2025.8</p></blockquote><h3 id="DiffusionNFT">DiffusionNFT</h3><blockquote><p>《DiffusionNFT: Online Diffusion Reinforcement with Forward Process》</p></blockquote><h4 id="动机-4">动机</h4><p>提出一种新的RL范式，不在反向过程，而是直接在前向扩散过程上执行策略优化，以克服GRPO的种种问题</p><h4 id="GRPO-RL的问题">GRPO RL的问题</h4><p>过去的GRPO风格的diffusion RL存在很多问题</p><h5 id="前向不一致">前向不一致</h5><blockquote><p>forward inconsistency</p></blockquote><p>扩散模型有前向扩散和反向生成两个过程，而GRPO只关注反向采样过程，使用了和前向过程不一样的噪声调度、时间分布、损失函数，训练的模型轨迹不再是原来前向扩散的逆过程</p><p>当前向不一致发生后，模型的每个反向过程更像是独立的高斯采样，而非真正的去噪声，最终退化为高斯噪声串接（cascaded Gaussians）。</p><h5 id="求解器限制">求解器限制</h5><blockquote><p>Solver restriction</p></blockquote><p>传统扩散模型的Loss中包含随机项，导致Loss和采样器是强绑定的，如果更换采样器，理论一致性就会破坏，造成数据偏移、输出失真</p><p>更高阶的求解器或者ODE求解器往往在采样效率和轨迹预测上有优势，但是由于求解器限制我们不能直接替换这些求解器</p><h5 id="CFG">CFG</h5><p>使用CFG的模型在训练和推理时需要两次前向计算（有条件和无条件），导致计算和内存开销翻倍<br>$$<br>\epsilon_\text{CFG} = \epsilon_\text{uncond} + w \cdot (\epsilon_\text{cond} - \epsilon_\text{uncond})<br>$$<br>目前的GRPO RL依赖于CFG，为了提升效率需要移除这部分</p><h4 id="负感知微调">负感知微调</h4><h5 id="优化方向">优化方向</h5><p>在Online RL中，将数据拆分为两个子集：正面和负面，其概率为<br>$$<br>\pi^+ &gt; \pi_{old} &gt; \pi^-<br>$$<br>我们希望优化方向可以同时用到正面和负面数据</p><p>如下图，假设我们后续要学的<strong>优化方向</strong>是 $v_\theta$ ，当前的速度场为 $v_{old}$ ，由训练数据 $x_0$ 得到的速度为 $v$</p><p>隐式正策略<br>$$<br>v^+= (1 - \beta)v_{\rm old} + \beta v_\theta<br>$$<br>隐式负策略：<br>$$<br>v^- = (1+\beta)v_{\rm old} - \beta v_\theta<br>$$<br>$v^+$ 和 $v^-$ 均与 $\theta$ 有关</p><blockquote><p>由于正负策略均为优化方向和当前速度的组合，所以正负策略可以在同一方向上</p></blockquote><p>![Improvement Direction](/images/Improvement Direction.png)</p><p>最终的loss为：<br>$$<br>\mathcal{L}(\theta) = \mathbb{E}_{c, x_0, t} \left[r | v^+ - v |^2 + (1 - r) | v^- - v |^2 \right]<br>$$<br>通过 $v$ 调整 $\theta$</p><h5 id="策略优化">策略优化</h5><p>$$<br>v_\theta ^* = v_{\rm old} + \frac{2}{\beta} \Delta<br>$$</p><h4 id="优势">优势</h4><ol><li>前向一致性</li><li>求解器灵活</li><li>隐式引导集成（无CFG）</li><li>无似然表述</li></ol><h2 id="参考">参考</h2><p><a href="https://datawhalechina.github.io/easy-rl/#/">easy-rl</a></p>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常微分方程</title>
      <link href="/math/ODE/"/>
      <url>/math/ODE/</url>
      
        <content type="html"><![CDATA[<h1>常微分方程</h1><h2 id="微分方程">微分方程</h2><p>观察下面两个方程<br>$$<br>x^2=1<br>$$</p><p>$$<br>\frac{\mathrm{d}y}{\mathrm{d}x}=2x<br>$$</p><p>发现下面的方程包含导数，我们称这类包含未知变量（y）对自变量（x）的导数的方程为<strong>微分方程</strong>，上面的普通方程叫代数方程</p><p>此外我们发现，这个微分方程中，最高阶的导数是这个y对x的一阶导数，于是这个微分方程的<strong>阶数</strong>为1</p><p>我们将微分方程分为：</p><ul><li>常微分方程（ODE），只涉及一个自变量的导数</li><li>偏微分方程（PDE），涉及多个自变量的偏导数</li></ul><h2 id="解析解法">解析解法</h2><h3 id="分离变量法">分离变量法</h3><p>适用于形如 $\frac{dy}{dx} = f(x)g(y)$ 的方程</p><p>例：求解 $\frac{dy}{dx} = xy$ ，初始条件 $y(0)=1$</p><p>将所有与 y 相关的项移到一边，与 x 相关的项移到另一边：<br>$$<br>\frac{dy}{y} = x , dx<br>$$<br>对两边积分<br>$$<br>\int \frac{1}{y} , dy = \int x , dx<br>$$<br>左边<br>$$<br>\int \frac{1}{y} , dy = \ln|y| + C_1<br>$$<br>右边<br>$$<br>\int x , dx = \frac{1}{2}x^2 + C_2<br>$$<br>合并常数<br>$$<br>\ln|y| = \frac{1}{2}x^2 + C<br>$$</p><p>$$<br>|y| = e^{\frac{1}{2}x^2 + C} = e^C \cdot e^{\frac{1}{2}x^2}<br>$$</p><p>令$A = \pm e^C$<br>$$<br>y = A e^{\frac{1}{2}x^2}<br>$$<br>带入初始条件<br>$$<br>y(0) = A e^{\frac{1}{2} \cdot 0^2} = A \cdot 1 = A = 1<br>$$<br>于是解为<br>$$<br>y = e^{\frac{1}{2}x^2}<br>$$</p><h3 id="变量替换法">变量替换法</h3><p>适用于齐次型方程，形如$\frac{dy}{dx}=y(\frac{y}{x})$</p><p>例：求解$\frac{dy}{dx} = \frac{x + y}{x - y}$，初始条件$y(0)=1$</p><p>经观察，右侧公式可以变形为<br>$$<br>\frac{x + y}{x - y} = \frac{1 + \frac{y}{x}}{1 - \frac{y}{x}}<br>$$<br>我们使用变量进行替换 $v = \frac{y}{x}$</p><p>对 $y=vx$ 关于 x求导<br>$$<br>\frac{dy}{dx} = v + x \frac{dv}{dx}<br>$$<br>带入原式<br>$$<br>v + x \frac{dv}{dx} = \frac{x + y}{x - y} = \frac{x + vx}{x - vx} = \frac{1 + v}{1 - v}<br>$$<br>化简得到<br>$$<br>v + x \frac{dv}{dx} = \frac{1 + v}{1 - v}<br>$$<br>得到<br>$$<br>x \frac{dv}{dx} = \frac{1 + v^2}{1 - v}<br>$$<br>得到<br>$$<br>\frac{1 - v}{1 + v^2} dv = \frac{1}{x} dx<br>$$<br>分解积分<br>$$<br>\int \frac{1}{1 + v^2} dv - \int \frac{v}{1 + v^2} dv = \frac{1}{x} dx<br>$$<br>得到<br>$$<br>\arctan v - \frac{1}{2} \ln |1 + v^2| = \ln |x| + C<br>$$<br>带入原变量<br>$$<br>\arctan \left( \frac{y}{x} \right) - \frac{1}{2} \ln \left( 1 + \left( \frac{y}{x} \right)^2 \right) = \ln |x| + C<br>$$</p><p>$$<br>\arctan \left( \frac{y}{x} \right) - \frac{1}{2} \left( \ln (x^2 + y^2) - 2 \ln |x| \right) = \ln |x| + C<br>$$</p><p>化简<br>$$<br>\arctan \left( \frac{y}{x} \right) - \frac{1}{2} \ln (x^2 + y^2) = C<br>$$<br>应用初始条件，得到<br>$$<br>\arctan \left( \frac{0}{1} \right) - \frac{1}{2} \ln (1^2 + 0^2) = \arctan 0 - \frac{1}{2} \ln 1 = 0 - 0 = 0<br>$$<br>因此 $C=0$</p><p>最终解为<br>$$<br>\arctan \left( \frac{y}{x} \right) = \frac{1}{2} \ln (x^2 + y^2)<br>$$</p><h3 id="伯努利方程">伯努利方程</h3><p>形如<br>$$<br>\frac{dy}{dx}=P(x)y + Q(x)y^n , (n \neq 0, 1)<br>$$</p><h2 id="欧拉方法">欧拉方法</h2><p>大部分情况下无法解出解析解，而是用数值解模拟出 key-value 对</p><h3 id="一阶欧拉方法">一阶欧拉方法</h3><p>欧拉方法是一种简单的数值方法，用于求解ODE的初值问题</p><p>假设时间步长为 $\Delta t$ ，则：<br>$$<br>x_{t+\Delta t}=x_t + v(x_t, t)\Delta t<br>$$<br>其物理意义是，每一小段时间都朝着当前方向匀速走一小段时间。</p><p>误差量级为 $O(\Delta t^2)$ ，步长要非常小才能控制误差，但是胜在使用便捷，只需要计算一次速度</p><h4 id="例子">例子</h4><p>例：用欧拉方法求下列式子在$[0, 1]$的解，步长为0.2<br>$$<br>\frac{dy}{dx} = -2x y, \quad y(0) = 1<br>$$<br>根据导数的定义<br>$$<br>\frac{dy}{dx} \approx \frac{y(x + h) - y(x)}{h}<br>$$<br>对于方程 $\frac{dy}{dx} = f(x, y)$，欧拉方法的迭代公式为：<br>$$<br>y_{n+1} = y_n + h \cdot f(x_n, y_n)<br>$$<br>步0：根据初始条件 $x_0 = 0, y_0 = 1$，<br>$$<br>f(x_0, y_0) = -2 \cdot 0 \cdot 1 = 0<br>$$</p><p>$$<br>y_1 = y_0 + h \cdot f(x_0, y_0) = 1 + 0.2 \cdot 0 = 1<br>$$</p><p>步1：$x_1 = 0.2, y_1 = 1$<br>$$<br>f(x_1, y_1) = -2 \cdot 0.2 \cdot 1 = -0.4<br>$$</p><p>$$<br>y_2 = y_1 + h \cdot f(x_1, y_1) = 1 + 0.2 \cdot (-0.4) = 1 - 0.08 = 0.92<br>$$</p><p>以此类推，得到最终的数值解。当然下面表哥的误差很大，但当步长非常小时，误差就会很小</p><table><thead><tr><th>步数</th><th>x</th><th>y</th></tr></thead><tbody><tr><td>0</td><td>0.0</td><td>1.0</td></tr><tr><td>1</td><td>0.2</td><td>1.0</td></tr><tr><td>2</td><td>0.4</td><td>0.92</td></tr><tr><td>3</td><td>0.6</td><td>0.7728</td></tr><tr><td>4</td><td>0.8</td><td>0.587328</td></tr><tr><td>5</td><td>1.0</td><td>0.39938304</td></tr></tbody></table><h3 id="二阶欧拉方法">二阶欧拉方法</h3><blockquote><p>Heun’s method（改进欧拉方法），核心思想是不仅看当前速度，还要预测未来速度的变化趋势</p></blockquote><ol><li>先用欧拉法预测一个临时点</li></ol><p>$$<br>\tilde{x}_{t+\Delta t} = x_t + v(x_t, t) \Delta t<br>$$</p><ol start="2"><li>再估计未来的速度</li></ol><p>$$<br>v_2 = v(\tilde{x}_{t+\Delta t}, t+\Delta t)<br>$$</p><ol start="3"><li>最终结果取平均</li></ol><p>$$<br>x_{t+\Delta t} = x_t + \frac{1}{2}(v(x_t, t) + v_2) \Delta t<br>$$</p><p>局部误差降低到 $O(\Delta t^3)$，全局误差  $O(\Delta t^2)$</p><blockquote><p>注意，$\Delta t$ 通常是小于1的数，所以 $\Delta t^3 &lt; \Delta t^2$</p></blockquote><h3 id="四阶">四阶</h3><blockquote><p>Runge-Kutta 4 ，更高阶的欧拉方法是沿着曲线移动的，用计算次数来换误差，由于大步幅误差也很低，所以可以减少采样次数</p></blockquote><p>$$<br>\begin{aligned}<br>k_1 &amp;= v(x_t, t) \<br>k_2 &amp;= v(x_t + \frac{\Delta t}{2} k_1, t + \frac{\Delta t}{2}) \<br>k_3 &amp;= v(x_t + \frac{\Delta t}{2} k_2, t + \frac{\Delta t}{2}) \<br>k_4 &amp;= v(x_t + \Delta t k_3, t + \Delta t)<br>\end{aligned}<br>$$</p><p>$$<br>x_{t+\Delta t} = x_t + \frac{\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)<br>$$</p><p>误差降低至 $O(\Delta t^5)$</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI 文章阅读</title>
      <link href="/ai/AI%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB/"/>
      <url>/ai/AI%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1>AI 文章阅读</h1><blockquote><p>follow <a href="https://www.zhihu.com/people/zhou-shu-chang-45/posts">周舒畅</a>的知乎文章，包含AI辅助创作</p></blockquote><p>论文阅读方法：</p><ol><li>分析论文的motivation</li><li>列举论文的核心创新点，并找出支撑这些创新点的关键技术</li><li>论文有哪些显著结果</li><li>详细说明流程步骤</li></ol><h2 id="自由能理论">自由能理论</h2><blockquote><p>Free Energy Principle, FEP</p></blockquote><p>任何自组织系统为了维持其存在，都必须通过行动和感知来最小化其<strong>变分自由能</strong>，从而间接最小化与环境之间的“惊奇”（Surprise）</p><p>变分自由能=复杂度-准确度</p><p>最小化自由能的过程，就是在<strong>保持自身简洁</strong>的和<strong>精确解释数据</strong>间寻找最佳平衡</p><h2 id="Adam优化器">Adam优化器</h2><blockquote><p>Adaptive Moment Estimation，自适应矩估计</p></blockquote><p>Adam的核心思想是动量法和自适应学习率，通过计算梯度的均值和方差，自适应调整学习率</p><h3 id="自然梯度">自然梯度</h3><p>梯度下降是指在参数空间中寻找梯度下降最快的方向。但对于神经网络，参数的微小变化可能会导致模型输出分布的巨大变化，参数空间的距离不等同于<strong>模型表达的概率分布空间</strong>中的距离</p><p>自然梯度的核心思想，就是在模型表达的概率分布空间中做最速下降。我们使用<strong>KL散度</strong>来描述概率分布空间间的距离</p><p>由参数$\theta$定义的概率分布 $p(x|\theta)$，找到一个参数更新方向 $d$，使得在新参数 $\theta+d$ 下，新概率分布和原概率分布的KL散度最小化</p><p>经过推导，自然梯度的方向与费雪信息矩阵（Fisher Information Matrix, FIM）有关</p><h4 id="KL散度">KL散度</h4><p>KL散度是用于衡量两个概率分布之间差异的度量，含义为用一个概率分布$Q$来近似另一个概率分布$P$时的信息损失，实现了量化两个分布之间的差异</p><p>对于离散概率部分<br>$$<br>D_{\text{KL}}(P || Q) = \sum_{x} P(x) \log \left( \frac{P(x)}{Q(x)} \right)<br>$$<br>对于连续概率分布<br>$$<br>D_{\text{KL}}(P || Q) = \int P(x) \log \left( \frac{P(x)}{Q(x)} \right) dx<br>$$<br>KL散度是非对称的，$D_{\text{KL}}(P || Q) \neq D_{\text{KL}}(Q || P)$</p><p>KL散度是非负的</p><p>从信息论的角度，KL散度是指用$Q$的编码方式来编码$P$时，需要的额外编码长度</p><p>KL散度不满足三角不等式，不是一个严格的距离</p><h4 id="度量">度量</h4><p>度量：距离</p><p>度量空间：描述集合内元素间距离的结构</p><p>性质：</p><ul><li>对称性（点A到点B到距离和点B到点A刀距离相同）</li><li>三角不等式（两边之和大于第三边）</li><li>同一性（当且仅当两点重合，两点间距离为0）</li><li>非负性（两点间距离不能为负数）</li></ul><h3 id="对角近似">对角近似</h3><p>如果一个模型参数为N，那么完整的FIM是一个NxN矩阵，对其求逆的复杂度为$O(N^3)$，对于参数量巨大的神经网络，这是不可接受的</p><p>Adam使用的是一个对角化的FIM矩阵，最终的计算复杂度是$O(N)$</p><h2 id="稀疏自编码器-SAE">稀疏自编码器 SAE</h2><p>和人脑一样，对于任何特定输入，神经网络中只有一小部分神经元会活跃，这种“稀疏激活”的特性，是生物智能高效和鲁棒的关键</p><p>一个普通的自编码器，会学到整体的压缩方式。而一个稀疏自编码器，会被迫去发现一些更基础、更独立的视觉“字母表”，倾向于用少量专业神经元来解释输入，是一种更加高效的编码方式</p><p>SAE的Loss由重建损失和稀疏性惩罚构成</p><p>重建损失往往使用MSE</p><p>稀疏性惩罚的实现方法有：</p><ul><li>L1正则化</li><li>KL散度</li></ul><h3 id="MSE">MSE</h3><p>均方误差，一种常见Loss函数，用于衡量预测值和真实值之间的差异<br>$$<br>\text{MSE} = \frac{1}{n} \sum_{i=1}^n (y_i - \hat{y}_i)^2<br>$$</p><h3 id="L1正则化">L1正则化</h3><p>通过限制模型参数（权重）的绝对值之和，促使部分参数趋向于零，从而实现模型的稀疏性（sparse model），即减少不重要的特征对模型的贡献</p><p>想要参数的绝对值之和尽可能小，那么参数就会尽可能为0<br>$$<br>\text{Loss} = L(\theta) + \lambda \sum_{i} |\theta_i|<br>$$</p><ul><li><p>$\theta $：模型参数（权重）。</p></li><li><p>$\sum_{i} |\theta_i|$：所有参数绝对值的和，称为L1范数。</p></li><li><p>$\lambda$：正则化强度的超参数，控制正则化的影响程度。较大的$\lambda$会更强烈地惩罚大的权重值。</p></li></ul><h3 id="KL散度-2">KL散度</h3><p>SAE使用KL散度，目的是增加隐藏层激活的稀疏性，不要求每次输入的激活都稀疏，而是要求在整个训练数据集上，每个隐藏神经元的<strong>平均激活度</strong>维持在一个很低的水平</p><blockquote><p>VAE也是用了KL散度，但是作用是衡量潜在变量的分布和先验分布（标准正态分布）间的差异，使得潜在空间分布更加规则、连续，更接近标准正态分布</p></blockquote><h3 id="专家混合模型">专家混合模型</h3><blockquote><p>Mixture of Experts, MoE</p></blockquote><p>MoE模型中有很多并行的专家（前馈神经网络）和一个路由器（gating network），对于每个输入，路由器会决定这个输入使用哪些专家来处理</p><p>MoE的思想和SAE有很多相似之处，都是条件计算和稀疏激活，一个是网络级别的稀疏激活，一个是神经元级别的稀疏激活</p><h4 id="Top-K-稀疏">Top-K 稀疏</h4><p>在每次前向传播中，我们只保留激活度最高的K个神经元，其他的强制设为0</p><h2 id="PPO-和-GAE">PPO 和 GAE</h2><p>PPO：近端策略优化</p><p>GAE：广义优势估计</p><h3 id="策略梯度">策略梯度</h3>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用数据集</title>
      <link href="/ai/dataset/"/>
      <url>/ai/dataset/</url>
      
        <content type="html"><![CDATA[<h1>常用数据集</h1><h2 id="3D重建">3D重建</h2><h3 id="Mip-NeRF-360">Mip-NeRF 360</h3><blockquote><p><a href="https://jonbarron.info/mipnerf360/">https://jonbarron.info/mipnerf360/</a></p></blockquote><p>几个，室内室外环绕拍摄，RGB图片</p><h3 id="DL3DV-10K">DL3DV-10K</h3><blockquote><p><a href="https://huggingface.co/datasets/DL3DV/DL3DV-ALL-4K">https://huggingface.co/datasets/DL3DV/DL3DV-ALL-4K</a></p></blockquote><p>10k，室内室外手机移动拍摄，RGB图片+Pose</p><h3 id="CO3D">CO3D</h3><blockquote><p><a href="https://ai.meta.com/datasets/co3d-downloads/">https://ai.meta.com/datasets/co3d-downloads/</a></p></blockquote><p>19k，常见真实物体的视频，RGBD图片+ply点云</p><h3 id="ARKitScenes">ARKitScenes</h3><blockquote><p><a href="https://github.com/apple/ARKitScenes">https://github.com/apple/ARKitScenes</a></p></blockquote><p>5k，室内视频iphone激光雷达视频，RGBD图片+相机位置</p><h3 id="SceneFun3D">SceneFun3D</h3><blockquote><p><a href="https://scenefun3d.github.io">https://scenefun3d.github.io</a></p></blockquote><p>710，室内场景，RGBD图片+ply点云+相机位置</p><h3 id="ScanNet">ScanNet</h3><blockquote><p><a href="https://github.com/ScanNet/ScanNet">https://github.com/ScanNet/ScanNet</a></p></blockquote><p>1500，室内场景，RGBD+ply点云</p><h2 id="Mesh">Mesh</h2><h3 id="3D-Front">3D-Front</h3><blockquote><p><a href="https://tianchi.aliyun.com/specials/promotion/alibaba-3d-scene-dataset">https://tianchi.aliyun.com/specials/promotion/alibaba-3d-scene-dataset</a></p></blockquote><p>19k，室内家具和排布，Mesh+Layout</p><h3 id="objaverse-XL">objaverse-XL</h3><blockquote><p><a href="https://github.com/allenai/objaverse-xl">https://github.com/allenai/objaverse-xl</a></p></blockquote><p>10m，各类物体的glb mesh</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.0的API示例</span></span><br><span class="line"><span class="keyword">import</span> objaverse</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">processes = multiprocessing.cpu_count()</span><br><span class="line"></span><br><span class="line">uids = [<span class="string">&quot;da1728266f3149af9d5ac54316d28c8e&quot;</span>, <span class="string">&quot;5907c0fd28aa49daa2887ed2f3c02abb&quot;</span>]</span><br><span class="line">objaverse.load_objects(uids, processes)<span class="comment"># 会下载到默认的.objaverse文件夹中</span></span><br></pre></td></tr></table></figure><h2 id="图像编辑">图像编辑</h2><h3 id="UCSC-VLAA-GPT-Image-Edit-1-5M">UCSC-VLAA/GPT-Image-Edit-1.5M</h3><p><a href="https://huggingface.co/datasets/UCSC-VLAA/GPT-Image-Edit-1.5M">https://huggingface.co/datasets/UCSC-VLAA/GPT-Image-Edit-1.5M</a></p><p>基于GPT4o洗出的1.5M数据</p><h2 id="图像">图像</h2><h3 id="nyanko7-danbooru2023">nyanko7/danbooru2023</h3><p>一个动漫图像数据集</p><h3 id="COYO-700M">COYO-700M</h3><p>一个有747m的文本图像对</p><h2 id="打标工具">打标工具</h2><h3 id="SmilingWolf-wd-swinv2-tagger-v3">SmilingWolf/wd-swinv2-tagger-v3</h3><p>一个基于Danbooru 数据集训练的数据打标工具，可以给动漫图像打标签</p>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用AI工具</title>
      <link href="/ai/AITools/"/>
      <url>/ai/AITools/</url>
      
        <content type="html"><![CDATA[<h1>实用AI工具</h1><h2 id="图片">图片</h2><h3 id="图片去背景">图片去背景</h3><p>使用RMBG为图片去背景</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForImageSegmentation</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">model = AutoModelForImageSegmentation.from_pretrained(<span class="string">&#x27;briaai/RMBG-2.0&#x27;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">torch.set_float32_matmul_precision([<span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;highest&#x27;</span>][<span class="number">0</span>])</span><br><span class="line">model.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Data settings</span></span><br><span class="line">image_size = (<span class="number">1024</span>, <span class="number">1024</span>)</span><br><span class="line">transform_image = transforms.Compose([</span><br><span class="line">    transforms.Resize(image_size),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line">root_dir = <span class="string">r&#x27;C:\Users\admin\Downloads\raw&#x27;</span></span><br><span class="line"><span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        file_path = os.path.join(dirpath, filename)</span><br><span class="line">        data.append(file_path)</span><br><span class="line"><span class="keyword">for</span> file_path <span class="keyword">in</span> tqdm(data):</span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&#x27;RGB&#x27;</span>)  </span><br><span class="line">    input_images = transform_image(image).unsqueeze(<span class="number">0</span>).to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prediction</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        preds = model(input_images)[-<span class="number">1</span>].sigmoid().cpu()</span><br><span class="line">    pred = preds[<span class="number">0</span>].squeeze()</span><br><span class="line">    pred_pil = transforms.ToPILImage()(pred)</span><br><span class="line">    mask = pred_pil.resize(image.size)</span><br><span class="line">    image.putalpha(mask)</span><br><span class="line"></span><br><span class="line">    save_name, save_extension = os.path.splitext(file_path)</span><br><span class="line">    save_path = <span class="string">f&#x27;<span class="subst">&#123;save_name&#125;</span>.png&#x27;</span></span><br><span class="line">    save_path = save_path.replace(<span class="string">&#x27;raw&#x27;</span>, <span class="string">&#x27;output&#x27;</span>)</span><br><span class="line">    save_folder = os.path.dirname(save_path)</span><br><span class="line">    os.makedirs(save_folder, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    image.save(save_path)</span><br></pre></td></tr></table></figure><h3 id="图片查重">图片查重</h3><p>使用CLIP对图片encoder，对提取的向量求余弦距离，越近说明越像</p><h2 id="音频">音频</h2><h3 id="提取节奏点">提取节奏点</h3><p>使用madmom库提取音频节奏点</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> madmom.features.beats <span class="keyword">import</span> RNNBeatProcessor, CRFBeatDetectionProcessor</span><br><span class="line"><span class="keyword">from</span> madmom.features.downbeats <span class="keyword">import</span> RNNBarProcessor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_beats</span>(<span class="params">input_audio, threshold_value=<span class="number">0.37</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Process <span class="subst">&#123;input_audio&#125;</span>&#x27;</span>)</span><br><span class="line">    proc = CRFBeatDetectionProcessor(fps=<span class="number">100</span>)</span><br><span class="line">    act = RNNBeatProcessor()(input_audio)</span><br><span class="line">    data = proc(act)<span class="comment"># 非常密的节奏点</span></span><br><span class="line"></span><br><span class="line">    proc2 = RNNBarProcessor()</span><br><span class="line">    downbeat_prob = proc2((input_audio, data))</span><br><span class="line">    ans = np.around(downbeat_prob, decimals=<span class="number">3</span>)</span><br><span class="line">    filtered = arr[arr[:, <span class="number">1</span>] &gt; threshold_value]</span><br><span class="line">    first_column = filtered[:, <span class="number">0</span>]<span class="comment"># 根据强度筛选的重音</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> json.dumps(ans.tolist()), json.dumps(data.tolist())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微软为什么使用GO重写TypeScript</title>
      <link href="/program/AndersTalk/"/>
      <url>/program/AndersTalk/</url>
      
        <content type="html"><![CDATA[<h1>《微软为何选择用Go而非Rust重写TypeScript》阅读笔记</h1><p>突然看到一篇神文，<a href="https://zhuanlan.zhihu.com/p/30110856072">微软为何选择用Go而非Rust重写TypeScript</a>，TS首席架构师分享了使用GO重写TS编译器的心路历程，其中包含了大量编译器知识，学习记录一下</p><h3 id="编译器的组成">编译器的组成</h3><p>一个编译器可能包含</p><ul><li>Front-end<ul><li>词法分析器</li><li>语法分析器</li><li>语义分析器</li><li>中间代码生成</li></ul></li><li>Optimizer</li><li>Back-end<ul><li>代码生成器</li></ul></li><li>辅助部分<ul><li>符号表管理</li><li>错误检查</li></ul></li><li>其他部分<ul><li>预处理</li><li>汇编器</li><li>链接器</li><li>加载器</li></ul></li></ul><h3 id="自举语言">自举语言</h3><blockquote><p>Self-Hosted Language</p></blockquote><p>实现自己的编译器或解释器的语言</p><h3 id="Rust借用检查器">Rust借用检查器</h3><blockquote><p>Borrow Checker</p></blockquote><p>借用检查器是Rust内存安全的核心</p><p>Rust的每个值都有唯一一个所有者，当所有者离开作用域，其所占用的内存就会被自动释放（智能指针？）</p><p>Rust可以在不获取所有权的情况下访问数据，这个过程称为<strong>借用</strong></p><ul><li>不可变借用：只读</li><li>可变借用：读写</li></ul><p>借用检查器的规则：</p><ol><li>一个资源，要么是可变的独占借用，要么是多个共享的不可变借用<ul><li>如果一个数据变为可变借用，那么借用期间，其他代码无法访问该数据（锁？）</li></ul></li><li>引用必须是有效的<ul><li>引用不能指向已经被释放的内存</li></ul></li></ol><h3 id="函数式编程">函数式编程</h3><h4 id="模式匹配">模式匹配</h4><blockquote><p>pattern matching</p></blockquote><p>根据数据的结构和内容，按照预先定义的规则进行处理</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C# 使用 switch 表达式进行模式匹配，根据shape的类型，输出不同的字符串</span></span><br><span class="line"><span class="built_in">string</span> description = shape <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    Circle c =&gt; <span class="string">$&quot;A circle with radius <span class="subst">&#123;c.Radius&#125;</span>&quot;</span>,</span><br><span class="line">    Rectangle r =&gt; <span class="string">$&quot;A rectangle with width <span class="subst">&#123;r.Width&#125;</span> and height <span class="subst">&#123;r.Height&#125;</span>&quot;</span>,</span><br><span class="line">    <span class="literal">null</span> =&gt; <span class="string">&quot;A null shape&quot;</span>,</span><br><span class="line">    _ =&gt; <span class="string">&quot;An unknown shape&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">Console.WriteLine(description);</span><br></pre></td></tr></table></figure><h4 id="高阶类型">高阶类型</h4><blockquote><p>higher-kinded types</p></blockquote><p>将类型的构造器作为参数</p><h4 id="单子">单子</h4><blockquote><p>monads</p></blockquote><p>要求实现该类型的类型都必须支持return和bind操作</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure><h3 id="不透明类型">不透明类型</h3><p>在类定义中隐藏了底层实现细节，只暴露必要接口的类型</p><p>比如我不想用户直接访问一个类型的value属性，而是将其包装为不透明类型，这个类型只能用提供好的借口</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">OpaqueType</span> &#123;</span><br><span class="line">  <span class="comment">// 定义必要的接口</span></span><br><span class="line">  <span class="title function_">getValue</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createOpaqueType</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="title class_">OpaqueType</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="title class_">OpaqueType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opaque = <span class="title function_">createOpaqueType</span>(<span class="string">&quot;secret&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(opaque.<span class="title function_">getValue</span>()); <span class="comment">// 输出 &quot;secret&quot;</span></span><br><span class="line"><span class="comment">// console.log(opaque.value); // 错误：类型 &quot;OpaqueType&quot; 上不存在属性 &quot;value&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>痛苦装库记录</title>
      <link href="/program/InstallPackage/"/>
      <url>/program/InstallPackage/</url>
      
        <content type="html"><![CDATA[<h1>痛苦装库记录</h1><p>感觉下别人的开源代码，并尝试跑通，真的非常痛苦，尤其是一些库死活安装不成功，感觉在浪费生命，于此记录一下</p><h3 id="torchsparse">torchsparse</h3><blockquote><p>这是一个一个用于处理稀疏张量的PyTorch扩展库，通常用于3D点云处理和相关任务，<a href="https://github.com/mit-han-lab/torchsparse">torchsparse</a></p></blockquote><p>我一直安装不成功，因为缺少了文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/torchsparse/torchsparse/backend/hashmap/hashmap_cpu.hpp:7:10: fatal error:</span><br><span class="line"> google/dense_hash_map: No such file or directory                               </span><br><span class="line">    7 | <span class="comment">#include &lt;google/dense_hash_map&gt;</span></span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install google-sparsehash -c bioconda</span><br><span class="line"><span class="built_in">export</span> PATH=/home/sunzheng/miniconda3/envs/&#123;name&#125;/include:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install bioconda::google-sparsehash</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mit-han-lab/torchsparse.git</span><br><span class="line"><span class="built_in">cd</span> torchsparse</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><h3 id="flash-attn">flash_attn</h3><p><a href="https://github.com/Dao-AILab/flash-attention">flash-attention</a></p><p>去github release中找对应的whl文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Dao-AILab/flash-attention/releases/download/v2.7.3/flash_attn-2.7.3+cu11torch2.1cxx11abiFALSE-cp310-cp310-linux_x86_64.whl</span><br><span class="line">pip install flash_attn-2.7.3+cu11torch2.1cxx11abiFALSE-cp310-cp310-linux_x86_64.whl</span><br></pre></td></tr></table></figure><ul><li><code>cu11</code>：表示cuda11.x版本（<code>cu12</code>表示cuda12.x版本）</li><li><code>torch2.1</code></li><li><code>cxx11</code></li><li><code>abiFALSE</code></li><li><code>cp310</code>：cpython版本，与python版本一致</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install flash-attn --no-build-isolation</span><br></pre></td></tr></table></figure><p><a href="https://developer.nvidia.com/cuda-gpus">CUDA GPU Compute Capability</a></p><h3 id="pytorch3d">pytorch3d</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n pytorch3d python=3.11</span><br><span class="line">conda activate pytorch3d</span><br><span class="line">conda install nvidia/label/cuda-12.4.0::cuda-toolkit</span><br><span class="line">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu124</span><br><span class="line">pip install &quot;git+https://github.com/facebookresearch/pytorch3d.git&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install &quot;git+https://github.com/facebookresearch/pytorch3d.git@stable&quot;</span><br></pre></td></tr></table></figure><h3 id="O-CNN">O-CNN</h3><p><a href="https://github.com/microsoft/O-CNN/blob/master/docs/installation.md">O-CNN</a></p><p>这个库一大问题是使用了cuda10.2，这个版本的cuda只支持GCC7，需要先对gcc进行降级</p><h3 id="pymeshlab">pymeshlab</h3><p>如果python版本&lt;=3.10，需要安装2022版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pymeshlab==2022.2.post3</span><br></pre></td></tr></table></figure><h3 id="vllm">vllm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install vllm --no-deps</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -U <span class="string">&quot;git+https://github.com/vllm-project/vllm.git&quot;</span></span><br></pre></td></tr></table></figure><h3 id="MinkowskiEngine">MinkowskiEngine</h3><p><a href="https://github.com/NVIDIA/MinkowskiEngine">MinkowskiEngine</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libopenblas-dev</span><br><span class="line">git <span class="built_in">clone</span> --recursive <span class="string">&quot;https://github.com/NVIDIA/MinkowskiEngine&quot;</span></span><br><span class="line"><span class="built_in">cd</span> MinkowskiEngine</span><br><span class="line">python setup.py install --force_cuda --blas=openblas</span><br></pre></td></tr></table></figure><h3 id="tiny-cuda-nn">tiny-cuda-nn</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/NVlabs/tiny-cuda-nn.git</span><br><span class="line"><span class="built_in">cd</span> tiny-cuda-nn/bindings/torch</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><h3 id="dgl">dgl</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c dglteam/label/cu118 dgl</span><br></pre></td></tr></table></figure><h3 id="triton">triton</h3><p>我之前triton一直报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/sunzheng/.triton/cache/q4oIpkjOtdHHfi8xBkm4jC4JWIk5AjKtN8WRkZb8MD8/cuda_utils.so: undefined symbol: cuModuleGetFunction</span><br></pre></td></tr></table></figure><p>后来执行了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldconfig</span><br></pre></td></tr></table></figure><p>刷新了缓存，才解决</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI 常用术语</title>
      <link href="/ai/AI%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD/"/>
      <url>/ai/AI%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1>AI 常用术语</h1><p>记录一些AI常用术语</p><h2 id="机器学习">机器学习</h2><p>AGI（通用人工智能）：能像人一样在多数认知任务上通用地学习、推理、适应与创造</p><p>ASI（超级人工智能）：在几乎所有领域都远超人类智能的系统</p><h3 id="监督学习">监督学习</h3><blockquote><p>Supervised Learning</p></blockquote><p>目标：从标记好的数据中学习输入到输出的映射，以泛化到新数据。</p><ul><li>回归（Regression）：预测连续型变量的值，如股票价格预测。</li><li>分类（Classification）：预测离散型变量的类别，如图像分类。</li><li>偏好学习（Preference Learning）：预测偏好顺序或选择，如电影排名。</li></ul><h3 id="无监督学习">无监督学习</h3><blockquote><p>Unsupervised Learning</p></blockquote><p>目标：从无标签的数据中提取特征，发现数据的内在结构。</p><ul><li>聚类（Clustering）：将数据划分为不同的组别，使得组内的相似性最大化，如客户细分。</li><li>降维（Dimensionality Reduction）：减少数据的维度，同时保留重要信息，如主成分分析（PCA）。</li><li>异常检测：识别数据中的异常点或异常模式。</li><li>自监督（Self-Supervised Learning）：表示学习，利用数据本身的内在结构或关系来生成标签，进行学习</li></ul><h3 id="强化学习">强化学习</h3><blockquote><p>Reinforcement Learning，RL</p></blockquote><p>目标：通过与环境的交互，学习最优策略以最大化累积奖励。</p><p>核心概念：</p><ul><li>智能体（Agent）：执行动作的实体，如自动驾驶汽车。</li><li>环境（Environment）：智能体所处的外部世界。</li><li>状态（State）：智能体当前的状况，如位置、速度。</li><li>动作（Action）：智能体可以执行的操作，如加速、刹车。</li><li>策略（Policy）：根据状态决定动作的规则。</li><li>奖励（Reward）：对智能体行为的反馈，用于指导学习。</li></ul><h4 id="马尔可夫决策过程">马尔可夫决策过程</h4><p>过程（Process）：一个随着时间变化的随机变量序列。如每天的股票价格、每天的天气情况</p><p>马尔可夫性：未来仅依赖于当前，而不依赖过去<br>$$<br>P(s_{t+1},|,s_t, s_{t-1}, \dots, s_0) = P(s_{t+1},|,s_t)<br>$$</p><p>马尔可夫链（Markov Chain）：一种满足马尔可夫性的随机过程</p><p>马尔可夫过程（Markov Process）：马尔可夫链的形式化定义<br>$$<br>\langle S, P \rangle<br>$$</p><ul><li><p>$S$：状态空间</p></li><li><p>$P$：状态转移概率矩阵</p></li></ul><p>马尔可夫奖励过程（Markov Reward Process, MRP）：在MP上加入奖励信号<br>$$<br>\langle S, P, R, \gamma \rangle<br>$$</p><ul><li>$R(s)$：在状态 $s$ 下得到的期望奖励</li><li>$\gamma \in [0,1]$：折扣因子，控制未来奖励的重要性</li></ul><p>马尔可夫决策过程 (Markov Decision Process, MDP)，在MRP中引入动作，智能体可以通过策略来影响环境演化<br>$$<br>\langle S, A, P, R, \gamma \rangle<br>$$</p><ul><li>$A$：动作空间</li></ul><h3 id="生成模型">生成模型</h3><p>目标：生成与真实数据相似的新数据样本。</p><ul><li><p>无条件生成（Unconditional Generation）：如无条件生成蝴蝶图片。</p></li><li><p>条件生成（Conditional Generation）：如文本到图像生成（T2I）。</p></li></ul><p>常见模型：</p><ul><li><p>GAN（Generative Adversarial Network）：通过生成器和判别器的对抗训练生成数据。</p></li><li><p>VAE（Variational Autoencoder）：在自编码器（AE）基础上对潜在空间分布建模，使得潜在空间中充满了有效数据，通过在潜在空间采样，即可生成数据。</p><ul><li>Conditional VAE：引入标注信息，实现条件生成。</li></ul></li><li><p>VQVAE（Vector Quantized VAE）：将潜在空间离散化，解决后验崩塌问题。</p></li><li><p>自回归模型（Autoregressive Model，AR）：利用时间序列的过去值预测未来值（next token），逐步生成数据。</p><ul><li>视觉自回归模型（Visual AutoRegressive modeling，VAR），在AR模型上引入了multi-scale, coarse-to-fine生成图像，每一步模型用低分辨率作为条件，预测更高分辨率的输出</li></ul></li><li><p>扩散模型（Diffusion Models）：通过前向加噪和反向去噪的过程生成数据。</p><ul><li>LDM（Latent Diffusion Model）：在潜在空间进行扩散，降低计算成本。</li><li>DiT（Diffusion Transformer）：使用Transformer替代UNet，进行噪声的预测。</li></ul></li></ul><blockquote><p>VAE、VQVAE现在往往并不会用来做数据生成，而是作为LDM、VLM的编解码器</p></blockquote><h3 id="其他任务">其他任务</h3><ul><li>时序预测</li><li>推荐系统</li></ul><h3 id="术语解释">术语解释</h3><h4 id="SOTA（State-of-the-Art）">SOTA（State of the Art）</h4><p>表示在某个特定领域中的最好成果、最佳实践。</p><h4 id="良定义（Well-Defined）">良定义（Well-Defined）</h4><p>要求：</p><ul><li>明确性：明确指出所定义对象的范围和特征。</li><li>一致性：定义不能自相矛盾。</li><li>完备性：定义要包含足够的信息，使得人们可以通过定义判断一个对象是否属于定义的范围。</li><li>无歧义性：定义要避免使用含糊不清、多义词。</li></ul><h3 id="量化指标">量化指标</h3><h4 id="召回率">召回率</h4><blockquote><p>Recall</p></blockquote><p>衡量模型对正例的识别能力（样本中的正例有多少被预测正确了）<br>$$<br>\text{Recall} = \frac{\text{TP}}{\text{TP} + \text{FN}}<br>$$</p><ul><li>TP（True Positive）：预测为正例且实际为正例的数量。</li><li>FN（False Negative）：预测为负例但实际为正例的数量</li></ul><h4 id="精确率">精确率</h4><blockquote><p>Precision</p></blockquote><p>衡量模型预测为正的样本中真正的正样本比例（预测为正的样本中有多少是真正的正样本）<br>$$<br>\text{Precision} = \frac{\text{TP}}{\text{TP} + \text{FP}}<br>$$</p><ul><li>FP（False Positive）：预测为正例但实际为负例的数量。</li></ul><h4 id="FID">FID</h4><blockquote><p>Fréchet Inception Distance</p></blockquote><p>评估生成式模型生成样本的质量，通过计算生成样本与真实样本在特征空间中的分布差异</p><h4 id="PSNR">PSNR</h4><blockquote><p>Peak Signal-to-Noise Ratio</p></blockquote><p>峰值信噪比，衡量图像或信号的重建质量，良好的8bit图像psnr一般在20～30，越大越好</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mse = np.mean((image1 - image2) ** <span class="number">2</span>)</span><br><span class="line">max_pixel = np.<span class="built_in">max</span>(image1)</span><br><span class="line">psnr = <span class="number">10</span> * np.log10((max_pixel ** <span class="number">2</span>) / mse)</span><br></pre></td></tr></table></figure><p>PSNR低，说明模型生成的细节丢失多，还原差</p><h4 id="SSIM">SSIM</h4><p>结构相似性指标，用于衡量图像的结构和纹理相似性，越大越好</p><h4 id="Perceptual-Similarity">Perceptual Similarity</h4><p>感知相似度，用于衡量两张图像在人类视觉感知上有多么相似</p><h3 id="实验方法">实验方法</h3><h4 id="消融实验">消融实验</h4><blockquote><p>Ablation Study</p></blockquote><p>确定一个条件或参数对结果的影响程度，通过去除或修改模型的某种组成，观察其对模型性能的影响</p><h4 id="交叉验证">交叉验证</h4><blockquote><p>Cross-Validation</p></blockquote><p>评估模型的泛化能力，通过将数据集划分为多个子集，轮流使用其中一个子集作为测试集，其余作为训练集</p><h4 id="超参数调优">超参数调优</h4><blockquote><p>Hyperparameter Tuning</p></blockquote><p>优化模型的超参数，以获得最佳性能</p><h4 id="from-scratch">from scratch</h4><p>从零开始，表示不使用预训练模型，而是从零开始训练</p><h2 id="神经网络">神经网络</h2><blockquote><p>参考 <a href="https://www.asimovinstitute.org/neural-network-zoo/">https://www.asimovinstitute.org/neural-network-zoo/</a></p></blockquote><h3 id="BNDE">BNDE</h3><p>B：Batch，批次大小</p><p>N：序列长度</p><p>D：Dim，特征纬度</p><p>E：Embed，嵌入纬度</p><h3 id="BCTHW">BCTHW</h3><ul><li><strong>B</strong> 表示批量维度（batch）</li><li><strong>C</strong> 表示通道维度（channel）</li><li><strong>T</strong> 表示时序维度（time）</li><li><strong>H</strong> 表示高度维度（height）</li><li><strong>W</strong> 表示宽度维度（width）</li></ul><h3 id="前向传播">前向传播</h3><p>做预测/推理的过程，输入数据到神经网络，经过逐层的计算，输出最终结果的过程</p><h3 id="反向传播">反向传播</h3><p>根据梯度下降更新模型参数的过程。根据链式法则计算梯度，这个过程是从后向前传递，所以叫反向传播</p><h3 id="激活函数">激活函数</h3><p>由于”线性函数的线性函数，还是一个线性函数“，而对神经元进行加权求和是一个线性操作，为了让模型能表示一些非线性的东西，我们需要激活函数<br>$$<br>a=f(z)<br>$$</p><ul><li>$f$：激活函数，任意一个非线性函数，常见为ReLU、Sigmoid</li><li>$z$：上一神经元的加权求和结果</li></ul><p>神经网络通过反向传播来训练，激活函数必须是可微的，或者几乎处处可微（ReLU在0点不可导，但在其他地方可导）</p><h4 id="次梯度">次梯度</h4><blockquote><p>subgradient</p></blockquote><p>ReLU是一种不可微但凸的函数。</p><ul><li>不可微：因为在0点处中断了，不可导</li><li>凸函数：在函数上任意两点连成的线段，一定在函数图形的上方的函数</li></ul><p><img src="/images/%E5%87%B8%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89.png" class="lazyload" data-srcset="/images/%E5%87%B8%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="凸函数定义"></p><p>对于这种函数，我们可以用次梯度来近似梯度，对于ReLU，我们可以在0点处得到一组扇面，扇面内点直线均可以作为次梯度。在深度学习中，我们在扇面中随机取一个斜率作为梯度来优化</p><h3 id="MLP">MLP</h3><blockquote><p>Multilayer Perceptron</p></blockquote><p>多层感知器，一种最简单的前馈神经网络</p><p>前馈（Feedforward）是一种控制机制，通过在系统受到干扰之前就采取行动来预测和补偿干扰的影响，具有预测性</p><blockquote><p>前馈的反义词是反馈，在生物学中很常见</p></blockquote><h3 id="CNN">CNN</h3><blockquote><p>Convolutional Neural Network，卷积神经网络</p></blockquote><p>由卷积层、全连接层、池化层等部分组成</p><p>CNN模型结构中，卷积带来了局部性，使用相同卷积核带来了平移等变性，这些性质被称为先验知识（prior knowledge）</p><h4 id="全连接层">全连接层</h4><p>该层每个神经元，都与上一层所有神经元相连。参数量会非常巨大，mxn</p><img src="/images/全连接层.png" class="lazyload" data-srcset="/images/全连接层.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="全连接层" style="zoom:50%;" /><h4 id="卷积层">卷积层</h4><p>卷积层=局部连接+空间权重共享</p><p>局部连接：卷积层的每个神经元只与输入数据的局部区域相连，而不是与整个输入数据相连（相邻像素相关性通常比远距离的像素大）</p><p>空间权重共享：使用相同的卷积权重在不同位置提取相同特征（图像的底层特征，如边缘，通常与具体位置无关）</p><img src="/images/卷积.png" class="lazyload" data-srcset="/images/卷积.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="卷积" style="zoom:50%;" /><h4 id="池化层">池化层</h4><p>使用一个滑动窗口在神经元间操作，如求最大值（最大池化），求平均值（平均池化）</p><p>池化层的目的是降采样，生成一个尺寸更小的特征图</p><p>池化层可以实现局部不变性：窗口内发生微小抖动，但仍旧可以得到相同/相似的特征表示</p><img src="/images/池化层.png" class="lazyload" data-srcset="/images/池化层.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="池化层" style="zoom:50%;" /><img src="/images/池化.png" class="lazyload" data-srcset="/images/池化.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="池化" style="zoom:50%;" /><h3 id="RNN">RNN</h3><blockquote><p>Recurrent Neural Network，循环神经网络，参考<a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding-LSTMs</a></p></blockquote><p>$$<br>y_t=f(y_{t-1}, x_t)<br>$$</p><p>能够处理序列变化的数据（能够理解同一数据在不同上下文中含义不同）</p><img src="/images/RNN.png" class="lazyload" data-srcset="/images/RNN.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RNN" style="zoom:33%;" /><p>由于RNN依赖先前的输出结果（RNN不是前馈的），因此对GPU并不友好</p><h4 id="LSTM">LSTM</h4><p>长短期记忆，比RNN在长序列中表现更好</p><p>RNN的一个问题是，他无法从先前的关键词中有选择地提取重要信息</p><img src="/images/LSTM.png" class="lazyload" data-srcset="/images/LSTM.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="LSTM" style="zoom:33%;" /><p>图中$\sigma$表示数据转为0或1</p><p>RNN的一大问题是顺序执行，节点的输入是上一节点的输出，有依赖关系</p><h3 id="Transformer">Transformer</h3><p>Transformer一种基于Attention的神经网络架构，放弃了顺序循环，完全通过注意力机制（Attention）来建立输入和输出的依赖关系，具有更强的并行性</p><p>Transformer克服了RNN在处理序列数据时顺序执行、记忆力差、梯度爆炸等问题，成为了LLM的基础单元。</p><p>Transformer主要包括两部分：encoder和decoder</p><p>基本组件有：</p><ul><li>Embedding、Positional Encoding：将离散的token转为向量，并注入位置信息，以弥补模型缺乏序列顺序感知的能力</li><li>Multi-Head Self-Attention</li><li>MLP</li><li>LayerNorm + 残差连接</li></ul><img src="/images/transform.png" class="lazyload" data-srcset="/images/transform.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="transform" style="zoom: 33%;" /><p>其中核心组件是Attention</p><h4 id="处理序列的优势">处理序列的优势</h4><blockquote><p>参考<a href="https://www.zhihu.com/question/580810624/answer/2979260071">Civ的回答 - 知乎</a></p></blockquote><p>Transformer由于使用了Attention，在处理序列数据时具有优势，下图为RNN、CNN、Attention表示序列模型示意。</p><ul><li><p>三行绿色节点表示这些模型都是三层结构，都是从下向上依次执行</p></li><li><p>横着向右表示时间步骤</p></li><li><p>箭头表示相关联（并不代表可训练参数）</p></li></ul><img src="/images/序列.png" class="lazyload" data-srcset="/images/序列.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="序列" style="zoom:50%;" /><table><thead><tr><th></th><th>RNN</th><th>CNN</th><th>Attention</th></tr></thead><tbody><tr><td>上下文长度</td><td>full</td><td>limited</td><td>full</td></tr><tr><td>是否前馈</td><td>不前馈</td><td>前馈</td><td>前馈</td></tr><tr><td>问题</td><td>优化不行</td><td>卷积核太小</td><td>没问题</td></tr></tbody></table><p>如果我们想要模型理解“<strong>小明</strong>在星期天要去露营，<strong>他</strong>准备叫上小红”，那么模型需要理解“他”指的是“小明”，那么模型的上下文需要同时看到“小明”和“他”</p><p>CNN使用一个滑动窗口在文本中卷积，如果我们的滑动窗口比较小，那么一个窗口中就无法同时包含“小明”和“他”，为此我们需要对窗口的信息再次卷积，即增加CNN的深度，不断加深使得“小明”和“他”的距离越来越近，最后能被一个滑动窗口捕捉到</p><p><img src="/images/CNN_LLM.jpg" class="lazyload" data-srcset="/images/CNN_LLM.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CNN_LLM"></p><p>RNN使用上一步的输出结果，先前的输入都会被汇总到一起，理论上“小明”对应的信息是可以传播到”他“这一步的，但实践中RNN训练极易导致梯度爆炸，一般最多只能处理二十个词</p><p>而注意力机制允许每个神经元在任何时间点，看先前所有步骤中的任意节点，计算一个新单词时，同时用到了先前所有词</p><h4 id="Attention结构">Attention结构</h4><p>Attention的作用是根据匹配度，将知识库中最相关的信息提取出来</p><p>Attention的机制是求输入的Query和Key，计算Q和K的相似性程度（越接近点积越接近1，越正交点积越接近0），使用相似性权重对Value做加权求和<br>$$<br>Attention(Q, K, V) = Softmax(QK^T / \sqrt{d_k})V<br>$$</p><ul><li><p><strong>Q (Query)</strong>：你现在关心的元素（我要关注什么？）</p></li><li><p><strong>K (Key)</strong>：输入里每个元素的“索引标签”（别人是什么？）</p></li><li><p><strong>V (Value)</strong>：输入里每个元素真正的内容（别人携带的信息）</p></li><li><p><strong>Softmax(QK^T / √dk)</strong>：计算 Query 和所有 Key 的匹配度，归一化成权重。</p></li><li><p><strong>加权求和</strong>：用这些权重对所有 Value 线性组合，得到新的表示。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求QKV</span></span><br><span class="line">query = attn.to_q(hidden_states)</span><br><span class="line">key = attn.to_k(hidden_states)</span><br><span class="line">value = attn.to_v(hidden_states)</span><br><span class="line"><span class="comment"># 计算QK相似性</span></span><br><span class="line">attention_probs = attn.get_attention_scores(query, key, attention_mask)</span><br><span class="line"><span class="comment"># 与V加权求和</span></span><br><span class="line">hidden_states = torch.bmm(attention_probs, value)</span><br></pre></td></tr></table></figure><p>Attention分为：</p><ul><li>Self-Attention：Q、K、V 都来自同一个序列</li><li>Cross-Attention：Q 来自一个序列，K/V 来自另一个序列</li><li>Causal-Attention：在 Self-Attention 上加掩码，只允许看历史，不看未来</li></ul><p>大模型训练时训练的权重 $W$ 是to_q、to_k、to_v，存储了模型的能力。QKV矩阵是运行时根据上下文计算出的<br>$$<br>Q = x \times W_Q<br>$$</p><p>$$<br>K = x \times W_K<br>$$</p><p>$$<br>V = x \times W_V<br>$$</p><h4 id="Self-Attention">Self-Attention</h4><blockquote><p>自注意力</p></blockquote><p>Self-Attention是一种Attention，Self-Attention是计算单一序列内部每个元素和其他元素的关联程度，QKV均来自目标序列</p><p>由于递归能力更强，参数少，被广泛使用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_self_attention</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    简化版的self-attention实现，便于理解核心原理</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># x: (seq_len, embed_dim)</span></span><br><span class="line">    seq_len, embed_dim = x.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 简单起见，直接使用输入作为Q、K、V（实际应该用线性变换）</span></span><br><span class="line">    Q = K = V = x</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算注意力分数，这里 math.sqrt(embed_dim)是除以根号d，是为了防止梯度丢失</span></span><br><span class="line">    attention_scores = torch.matmul(Q, K.T) / math.sqrt(embed_dim)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Softmax归一化</span></span><br><span class="line">    attention_weights = F.softmax(attention_scores, dim=-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 加权求和</span></span><br><span class="line">    output = torch.matmul(attention_weights, V)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> output, attention_weights</span><br></pre></td></tr></table></figure><blockquote><p>Self-Attention可以类似一种更高级的卷积操作</p><p>对于一个图像，我们可以用一个nxn的卷积核，得到一个和原图像尺寸一样的新图片，这里新图片的每一个像素都经过了一次更新，都有着过去同位置像素和其邻居像素的信息。</p><p>Self-Attention的输入是一个[L,D]的序列，输出也是一个[L,D]的序列，新序列中每个元素也都得到了更新，但是相较于卷积，Self-Attention每个元素更新，都用到了整个序列的所有内容，是自己+序列中其他所有元素的加权和。不过利用注意力机制，这个“超级卷积”不是无脑求和，而是有选择的按需分配注意力，比如当前元素是“他“，可能会给上文中”小明“更高的注意力</p></blockquote><h4 id="Mask-Self-Attention">Mask Self-Attention</h4><p>在自回归生成时，在生成第 $t$ 个词时，模型只能看到前 $t-1$ 个词，我们用第 $t-1$ 个词来计算QKV，用 $Q_{t-1}$ 去匹配先前所有的K，得到每个匹配度。然后将匹配度转为概率（Softmax），取对应的V融合为结果</p><p>以“我喜欢”预测下一个词为例：</p><ol><li>模型最后一个词是“喜欢”，得到“喜欢”的初始向量 $x_{喜欢}$</li><li>对 $x_{喜欢}$ 进行残差、归一化等预处理，得到 $Input_{喜欢}$</li><li>$Input_{喜欢}$ 分别与 $W_Q$ 、$W_K$ 、$W_V$ 点积，得到QKV</li><li>对QK进行旋转编码，将KV存入KV-Cache</li><li>让 $Q_{喜欢}$ 和 KV-Cache中所有的K（包括 $K_{喜欢}$）进行匹配，得到所有分数 $Score = Q_{喜欢} \cdot K_{我}$</li><li>将这些分数Softmax为概率，假设这里 $p_{我}=0.9$，$p_{喜欢}=0.1$</li><li>采样，融合，得到 $Z=0.9 \times V_{我} + 0.1 \times V_{喜欢}$</li><li>$Z$ 和输出矩阵 $W_O$ 整合，经过MLP，得到以embedding</li><li>与词表进行对比，发现和“你”最靠近</li><li>预测下一次为“你”</li></ol><h4 id="位置编码">位置编码</h4><p>位置编码（Positional Encoding），Transformer本身是无序结构，只能看到一堆token embd，需要告诉模型token的位置信息</p><p>绝对位置编码（Absolute Position Encoding），给每个位置加上一个固定或可学习的向量</p><p>相对位置编码（Relative Position Encoding），模型不关心具体在某一帧，而是帧和帧的距离关系（第3个词和第5个词之间间隔2，计算注意力权重时，这个间隔2比位置3、5更重要）</p><h5 id="RoPE">RoPE</h5><p>旋转位置编码（Rotary Position Embedding，RoPE），一种相对位置编码的实现方式，通过在注意力机制中，先计算出裸的QK矩阵（只有语义信息），在向量空间中将QK矩阵旋转 $m \times \theta $ 度（m是这个词的位置，如第几个词），得到最终的矩阵。这种方法让模型隐式感知相对位置信息，不需要显示加入绝对位置编码</p><p>旋转后的QK点积结果：<br>$$<br>\text{Score} = q_{\text{rotated}} \cdot k_{\text{rotated}} = |q| |k| \cos((m - n)\theta)<br>$$<br>RoPE有效的原因：</p><ol><li>相对位置的平移不变形：将”我喜欢狗“这句话移动到文章的任何一个位置，“我”和“狗”的相对位置不变，注意力机制是对两个向量（QK）进行点积，从分数公式可知，最终的分数仅和 $m-n$ 即两个词的相对位置有关，所以旋转不会使得注意力机制失效</li><li>远程衰减</li><li>外推能力</li></ol><h4 id="置换不变">置换不变</h4><blockquote><p>Permutation Invariant</p></blockquote><p>置换不变的含义：将输入序列打乱，模型的输出结果不会改变</p><p>Transformer（在没有位置编码的情况下）就是置换不变的</p><blockquote><p>矩阵的行交换、行倍乘、行加减都不影响解集</p></blockquote><h5 id="自然语言中的置换不变">自然语言中的置换不变</h5><ul><li>并列：“我喜欢吃苹果和香蕉”与“我喜欢吃香蕉和苹果”</li><li>无序集合：“三只猫在房间里”与“房间里有三只猫“</li><li>无序属性：“一个漂亮聪明的女孩”与“一个聪明漂亮的女孩”</li><li>统计与摘要</li><li>通过<strong>与</strong>连接的逻辑命题</li></ul><h4 id="KV-Cache">KV-Cache</h4><p>如果不做优化，每次对话时后需要重新计算QKV矩阵，而KV矩阵实际上是可以复用的</p><p>比如让模型预测“我爱吃“的下一个词，此时计算出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;我&#x27;, &#x27;爱&#x27;, &#x27;吃&#x27;]</span><br></pre></td></tr></table></figure><p>的QKV矩阵，预测出“苹”，下一个词我们需要计算</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;我&#x27;, &#x27;爱&#x27;, &#x27;吃&#x27;, &#x27;苹&#x27;]</span><br></pre></td></tr></table></figure><p>如果服用先前三词的KV矩阵，实际只需要新计算”苹“的KV矩阵</p><h4 id="应用">应用</h4><h5 id="GPT">GPT</h5><blockquote><p>Generative Pre-trained Transformer</p></blockquote><p>一个语言模型，输入句子前缀，预测下一个单词</p><h5 id="Diffusion-Transformer">Diffusion Transformer</h5><blockquote><p>DiT</p></blockquote><p>用Transformer替代UNet，进行Latent的生成</p><h5 id="VIT">VIT</h5><blockquote><p>Vision Transformer</p></blockquote><p>基于Transformer的计算机视觉技术，将大模型NLP和CV整合在一起</p><p>Transformer在处理（一维）序列数据上非常优秀，但图像是一个二维数据，所以我们使用<strong>位置编码</strong>，将二维的图像转为一维的序列</p><p>位置编码：ViT将一张图片进行切分，如下图切分为9份，将这些patch平铺为一个序列。</p><p>使用位置编码可以让模型更好理解不同物体的位置的相对关系</p><p><img src="/images/ViT.png" class="lazyload" data-srcset="/images/ViT.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ViT"></p><h5 id="DINOv2">DINOv2</h5><p>一个自监督ViT，常作为image_cond_model，将图片转为embedding</p><h5 id="CLIP">CLIP</h5><p>通过大量图片和文本对进行训练，可以对齐图像和文本的关系，也可以通过余弦相似度来判断两个图片的相似度</p><h2 id="深度学习">深度学习</h2><blockquote><p>“深度学习是一种表示学习”——何凯明</p></blockquote><h3 id="LeNet">LeNet</h3><p>开创了卷积层、池化层、全连接层，并使用反向传播端到端训练整个架构，参考<a href="###CNN">CNN</a>。但受困于算力和数据集过少没有得到重视</p><h4 id="端到端">端到端</h4><blockquote><p>end to end</p></blockquote><p>AI系统直接从输入数据中学习，并产生期望的输出，无需人为分解中间步骤</p><p>流程简单，但非常黑盒，不可解释，会发生灾难性遗忘</p><h3 id="AlexNet">AlexNet</h3><blockquote><p><a href="https://proceedings.neurips.cc/paper_files/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf">论文地址</a></p></blockquote><p>使用了更大的数据集（ImageNet）和更大模型</p><h4 id="结构">结构</h4><p>一共八层</p><p><img src="/images/Alex.png" class="lazyload" data-srcset="/images/Alex.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Alex"></p><h4 id="稀疏激活">稀疏激活</h4><blockquote><p>Sparse Activation</p></blockquote><p>稀疏激活是指在神经网络中，大部分神经元的输出为0（或接近0），只有少量神经元输出非零值</p><p>使用稀疏激活可以提高计算效率，加速收敛，降低损失</p><p>通常通过使用特定的激活函数（activation function）实现，比如ReLU（Rectified Linear Unit）</p><p>$$<br>f(x)=\max(0, x)<br>$$</p><h4 id="多GPU训练">多GPU训练</h4><p>单个GPU的显存太小，无法放下训练数据，由于当时显卡具有交火功能，可以直接从另一张卡中读写数据，于是作者将模型平分放在两张卡上</p><p>为了减少GPU间通信，模型被设计为好几层，只有在某些层（C3）两张卡才会进行数据通信，其他层的输入只使用当前GPU中上一层的输出，大幅减少了通信次数</p><h4 id="LRN">LRN</h4><blockquote><p>Local Response Normalization</p></blockquote><p>对模型的输出进行归一化，以提高模型泛化的能力</p><h4 id="重叠池化">重叠池化</h4><blockquote><p>Overlapping Pooling</p></blockquote><p>重叠池化的池化窗口在特征图上滑动时存在重叠部分。通过增加特征冗余性、减少空间信息损失、增强特征不变性、提高尺度不变性和降低特征维度等方式，有助于防止模型在训练过程中发生过拟合现象</p><h4 id="数据增强">数据增强</h4><blockquote><p>Data Augmentation</p></blockquote><p>在不实质增加数据的情况下，扩展训练数据的方法</p><ol><li>对图片旋转、缩放、裁剪、通道变换</li><li>对文本替换、插入、删除、同义替换</li><li>对语音添加噪声、改变语速、改变音调</li></ol><h4 id="dropout">dropout</h4><p>对神经元的输出结果进行随机丢弃（以概率$\mathbf{p}$置零）</p><blockquote><p>dropout很显然会影响神经元输出的均值，毕竟白白多出了这么多0，从x降到(1-p)x</p><p>model.eval()后，模型将不会dropout，为了实现训练和推理的一致性，模型所有神经元都会输出，但是每个输出都会乘以(1-p)，以保证绝对值均值一致</p></blockquote><h3 id="Visualizing-ConvNet">Visualizing ConvNet</h3><p>对神经网络进行可视化，发现神经网络可以学习数据的高级表示。并发现模型是可迁移的，可以在大数据集中预训练出能力，再在小数据集中fine-tune</p><h4 id="迁移学习">迁移学习</h4><p>模型能够学习大数据集中数据的抽象表示，这种表示在其他类似的小数据集中也有意义，于是我们可以在大数据集中做预训练，在其他数据集中做fine-tune</p><p>One-Shot Learning、few-shot learning是一种特殊的迁移学习，仅使用一个（或很少的）样本进行学习，使得模型可以识别新的类型。在人脸识别、物品检测、音频克隆中很常用</p><h3 id="VGGNet">VGGNet</h3><blockquote><p><a href="https://arxiv.org/pdf/1409.1556">论文地址</a></p></blockquote><p>作者成功构建出一个非常深的卷积神经网络，并得到了更低的错误率和更强的泛化能力</p><p>为了构建一个很深的神经网络，作者</p><ol><li>使用了非常小的卷积核</li><li>参数随机初始化</li><li>数据增强，比如随机裁剪、多尺度训练（放缩）</li><li>多GPU并行训练，将图像切分放入GPU中求梯度，将所有GPU中的梯度做均值，作为最终梯度</li></ol><h3 id="GoogLeNet">GoogLeNet</h3><p>启发了标准化模块</p><h3 id="normalization-modules">normalization modules</h3><img src="/images/归一化.png" class="lazyload" data-srcset="/images/归一化.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="归一化" style="zoom: 33%;" /><ol><li>对输入数据减去期望，再除以标准差，以实现归一化。</li><li>对归一化的结果引入一个线性变化，以提高自由度</li></ol><h3 id="ResNet">ResNet</h3><p><a href="https://arxiv.org/pdf/1512.03385">论文地址</a></p><p>实现训练更深（上千层）的模型，减轻了退化现象</p><h4 id="退化现象">退化现象</h4><p>先前的工作表明，模型越深越好，但实践中深到一定程度，会出现退化（degradation）现象：即随着网络深度的提升，准确性会饱和。</p><p>作者认为，如果解决一个任务最适合用K层网络，那么即使我们训练了一个比K深的网络，只要K之后的网络做恒等映射（Identity Mapping），直接返回输入的值，就能取得和K层网络相同的效果。因此，理论上比K深的模型效果不应比K层差，但实验结果是某个任务56层确实比20层差</p><p><img src="/images/ResNet.png" class="lazyload" data-srcset="/images/ResNet.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ResNet"></p><p>于是作者认为，模型在试图用多个非线性层混合输出一个恒等映射（比如对一个数据先平方再开方之类的吗？），我们应该直接给模型一个恒等映射的能力</p><h4 id="残差学习框架">残差学习框架</h4><p>作者引入了残差学习框架，来解决退化问题</p><p><img src="/images/ResNet2.png" class="lazyload" data-srcset="/images/ResNet2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ResNet2"></p><p>残差网络的核心，是在非线性层基础上加了一个x，从<br>$$<br>y = F(x)<br>$$<br>变成（当然，新训练出的F(x)和之前是不同的）<br>$$<br>y = F(x)+x<br>$$<br>使用了这种操作（快捷连接）的网络都可以称作残差神经网络</p><p>理论上（万能近似定律），无论是$y=F(x)$还是$y=F(x)+x$，喂入足够的数据，都能拟合出所需的函数，区别是这两个模型的训练难度可能有所差异</p><p>通过观察可知，这一层模型是有可能被训练为$y=x$，也就是$F(x)$的输出恒为0，此时实现了恒等映射</p><h4 id="维度映射">维度映射</h4><p>残差网络中输入和输出的维度应该是相同的，但实践中经常需要改变输出输出的通道数，可以用一个线性投影来匹配维度<br>$$<br>y=F(x, {W_i})+W_sx<br>$$</p><ul><li>zero-padding shortcuts：通过在输入中填充0来增加维度</li><li>projection shortcuts：通过1x1的卷积线性增加或减少维度</li></ul><p>作者发现投影效果比零填充要好，但也没有好太多，于是不是必须的</p><h4 id="网络架构">网络架构</h4><ol><li>和VGGNet很类似，使用3x3的滤波器进行卷积</li><li>当输出的维度减半时，滤波核的数量就跟着翻倍，以维持复杂度</li><li>每两层网络添加一个快捷连接，以实现残差网络</li></ol><p><img src="/images/ResNet3.png" class="lazyload" data-srcset="/images/ResNet3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ResNet3"></p><h2 id="大语言模型">大语言模型</h2><h3 id="模型">模型</h3><p>按训练方式分：</p><ul><li>预训练模型（Pre-Trained Models）</li><li>指令微调模型（Instruct-tuned Models）</li><li>强化学习微调模型（RLHF Models，Reinforcement learning from human feedback models）</li></ul><h4 id="LLM">LLM</h4><p>大语言模型</p><h4 id="VLM">VLM</h4><h4 id="LMM">LMM</h4><p>大型多模态模型</p><ul><li><p>感知</p></li><li><p>理解（认知）</p></li><li><p>生成</p></li></ul><h4 id="世界模型">世界模型</h4><ul><li>虚拟世界（游戏）</li><li>重建式（Nerf、3DGS）</li><li>生成式（Sora）</li></ul><h4 id="VLA">VLA</h4><h4 id="参数量">参数量</h4><p>B（Billion）十亿</p><p>T（Trillion）万亿</p><h5 id="激活参数量">激活参数量</h5><blockquote><p>Active Parameters</p></blockquote><p>对于MoE模型，每次推理只会使用一小部分参数量</p><p>以Qwen3-VL-235B-A22B为例，VL表示这是一个多模态模型（Vision-Language），235B表示全参数规模，A22B表示模型每次推理使用22B的激活参数量</p><p>对于MoE模型，训练时需要加载全部的参数量，但是推理时只需要激活参数量</p><h3 id="训练流程">训练流程</h3><h4 id="Pre-Training">Pre-Training</h4><blockquote><p>需要数T的数据</p></blockquote><p>从随机初始化的模型开始，通过海量数据的长时间训练，得到Base model</p><h4 id="SFT">SFT</h4><blockquote><p>Supervised Fine-Tuning，有监督微调</p></blockquote><p>训练数据为输入prompt和输出Response，loss为$\mathrm{Response} | \mathrm{prompt}$</p><h4 id="Post-Training">Post-Training</h4><blockquote><p>需要几十M到几B到数据</p></blockquote><p>目前常用RL（Reinforcement Learning）对模型进行Post-Training</p><ul><li>online RL：智能体在训练过程中持续与环境进行交互，数据的采集和训练是交替循环进行的<ul><li>PPO：RM给出绝对分数的估计值，梯度/优势为 实际得分 - Critic 预估分</li><li>GRPO：RM给出组内各个数据的分数，并得到一个排序，根据排序计算优势</li></ul></li><li>offline RL：收集一组成对数据集进行模型训练<ul><li>DPO（Direct Preference Optimization），训练数据为输入prompt、好的Response、坏的Response，loss为$\mathrm{Good} | \mathrm{prompt} - \mathrm{Bad} | \mathrm{prompt}$</li></ul></li></ul><h5 id="MPO">MPO</h5><blockquote><p>Mixed Preference Optimization</p></blockquote><p>DPO不需要Reward Model，十分简洁，但是在数据量很大时成本飙升，上限较低。PPO需要RM，训练十分脆弱不稳定，但是上限更高。</p><p>MPO（混合偏好优化）试图将DPO和PPO结合起来，先用DPO让模型初步建立好坏感，然后再PPO/GRPO</p><h3 id="训练细节">训练细节</h3><h4 id="对话模版">对话模版</h4><p>通常是一个Jinja2 脚本，负责将训练数据中的Messages转化为模型可读字符串</p><ol><li>工具调用，若输入中有tools标签，会在system中注入XML描述，告诉模型如何调用外部函数</li><li>多模态处理，统计消息中图像、视频数量，并将图像视频转化为占位符，并标记ID</li><li>回复前缀</li><li>强制思考/不思考</li></ol><h4 id="自回归训练">自回归训练</h4><p>LLM通过自回归的方式训练，对于一组对话序列，模型会根据特殊符号区分为用户输入和机器回答，只计算机器回答的Loss。</p><p>对于机器回答部分，每次先将历史序列用tokenizer转为一组token id序列，用mask标记下一词，模型预测下一词，计算和真实结果的<strong>交叉熵损失</strong>（衡量“模型预测的概率分布”与“真实下一个词”之间差距）</p><p>每次训练时，无论模型预测正确与否，每次预测下一个词时，先前的序列都是用的标准答案</p><p>模型并不是串行训练，而是一次性将每个位置的序列都先计算出来，一次性并行计算出每个位置的loss</p><h4 id="Loss">Loss</h4><h5 id="交叉熵损失">交叉熵损失</h5><blockquote><p>Cross-Entropy Loss</p></blockquote><p>目的：学习预测下一词，是LLM的核心Loss<br>$$<br>H(W) = -\frac{1}{N} \sum_{i=1}^N \log P(w_i | w_1, \dots, w_{i-1})<br>$$</p><h5 id="困惑度">困惑度</h5><blockquote><p>PPL</p></blockquote><p>目的：衡量模型预测的不确定性</p><p>常用于数据筛选</p><p>PPL 在直观上代表了模型在预测下一个词时，平均面临的<strong>等效选择分支数</strong>。如果一个模型的 PPL 是 10，意味着在模型眼中，下一个词出现的可能性相当于从 10 个同样可能的词中做选择。</p><ul><li>PPL高，意味着这段文字逻辑混乱、充满了乱码或无意义符号（模型完全看不懂）</li><li>PPL低（接近1），意味着这段文本可能是过度重复的废话或者是已经被模型背下来的模板</li></ul><h5 id="KL散度">KL散度</h5><p>目的：防止崩溃、保留原有能力</p><h4 id="分布式训练">分布式训练</h4><ul><li>数据并行：数据分成多份，分给不同的GPU，每个GPU有完整的模型副本，计算梯度后Reduce同步</li><li>模型并行：将模型的每一层切分到多个GPU中，需要在GPU间来回通信</li><li>流水线并行：将模型的不同层分配给不同GPU，但由于层和层之间存在先后依赖，会出现“流水线空泡”（pipeline bubble），利用率不高</li></ul><h4 id="显存优化">显存优化</h4><h5 id="DeepSeed">DeepSeed</h5><p>DeepSeed是微软开发的优化库，其核心ZeRO（Zero Redundancy Optimizer）机制，通过消除冗余来减少显存使用</p><table><thead><tr><th></th><th>分片部分</th><th>内存节省</th><th>适用</th></tr></thead><tbody><tr><td>Stage 1</td><td>优化器状态</td><td>少</td><td>10B以下小模型</td></tr><tr><td>Stage 2</td><td>优化器状态+梯度</td><td>中等</td><td>10B～100B</td></tr><tr><td>Stage 3</td><td>优化器状态+梯度+模型参数</td><td>多</td><td>100B+的大模型</td></tr></tbody></table><h5 id="FlashAtten">FlashAtten</h5><p>通过改变计算的先后顺序，提高了Attention的计算速度，并降低了显存</p><ul><li>矩阵分块</li><li>在线Softmax</li><li>重计算</li></ul><h4 id="训练动力学">训练动力学</h4><ul><li><strong>涌现 (Emergence)</strong>：指当模型规模（参数、算力、数据）跨越某个临界点时，模型突然展现出处理复杂逻辑、代码推理等预料之外的能力。在准确率曲线上常表现为非线性的阶梯状上升</li><li><strong>退化 (Degradation)</strong>：模型因训练不当失去原有能力的现象。<ul><li><strong>灾难性遗忘</strong>：在微调新领域数据时，若未混合旧数据，模型会快速遗忘基础能力。</li><li><strong>数据重复与质量</strong>：反复训练低质数据会导致参数空间坍缩。<strong>Condition（条件化/调节）</strong> 良好的高质量数据是防止退化的关键</li></ul></li><li><strong>先验 (Priors)</strong>：指在模型架构设计阶段引入的假设（如 Transformer 对序列关联的假设，CNN对图像连续性的假设）或初始化权重时引入的先验分布</li></ul><h4 id="蒸馏">蒸馏</h4><p>本质是一种知识迁移，将一个巨大的聪明的教师模型的能力，迁移到更小更轻量的学生模型中</p><ol><li>降低推理成本、提升速度</li><li>去粗取精，定向增强，提升特定领域的表现</li></ol><h5 id="为什么蒸馏模型更难训练LoRA">为什么蒸馏模型更难训练LoRA</h5><p>因为蒸馏模型为了用较小的参数规模达到教师的水平，学生模型的权重被压缩在一个极致（甚至脆弱）的状态，特征空间高度饱和。LoRA的核心是模型微调时的权重变化是“低秩”（Low-Rank）的，对于学生模型来说，简单的低秩矩阵可能无法在不破坏原有能力的前提下扭转模型的输出</p><h4 id="参数高效微调">参数高效微调</h4><blockquote><p>PEFT，Parameter Efficient Fine-tuning</p></blockquote><p>PEFT的核心逻辑是，在不改变原模型的基础上，通过学习低秩分解矩阵来捕捉参数更新，从而极大地降低了微调的计算与存储成本</p><p>相较于Full Fine-Tuning，PEFT更便宜高效</p><h5 id="LoRA">LoRA</h5><blockquote><p>Low-Rank Adaptation，<a href="https://zhuanlan.zhihu.com/p/663557294">参考</a></p></blockquote><p>一种PEFT手段，将权重更新 $\Delta W$ 分解为两个极小矩阵相乘<br>$$<br>W + \Delta W = W + BA<br>$$</p><ul><li>$W$ ： 原模型权重矩阵，$W \in \mathbb{R}^{d \times k}$</li><li>$A$ ：降纬矩阵，用高斯分布初始化，$A \in \mathbb{R}^{r \times k}$</li><li>$B$ ：增维矩阵，初始全0，$B \in \mathbb{R}^{d \times r}$</li><li>$r$ ：设定的秩，是一个远小于原始维度的超参数</li></ul><p>过参数化：LLM拥有大量参数，但是针对特定任务有效参数实际很少，只落在一个极低的内在纬度上。修改模型的某一层，不需要要全秩，而是可以通过一个低秩矩阵来近似</p><blockquote><p>秩（Rank）表示矩阵中线性无关的行或列的最大数量，分为行秩和列秩</p></blockquote><h5 id="冻结">冻结</h5><blockquote><p>Freeze</p></blockquote><p>固定模型的主体权重，仅更新特定的层或适配器（如 LoRA），可以极大地节省内存和计算开销，同时有效缓解灾难性遗忘，保护预训练阶段习得的通用知识</p><h4 id="MFU">MFU</h4><blockquote><p>Model FLOPs Utilization</p></blockquote><p>用于衡量模型训练中计算资源利用率的指标<br>$$<br>\mathrm {MFU} = \frac{模型一次迭代消耗的浮点运算次数 \mathrm{FLOPs}}{\mathrm{GPU}单卡算力 \times 卡数 \times 模型一次迭代的时间}<br>$$</p><h4 id="SM-Efficiency">SM Efficiency</h4><p>用于衡量GPU SM（Streaming Multiprocessor，流多处理器）利用率（有多少比例在干活）</p><p>相比GPU利用率，SM Efficiency更能反应GPU是否在“出工不出力”</p><ul><li>高 SM Activity + 低计算效率：意味着 SM 虽然在运行，但可能因为频繁等待显存读取（Memory Bound）而处于停滞状态。</li><li>低 SM Activity：通常意味着 <strong>并行度不足</strong>。对于大模型，这可能源于 Batch Size 太小、算子拆分过细、或者模型并行的流水线气泡（Pipeline Bubble）太大</li></ul><h4 id="SM-Occupancy">SM Occupancy</h4><p>每个 SM 内部驻留的 Warp 数量占最大容量的比例，用于判断 <strong>Kernel 内部</strong>的资源分配是否合理</p><h4 id="显存">显存</h4><ul><li>显存分配（Reserved）：通过显存内存池申请占用的显存空间，Reserved Memory</li><li>显存使用（Used）：实际占用的显存空间，Allocated Memory</li></ul><p>可以通过<code>torch.cuda.empty_cache()</code>手动把未使用的预留空间还给系统，但这会降低后续分配的速度</p><h3 id="Scaling-Laws">Scaling Laws</h3><p>Transformer语言模型的性能与规模强相关，而对形状（具体深度、宽度）依赖弱</p><p>模型参数数量N，数据集大小D，训练用的计算量C</p><ul><li>扩大规模会提高模型性能：同时增大N和D，性能会提升，但固定一方同时增加另一方，收益会递减</li><li>大模型比小模型更好：大模型比小模型更具样本效率，能以更少的优化步骤达到相同的性能水平，并使用更少的数据点</li></ul><p>是目前LLM最大的故事</p><h3 id="模型结构">模型结构</h3><p>LLM本质是一个基于概率的自回归任务</p><h4 id="Logits">Logits</h4><blockquote><p>logits → softmax → 概率分布 → 采样/取最大值 → 下一个 token</p></blockquote><p>在模型输出层的最后一步，模型会产生一组原始数值，称为 <strong>Logits</strong></p><p>Logits 是 LLM 最后一层全连接层输出的未归一化线性激活值。它反映了词表中每个可能的 Token 的原始能量得分</p><p>比如一个小词表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;]</span><br></pre></td></tr></table></figure><p>LLM输出的logits</p><table><thead><tr><th>Token</th><th>Logit</th></tr></thead><tbody><tr><td>Hello</td><td>1.8</td></tr><tr><td>world</td><td>0.3</td></tr><tr><td>!</td><td>-0.5</td></tr></tbody></table><p>为了将这些原始得分转化为具备统计意义的概率，需要引入<strong>Softmax 变换</strong><br>$$<br>p_i =\frac{e^{\text{logit}_{i}}}{\sum e^{\text{logit}_j}}<br>$$</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.63, 0.25, 0.12]</span><br></pre></td></tr></table></figure><p>于是模型会以63%的概率输出<code>&quot;Hello&quot;</code></p><p>在模型训练时，我们需要让正确的token的Logits尽量大（最小化交叉熵损失）<br>$$<br>\mathcal{L} = -\log \frac{e^{\text{logit}_{y_t}}}{\sum_j e^{\text{logit}_j}}<br>$$</p><h5 id="softmax">softmax</h5><p>作用是将一组实数转为一个概率分布，并放大最大的Logits（接近1），缩小小的值（压到0），适用于分类任务的概率输出<br>$$<br>\text{softmax}(z_i) = \frac{e^{z_i}}{\sum_{j=1}^{n} e^{z_j}}<br>$$<br>经过softmax，可以将模型给出的原始分变成“正且可比”的分数，分数均为0～1，且总和为1，分数越大概率越大</p><h4 id="采样">采样</h4><p>模型得到概率分布后，并不一定总是选取概率最高的Token（贪心搜索），而是通过采样策略平衡多样性与准确性</p><ul><li>Top-K：在生成下一个 Token 时，将词表按概率从大到小排序，仅在概率前 $K$ 个 Token 中进行采样<ul><li>LLM生成的概率具有长尾效应，截断这些概率极低但数量众多的低质量Token，可以有效防止模型逻辑崩坏</li></ul></li><li>Top-P：取概率累计和达到阈值 $P$（如 0.9 或 0.95）的最小 Token 集合<ul><li>模型在不同预测步骤下的“自信度”是不同的。当概率分布很集中时，Top-P 选取的集合很小；当分布很平坦时，集合变大。这种<strong>动态调整</strong>比固定的 Top-K 更加灵活，能有效过滤长尾噪声，同时保留合理的可能性</li></ul></li><li>Temperature：一种分布平滑技术，作用在Softmax前<ul><li>$\tau &lt;1$：低温，放大 Logits 之间的差异，使得概率分布变得更“尖锐”，模型会变得更保守、更确定，通常用于数学或代码任务</li><li>$\tau &gt; 1$：高温，缩小 Logits 之间的差异，使得分布更“平坦”，模型会变得更具随机性和创造性</li><li>$\tau \to 0$：等同于贪心搜索，每次使用概率最高的Token</li></ul></li><li>RAS（Repetition Aware Samping）：重复感知采样。针对已生成的 Token 动态调整概率，通过惩罚因子降低已出现词汇的概率<ul><li>专门解决模型在长文本生成中陷入“无限循环”或“复读机”的问题</li><li>存在惩罚、频率惩罚</li></ul></li></ul><h4 id="MoE">MoE</h4><blockquote><p>混合专家模式，Mixture of Experts</p></blockquote><p>通过动态选择专门的子模型或“专家”来处理输入的不同部分，每个专家专注于特定任务</p><p>Switch Transformer</p><h4 id="特殊标记">特殊标记</h4><h5 id="对话模版标记">对话模版标记</h5><p>为了让模型区分对话哪部分是人说的，哪些是机器说的，通常会通过特殊的模版标记，例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;|im_start|&gt;user</span><br><span class="line">你好&lt;|im_end|&gt;</span><br><span class="line">&lt;|im_start|&gt;assistant</span><br><span class="line">你好！我是AI助手。&lt;|im_end|&gt;</span><br></pre></td></tr></table></figure><h5 id="EOS">EOS</h5><blockquote><p>End of Sequence</p></blockquote><p>用于标记序列的结束，使得模型能够识别序列的长度和边界，能让模型学会什么时候停止生成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;|endoftext|&gt;</span><br></pre></td></tr></table></figure><h5 id="image">image</h5><p>图片会被Vision Encoder 编码后会生成大量的 Visual Tokens，这些token会替换对话中的<code>&lt;image&gt;</code>标记</p><p>常见的带image的训练集都是Image + Instruction格式，即把image标记放在最前面，后面是指令</p><ol><li>机制上，模型每个token只能看到前面的token，如果将图片放在后面，指令无法与图片建立联系</li><li>工程上，图像放在前面可以利用前缀缓存，在多轮对话可以避免重复计算</li><li>数据上，预训练中进行了大量“给定一张图 -&gt; 生成它的描述”训练，模型更喜欢图在前面。此外社区数据也都采用图+指令的格式</li></ol><h3 id="幻觉">幻觉</h3><p>模型在“一本正经地胡说八道”</p><ul><li>知识幻觉：指模型生成的回答违背了世界客观事实或常识，模型“以为”自己知道，但实际上是在编造。如编造不存在的历史事件、虚构人物传记、弄错科学常识或引用不存在的论文/法律条文</li><li>上下文幻觉：模型生成的回答与用户提供的参考文本（Context）相矛盾，或者凭空捏造了参考文本中不存在的信息，常出现在摘要、阅读理解任务中</li><li>诱导幻觉：常被称为阿谀奉承（Sycophancy）或顺从性幻觉。 这是指模型受到用户提示词（Prompt）中误导性前提、偏见或特定逻辑陷阱的影响，为了“顺从”用户或完成指令，而生成了错误的回答</li></ul><h3 id="Agent">Agent</h3><p>早期的LLM是一个Generator，是一个读过很多书的演说家，你问它答。现在的Agent是一个带工具的LLM，比如会通过工具增强（联网搜索、运行代码、调取数据库），再根据第一部搜索到的结果修正回答</p><h3 id="Reasoning">Reasoning</h3><h4 id="CoT">CoT</h4><blockquote><p>Chain of Thought</p></blockquote><p>思维链，将一个大问题拆分为多个小的子问题，逐步解决这些问题，模型的输入输出包含中间结果，模拟人类思考的过程</p><p>能提高数学问题、符号推理的求解能力</p><h3 id="Deep-Research">Deep Research</h3><p>深度研究模型，通过智能体工具、长程推理拓展LLM能力，通常为Reasoning + Act架构</p><ul><li>多跳推理：如果你问“A 公司的核心技术如何影响了 B 行业的碳中和进程？”，模型不能一步到位。它需要先查 A 的技术，再查 B 行业的现状，最后通过逻辑推导建立两者联系。这就是“多跳”</li><li>长程推理：模型能够在一个长达数小时甚至数天的任务中保持目标不丢失。它能记住第一步发现的矛盾点，并在第十步时回过头来核实，而不是走一步忘一步</li><li>迭代规划：模型会根据搜索到的结果实时修正计划。如果原本计划搜网页 A，但网页 A 说“相关信息请参考报告 B”，模型会动态改变路线去抓取报告 B</li></ul><h3 id="应用-2">应用</h3><p>LLM可以做很多应用，很多功能不需要训练就能实现，在训练前需要先思考是否可以不训练</p><table><thead><tr><th>功能</th><th>实现方法</th></tr></thead><tbody><tr><td>跟随一些指令（如讨论xxx，不讨论xxx）</td><td>修改prompt</td></tr><tr><td>查询数据库/知识库</td><td>RAG</td></tr><tr><td>定制LLM（如医疗大模型）</td><td>训练</td></tr></tbody></table><h4 id="提示学习">提示学习</h4><blockquote><p>Prompt Learning</p></blockquote><p>将任务转化为一个语言模型的预测问题，通过调整提示的格式和内容，使模型能够更准确地理解任务要求并生成相应的答案</p><p>你可以把很多奇怪的任务比如用矩阵控制人物表情转为训练一个模型输出字符串，再将这个字符串转回矩阵</p><h4 id="RAG">RAG</h4><blockquote><p>Retrieval Augmented Generation</p></blockquote><p>检索增强生成</p><p>Llama_index</p><h4 id="为什么API计费要区分输入输出">为什么API计费要区分输入输出</h4><p>大模型 API的输入和输出 token通常要分别计费</p><ul><li>输入阶段：将输入prompt做embedding，进行一次前向传播，保存KV cache</li><li>输出阶段：自回归生成并保存新token，每次都要访问缓存、前向传播</li></ul><p>输出阶段的访存带宽大，时间消耗长，计算次数多，会更贵一些</p><h3 id="分层推理模型">分层推理模型</h3><blockquote><p>Hierarchical Reasoning Model</p></blockquote><p>一种新型循环架构，能够在保持训练稳定性和效率的同时实现显著的计算深度。模型参数量小，训练成本低，但效果很好</p><p>模型由两个耦合的循环结构组成，一个高级模块负责缓慢抽象的规划与指导，一个低级模块负责快速详细的计算</p><p>LLM的深度固定，用CoT进行推理。HRM是循环架构，思考深度可拓展，用latent进行思考（没有显示CoT），成本更低</p><p>RNN训练难收敛。HRM低级模块周期内局部收敛，高级模块重制上下文</p><h2 id="计算机视觉">计算机视觉</h2><p>计算机视觉的目标是让模型能够看懂世界</p><p>感知、理解、重建、生成</p><ul><li>检测识别</li><li>分割重建</li><li>运动估计</li><li>生成合成</li><li>多模态理解</li></ul><h3 id="检测识别">检测识别</h3><h4 id="Landmark">Landmark</h4><p>使用关键点、特征点来处理计算机视觉任务，比如人脸识别中使用眼睛、嘴巴、鼻子为关键点来检测追踪</p><p><img src="/images/landmark.png" class="lazyload" data-srcset="/images/landmark.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="landmark"></p><h4 id="FACS">FACS</h4><blockquote><p>Facial Action Coding System</p></blockquote><h3 id="人体建模">人体建模</h3><h4 id="SMPL">SMPL</h4><blockquote><p>Skinned Multi-Person Linear Model</p></blockquote><p>SMPL是一种用于描述人体形状（shape）和姿态（pose）的模型</p><ul><li>shape是类似blendshape的channel，用于描述人的高矮胖瘦，可以转为fbx等模型</li><li>pose是描述了定义好的关节节点（通常为24个）的旋转状态，使用轴角存储，可以保存为bvh等骨骼动画</li></ul><p><img src="/images/SMPL.png" class="lazyload" data-srcset="/images/SMPL.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SMPL"></p><p>SMPL也有SMPL-X等拓展，还有手部等动画信息</p><h3 id="图像重建">图像重建</h3><h4 id="Inpainting">Inpainting</h4><p>使用周围像素对图像进行修复/填充</p><h4 id="结构纹理分解">结构纹理分解</h4><p>将图像分解为结构（structure）和纹理（texture），便于风格迁移、图像去噪、编辑等任务</p><h4 id="边缘提取">边缘提取</h4><p>如Canny，可以用于提取线稿，常搭配SD ControlNet使用</p><h3 id="三维重建">三维重建</h3><p>正向渲染：从三维模型出发，得到二维图像的过程（也就是图形学的渲染）</p><p>逆向渲染：从二维图像出发，重建三维场景的过程</p><h4 id="可微渲染">可微渲染</h4><blockquote><p><a href="https://youtu.be/9XyK5rhHrPk?si=4EUOO1RDnnjb4hRO">Reparameterizing Discontinuous Integrands for Differentiable Rendering</a></p></blockquote><p>可微渲染（Differentiable Rendering）是一种实现逆向渲染的方法</p><p>从一个近似的三维场景出发渲染一张二维图片，求与Ground True的损失（loss），对三维场景的参数求偏导（Partial derivatives），即可使用梯度下降（Gradient descent）的方法得到和GT最相似的三维场景参数</p><p>问题：</p><ol><li>传统的渲染器并不能对参数求偏导：搭建一个可微渲染器</li><li>很多参数不连续：对不连续的参数换元，并乘以一个平滑函数</li></ol><h4 id="NeRF">NeRF</h4><blockquote><p>《NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis》</p></blockquote><p>NeRF的任务是从一组已知的图片出发，得到其他视角下的图片</p><ol><li>环绕物体拍摄一组2d的照片，在神经网络中构建一个5维的函数，输入为世界坐标$(x,y,z)$和视角$(\theta,\phi)$，输出为体密度和颜色</li><li>使用光线步进的方式进行体渲染</li></ol><p><img src="/images/nerf.png" class="lazyload" data-srcset="/images/nerf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="nerf"></p><h4 id="3DGS">3DGS</h4><blockquote><p>Gaussian Splatting</p></blockquote><p>与NeRF类似，Gaussian Splatting也是从多个视角的图片出发，构建场景描述，通过高斯点染的方式，生成新视图</p><p><a href="https://huggingface.co/blog/zh/gaussian-splatting">高斯点染</a>的概念和光栅化很像，使用一个个椭球状的2D高斯函数为图元，将3D场景映射到2D图像上</p><h3 id="视频与运动建模">视频与运动建模</h3><h4 id="光流">光流</h4><blockquote><p>Optical Flow</p></blockquote><p>描述图像序列中像素的运动矢量场，通过计算连续两帧图像中像素点的位移来估计物体的运动<br>常见假设：</p><ol><li>亮度恒定假设</li><li>小运动假设</li><li>空间一致性假设<br>→ 用于运动估计、跟踪、插帧、动作识别等。</li></ol><h4 id="MEMC">MEMC</h4><blockquote><p>运动估计和运动补偿（Motion Estimation and Motion Compensation）</p></blockquote><p>通过分析视频中的运动信息，估计物体的运动轨迹，并根据这些信息来合成新的帧，常用于视频插帧</p><h4 id="未来帧预测">未来帧预测</h4><blockquote><p>Future Frame Prediction</p></blockquote><p>基于历史视频帧预测未来帧。<br>应用：自动驾驶、异常检测、视频编辑。<br>主要约束：</p><ul><li>空间约束（Spatial Constraints）：外观一致性</li><li>时间约束（Temporal Constraints）：动作连贯性</li></ul><h4 id="长程预测">长程预测</h4><p>扩展时间跨度的预测，关注运动趋势和长期依赖。</p><h4 id="世界线">世界线</h4><blockquote><p>Worldline</p></blockquote><p>描述物体在时空中的运动轨迹</p><h3 id="图像理解">图像理解</h3><h4 id="视觉问答">视觉问答</h4><blockquote><p>Visual Question Answering，VQA</p></blockquote><p>输入图像与问题文本，输出答案</p><h3 id="图像编辑">图像编辑</h3><h4 id="ChronoEdit">ChronoEdit</h4><p>将图形编辑视为相邻的两帧视频帧，将一个视频生成的预训练模型改为一个图像编辑模型，得到更好的物理一致性</p><h3 id="Talking-Head">Talking Head</h3><p>用于生成一个逼真的、会说话的人脸模型</p><ul><li>基于3D模型</li><li>基于视频生成</li></ul><h3 id="显著性预测器">显著性预测器</h3><blockquote><p>Saliency Predictor</p></blockquote><p>人眼无法一次性处理视野内所有细节，会优先关注突出的部分。SP旨在模拟人类的视觉系统，预测在图像或视频中，哪些区域最能吸引人的注意力</p><p>输入原始图片分析图像的特征（颜色、亮度、边缘、语义内容），生成一张显著性图，通常为灰度图或热力图（Heatmap）</p><h2 id="NLP">NLP</h2><p>自然语言处理</p><h3 id="BPE">BPE</h3><blockquote><p>Byte Pair Encoding，字节对编码</p></blockquote><p>一种子词切分技术，通过将文本中的字符或字节对进行统计和合并，生成更小的子词单位，从而实现对文本的切分</p><ol><li>构建词汇表</li><li>统计字符、字节的出现频率</li><li>按照频率从高到低合并为一个单独的字符，循环进行，直到没有字符对可以合并</li><li>得到最终的词汇表</li></ol><h3 id="ASR">ASR</h3><blockquote><p>Automatic Speech Recognition，自动语音识别</p></blockquote><p>将人类语言转化为文字，以便AI理解并处理人类语言</p><h3 id="LID">LID</h3><blockquote><p>Language IDentification，语言识别，用于确定文本或语音所属语言类别的技术</p></blockquote><h3 id="EOS-2">EOS</h3><blockquote><p>End of Sequence</p></blockquote><p>用于标注序列的结束</p><h3 id="SSM">SSM</h3><blockquote><p>State Space Model</p></blockquote><p>状态空间模型，是一种用于描述序列在各时间步的状态表示，并根据输入预测其下一个状态的模型，随着输入序列长度的增加，计算复杂度不会呈指数级增长</p><h2 id="音频">音频</h2><h3 id="Mel-Spectrogram">Mel Spectrogram</h3><p>梅尔频谱图是一种常用的标准的音频特征提取方法，可以用<code>librosa</code>将音频转化为mel谱图</p><h3 id="RTF">RTF</h3><blockquote><p>Real Time Factor，实时率</p></blockquote><p>处理音频所需的时间 / 音频时长</p><p>如果实时率小于1，则可以通过串流的方式实时给用户</p><h3 id="VAD">VAD</h3><blockquote><p>Voice Activity Detection</p></blockquote><p>语音活动检测（语音端点监测），可以从有噪音的语音中定位语音的开始和结束点、分离静音片段（或者分离主歌副歌）</p><h3 id="TTS">TTS</h3><blockquote><p>Text-to-Speech，文本转语音</p></blockquote><h3 id="ASR-2">ASR</h3><p>语音识别</p><h3 id="Vocoder">Vocoder</h3><p>声码器，将语音特征转化为声音的模型</p><h3 id="实时语音输入流">实时语音输入流</h3><p>用户的语音输入不是完整录完再送入，而是分片（chunked）输入，使得模型可以在用户尚未完全说完话，就开始响应</p><h3 id="意图边界">意图边界</h3><blockquote><p>intent boundary</p></blockquote><p>尽管用户的输入尚未停顿，但模型已经理解了“这句已经说完主要意思“</p><h3 id="音色克隆">音色克隆</h3><h4 id="RVC">RVC</h4><blockquote><p>Retrieval-based Voice Conversion</p></blockquote><p>检索式语音转换（RVC），常用于实现音色克隆</p><h3 id="音乐卡点">音乐卡点</h3><h3 id="音轨分离">音轨分离</h3><h2 id="视频">视频</h2><p>长上下文视频生成本质上是一个记忆问题</p><h2 id="3D">3D</h2><h3 id="任务">任务</h3><h4 id="MVS">MVS</h4><blockquote><p>Multi-View Stereo</p></blockquote><p>指从多视角图片重建三维场景的一类任务，通常会使用SFM等技术</p><h4 id="Novel-View">Novel View</h4><p>新颖视角</p><p>新颖视角生成是AI领域一个重要研究方向，根据一组已有的视图数据，生成一个从未出现过的新视角数据</p><h4 id="Dense-View">Dense View</h4><p>密集视角</p><p>从较多输入视角重建场景</p><h4 id="Sparse-View">Sparse View</h4><p>稀疏视角</p><p>从较少的输入视角（2~4张）重建场景</p><h3 id="长尾数据">长尾数据</h3><blockquote><p>long-tail data</p></blockquote><p>自然数据中，数据分布并不均匀，少数类别的样本及其常见（Head），大量类别的样本及其少见（Tail）。比如动物照片中，猫狗的照片数量非常非常多，但某种节肢动物的图片会很好，而节肢动物的类比远高于猫狗</p><p>长尾数据指的就是训练集中样本稀少、难以覆盖的类别或场景</p><h3 id="NeRF-2">NeRF</h3><blockquote><p>Neural Radiance Field</p></blockquote><h3 id="3dgs">3dgs</h3><blockquote><p>3D Gaussian Splatting</p></blockquote><p>目标是通过一组从场景中拍摄的图片，得到场景的三维表示，并可以做到实时渲染</p><p>3dgs是一组在三维世界坐标上的高斯球，信息有世界坐标、协方差矩阵（旋转缩放）、体密度（透明度）、球谐（颜色）</p><p>3dgs可以很容易投影为2dgs，然后通过Alpha混合的方法进行渲染</p><h4 id="3dgs的问题">3dgs的问题</h4><ol><li>没有显式的表面定义，难以与光线进行求交（跟SDF、Mesh比），没有一个好的几何</li><li>Novel View质量很差</li></ol><h4 id="TrimGS">TrimGS</h4><p>一个开源项目，能将3dgs转为三角Mesh</p><h4 id="VGGT">VGGT</h4><h3 id="SFM">SFM</h3><blockquote><p>Structure from Motion</p></blockquote><p>从无序的多视角图片重建三维场景（稀疏点云）和相机轨迹的技术</p><ul><li>图像匹配：对每个图像提取特征点，为每个特征点提取描述子，通过匹配描述子找到最相似的特征点对，这些特征点被视为同一3D点在不同视角下的投影</li><li>三角测量：给定两个匹配的特征点和他们的相机参数，计算该点的3D坐标</li><li>束调整：通过最小化所有图像中所有匹配点的重投影误差来优化相机参数和3D坐标</li></ul><h4 id="colmap">colmap</h4><p>一个开源项目，能将一组图片重建出点云和相机轨迹，进而被转为3dgs</p><h3 id="SLAM">SLAM</h3><blockquote><p>Simultaneous Localization and Mapping</p></blockquote><p>同时定位与地图构建，用于在未知环境中创建地图并实时确定设备在该地图上的位置</p><h3 id="Triplane">Triplane</h3><h3 id="Panorama">Panorama</h3><p>全景图</p><h3 id="floater">floater</h3><p>漂浮物，是3dgs重建时常出现的bad case</p><h3 id="watertight">watertight</h3><p>水密Mesh是指一个完全封闭、无孔洞、无自相交且拓扑正确的3D网格模型，没有裂缝、孔洞、非流形几何（悬浮的顶点、边）</p><p>将Mesh转为水密，有利于后续将Mesh转为SDF</p><h4 id="Poisson表面重建算法">Poisson表面重建算法</h4><p>一种基于隐式表面的重建方法，将表面重建转化为求解Poisson方程</p><p>原理大致是将点云坐标视为物体内部，指示函数为0，其余位置为0，于是得到一个标量场，该场的等值面就是目标表面，可以用marching cube的方式提取Mesh</p><p>缺点：</p><ul><li>倾向生成平滑表面，可能会平滑掉硬边、锐角</li><li>计算成本高</li><li>对法线质量要求高</li><li>对孔洞、隧道的处理能力较差</li></ul><h3 id="Occupancy-Grid">Occupancy Grid</h3><p>占用网格，是一个离散化的空间表示方法，将空间切分为体素网格，每个网格单元存储一个概率值，表示这个区域被障碍物占据的可行性，0表示完全自由，1表示完全被占用</p><p>常用于自动驾驶、SLAM、3D重建</p><h3 id="点云">点云</h3><h4 id="正负样本">正负样本</h4><p>Mesh采样点云时，通过会区分正负样本，正样本是直接从mesh表面采样点的点，负样本是从mesh表面通过偏移得到的点，负样本往往不在mesh表面</p><h3 id="Coarse-to-fine">Coarse to fine</h3><p>从粗到细，是一种常见的生成范式</p><h3 id="ICP">ICP</h3><blockquote><p>Iterative Closest Point</p></blockquote><p>迭代最近点算法，作用是将两个位置错开的点云，通过移动和旋转，使得所有配对点的距离误差平方和最小。在SLAM算法、3D重建中经常使用</p><ul><li>点对点</li><li>点对面</li></ul><h3 id="SDF">SDF</h3><p>实践中大部分SDF/UDF并不是以隐式表面/三维函数的形式，而是给定一个均匀grid求每个点距离Mesh的距离。一个常见的提取SDF的方法是</p><ol><li>遍历Mesh每一个三角面，获得他们的AABB，统计所有AABB内的grid点（活跃点），并记录这些点在哪些三角面AABB内（临域表）</li><li>遍历每个活跃点，计算活跃点距离相邻三角面的最小距离（可以用原子操作加速）</li></ol><h3 id="3D数据的问题">3D数据的问题</h3><p>3D仿真数据和现实数据是存在bias的，用仿真数据训练模型涨点，加到全部数据中可能会整体掉点</p><h2 id="具身智能">具身智能</h2><blockquote><p>Embodied AI</p></blockquote><p>具身智能的目标不是在虚拟世界中解决抽象的问题，而是处理现实物理世界复杂而多样的情况。具身智能被认为是通往AGI的一种途径</p><p>具身智能的主要研究方向：</p><ul><li><p>具身机器人</p></li><li><p>感知</p></li><li><p>模拟</p></li><li><p>交互</p></li></ul><h3 id="具身机器人">具身机器人</h3><ul><li>轮式/履带机器人</li><li>四足机器人</li><li>人形机器人</li><li>仿生机器人</li></ul><h3 id="具身感知">具身感知</h3><ul><li>vSLAM（基于视觉的同时定位与建图）</li><li>3D场景<ul><li>Projection-based</li><li>Voxel-based</li><li>Point-based</li></ul></li><li>主动探索场景</li></ul><h3 id="具身模拟">具身模拟</h3><p>在现实世界中收集数据可能非常困难昂贵，且在现实中进行实验可以损坏智能体和环境，存在风险</p><p>为了克服数据稀缺的问题，往往使用模拟器为具身智能收集数据</p><ul><li>Isaac Sim，英伟达开发的一个模拟平台</li><li>carla，汽车模拟软件</li><li>Gazebo</li></ul><h3 id="具身交互">具身交互</h3><ul><li>回答</li><li>抓取</li></ul><h3 id="世界模型-2">世界模型</h3><ul><li>生成式</li><li>预测式</li><li>基于知识的办法</li></ul><h3 id="VLA-2">VLA</h3><blockquote><p>Vision-Language-Action Model</p></blockquote><p>从多模态输入生成动作输出，可以用于机器人操作</p><p>LLM在多种任务中已经表现出很强的泛化能力，可以在没见过的场景下理解并执行指令。物理世界的机器人除了理解感知，还需要生成具体的动作</p><p>《RT-2: Vision-Language-Action Models Transfer Web Knowledge to Robotic Control》</p><p>《OpenVLA: An Open-Source Vision-Language-Action Model》</p><h3 id="manipulation">manipulation</h3><p>操控能力，主要是上半身功夫</p><ul><li>物体抓取</li><li>多指操作</li><li>多模态感知</li><li>交互预测</li></ul><h3 id="locomotion">locomotion</h3><p>移动能力，主要是下半身功夫</p><ul><li>稳定控制：在不平坦的地形不摔倒</li><li>高效移动：跑跳</li><li>环境适应：在未知环境中导航</li><li>端到端学习：从感知到控制的直接映射</li></ul>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diffusion</title>
      <link href="/ai/diffusion/"/>
      <url>/ai/diffusion/</url>
      
        <content type="html"><![CDATA[<h1>Diffusion</h1><h2 id="扩散原理">扩散原理</h2><p>生成模型的目标是：给定一组数据，构建一个分布，生成新的数据</p><p>在物理学中很多微观过程都是时间可逆的，如果能知道当前系统的状态，理论上可以求出上一时间的状态。受此启发，如果我们知道从一幅画上如何一步步加噪声，也许能学会如何从噪声出发一步步去噪声得到一幅画。</p><p>扩散模型是一类概率生成模型，定义了两个马尔可夫过程：</p><ol><li>前向过程：一个固定的马尔可夫链，将数据分布逐步添加高斯噪声，转为一种已知的先验分布（通常为标准高斯分布）</li><li>反向过程：一个参数化的马尔可夫链，从先验分布开始逐步降噪，最终生成数据分布的样本</li></ol><p>扩散模型将一个复杂的抽样转为一系列的简单抽样，简化了学习</p><blockquote><p>扩散：物质或能量在空间中自发地从高浓度区域向低浓度区域的随机运动过程，是热力学第二定律的宏观表现</p><p>扩散模型中的扩散：在噪声的不断扰动下（在原数据不断加噪声的过程），数据逐渐接近标准高斯分布的过程</p></blockquote><h3 id="高斯扩散">高斯扩散</h3><p>$$<br>x_{t+1}=x_t + \eta_t ,\quad \eta_t \sim N(0, \sigma^2)<br>$$</p><p>一个假设：反向过程中，每一次去噪声的结果，仍是高斯分布。</p><p>于是这个分布可以用一组均值和方差表示，神经网络只需要预测这组参数，就能还原出$x_0$</p><h3 id="生成策略与具体样本">生成策略与具体样本</h3><p>为什么扩散模型不是“记住具体样本（instance）”，而是学会一种“生成策略（policy）”？</p><ol><li>从训练目标来看：扩散模型优化的是分布，而非样本，不是学习某个具体的图像A，而是学习如果生成类似A的图像</li><li>从采样方式来看：扩散是一个多步决策序列</li><li>从泛化性角度，如果模型是instance base，那么采样时只会复现训练数据，对那些未训练的数据“不公平”（分布外泛化不公平）</li></ol><h3 id="最优传输理论">最优传输理论</h3><p>最优传输理论：一种研究如何以最小成本将一个概率分布转移为另一种概率分布</p><h2 id="扩散模型架构">扩散模型架构</h2><h3 id="U-Net">U-Net</h3><blockquote><p>《U-Net: Convolutional Networks for Biomedical Image Segmentation》2015.5</p></blockquote><p>U-Net最初是一个医学图像分割模型，当时的需求是神经网络既要理解全局语义信息（这是什么器官），又要精确定位像素。传统的Encoder-Decoder架构当特征图被压缩到最小时，大量空间信息被丢失了，而U-Net通过引入跳跃连接（下图灰色箭头），让高分辨率的信息直接拷贝到后续部分。</p><p>U型的网络传递全局语义信息，跳跃连接传递局部高分辨像素信息</p><p><img src="/images/UNet.png" class="lazyload" data-srcset="/images/UNet.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UNet"></p><p>U-Net的优点：</p><ol><li>对称性的架构，能保证输出和输入在空间上严格对齐</li><li>多尺度的处理能力，在扩散过程中，前期高噪声时主要进行全局结构和语义重建，后期需要进行精修细节和清晰度，U-Net可以兼顾全局和局部</li><li>高效，大部分复杂计算（如自注意力）在低分辨率的特征图中，在高分辨率下只做简单操作</li></ol><h3 id="DDPM">DDPM</h3><blockquote><p>《Denoising Diffusion Probabilistic Model》2020.12</p></blockquote><h4 id="动机">动机</h4><ol><li>当时扩散模型质量仍不够高，尽管生成样本质量高，但是对数似然不够好</li><li>作者认为扩散模型很有潜力</li><li>作者认为扩散模型和去噪分数匹配的理论有潜在联系</li></ol><h5 id="似然">似然</h5><blockquote><p>如果我们掷骰子一直是六点，比较合理的解释是这个骰子被做了手脚，密度不均匀。</p></blockquote><p>概率：模型给定后，这个数据出现的概率是多少<br>$$<br>P(x|\theta)<br>$$<br>似然（Likelihood）：这个数据出现了，模型参数应该是多少才合适<br>$$<br>\mathcal{L}(\theta|x)<br>$$<br>对数似然：似然是非常小的数，取对数方便计算</p><blockquote><p>对数似然下界（ELBO）：用于求一个复杂概率分布的后验分布，由于直接计算后验分布十分困难，所以引入变分推断来近似</p></blockquote><p>模型训练的常见目标，就是最大化似然估计（MLE），对于训练集中的数据，要如何调整模型参数，才能让模型最好地解释它</p><p>似然估计低，说明模型认为该数据不太可能在自己的分布中出现，意味着生成分布和真实分布差异较大，模型的采样结果不一定能覆盖真实数据空间。而扩散模型的训练目标，就是用已有的数据去构造一个分布，然后在分布中采样得到新数据</p><h5 id="归纳偏差">归纳偏差</h5><p>归纳偏差=模型对世界“先验相信的规则”，是未经学习就内置的思维惯性</p><ul><li>对CNN来说，图像有空间、时间一致性，这就是一种归纳偏差</li><li>对RNN来说，序列是按时间排序的，这也是一种归纳偏差</li></ul><h4 id="创新点">创新点</h4><ol><li>从预测图像改为预测噪声</li><li>简化训练方程，仅使用误差平方</li><li>将生成过程解释为渐进式有损解压缩方案</li></ol><h4 id="关键技术">关键技术</h4><h5 id="预测噪声">预测噪声</h5><p>DDPM（去噪扩散概率模型），一个常用的构建反向采样器的方法，将复杂的变分推断问题简化为一个简单的去噪任务</p><p>DDPM的简化：</p><ol><li>固定前向过程，前向加噪时使用一个预先设定的固定方差的高斯噪声，无需学习，只需要专注学习反向过程</li><li>简化反向过程，反向去噪时每次都是用固定方差的高斯噪声，模型只需要学习预测高斯分布的均值</li><li>重参数化目标，从学习预测图像转为预测噪声，极大地稳定了训练过程</li></ol><p><strong>DDPM训练伪代码</strong></p><ol><li><p>从数据集中随机抽取一批原始图像 $x_0$</p></li><li><p>为该批次中的每个图像随机选择一个时间步 $t$ (从1到T)</p></li><li><p>从标准正态分布中采样一个噪声 $\epsilon$</p></li><li><p>使用闭式解计算 $t$ 时刻的噪声图像 $x_t$</p></li></ol><p>$$<br>x_t = \sqrt{\bar{\alpha}_t} x_0 + \sqrt{1 - \bar{\alpha}_t} \epsilon<br>$$</p><ol start="5"><li><p>将 $x_t$ 和 $t$ 输入到神经网络 中，得到预测的噪声 $\epsilon_{pred}$</p></li><li><p>计算损失： $loss = \text{MSE}(\epsilon, \epsilon_{pred})$</p></li><li><p>使用梯度下降更新模型参数 $\theta$</p></li></ol><img src="/images/ddpm.jpg" class="lazyload" data-srcset="/images/ddpm.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ddpm" style="zoom:50%;" /><h5 id="重参数化">重参数化</h5><blockquote><p>Reparameterization</p></blockquote><p>对一个概率分布直接采样，是随机且不可导的。重参数化的核心是将采样分为两步：</p><ol><li><p>从一个无参数的分布（如标准正态分布）中采样一个噪声变量 $\epsilon$</p></li><li><p>通过一个确定的可导的函数 $g_{\theta}(\epsilon)$ 将噪声转化为目标样本</p></li></ol><p>于是采样过程变成了一个与参数 $\theta$ 有关的确定性函数</p><h3 id="基于分数的生成模型">基于分数的生成模型</h3><blockquote><p>《Score-Based Generative Modeling through Stochastic Differential Equations》2021.2</p></blockquote><p>从数学（Energy-Based）的角度，扩散模型本质上上学习数据的分数函数（score function）</p><h4 id="动机-2">动机</h4><ol><li>DDPM受限于离散马尔可夫过程，不能无缝拓展到连续过程</li><li>希望通过SDE提供一个连续视角，将数据分布平滑转化为先验分布，并逆转此过程</li></ol><h4 id="创新点-2">创新点</h4><ol><li>统一的SDE框架，用SDE模拟噪声演化过程，将数据平滑扩散为噪声，再逆转生成</li><li>预测-矫正采样器</li><li>概率流ODE与神经ODE连接</li><li>无条件生成模型可以通过条件SDE实现条件生成，而无需重新训练</li></ol><h4 id="关键技术-2">关键技术</h4><h5 id="分数函数">分数函数</h5><p>给定概率密度函数$p(x)$，分数函数为<br>$$<br>s(x) = \nabla_{x} \log p(x)<br>$$<br>含义为对数概率密度关于x的梯度</p><p>分数函数表示任意一点概率密度增长最快的方向，定义了数据流形上的向量场，这个局部信息可以指导我们如何在概率空间中“导航”</p><h5 id="概率流ODE">概率流ODE</h5><blockquote><p>Probability Flow ODE</p></blockquote><p>前向过程SDE：<br>$$<br>dx = f(x,t) dt + g(t) dw_t<br>$$</p><ul><li>$x$ : 数据</li><li>$f(x,t)$：漂移项</li><li>$g(t)$: 扩散系数</li><li>$dw_t$: 标准高斯噪声</li></ul><p>尽管原始扩散是SDE，但是我们可以构造一个确定性 ODE，使其在统计意义上产生相同的边缘分布 $p_t(x)$</p><p>概率流ODE：<br>$$<br>\frac{dx}{dt} = f(x,t) - \frac{1}{2} g(t)^2 \nabla_x \log p_t(x)<br>$$</p><ul><li>$f(x,t)$：漂移项（和SDE相同）</li><li>$\nabla_x \log p_t(x)$: 分数函数</li></ul><h3 id="LDM">LDM</h3><blockquote><p>《High-Resolution Image Synthesis with Latent Diffusion Models》2022.4</p></blockquote><h4 id="动机-3">动机</h4><p>过去的Diffusion直接在像素空间操作，带来了巨大的计算成本，训练门槛高、效率低下、且过度建模数据中难以察觉的细节</p><h4 id="创新点-3">创新点</h4><ol><li>使用VAE将数据编码为latent，在latent空间中训练diffusion</li><li>可以轻松画大图</li><li>VAE是单独的，可分离</li></ol><h3 id="DDIM">DDIM</h3><blockquote><p>《Denoising Diffusion Implicit Models》2022.10</p></blockquote><h4 id="动机-4">动机</h4><ol><li>DDPM采样次数过多，效率低下</li><li>DDPM采样具有随机性</li></ol><h5 id="DDPM的局限性">DDPM的局限性</h5><ol><li>采样的随机性，每一次去噪都会注入随机性，即使初始条件相同，也会得到不同的图像，无法精确控制生成过程</li><li>步数依赖：DDPM需要1000步的去噪过程，减少步数会大幅降低生成质量</li><li>不可逆：给定一张图片，无法还原出初始噪声，限制了图像编辑等模型的开发</li></ol><h4 id="创新点-4">创新点</h4><ol><li>将DDPM的马尔可夫前向过程，泛化为非马尔可夫过程，并保持相同的边缘分布，保持变分训练目标不变</li><li>提出DDIM，生成过程可确定，采样次数大幅减少</li><li>短轨迹采样，加速生成过程</li><li>链接神经ODE</li></ol><h4 id="关键技术-3">关键技术</h4><h5 id="DDIM-2">DDIM</h5><p>将DDPM的平滑过渡转为确定性映射</p><p>在DDPM中，我们采样<br>$$<br>x_{t-1} = \mu_\theta(x_t,t) + \sigma_t z,\quad z\sim\mathcal{N}(0,I)<br>$$<br>DDIM直接设定无噪声版：<br>$$<br>x_{t-1} = \mu_\theta(x_t,t)<br>$$<br>即<br>$$<br>x_{t-1} = \sqrt{\bar{\alpha}<em>{t-1}}\hat{x}<em>0 + \sqrt{1-\bar{\alpha}</em>{t-1}}\epsilon</em>\theta(x_t,t)<br>$$<br><img src="/images/ddim.jpg" class="lazyload" data-srcset="/images/ddim.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ddim" style="zoom:50%;" /></p><blockquote><p>DDIM 是 DDPM SDE 的确定性 ODE 解路径</p></blockquote><h4 id="相关概念">相关概念</h4><h5 id="边缘分布">边缘分布</h5><p>边缘分布（Marginal Distribution）：在一个多变量联合分布中，只关注其中某个变量自身分布时所得到的分布</p><p>假设我们有两个随机变量 (X) 和 (Y)，它们有联合分布 (p(x, y))。</p><p>如果我们只关心 (X) 的概率分布，那么：<br>$$<br>p(x) = \sum_y p(x, y) \quad \text{(离散情况)}<br>$$<br>或<br>$$<br>p(x) = \int p(x, y), dy \quad \text{(连续情况)}<br>$$<br>这种对另一个变量（Y）进行求和（或积分）“压扁”出来的分布，就叫边缘分布</p><p>在DDIM将马尔可夫过程转为非马尔可夫过程时，需要保持（X的）边缘分布不变，以为着我们只是修改了描述方式，而没有改动系统本身。两个模型会生成同一份数据，只是内部机制不同</p><h5 id="马尔可夫过程">马尔可夫过程</h5><blockquote><p>Markov Process</p></blockquote><p>马尔可夫过程，核心特征是<strong>无记忆性</strong>，系统的未来状态仅于当前状态有关，而与历史状态（先前的状态）无关<br>$$<br>P(X_{t+1} \mid X_t, X_{t-1}, \dots, X_0) = P(X_{t+1} \mid X_t)<br>$$<br>如果不满足这个条件，就是非马尔可夫过程，意味着系统有记忆</p><h3 id="CFG">CFG</h3><blockquote><p>《Classifier-Free Diffsuion  Guidance》2022.7</p></blockquote><h4 id="动机-5">动机</h4><p>CFG希望扩散模型既可以生成高质量图像，又可以遵循prompt条件</p><p>早期Diffusion在无条件生成领域取得非常好的成果，然而条件生成却很一般（没能超越GAN），通过直接在噪声预测网络中加条件，可以保证多样性，但生成的内容模糊、保真度低。朴素的条件生成无法实现低温度采样（不牺牲太多多样性，提高样本的锐度和符合条件的精确性）的原因，是噪声的随机性导致采样路径偏离条件生成的高密度区</p><h4 id="创新点-5">创新点</h4><ol><li>分类器指导CFG（Classifier-Free  Guidance）</li><li>在训练期间随机丢弃条件信息，来令模型同时掌握条件生成和非条件生成</li></ol><h4 id="关键技术-4">关键技术</h4><h5 id="CFG-2">CFG</h5><p>CFG让模型同时学习有条件和无条件生成，并用一个引导系数连接两者<br>$$<br>\epsilon_\text{CFG} = \epsilon_\text{uncond} + w \cdot (\epsilon_\text{cond} - \epsilon_\text{uncond})<br>$$<br>当 $w &gt; 1$ ，模型会更强烈地遵循文本条件</p><p>当 $w =0$，模型只会无条件生成</p><p>有条件和无条件生成是同一个模型共享网络参数，但是在训练和推理上，每次都需要进行两次前向计算（无条件和有条件），再将两者合并</p><h5 id="丢弃训练">丢弃训练</h5><p>额外训练一个分类器指导是十分麻烦的。CFG的作者认为分类器指导的本质，是通过隐式分类器实现的，而score的线性组合是可以等价于分类器的。使用一个单一的神经网络，同时训练条件生成和无条件生成。实现方式是在训练时随机丢弃一些条件信息（0.1～0.2的概率），模型会同时掌握条件和无条件生成。</p><h4 id="条件生成">条件生成</h4><h3 id="Flow-Matching">Flow Matching</h3><blockquote><p>《Flow Matching for Generative Modeling》2023.2</p></blockquote><h4 id="动机-6">动机</h4><ol><li>连续归一化流（CNFs）极具潜力，可以建模任意概率路径，并支持精确似然估计和确定性采样，很适合扩散模型</li><li>但传统的CNFs训练难度大，难以扩展到大规模数据集</li></ol><h4 id="创新点-6">创新点</h4><p>提出了Flow Matching训练方法，用于训练CNFs，允许使用更高阶的求解器</p><h4 id="概率密度路径">概率密度路径</h4><p>概率密度函数：对于一个连续随机变量 $X$ ，概率密度函数 $p(x)$ 描述了随机变量在每个点附近出现的“相对可能性”。</p><p>概率密度函数满足：<br>$$<br>p(x) \ge 0<br>$$</p><p>$$<br>\int_{-\infty}^{+\infty} p(x)dx = 1<br>$$</p><p>概率密度路径：一族随时间（或某个过程参数 t）变化的概率密度函数<br>$$<br>p_t(x), \quad t \in [0,1]<br>$$</p><ul><li>当 $t=0$, 是初始概率分布 $p_0(x)$</li><li>当 $t=1$, 是最终概率分布 $p_1(x)$</li><li>其他 $t$ 表示从初始分布到最终分布的演化流动过程</li></ul><p>概率密度路径表示概率是如何移动、扩散、集中</p><h4 id="连续归一化流">连续归一化流</h4><blockquote><p>Continuous Normalizing Flow，CNF</p></blockquote><p>流（Flow）：对象随着时间持续变化的过程</p><p>归一化流（Normalizing Flow）：我们想要找一个函数 $f$，可以将一个简单的概率分布（高斯分布）转化为复杂概率分布（真实图像分布），且这个过程保证变化后的分布仍是合法的概率分布（积分为1）</p><p>连续归一化流（Continuous Normalizing Flow）：普通的归一化流中，变化往往是离散的<br>$$<br>z \xrightarrow{f_1} h_1 \xrightarrow{f_2} h_2 \xrightarrow{\cdots} x<br>$$<br>而CNF中不再使用离散变化，而是让数据在一个向量场中连续流动（从分几步走变成沿着轨迹连续走）</p><h5 id="雅可比">雅可比</h5><blockquote><p>Jacobian</p></blockquote><p>如果用一个变化将向量 $z$ 映射到向量 $x$ ，将每个输出分量对每个输入分量求偏导，放在一起，就形成了雅可比矩阵</p><p><img src="/images/Jacobian.png" class="lazyload" data-srcset="/images/Jacobian.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Jacobian"></p><p>雅可比矩阵描述了这个变换在局部把空间「拉伸、压缩、翻转」的程度和方向。</p><p>雅可比矩阵补偿了体积变化，保证了概率密度变换后，仍是合法的概率密度函数<br>$$<br>\int p_X(x),dx = \int p_Z(z),dz = 1<br>$$</p><h4 id="流匹配">流匹配</h4><p>流匹配（Flow Matching）的目标是学习个从任意起点分布到终点分布的流动方向场（向量场）<br>$$<br>\frac{dx}{dt}=v_0(x,t)<br>$$<br>由于我们并不知道真实的概率分布路径，与其先设计一个真实的概率分布路径，再去跟随它，不如直接人为设定一条简单的插值路径<br>$$<br>x(t)=(1-t)x_{data}+tz_{noise}<br>$$<br>对这个路径求 $t$ 的导数得到速度：<br>$$<br>v_\theta(x(t), t) \approx \frac{dx(t)}{dt}=-x_{data} + z_{noise}<br>$$<br>只要求模型在每一个时间都能输出正确的速度方向，也能从起点到达终点，这个叫做<strong>速度场监督</strong>（velocity matching）</p><p>FM训练公式<br>$$<br>\min_\theta \ \mathbb{E}<em>{x</em>{\text{data}}, z, t}\left[ |v_\theta(x(t), t) - (z - x_{\text{data}})|^2 \right]<br>$$<br>生成时求解ODE：<br>$$<br>\frac{dx}{dt}=v_\theta(x,t)<br>$$<br>相较于DDPM和DDIM，Flow Matching更简洁、直观、可逆</p><img src="/images/flowmatching.jpg" class="lazyload" data-srcset="/images/flowmatching.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="flowmatching" style="zoom: 67%;" /><h4 id="ODE">ODE</h4><p>DDPM描述的随机扩散过程SDE：<br>$$<br>dx=f(x,t)dt+g(t)dW_t<br>$$</p><ul><li>$f$：漂移项</li><li>$g(t)$：噪声强度</li><li>$dW_t$：随机噪声</li></ul><p>训练过程训练的是噪声预测（或score function），使得模型反向过程能够还原前向加噪轨迹<br>$$<br>p_\theta(x_{t-1}|x_t) \approx q(x_{t-1}|x_t)<br>$$<br>由于存在随机噪声项，模拟的逆过程只能由随机SDE采样器（一阶欧拉法）近似实现，loss函数也绑定在这种一阶SDE采样器上</p><p>而FM彻底改写了生成过程的数据形式，不再依赖随机噪声，而是显式定义了一个确定性流动ODE<br>$$<br>\frac{dx}{dt}=v_0(x,t)<br>$$<br>FM的loss定义为<br>$$<br>\mathcal{L} = \mathbb{E}_{t, x_t, x_1, x_0} |v\theta(x_t, t) - v^*(x_t, t)|^2<br>$$<br>这个loss没有随机项，不依赖于任何一个特定的数值积分器（如果有随机项，那么loss的实际分布会与采样器有关），模型学习的是连续时间下的真实速度场，而非某种离散积分器的近似轨迹，于是在推理时可以使用比一阶欧拉更高阶的采样器，也不会破坏模型的一致性</p><h3 id="DiT">DiT</h3><blockquote><p>《Scalable Diffusion Models with Transformers》2023.2</p></blockquote><h4 id="动机-7">动机</h4><ol><li>Transformer在NLP等领域、ViT在图像分类领域取得了巨大成绩，而生成模型还在使用UNet模型</li><li>作者质疑UNet的归纳偏执是否有必要</li><li>作者希望使用Transformer大幅提升生成模型的参数量</li></ol><h4 id="创新点-7">创新点</h4><ol><li>用纯Transformer替换UNet，在LDM下训练DiT</li><li>自适应层归一化 + 零初始化</li><li>探究模型参数量和FID的关系，发现参数量提升和FID下降呈强对数线形关系</li></ol><h4 id="关键技术-5">关键技术</h4><h5 id="自适应层归一化">自适应层归一化</h5><blockquote><p>Adaptive Layer Normalization</p></blockquote><p>DiT最核心的条件注入机制，是DiT能够超越传统U-Net的关键创新之一，以极低的计算开销（&lt;1%额外Gflops）实现了高效、稳定的条件控制</p><h3 id="MM-DiT">MM-DiT</h3><blockquote><p>《Scaling Rectified Flow Transformers for High-Resolution Image Synthesis》2024.3，这是SD3的技术报告</p></blockquote><h4 id="动机-8">动机</h4><p>之前的模型使用Cross-Attention，将文本特征注入到图像生成网络中，图像和文本流是单向且独立的</p><h4 id="创新点-8">创新点</h4><ol><li>双流处理，模型为图像块和文本embedding分别维护一套独立的权重，这意味着文本和图像在各自的空间内拥有不同的特征表达能力</li><li>双流信息交换，在注意力层，图像和文本特征会被拼接在一起进行全注意力计算。这使得文本特征能够根据图像内容进行更新，反之亦然</li></ol><h2 id="采样器革命">采样器革命</h2><h3 id="DPM-Solver">DPM-Solver</h3><blockquote><p>《DPM-Solver: A Fast ODE Solver for Diffusion Probabilistic Model Sampling in Around 10 Steps》2022.10</p></blockquote><h4 id="动机-9">动机</h4><p>更高效更高阶的ODE Solver，相较于普通求解器可以用更少的步骤且不偏离最终方向</p><h4 id="创新点-9">创新点</h4><ol><li>推导扩散模型ODEs的精确解公式</li><li>提出DPM-Solver系列求解器</li><li>加速技巧：采样不受噪声类型影响、自适应步长</li></ol><h3 id="EDM">EDM</h3><blockquote><p>《Elucidating the Design Space of Diffusion-Based Generative Models》2022.10</p></blockquote><p>EDM（Elucidated Diffusion Model）= 对扩散模型“从第一性原理重新推导 + 给出更优训练和采样策略”</p><blockquote><p>第一性原理：从零开始从基础的不可再推导的基本原理出发，通过逻辑推演构建完整结论的方式，比如《几何原本》</p></blockquote><h4 id="动机-10">动机</h4><ol><li>当时的扩散模型工作理论十分复杂，噪声设计随意、loss权重不平衡、采样器多且乱</li><li>希望从实际训练的角度，聚焦训练和采样中的“有形”对象</li></ol><h4 id="创新点-10">创新点</h4><ol><li>使用对数正态分布为噪声</li><li>统一采样器理论，均基于ODE/SDE一致理论</li><li>改进损害函数</li></ol><h3 id="DMD">DMD</h3><blockquote><p>《One-step Diffusion with Distribution Matching Distillation》2024.10</p></blockquote><p>提出了一种新的蒸馏方法（Distribution Matching Distillation, DMD），成功将原本需要数十步甚至上百步迭代的扩散模型（Diffusion Models），压缩为一个仅需一步（One-step）的生成器，同时保持了极高的图像质量</p><h3 id="DMD2">DMD2</h3><blockquote><p>《Improved Distribution Matching Distillation for Fast Image Synthesis》2024.5</p></blockquote><p>DMD虽然能实现一步生成，但是依赖回归损失，这带来了代价昂贵、限制上限和灵活性</p><ol><li>DMD2移除了回归损失，引入双时间尺度更新规则（Two Time-Scale Update Rule，TTUR）</li><li>引入GAN损失</li><li>从一步生成改为多步（2～4步）生成</li></ol><h2 id="可控生成">可控生成</h2><p>实现可控生成的方法有：</p><ol><li>训练一个稳定的角色、画风LoRA</li><li>支持参考图</li><li>支持图像编辑</li></ol><h3 id="Textual-Inversion">Textual Inversion</h3><blockquote><p>《An Image is Worth One Word: Personalizing Text-to-Image Generation using Textual Inversion》2022.8</p></blockquote><h4 id="动机-11">动机</h4><p>让更好的学习一个一个新概念</p><h4 id="核心技术">核心技术</h4><h5 id="文本反演">文本反演</h5><ol><li>给定想要模型学习的新概念，以及对应的若干图片</li><li>冻结整个扩散模型，只训练概念token（如<code>&lt;sks-dog&gt;</code>）在CLIP text encoder 的 embedding 空间</li><li>模型训练</li></ol><p>在推理生成时，在prompt中写入带<code>&lt;sks-dog&gt;</code>的prompt</p><h3 id="DreamBooth">DreamBooth</h3><blockquote><p>《DreamBooth: Fine Tuning Text-to-Image Diffusion Models for Subject-Driven Generation》2023.3</p></blockquote><p>目前huggingface diffusers库提供的Flux训练均基于DreamBooth，其核心机制是：</p><ul><li>稀有标识符：在instance prompt中插入一些token，如 <code>a dog</code> 变成 <code>a [V]dog</code>，使得这个词会变得很稀有，训练效果会更好</li><li>保留先验损失：为了避免语义漂移，如将所有的 <code>a dog</code> 都绑定为 <code>a [V]dog</code>，会用训练前的模型用 <code>a dog</code>  生成出一些样本加入训练集中，这样模型能理解两者的差异</li></ul><blockquote><p>在使用huggingface 的DreamBooth训练脚本训练时，如果关闭了textencoder训练、关闭了稀有标识符替换、关闭了先验保留，就跟普通的sft没有区别了。感觉社区还是更喜欢普通sft，这种需要替换textencoder的模型还是太重了</p></blockquote><h3 id="T2I-Adapter">T2I-Adapter</h3><blockquote><p>《T2I-Adapter: Learning Adapters to Dig out More Controllable Ability for Text-to-Image Diffusion Models》2023.3</p></blockquote><h4 id="动机-12">动机</h4><p>当时的SD模型的文本提示不足，对细节的控制能力弱，用户需要更细粒度的可控生成。希望在不修改原模型的情况下，将外部控制信号映射到扩散模型的特征空间</p><h4 id="创新点-11">创新点</h4><p>提出一个轻量级、即插即用的适配器框架，不修改原始模型，支持多种控制（如草图、深度图、关键pose、语意分割）、支持多适配器组合</p><h3 id="IP-Adapter">IP-Adapter</h3><blockquote><p>《IP-Adapter: Text Compatible Image Prompt Adapter for Text-to-Image Diffusion Models》2023.8</p></blockquote><p>让扩散模型理解“图像的语义”作为prompt，实现通过图像指导生成</p><ol><li>使用CLIP提取图像特征</li><li>训练一个Adapter，将图像特征映射到text encoder的embedding空间</li><li>生成时输入文本和图像条件</li></ol><h3 id="ControlNet">ControlNet</h3><blockquote><p>《Adding Conditional Control to Text-to-Image Diffusion Models》2023.11</p></blockquote><p>对扩散模型的UNet复制一份可训练的分支，用于接收结构性输入（Canny、Depth、Pose），实现精确控制</p><h3 id="InstantID">InstantID</h3><blockquote><p>《InstantID: Zero-shot Identity-Preserving Generation in Seconds》2024.2</p></blockquote><h4 id="动机-13">动机</h4><p>zero-shot图像生成保ID</p><ol><li>基于角色LoRA等方法需要漫长训练、多参考图，且容易过拟合</li><li>IP-Adapter等方法保真度低</li><li>目前的方法难以精确控制面部</li></ol><h4 id="创新点-12">创新点</h4><ol><li>模块化设计，即插即用</li><li>高保真ID嵌入提取，取代CLIP的粗粒度嵌入</li><li>IdentityNet条件引导，不仅能保ID，还具有一定的文本编辑能力</li></ol><h4 id="关键技术-6">关键技术</h4><h5 id="参考图处理">参考图处理</h5><p>在生图过程中，从参考图中提取ID嵌入和粗landmark，输出UNet残差，作为条件注入扩散生成</p><h5 id="数据预处理">数据预处理</h5><p>从人类主体的图像-文本对出发（LAION-Face），检测面部，使用antelopev2（insightface）提取ID嵌入，生成粗关键点图（2眼、鼻、2嘴）</p><h3 id="PuLID">PuLID</h3><blockquote><p>《PuLID: Pure and Lightning ID Customization via Contrastive Alignment》2024.10</p></blockquote><p>人脸保ID</p><h3 id="Flux-Kontext">Flux Kontext</h3><blockquote><p>《FLUX.1 Kontext: Flow Matching for In-Context Image Generation and Editing in Latent Space》2025.6</p></blockquote><h4 id="动机-14">动机</h4><p>训练一个同时输入文本和参考图的生成模型</p><h4 id="创新点-13">创新点</h4><p>将上下文图像的latent拼接在序列中，实现了基于参考图的编辑能力</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[latent_x (t=0) ; latent_y (t=1)] + 文本tokens</span><br></pre></td></tr></table></figure><h3 id="Qwen-Image">Qwen-Image</h3><blockquote><p>《Qwen-Image Technical Report》2025.8</p></blockquote><h2 id="应用">应用</h2><h3 id="如何组织-prompt">如何组织 prompt</h3><h3 id="T2I">T2I</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DiffusionPipeline</span><br><span class="line"></span><br><span class="line">pipe_id = <span class="string">&quot;stabilityai/stable-diffusion-xl-base-1.0&quot;</span></span><br><span class="line">pipe = DiffusionPipeline.from_pretrained(pipe_id, torch_dtype=torch.float16).to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;a blue hair gril&quot;</span></span><br><span class="line">image = pipe(prompt, num_inference_steps=<span class="number">45</span>, guidance_scale=<span class="number">7.5</span>, height=<span class="number">1024</span>, width=<span class="number">1024</span>).images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">image.save(<span class="string">&quot;output.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="T2I-LoRA">T2I LoRA</h3><p>LoRA可以改变模型画风</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DiffusionPipeline</span><br><span class="line"></span><br><span class="line">pipe_id = <span class="string">&quot;stabilityai/stable-diffusion-xl-base-1.0&quot;</span></span><br><span class="line">pipe = DiffusionPipeline.from_pretrained(pipe_id, torch_dtype=torch.float16).to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">pipe.load_lora_weights(<span class="string">&quot;sd-gbf-lora&quot;</span>, weight_name=<span class="string">&quot;default_0&quot;</span>)</span><br><span class="line">pipeline.set_adapters(<span class="string">&quot;default_0&quot;</span>, <span class="number">1.0</span>) </span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;a blue hair gril&quot;</span></span><br><span class="line">lora_scale = <span class="number">0.9</span></span><br><span class="line">image = pipe(prompt, num_inference_steps=<span class="number">45</span>, guidance_scale=<span class="number">7.5</span>, cross_attention_kwargs=&#123;<span class="string">&quot;scale&quot;</span>: lora_scale&#125;, height=<span class="number">1024</span>, width=<span class="number">1024</span>).images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">image.save(<span class="string">&quot;output.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="I2I-LoRA">I2I LoRA</h3><p>将图片转为LoRA画风</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> StableDiffusionXLImg2ImgPipeline</span><br><span class="line"></span><br><span class="line">pipe_id = <span class="string">&quot;stabilityai/stable-diffusion-xl-base-1.0&quot;</span></span><br><span class="line">pipe = StableDiffusionXLImg2ImgPipeline.from_pretrained(pipe_id, torch_dtype=torch.float16).to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">pipe.load_lora_weights(<span class="string">&quot;sd-gbf-lora&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载输入图像</span></span><br><span class="line">input_image_path = <span class="string">&quot;examples/lubi.jpg&quot;</span>  </span><br><span class="line">input_image = Image.<span class="built_in">open</span>(input_image_path).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;gbfhero&quot;</span>  </span><br><span class="line">negative_prompt = <span class="string">&quot;low quality, bad quality&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    output_image = pipe(</span><br><span class="line">        prompt=prompt,</span><br><span class="line">        negative_prompt=negative_prompt,</span><br><span class="line">        guidance_scale=<span class="number">7.5</span>,</span><br><span class="line">        cross_attention_kwargs=&#123;<span class="string">&quot;scale&quot;</span>: <span class="number">0.9</span>&#125;, </span><br><span class="line">        height=<span class="number">1024</span>, width=<span class="number">1024</span>,</span><br><span class="line">        image=input_image,</span><br><span class="line">        strength=<span class="number">0.5</span>  <span class="comment"># 控制生成图像与输入图像的相似程度，范围为0到1</span></span><br><span class="line">    ).images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">output_image.save(<span class="string">f&quot;outputs/1.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="I2I-LoRA-Controlnet">I2I LoRA Controlnet</h3><p>直接使用I2I LoRA效果并不好，对原图的控制能力比较弱，可以配合使用Controlnet使用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> StableDiffusionXLControlNetImg2ImgPipeline, ControlNetModel</span><br><span class="line"></span><br><span class="line">output_folder = <span class="string">&quot;outputs&quot;</span></span><br><span class="line">os.makedirs(output_folder, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型和Controlnet</span></span><br><span class="line">pipe_id = <span class="string">&quot;stabilityai/stable-diffusion-xl-base-1.0&quot;</span></span><br><span class="line">controlnet_id = <span class="string">&quot;diffusers/controlnet-canny-sdxl-1.0&quot;</span></span><br><span class="line">controlnet = ControlNetModel.from_pretrained(controlnet_id, torch_dtype=torch.float16)</span><br><span class="line">pipe = StableDiffusionXLControlNetImg2ImgPipeline.from_pretrained(pipe_id, controlnet=controlnet, torch_dtype=torch.float16).to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">pipe.load_lora_weights(<span class="string">&quot;sd-gbf-lora3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图片</span></span><br><span class="line">input_image_path = <span class="string">&quot;examples/leishen.jpeg&quot;</span>  </span><br><span class="line">input_image = Image.<span class="built_in">open</span>(input_image_path).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">np_image = np.array(input_image)</span><br><span class="line"><span class="comment"># 生成 edges</span></span><br><span class="line">np_image = cv2.Canny(np_image, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">np_image = np_image[:, :, <span class="literal">None</span>]</span><br><span class="line">np_image = np.concatenate([np_image, np_image, np_image], axis=<span class="number">2</span>)</span><br><span class="line">canny_image = Image.fromarray(np_image)</span><br><span class="line">canny_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_folder&#125;</span>/tmp_edge.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;gbfhero, clean background&quot;</span></span><br><span class="line">negative_prompt = <span class="string">&quot;low quality, bad quality&quot;</span></span><br><span class="line">lora_scale = <span class="number">0.9</span></span><br><span class="line">image = pipe(prompt, </span><br><span class="line">    negative_prompt=negative_prompt,</span><br><span class="line">    guidance_scale=<span class="number">7.5</span>,</span><br><span class="line">    cross_attention_kwargs=&#123;<span class="string">&quot;scale&quot;</span>: lora_scale&#125;, </span><br><span class="line">    controlnet_conditioning_scale=<span class="number">0.5</span>,</span><br><span class="line">    image=input_image,</span><br><span class="line">    strength=<span class="number">0.9</span>,</span><br><span class="line">    control_image=canny_image,</span><br><span class="line">    height=<span class="number">1024</span>, width=<span class="number">1024</span>).images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">image.save(<span class="string">f&quot;<span class="subst">&#123;output_folder&#125;</span>/5.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="更长的prompt">更长的prompt</h3><p>SD画图经常遇到CLIP能力限制，Token数不够的问题，这限制了我们使用更多更长的prompt</p><p>可以使用<a href="https://github.com/xhinker/sd_embed?tab=readme-ov-file">sd_embed</a>库，克服77 Token限制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sd_embed.embedding_funcs <span class="keyword">import</span> get_weighted_text_embeddings_sdxl</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;...&quot;</span></span><br><span class="line">negative_prompt = <span class="string">&quot;...&quot;</span></span><br><span class="line">seed = <span class="number">481167465</span></span><br><span class="line"></span><br><span class="line">pipeline = StableDiffusionXLPipeline.from_single_file(</span><br><span class="line">    model_path,</span><br><span class="line">    torch_dtype=torch.float16,</span><br><span class="line">    use_safetensors=<span class="literal">True</span>,</span><br><span class="line">    variant=<span class="string">&quot;fp16&quot;</span>,</span><br><span class="line">    scheduler = scheduler</span><br><span class="line">).to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line">( </span><br><span class="line">  prompt_embeds,</span><br><span class="line">  prompt_neg_embeds,</span><br><span class="line">  pooled_prompt_embeds,</span><br><span class="line">  negative_pooled_prompt_embeds</span><br><span class="line">) = get_weighted_text_embeddings_sdxl(</span><br><span class="line">    pipeline,</span><br><span class="line">    prompt=prompt,</span><br><span class="line">    neg_prompt=negative_prompt</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成图像</span></span><br><span class="line">image = pipeline(</span><br><span class="line">    prompt_embeds=prompt_embeds,</span><br><span class="line">    negative_prompt_embeds=prompt_neg_embeds,</span><br><span class="line">    pooled_prompt_embeds=pooled_prompt_embeds,</span><br><span class="line">    negative_pooled_prompt_embeds=negative_pooled_prompt_embeds,</span><br><span class="line">    num_inference_steps=<span class="number">28</span>,</span><br><span class="line">    guidance_scale=<span class="number">5.0</span>,</span><br><span class="line">    generator=torch.Generator(device=pipeline.device).manual_seed(seed),</span><br><span class="line">    height=<span class="number">1216</span>,</span><br><span class="line">    width=<span class="number">832</span></span><br><span class="line">).images[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="检查VAE">检查VAE</h3><p>只加载vae，将图片编码为latent，再解码回图像，这里使用Flux的VAE</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> AutoencoderKL</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">vae = AutoencoderKL.from_pretrained(<span class="string">&quot;black-forest-labs/FLUX.1-dev&quot;</span>, subfolder=<span class="string">&quot;vae&quot;</span>, torch_dtype=torch.bfloat16)</span><br><span class="line">device = <span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span></span><br><span class="line">vae = vae.to(device)</span><br><span class="line"></span><br><span class="line">image_path = <span class="string">&quot;0.png&quot;</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(image_path).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Resize to a size divisible by 16 (e.g., 1024x1024 for Flux)</span></span><br><span class="line">image = image.resize((<span class="number">1024</span>, <span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocess image to tensor in [-1, 1]</span></span><br><span class="line">img_array = np.array(image).astype(np.float32) / <span class="number">255.0</span></span><br><span class="line">img_array = img_array * <span class="number">2.0</span> - <span class="number">1.0</span></span><br><span class="line">img_tensor = torch.from_numpy(img_array).permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>).unsqueeze(<span class="number">0</span>)  <span class="comment"># Shape: (1, 3, H, W)</span></span><br><span class="line">img_tensor = img_tensor.to(device, dtype=vae.dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encode the image to latents</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    latent_dist = vae.encode(img_tensor)</span><br><span class="line">    <span class="comment"># Use mode (mean) for better reconstruction</span></span><br><span class="line">    latents = latent_dist.latent_dist.mode()</span><br><span class="line">    <span class="comment"># Apply scale and shift (specific to Flux VAE)</span></span><br><span class="line">    latents = latents * vae.config.scaling_factor + vae.config.shift_factor</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decode the latents back to image</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="comment"># Reverse shift and scale</span></span><br><span class="line">    latents_for_decode = latents / vae.config.scaling_factor + vae.config.shift_factor</span><br><span class="line">    decoded = vae.decode(latents_for_decode).sample</span><br><span class="line"></span><br><span class="line"><span class="comment"># Postprocess decoded tensor to [0, 1] and convert to PIL image</span></span><br><span class="line">decoded = (decoded + <span class="number">1.0</span>) / <span class="number">2.0</span></span><br><span class="line">decoded = torch.clamp(decoded, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">decoded_img = (decoded[<span class="number">0</span>].<span class="built_in">float</span>().permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).cpu().numpy() * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">output_image = Image.fromarray(decoded_img)</span><br><span class="line"></span><br><span class="line">output_image.save(<span class="string">&quot;0-re.png&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://github.com/zsc/diffusion_tutorial/tree/main">diffusion_tutorial</a></p><p>《Step-by-Step Diffusion: An Elementary Tutorial》</p><p><a href="https://zsc.github.io/diffusion_tutorial/html/">扩散模型教程</a></p>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Graph Editor</title>
      <link href="/engine/UnityGraphEditor/"/>
      <url>/engine/UnityGraphEditor/</url>
      
        <content type="html"><![CDATA[<h1>Unity Graph Editor</h1><p>今天跟群友聊天聊到Behavior Designer，这是一个Unity行为树的库，突然好奇如何自己在Unity绘制一个Graph Node Editor，简单做了下调研</p><h2 id="Handles">Handles</h2><blockquote><p>Handles的用法和GL很像，你也可以用GL.xxx实现下面的代码</p></blockquote><p>Unity的Handles类本身就可以像OpenGL那样绘制2D Editor</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DrawGraphWindow</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DrawGraphWindow _window;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">float</span> _minZoom = <span class="number">0.4f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">float</span> _maxZoom = <span class="number">7.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">float</span> _zoonSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    <span class="keyword">private</span> Color bgColor = <span class="keyword">new</span> Color(<span class="number">0.15f</span>, <span class="number">0.15f</span>, <span class="number">0.15f</span>);</span><br><span class="line">    <span class="keyword">private</span> Color gridColor = <span class="keyword">new</span> Color(<span class="number">0.85f</span>, <span class="number">0.85f</span>, <span class="number">0.85f</span>);</span><br><span class="line">    <span class="keyword">private</span> Rect graphRect;</span><br><span class="line">    <span class="keyword">private</span> Vector2 drag;</span><br><span class="line">    <span class="keyword">private</span> Vector2 offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> zoom = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector2 dragStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> dragSpeed = <span class="number">0.1f</span>;</span><br><span class="line">  </span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;Tools/Draw&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PopUp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _window = GetWindow&lt;DrawGraphWindow&gt;(<span class="string">&quot;Draw&quot;</span>);</span><br><span class="line">        _window.minSize = <span class="keyword">new</span> Vector2(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">        _window.Show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetupSize();</span><br><span class="line">        ProcessEvents(Event.current);</span><br><span class="line">        DrawBackground();</span><br><span class="line">        DrawGrid(<span class="number">10</span> * zoom, <span class="number">0.2f</span>);</span><br><span class="line">        DrawGrid(<span class="number">50</span> * zoom, <span class="number">0.4f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetupSize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        graphRect = <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, position.width, position.height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ProcessEvents</span>(<span class="params">Event e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.type == EventType.MouseDown &amp;&amp; e.button == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dragStart = e.mousePosition;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.type == EventType.MouseDrag &amp;&amp; e.button == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            drag = e.mousePosition - dragStart;</span><br><span class="line">            dragStart = e.mousePosition;</span><br><span class="line">            GUI.changed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.type == EventType.ScrollWheel)</span><br><span class="line">        &#123;</span><br><span class="line">            zoom -= _zoonSpeed * e.delta.y;</span><br><span class="line">            zoom = Mathf.Clamp(zoom, _minZoom, _maxZoom);</span><br><span class="line">            e.Use();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawBackground</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorGUI.DrawRect(graphRect, bgColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawGrid</span>(<span class="params"><span class="built_in">float</span> gridSpacing, <span class="built_in">float</span> gridOpacity</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> widthDivs = Mathf.CeilToInt(position.width / gridSpacing);</span><br><span class="line">        <span class="built_in">int</span> heightDivs = Mathf.CeilToInt(position.height / gridSpacing);</span><br><span class="line">        Handles.BeginGUI();</span><br><span class="line">        Handles.color = <span class="keyword">new</span> Color(gridColor.r, gridColor.g, gridColor.b, gridOpacity);</span><br><span class="line">        offset += drag * dragSpeed;</span><br><span class="line">        Vector3 newOffset = <span class="keyword">new</span> Vector3(offset.x % gridSpacing, offset.y % gridSpacing, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; widthDivs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Handles.DrawLine(<span class="keyword">new</span> Vector3(gridSpacing * i, -gridSpacing, <span class="number">0</span>) + newOffset, <span class="keyword">new</span> Vector3(gridSpacing * i, position.height, <span class="number">0f</span>) + newOffset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; heightDivs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Handles.DrawLine(<span class="keyword">new</span> Vector3(-gridSpacing, gridSpacing * i, <span class="number">0</span>) + newOffset, <span class="keyword">new</span> Vector3(position.width, gridSpacing * i, <span class="number">0</span>) + newOffset);</span><br><span class="line">        &#125;</span><br><span class="line">        Handles.color = Color.white;</span><br><span class="line">        Handles.EndGUI();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下，按住鼠标右键可以拖拽，转动滚轮可以缩放</p><p><img src="/images/handles.png" class="lazyload" data-srcset="/images/handles.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="handles"></p><h2 id="插件">插件</h2><p>自己重写一份图节点编辑器是非常费劲的，比如要处理反射等信息</p><p>你可以尝试使用<a href="https://assetstore.unity.com/packages/tools/visual-scripting/flowcanvas-33903?srsltid=AfmBOoqc_Iq0xbXD0tvn76x3mpe9LCI7YCKi_Anm1gQrts_h0Yxs8vAi">FlowCanvas</a>、<a href="https://assetstore.unity.com/packages/tools/visual-scripting/xnode-104276">xNode</a>，或者ui toolkit</p><h2 id="参考">参考</h2><p><a href="https://github.com/XINCGer/UnityToolchainsTrick">UnityToolchainsTrick</a></p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE5 学习笔记</title>
      <link href="/engine/Note-of-UE/"/>
      <url>/engine/Note-of-UE/</url>
      
        <content type="html"><![CDATA[<h1>UE5 学习笔记</h1><h2 id="渲染图片">渲染图片</h2><p>使用UE5 Movie Remder Queue来渲染场景，出一些demo视频和图片</p><h2 id="Editor开发">Editor开发</h2><h3 id="扩展MenuBar">扩展MenuBar</h3><p><a href="https://www.youtube.com/watch?v=teL4APVRg7k">参考</a></p><h4 id="创建Editor-Module">创建Editor Module</h4><p>打开C++项目，创建一个Editor类型的UE Module</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FEdgeEditorModule</span> : <span class="keyword">public</span> IModuleInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartupModule</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShutdownModule</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddMenu</span><span class="params">(FMenuBarBuilder&amp; MenuBarBuilder)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FileMenu</span><span class="params">(FMenuBuilder&amp; MenuBuilder)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FEdgeEditorModule::StartupModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 在LevelEditor注册扩展</span></span><br><span class="line">    FLevelEditorModule&amp; LevelEditorModule = FModuleManager::<span class="built_in">LoadModuleChecked</span>&lt;FLevelEditorModule&gt;(<span class="string">&quot;LevelEditor&quot;</span>);</span><br><span class="line">    <span class="type">const</span> TSharedPtr&lt;FExtender&gt; MenuExtender = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FExtender</span>());</span><br><span class="line">    MenuExtender-&gt;<span class="built_in">AddMenuBarExtension</span>(<span class="string">&quot;Help&quot;</span>, EExtensionHook::After, <span class="literal">nullptr</span>, FMenuBarExtensionDelegate::<span class="built_in">CreateRaw</span>(<span class="keyword">this</span>, &amp;FEdgeEditorModule::AddMenu));</span><br><span class="line">    LevelEditorModule.<span class="built_in">GetMenuExtensibilityManager</span>()-&gt;<span class="built_in">AddExtender</span>(MenuExtender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FEdgeEditorModule::AddMenu</span><span class="params">(FMenuBarBuilder&amp; MenuBarBuilder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个下拉菜单</span></span><br><span class="line">    MenuBarBuilder.<span class="built_in">AddPullDownMenu</span>(FText::<span class="built_in">FromString</span>(<span class="string">&quot;Hard Edge&quot;</span>), FText::<span class="built_in">FromString</span>(<span class="string">&quot;Hard Edge Tools&quot;</span>), FNewMenuDelegate::<span class="built_in">CreateRaw</span>(<span class="keyword">this</span>, &amp;FEdgeEditorModule::FileMenu));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FEdgeEditorModule::FileMenu</span><span class="params">(FMenuBuilder&amp; MenuBuilder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 下拉菜单中添加一个选项，点击后会输出Log</span></span><br><span class="line">    MenuBuilder.<span class="built_in">AddMenuEntry</span>(FText::<span class="built_in">FromString</span>(<span class="string">&quot;A Tool&quot;</span>), FText::<span class="built_in">FromString</span>(<span class="string">&quot;A Tool Tooltip&quot;</span>), <span class="built_in">FSlateIcon</span>(), <span class="built_in">FUIAction</span>(FExecuteAction::<span class="built_in">CreateLambda</span>([]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogEdgeEditor, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;A Tool Clicked&quot;</span>));</span><br><span class="line">    &#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义Log">自定义Log</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在.h文件中定义</span></span><br><span class="line"><span class="built_in">DECLARE_LOG_CATEGORY_EXTERN</span>(LogEdgeEditor, All, All);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 .cpp文件中实现，注意不能重复实现</span></span><br><span class="line"><span class="built_in">DEFINE_LOG_CATEGORY</span>(LogEdgeEditor);</span><br></pre></td></tr></table></figure><h4 id="编辑菜单">编辑菜单</h4><p>输入控制台命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ToolMenus.Edit</span><br></pre></td></tr></table></figure><p>即可编辑菜单栏</p><h2 id="网络同步">网络同步</h2>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微调大模型</title>
      <link href="/ai/llama/"/>
      <url>/ai/llama/</url>
      
        <content type="html"><![CDATA[<h1>微调大模型</h1><h2 id="直接推理">直接推理</h2><h3 id="Llama3">Llama3</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> transformers</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">model_id = <span class="string">&quot;meta-llama/Meta-Llama-3.1-8B-Instruct&quot;</span></span><br><span class="line"></span><br><span class="line">pipeline = transformers.pipeline(</span><br><span class="line">    <span class="string">&quot;text-generation&quot;</span>,</span><br><span class="line">    model=model_id,</span><br><span class="line">    model_kwargs=&#123;<span class="string">&quot;torch_dtype&quot;</span>: torch.bfloat16&#125;,</span><br><span class="line">    device_map=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a pirate chatbot who always responds in pirate speak!&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Do you know Genshin Impact?&quot;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">outputs = pipeline(</span><br><span class="line">    messages,</span><br><span class="line">    max_new_tokens=<span class="number">256</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(outputs[<span class="number">0</span>][<span class="string">&quot;generated_text&quot;</span>][-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="Qwen2-5">Qwen2.5</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, AutoTokenizer</span><br><span class="line"></span><br><span class="line">model_name = <span class="string">&quot;Qwen/Qwen2.5-7B-Instruct&quot;</span></span><br><span class="line"></span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=torch.float16)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_name)</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;给我简单介绍一下大语言模型&quot;</span></span><br><span class="line">messages = [</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are Qwen, created by Alibaba Cloud. You are a helpful assistant.&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: prompt&#125;</span><br><span class="line">]</span><br><span class="line">text = tokenizer.apply_chat_template(</span><br><span class="line">    messages,</span><br><span class="line">    tokenize=<span class="literal">False</span>,</span><br><span class="line">    add_generation_prompt=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">model_inputs = tokenizer([text], return_tensors=<span class="string">&quot;pt&quot;</span>).to(model.device)</span><br><span class="line"></span><br><span class="line">generated_ids = model.generate(</span><br><span class="line">    **model_inputs,</span><br><span class="line">    max_new_tokens=<span class="number">512</span></span><br><span class="line">)</span><br><span class="line">generated_ids = [</span><br><span class="line">    output_ids[<span class="built_in">len</span>(input_ids):] <span class="keyword">for</span> input_ids, output_ids <span class="keyword">in</span> <span class="built_in">zip</span>(model_inputs.input_ids, generated_ids)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">response = tokenizer.batch_decode(generated_ids, skip_special_tokens=<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><h3 id="Qwen2-5-VL">Qwen2.5 VL</h3><p>使用Qwen2.5 VL识别一张图片</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> Qwen2_5_VLForConditionalGeneration, AutoProcessor</span><br><span class="line"><span class="keyword">from</span> qwen_vl_utils <span class="keyword">import</span> process_vision_info</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">model = Qwen2_5_VLForConditionalGeneration.from_pretrained(</span><br><span class="line">    <span class="string">&quot;Qwen/Qwen2.5-VL-7B-Instruct&quot;</span>, torch_dtype=<span class="string">&quot;auto&quot;</span>, device_map=<span class="string">&quot;auto&quot;</span></span><br><span class="line">)</span><br><span class="line">processor = AutoProcessor.from_pretrained(<span class="string">&quot;Qwen/Qwen2.5-VL-7B-Instruct&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入的图片进行resize, 图片尺寸越大占用的显存越多</span></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;assets/pgfjebp_4K_Albedo.jpg&#x27;</span>)</span><br><span class="line">MAX_SIZE = <span class="number">1280</span></span><br><span class="line">height, width = image.shape[:<span class="number">2</span>]</span><br><span class="line">scale_factor = <span class="built_in">min</span>(MAX_SIZE / width, MAX_SIZE / height)</span><br><span class="line">new_width = <span class="built_in">int</span>(width * scale_factor)</span><br><span class="line">new_height = <span class="built_in">int</span>(height * scale_factor)</span><br><span class="line">resized_image = cv2.resize(image, (new_width, new_height), interpolation=cv2.INTER_LINEAR)</span><br><span class="line">os.makedirs(<span class="string">&#x27;temp&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;temp/test.jpg&#x27;</span>, resized_image)</span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;image&quot;</span>,</span><br><span class="line">                <span class="string">&quot;image&quot;</span>: <span class="string">&quot;file://temp/test.jpg&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Determine which of the following type this image is: Normal map, Albedo map, Roughness map. Only response type&quot;</span>&#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preparation for inference</span></span><br><span class="line">text = processor.apply_chat_template(</span><br><span class="line">    messages, tokenize=<span class="literal">False</span>, add_generation_prompt=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">image_inputs, video_inputs = process_vision_info(messages)</span><br><span class="line">inputs = processor(</span><br><span class="line">    text=[text],</span><br><span class="line">    images=image_inputs,</span><br><span class="line">    videos=video_inputs,</span><br><span class="line">    padding=<span class="literal">True</span>,</span><br><span class="line">    return_tensors=<span class="string">&quot;pt&quot;</span>,</span><br><span class="line">)</span><br><span class="line">inputs = inputs.to(model.device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inference: Generation of the output</span></span><br><span class="line">generated_ids = model.generate(**inputs, max_new_tokens=<span class="number">128</span>)</span><br><span class="line">generated_ids_trimmed = [</span><br><span class="line">    out_ids[<span class="built_in">len</span>(in_ids) :] <span class="keyword">for</span> in_ids, out_ids <span class="keyword">in</span> <span class="built_in">zip</span>(inputs.input_ids, generated_ids)</span><br><span class="line">]</span><br><span class="line">output_text = processor.batch_decode(</span><br><span class="line">    generated_ids_trimmed, skip_special_tokens=<span class="literal">True</span>, clean_up_tokenization_spaces=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(output_text)</span><br></pre></td></tr></table></figure><h2 id="vllm部署">vllm部署</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vllm serve Qwen/Qwen2<span class="number">.5</span>-7B-Instruct --host <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> --port <span class="number">7861</span></span><br></pre></td></tr></table></figure><h3 id="openai-api">openai api</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">openai_api_key = <span class="string">&quot;EMPTY&quot;</span></span><br><span class="line">openai_api_base = <span class="string">&quot;xxx/v1&quot;</span></span><br><span class="line"></span><br><span class="line">client = OpenAI(</span><br><span class="line">    api_key=openai_api_key,</span><br><span class="line">    base_url=openai_api_base,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chat_response = client.chat.completions.create(</span><br><span class="line">    model=<span class="string">&quot;Qwen/Qwen2.5-7B-Instruct&quot;</span>,</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are Qwen, created by Alibaba Cloud. You are a helpful assistant.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Tell me something about large language models.&quot;</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">    temperature=<span class="number">0.7</span>,</span><br><span class="line">    top_p=<span class="number">0.8</span>,</span><br><span class="line">    max_tokens=<span class="number">512</span>,</span><br><span class="line">    extra_body=&#123;</span><br><span class="line">        <span class="string">&quot;repetition_penalty&quot;</span>: <span class="number">1.05</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    extra_headers=headers</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Chat response:&quot;</span>, chat_response)</span><br></pre></td></tr></table></figure><h2 id="SFT">SFT</h2><p>可以用于学习知识或能力</p><p>微调大模型有很多框架，Megatron很专业但门槛比较高，unsloth、LLaMA-Factory很玩具但比较适合新手</p><h3 id="unsloth">unsloth</h3><p>这是一个模型sft框架，用起来很方便，但免费版只能单机单卡</p><p>参考<a href="https://colab.research.google.com/github/unslothai/notebooks/blob/main/nb/Llama3.1_(8B)-Alpaca.ipynb">Llama3.1_(8B)</a></p><p>训练结束后会在outputs文件夹中会保存一个checkpoint</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> unsloth <span class="keyword">import</span> FastLanguageModel</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line"><span class="keyword">from</span> trl <span class="keyword">import</span> SFTTrainer</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> TrainingArguments</span><br><span class="line"><span class="keyword">from</span> unsloth <span class="keyword">import</span> is_bfloat16_supported</span><br><span class="line"></span><br><span class="line">model_id = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model, tokenizer = FastLanguageModel.from_pretrained(...)</span><br><span class="line"><span class="comment"># 转为PEFT模型，准备训练LoRA</span></span><br><span class="line">model = FastLanguageModel.get_peft_model(...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据集转为alpaca格式</span></span><br><span class="line">alpaca_prompt = <span class="string">&quot;&quot;&quot;...&quot;&quot;&quot;</span></span><br><span class="line">EOS_TOKEN = tokenizer.eos_token <span class="comment"># Must add EOS_TOKEN</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">formatting_prompts_func</span>(<span class="params">examples</span>):</span><br><span class="line">    instructions = examples[<span class="string">&quot;instruction&quot;</span>]</span><br><span class="line">    inputs       = examples[<span class="string">&quot;input&quot;</span>]</span><br><span class="line">    outputs      = examples[<span class="string">&quot;output&quot;</span>]</span><br><span class="line">    texts = []</span><br><span class="line">    <span class="keyword">for</span> instruction, <span class="built_in">input</span>, output <span class="keyword">in</span> <span class="built_in">zip</span>(instructions, inputs, outputs):</span><br><span class="line">        <span class="comment"># Must add EOS_TOKEN, otherwise your generation will go on forever!</span></span><br><span class="line">        text = alpaca_prompt.<span class="built_in">format</span>(instruction, <span class="built_in">input</span>, output) + EOS_TOKEN</span><br><span class="line">        texts.append(text)</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="string">&quot;text&quot;</span> : texts, &#125;</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">dataset = load_dataset(<span class="string">&quot;yahma/alpaca-cleaned&quot;</span>, split = <span class="string">&quot;train&quot;</span>)</span><br><span class="line"><span class="comment"># 处理数据集</span></span><br><span class="line">dataset = dataset.<span class="built_in">map</span>(formatting_prompts_func, batched = <span class="literal">True</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置训练参数</span></span><br><span class="line">training_args = TrainingArguments(</span><br><span class="line">    per_device_train_batch_size = <span class="number">2</span>,</span><br><span class="line">    gradient_accumulation_steps = <span class="number">4</span>,</span><br><span class="line">    warmup_steps = <span class="number">5</span>,</span><br><span class="line">    <span class="comment"># num_train_epochs = 1, # Set this for 1 full training run.</span></span><br><span class="line">    max_steps = <span class="number">60</span>,</span><br><span class="line">    learning_rate = <span class="number">2e-4</span>,</span><br><span class="line">    fp16 = <span class="keyword">not</span> is_bfloat16_supported(),</span><br><span class="line">    bf16 = is_bfloat16_supported(),</span><br><span class="line">    logging_steps = <span class="number">1</span>,</span><br><span class="line">    optim = <span class="string">&quot;adamw_8bit&quot;</span>,</span><br><span class="line">    weight_decay = <span class="number">0.01</span>,</span><br><span class="line">    lr_scheduler_type = <span class="string">&quot;linear&quot;</span>,</span><br><span class="line">    seed = <span class="number">3407</span>,</span><br><span class="line">    output_dir = <span class="string">&quot;outputs&quot;</span>,</span><br><span class="line">    report_to = <span class="string">&quot;none&quot;</span>, <span class="comment"># Use this for WandB etc</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">trainer = SFTTrainer(</span><br><span class="line">    model = model,</span><br><span class="line">    tokenizer = tokenizer,</span><br><span class="line">    train_dataset = dataset,</span><br><span class="line">    dataset_text_field = <span class="string">&quot;text&quot;</span>,</span><br><span class="line">    max_seq_length = max_seq_length,</span><br><span class="line">    dataset_num_proc = <span class="number">2</span>,</span><br><span class="line">    packing = <span class="literal">False</span>, <span class="comment"># Can make training 5x faster for short sequences.</span></span><br><span class="line">    args = training_args,</span><br><span class="line">)</span><br><span class="line">trainer_stats = trainer.train()</span><br><span class="line"><span class="comment"># 保存LoRA</span></span><br><span class="line">model.save_pretrained(<span class="string">&quot;lora_model&quot;</span>) </span><br><span class="line">tokenizer.save_pretrained(<span class="string">&quot;lora_model&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="测试checkpoint">测试checkpoint</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用本地模型</span></span><br><span class="line">model_id = <span class="string">&quot;outputs/checkpoint-60&quot;</span></span><br><span class="line"></span><br><span class="line">pipeline = transformers.pipeline(</span><br><span class="line">    <span class="string">&quot;text-generation&quot;</span>,</span><br><span class="line">    model=model_id,</span><br><span class="line">    model_kwargs=&#123;<span class="string">&quot;torch_dtype&quot;</span>: torch.bfloat16&#125;,</span><br><span class="line">    device_map=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Give three tips for staying healthy&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Do you know Genshin Impact?&quot;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">outputs = pipeline(</span><br><span class="line">    messages,</span><br><span class="line">    max_new_tokens=<span class="number">256</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(outputs[<span class="number">0</span>][<span class="string">&quot;generated_text&quot;</span>][-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>输出结果中很显然背了了很多医学知识</p><h3 id="LLaMA-Factory">LLaMA-Factory</h3><p>一个开源LLM sft框架，可以实现多机多卡，但感觉跟unsloth比更玩具了</p><h4 id="安装">安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/hiyouga/LLaMA-Factory.git</span><br><span class="line"><span class="built_in">cd</span> LLaMA-Factory</span><br><span class="line">pip install -e <span class="string">&quot;.[torch,metrics]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">llamafactory-cli version</span><br></pre></td></tr></table></figure><h4 id="sft">sft</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">accelerate launch --config_file deepspeed.config src/train.py llm_config.yaml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deepspeed.config</span></span><br><span class="line"><span class="attr">compute_environment:</span> <span class="string">LOCAL_MACHINE</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">deepspeed_config:</span></span><br><span class="line">    <span class="attr">deepspeed_multinode_launcher:</span> <span class="string">standard</span></span><br><span class="line">    <span class="attr">gradient_accumulation_steps:</span> <span class="number">8</span></span><br><span class="line">    <span class="attr">offload_optimizer_device:</span> <span class="string">none</span></span><br><span class="line">    <span class="attr">offload_param_device:</span> <span class="string">none</span></span><br><span class="line">    <span class="attr">zero3_init_flag:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">zero_stage:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">distributed_type:</span> <span class="string">DEEPSPEED</span></span><br><span class="line"><span class="attr">downcast_bf16:</span> <span class="string">&#x27;no&#x27;</span></span><br><span class="line"><span class="attr">enable_cpu_affinity:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">machine_rank:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">main_process_ip:</span> <span class="string">&#x27;100.96.220.190&#x27;</span></span><br><span class="line"><span class="attr">main_process_port:</span> <span class="number">29500</span></span><br><span class="line"><span class="attr">main_training_function:</span> <span class="string">main</span></span><br><span class="line"><span class="attr">mixed_precision:</span> <span class="string">fp16</span></span><br><span class="line"><span class="attr">num_machines:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">num_processes:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">rdzv_backend:</span> <span class="string">static</span></span><br><span class="line"><span class="attr">same_network:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">tpu_env:</span> []</span><br><span class="line"><span class="attr">tpu_use_cluster:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">tpu_use_sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">use_cpu:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># llm_config.yaml</span></span><br><span class="line"><span class="attr">model_name_or_path:</span> <span class="string">Qwen/Qwen2.5-7B-Instruct</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stage:</span> <span class="string">sft</span></span><br><span class="line"><span class="attr">do_train:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">finetuning_type:</span> <span class="string">lora</span></span><br><span class="line"><span class="attr">lora_target:</span> <span class="string">all</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dataset:</span> <span class="string">alpaca_zh_demo</span></span><br><span class="line"><span class="attr">template:</span> <span class="string">qwen</span></span><br><span class="line"><span class="attr">cutoff_len:</span> <span class="number">1024</span></span><br><span class="line"><span class="attr">max_samples:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">overwrite_cache:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">preprocessing_num_workers:</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output_dir:</span> <span class="string">saves/qwen-8b/lora/sft</span></span><br><span class="line"><span class="attr">logging_steps:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">save_steps:</span> <span class="number">500</span></span><br><span class="line"><span class="attr">plot_loss:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">overwrite_output_dir:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">per_device_train_batch_size:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">gradient_accumulation_steps:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">learning_rate:</span> <span class="number">1.0e-4</span></span><br><span class="line"><span class="attr">num_train_epochs:</span> <span class="number">3.0</span></span><br><span class="line"><span class="attr">lr_scheduler_type:</span> <span class="string">cosine</span></span><br><span class="line"><span class="attr">warmup_ratio:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">bf16:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ddp_timeout:</span> <span class="number">180000000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">val_size:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">per_device_eval_batch_size:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">eval_strategy:</span> <span class="string">steps</span></span><br><span class="line"><span class="attr">eval_steps:</span> <span class="number">500</span></span><br></pre></td></tr></table></figure><h2 id="Reasoning">Reasoning</h2><p>deepseek爆火后最流行的模型结构，可以长思维链思考，用RL训练</p><h3 id="unsloth-2">unsloth</h3><p>unsloth提供了一种基于GRPO的训练方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> unsloth <span class="keyword">import</span> FastLanguageModel, PatchFastRL, is_bfloat16_supported</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset, Dataset</span><br><span class="line"><span class="keyword">from</span> trl <span class="keyword">import</span> GRPOConfig, GRPOTrainer</span><br><span class="line"><span class="comment"># 修改FastLanguageModel，使其支持GRPO</span></span><br><span class="line">PatchFastRL(<span class="string">&quot;GRPO&quot;</span>, FastLanguageModel)</span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model, tokenizer = FastLanguageModel.from_pretrained(...)</span><br><span class="line"><span class="comment"># 转为PEFT来训LoRA</span></span><br><span class="line">model = FastLanguageModel.get_peft_model(...)</span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">dataset = get_gsm8k_questions()</span><br><span class="line"><span class="comment"># 训练配置</span></span><br><span class="line">training_args = GRPOConfig(</span><br><span class="line">    use_vllm = <span class="literal">True</span>, <span class="comment"># use vLLM for fast inference!</span></span><br><span class="line">    learning_rate = <span class="number">5e-6</span>,</span><br><span class="line">    adam_beta1 = <span class="number">0.9</span>,</span><br><span class="line">    adam_beta2 = <span class="number">0.99</span>,</span><br><span class="line">    weight_decay = <span class="number">0.1</span>,</span><br><span class="line">    warmup_ratio = <span class="number">0.1</span>,</span><br><span class="line">    lr_scheduler_type = <span class="string">&quot;cosine&quot;</span>,</span><br><span class="line">    optim = <span class="string">&quot;adamw_8bit&quot;</span>,</span><br><span class="line">    logging_steps = <span class="number">1</span>,</span><br><span class="line">    bf16 = is_bfloat16_supported(),</span><br><span class="line">    fp16 = <span class="keyword">not</span> is_bfloat16_supported(),</span><br><span class="line">    per_device_train_batch_size = <span class="number">1</span>,</span><br><span class="line">    gradient_accumulation_steps = <span class="number">1</span>, <span class="comment"># Increase to 4 for smoother training</span></span><br><span class="line">    num_generations = <span class="number">8</span>, <span class="comment"># Decrease if out of memory</span></span><br><span class="line">    max_prompt_length = <span class="number">256</span>,</span><br><span class="line">    max_completion_length = <span class="number">200</span>,</span><br><span class="line">    <span class="comment"># num_train_epochs = 1, # Set to 1 for a full training run</span></span><br><span class="line">    max_steps = <span class="number">250</span>,</span><br><span class="line">    save_steps = <span class="number">250</span>,</span><br><span class="line">    max_grad_norm = <span class="number">0.1</span>,</span><br><span class="line">    report_to = <span class="string">&quot;tensorboard&quot;</span>, <span class="comment"># Can use Weights &amp; Biases</span></span><br><span class="line">    output_dir = <span class="string">&quot;outputs&quot;</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 训练，reward_funcs是RL的奖励函数，这里是与text结构有关</span></span><br><span class="line">trainer = GRPOTrainer(</span><br><span class="line">    model = model,</span><br><span class="line">    processing_class = tokenizer,</span><br><span class="line">    reward_funcs = [</span><br><span class="line">        xmlcount_reward_func,</span><br><span class="line">        soft_format_reward_func,</span><br><span class="line">        strict_format_reward_func,</span><br><span class="line">        int_reward_func,</span><br><span class="line">        correctness_reward_func,</span><br><span class="line">    ],</span><br><span class="line">    args = training_args,</span><br><span class="line">    train_dataset = dataset</span><br><span class="line">)</span><br><span class="line">trainer.train()</span><br><span class="line"><span class="comment"># 保存LoRA</span></span><br><span class="line">model.save_lora(<span class="string">&quot;grpo_saved_lora&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="测试LoRA">测试LoRA</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> LoraConfig</span><br><span class="line"></span><br><span class="line">model_name = <span class="string">&quot;Qwen/Qwen2.5-3B-Instruct&quot;</span></span><br><span class="line"></span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=torch.float16)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_name)</span><br><span class="line"></span><br><span class="line">lora_config = LoraConfig(</span><br><span class="line">    r=<span class="number">64</span>,</span><br><span class="line">    target_modules=[<span class="string">&quot;q_proj&quot;</span>, <span class="string">&quot;k_proj&quot;</span>, <span class="string">&quot;v_proj&quot;</span>, <span class="string">&quot;o_proj&quot;</span>, <span class="string">&quot;gate_proj&quot;</span>, <span class="string">&quot;up_proj&quot;</span>, <span class="string">&quot;down_proj&quot;</span>],</span><br><span class="line">    lora_alpha=<span class="number">64</span></span><br><span class="line">)</span><br><span class="line">model.add_adapter(lora_config, adapter_name=<span class="string">&quot;grpo_saved_lora&quot;</span>)</span><br><span class="line"></span><br><span class="line">SYSTEM_PROMPT = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Respond in the following format:</span></span><br><span class="line"><span class="string">&lt;reasoning&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&lt;/reasoning&gt;</span></span><br><span class="line"><span class="string">&lt;answer&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&lt;/answer&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;How many r&#x27;s are in strawberry?&quot;</span></span><br><span class="line">messages = [</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: SYSTEM_PROMPT&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: prompt&#125;</span><br><span class="line">]</span><br><span class="line">text = tokenizer.apply_chat_template(</span><br><span class="line">    messages,</span><br><span class="line">    tokenize=<span class="literal">False</span>,</span><br><span class="line">    add_generation_prompt=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">model_inputs = tokenizer([text], return_tensors=<span class="string">&quot;pt&quot;</span>).to(model.device)</span><br><span class="line"></span><br><span class="line">generated_ids = model.generate(</span><br><span class="line">    **model_inputs,</span><br><span class="line">    max_new_tokens=<span class="number">512</span></span><br><span class="line">)</span><br><span class="line">generated_ids = [</span><br><span class="line">    output_ids[<span class="built_in">len</span>(input_ids):] <span class="keyword">for</span> input_ids, output_ids <span class="keyword">in</span> <span class="built_in">zip</span>(model_inputs.input_ids, generated_ids)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">response = tokenizer.batch_decode(generated_ids, skip_special_tokens=<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> LLM </tag>
            
            <tag> Llama </tag>
            
            <tag> Qwen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL 深度学习环境搭建</title>
      <link href="/ai/WSL/"/>
      <url>/ai/WSL/</url>
      
        <content type="html"><![CDATA[<h1>WSL 深度学习环境搭建</h1><blockquote><p>Win11，N卡</p></blockquote><p>很多人只有一台Windows电脑，装双系统很麻烦，尤其是一个有N卡驱动的Linux，而WSL2环境搭建非常方便</p><blockquote><p>之前有写过一篇Linux入门，但是内容记的太杂了，这里精简一下</p></blockquote><h2 id="安装WSL2">安装WSL2</h2><p>在Windows Terminal（如果没有，去微软的store中下载）中输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure><p>默认会安装一个最新的Ubuntu</p><h2 id="安装GCC-11">安装GCC 11</h2><blockquote><p>主要是为了对应cuda版本</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gcc-11 g++-11</span><br></pre></td></tr></table></figure><p>设置gcc版本优先级（自动模式）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 9</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 9</span><br></pre></td></tr></table></figure><p>设置gcc版本（手动模式）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --set gcc /usr/bin/gcc-11</span><br></pre></td></tr></table></figure><p>更新并保存环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/bin:$PATH</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>测试gcc</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><p>如果没成功，试着重启wsl</p><p>查看已安装的gcc版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update-alternatives --display gcc</span><br></pre></td></tr></table></figure><h2 id="安装CUDA-11-8">安装CUDA 11.8</h2><blockquote><p>这个方法需要能访问外网，这里安装的是CUDA 11.8，需要其他版本可以在<a href="https://developer.nvidia.com/cuda-11-8-0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-Ubuntu&amp;target_version=2.0&amp;target_type=runfile_local">英伟达官网</a>找</p></blockquote><p>寻找一个空间较大的目录（主要是怕你乱放），输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_520.61.05_linux.run</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh cuda_11.8.0_520.61.05_linux.run</span><br></pre></td></tr></table></figure><p>输入accept和按install后，会弹出提示，按照提示配置环境变量</p><blockquote><p>如果配置不上，你可以每次启动时都<code>ctrl+R</code>搜索这个export命令，每次都配置一次nvcc</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/cuda-11.8/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-11.8/lib64:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><h2 id="安装Anaconda">安装Anaconda</h2><p><a href="https://repo.anaconda.com/archive/">官网下载</a></p><p>安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-2024.10-1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>安装时会询问保存路径，默认在用户目录，由于这个非常占空间，建议选一个空间大的地方</p><p>激活</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> &lt;you anaconda path&gt;/bin/activate</span><br><span class="line"><span class="comment"># source ~/anaconda3/bin/activate</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda init</span><br></pre></td></tr></table></figure><h3 id="持久化">持久化</h3><p>修改<code>.bashrc</code>，添加下面内容，启动bash时就自动激活conda了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__conda_setup=<span class="string">&quot;<span class="subst">$(&#x27;/home/your_username/anaconda3/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">&quot;<span class="variable">$__conda_setup</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&quot;/home/your_username/anaconda3/etc/profile.d/conda.sh&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">&quot;/home/your_username/anaconda3/etc/profile.d/conda.sh&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">export</span> PATH=<span class="string">&quot;/home/your_username/anaconda3/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __conda_setup</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda-11.8/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h2 id="node-js">node.js</h2><p>很多ui demo要用node.js搭建</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看node.js版本</span></span><br><span class="line">node -v</span><br><span class="line"><span class="comment"># 查看nvm版本</span></span><br><span class="line">nvm --version</span><br><span class="line"><span class="comment"># 安装node.js 指定版本</span></span><br><span class="line">nvm install 24</span><br><span class="line"><span class="comment"># 设置默认node.js</span></span><br><span class="line">nvm use 24</span><br><span class="line">nvm <span class="built_in">alias</span> default 24</span><br><span class="line"><span class="comment"># 查看已经安装了哪些node.js</span></span><br><span class="line">nvm list</span><br></pre></td></tr></table></figure><h2 id="访问WSL端口">访问WSL端口</h2><blockquote><p>在wsl中搭建web服务，在windows中访问，不需要做什么代理映射，非常方便</p></blockquote><p>在wsl中输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname -I</span><br></pre></td></tr></table></figure><p>即可得到WSL的IP地址</p><h3 id="Gradio">Gradio</h3><p>编写一个Gradio demo，并架设在wsl的localhost:7861</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> gr.Blocks() <span class="keyword">as</span> demo:</span><br><span class="line">    gr.Markdown(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    demo.launch(server_name=<span class="string">&#x27;0.0.0.0&#x27;</span>, server_port=<span class="number">7861</span>)</span><br></pre></td></tr></table></figure><p>假设<code>hostname -I</code>获得的IP地址是<code>172.23.105.49</code></p><p>在Windows浏览器中访问地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">172.23</span><span class="number">.105</span><span class="number">.49</span>:<span class="number">7861</span></span><br></pre></td></tr></table></figure><p>发现成功打开Gradio demo</p><h2 id="安装Pytorch">安装Pytorch</h2><p>创建一个conda环境（<code>sd</code>是环境的名称）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda create -n sd python=<span class="number">3.10</span> pip</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda activate sd</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118</span><br></pre></td></tr></table></figure><h2 id="设置huggingface">设置huggingface</h2><blockquote><p>用学校邮箱注册huggingface审批更快，申请大模型时最好不要选择China，有可能被拒绝，可以选新加坡</p></blockquote><p>很多AI模型都架设在<a href="https://huggingface.co">huggingface</a>中，hf默认会把cache存储在<code>~/.cache</code>下，考虑到模型都非常巨大，一般都会放在其他地方</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">export HF_HOME=/data/hf</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>在第一次使用hf时，需要先登陆，你需要在hf网站中获得一个Access Tokens，并在python中执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> huggingface_hub <span class="keyword">import</span> login</span><br><span class="line"></span><br><span class="line">login(token=<span class="string">&quot;hf_xxxx&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="SD3-5画图">SD3.5画图</h2><p>尝试一下SD3.5画图，这是一个8B大模型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install -U diffusers</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> StableDiffusion3Pipeline</span><br><span class="line"></span><br><span class="line">pipe = StableDiffusion3Pipeline.from_pretrained(<span class="string">&quot;stabilityai/stable-diffusion-3.5-large&quot;</span>, torch_dtype=torch.bfloat16)</span><br><span class="line">pipe = pipe.to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line">image = pipe(</span><br><span class="line">    <span class="string">&quot;A capybara holding a sign that reads Hello World&quot;</span>,</span><br><span class="line">    num_inference_steps=<span class="number">28</span>,</span><br><span class="line">    guidance_scale=<span class="number">3.5</span>,</span><br><span class="line">).images[<span class="number">0</span>]</span><br><span class="line">image.save(<span class="string">&quot;capybara.png&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity 动画</title>
      <link href="/engine/Unity%E5%8A%A8%E7%94%BB/"/>
      <url>/engine/Unity%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h1>Unity 动画</h1><blockquote><p>整理一下先前做动画的收获</p></blockquote><h2 id="骨骼动画">骨骼动画</h2><ul><li>序列帧动画：记录动作的每一帧<ul><li>非矢量动画：每一帧是固定不可复用的，新的一帧本质上是完全重画一次物体，没有发生形态上的改变</li></ul></li><li>关键帧动画：记录动作的始末和轨迹曲线，运行时根据曲线进行插值（很显然，这是一种矢量动画）<ul><li>每个关键帧被称为姿势</li></ul></li></ul><h3 id="顶点动画">顶点动画</h3><p>骨骼动画的本质是顶点动画</p><ul><li>刚体动画：在渲染中网格不发生改变，刚体的变化矩阵发生改变</li><li>顶点动画：在渲染中网格顶点发生了直接的变化（位移旋转缩放）<ul><li>骨骼动画：一种对顶点动画的压缩算法</li><li>流体动画</li><li>粒子动画</li><li>变形动画：常用于制作表情，捏脸</li></ul></li></ul><p>根据顶点动画的实现方式，分为CPU和GPU</p><table><thead><tr><th></th><th>CPU动画</th><th>GPU动画</th></tr></thead><tbody><tr><td>顶点位置改变时机</td><td>CPU应用阶段</td><td>GPU几何阶段</td></tr><tr><td>数据流</td><td>CPU传递给GPU的顶点数组发生改变</td><td>顶点着色器输出发生改变</td></tr></tbody></table><h3 id="骨骼动画-2">骨骼动画</h3><p>骨骼动画的模型整体不是刚体，同时为了避免旋转、移动时发生断裂，也不能将物体拆分为多个小刚体，因此只能选择顶点动画。</p><p>然而顶点动画带来的顶点移动，如果全部交由vertex着色器处理，过于昂贵，实时渲染不可接受</p><p>而且骨骼动画的顶点受更高层次的骨骼节点控制</p><ul><li>同一根骨骼的顶点要保持相对位置不变</li><li>骨骼间顶点要进行平滑</li><li>顶点的大体形状受骨骼形状制约，顶点变化时要保持和骨骼的联系</li></ul><h4 id="实现">实现</h4><p>矩阵调色板蒙皮技术（Matrix Palette Skinning）：</p><ul><li>骨骼为近似刚体，其变化矩阵按顺序存储在数组中（我们称这个数组为骨骼）</li><li>顶点缓冲中会存储其骨骼ID和权重信息（一个顶点通常会受1～4个骨骼影响，可以用两个Vector存储）</li><li>进行变化时，顶点可以根据骨骼ID和权重查询变化矩阵，并通过插值的方式实现顶点动画（我们称查询矩阵为蒙皮）</li><li>CPU通过姿势间插值，以获得每一帧骨骼的位置及矩阵，GPU根据顶点信息查询矩阵进而实现运动</li></ul><h3 id="坐标系">坐标系</h3><p><img src="/images/%E5%9D%90%E6%A0%87%E7%B3%BB.png" class="lazyload" data-srcset="/images/%E5%9D%90%E6%A0%87%E7%B3%BB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><h4 id="骨骼树">骨骼树</h4><p>三维骨骼本质上是一系列Bone组成的树状结构</p><p>在骨骼动画中，我们更关心骨骼的相对位置，于是我们选择本地坐标系（A物体的本地坐标就是以A物体中心为原点，相对于中心的偏移），并让坐标系层次嵌套</p><blockquote><p>比如大臂移动时也会带动小臂移动，我们就把小臂的本地坐标系定义在大臂的本地坐标系之下，我们称大臂是小臂的父物体，小臂是大臂的子物体。而小臂在大臂的本地坐标系的坐标被称为局部坐标系（可以参考Unity的GO组织）</p></blockquote><p>顺着嵌套关系向根部搜索，就可以获得物体的世界坐标系</p><p>下图为树节点的数据结构</p><p><img src="/images/%E7%A9%BA%E9%97%B4%E6%A0%91%E8%8A%82%E7%82%B9.png" class="lazyload" data-srcset="/images/%E7%A9%BA%E9%97%B4%E6%A0%91%E8%8A%82%E7%82%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><ul><li>本地坐标系就是object space transform</li></ul><p>在播放动画时，会从空间树的根节点（一般为盆骨节点或者root节点）开始向下递归变化，以保证父物体的local transform总是先于子物体刷新</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//对关键帧进行插值 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OnAnimated</span>(<span class="params">CoordinateTreeNode Key0, CoordinateTreeNode Key1, <span class="built_in">float</span> t</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    Position = Vector3.Lerp(Key0.Position, Key1.Position, t); </span><br><span class="line">    Rotation = Quaternion.Lerp(Key0.Rotation, Key2.Rotation, t); </span><br><span class="line">    Scale = Vector3.Lerp(Key0.Scale, Key1.Scale, t); </span><br><span class="line">    </span><br><span class="line">    localTransform = <span class="keyword">new</span> TransformMatrix(Position, Rotation, Scale); </span><br><span class="line">    combinedTransform = parent.localTransform * <span class="keyword">this</span>.localTransform; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="骨骼">骨骼</h4><ul><li>盆骨：选盆骨作为根节点（或者是空根节点的第一也是唯一的子节点），是因为盆骨在运动时相对匀速，且位置居中，可以避免骨骼树过深</li><li>脊椎骨：模拟躯干运动，一般有2～3块</li><li>捻度骨骼：Twist Bone，生物学中像小臂这类骨骼不是一块骨骼，而是两条并排的骨骼，以此实现肘关节不动而手掌可以旋转</li></ul><p><img src="/images/%E4%BA%BA%E4%BD%93%E9%AA%A8%E9%AA%BC.png" class="lazyload" data-srcset="/images/%E4%BA%BA%E4%BD%93%E9%AA%A8%E9%AA%BC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><h4 id="坐标变化">坐标变化</h4><ul><li>位移矩阵</li><li>缩放矩阵</li><li>旋转矩阵</li><li>齐次坐标</li><li>仿射变换：缩放–旋转–平移</li><li>列矩阵左乘</li><li>手性变换：只需要对所有的矩阵任选一维进行取反即可（哪个维度不重要，只要统一即可）</li></ul><h3 id="旋转">旋转</h3><p>骨骼动画是矢量动画，是关键帧动画，因此会用到大量的插值，这决定了旋转的表达<strong>必须便于插值</strong></p><p>三维空间中的点可以由三个正交向量插值表示，根据嵌套关系，一个物体发生旋转，其实就是其基向量相对于父节点基向量发生改变</p><h4 id="双向量法">双向量法</h4><p>既然旋转可以由基向量的朝向表示，那么我们就直接基向量表示旋转吧！</p><p>正好三个基向量正交，而且对长度不敏感，那么我们还可以将三个向量压缩为两个向量</p><p>更进一步，这些向量都在球面上，那么用球坐标系替代直角坐标系</p><p>问题：</p><ul><li>需要时刻保证两个向量垂直</li><li>不好插值</li></ul><h4 id="欧拉角">欧拉角</h4><p>在航空业应用广泛，本质是一种过程量，描述了从初始位置沿着xyz轴旋转指定角度的过程，使用时需要明确旋转顺序（即顺规）</p><table><thead><tr><th></th><th>直角坐标系</th><th>欧拉角</th></tr></thead><tbody><tr><td>前进方向</td><td>Z</td><td>Roll 桶滚角</td></tr><tr><td>上方向</td><td>Y</td><td>Yaw 偏航角</td></tr><tr><td>右方向</td><td>X</td><td>Pitch 俯仰角</td></tr></tbody></table><p>问题：</p><ul><li>没有统一标准，而欧拉角强依赖于顺规</li><li>某些情况下会有两个轴平行，以至于失去一个自由度，导致万向节死锁</li><li>不能线性插值</li></ul><h4 id="轴角与四元数">轴角与四元数</h4><p>轴角（x, y, z, w）指沿着轴（x, y, z）旋转w度，也可以压缩为三维向量（wx’, wy’, wz’），轴角可以通过对轴向量和旋转角度分别插值对方法进行插值</p><p>四元数是一种超复数，可以用来表示旋转</p><p><a href="https://www.bilibili.com/video/BV1SW411y7W1">四元数的可视化_哔哩哔哩_bilibili</a></p><h3 id="蒙皮解算">蒙皮解算</h3><p>Mesh中的顶点缓存中会存储骨架、骨骼索引，骨骼权重，运行时在顶点函数进行位置的偏移，效果表现为Mesh跟着骨架一起运动，而且在边缘处会进行变形（效果与权重分配有关），就像皮肤蒙在骨骼上一样，这个过程被称为蒙皮结算</p><p><img src="/images/Mesh.png" class="lazyload" data-srcset="/images/Mesh.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Mesh"></p><h3 id="Motion-Matching">Motion Matching</h3><p>游戏中不止使用一个动画，于是动画系统不仅需要播放动画，还需要管理动画。最常见的管理方式是数据驱动，实现形式为图状态机，通过一些bool、float、trigger数据控制动画状态</p><p>但随着角色3C不断复杂，动画系统也越发复杂，状态机里塞进了海量动画节点，他们的状态难以维护，为此育碧提出了Motion Matching</p><p>MM通过角色当前的姿势（Pose Channel）和行动轨迹（Trajectory Channel）在动画数据库中进行匹配，自动设置当前动画状态</p><ul><li><p>Trajectory Channel通常是一个二维平面，通过人物移动速度，绘制一个移动轨迹，主要作用是跑步时转向会侧倾</p></li><li><p>Pose Channel是使用角色骨骼的几个节点，通常是两个脚的节点（当然你可以使用更多的节点，但随着节点数量的提升，匹配速度会更慢），主要作用是脚着地、手抓墙</p></li></ul><h2 id="骨骼动画播放">骨骼动画播放</h2><h3 id="Unity-Playable-Script-动画播放">Unity Playable Script 动画播放</h3><p>当我们在使用Unity Animator时，会发现我们必须要先将所需的动画片段放入Animation Controller中才能播放。如果我们想要一个Resources目录下的某个Clip，是做不到的</p><p>当游戏动画逻辑非常复杂时，状态机会非常复杂，几乎不可维护，于是很多公司会自己用Playable Script重写一份动画播放系统</p><p>Playable Script仍然是驱动Animator和Avatar的，所以角色身上仍需要Animator组件</p><h4 id="直接播放一个动画片段">直接播放一个动画片段</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">PlayableGraph playableGraph;</span><br><span class="line">AnimationClip idleClip;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;       </span><br><span class="line">    playableGraph = PlayableGraph.Create();</span><br><span class="line">    playableGraph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(xxx)</span><br><span class="line">    &#123;</span><br><span class="line">        AnimationPlayableUtilities.PlayClip(GetComponent&lt;Animator&gt;(), idleClip, <span class="keyword">out</span> playableGraph);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    playableGraph.Destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等效于</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> output = AnimationPlayableOutput.Create(playableGraph, <span class="string">&quot;AnimationOutput&quot;</span>, GetComponent&lt;Animator&gt;());</span><br><span class="line"><span class="keyword">var</span> clip = AnimationClipPlayable.Create(playableGraph, idleClip);</span><br><span class="line">output.SetSourcePlayable(clip);</span><br><span class="line">playableGraph.Play();</span><br></pre></td></tr></table></figure><h3 id="自行解算Humanoid">自行解算Humanoid</h3><p>对于一个Humanoid骨骼的模型，我们可以直接遍历获得骨骼的Transform，对其进行修改</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Animator animator; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历Humanoid所有的骨骼</span></span><br><span class="line"><span class="keyword">foreach</span> (HumanBodyBones bone <span class="keyword">in</span> System.Enum.GetValues(<span class="keyword">typeof</span>(HumanBodyBones)))</span><br><span class="line">&#123;</span><br><span class="line">    Transform boneTransform = anim.GetBoneTransform(bone);</span><br><span class="line">    <span class="comment">// 修改 boneTransform</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rig">Rig</h3><p>一种基于反向动力学的组件，可以覆盖动画，原理是为一个骨骼点绑定其几个父节点，并刷上相关权重，当骨骼点因为外力移动时，父节点会跟着一起运动，从而使得整体动画协调</p><p>常用于武器运动时手跟着一起动、脚着地时腿跟着一起动、头看向临近的人</p><p><a href="https://reubensun.com/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/?keyword=rig#11-%E7%9E%84%E5%87%86%E5%B0%84%E5%87%BB">参考</a></p><h2 id="Blendshape动画">Blendshape动画</h2><p>blendshape常用于实现表情动画、形变动画，相较于骨骼动画，十分昂贵</p><p>blendshape本质是在两个（或多个）顶点数量相同但位置不同的两个网格间插值出新网格</p><p>一个Mesh会有多个blendshape channel，每个channel都存了原始的mesh顶点buffer信息（主要是位置和法线），和目标mesh的顶点buffer信息，在解算时在两个mesh间线性插值。当有多个channel时，会按顺序依次插值</p><p>我们常用IClone和CC4制作bs模型</p><h3 id="Unity播放bs">Unity播放bs</h3><p>一个拥有bs channel的模型导入unity，会在SkinMeshRenderer上看到bs channel，直接修改这些channel就能实现动画播放</p><h2 id="物理动画">物理动画</h2><p>大部分物理动画是通过解算一些物理观测点，再将这些点映射回（骨骼）动画中</p><h3 id="Unity-Magica-Cloth">Unity Magica Cloth</h3><blockquote><p><a href="https://www.youtube.com/watch?v=mh5zgxSjIhE">使用 Unity Magica Cloth插件一站式解决头发、衣服和胸部的物理模拟</a></p></blockquote><p><a href="https://assetstore.unity.com/packages/tools/physics/magica-cloth-160144">Magica Cloth</a>是Unity一个布料模拟插件，有两个版本，我使用的是基于Jobs的普通版本（2是基于DOTS的）</p><h4 id="1-添加预制体">1. 添加预制体</h4><p>在场景中拖入MagicaPhysicsManager.prefab</p><blockquote><p>位置在Assets/MagicaCloth/Res/Prefab</p></blockquote><h4 id="2-绘制骨架">2. 绘制骨架</h4><p>使用Animation Rigging绘制骨架，方便后续配置布料</p><blockquote><p>Animation Rigging – Bone Renderer Setup</p></blockquote><h4 id="3-添加Magcia-Bone-Cloth">3. 添加Magcia Bone Cloth</h4><blockquote><p>Create Others – Magica Cloth – Magica Bone Cloth</p></blockquote><ol><li>将布料的根节点拖到Root List中，通常会有多个根节点</li><li>店家Start Point Selection开始调整节点<ol><li>为节点刷颜色，红色只能旋转，绿色可以运动，根节点们都要为红色（你可以先点Fill将所以节点都设为绿色，然后切换到红色笔刷状态，按住鼠标左键在场景中将根节点都刷为红色）</li><li>完成后按End Point Selection保存</li></ol></li></ol><p><img src="/images/cloth.png" class="lazyload" data-srcset="/images/cloth.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cloth"></p><ol start="3"><li>调整参数（也可以直接选择Preset）</li><li>点击最下方的Create，完成创建</li></ol><h4 id="4-防穿模">4. 防穿模</h4><p>在模型骨架下创建Magica Collider</p><h3 id="Unity-Ragdoll-Animator">Unity Ragdoll Animator</h3><p>Ragdoll（布娃娃系统）是一种基于物理模拟角色动作的技术，通常是通过在角色关节和躯干上放置碰撞器和约束实现，可以参考动物派队、人类一败涂地的角色控制，该技术还常用于实现角色受击、尸体倒地等</p><p>我使用的是插件<a href="https://assetstore.unity.com/packages/tools/physics/ragdoll-animator-2-285638">Ragdoll Animator 2</a>，使用起来非常简单，而且可以做角色动画和物理的混合</p><h4 id="人物模型初始化">人物模型初始化</h4><ol><li>导入一个模型，将其Rig设为Humanoid</li><li>将模型拖入场景，添加组件Ragdoll Animator 2</li><li>点击Try Auto-Find Requied Bones，人形模型可以自动初始化</li></ol><p><img src="/images/ragdoll.png" class="lazyload" data-srcset="/images/ragdoll.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ragdoll"></p><h4 id="参数调整">参数调整</h4><ol><li>调整碰撞体的类型、大小（Construct–Colliders）</li><li>调整躯干重量、摆动范围（Construct–Physics）</li><li>调整肌肉力量、动画混合程度（Motion）</li><li>设置IK（在Extra–Utility–Kinematic Bone Selector）</li></ol><h2 id="动画压缩">动画压缩</h2><p>用ALU和效果换存储和带宽，动画有很多关键帧和插值函数组成，Unity Editor下可以对动画Clip进行采样，生成更简化的关键帧，在运行时通过插值还原回动画信息</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity URP卡通渲染</title>
      <link href="/graphics/%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93/"/>
      <url>/graphics/%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1>Unity URP卡通渲染包</h1><p>最近工作之余抄了一个卡渲，结果越做感觉越没意思，主要是缺少一些美术资源，于是先pending，在此先记录一下</p><h2 id="当前进度">当前进度</h2><p>代码已开源，<a href="https://github.com/Reuben-Sun/ToonURP">仓库地址</a></p><p><img src="/images/patuo.png" class="lazyload" data-srcset="/images/patuo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="patuo"></p><h2 id="设计理念">设计理念</h2><blockquote><p>高复用，易拓展，低侵入</p></blockquote><h3 id="我遇到了什么问题">我遇到了什么问题</h3><p>每次我要写Unity shader时，我都要不厌其烦地写</p><ol><li>Shader GUI、Properties</li><li>定义贴图和采样器，定义全局变量</li><li>维护CBuffer，尤其是SRP batcher</li><li>几乎一模一样的Vertex函数</li><li>大量贴图采样，参数初始化</li><li>照抄的渲染方程和灯光Loop</li></ol><p>我一直认为，大部分情况，都不应该写Shading Function，这些BRDF是渲染的基石，是必须要用有科学依据、有论文支撑、经过行业验证的方案，而每次都自行写渲染方程，很容易产生错误</p><p>此外为了实现材质的多光源，渲染方程中会有大量的灯光着色Loop，他们代码十分重复，如果直接展开在片源函数中，很容易漏维护（比如只更新了主方向光的代码，其他的都没管）</p><p>因此我认为，应当将渲染方程视为黑盒，用户在定义材质shader时只需要收集数据，传入方程</p><h3 id="高可复用">高可复用</h3><p>类似URP的<code>UniversalFragmentPBR</code>，我定义了一个<code>float4 ToonFragment(inputData, surfaceData, input.uv)</code>函数，用户只需要修改传入函数的参数</p><p>修改分为两个部分，材质修改和渲染修改</p><h4 id="新材质需求">新材质需求</h4><p>材质修改是通过<code>PreProcessMaterial</code>，对传入函数的<code>InputData</code>和<code>ToonSurfaceData</code>进行修改，<a href="https://github.com/Reuben-Sun/ToonURP/blob/109da12064f8865fac8d4f752d45e8bb8fc4c4ea/Shaders/ToonRock.shader#L147C70-L147C85">参考</a></p><p>在Standard的基础上，让石头顶部覆盖雪或草</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// Feature</span><br><span class="line"><span class="addition">+[Main(FeatureMode, _, off, off)] _FeatureGroup(&quot;Feature&quot;, float) = 0</span></span><br><span class="line"><span class="addition">+[KWEnum(FeatureMode, SnowRock, _SNOWROCK, GrassRock, _GRASSROCK)] _EnumFeatureMode (&quot;Feature&quot;, float) = 0</span></span><br><span class="line"><span class="addition">+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 0)] _CustomVector1 (&quot;Snow Color&quot;, Color) = (1,1,1,1)</span></span><br><span class="line"><span class="addition">+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 0)] _CustomFloat1 (&quot;Snow Line (World)&quot;, Float) = 0.5</span></span><br><span class="line"><span class="addition">+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 1)] _CustomVector2 (&quot;Grass Rock Color&quot;, Color) = (1,1,1,1)</span></span><br><span class="line"><span class="addition">+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 1)] _CustomFloat2 (&quot;Grass Scale&quot;, Range(0,1)) = 0.9</span></span><br><span class="line"><span class="addition">+[Tex(FeatureMode_GRASSROCK)] _CustomMap1(&quot;GrassMap&quot;, 2D) = &quot;white&quot; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma shader_feature_local _CELLSHADING _PBRSHADING _CUSTOMSHADING</span><br><span class="line"><span class="addition">+#pragma shader_feature_local _SNOWROCK _GRASSROCK</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+#define _SnowLine _CustomFloat1</span></span><br><span class="line"><span class="addition">+#define _SnowColor _CustomVector1</span></span><br><span class="line"><span class="addition">+#define _GrassScale _CustomFloat2</span></span><br><span class="line"><span class="addition">+#define _GrassColor _CustomVector2</span></span><br><span class="line"><span class="addition">+#define _GrassMap _CustomMap1</span></span><br><span class="line"></span><br><span class="line">void PreProcessMaterial(inout InputData inputData, inout ToonSurfaceData surfaceData, float2 uv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="addition">+    #if _SNOWROCK</span></span><br><span class="line"><span class="addition">+    float snowScale = saturate(inputData.positionWS.y - _SnowLine);</span></span><br><span class="line"><span class="addition">+    surfaceData.albedo = lerp(surfaceData.albedo, _SnowColor.rgb, snowScale);</span></span><br><span class="line"><span class="addition">+    #endif</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    #if _GRASSROCK</span></span><br><span class="line"><span class="addition">+    float3 grassColor = _GrassColor.rgb;</span></span><br><span class="line"><span class="addition">+    grassColor *= SAMPLE_TEXTURE2D(_GrassMap, sampler_CustomMap1, uv).rgb;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    float3 upVector = float3(0, 1, 0);</span></span><br><span class="line"><span class="addition">+    float NoU = dot(upVector, inputData.normalWS);</span></span><br><span class="line"><span class="addition">+    float grassScale = saturate(NoU - _GrassScale);</span></span><br><span class="line"><span class="addition">+    // surfaceData.albedo = lerp(surfaceData.albedo, grassColor, grassScale);</span></span><br><span class="line"><span class="addition">+    if(NoU &gt; _GrassScale)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        surfaceData.albedo = grassColor;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    #endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 CustomFragment(InputData inputData, ToonSurfaceData toonSurfaceData, AdditionInputData additionInput)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#include &quot;Packages/com.reubensun.toonurp/Shaders/ToonStandardForwardPass.hlsl&quot;</span><br></pre></td></tr></table></figure><h4 id="新着色需求">新着色需求</h4><p>渲染修改是着色后对diffuse、specular进行一次modify，<a href="https://github.com/Reuben-Sun/ToonURP/blob/109da12064f8865fac8d4f752d45e8bb8fc4c4ea/Shaders/ToonStocking.shader#L150">参考</a></p><p>让材质的diffuse根据菲涅尔差值，实现简单的丝袜，这里的modify将会直接乘到diffuse颜色上</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+// Feature</span></span><br><span class="line"><span class="addition">+[Main(FeatureMode, _, off, off)] _FeatureGroup(&quot;Feature&quot;, float) = 0</span></span><br><span class="line"><span class="addition">+[KWEnum(FeatureMode, FresnelStocking, _FRESNEL_STOCKING)] _EnumFeatureMode (&quot;Feature&quot;, float) = 0</span></span><br><span class="line"><span class="addition">+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 0)] _CustomFloat1 (&quot;Stockings Pow&quot;, Float) = 0.5</span></span><br><span class="line"><span class="addition">+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 0)] _CustomVector1 (&quot;Color Inside&quot;, Color) = (1,1,1,1)</span></span><br><span class="line"><span class="addition">+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 0)] _CustomVector2 (&quot;Color Outside&quot;, Color) = (1,1,1,1)</span></span><br><span class="line"></span><br><span class="line">#pragma shader_feature_local _CELLSHADING _PBRSHADING</span><br><span class="line"><span class="addition">+#pragma shader_feature_local _FRESNEL_STOCKING</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+#define _StockingsPow _CustomFloat1</span></span><br><span class="line"><span class="addition">+#define _StockingsColorInside _CustomVector1</span></span><br><span class="line"><span class="addition">+#define _StockingsColorOutside _CustomVector2</span></span><br><span class="line"></span><br><span class="line">void PreProcessMaterial(inout InputData inputData, inout ToonSurfaceData surfaceData, float2 uv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="addition">+    #if _FRESNEL_STOCKING</span></span><br><span class="line"><span class="addition">+    float NoV = max(dot(inputData.viewDirectionWS, inputData.normalWS), 0.001);</span></span><br><span class="line"><span class="addition">+    float fresnelStockings = pow(NoV, _StockingsPow);</span></span><br><span class="line"><span class="addition">+    float3 stockingsColor = lerp(_StockingsColorOutside.rgb, _StockingsColorInside.rgb, fresnelStockings);</span></span><br><span class="line"><span class="addition">+    surfaceData.diffuseModify = stockingsColor;</span></span><br><span class="line"><span class="addition">+    #endif</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="易拓展">易拓展</h3><p>必须承认，不同材质的ShadingMode不同，因此我们必须要支持自定义ShadingMode，于是我设计了一个<code>CustomFragment</code>函数，并定义了一个宏，当这个宏打开，就不走<code>ToonFragment</code>，而是<code>CustomFragment</code>，<a href="https://github.com/Reuben-Sun/ToonURP/blob/109da12064f8865fac8d4f752d45e8bb8fc4c4ea/Shaders/ToonHair.shader#L152">参考</a></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// Lighting mode</span><br><span class="line">[Main(ShadingMode, _, off, off)] _ShadingModeGroup(&quot;ShadingMode&quot;, float) = 0</span><br><span class="line"><span class="addition">+[KWEnum(ShadingMode, CelShading, _CELLSHADING, PBRShading, _PBRSHADING, CelHair, _CUSTOMSHADING)] _EnumShadingMode (&quot;Mode&quot;, float) = 2</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+#pragma shader_feature_local _CELLSHADING _PBRSHADING _CUSTOMSHADING</span></span><br><span class="line"></span><br><span class="line">float4 CustomFragment(InputData inputData, ToonSurfaceData toonSurfaceData, AdditionInputData additionInput)</span><br><span class="line">&#123;</span><br><span class="line"><span class="addition">+...</span></span><br><span class="line">return color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#include &quot;Packages/com.reubensun.toonurp/Shaders/ToonStandardForwardPass.hlsl&quot;</span><br></pre></td></tr></table></figure><h3 id="维护SRP-batcher">维护SRP batcher</h3><p>为了让材质都支持SRP batcher，我们需要不同shader的CBuffer相同，但不同材质要很多不同的变量</p><p>为此我在CBuffer中提前定义了大量的float、vector、贴图，在使用时只需要先用<code>#define</code>对这个custom变量重命名，就能兼容SRP batcher，<a href="https://github.com/Reuben-Sun/ToonURP/blob/109da12064f8865fac8d4f752d45e8bb8fc4c4ea/Shaders/ToonRock.shader#L141">参考</a></p><h3 id="低侵入">低侵入</h3><p>我看到很多卡通渲染包，他们都把URP完整复制一份，然后在其中进行少部分的修改，结果就是用户很难分清哪些是自定义的，当用户打算升级URP版本时，就会遇到很多问题</p><p>于是我把URP复制到另一个项目中，仅仅做必须在URP做的修改（比如加一个GT Tonemapping），其他的RenderFeature和Shader都在主项目中进行，于是主项目中几乎没有Unity URP自带的内容，十分简洁</p><h2 id="功能实现">功能实现</h2><p><a href="https://github.com/Reuben-Sun/ToonURP">详情</a></p><h2 id="为什么不想做了">为什么不想做了</h2><p>TA届有句名言，工匠克算法</p><p>我感觉卡渲的效果太依赖模型、材质了，而我自己不能产出这些资源，游戏公司公开的mmd模型并不是他们实际使用的，很多feature所需的资产并没有公开，非常劝退</p><p>而且我感觉URP的设计没有想象中那么好，我想添加一个Tonemapping需要改URP源码，想自己实现阴影要注释掉很多东西，RenderGraph的API频繁改动，让人没有上的欲望</p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> URP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity 性能优化</title>
      <link href="/engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1>Unity 性能优化</h1><blockquote><p>Unity版本为2022.3.34，本文所有的测试均在Editor下进行</p></blockquote><p>尽管我认为，性能远远没有实现重要，提前优化、过度优化、虚空优化，之会影响开发效率，不过还是记录一下我最近学到的一些关于Unity性能优化的小技巧</p><h2 id="脚本优化">脚本优化</h2><h3 id="测试工具">测试工具</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomTimer</span>: <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _count;</span><br><span class="line">    <span class="keyword">private</span> Stopwatch _stopwatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTimer</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _count = count;</span><br><span class="line">        <span class="keyword">if</span> (_count &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _stopwatch = Stopwatch.StartNew();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _stopwatch.Stop();</span><br><span class="line">        UnityEngine.Debug.Log(<span class="string">$&quot;<span class="subst">&#123;_name&#125;</span> took <span class="subst">&#123;_stopwatch.ElapsedMilliseconds&#125;</span>ms for <span class="subst">&#123;_count.ToString(<span class="string">&quot;N0&quot;</span>)&#125;</span> iterations, average time: <span class="subst">&#123;_stopwatch.ElapsedMilliseconds / _count&#125;</span>ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GetComponent的方式">GetComponent的方式</h3><p>测试三种获得Component的方式</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ComponentTest comp = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">new</span> CustomTimer(<span class="string">&quot;GetComponent(string)&quot;</span>, testCount))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; testCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        comp = (ComponentTest)GetComponent(<span class="string">&quot;ComponentTest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">new</span> CustomTimer(<span class="string">&quot;GetComponent&lt;&gt;&quot;</span>, testCount))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; testCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        comp = GetComponent&lt;ComponentTest&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">new</span> CustomTimer(<span class="string">&quot;GetComponent(typeof(ComponentTest))&quot;</span>, testCount))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; testCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        comp = (ComponentTest)GetComponent(<span class="keyword">typeof</span>(ComponentTest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试，几乎无差别（貌似老版本会有区别，用string最慢）</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GetComponent(<span class="built_in">string</span>) took <span class="number">136</span>ms <span class="keyword">for</span> <span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span> iterations, average time: <span class="number">0</span>ms</span><br><span class="line">GetComponent&lt;&gt; took <span class="number">115</span>ms <span class="keyword">for</span> <span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span> iterations, average time: <span class="number">0</span><span class="function">ms</span></span><br><span class="line"><span class="function"><span class="title">GetComponent</span>(<span class="params"><span class="keyword">typeof</span>(ComponentTest</span>)) took 177ms <span class="keyword">for</span> 1,000,000 iterations, average time: 0ms</span></span><br></pre></td></tr></table></figure><h3 id="比较go是否为null">比较go是否为null</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">new</span> CustomTimer(<span class="string">&quot;Empty&quot;</span>, testCount))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; testCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Debug.Log(ans);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">new</span> CustomTimer(<span class="string">&quot;!=&quot;</span>, testCount))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; testCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (go != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Debug.Log(ans);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">new</span> CustomTimer(<span class="string">&quot;ReferenceEquals&quot;</span>, testCount))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; testCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!System.Object.ReferenceEquals(go, <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Debug.Log(ans);</span><br></pre></td></tr></table></figure><p>经测试，直接比较是!= null更慢</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Empty took <span class="number">21</span>ms <span class="keyword">for</span> <span class="number">100</span>,<span class="number">000</span>,<span class="number">000</span> iterations, average time: <span class="number">0</span>ms</span><br><span class="line">!= took <span class="number">445</span>ms <span class="keyword">for</span> <span class="number">100</span>,<span class="number">000</span>,<span class="number">000</span> iterations, average time: <span class="number">0</span>ms</span><br><span class="line">ReferenceEquals took <span class="number">22</span>ms <span class="keyword">for</span> <span class="number">100</span>,<span class="number">000</span>,<span class="number">000</span> iterations, average time: <span class="number">0</span>ms</span><br></pre></td></tr></table></figure><h3 id="检索Tag">检索Tag</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">new</span> CustomTimer(<span class="string">&quot;string tag&quot;</span>, testCount))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; testCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (go.tag == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Debug.Log(ans);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">new</span> CustomTimer(<span class="string">&quot;CompareTag&quot;</span>, testCount))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; testCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (go.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Debug.Log(ans);</span><br></pre></td></tr></table></figure><p>直接比较tag字符串更慢</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> tag took <span class="number">162</span>ms <span class="keyword">for</span> <span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span> iterations, average time: <span class="number">0</span>ms</span><br><span class="line">CompareTag took <span class="number">70</span>ms <span class="keyword">for</span> <span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span> iterations, average time: <span class="number">0</span>ms</span><br></pre></td></tr></table></figure><h3 id="Update">Update</h3><ul><li><p>停止远处GO的脚本<code>update</code></p></li><li><p>分层<code>update</code></p></li></ul><h3 id="序列化">序列化</h3><p>重写序列化，只保留一些必须的参数，尽量存储简单的数据结构，反序列化时自行从<code>Resources.LoadAsync()</code>中加载出来</p><h2 id="图形优化">图形优化</h2><h3 id="SRP-Bather">SRP Bather</h3>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python numpy</title>
      <link href="/program/numpy/"/>
      <url>/program/numpy/</url>
      
        <content type="html"><![CDATA[<h1>Python numpy</h1><p>我发现Python numpy的性能真的是特别强，甚至可以用来写ShaderToy</p><h2 id="Numpy画圆的性能对比">Numpy画圆的性能对比</h2><p>对一张512x512的图片，使用ShaderToy的方式画圆，性能居然能差50倍！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">data, out_path</span>):</span><br><span class="line">    data = data.astype(np.uint8)</span><br><span class="line">    image = Image.fromarray(data, mode=<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">    image.save(out_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sdf_sphere</span>(<span class="params">x, y, cx, cy, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算点 (x, y) 到中心为 (cx, cy) 且半径为 r 的圆的符号距离&quot;&quot;&quot;</span></span><br><span class="line">    dx = x - cx</span><br><span class="line">    dy = y - cy</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(dx * dx + dy * dy) - r</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">input_image</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;For循环遍历每一个元素&quot;&quot;&quot;</span></span><br><span class="line">    width = input_image.shape[<span class="number">0</span>]</span><br><span class="line">    height = input_image.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;width: <span class="subst">&#123;width&#125;</span>, height: <span class="subst">&#123;height&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            u = i / width</span><br><span class="line">            v = j / height</span><br><span class="line">            <span class="keyword">if</span> sdf_sphere(u, v, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.2</span>) &lt; <span class="number">0.1</span>:</span><br><span class="line">                input_image[i, j] = <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> input_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">input_image</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;使用np向量操作&quot;&quot;&quot;</span></span><br><span class="line">    width = input_image.shape[<span class="number">0</span>]</span><br><span class="line">    height = input_image.shape[<span class="number">1</span>]</span><br><span class="line">    u, v = np.meshgrid(np.linspace(<span class="number">0</span>, <span class="number">1</span>, width), np.linspace(<span class="number">0</span>, <span class="number">1</span>, height), indexing=<span class="string">&#x27;ij&#x27;</span>)</span><br><span class="line">    distances = sdf_sphere(u, v, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.2</span>)</span><br><span class="line">    input_image[distances &lt; <span class="number">0.1</span>] = <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> input_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    image1 = np.zeros((<span class="number">512</span>, <span class="number">512</span>), dtype=np.float32)</span><br><span class="line">    image2 = np.zeros((<span class="number">512</span>, <span class="number">512</span>), dtype=np.float32)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    out1 = func1(image1)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(end_time - start_time)<span class="comment"># 0.4647049903869629</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    out2 = func2(image2)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(end_time - start_time)<span class="comment"># 0.00978851318359375</span></span><br><span class="line">    save_image(out1, <span class="string">&#x27;assets/temp/image.png&#x27;</span>)</span><br><span class="line">    save_image(out2, <span class="string">&#x27;assets/temp/image2.png&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="2D-SDF">2D SDF</h2><h3 id="圆">圆</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sdf_sphere</span>(<span class="params">x, y, cx, cy, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算点 (x, y) 到中心为 (cx, cy) 且半径为 r 的圆的符号距离&quot;&quot;&quot;</span></span><br><span class="line">    dx = x - cx</span><br><span class="line">    dy = y - cy</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(dx * dx + dy * dy) - r</span><br></pre></td></tr></table></figure><h3 id="正方形">正方形</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sdf_square</span>(<span class="params">x, y, cx, cy, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算点 (x, y) 到中心为 (cx, cy) 且边长为 size 的正方形的符号距离&quot;&quot;&quot;</span></span><br><span class="line">    dx = np.maximum(np.<span class="built_in">abs</span>(x - cx) - size / <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">    dy = np.maximum(np.<span class="built_in">abs</span>(y - cy) - size / <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(dx * dx + dy * dy)</span><br></pre></td></tr></table></figure><h3 id="正方形线框">正方形线框</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sdf_square_frame</span>(<span class="params">x, y, cx, cy, size</span>):</span><br><span class="line">    dx = np.<span class="built_in">abs</span>(x - cx) - size / <span class="number">2</span></span><br><span class="line">    dy = np.<span class="built_in">abs</span>(y - cy) - size / <span class="number">2</span></span><br><span class="line">    outside_distance = np.sqrt(np.maximum(dx, <span class="number">0</span>)**<span class="number">2</span> + np.maximum(dy, <span class="number">0</span>)**<span class="number">2</span>)</span><br><span class="line">    inside_distance = -np.minimum(np.maximum(dx, dy), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> outside_distance + inside_distance</span><br></pre></td></tr></table></figure><h2 id="常用Numpy函数">常用Numpy函数</h2><h3 id="np-prod">np.prod</h3><p>返回输入数组中所有元素的乘积</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">result = np.prod(arr)<span class="comment"># 24 = 1 * 2 * 3 *4</span></span><br><span class="line"><span class="comment"># 根据轴</span></span><br><span class="line">result2 = np.prod(arr, axis=<span class="number">0</span>)<span class="comment"># [3, 8], 3 = 1 * 3, 8 = 2 * 4</span></span><br><span class="line"><span class="comment"># 使用初始值</span></span><br><span class="line">result3 = np.prod(arr, initial=<span class="number">2</span>)<span class="comment"># 48 = 2 * 1 * 2 * 3 * 4</span></span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://iquilezles.org/articles/distfunctions/">sdf</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyBind11实现Python调用C++</title>
      <link href="/program/pybind11/"/>
      <url>/program/pybind11/</url>
      
        <content type="html"><![CDATA[<h1>PyBind11实现Python调用C++</h1><p>我曾经写过一篇SWIG实现Python调用C++的文章，SWIG是一个非常好用的通用工具，可以实现很多语言间的互通，不过最近我发现一个专门为Python和C++设计的库，PyBind11，AI领域貌似更喜欢这个库</p><p>PyBind11是一个非常轻量的纯头文件库，可以看作对Boost.Python的简化模仿，这个库要求至少使用C++11、Python 3.6，使用条件相对苛刻，但说实话，对于新项目这个版本要求并不过分</p><p>PyBind11有很多优点，我个人比较喜欢将项目嵌入到CMake项目，并使用<code>pip install</code>进行安装</p><h2 id="嵌入到CMake项目">嵌入到CMake项目</h2><h3 id="1-submodule">1. submodule</h3><p>首先将PyBind11库作为Submodule添加到项目根目录（你也可以放在其他地方）下的pybind11文件夹</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git submodule add https:<span class="comment">//github.com/pybind/pybind11.git pybind11</span></span><br></pre></td></tr></table></figure><h3 id="2-setup-py">2. <a href="http://setup.py">setup.py</a></h3><p>在项目根目录添加一个setup.py文件，便于pip安装</p><p>可以基于<a href="https://github.com/pybind/cmake_example/blob/master/setup.py">官方示例</a>修改</p><h3 id="3-CMakeList-txt">3. CMakeList.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"><span class="keyword">project</span>(pycppstudy LANGUAGES CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(pybind11)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE HEADERS src/*.h)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES src/*.cpp)</span><br><span class="line">pybind11_add_module(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;HEADERS&#125;</span> <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure><p>核心是通过<code>pybind11_add_module</code>创建库</p><h3 id="4-编写代码">4. 编写代码</h3><p>引入pybind11头文件，并编写约定</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> py = pybind11;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 约定</span></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(pycppstudy, m) &#123;</span><br><span class="line">    m.<span class="built_in">doc</span>() = <span class="string">&quot;pybind11 pycppstudy plugin&quot;</span>; </span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;add&quot;</span>, &amp;add, <span class="string">&quot;A function that adds two numbers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-安装包">5. 安装包</h3><p>在这个项目的外层，输入命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -e ./&lt;项目文件夹名&gt;</span><br></pre></td></tr></table></figure><p>就会按照自定义的包</p><blockquote><p>卸载包的方式是 pip uninstall &lt;包名&gt;</p></blockquote><h3 id="6-使用">6. 使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pycppstudy</span><br><span class="line">pycppstudy.add(<span class="number">1</span>, <span class="number">2</span>)<span class="comment"># 3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenAI API</title>
      <link href="/ai/OpenAI/"/>
      <url>/ai/OpenAI/</url>
      
        <content type="html"><![CDATA[<h1>OpenAI API</h1><blockquote><p>我这里使用的<a href="https://platform.stepfun.com">Step开放平台</a>，其API与OpenAI兼容</p></blockquote><p>Python可以使用<code>openai</code>库轻松调用一些大模型服务，对Agent工程师来说非常有用</p><h3 id="对话">对话</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"> </span><br><span class="line">client = OpenAI(api_key=<span class="string">&quot;xxxxx&quot;</span>, base_url=<span class="string">&quot;https://api.stepfun.com/v1&quot;</span>)</span><br><span class="line"> </span><br><span class="line">completion = client.chat.completions.create(</span><br><span class="line">model=<span class="string">&quot;step-1-8k&quot;</span>,</span><br><span class="line">messages=[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>,</span><br><span class="line"><span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是由阶跃星辰提供的AI聊天助手，你擅长中文，英文，以及多种其他语言的对话。在保证用户数据安全的前提下，你能对用户的问题和请求，作出快速和精准的回答。同时，你的回答和建议应该拒绝黄赌毒，暴力恐怖主义的内容&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你好，请介绍一下阶跃星辰的人工智能!&quot;</span>&#125;,</span><br><span class="line">],</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(completion)</span><br></pre></td></tr></table></figure><h3 id="流式响应">流式响应</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># api_key需要自己申请 </span></span><br><span class="line">client = OpenAI(api_key=<span class="string">&quot;xxxxx&quot;</span>, base_url=<span class="string">&quot;https://api.stepfun.com/v1&quot;</span>)</span><br><span class="line"> </span><br><span class="line">completion = client.chat.completions.create(</span><br><span class="line">model=<span class="string">&quot;step-1-8k&quot;</span>,</span><br><span class="line">  stream = <span class="literal">True</span>,</span><br><span class="line">messages=[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>,</span><br><span class="line"><span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是由阶跃星辰提供的AI聊天助手，你擅长中文，英文，以及多种其他语言的对话。在保证用户数据安全的前提下，你能对用户的问题和请求，作出快速和精准的回答。同时，你的回答和建议应该拒绝黄赌毒，暴力恐怖主义的内容&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你好，请介绍一下阶跃星辰的人工智能!&quot;</span>&#125;,</span><br><span class="line">],</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 流式打印出来</span></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> completion:</span><br><span class="line">    sys.stdout.write(chunk.choices[<span class="number">0</span>].delta.content)</span><br><span class="line">    sys.stdout.flush()</span><br></pre></td></tr></table></figure><h3 id="多轮对话">多轮对话</h3><p>将先前双方的对话内容（包含system）塞入messages中，在末尾加入本次问题</p><blockquote><p>传入history模型会利用kvcache加速，于是多轮的回答耗时不会显著提升（耗时会随着history增长而延长，但并不显著）</p><p>你可以一个滑动窗口截断history</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">local_message = []</span><br><span class="line">local_message.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;xxxxx&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> history <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">  <span class="keyword">for</span> his <span class="keyword">in</span> history:</span><br><span class="line">    local_message.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: his[<span class="number">0</span>]&#125;)</span><br><span class="line">    local_message.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: his[<span class="number">1</span>]&#125;)</span><br><span class="line">local_message.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;xxxxxx&quot;</span>&#125;)</span><br><span class="line">completion = client.chat.completions.create(</span><br><span class="line">model=<span class="string">&quot;step-1-8k&quot;</span>,</span><br><span class="line">messages=local_message</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 再将completion的输入和结果塞入history中</span></span><br></pre></td></tr></table></figure><h3 id="图像理解">图像理解</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prompt = <span class="string">&#x27;这张图片是用blender从顶部向下渲染一个场景的结果，请你判断这个场景是否是一个复杂室外场景，只能回答是或不是。注意，一个室外场景往往意味着一组建筑、物体排布在一个大地图上。如果建筑内部信息被展示出来，则不属于室外场景。如果这个场景非常单调，物体数量比较少，则不属于复杂的场景。也请将我的世界（MC）风格的场景视为否。&#x27;</span></span><br><span class="line">messages_data = &#123;</span><br><span class="line">    <span class="string">&#x27;model&#x27;</span>: <span class="string">&#x27;gpt-4o&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;stream&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&quot;max_tokens&quot;</span>: <span class="number">4096</span>,</span><br><span class="line">    <span class="string">&quot;messages&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;role&#x27;</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;content&#x27;</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;image_url&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;image_url&#x27;</span>: &#123;<span class="string">&#x27;url&#x27;</span>: convert_image_to_base64(image)&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;text&#x27;</span>: prompt</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRTP</title>
      <link href="/program/CRTP/"/>
      <url>/program/CRTP/</url>
      
        <content type="html"><![CDATA[<h1>奇异递归模板模式</h1><blockquote><p>Curiously Recurring Template Pattern，CRTP</p></blockquote><p>最近发现一个很优雅的写法，CRTP，利用了模版和继承的特性，实现了一种奇观的“自我认知”，可以省去写很多重复代码</p><h2 id="C-实现一个单例">C#实现一个单例</h2><h3 id="定义">定义</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> T _instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> HasInstance =&gt; _instance != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = FindObjectOfType&lt;T&gt; ();</span><br><span class="line">                <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    GameObject obj = <span class="keyword">new</span> GameObject ();</span><br><span class="line">                    obj.name = <span class="keyword">typeof</span>(T).Name + <span class="string">&quot;_AutoCreated&quot;</span>;</span><br><span class="line">                    _instance = obj.AddComponent&lt;T&gt; ();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeSingleton();      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InitializeSingleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Application.isPlaying)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _instance = <span class="keyword">this</span> <span class="keyword">as</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用">使用</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GlobalTableManager</span> : <span class="title">Singleton</span>&lt;<span class="title">GlobalTableManager</span>&gt;</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="C-实现一个单例-2">C++实现一个单例</h2><h3 id="定义-2">定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">static</span> T* instance;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 构造函数私有，确保不能直接实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> instance;</span><br><span class="line">        instance = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><h3 id="使用-2">使用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySingleton</span> : <span class="keyword">public</span> Singleton&lt;MySingleton&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MySingleton::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
            <tag> Csharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Luban</title>
      <link href="/engine/UnityLuban/"/>
      <url>/engine/UnityLuban/</url>
      
        <content type="html"><![CDATA[<h1>Unity Luban表格工具</h1><p><a href="https://luban.doc.code-philosophy.com/docs/intro">Luban</a>是一个很好用的导表工具</p><p>Unity Luban由三部分组成：</p><ol><li>Unity Package，用于读取json</li><li>导表工具，点击一下<code>.bat</code>，就能将表格转为C#和json</li><li>生成的代码+ExternalTypeUtil，这部分将放在Unity Assets内</li></ol><h2 id="项目初始化">项目初始化</h2><h3 id="一：下载导表工具">一：下载导表工具</h3><p>参考<a href="https://github.com/focus-creative-games/luban_examples/tree/main/Projects/Csharp_Unity_json">Csharp Unity json</a>，在Unity项目外某处新建一个文件夹，将表格和Tools放在其中，并创建一个<code>gen.bat</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set LUBAN_DLL=.\Tools\Luban\Luban.dll</span><br><span class="line">set CONF_ROOT=.\DataTables</span><br><span class="line"></span><br><span class="line">dotnet %LUBAN_DLL% ^</span><br><span class="line">    -t client ^</span><br><span class="line">    -c cs-simple-json ^</span><br><span class="line">    -d json  ^</span><br><span class="line">    --conf %CONF_ROOT%\luban.conf ^</span><br><span class="line">    -x outputCodeDir=..\Assets\Luban\Gen ^</span><br><span class="line">    -x outputDataDir=..\Assets\Luban\Json</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h3 id="二：安装Luban-Unity-Package">二：安装Luban Unity Package</h3><p><a href="https://github.com/focus-creative-games/luban_unity">下载地址</a></p><p>下载后放入Packages文件夹中，在Project Setting中开启unsafe</p><h3 id="三：生成">三：生成</h3><p>双击运行之前创建的<code>gen.bat</code>，就会在Assets对应的文件夹中生成json和相关代码</p><p>在再项目中添加文件<code>ExternalTypeUtil.cs</code></p><h3 id="四：使用">四：使用</h3><p>创建一个<code>LoadByteBuf</code>函数，用于找到json放置的位置，用<code>new cfg.Tables(LoadByteBuf)</code>加载表格</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    var tables = <span class="keyword">new</span> cfg.<span class="built_in">Tables</span>(LoadByteBuf);</span><br><span class="line">    UnityEngine.Debug.<span class="built_in">LogFormat</span>(<span class="string">&quot;item[1].name:&#123;0&#125;&quot;</span>, tables.TbItem[<span class="number">1</span>].Name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    UnityEngine.Debug.<span class="built_in">Log</span>(<span class="string">&quot;== load succ==&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> JSONNode <span class="title">LoadByteBuf</span><span class="params">(string file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JSON.<span class="built_in">Parse</span>(File.<span class="built_in">ReadAllText</span>(Application.dataPath + <span class="string">&quot;/Luban/Json/&quot;</span> + file + <span class="string">&quot;.json&quot;</span>, System.Text.Encoding.UTF8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建自己的表格">创建自己的表格</h2><ol><li>按照<a href="https://luban.doc.code-philosophy.com/docs/manual/excel">表格规范</a>创建一个自己的表格</li><li>在<code>__tables__.xlsx</code>中添加刚刚的表格</li></ol>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity UI 开发</title>
      <link href="/engine/UnityUI%E5%BC%80%E5%8F%91/"/>
      <url>/engine/UnityUI%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1>Unity UI 开发</h1><h2 id="使用中文字体">使用中文字体</h2><p>在使用Unity制作游戏时，想要UI（TMP）使用中文字体</p><ol><li>下载一个字体文件<code>.ttf</code></li><li>下载一个中文字符集<code>.txt</code></li></ol><blockquote><p>分享一个字符集项目<a href="https://github.com/wy-luke/Unity-TextMeshPro-Chinese-Characters-Set.git">https://github.com/wy-luke/Unity-TextMeshPro-Chinese-Characters-Set.git</a></p></blockquote><ol start="3"><li>Window–TextMeshPro–Font Asset Creator</li></ol><p><img src="/images/%E5%88%9B%E5%BB%BA%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93.png" class="lazyload" data-srcset="/images/%E5%88%9B%E5%BB%BA%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="创建中文字体"></p><h2 id="富文本字体">富文本字体</h2><p>Unity的Text支持<a href="https://docs.unity3d.com/cn/2023.1/Manual/StyledText.html">富文本</a></p><p>比如让下面这段文字中colorfully变色</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">We are &lt;color=<span class="params">#</span>ff0000ff&gt;colorfully&lt;/color&gt; amused</span><br></pre></td></tr></table></figure><h2 id="鼠标事件">鼠标事件</h2><p>为UI物体添加2D碰撞体后，可以在上面绑定脚本，添加生命周期函数，如<code>OnMouseEnter</code>，<code>OnMouseExit</code></p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradio</title>
      <link href="/program/Gradio/"/>
      <url>/program/Gradio/</url>
      
        <content type="html"><![CDATA[<h1>Gradio</h1><p>Gradio是一个基于Python的Web UI框架，常用于AI demo搭建，SD的webui就使用的Gradio</p><p>Gradio采用函数式编程，由组件和函数组成，声明组件即可绘制UI，为组件绑定函数可以修改组件内容</p><p>可以在<a href="https://www.gradio.app/playground">Gradio Playground</a>中预览体验</p><h2 id="基本语法">基本语法</h2><h3 id="Blocks">Blocks</h3><blockquote><p>我不太喜欢 Interface</p></blockquote><p>相较于Interface，Blocks可以使用<code>gr.Row()</code>等排版方式，更灵活</p><p>Gradio可以渲染一个markdown、html文本，可以将一些大段文字写在资源里，运行时读资源文本</p><p>在某个层级声明一个组件（比如Button）就会渲染一个按钮，可以用循环等方式批量生成</p><p>组件可以绑定事件，事件由函数+输入+输出组成</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> gr.Blocks() <span class="keyword">as</span> demo:<span class="comment"># MARK!</span></span><br><span class="line">  <span class="comment"># 声明一个Markdown标题</span></span><br><span class="line">    gr.Markdown(<span class="string">&#x27;# Hello Title&#x27;</span>)</span><br><span class="line">    <span class="comment"># 声明一个Upload button</span></span><br><span class="line">    u = gr.UploadButton(<span class="string">&quot;Upload a file&quot;</span>, file_count=<span class="string">&quot;single&quot;</span>, file_types=[<span class="string">&quot;.zip&quot;</span>])</span><br><span class="line">    <span class="comment"># 下面的几个组件在一行</span></span><br><span class="line">    <span class="keyword">with</span> gr.Row():</span><br><span class="line">        file_name_text = gr.Textbox(lines=<span class="number">1</span>, label=<span class="string">&quot;File name&quot;</span>)</span><br><span class="line">        file_count_text = gr.Textbox(lines=<span class="number">1</span>, label=<span class="string">&quot;File count&quot;</span>)</span><br><span class="line">    <span class="comment"># 为Upload button绑定事件，输入是button本身，输出是两个Textbox</span></span><br><span class="line">    u.upload(process_upload_file, inputs=u, outputs=[file_name_text, file_count_text])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    demo.launch(server_name=<span class="string">&quot;0.0.0.0&quot;</span>, server_port=<span class="number">7860</span>)<span class="comment"># 端口，尤其是要将服务暴露出去时</span></span><br><span class="line">    demo.queue(concurrency_count=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="TabbedInterface">TabbedInterface</h3><p>可以将多个Blocks和在一起，通过左上角的页签切换显示的Blocks，很适合多个平行功能的开发</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> gr.Blocks() <span class="keyword">as</span> demo:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">with</span> gr.Blocks() <span class="keyword">as</span> demo2:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">app = gr.TabbedInterface([demo, demo2], [<span class="string">&#x27;Demo Name&#x27;</span>, <span class="string">&#x27;Demo2 Name&#x27;</span>])</span><br><span class="line">app.launch(server_name=<span class="string">&quot;0.0.0.0&quot;</span>, server_port=<span class="number">7861</span>)</span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><p>我感觉gradio的函数写法很神奇，你在函数外只能声明组件，不能拿到组件的值，不能修改组件，想做1+1也要使用函数</p><p>为组件绑定函数时，inputs和outputs均为组件（或组件数组），但函数的输入和输出是组件的值，而非组件本身，比如你为一个函数绑定了输出为一个Textbox，你只需要返回一个字符串就行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个函数的输入是一个upload button对应的内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_upload_file</span>(<span class="params">file</span>):</span><br><span class="line">    upload_dir = Path(<span class="string">&quot;./uploads&quot;</span>)</span><br><span class="line">    upload_dir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)  <span class="comment"># Create the directory if it doesn&#x27;t exist</span></span><br><span class="line">    file_path = upload_dir / Path(file.name)</span><br><span class="line">    shutil.copy(file, upload_dir)</span><br><span class="line">    unzip_folder = upload_dir / Path(file).stem</span><br><span class="line">    <span class="keyword">with</span> zipfile.ZipFile(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">        zip_ref.extractall(unzip_folder)</span><br><span class="line">    <span class="comment"># 输出是两个字符串</span></span><br><span class="line">    <span class="keyword">return</span> Path(file).stem, <span class="built_in">len</span>(zip_ref.namelist())</span><br></pre></td></tr></table></figure><h3 id="全局变量">全局变量</h3><p>在外部定义一个全局变量，在函数中可以访问</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stop_animation = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play_animation</span>(<span class="params">file_name, current_frame, file_count, frame_rate</span>):</span><br><span class="line">     <span class="keyword">global</span> stop_animation</span><br><span class="line">     stop_animation = <span class="literal">False</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(current_frame), <span class="built_in">int</span>(file_count)):</span><br><span class="line">        <span class="keyword">if</span> stop_animation:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>/<span class="built_in">float</span>(frame_rate))</span><br><span class="line">        progress = (i+<span class="number">1</span>)/<span class="built_in">int</span>(file_count)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;uploads/<span class="subst">&#123;file_name&#125;</span>/<span class="subst">&#123;i&#125;</span>.svg&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            svg_content = f.read()</span><br><span class="line">        <span class="comment"># 这里的yield是stream用法</span></span><br><span class="line">        <span class="keyword">yield</span> svg_content, i, progress</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stop_animation</span>():</span><br><span class="line">    <span class="keyword">global</span> stop_animation<span class="comment"># MARK!</span></span><br><span class="line">    stop_animation = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> gr.Blocks() <span class="keyword">as</span> demo:</span><br><span class="line">  ...</span><br><span class="line">  html = gr.HTML()</span><br><span class="line">    <span class="keyword">with</span> gr.Row():</span><br><span class="line">        btn = gr.Button(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">        stop_btn = gr.Button(<span class="string">&quot;Stop&quot;</span>)</span><br><span class="line">    btn.click(play_animation, inputs=[file_name_text, frame_index, file_count_text, frame_rate], outputs=[html, frame_index, sl])</span><br><span class="line">    stop_btn.click(stop_animation)</span><br></pre></td></tr></table></figure><h2 id="组件">组件</h2><h3 id="示例">示例</h3><p>可以给一些输入组件提供示例，点一下自动填充</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_image = gr.Image(<span class="built_in">type</span>=<span class="string">&quot;filepath&quot;</span>)</span><br><span class="line">gr.Examples(</span><br><span class="line">        examples=[</span><br><span class="line">            [osp.join(example_portrait_dir, <span class="string">&quot;hal.jpeg&quot;</span>)],</span><br><span class="line">            [osp.join(example_portrait_dir, <span class="string">&quot;s7.jpg&quot;</span>)],</span><br><span class="line">        ],</span><br><span class="line">        inputs=[input_image],</span><br><span class="line">        cache_examples=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><h3 id="网络连接bug">网络连接bug</h3><p><a href="https://github.com/gradio-app/gradio/issues/4332">https://github.com/gradio-app/gradio/issues/4332</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下GCC降级</title>
      <link href="/program/GCC%E9%99%8D%E7%BA%A7/"/>
      <url>/program/GCC%E9%99%8D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1>Linux下GCC降级</h1><p>CUDA版本需要和gcc版本对应，兼容性出奇地差，Ubuntu自带gcc，但是通常版本很高，于是需要对gcc进行降级</p><h2 id="降级到gcc-7">降级到gcc-7</h2><p>安装gcc-7</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc-7 g++-7</span><br></pre></td></tr></table></figure><p>设置gcc版本优先级</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 9</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 1</span><br></pre></td></tr></table></figure><p>查看gcc版本优先级</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --display gcc</span><br></pre></td></tr></table></figure><p>设置g++版本优先级</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 9</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 1</span><br></pre></td></tr></table></figure><p>查看g++版本优先级</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --display g++</span><br></pre></td></tr></table></figure><blockquote><p>或者可以</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">sudo update-alternatives --config g++</span><br></pre></td></tr></table></figure></blockquote><h2 id="参考">参考</h2><p><a href="https://blog.csdn.net/weixin_39529413/article/details/109098144">https://blog.csdn.net/weixin_39529413/article/details/109098144</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Photoshop使用笔记</title>
      <link href="/dcc/PS%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/dcc/PS%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>Photoshop使用笔记</h1><h3 id="白天变黑夜">白天变黑夜</h3><ol><li>导入图片，解除图片锁定</li><li>右下角点击曲线</li></ol><p><img src="/images/PS%E6%9B%B2%E7%BA%BF.png" class="lazyload" data-srcset="/images/PS%E6%9B%B2%E7%BA%BF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PS曲线"></p><ol start="3"><li>将曲线的右上角点向下移动，此时整个图片将会变黑</li><li>添加一个新图层，用画笔工具在图层中画白色内容</li><li>将新图层设为叠加，于是白色内容部分就会变亮</li></ol>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity自定义Package</title>
      <link href="/engine/UnityPackage/"/>
      <url>/engine/UnityPackage/</url>
      
        <content type="html"><![CDATA[<h1>Unity自定义Package</h1><p>每一个Unity图形引擎中台，都应该学会自定义一个Unity Package，这样你的代码可以与项目解耦，也可以在多个项目间复用，通过版本控制可以提高维护性</p><h2 id="版本管理">版本管理</h2><p>个人建议直接使用Git进行管理，创建一个Git仓库，使用时只需要在项目Packages文件夹下<code>git clone</code></p><h2 id="package-json">package.json</h2><p>在根目录下添加文件<code>package.json</code>，Unity将会将当前文件夹识别为一个Package</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.reubensun.toonurp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A omnipotence rendering pipeline for Unity&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;unity&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;displayName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Toon URP&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;com.unity.mathematics&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;com.unity.burst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.8.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;com.unity.render-pipelines.universal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;14.0.10&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Reuben Sun&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/Reuben-Sun/ToonURP&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;shaders&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;toon&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;samples&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;displayName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ToonURP Package Samples&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Collection of scenes showcasing different features of the Toon URP.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Samples&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>name：包名称</li><li>description：在Package manager中包的描述</li><li>version：当前包的版本号</li><li>dependencies：对其他包的依赖（通常只写对Unity官方库的依赖）</li><li>samples：添加后用户可以在Package manager中选择Import你包的Samples文件夹到Assets目录（你可以将你的Samples目录后面加入一个<code>~</code>，这样Unity就不会默认Import这个文件夹，便于精简包）</li></ul><h2 id="程序集定义">程序集定义</h2><p>如果你的包有Editor和Runtime的代码，可以在这两个文件夹中添加程序集定义（Create–Assembly Definition）</p><p>Runtime的程序集命名为<code>xxx</code>，Editor命名为<code>xxx.Editor</code>，设置他们的平台和程序集引用，Editor程序集要引用Runtime程序集</p><h2 id="Changelog-md"><a href="http://Changelog.md">Changelog.md</a></h2><p>在根目录添加<code>CHANGELOG.md</code>，并按 <a href="https://keepachangelog.com/zh-CN/1.1.0/">Keep a Changelog</a>和 <a href="https://semver.org/lang/zh-CN/">Semantic Versioning</a>手动编写</p><h2 id="LICENSE-md"><a href="http://LICENSE.md">LICENSE.md</a></h2><p>在根目录添加<code>LICENSE.md</code>，并设定自己喜欢的开源协议</p><h2 id="Documentation～">Documentation～</h2><p>在根目录添加<code>Documentation～</code>文件夹，并在其中添加一些<code>.md</code>文件，用于描述包中功能</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Odin的Unity编辑器工具开发</title>
      <link href="/engine/UnityOdin/"/>
      <url>/engine/UnityOdin/</url>
      
        <content type="html"><![CDATA[<h1>基于Odin的Unity编辑器工具开发</h1><p><a href="https://assetstore.unity.com/packages/tools/utilities/odin-inspector-and-serializer-89041">Odin</a>是一个非常好用的Unity Editor工具开发框架，非常简洁，不过会被打入游戏包体内部</p><p>Odin使用起来非常简单，使用一些Attribute就可以暴露参数、按钮、生命周期函数，于是这里没有Odin基础教程，大部分是我自己的理解</p><h2 id="插件化示例">插件化示例</h2><blockquote><p>需求：插件化</p></blockquote><p>这是一个使用C# Attribute自动注册窗口的示例，通过对类进行标注，就可以自动添加到MenuWindow上，不需要改动Menu代码</p><p>你可以将这些文件打包成程序集（DLL），选择性加载，以此实现插件化</p><p><img src="/images/MainMenu.png" class="lazyload" data-srcset="/images/MainMenu.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="MainMenu"></p><h3 id="Attribute">Attribute</h3><p>Attribute是C#一个非常好用的功能，可以非常便捷地标注一个类</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class, AllowMultiple = false)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PanelAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PanelAttribute</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过添加新的Attribute类，可以分别添加到不同的Menu上</p><p>通过在Attribute中添加属性，可以存储更新信息，比如EditorIcon</p><h3 id="具体的Panel">具体的Panel</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Panel(<span class="string">&quot;Ragdoll&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RagdollPanel</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Title(<span class="string">&quot;Properties&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ShowInInspector</span>] <span class="keyword">public</span> <span class="built_in">int</span> AATime = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Panel(<span class="string">&quot;Bake&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BakePanel</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Title(<span class="string">&quot;Properties&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ShowInInspector</span>] <span class="keyword">public</span> <span class="built_in">int</span> test = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Menu-Window">Menu Window</h3><p>这里遍历的程序集中所有被<code>PanelAttribute</code>标注的类，创建出这些类的对象，并提取出Attribute内容</p><p><code>OdinMenuTree</code>将以侧边栏+内容的形式展示所有的窗口</p><p><code>MenuItem</code>用于在Editor顶部注册按钮，以便打开这个Menu</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainMenu</span> : <span class="title">OdinMenuEditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> OdinMenuTree <span class="title">BuildMenuTree</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> tree = <span class="keyword">new</span> OdinMenuTree();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> pluginTypes = Assembly.GetExecutingAssembly().GetTypes()</span><br><span class="line">            .Where(type =&gt; type.GetCustomAttributes(<span class="keyword">typeof</span>(PanelAttribute), <span class="literal">true</span>).Length &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> pluginType <span class="keyword">in</span> pluginTypes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> attribute = (PanelAttribute)Attribute.GetCustomAttribute(pluginType, <span class="keyword">typeof</span>(PanelAttribute));</span><br><span class="line">            <span class="keyword">var</span> instance = Activator.CreateInstance(pluginType);</span><br><span class="line">            tree.Add(attribute.Name, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;Tools/Baker Menu&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenWindow</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> window = GetWindow&lt;MainMenu&gt;();</span><br><span class="line">        window.position = GUIHelper.GetEditorWindowRect().AlignCenter(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听Http请求">监听Http请求</h2><blockquote><p>需求：使用Http请求操控Editor</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Panel(<span class="string">&quot;Web&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebPanel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread workerThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> stopFlag;      <span class="comment">// 用于停止工作线程</span></span><br><span class="line">    <span class="keyword">private</span> HttpListener listener;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">OnInspectorInit</span>]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        stopFlag = <span class="literal">false</span>;</span><br><span class="line">        listener = <span class="keyword">new</span> HttpListener();</span><br><span class="line">        listener.Prefixes.Add (<span class="string">&quot;http://localhost:7863/&quot;</span>);</span><br><span class="line">        listener.AuthenticationSchemes = AuthenticationSchemes.Anonymous;</span><br><span class="line">        listener.Start ();</span><br><span class="line">        workerThread = <span class="keyword">new</span> Thread(DoWork);</span><br><span class="line">        workerThread.Start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">OnInspectorDispose</span>]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">End</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;dispose&quot;</span>);</span><br><span class="line">        stopFlag = <span class="literal">true</span>;</span><br><span class="line">        listener.Close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoWork</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stopFlag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Debug.Log(&quot;working...&quot;);</span></span><br><span class="line">            <span class="keyword">var</span> result = listener.BeginGetContext(ListenerCallback, listener);</span><br><span class="line">            Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于反序列化request中的json</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionInput</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Arg &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ListenerCallback</span>(<span class="params">IAsyncResult result</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> context = listener.EndGetContext (result);</span><br><span class="line">        Debug.Log (<span class="string">&quot;Method: &quot;</span> + context.Request.HttpMethod);</span><br><span class="line">        <span class="built_in">string</span> url = context.Request.Url.LocalPath.ToString();</span><br><span class="line">        Debug.Log (<span class="string">&quot;LocalUrl: &quot;</span> + context.Request.Url.LocalPath);</span><br><span class="line">        <span class="comment">// 读请求中的json</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(context.Request.InputStream, context.Request.ContentEncoding))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> json = reader.ReadToEnd();</span><br><span class="line">            <span class="keyword">var</span> data = JsonConvert.DeserializeObject&lt;ActionInput&gt;(json);</span><br><span class="line">            Debug.Log(<span class="string">&quot;Data: &quot;</span> + data.Arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回一个json</span></span><br><span class="line">        <span class="keyword">if</span> (url == <span class="string">&quot;/test&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 匿名类型（Anonymous Type）</span></span><br><span class="line">            <span class="keyword">var</span> ro = <span class="keyword">new</span></span><br><span class="line">            &#123;</span><br><span class="line">                message = <span class="string">&quot;This is the response.&quot;</span>,</span><br><span class="line">                timestamp = DateTime.Now</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">string</span> jsonResponse = JsonConvert.SerializeObject(ro);</span><br><span class="line">            <span class="built_in">byte</span>[] buffer = System.Text.Encoding.UTF8.GetBytes(jsonResponse);</span><br><span class="line">            context.Response.ContentType = <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">            context.Response.ContentLength64 = buffer.Length;</span><br><span class="line">            context.Response.OutputStream.Write(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        context.Response.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求测试">请求测试</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://localhost:7863/test&quot;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;Arg&quot;</span>: <span class="string">&quot;这是一段测试文本&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, json=data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(response.json())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request failed with status code:&quot;</span>, response.status_code)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>&#x27;message&#x27;<span class="punctuation">:</span> &#x27;This is the response.&#x27;<span class="punctuation">,</span> &#x27;timestamp&#x27;<span class="punctuation">:</span> &#x27;<span class="number">2024</span><span class="number">-06</span><span class="number">-17</span>T14<span class="punctuation">:</span><span class="number">43</span><span class="punctuation">:</span><span class="number">25.1490146</span>+<span class="number">08</span><span class="punctuation">:</span><span class="number">00</span>&#x27;<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="访问主线程">访问主线程</h3><p>Web服务是跑在一个单独线程中，Unity Editor跑在主线程，于是Web服务无法调用很多API，可以使用<code>delayCall</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">EditorApplication.delayCall += () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    EditorApplication.isPlaying = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这个API还是有问题：Unity Editor在后台时，是不会刷新UI的，导致你必须点一下Editor窗口，或者一直保持在Editor窗口，才能正常运行</p><p>下面是另一个方法，我感觉更好</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Panel(<span class="string">&quot;Ragdoll&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RagdollPanel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizationContext mainThreadContext;</span><br><span class="line">    [<span class="meta">OnInspectorInit</span>]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        mainThreadContext = SynchronizationContext.Current;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ListenerCallback</span>(<span class="params">IAsyncResult result</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mainThreadContext.Post(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            EditorApplication.isPlaying = <span class="literal">true</span>;</span><br><span class="line">        &#125;, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> Unity </tag>
            
            <tag> Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 学习</title>
      <link href="/program/python%E5%AD%A6%E4%B9%A0/"/>
      <url>/program/python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>Python 学习</h1><blockquote><p>很难绷，编程四五年，现在才学Python</p></blockquote><p>Python是一门很简单的语言，但很多语法跟C++、C#不一样，一眼看上去发现好多不认识的东西，在此记录一下</p><h2 id="语法">语法</h2><h3 id="循环">循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">  <span class="built_in">print</span>(i)<span class="comment"># 0, 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure><p>循环指定范围</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">  <span class="built_in">print</span>(i)<span class="comment"># 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure><p>循环指定步进步长</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>):</span><br><span class="line">  <span class="built_in">print</span>(i)<span class="comment"># 0, 2, 4</span></span><br></pre></td></tr></table></figure><h3 id="索引">索引</h3><p>Python除了可以使用正向索引，还可以使用负向索引，表示为从最后一个元素开始倒着数，-1是最后一个元素</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])<span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>])<span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">1</span>])<span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">2</span>])<span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>这个功能常用于处理路径</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file_path = <span class="string">&quot;datasets/xa/xaa/a.json&quot;</span></span><br><span class="line">file_name = file_path.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]<span class="comment"># a.json</span></span><br></pre></td></tr></table></figure><h3 id="异常">异常</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">if</span> xxx:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;There is a error&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h4 id="assert">assert</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> &lt;一个<span class="built_in">bool</span>变量&gt;</span><br></pre></td></tr></table></figure><p>若条件为真，程序继续进行</p><p>若条件为假，程序抛出AssertionError异常，可以加一个参数信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> &lt;一个<span class="built_in">bool</span>变量&gt;, &lt;一个字符串参数&gt;</span><br></pre></td></tr></table></figure><h3 id="内置函数">内置函数</h3><h4 id="isinstance">isinstance</h4><p>用于判断一个对象是否是某种类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(data, <span class="type">List</span>):</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="面向对象">面向对象</h3><p>创建一个类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, student_name</span>):</span><br><span class="line">    self.name = student_name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self.name)</span><br></pre></td></tr></table></figure><h4 id="魔法方法">魔法方法</h4><p>python通关魔法方法（Magic Methods）为类提供一些机制，形如<code>__xxx__</code>的成员函数</p><ol><li>对象创建和销毁</li></ol><ul><li><strong><code>__new__</code></strong>：在对象创建之前调用，用于控制对象的创建过程。</li><li><strong><code>__init__</code></strong>：在对象创建后调用，用于初始化对象的属性。</li><li><strong><code>__del__</code></strong>：在对象被销毁时调用，用于清理资源。</li></ul><ol start="2"><li>字符串表示</li></ol><ul><li><strong><code>__str__</code></strong>：返回对象的字符串表示，用于 <code>print()</code> 函数。</li><li><strong><code>__repr__</code></strong>：返回对象的字符串表示，用于调试和开发。</li></ul><ol start="3"><li>序列操作</li></ol><ul><li><strong><code>__len__</code></strong>：返回对象的长度，用于 <code>len()</code> 函数。</li><li><strong><code>__getitem__</code></strong>：获取对象中指定键的值，用于索引操作。</li><li><strong><code>__setitem__</code></strong>：设置对象中指定键的值，用于赋值操作。</li><li><strong><code>__delitem__</code></strong>：删除对象中指定键的值，用于删除操作。</li></ul><ol start="4"><li>迭代器</li></ol><ul><li><strong><code>__iter__</code></strong>：返回一个可迭代对象，用于 <code>for</code> 循环。</li><li><strong><code>__next__</code></strong>：返回下一个迭代器对象，用于 <code>next()</code> 函数。</li></ul><ol start="5"><li>运算符重载</li></ol><ul><li><strong><code>__add__</code></strong>：定义加法运算符。</li><li><strong><code>__sub__</code></strong>：定义减法运算符。</li><li><strong><code>__mul__</code></strong>：定义乘法运算符。</li><li><strong><code>__div__</code></strong>：定义除法运算符。</li><li><strong><code>__eq__</code></strong>：定义等于运算符。</li><li><strong><code>__ne__</code></strong>：定义不等于运算符。</li><li><strong><code>__lt__</code></strong>：定义小于运算符。</li><li><strong><code>__le__</code></strong>：定义小于等于运算符。</li><li><strong><code>__gt__</code></strong>：定义大于运算符。</li><li><strong><code>__ge__</code></strong>：定义大于等于运算符。</li></ul><ol start="6"><li>属性访问</li></ol><ul><li><strong><code>__getattr__</code></strong>：当访问不存在的属性时调用。</li><li><strong><code>__getattribute__</code></strong>：拦截所有的属性访问。</li><li><strong><code>__setattr__</code></strong>：拦截所有属性的赋值操作。</li><li><strong><code>__delattr__</code></strong>：拦截所有属性的删除操作。</li></ul><ol start="7"><li>上下文管理</li></ol><ul><li><strong><code>__enter__</code></strong>：在 <code>with</code> 语句开始时调用。</li><li><strong><code>__exit__</code></strong>：在 <code>with</code> 语句结束时调用。</li></ul><ol start="8"><li>可调用对象</li></ol><ul><li><strong><code>__call__</code></strong>：允许对象像函数一样被调用</li></ul><h3 id="装饰器">装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># @staticmethod 装饰器可以将一个函数变成静态函数，可以用类名+函数名直接访问，不依赖某个成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmbeddingLayer</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">embed</span>(<span class="params"><span class="built_in">input</span>, basis</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">EmbeddingLayer.embed(input_tensor, basis_matrix)</span><br></pre></td></tr></table></figure><h3 id="高阶函数">高阶函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个数字列表</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 map() 函数将 square() 函数应用于 numbers 列表中的每个元素</span></span><br><span class="line">squared_numbers = <span class="built_in">map</span>(square, numbers)</span><br></pre></td></tr></table></figure><h2 id="容器">容器</h2><h3 id="set">set</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个set</span></span><br><span class="line">dataset = <span class="built_in">set</span>()</span><br><span class="line">key = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="comment"># 添加一个元素</span></span><br><span class="line">dataset.add(key)</span><br><span class="line"><span class="comment"># 判断元素是否在set中</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> dataset:</span><br><span class="line">  <span class="built_in">print</span>(key)</span><br><span class="line">  <span class="comment"># 将这个元素从set中移除</span></span><br><span class="line">  dataset.discard(key)</span><br></pre></td></tr></table></figure><h3 id="list">list</h3><h4 id="切片">切片</h4><p>Python可以使用切片操作，从一个序列（如列表、元组或字符串）中获取一部分元素</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(numbers[:<span class="number">2</span>])  <span class="comment"># 输出：[0, 1]</span></span><br><span class="line">s = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">2</span>])  <span class="comment"># 输出：&#x27;He&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="列表推导式">列表推导式</h4><blockquote><p>List Comprehension</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raw = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ans = [x-<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> raw]<span class="comment"># ans = [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">input</span> = <span class="string">&quot;&lt;h1&gt;&lt;h3&gt;&lt;h5&gt;&lt;h7&gt;&quot;</span></span><br><span class="line">pattern = <span class="string">r&#x27;&lt;h(\d+)&gt;&#x27;</span></span><br><span class="line">token_lst = [<span class="built_in">int</span>(<span class="keyword">match</span>) <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> re.findall(pattern, <span class="built_in">input</span>)]</span><br><span class="line"><span class="comment"># token_lst = [1, 3, 5, 7]</span></span><br></pre></td></tr></table></figure><h3 id="dict">dict</h3><h4 id="判断Dict中有无Key">判断Dict中有无Key</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;key_name&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">  xxx</span><br></pre></td></tr></table></figure><h2 id="关键词">关键词</h2><h3 id="with">with</h3><p>很类似C#的using，用于打开文件，期间代码出现异常会正常关闭，加载的文件也会被关闭释放</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  content = f.read()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  content = json.loads(f)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">  <span class="built_in">print</span>(line.strip())</span><br></pre></td></tr></table></figure><h2 id="字符串">字符串</h2><h3 id="前缀">前缀</h3><p>Python的字符串可以使用前缀表示某个格式和行为</p><h4 id="原始字符串">原始字符串</h4><p>转义字符将会被视为普通字符，常用于正则表达式和Windwos下文件路径</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正则</span></span><br><span class="line">pattern = <span class="string">r&quot;\d+&quot;</span></span><br><span class="line"><span class="comment"># Windows路径</span></span><br><span class="line">path = <span class="string">r&quot;C:\Users\Admin\Documents&quot;</span></span><br></pre></td></tr></table></figure><h4 id="格式化字符串">格式化字符串</h4><p>可以用<code>{}</code>来嵌入Python表达式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">str2 = <span class="string">f&#x27;str1: <span class="subst">&#123;str1&#125;</span>&#x27;</span><span class="comment"># str1: Hello</span></span><br></pre></td></tr></table></figure><h4 id="字节字符串">字节字符串</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">b&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="匹配">匹配</h3><h4 id="endswith">endswith</h4><p>可以用元组实现多种匹配</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> str1.endswith((<span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;.png&#x27;</span>)):</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="格式化数字">格式化数字</h3><p>在按顺序输出文件名时，经常有格式化数字的需求</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">12</span></span><br><span class="line">formatted_str = <span class="string">f&quot;<span class="subst">&#123;num:04d&#125;</span>&quot;</span><span class="comment"># 0012</span></span><br><span class="line"></span><br><span class="line">f = <span class="number">1.2222</span></span><br><span class="line">formatted_str_f = <span class="string">f&quot;<span class="subst">&#123;f:<span class="number">.02</span>f&#125;</span>&quot;</span><span class="comment"># 1.22</span></span><br></pre></td></tr></table></figure><h2 id="常用库">常用库</h2><h3 id="自定义文件">自定义文件</h3><p>从自定义的python文件中import函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前python的同级目录下有一个utils.py文件，文件中定义了一个load_models函数</span></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> load_models</span><br></pre></td></tr></table></figure><p>也可以将当前文件添加到sys路径中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">current_dir = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">sys.path.append(current_dir)</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> load_models</span><br></pre></td></tr></table></figure><h3 id="sys">sys</h3><p>传递参数，跟C++ main函数的argv意义相同</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># python a1 a2</span></span><br><span class="line">a1 = sys.argv[<span class="number">1</span>]<span class="comment"># a1</span></span><br><span class="line">a2 = sys.argv[<span class="number">2</span>]<span class="comment"># a2</span></span><br></pre></td></tr></table></figure><h3 id="os">os</h3><h4 id="遍历目录">遍历目录</h4><p>访问文件夹下所有文件（递归遍历子文件夹）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        file_path = os.path.join(dirpath, filename)</span><br><span class="line">    <span class="comment"># 打开 file_path</span></span><br></pre></td></tr></table></figure><h4 id="得到文件所在文件夹">得到文件所在文件夹</h4><p>不存在就创建文件夹</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp_folder = os.path.dirname(out_path)</span><br><span class="line">os.makedirs(temp_folder, exist_ok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="unset-http-proxy">unset http proxy</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.environ.pop(<span class="string">&quot;http_proxy&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">os.environ.pop(<span class="string">&quot;https_proxy&quot;</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h4 id="添加文件夹">添加文件夹</h4><p>可以import某个文件夹下的文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libpath = os.path.abspath(</span><br><span class="line">    os.path.join(</span><br><span class="line">        os.path.dirname(os.path.abspath(__file__)),</span><br><span class="line">        <span class="string">&quot;step_align&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(libpath):</span><br><span class="line">    <span class="keyword">if</span> libpath <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">        sys.path.insert(<span class="number">0</span>, libpath)</span><br><span class="line"><span class="keyword">from</span> local_file <span class="keyword">import</span> custom_class</span><br></pre></td></tr></table></figure><h3 id="zipfile">zipfile</h3><p>python可以在不解压文件的情况下读取文件内容</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="comment"># zip</span></span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">f&#x27;<span class="subst">&#123;file_name&#125;</span>.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">  <span class="keyword">for</span> name <span class="keyword">in</span> zip_ref.namelist():</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    content = zip_ref.read(name).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="tarfile">tarfile</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="comment"># tar</span></span><br><span class="line"><span class="keyword">with</span> tarfile.<span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;file_name&#125;</span>.tar&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> tar_ref:</span><br><span class="line">  <span class="comment"># 遍历包内所有文件</span></span><br><span class="line">  <span class="keyword">for</span> member <span class="keyword">in</span> tar_ref.getmembers():</span><br><span class="line">    <span class="comment"># 压缩包中可能不是文件，而是文件夹</span></span><br><span class="line">    <span class="keyword">if</span> member.isfile():</span><br><span class="line">      <span class="comment"># 打印文件名</span></span><br><span class="line">    <span class="built_in">print</span>(member.name)</span><br><span class="line">    <span class="comment"># 使用文件名直接读文件内容</span></span><br><span class="line">    content = tar_ref.extractfile(member).read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">      <span class="comment"># 将文件解压到extract_dir文件夹下</span></span><br><span class="line">      tar_ref.extract(member, path=extract_dir)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># 将target_folder整个压缩</span></span><br><span class="line"><span class="keyword">with</span> tarfile.<span class="built_in">open</span>(new_tar_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> tar:</span><br><span class="line">        <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(target_folder):</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">                file_path = os.path.join(root, file)</span><br><span class="line">                tar.add(file_path, arcname=os.path.join(os.path.basename(root), file))</span><br><span class="line"><span class="comment"># 删除target_folder</span></span><br><span class="line">shutil.rmtree(target_folder)</span><br></pre></td></tr></table></figure><h3 id="发起进程">发起进程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">script_path = <span class="string">&#x27;inference.py&#x27;</span></span><br><span class="line">arguments = [<span class="string">&#x27;-s&#x27;</span>, <span class="string">&#x27;assets/examples/source/hal.jpeg&#x27;</span>, <span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;assets/temp/sun.mp4&#x27;</span>, <span class="string">&#x27;--flag_normalize_lip&#x27;</span>]</span><br><span class="line">subprocess.call([<span class="string">&#x27;python&#x27;</span>, script_path] + arguments)</span><br></pre></td></tr></table></figure><h3 id="pkl">pkl</h3><p>将参数存储为二进制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_pkl_file</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        data = pickle.load(file)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_pkl_file</span>(<span class="params">file_path, data</span>):</span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    pickle.dump(data, file)</span><br></pre></td></tr></table></figure><h3 id="random">random</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成随机数</span></span><br><span class="line">ans = random.uniform(c_min, c_max)</span><br><span class="line"><span class="comment"># 随机整数</span></span><br><span class="line">n = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 从数组中随机挑选500条不重复的</span></span><br><span class="line">select_list = random.sample(raw_list, <span class="number">500</span>)</span><br></pre></td></tr></table></figure><h3 id="json">json</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读字符串为json</span></span><br><span class="line">data = json.loads(input_text)</span><br><span class="line"><span class="comment"># 对象转为字符串</span></span><br><span class="line">json_str = json.dumps(data)</span><br><span class="line"><span class="comment"># 从文件中加载json</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xx.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  data = json.load(f)</span><br><span class="line"><span class="comment"># 写json到文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xx.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  json.dump(data, f, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="moviepy">moviepy</h3><p>moviepy是一个处理视频和音频的库</p><h4 id="为视频配音">为视频配音</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">video = mp.VideoFileClip(<span class="string">&quot;1.mp4&quot;</span>)</span><br><span class="line">audio = mp.AudioFileClip(<span class="string">&quot;2.mp3&quot;</span>)</span><br><span class="line">video = video.set_audio(audio)</span><br><span class="line">video.write_videofile(<span class="string">&quot;3.mp4&quot;</span>, codec=<span class="string">&quot;libx264&quot;</span>, audio_codec=<span class="string">&quot;aac&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="opencv">opencv</h3><h4 id="查看视频帧率">查看视频帧率</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开视频文件</span></span><br><span class="line">video_path = <span class="string">&#x27;s18.mp4&#x27;</span></span><br><span class="line">cap = cv2.VideoCapture(video_path)</span><br><span class="line"><span class="comment"># 获取视频的帧率</span></span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;视频的帧率为：<span class="subst">&#123;fps&#125;</span> FPS&#x27;</span>)</span><br><span class="line"><span class="comment"># 释放资源</span></span><br><span class="line">cap.release()</span><br></pre></td></tr></table></figure><h3 id="plt">plt</h3><h4 id="折线图">折线图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制折线图</span></span><br><span class="line">plt.plot(x, y, marker=<span class="string">&#x27;o&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, label=<span class="string">&#x27;line&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题和刻度标签</span></span><br><span class="line">plt.title(<span class="string">&#x27;Graph&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Frame&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Value&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示折线的名字</span></span><br><span class="line"><span class="comment"># plt.legend()</span></span><br><span class="line"><span class="keyword">if</span> enable_save:</span><br><span class="line">  <span class="comment"># 将图表保存为文件</span></span><br><span class="line">    plt.savefig(<span class="string">f&#x27;<span class="subst">&#123;file_name&#125;</span>.png&#x27;</span>, dpi=<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图表（如果不是headless）</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="散点图">散点图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value_x = []</span><br><span class="line">value_y = []</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 绘制散点图</span></span><br><span class="line">plt.scatter(value_x, value_y)</span><br><span class="line"><span class="comment"># 绘制文本</span></span><br><span class="line">plt.text(<span class="number">0</span>, p5, <span class="string">f&#x27;P5: <span class="subst">&#123;p5:<span class="number">.2</span>f&#125;</span>&#x27;</span>, fontsize=<span class="number">20</span>, verticalalignment=<span class="string">&#x27;bottom&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>, ha=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制线</span></span><br><span class="line">plt.axhline(y=p5, color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="comment"># 布局风格</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;output.png&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="联合图表">联合图表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个2x2的联合图表</span></span><br><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">14</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].scatter(xx, yy)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].set_title(<span class="string">&#x27;title 1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].scatter(xx, yy)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].set_title(<span class="string">&#x27;title 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].scatter(xx, yy)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].set_ylabel(<span class="string">&#x27;ye&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].set_title(<span class="string">&#x27;title 3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].scatter(xx, yy)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].set_title(<span class="string">&#x27;title 4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">&#x27;output.png&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="numpy">numpy</h3><h4 id="求百分位数">求百分位数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p5 = np.percentile(speed, <span class="number">5</span>)</span><br><span class="line">p50 = np.percentile(speed, <span class="number">50</span>)</span><br><span class="line">p95 = np.percentile(speed, <span class="number">95</span>)</span><br></pre></td></tr></table></figure><h4 id="mask">mask</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr = np.array(rates)</span><br><span class="line">mask = arr &gt; 0.05</span><br><span class="line">count = mask.sum()<span class="comment"># 统计数组rates中大于0.05的值的数量</span></span><br></pre></td></tr></table></figure><h4 id="unique">unique</h4><p>从arr中提取唯一值（去除数组中重复元素，可以用于判断数组中出现了哪些数，可以用来判断数组是否全是01）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ans = np.unique(arr)</span><br></pre></td></tr></table></figure><h3 id="ffmpeg">ffmpeg</h3><h4 id="文件类型转换">文件类型转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">m4s_to_mp3</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    ffmpeg_command = [</span><br><span class="line">        <span class="string">&quot;ffmpeg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-i&quot;</span>, input_file,</span><br><span class="line">        <span class="string">&quot;-acodec&quot;</span>, <span class="string">&quot;libmp3lame&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-q:a&quot;</span>, <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        output_file</span><br><span class="line">    ]</span><br><span class="line">    subprocess.run(ffmpeg_command, check=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">m4s_to_mp3(<span class="string">&#x27;a.m4s&#x27;</span>, <span class="string">&#x27;a.mp3&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="视频左右拼接">视频左右拼接</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 101.mp4 -i o101.mp4 -filter_complex <span class="string">&quot;[0:v]pad=iw*2:ih[a];[a][1:v]overlay=w&quot;</span> c101.mp4</span><br></pre></td></tr></table></figure><h3 id="tqdm">tqdm</h3><p>用于显示进度条</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">100</span>)):</span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><h3 id="datasets">datasets</h3><p>Hugging face的数据类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> Dataset, load_from_disk</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 将jsonl保存为hf datasets</span></span><br><span class="line">name = <span class="string">&#x27;combine&#x27;</span></span><br><span class="line">df = pd.read_json(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>.jsonl&quot;</span>, lines=<span class="literal">True</span>)</span><br><span class="line">dataset = Dataset.from_pandas(df)</span><br><span class="line">dataset.save_to_disk(name)</span><br><span class="line"><span class="comment"># 加载hf datasets</span></span><br><span class="line">loaded_dataset = load_from_disk(name)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(loaded_dataset))</span><br><span class="line"><span class="built_in">print</span>(loaded_dataset[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="argparse">argparse</h3><p>处理输入参数，自动转化为变量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--input_folder&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;The folder path to the dataset&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--detail&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Print detailed information&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--max_steps&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">2000000</span>, <span class="built_in">help</span>=<span class="string">&#x27;Max steps&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 互斥组参数</span></span><br><span class="line">group = parser.add_mutually_exclusive_group()</span><br><span class="line">group.add_argument(<span class="string">&quot;--mode1&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;启用模式 1&quot;</span>)</span><br><span class="line">group.add_argument(<span class="string">&quot;--mode2&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;启用模式 2&quot;</span>)</span><br><span class="line">group.add_argument(<span class="string">&quot;--mode3&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;启用模式 3&quot;</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.detail:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The input folder is:&#x27;</span>, args.input_folder)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The max steps is:&#x27;</span>, args.max_steps)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The input folder is:&#x27;</span>, args.input_folder)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python parser_test.py --input_folder ./ --detail --max_steps <span class="number">10</span> </span><br><span class="line">python parser_test.py --input_folder ./ --max_steps <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="imap">imap</h3><p>基于multiprocessing的并行处理代码</p><blockquote><p>小技巧，如果我有一个巨大的dict，直接遍历处理会超内存，被Killed。可以将key转为哈希，根据dict的大小取哈希的前两三位，将dict摊开，再做处理</p></blockquote><h4 id="处理数组">处理数组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">item</span>):</span><br><span class="line">    index, name = item</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;hash_split/<span class="subst">&#123;name&#125;</span>&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            info = json.loads(line.strip())</span><br><span class="line">            ...</span><br><span class="line">    <span class="keyword">return</span> item    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = []</span><br><span class="line">    root_dir = <span class="string">&#x27;hash_split&#x27;</span><span class="comment"># 这个文件存储了被哈希切分的jsonl们</span></span><br><span class="line">    <span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.jsonl&#x27;</span>):</span><br><span class="line">                data.append(filename)</span><br><span class="line">    <span class="comment"># 并行处理            </span></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">16</span>)</span><br><span class="line">    processed_data_iterator = tqdm(pool.imap(process_item, <span class="built_in">enumerate</span>(data)), total=<span class="built_in">len</span>(data))</span><br><span class="line">    processed_data = <span class="built_in">list</span>(processed_data_iterator)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><h4 id="处理dict">处理dict</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理dict</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">item</span>):</span><br><span class="line">    key, value = item</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> item    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="comment"># 并行处理            </span></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">16</span>)</span><br><span class="line">    processed_data_iterator = tqdm(pool.imap(process_item, data.items()), total=<span class="built_in">len</span>(data))</span><br><span class="line">    processed_data = <span class="built_in">list</span>(processed_data_iterator)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><h4 id="带参数">带参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">item, args</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  datas = []</span><br><span class="line">  pool = multiprocessing.Pool(<span class="number">16</span>)</span><br><span class="line">    partial_process_item = functools.partial(process_item, args=args)</span><br><span class="line">    processed_data_iterator = tqdm(pool.imap(partial_process_item, datas), total=<span class="built_in">len</span>(datas), desc=<span class="string">&quot;Process&quot;</span>)</span><br><span class="line">    result_list = <span class="built_in">list</span>(processed_data_iterator)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><h4 id="实时更新">实时更新</h4><p>对于一些执行速度很慢的任务，经常发现tqdm的更新不够及时。这是因为<code>imap</code>要保证按顺序完成执行，如果对顺序要求不那么强烈，可以使用<code>imap_unordered</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">processed_data_iterator = tqdm(pool.imap_unordered(partial_process_item, datas), total=<span class="built_in">len</span>(datas), desc=<span class="string">&quot;Process&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="全局初始化参数">全局初始化参数</h4><p>一些参数不好传入，可以初始化后放在全局</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_init_cache_set</span>(<span class="params">shared_cache_set</span>):</span><br><span class="line">    <span class="keyword">global</span> _CACHE_SET</span><br><span class="line">    _CACHE_SET = shared_cache_set</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  cache_set = <span class="built_in">set</span>(cache_data)</span><br><span class="line">  filter_pool = multiprocessing.Pool(processes=<span class="number">32</span>, initializer=_init_cache_set, initargs=(cache_set,))</span><br></pre></td></tr></table></figure><h3 id="curl">curl</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curl http://xxx/v1/api -X POST  -H  <span class="string">&quot;Content-Type: application/json&quot;</span>  -d <span class="string">&#x27;&#123;&quot;text&quot;: [&quot;1&quot;, &quot;2&quot;]&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://xxx/v1/api&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(url, headers=headers, json=data)</span><br></pre></td></tr></table></figure><h3 id="torchaudio">torchaudio</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchaudio</span><br><span class="line"><span class="comment"># 从路径加载音频</span></span><br><span class="line">waveform, sample_rate = torchaudio.load(file_path)</span><br><span class="line"><span class="comment"># 获得音频时长，单位为秒</span></span><br><span class="line">duration = waveform.shape[<span class="number">1</span>] / sample_rate</span><br></pre></td></tr></table></figure><h3 id="warnings">warnings</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="dataclass">dataclass</h3><p>更方便定义一个数据类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProcessConfig</span>:</span><br><span class="line">    batch_size = <span class="number">32</span></span><br><span class="line">    save_folder = <span class="string">&quot;/tmp&quot;</span></span><br></pre></td></tr></table></figure><h3 id="hashlib">hashlib</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用md5生成字符串的16进制哈希</span></span><br><span class="line">hash_object = hashlib.new(<span class="string">&quot;md5&quot;</span>)</span><br><span class="line">hash_object.update(lyrics.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">hex_hash = hash_object.hexdigest()</span><br><span class="line"><span class="built_in">print</span>(hex_hash)</span><br></pre></td></tr></table></figure><h3 id="datetime">datetime</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line">current_time = time.time()</span><br><span class="line">local_datetime = datetime.fromtimestamp(current_time)</span><br><span class="line"><span class="built_in">print</span>(local_datetime)</span><br></pre></td></tr></table></figure><h3 id="trimesh">trimesh</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将GLB文件转为obj、mtl、贴图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> trimesh</span><br><span class="line">mesh = trimesh.load(glb_path)</span><br><span class="line"><span class="comment"># 检查是否为场景（多网格）</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(mesh, trimesh.Scene):</span><br><span class="line">    mesh = mesh.dump(concatenate=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 导出为 OBJ</span></span><br><span class="line">mesh.export(obj_path)</span><br></pre></td></tr></table></figure><blockquote><p>如果没能导出图片，那么更新一下包 <code>pip install --upgrade trimesh pillow imageio</code></p></blockquote><h3 id="PIL">PIL</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(path)</span><br><span class="line">image.save(<span class="string">&#x27;output.png&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="base64">base64</h3><p>将图片转为base64</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image_to_base64</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="comment"># 打开图片</span></span><br><span class="line">    <span class="keyword">with</span> Image.<span class="built_in">open</span>(image_path) <span class="keyword">as</span> img:</span><br><span class="line">        <span class="comment"># 将图片转换为字节流</span></span><br><span class="line">        buffered = BytesIO()</span><br><span class="line">        img.save(buffered, <span class="built_in">format</span>=<span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">        <span class="comment"># 将字节流转换为 base64 编码</span></span><br><span class="line">        img_base64 = base64.b64encode(buffered.getvalue()).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> img_base64</span><br></pre></td></tr></table></figure><h3 id="dataset">dataset</h3><p>huggingface提供的数据集类型，非常轻量，整个数据集的核心是<code>metadata.jsonl</code>，形如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_dataset/</span><br><span class="line">├── 001.jpg</span><br><span class="line">├── 002.jpg</span><br><span class="line">└── metadata.jsonl</span><br></pre></td></tr></table></figure><p>metadata.jsonl格式为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;file_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;001.jpg&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;prompt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="number">2560</span><span class="punctuation">,</span> <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">3581</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;file_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;002.jpg&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;prompt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="number">2560</span><span class="punctuation">,</span> <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">3581</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>你可以为这个jsonl添加各种keys</p><h4 id="下载">下载</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> huggingface_hub <span class="keyword">import</span> snapshot_download</span><br><span class="line"></span><br><span class="line">local_dir = <span class="string">&quot;./my_dataset&quot;</span></span><br><span class="line">snapshot_download(</span><br><span class="line">    <span class="string">&quot;Reuben-Sun/dataset-name&quot;</span>,</span><br><span class="line">    local_dir=local_dir, repo_type=<span class="string">&quot;dataset&quot;</span>,</span><br><span class="line">    ignore_patterns=<span class="string">&quot;.gitattributes&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="加载">加载</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line">dataset = load_dataset(path=<span class="string">&quot;imagefolder&quot;</span>, data_dir=<span class="string">&quot;my_dataset&quot;</span>)</span><br><span class="line">train_dataset = dataset[<span class="string">&#x27;train&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li><code>imagefolder</code>：数据集类型为<code>imagefolder</code></li></ul><h3 id="huggingface-hub">huggingface_hub</h3><h4 id="下载某个库的某些文件">下载某个库的某些文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> huggingface_hub <span class="keyword">import</span> hf_hub_download, login</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">repo_id = <span class="string">&quot;black-forest-labs/FLUX.1-dev&quot;</span></span><br><span class="line">files_to_download = [<span class="string">&quot;flux1-dev.safetensors&quot;</span>, <span class="string">&quot;ae.safetensors&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定下载目录</span></span><br><span class="line">download_dir = <span class="string">&quot;./flux_models&quot;</span></span><br><span class="line">os.makedirs(download_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载指定文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files_to_download:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Downloading <span class="subst">&#123;file&#125;</span>...&quot;</span>)</span><br><span class="line">    hf_hub_download(</span><br><span class="line">        repo_id=repo_id,</span><br><span class="line">        filename=file,</span><br><span class="line">        local_dir=download_dir,</span><br><span class="line">        local_dir_use_symlinks=<span class="literal">False</span>  <span class="comment"># 确保直接下载文件，而不是符号链接</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;file&#125;</span> downloaded to <span class="subst">&#123;download_dir&#125;</span>/<span class="subst">&#123;file&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="其他操作">其他操作</h2><h3 id="找到site-packages">找到site-packages</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.sysconfig <span class="keyword">import</span> get_python_lib</span><br><span class="line"><span class="built_in">print</span>(get_python_lib())</span><br></pre></td></tr></table></figure><h3 id="pip">pip</h3><h4 id="requirements-txt">requirements.txt</h4><p>下载requirements.txt</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>生成</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipreqs ./ --encoding=utf8  --force</span><br></pre></td></tr></table></figure><h4 id="可编辑模式">可编辑模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -e /path/to/my_package</span><br></pre></td></tr></table></figure><p>选择一个本地python包路径，使用-e的pip，这个包内容会被链接到python环境中，对包内容的更改会实时影响python环境里的包内容，便于bao</p><h4 id="whl">whl</h4><p>安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install xxx.whl</span><br></pre></td></tr></table></figure><p>生成whl（要求项目根目录有setup.py文件），执行后dist目录下就会有whl文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python setup.py bdist_wheel</span><br></pre></td></tr></table></figure><h3 id="以包的形式运行">以包的形式运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m &lt;package name&gt;.&lt;file name&gt;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &lt;package folder&gt;</span><br><span class="line">python3 &lt;file name&gt;.py</span><br></pre></td></tr></table></figure><p>但这种调用方式可以用<code>.</code>和<code>..</code>，import包</p><h3 id="bash">bash</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> music_type=<span class="string">&quot;song&quot;</span></span><br><span class="line"><span class="built_in">export</span> model_name=<span class="string">&quot;llama3.1&quot;</span></span><br><span class="line"><span class="built_in">export</span> retry_count=5</span><br><span class="line"></span><br><span class="line">python3 call.py --music_type <span class="variable">$music_type</span> --model_name <span class="variable">$model_name</span> --retry_count <span class="variable">$retry_count</span></span><br></pre></td></tr></table></figure><h2 id="调试">调试</h2><h3 id="IPython">IPython</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython <span class="keyword">import</span> embed</span><br><span class="line">embed()</span><br></pre></td></tr></table></figure><h3 id="pdb">pdb</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">pdb.set_trace()</span><br></pre></td></tr></table></figure><h3 id="traceback">traceback</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能出错的代码</span></span><br><span class="line">    result = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 打印完整的错误信息和堆栈跟踪</span></span><br><span class="line">    traceback.print_exc()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 或者获取错误信息字符串</span></span><br><span class="line">    error_msg = traceback.format_exc()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;错误信息:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(error_msg)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>崩铁银河战士like同人游戏</title>
      <link href="/game/%E5%B4%A9%E9%93%81%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike%E5%90%8C%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
      <url>/game/%E5%B4%A9%E9%93%81%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike%E5%90%8C%E4%BA%BA%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1>崩铁银河战士like同人游戏</h1><p>看到崩铁的萨姆第一眼，就感觉这个角色很帅，了解了剧情背景，感觉很适合做成银河战士类的游戏，定位是同人游戏，主要是为了讲故事，玩法基本“抄袭”银河战士</p><p>其实我感觉萨姆角色设计应该有参考银河战士</p><table><thead><tr><th></th><th>银河战士</th><th>星穹铁道</th></tr></thead><tbody><tr><td>名字</td><td>萨姆斯</td><td>萨姆（流萤）</td></tr><tr><td>性别</td><td>女</td><td>女</td></tr><tr><td>任务</td><td>对抗寄生怪物</td><td>对抗繁育虫群</td></tr><tr><td>称号</td><td>银河战士</td><td>星核猎手</td></tr></tbody></table><h2 id="游戏背景">游戏背景</h2><blockquote><p>考虑到流萤还没正式上线，相关的文本很少，游戏剧情纯属我个人意淫，就当我是虚构史学派在构史吧</p></blockquote><p>游戏时间是帝国和虫群还在战斗时，虫群袭击了养育间，为了抵抗虫群，研究员释放了尚未成熟的铁骑（也就是主角），主角此时缺少力量，但通过与虫群的厮杀，吸收了很多繁育的力量，最后冲出重围，消灭了虫群，存活下来</p><p>主旨就是<strong>求生</strong>，主角以错误的形式诞生，但是充满着对生命的渴望，她不想死，于是与虫群作战。在虫群作战中，看到到处的尸体与牺牲，深刻理解了<strong>飞萤扑火，向死而生</strong>。战斗结束后又了解自己天生患有失熵症，于是踏上了寻找生命意义的道路，为自己取名<strong>流萤</strong></p><h2 id="角色设计">角色设计</h2><p>玩家游玩的是萨姆，主要是想要体验<strong>战斗，爽</strong>，只会设计很少的能力锁，玩家的任务不是探索地宫，而是从地宫逃出，于是非必要不会回溯探索</p><h3 id="能力">能力</h3><ul><li>上勾拳，可以触发防反（玩过银河战士的应该都知道）</li><li>踢击，向前踢出一个较长的踢击，用于开门、破环墙壁（功能类似银河战士中开门打墙的导弹）<ul><li>火焰踢击，补充能量后可以进行一次伤害巨大的踢击，能伤害到一些强大生物（参考银河战士生存恐惧中蓝色激光炮）</li></ul></li><li>能量，将银河战士的电量和导弹合并，可以通过攻击敌人、安全屋补充</li><li>护盾，额外的护盾条，一段时间不受伤自动快速恢复</li><li>镭射，消耗能量的远距离光束攻击，有穿透能力</li><li>跳跃<ul><li>原地起跳后左右移动能力很弱</li><li>跑跳后在空中可以进行翻滚，以跳的更远</li><li>空中转向会导致速度衰减</li></ul></li><li>抓墙<ul><li>主角可以单手抓住一个平台，再按跳跃会上平台</li><li>抓墙时可以发射镭射</li></ul></li><li>冲刺，向前冲刺，有CD<ul><li>地面上冲刺类似银河战士的瞬移，对boss战很有帮助</li><li>空中冲刺类似蔚蓝的二段跳</li></ul></li><li>隐身，消耗能量短暂隐身，可以躲避一些怪物的视线</li></ul><h3 id="进阶能力">进阶能力</h3><p>思考中</p><h2 id="关卡设计">关卡设计</h2><h3 id="门">门</h3><ul><li>正常工作的门，靠近即可开门</li><li>一些毁坏的门，可以被踢击破坏</li><li>一些被虫群腐蚀的门，靠近就会关掉，需要隐身走过（这些门后面的房屋有虫子的核心，击破后腐蚀门就会变成普通的被毁坏的门</li></ul><h3 id="单向门">单向门</h3><ul><li>一些门是一次性的，走过后就会关闭，断我们后路</li></ul><h3 id="可破坏墙壁">可破坏墙壁</h3><ul><li>一些由虫群尸体组成的墙壁，可以被踢击、镭射破坏</li><li>一些虫群的尸体组成的地板，踩上会直接破坏，但不能被踢击镭射破坏</li><li>一些坚固的虫群尸体组成的墙壁，需要用地面冲刺破坏</li></ul><h2 id="流程设计">流程设计</h2><p>像生存恐惧结尾逃出生天的流程，地宫是线性分层的，主角出生在最底层，想要到达地面</p><p>当主角击败一层boss时，这一层会坍塌、破坏、被岩浆淹没（总之几乎不能回到这一层）</p><h2 id="开发日志">开发日志</h2><h3 id="5-19">5.19</h3><p>跳跃手感很难调整，而且不清楚改如何制作攻击动画，我希望攻击时人物会进行移动，我最初没有使用Apply Root Motion，现在看来是有问题的</p><p>有人建议我说，除了跑步这种Loop的动画外，其他动画都应该Apply Root Motion</p><p>我这个项目有一点很特殊，会有大量的跳跃，我感觉我的跳跃也应该是In Place Loop的</p><p>感觉要研究一下Blender 3D动画制作</p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity 加载文件</title>
      <link href="/engine/Unity%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/engine/Unity%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1>Unity 加载文件</h1><p>当我们在使用Unity制作一些程序时，往往需要从磁盘中运行时加载一些资产，而非提前放进Assets中，打进包体里</p><h2 id="加载贴图">加载贴图</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> rootPath = Path.GetDirectoryName(Path.GetDirectoryName(Application.dataPath));</span><br><span class="line"><span class="built_in">string</span> uvPath = Path.Combine(rootPath, <span class="string">&quot;uv.png&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (File.Exists(uvPath))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] fileData = System.IO.File.ReadAllBytes(uvmapPath);</span><br><span class="line">    Texture2D uvmap = <span class="keyword">new</span> Texture2D(<span class="number">2048</span>, <span class="number">2048</span>);</span><br><span class="line">    uvmap.LoadImage(fileData);</span><br><span class="line">    Shader.SetGlobalTexture(<span class="string">&quot;_GlobalTexture&quot;</span>, uvmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加载动画">加载动画</h2><p>先给一个暴论，Unity运行时加载一个FBX动画，将其转换为Humanoid格式是<strong>不可能的</strong>，加载动画唯一可行的就是Legacy格式</p><p>这会带来几个问题：</p><ol><li>不能使用Humanoid格式的动画，于是动画数据要和模型的骨骼匹配</li><li>不能使用Playable Script播放动画，必须用老旧的Animation模块</li></ol><p>使用<a href="https://assetstore.unity.com/packages/tools/modeling/trilib-2-model-loading-package-157548">TriLib2库</a>加载模型</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;AnimationClip&gt; clips = <span class="keyword">new</span> List&lt;AnimationClip&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// load animation</span></span><br><span class="line">    <span class="keyword">var</span> options = AssetLoader.CreateDefaultLoaderOptions();</span><br><span class="line">    <span class="keyword">var</span> context = AssetLoader.LoadModelFromFile(modelPath, OnLoad, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnLoad</span>(<span class="params">AssetLoaderContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get all animations</span></span><br><span class="line">    <span class="keyword">var</span> root = context.RootGameObject.GetComponent&lt;Animation&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> localClips = root.GetAllAnimationClips();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> clip <span class="keyword">in</span> localClips)</span><br><span class="line">        &#123;</span><br><span class="line">            clips.Add(clip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    context.RootGameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// load is asyc, so need wait</span></span><br><span class="line">    <span class="keyword">if</span> (hadPlay)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (clips.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hadPlay = <span class="literal">true</span>;</span><br><span class="line">        Debug.Log(clips.Count);</span><br><span class="line">        animationLength = Mathf.RoundToInt(clips[<span class="number">0</span>].frameRate * clips[<span class="number">0</span>].length);</span><br><span class="line">        currentFrame = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// play animation</span></span><br><span class="line">        <span class="keyword">var</span> anim = GetComponent&lt;Animation&gt;();</span><br><span class="line">        anim.AddClip(clips[<span class="number">0</span>], <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        anim.clip = anim.GetClip(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        anim[<span class="string">&quot;0&quot;</span>].time = <span class="number">0</span>;</span><br><span class="line">        anim[<span class="string">&quot;0&quot;</span>].speed = <span class="number">1</span>;</span><br><span class="line">        anim.CrossFade(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLTF模型和动画是可以运行时导入的，但是GLTF的Humanoid和FBX Humanoid不兼容，且GLTF Humanoid转换时，必须原始骨架要符合规范，而FBX Humanoid可以映射MMD骨架，因此在Unity官方提供GLTF加载库前，我不建议在Unity使用GLTF</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OBJ格式解析</title>
      <link href="/dcc/OBJ%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
      <url>/dcc/OBJ%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1>OBJ 格式解析</h1><p>OBJ是一种常用的文本格式（也可以是二进制）的三维模型格式，可读性很强</p><h2 id="OBJ">.OBJ</h2><p>打开一个<code>.obj</code>文件，通常形如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mtllib sphere.mtl</span><br><span class="line">o Sphere </span><br><span class="line">v <span class="number">0.5</span> <span class="number">0.5</span> <span class="number">-0.5</span></span><br><span class="line">...</span><br><span class="line">vt <span class="number">0.0</span> <span class="number">1.0</span></span><br><span class="line">...</span><br><span class="line">vn <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">1.0</span></span><br><span class="line">...</span><br><span class="line">f <span class="number">1</span>/<span class="number">19</span>/<span class="number">15</span> <span class="number">8</span>/<span class="number">18</span>/<span class="number">14</span> <span class="number">2</span>/<span class="number">20</span>/<span class="number">16</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>obj本身是一个巨大的字符串，由换行符<code>\n</code>分割每一行，每一行都代表一组数组</p><h3 id="组信息">组信息</h3><table><thead><tr><th>行开头</th><th>含义</th></tr></thead><tbody><tr><td>g</td><td>组名</td></tr><tr><td>o</td><td>物体（object）名称</td></tr><tr><td>s</td><td>平滑组</td></tr><tr><td>mg</td><td>merging group</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭平滑组</span></span><br><span class="line">s off</span><br><span class="line"><span class="comment">// 下面的f都属于平滑组1</span></span><br><span class="line">s <span class="number">1</span></span><br><span class="line">f ...</span><br><span class="line">f ...</span><br></pre></td></tr></table></figure><h3 id="顶点数据">顶点数据</h3><table><thead><tr><th>行开头</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>v</td><td>顶点坐标</td><td>Float3</td></tr><tr><td>vt</td><td>纹理坐标</td><td>Float2或Float3</td></tr><tr><td>vn</td><td>顶点法线</td><td>Float3</td></tr></tbody></table><p>参数模型顶点数据</p><table><thead><tr><th>行开头</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>vp</td><td>参数空间顶点</td><td>Float3</td></tr><tr><td>cstype</td><td>曲线、曲面形式</td><td></td></tr><tr><td>deg</td><td></td><td></td></tr><tr><td>bmat</td><td></td><td></td></tr><tr><td>step</td><td></td><td></td></tr></tbody></table><h3 id="图元数据">图元数据</h3><table><thead><tr><th>行开头</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>f</td><td>四边面</td><td>v1/vt1/vn1  v2/vt2/vn2  v3/vt3/vn3 v4/vt4/vn4</td></tr><tr><td>p</td><td>点</td><td>v1 v2 v3</td></tr><tr><td>l</td><td>线</td><td>v1/vt1 v2/vt2</td></tr><tr><td>curv</td><td>曲线</td><td></td></tr><tr><td>curv2</td><td>二维曲线</td><td></td></tr><tr><td>surf</td><td>surface</td><td></td></tr></tbody></table><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">// f 有多种形式，如</span><br><span class="line">f 1 2 3</span><br><span class="line">f 1/1/1 2/2/2 3/3/3</span><br><span class="line">f 1//1 2//2 3// 3</span><br></pre></td></tr></table></figure><h3 id="渲染信息">渲染信息</h3><table><thead><tr><th>行开头</th><th>含义</th></tr></thead><tbody><tr><td>lod</td><td>lod</td></tr><tr><td>使用材质名称</td><td>usemtl</td></tr><tr><td>引入一个材质库（很类似#include）</td><td>mtllib</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在obj的开头通常会使用mtllib引入一个材质库</span></span><br><span class="line">mtllib sphere.mtl</span><br><span class="line"><span class="comment">// 在一组f前使用usemtl表示使用这个材质</span></span><br><span class="line">usemtl yellow</span><br><span class="line">s <span class="number">1</span></span><br><span class="line">f ...</span><br></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><p>观察可知，对于obj来说，一个三脚面，他们的顶点坐标、纹理坐标、顶点法线的<strong>index并不是共同</strong>的，比如<code>1/19/15</code>就表示组成这个三角形的第一个顶点，他的顶点坐标位于第1个v，纹理坐标位于第19个vt，顶点法线位于第15个vn</p><p>而且非常阴间的是，<strong>obj的索引是从1开始的</strong>，而非0，在导入到游戏引擎被图形API使用时，需要将f的索引都减一</p><h2 id="mtl">.mtl</h2><p>mtl是常与obj一起使用的文件，用于描述材质，写过PBR的人很容易理解含义</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">newmtl yellow</span><br><span class="line">Ns <span class="number">225.000000</span></span><br><span class="line">Ka <span class="number">1.000000</span> <span class="number">1.000000</span> <span class="number">1.000000</span></span><br><span class="line">Kd <span class="number">0.800000</span> <span class="number">0.599518</span> <span class="number">0.000000</span></span><br><span class="line">Ks <span class="number">0.500000</span> <span class="number">0.500000</span> <span class="number">0.500000</span></span><br><span class="line">Ke <span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">0.000000</span></span><br><span class="line">Ni <span class="number">1.450000</span></span><br><span class="line">d <span class="number">1.000000</span></span><br><span class="line">illum <span class="number">2</span></span><br><span class="line">map_Kd wmqjcfsg_2K_Albedo.jpg</span><br><span class="line">map_roughness wmqjcfsg_2K_Roughness.jpg</span><br><span class="line">map_metallic wmqjcfsg_2K_Displacement.jpg</span><br><span class="line">map_ao wmqjcfsg_2K_AO.jpg</span><br></pre></td></tr></table></figure><table><thead><tr><th>行开头</th><th>含义</th><th>格式</th><th>范围</th></tr></thead><tbody><tr><td>Ns</td><td>specular，越高高光越紧凑</td><td>Float</td><td>0~1000</td></tr><tr><td>Ka</td><td>ambient，环境光反射率</td><td></td><td></td></tr><tr><td>Kd</td><td>diffuse，漫反射颜色</td><td></td><td></td></tr><tr><td>Ks</td><td>高光颜色</td><td></td><td></td></tr><tr><td>Ke</td><td>自发光颜色</td><td></td><td></td></tr><tr><td>Ni</td><td>折射率（玻璃的折射率为1.5）</td><td></td><td></td></tr><tr><td>illum</td><td>使用何种光照模型</td><td></td><td></td></tr><tr><td>d</td><td>dissolve，不透明度，为1时完全不透明</td><td>Float</td><td>0~1</td></tr><tr><td>map_xxx</td><td>xxx贴图</td><td></td><td></td></tr></tbody></table><h2 id="参考">参考</h2><p><a href="https://paulbourke.net/dataformats/obj/">Object Files</a></p><p><a href="https://paulbourke.net/dataformats/mtl/">MTL material format</a></p>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OBJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.Net最小Web API</title>
      <link href="/program/ASPDoNet/"/>
      <url>/program/ASPDoNet/</url>
      
        <content type="html"><![CDATA[<h1>ASP.Net最小Web API</h1><p>最近需要搭建一个Windows Web服务器，处理一些很简单的访问请求，于是研究了一下ASP.Net的最小Web API</p><h2 id="项目创建">项目创建</h2><p>打开VS2022，按照ASP.Net模块后，使用模板创建项目</p><p><img src="/images/ASP%E6%A8%A1%E6%9D%BF.png" class="lazyload" data-srcset="/images/ASP%E6%A8%A1%E6%9D%BF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ASP模板"></p><p><img src="/images/ASP%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0.png" class="lazyload" data-srcset="/images/ASP%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ASP模板参数"></p><h2 id="程序运行">程序运行</h2><p>模板是一个预测（随机生成）未来五天天气的demo，可以用命令行启动程序</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dotnet run --project=./项目名称</span><br></pre></td></tr></table></figure><h2 id="Mini-API">Mini API</h2><p>模板项目内容非常少，只有一个C#文件</p><p><img src="/images/ASP%E6%A8%A1%E6%9D%BF%E5%86%85%E5%AE%B9.png" class="lazyload" data-srcset="/images/ASP%E6%A8%A1%E6%9D%BF%E5%86%85%E5%AE%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ASP模板内容"></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Get接口，返回天气预测结果</span></span><br><span class="line">app.MapGet(<span class="string">&quot;/weatherforecast&quot;</span>, () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> forecast = Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>).Select(index =&gt;</span><br><span class="line">        <span class="keyword">new</span> WeatherForecast</span><br><span class="line">        (</span><br><span class="line">            ...</span><br><span class="line">        ))</span><br><span class="line">        .ToArray();</span><br><span class="line">    <span class="keyword">return</span> forecast;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.Run();</span><br><span class="line"></span><br><span class="line"><span class="comment">// record是C#的一个关键字，可以定义一个不可变的数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">record</span> <span class="title">WeatherForecast</span>(<span class="params">DateOnly Date, <span class="built_in">int</span> TemperatureC, <span class="built_in">string</span>? Summary</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TemperatureF =&gt; <span class="number">32</span> + (<span class="built_in">int</span>)(TemperatureC / <span class="number">0.5556</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>record可以用于快速定义一个类</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两者等效</span></span><br><span class="line"><span class="keyword">record</span> <span class="title">EditTodoItemRequest</span>(<span class="title">int</span> <span class="title">Id</span>, <span class="title">TodoItemDTO</span> <span class="title">Dto</span>, <span class="title">TodoDb</span> <span class="title">Db</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">EditTodoItemRequest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> TodoItemDTO Dto &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">default</span>!;</span><br><span class="line">    <span class="keyword">public</span> TodoDb Db &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">default</span>!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加一个新Get">添加一个新Get</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">app.MapGet(<span class="string">&quot;/open/&#123;path&#125;&quot;</span>, (<span class="built_in">string</span> path) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Process.Start(<span class="string">&quot;explorer.exe&quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Can&#x27;t open folder: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:xxxx/open/C%3A%5CUsers%5C28240%5Ccode</span></span><br></pre></td></tr></table></figure><p>用文件浏览器打开本地的<code>C:\Users\28240\code</code>路径</p><h3 id="解析Request内容">解析Request内容</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">app.MapGet(<span class="string">&quot;/do&quot;</span>, (HttpRequest request) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> prop_a = request.Query[<span class="string">&quot;a&quot;</span>];</span><br><span class="line">    <span class="keyword">var</span> prop_b = request.Query[<span class="string">&quot;b&quot;</span>];</span><br><span class="line">    <span class="keyword">var</span> sessionid = request.Query[<span class="string">&quot;sessionid&quot;</span>];    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:xxxx/do?a=hello&amp;b=world&amp;sessionid=default</span></span><br></pre></td></tr></table></figure><h3 id="输入一个文件">输入一个文件</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">app.MapPost(<span class="string">&quot;/do&quot;</span>, (HttpRequest request) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sourceFile = request.Form.Files[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 将 http 请求的文件保存在本地</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> st = <span class="keyword">new</span> FileStream(localPath, FileMode.Create))</span><br><span class="line">    &#123;</span><br><span class="line">        sourceFile.CopyTo(st); </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="返回一个文件">返回一个文件</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">app.MapPost(<span class="string">&quot;/download&quot;</span>, (HttpRequest request) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Results.File(System.IO.File.OpenRead(localVideoPath), <span class="string">&quot;video/mp4&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用python下载这个文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.post(url, headers=headers, files=&#123;<span class="string">&quot;file&quot;</span>: file&#125;)</span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request successful!&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;received_file.mp4&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(response.content)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件已保存为 &#x27;received_file.mp4&#x27;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request failed with status code:&quot;</span>, response.status_code)</span><br></pre></td></tr></table></figure><h3 id="url转义规则">url转义规则</h3><p>除了下面这些保留字外，用<code>%{两位十六进制}</code>进行转义</p><table><thead><tr><th>字符</th><th>转义形式</th></tr></thead><tbody><tr><td>空格</td><td>%20</td></tr><tr><td>!</td><td>%21</td></tr><tr><td>*</td><td>%2A</td></tr><tr><td>’</td><td>%27</td></tr><tr><td>(</td><td>%28</td></tr><tr><td>)</td><td>%29</td></tr><tr><td>;</td><td>%3B</td></tr><tr><td>:</td><td>%3A</td></tr><tr><td>@</td><td>%40</td></tr><tr><td>&amp;</td><td>%26</td></tr><tr><td>=</td><td>%3D</td></tr><tr><td>+</td><td>%2B</td></tr><tr><td>$</td><td>%24</td></tr><tr><td>,</td><td>%2C</td></tr><tr><td>/</td><td>%2F</td></tr><tr><td>?</td><td>%3F</td></tr><tr><td>#</td><td>%23</td></tr><tr><td>[</td><td>%5B</td></tr><tr><td>]</td><td>%5D</td></tr></tbody></table><h2 id="Web-Socket">Web Socket</h2><p>除了简单的Web API，我们有时也会用到Web Socket</p><h3 id="服务端代码">服务端代码</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program.cs</span></span><br><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line">builder.Services.AddControllers();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> webSocketOptions = <span class="keyword">new</span> WebSocketOptions</span><br><span class="line">&#123;</span><br><span class="line">    KeepAliveInterval = TimeSpan.FromMinutes(<span class="number">2</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.UseWebSockets(webSocketOptions);</span><br><span class="line"></span><br><span class="line">app.MapControllers();</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">SocketDemo.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">xxxxController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Route(<span class="string">&quot;/ws&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Get</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (HttpContext.WebSockets.IsWebSocketRequest)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> <span class="keyword">var</span> webSocket = <span class="keyword">await</span> HttpContext.WebSockets.AcceptWebSocketAsync();</span><br><span class="line">                <span class="keyword">await</span> Echo(webSocket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                HttpContext.Response.StatusCode = StatusCodes.Status400BadRequest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Echo</span>(<span class="params">WebSocket webSocket</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;First Connect&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span> * <span class="number">4</span>];</span><br><span class="line">            <span class="keyword">var</span> receiveResult = <span class="keyword">await</span> webSocket.ReceiveAsync(</span><br><span class="line">                <span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!receiveResult.CloseStatus.HasValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> segment = <span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer, <span class="number">0</span>, receiveResult.Count);</span><br><span class="line">                <span class="keyword">await</span> webSocket.SendAsync(</span><br><span class="line">                    segment,</span><br><span class="line">                    receiveResult.MessageType,</span><br><span class="line">                    receiveResult.EndOfMessage,</span><br><span class="line">                    CancellationToken.None);</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Send: <span class="subst">&#123;Encoding.UTF8.GetString(segment.Array, segment.Offset, segment.Count)&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                receiveResult = <span class="keyword">await</span> webSocket.ReceiveAsync(</span><br><span class="line">                    <span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> webSocket.CloseAsync(</span><br><span class="line">                receiveResult.CloseStatus.Value,</span><br><span class="line">                receiveResult.CloseStatusDescription,</span><br><span class="line">                CancellationToken.None);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端代码">客户端代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">connect_to_server</span>():</span><br><span class="line">    uri = <span class="string">&quot;wss://localhost:7167/ws&quot;</span>  <span class="comment"># 替换成你的服务器地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> websockets.connect(uri) <span class="keyword">as</span> websocket:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connected to <span class="subst">&#123;uri&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                message = <span class="built_in">input</span>(<span class="string">&quot;Enter message to send (or &#x27;exit&#x27; to quit): &quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> message.lower() == <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">await</span> websocket.send(message)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;&gt; Sent: <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                response = <span class="keyword">await</span> websocket.recv()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;&lt; Received: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">await</span> websocket.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;WebSocket connection closed&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(connect_to_server())</span><br></pre></td></tr></table></figure><p>注：客户端连接websocket时，不使用http、https，而是ws、wss</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Nova UI</title>
      <link href="/engine/UnityNovaUI/"/>
      <url>/engine/UnityNovaUI/</url>
      
        <content type="html"><![CDATA[<h1>Unity Nova UI</h1><p>今天发现了一个特别好的Unity Game UI框架：<a href="https://assetstore.unity.com/packages/tools/gui/nova-free-trial-231156">Nova</a>，挖个坑，打算学习一下</p><p><img src="/images/NovaBlur.gif" class="lazyload" data-srcset="/images/NovaBlur.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="NovaBlur"></p><p><img src="/images/NovaUI.png" class="lazyload" data-srcset="/images/NovaUI.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="NovaUI"></p><p><img src="/images/NovaPlayground.gif" class="lazyload" data-srcset="/images/NovaPlayground.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="NovaPlayground"></p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插值</title>
      <link href="/math/%E6%8F%92%E5%80%BC/"/>
      <url>/math/%E6%8F%92%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1>插值</h1><h2 id="线性插值">线性插值</h2><p>$$<br>\mathrm{lerp}(p_0,p_1;t)=(1-t)p_0+tp_1<br>$$</p><h2 id="Smoothstep">Smoothstep</h2><blockquote><p>Hermite</p></blockquote><p>将一个数平滑映射到<code>[0, 1]</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> v = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, time);</span><br><span class="line"><span class="comment">// 等同于 time * time * (3 - 2 * time)</span></span><br></pre></td></tr></table></figure><h2 id="球面插值">球面插值</h2><blockquote><p>Slerp</p></blockquote><p>在球面上线性插值</p><p><img src="/images/lerp_vs_slerp.png" class="lazyload" data-srcset="/images/lerp_vs_slerp.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="lerp_vs_slerp"></p><p><img src="/images/Slerp_factor_explanation.png" class="lazyload" data-srcset="/images/Slerp_factor_explanation.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Slerp_factor_explanation"><br>$$<br>\mathrm{Slerp(p_0,p_1;t)}=\frac{\sin[(1-t)\Omega]}{\sin \Omega}p_0+\frac{\sin [t\Omega]}{\sin \Omega}p_1<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">Slerp</span><span class="params">(vec4 p0, vec4 p1, <span class="type">float</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> dotp = <span class="built_in">dot</span>(<span class="built_in">normalize</span>(p0), <span class="built_in">normalize</span>(p1));</span><br><span class="line">  <span class="keyword">if</span> ((dotp &gt; <span class="number">0.9999</span>) || (dotp&lt;<span class="number">-0.9999</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (t&lt;=<span class="number">0.5</span>)</span><br><span class="line">      <span class="keyword">return</span> p0;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">float</span> theta = <span class="built_in">acos</span>(dotp * <span class="number">3.14159</span>/<span class="number">180.0</span>);</span><br><span class="line">  vec4 P = ((p0*<span class="built_in">sin</span>((<span class="number">1</span>-t)*theta) + p1*<span class="built_in">sin</span>(t*theta)) / <span class="built_in">sin</span>(theta));</span><br><span class="line">  P.w = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vec4 P = <span class="built_in">Slerp</span>(gxl3d_Position, gxl3d_Attrib1, time);</span><br><span class="line">  gl_Position = gxl3d_ModelViewProjectionMatrix * P;</span><br><span class="line">  Vertex_Color = gxl3d_Attrib0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://www.geeks3d.com/20140205/glsl-simple-morph-target-animation-opengl-glslhacker-demo/">glsl-simple-morph-target-animation</a></p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Marching Cubes</title>
      <link href="/graphics/MarchingCube/"/>
      <url>/graphics/MarchingCube/</url>
      
        <content type="html"><![CDATA[<h1>Marching Cubes</h1><blockquote><p>Marching可以理解为一种循环</p></blockquote><p>步进正方形（Marching Cubes）是一种非常常用的构建三角形网格的算法，在三维空间中均匀摆放正方形，循环遍历这些正方形，插值出三角形表面</p><p>Marching Cubes每个顶点有两个参数，顶点位置和权重（SDF）</p><p><img src="/images/MarchingCubes.png" class="lazyload" data-srcset="/images/MarchingCubes.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="MarchingCubes"></p><p><img src="/images/MarchingCubes2.png" class="lazyload" data-srcset="/images/MarchingCubes2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="MarchingCubes2"></p><h2 id="Unity显示三角形网格">Unity显示三角形网格</h2><blockquote><p>注意！Unity拼装Mesh时，要先设置vertices，再设置triangles（尤其是在使用SetIndices接口，而非直接改mesh成员的方式），因为Unity在修改triangles时会对内部的信息做一次合法性检测，如果此时vertices是空的，就会报越界的错</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建一个Mesh，填充Vertex Buffer和Index Buffer</span></span><br><span class="line">Mesh constructMesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">constructMesh.vertices = verts;<span class="comment">// 这里的vertices仅有positionOS</span></span><br><span class="line">constructMesh.triangles = tris;<span class="comment">// 一个int数组，每三个组成一个三角形，内容是vertices的索引，于是一般情形下远多于三倍的vertices数量</span></span><br><span class="line">constructMesh.RecalculateNormals();<span class="comment">// 重建法线（应该是对面法线求平均值）</span></span><br><span class="line"><span class="comment">// 替换MeshFilter的sharedMesh</span></span><br><span class="line">meshFilter.sharedMesh = constructMesh；</span><br></pre></td></tr></table></figure><h2 id="Unity-Compute-Shader">Unity Compute Shader</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个Buffer</span></span><br><span class="line">ComputeBuffer buffer = <span class="keyword">new</span> ComputeBuffer(count, stride, type);</span><br></pre></td></tr></table></figure><ul><li>stride是Buffer内每个元素的大小，注意CPU和Shader中定义要一致</li><li>type是Buffer的类型<ul><li>AppendStructuredBuffer</li><li>RWStructuredBuffer</li></ul></li></ul><h3 id="AppendStructuredBuffer">AppendStructuredBuffer</h3><p>有些像一个总容量固定的vector，在使用时需要提前分配一个足够大的总容量</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在CPU端设置有效容量</span></span><br><span class="line">_trianglesBuffer.SetCounterValue(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在CPU端获取当前有效容量</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">ReadTriangleCount</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span>[] triCount = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ComputeBuffer.CopyCount(_trianglesBuffer, _trianglesCountBuffer, <span class="number">0</span>);</span><br><span class="line">    _trianglesCountBuffer.GetData(triCount);</span><br><span class="line">    <span class="keyword">return</span> triCount[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AppendStructuredBuffer&lt;Triangle&gt; _Triangles;</span><br><span class="line"></span><br><span class="line">[<span class="built_in">numthreads</span>(numThreads, numThreads, numThreads)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">March</span><span class="params">(uint3 id : SV_DispatchThreadID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在GPU端在Buffer尾部添加新元素</span></span><br><span class="line">_Triangles.<span class="built_in">Append</span>(tri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建Marching-Cubes">构建Marching Cubes</h2><ul><li>构建一个立方体Grids</li><li>生成SDF</li><li>根据SDF获得CubeIndex</li><li>使用CubeIndex从LUT中读取边的数组</li><li>从相邻三个边插值出三角形三个点的顶点坐标</li></ul><blockquote><p>这里生成的vertex buffer数量和index buffer相同，是全展的，存在性能浪费</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> edges[] = triTable[cubeIndex];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; edges[i] != <span class="number">-1</span>; i += <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// First edge lies between vertex e00 and vertex e01</span></span><br><span class="line">    <span class="type">int</span> e00 = edgeConnections[edges[i]][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> e01 = edgeConnections[edges[i]][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Second edge lies between vertex e10 and vertex e11</span></span><br><span class="line">    <span class="type">int</span> e10 = edgeConnections[edges[i + <span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> e11 = edgeConnections[edges[i + <span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Third edge lies between vertex e20 and vertex e21</span></span><br><span class="line">    <span class="type">int</span> e20 = edgeConnections[edges[i + <span class="number">2</span>]][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> e21 = edgeConnections[edges[i + <span class="number">2</span>]][<span class="number">1</span>];</span><br><span class="line">    Triangle tri;</span><br><span class="line">    tri.a = <span class="built_in">interp</span>(cornerOffsets[e00], cubeValues[e00], cornerOffsets[e01], cubeValues[e01]) + id;</span><br><span class="line">    tri.b = <span class="built_in">interp</span>(cornerOffsets[e10], cubeValues[e10], cornerOffsets[e11], cubeValues[e11]) + id;</span><br><span class="line">    tri.c = <span class="built_in">interp</span>(cornerOffsets[e20], cubeValues[e20], cornerOffsets[e21], cubeValues[e21]) + id;</span><br><span class="line">    _Triangles.<span class="built_in">Append</span>(tri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/marchingCube%E6%95%88%E6%9E%9C.png" class="lazyload" data-srcset="/images/marchingCube%E6%95%88%E6%9E%9C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="marchingCube效果"></p><h2 id="参考">参考</h2><p><a href="https://polycoding.net/marching-cubes/">Marching Cubes</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KL散度</title>
      <link href="/math/KL%E6%95%A3%E5%BA%A6/"/>
      <url>/math/KL%E6%95%A3%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1>KL散度</h1><p>在AI领域，我们经常需要衡量两个概率分布的相似度</p><h3 id="KL散度">KL散度</h3><p>KL散度（Kullback-Leibler Divergence），也称为相对熵（Relative Entropy），用于衡量一个分布相对于另一个分布的相似性</p><p>假设现在有两个离散概率分布$P$和$Q$，他们的KL散度计算公式为：<br>$$<br>D_{KL}(P||Q)=\sum_{i}P(i)\log \left(\frac{P(i)}{Q(i)} \right)<br>$$<br>其中$P(i)$表示分布$P$在第$i$个事件的概率</p><p>特性：</p><ul><li>非负性，KL散度通常大于等于0，当且仅当两个分布相同时等于0</li><li>不对称性，$D_{KL}(P||Q)$往往和$D_{KL}(Q||P)$不同</li><li>不满足三角不等式（即两边之和大于第三边）</li></ul><h3 id="JSD">JSD</h3><p>Jensen-Shannon Divergence (JSD)也是一种衡量两个概率分布相似性的的指标，基于KL散度，但JSD具有对称性</p><p>JSD计算方式：</p><ol><li>计算$P$和$Q$的平均分布</li></ol><p>$$<br>M = (P+Q)/2<br>$$</p><ol start="2"><li><p>计算$D_{KL}(P||M)$和$D_{KL}(Q||M)$</p></li><li><p>JSD是两个散度的平均值</p></li></ol><p>$$<br>JSD(P||Q)=\frac{1}{2}(D_{KL}(P||M) + D_{KL}(Q||M))<br>$$</p><p>JSD的范围是<code>[0, 1]</code>，0表示两个分布完全重合，1表示两个分布完全没有重叠（差异最大）</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch学习记录</title>
      <link href="/ai/Pytorch/"/>
      <url>/ai/Pytorch/</url>
      
        <content type="html"><![CDATA[<h1>PyTorch学习记录</h1><p>PyTorch是一个Python机器学习框架</p><h2 id="张量">张量</h2><h3 id="创建一个张量">创建一个张量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="comment"># tensor([1, 2, 3])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.zeros(<span class="number">2</span>,<span class="number">3</span>)  <span class="comment"># tensor([[0., 0., 0.],</span></span><br><span class="line">                  <span class="comment">#         [0., 0., 0.]])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.ones(<span class="number">2</span>,<span class="number">2</span>)   <span class="comment"># tensor([[1., 1.],</span></span><br><span class="line">                  <span class="comment">#         [1., 1.]])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)  <span class="comment"># tensor([0, 2, 4, 6, 8])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>)   <span class="comment"># tensor([0.0000, 0.2500, 0.5000, 0.7500, 1.0000])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.eye(<span class="number">3</span>)  <span class="comment"># tensor([[1., 0., 0.],</span></span><br><span class="line">              <span class="comment">#         [0., 1., 0.],</span></span><br><span class="line">              <span class="comment">#         [0., 0., 1.]])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.rand(<span class="number">2</span>,<span class="number">3</span>)  <span class="comment"># tensor([[0.1234, 0.6789, 0.2345],</span></span><br><span class="line">                 <span class="comment">#         [0.3456, 0.9876, 0.1111]])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.randn(<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 标准正态分布，均值0方差1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.empty(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># 未初始化内存的张量（内容随机）</span></span><br></pre></td></tr></table></figure><h3 id="张量属性">张量属性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x.shape                                   <span class="comment"># torch.Size([2, 3])</span></span><br><span class="line">x.dtype                                   <span class="comment"># torch.float32</span></span><br><span class="line">x.device                                  <span class="comment"># device(type=&#x27;cpu&#x27;)</span></span><br><span class="line">x.ndim                                    <span class="comment"># 2</span></span><br><span class="line">x.numel()                                 <span class="comment"># 6  （总元素数）</span></span><br></pre></td></tr></table></figure><h3 id="基础运算">基础运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = torch.tensor([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础运算</span></span><br><span class="line">a ** <span class="number">2</span>                                    <span class="comment"># tensor([1, 4, 9])</span></span><br><span class="line">torch.add(a,b)                            <span class="comment"># tensor([4, 4, 4])</span></span><br><span class="line">torch.mul(a,b)                            <span class="comment"># tensor([3, 4, 3])</span></span><br></pre></td></tr></table></figure><h3 id="矩阵运算">矩阵运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[<span class="number">1.</span>,<span class="number">2.</span>],[<span class="number">3.</span>,<span class="number">4.</span>]])</span><br><span class="line">B = torch.tensor([[<span class="number">2.</span>,<span class="number">0.</span>],[<span class="number">1.</span>,<span class="number">2.</span>]])</span><br><span class="line"><span class="comment"># 矩阵乘法</span></span><br><span class="line">torch.matmul(A,B)                         <span class="comment"># tensor([[4., 4.],</span></span><br><span class="line">                                          <span class="comment">#         [10., 8.]])</span></span><br><span class="line"><span class="comment"># 逆矩阵，与原矩阵相乘得到单位矩阵</span></span><br><span class="line">torch.inverse(A)                          <span class="comment"># tensor([[-2.0000,  1.0000],</span></span><br><span class="line">                                          <span class="comment">#         [ 1.5000, -0.5000]])</span></span><br><span class="line"><span class="comment"># 交互矩阵的行和列</span></span><br><span class="line">torch.transpose(A, <span class="number">0</span>, <span class="number">1</span>)                  <span class="comment"># tensor([[1., 3.],</span></span><br><span class="line">                                          <span class="comment">#         [2., 4.]])</span></span><br></pre></td></tr></table></figure><h3 id="维度操作">维度操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">6</span>).view(<span class="number">2</span>,<span class="number">3</span>)             <span class="comment"># tensor([[0, 1, 2],</span></span><br><span class="line">                                          <span class="comment">#         [3, 4, 5]])</span></span><br><span class="line"><span class="comment"># 改变张量形状</span></span><br><span class="line">x.view(<span class="number">3</span>,<span class="number">2</span>)                               <span class="comment"># tensor([[0, 1],</span></span><br><span class="line">                                          <span class="comment">#         [2, 3],</span></span><br><span class="line">                                          <span class="comment">#         [4, 5]])</span></span><br><span class="line"><span class="comment"># 改变张量形状，同 x.view(3,2)        </span></span><br><span class="line">x.reshape(<span class="number">3</span>,<span class="number">2</span>)   </span><br><span class="line"><span class="comment"># 在原张量的第0维上增加一维，常用来将单条数据转为batch_size为1的批数据</span></span><br><span class="line">x.unsqueeze(<span class="number">0</span>).shape                      <span class="comment"># torch.Size([1, 2, 3])</span></span><br><span class="line"><span class="comment"># 展平张量，常用于将图像数据展平送至全连接层中</span></span><br><span class="line">x.flatten()                               <span class="comment"># tensor([0, 1, 2, 3, 4, 5])</span></span><br><span class="line"><span class="comment"># 沿着指定维度将两个张量拼接</span></span><br><span class="line">torch.cat([x,x], dim=<span class="number">0</span>)                   <span class="comment"># 按行拼接 → (4,3)</span></span><br><span class="line"><span class="comment"># 沿着指定维度将两个张量堆叠</span></span><br><span class="line">torch.stack([x,x], dim=<span class="number">0</span>)           <span class="comment"># torch.Size([2, 2, 3])</span></span><br></pre></td></tr></table></figure><h3 id="切片">切片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)          <span class="comment"># tensor([[0,1,2],</span></span><br><span class="line">                                          <span class="comment">#         [3,4,5],</span></span><br><span class="line">                                          <span class="comment">#         [6,7,8]])</span></span><br><span class="line">x[:,<span class="number">1</span>]                                    <span class="comment"># tensor([1,4,7])</span></span><br><span class="line">x[<span class="number">1</span>:,:<span class="number">2</span>]                                  <span class="comment"># tensor([[3,4],</span></span><br><span class="line">                                          <span class="comment">#         [6,7]])</span></span><br><span class="line">x[x&gt;<span class="number">4</span>]                                    <span class="comment"># tensor([5,6,7,8])</span></span><br></pre></td></tr></table></figure><h3 id="数学函数">数学函数</h3><h3 id="随机数与采样">随机数与采样</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.manual_seed(<span class="number">0</span>)</span><br><span class="line">torch.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">2</span>,<span class="number">3</span>))                 <span class="comment"># tensor([[4, 8, 4],</span></span><br><span class="line">                                          <span class="comment">#         [6, 3, 4]])</span></span><br><span class="line">torch.randn(<span class="number">2</span>,<span class="number">2</span>)                          <span class="comment"># 标准正态分布</span></span><br><span class="line">torch.rand(<span class="number">2</span>,<span class="number">2</span>)                           <span class="comment"># 均匀分布 [0,1)</span></span><br><span class="line">torch.bernoulli(torch.tensor([<span class="number">0.2</span>,<span class="number">0.8</span>]))  <span class="comment"># tensor([0., 1.])</span></span><br></pre></td></tr></table></figure><h3 id="数据结构">数据结构</h3><h4 id="复数">复数</h4><p>$$<br>z=a + bj<br>$$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>+<span class="number">2j</span>, <span class="number">3</span>+<span class="number">4j</span>], dtype=torch.complex128)</span><br><span class="line"><span class="built_in">print</span>(x.real, x.imag)</span><br></pre></td></tr></table></figure><h2 id="网络模块">网络模块</h2><h3 id="nn-Module">nn.Module</h3><p>所有网络的基类，可以用于自定义网络模型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Attention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embed_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.embed_dim = embed_dim</span><br><span class="line">        self.query = nn.Linear(embed_dim, embed_dim)</span><br><span class="line">        self.key = nn.Linear(embed_dim, embed_dim)</span><br><span class="line">        self.value = nn.Linear(embed_dim, embed_dim)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, query, key, value</span>):</span><br><span class="line">        <span class="comment"># Implement attention mechanism</span></span><br></pre></td></tr></table></figure><h3 id="基础层">基础层</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全连接层</span></span><br><span class="line">nn.Linear(in_features, out_features)</span><br><span class="line"><span class="comment"># 卷积层</span></span><br><span class="line">nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 逆卷积层，将数据尺寸放大</span></span><br><span class="line">nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 一维归一化</span></span><br><span class="line">nn.BatchNorm1d(num_features)</span><br><span class="line"><span class="comment"># 二维归一化</span></span><br><span class="line">nn.BatchNorm2d(num_features)</span><br><span class="line"><span class="comment"># 层归一化（均值为0，方差为1）</span></span><br><span class="line">nn.LayerNorm(normalized_shape)</span><br><span class="line"><span class="comment"># 嵌入层，是一种查找表，将离散数据映射为连续数据</span></span><br><span class="line">nn.Embedding(num_embeddings, embedding_dim)</span><br><span class="line"><span class="comment"># Dropout，按比例丢弃数据</span></span><br><span class="line">nn.Dropout(p=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 恒等映射，常与Dropout一起用</span></span><br><span class="line">nn.Identity()</span><br><span class="line"><span class="comment"># 激活函数</span></span><br><span class="line">nn.ReLU(), nn.LeakyReLU(), nn.Sigmoid(), nn.Tanh()</span><br></pre></td></tr></table></figure><h3 id="容器">容器</h3><h4 id="nn-Sequential">nn.Sequential</h4><p>拥有自动前向传播</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将多层网络按顺序级联</span></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">20</span>, <span class="number">64</span>, <span class="number">5</span>),</span><br><span class="line">    nn.ReLU()</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">model2 = nn.Sequential()</span><br><span class="line">model2.add_module(<span class="string">&quot;conv1&quot;</span>, nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>))</span><br><span class="line">model2.add_module(<span class="string">&#x27;relu1&#x27;</span>, nn.ReLU())</span><br><span class="line">model2.add_module(<span class="string">&#x27;conv2&#x27;</span>, nn.Conv2d(<span class="number">20</span>, <span class="number">64</span>, <span class="number">5</span>))</span><br><span class="line">model2.add_module(<span class="string">&#x27;relu2&#x27;</span>, nn.ReLU())</span><br></pre></td></tr></table></figure><h4 id="nn-ModuleList">nn.ModuleList</h4><p>一组模型的集合，需要手动实现forward</p><h3 id="权重">权重</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存</span></span><br><span class="line">torch.save(model.state_dict(), <span class="string">&#x27;checkpoints/save.pt&#x27;</span>)</span><br><span class="line"><span class="comment"># 加载</span></span><br><span class="line">state_dict = torch.load(<span class="string">&#x27;checkpoints/save.pt&#x27;</span>, map_location=torch.device(<span class="string">&#x27;cpu&#x27;</span>))</span><br><span class="line">model = Flow()</span><br><span class="line">model.load_state_dict(state_dict)</span><br></pre></td></tr></table></figure><h2 id="预处理">预处理</h2><h3 id="图像转换">图像转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transforms.Resize((<span class="number">256</span>,<span class="number">256</span>))</span><br><span class="line">transforms.CenterCrop(<span class="number">224</span>)</span><br><span class="line">transforms.RandomCrop(<span class="number">224</span>)</span><br><span class="line">transforms.RandomHorizontalFlip()</span><br><span class="line">transforms.RandomVerticalFlip()</span><br><span class="line">transforms.RandomRotation(<span class="number">30</span>)</span><br><span class="line">transforms.ColorJitter(brightness=<span class="number">0.2</span>, contrast=<span class="number">0.2</span>)</span><br><span class="line">transforms.RandomGrayscale(p=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><h3 id="张量化与归一化">张量化与归一化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transforms.ToTensor()         <span class="comment"># PIL-&gt;Tensor, 0-1</span></span><br><span class="line">transforms.Normalize(mean, std) <span class="comment"># 标准化</span></span><br></pre></td></tr></table></figure><h3 id="组合">组合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transforms.Compose([</span><br><span class="line">    transforms.Resize(<span class="number">256</span>),</span><br><span class="line">    transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(mean,std)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="分布式训练">分布式训练</h2>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维模型的表示方法</title>
      <link href="/graphics/%E6%A8%A1%E5%9E%8B%E8%A1%A8%E7%A4%BA/"/>
      <url>/graphics/%E6%A8%A1%E5%9E%8B%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1>三维模型的表示方法</h1><p>常见的模型表示法有：多边形网格、点云、体素、参数模型、隐式表面</p><h2 id="表示方式">表示方式</h2><h3 id="Polygon-mesh">Polygon mesh</h3><blockquote><p>一般特指三角形网格</p></blockquote><p>三角形网格由两部分组成：</p><ul><li>一个个离散的顶点</li><li>顶点间的拓扑关系</li></ul><p>图形渲染中最常见的方法是光栅化和光追，都适用于三角形</p><p>方便进行深度测试、UV映射</p><p>方便进行模型细分和简化、布尔建模</p><p>美术行业长期使用该格式，存在很强的惯性</p><h4 id="三角面与四角面">三角面与四角面</h4><p>三角面</p><ol><li>三角面具有稳定性，不容易发生形变和自交</li><li>比较适合光栅化和光追，渲染效率高，常用于游戏等实时渲染场景</li><li>任何多边形都可以被三角面表示</li><li>三角面便于计算法线</li></ol><p>四角面</p><ol><li>纹理映射效果更好，能够提供更均匀的纹理坐标分布</li><li>与建模软件适配更好，很容易实现稳定的细化、拖拽、简化</li><li>法线可能会有歧义（四点可能不共面，四点的顺序有两种可能）</li></ol><h3 id="Voxel">Voxel</h3><p>与2D的像素类似，我们使用体素填充3D空间，就能表示一个三维模型</p><p>体素对空间的描述是均匀的，想要达到和三角网格相近的精度，需要占用更大的存储空间，这也意味着相同存储空间下体素的精度更差</p><p>下图左为2MB的三角网格，图右为13MB的SDF体素</p><p><img src="/images/voxel.png" class="lazyload" data-srcset="/images/voxel.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="voxel"></p><p>SDF体素具有非常好的光追性能，很容易进行相交测试和求出光线移动的距离</p><p>体素可以进行离散化，就像Clipmap那样，大片连续的体素会被合成为一个大体素，以降低存储空间（但还是比三角网格空间大）</p><p>不过为了保持边缘柔顺，我们需要在边缘处保留大量细小的体素，这种边缘处理会影响光追性能，一个好的模型数据结构应该能够表示软硬边，而非专门浪费性能来实现光滑</p><p>我们仍需要使用贴图映射，体素颜色不能替代UV，体素UV可能会出现接缝问题</p><h3 id="Point-cloud">Point cloud</h3><blockquote><p>多边形网格某种程度上就是有拓扑关系的点云</p></blockquote><p>点云记录了模型表面顶点的坐标</p><p>点云渲染会带来巨大的overdraw，为此我们需要进行填洞、做深度剔除，而填洞的难度很大</p><p>点云的一大优点是更适合通过扫描获得（三角形网格扫描容易出现破面）</p><p>点云的另一大优点是数据的顺序无关，我们可以任意调整顶点存储的顺序，但这其实也是一种缺点，我们不好比较两个点云的差异</p><h3 id="Implicit-field">Implicit field</h3><p>使用一组连续函数的零水平集来表示3D模型</p><blockquote><p>连续函数的零水平集：使函数值=0的输入取值的集合</p></blockquote><p>SDF就是一种隐式场，通过定义一组距离值函数，将点的坐标带入函数可以求得点到物体表面的距离</p><p>可以快速进行碰撞检测、UV生成</p><p>但制作难度过高，难以表达所有的模型，对于复杂模型，计算复杂度过高</p><p>难以进行编辑、布尔操作、细分</p><h2 id="评价指标">评价指标</h2><h3 id="水密">水密</h3><blockquote><p>Watertight</p></blockquote><p>指一个三维模型的表面是<strong>无缝且封闭的</strong>，没有任何孔洞或缺口</p><h3 id="流形">流形</h3><blockquote><p>Manifold</p></blockquote><p>每个顶点都恰好属于两个三角形（在边界上）或多个三角形（在内部）</p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贴图UV</title>
      <link href="/graphics/%E8%B4%B4%E5%9B%BEUV/"/>
      <url>/graphics/%E8%B4%B4%E5%9B%BEUV/</url>
      
        <content type="html"><![CDATA[<h1>贴图UV</h1><p>一个多边形Mesh中有Index Buffer和Vertex Buffer，其中Vertex Buffer上存储着顶点信息，包括顶点坐标、UV、法线、切线</p><p>最开始，我们只有顶点坐标，三角形的边向量叉积可以得到面法线，将面法线求和可以得到顶点法线，切线和次切线的方向就是沿着UV方向，那么问题来了，UV是怎么生成的？</p><h2 id="UV的用用途">UV的用用途</h2><p>UV是贴图的颜色的索引，可以用来采样贴图，是一种高效的传递模型表面材质信息的方式</p><h2 id="UV的分类">UV的分类</h2><p>UV通常分为全展UV和重叠UV</p><ul><li>重叠UV允许模型不同位置采样贴图的同一位置，于是更省空间（或者精度更好）</li><li>全展UV模型每一处UV都是不同的，可以用来采样Lightmap信息</li></ul><h2 id="UV的生成">UV的生成</h2><blockquote><p>我们这里说的都是多边形网格的UV，对于参数表面这类模型，是有天生的UV的</p></blockquote><p>DCC工具允许美术像编辑顶点坐标那样编辑顶点UV，但在这之前，我们需要先将三维的顶点坐标<strong>投影</strong>（Projector）到二维的UV上</p><p>投影方式有球面（spherical）投影、圆柱（cylindrical）投影、平面（planar）投影</p><p><img src="/images/UV%E6%8A%95%E5%BD%B1.png" class="lazyload" data-srcset="/images/UV%E6%8A%95%E5%BD%B1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UV投影"></p><p>球面投影：模型顶点坐标和一个虚构的球心会形成一个向量，沿着这个向量将顶点坐标投影到球面上</p><p>圆柱投影：u的投影和球面相同，v是模型顶点到虚拟圆锥轴的距离</p><p>面投影：将模型顶点做正交投影</p><p>美术通常会将模型进行切分，在不同位置应用不同的投影方法</p><p><img src="/images/%E9%80%89%E6%8B%A9%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8A%95%E5%BD%B1%E6%96%B9%E6%B3%95.png" class="lazyload" data-srcset="/images/%E9%80%89%E6%8B%A9%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8A%95%E5%BD%B1%E6%96%B9%E6%B3%95.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="选择不同的投影方法"></p><h2 id="Corresponder">Corresponder</h2><p>采样UV和贴图坐标有时范围是不同的（当你进行缩放采样时经常出现），于是我们需要处理边缘采样</p><p>有四种方法：</p><ul><li>重复（wrap、repeat、tile）</li><li>镜像（mirror）</li><li>截断（clamp to edge）</li><li>边界（clamp to border）</li></ul><p><img src="/images/Corresponder.png" class="lazyload" data-srcset="/images/Corresponder.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Corresponder"></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity保存RenderTarget</title>
      <link href="/engine/Unity%E4%BF%9D%E5%AD%98RT/"/>
      <url>/engine/Unity%E4%BF%9D%E5%AD%98RT/</url>
      
        <content type="html"><![CDATA[<h1>Unity保存RenderTarget</h1><p>使用Unity产出一些美术资产时，经常需要保存某个RenderTarget，最近发现用<code>ReadPixels</code>进行保存时，精度很差，只有8 bits，最后成功搞定了保存32 bits RenderTarget的方法，在此记录一下</p><h3 id="屏幕截图">屏幕截图</h3><p>如果想要保存当前屏幕的渲染结果，可以直接调用</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ScreenCapture.CaptureScreenshot(pngPath);</span><br></pre></td></tr></table></figure><h3 id="保存相机的RT">保存相机的RT</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Camera renderCamera;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveColor</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    RenderTexture activeRenderTexture = RenderTexture.active;</span><br><span class="line">    RenderTexture cameraRenderTexture = <span class="keyword">new</span> RenderTexture(renderCamera.pixelWidth, renderCamera.pixelHeight, <span class="number">24</span>);</span><br><span class="line">    renderCamera.targetTexture = cameraRenderTexture;</span><br><span class="line">    renderCamera.Render();</span><br><span class="line">    RenderTexture.active = cameraRenderTexture;</span><br><span class="line"></span><br><span class="line">    Texture2D cameraImage = <span class="keyword">new</span> Texture2D(renderCamera.pixelWidth, renderCamera.pixelHeight, TextureFormat.RGBAFloat, <span class="literal">false</span>);</span><br><span class="line">    cameraImage.ReadPixels(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, cameraRenderTexture.width, cameraRenderTexture.height), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cameraImage.Apply();</span><br><span class="line"></span><br><span class="line">    Color[] colors = cameraImage.GetPixels();</span><br><span class="line">    <span class="built_in">byte</span>[] cameraImageBytes = cameraImage.EncodeToTGA();</span><br><span class="line">    File.WriteAllBytes(Path.Combine(outputPath, <span class="string">&quot;cameraImage.tga&quot;</span>), cameraImageBytes);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保存深度">保存深度</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RenderTexture depthTarget;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    depthTarget = <span class="keyword">new</span> RenderTexture(<span class="number">1024</span>, <span class="number">1024</span>, <span class="number">0</span>, RenderTextureFormat.RHalf)</span><br><span class="line">    &#123;</span><br><span class="line">        autoGenerateMips = <span class="literal">false</span>,</span><br><span class="line">        useMipMap = <span class="literal">false</span>,</span><br><span class="line">        filterMode = FilterMode.Point</span><br><span class="line">    &#125;;</span><br><span class="line">    depthTarget.Create();</span><br><span class="line">    Camera.main.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveDepth</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个临时RT</span></span><br><span class="line">    RenderTexture depthRT = RenderTexture.GetTemporary(Screen.width, Screen.height, <span class="number">0</span>, depthTarget.format);</span><br><span class="line">    depthRT.filterMode = FilterMode.Point;</span><br><span class="line">    <span class="comment">// 将GPU的深度贴图Blit到临时RT上</span></span><br><span class="line">    Graphics.Blit(Shader.GetGlobalTexture(<span class="string">&quot;_CameraDepthTexture&quot;</span>), depthRT);</span><br><span class="line"><span class="comment">// 将临时RT的像素保存到Color数组</span></span><br><span class="line">    Texture2D depthTexture = <span class="keyword">new</span> Texture2D(depthRT.width, depthRT.height, TextureFormat.RFloat, <span class="literal">false</span>);</span><br><span class="line">    RenderTexture.active = depthRT;</span><br><span class="line">    depthTexture.ReadPixels(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, depthRT.width, depthRT.height), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    depthTexture.Apply();</span><br><span class="line">    Color[] pixels = depthTexture.GetPixels();</span><br><span class="line">    RenderTexture.active = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 编码、写贴图</span></span><br><span class="line">    <span class="built_in">byte</span>[] bytes = depthTexture.EncodeToPNG();</span><br><span class="line">    <span class="built_in">string</span> filename = Path.Combine(outputPath, <span class="string">&quot;depth.png&quot;</span>);</span><br><span class="line">File.WriteAllBytes(filename, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更高精度的RT">更高精度的RT</h3><p>我发现在保存相机RT时，每个通道的精度仅仅是8 bits，将这些通道乘以<code>255.0f</code>，就非常接近整数了</p><p>这其实是因为<code>cameraRenderTexture</code>的默认格式是ARGB32，每个通道仅8 bits，我只需要在其创建时设置一个更高精度的格式，比如ARGBFloat，每个通道32 bits，精度就大大提高了</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">RenderTexture cameraRenderTexture = new RenderTexture(renderCamera.pixelWidth, </span><br><span class="line">renderCamera.pixelHeight, 24, </span><br><span class="line"><span class="addition">+RenderTextureFormat.ARGBFloat</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#读表格</title>
      <link href="/program/CSharp%E8%A1%A8%E6%A0%BC/"/>
      <url>/program/CSharp%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1>C#读表格</h1><blockquote><p>这里使用<a href="https://github.com/dotnet/Open-XML-SDK">Open XML SDK</a>读xml和xlsx表格</p></blockquote><h2 id="读XLSX">读XLSX</h2><h3 id="打开一个xlsx">打开一个xlsx</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">readResourceXlsxTable</span><span class="params">(string xlsx_path, string prefix_path, Dictionary&lt;string, string&gt; id_to_texture_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">using</span> (SpreadsheetDocument doc = SpreadsheetDocument.<span class="built_in">Open</span>(xlsx_path, <span class="literal">false</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        OpenXmlElementList childs = doc.WorkbookPart.Workbook.Sheets.ChildElements;</span><br><span class="line">        OpenXmlElement sheet_element = childs.<span class="built_in">GetItem</span>(<span class="number">0</span>);</span><br><span class="line">        Sheet sheet = (Sheet)sheet_element;</span><br><span class="line">        Worksheet worksheet = (doc.WorkbookPart.<span class="built_in">GetPartById</span>(sheet.Id.Value) as WorksheetPart).Worksheet;</span><br><span class="line">        IEnumerable&lt;Row&gt; rows = worksheet.<span class="built_in">GetFirstChild</span>&lt;SheetData&gt;().<span class="built_in">Descendants</span>&lt;Row&gt;();</span><br><span class="line">        SharedStringTablePart string_table_part = doc.WorkbookPart.SharedStringTablePart;</span><br><span class="line">        <span class="type">int</span> excel_row_count = rows.<span class="built_in">Count</span>();</span><br><span class="line">        <span class="keyword">if</span> (excel_row_count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;string&gt; string_table = <span class="keyword">new</span> <span class="built_in">List</span>&lt;string&gt;();</span><br><span class="line">            foreach (OpenXmlElement node in string_table_part.SharedStringTable.ChildElements)</span><br><span class="line">            &#123;</span><br><span class="line">                string_table.<span class="built_in">Add</span>(node.InnerText);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// MARK: 这里不是真正的row和column</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> row_index = <span class="number">0</span>; row_index &lt; excel_row_count; row_index++)</span><br><span class="line">            &#123;</span><br><span class="line">                var cells = rows.<span class="built_in">ElementAt</span>(row_index).<span class="built_in">Descendants</span>&lt;Cell&gt;().<span class="built_in">ToList</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> column_index = <span class="number">0</span>; column_index &lt; cells.Length; column_index++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Cell cell = cells.<span class="built_in">ElementAt</span>(column_index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读单元格数据">读单元格数据</h3><p>值得注意的是，单元格数据是有类型的，尤其是<strong>字符串</strong>，有的是直接内嵌到<code>cell.CellValue.InnerText</code>中，有的是放在<code>SharedStringTablePart</code>中，单元格内只保留一个引用</p><p>于是我们需要先拿到共享字符串表的内容，然后用引用ID去得到真正的字符串</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">SharedStringTablePart string_table_part = doc.WorkbookPart.SharedStringTablePart;</span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; string_table = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (OpenXmlElement node <span class="keyword">in</span> string_table_part.SharedStringTable.ChildElements)</span><br><span class="line">&#123;</span><br><span class="line">    string_table.Add(node.InnerText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cell.DataType == CellValues.SharedString)</span><br><span class="line">&#123;</span><br><span class="line">    text = string_table.ElementAt(Convert.ToInt32(cell.CellValue.InnerText));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    text = cell.CellValue.InnerText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元格坐标">单元格坐标</h3><p>我们使用Excel打开一个表格，每个单元格是通过英文字母和数字拼成一个ID，这个是真正的坐标，存储在<code>cell.CellReference</code>中，我们上面的遍历，如果遇到空单元格，会出现问题（会认为空单元格不存在）</p><p>可以解析<code>CellReference</code>获得真正的坐标</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetRowAndColumn</span>(<span class="params"><span class="built_in">string</span> cellReference, <span class="keyword">out</span> <span class="built_in">int</span> row, <span class="keyword">out</span> <span class="built_in">int</span> column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    row = <span class="number">0</span>;</span><br><span class="line">    column = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> columnLetters = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// column index</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> cellReference)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">char</span>.IsLetter(c))</span><br><span class="line">        &#123;</span><br><span class="line">            columnLetters += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    column = ColumnLettersToNumber(columnLetters);</span><br><span class="line">    <span class="comment">// row index</span></span><br><span class="line">    <span class="built_in">int</span>.TryParse(cellReference.Substring(columnLetters.Length), <span class="keyword">out</span> row);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ColumnLettersToNumber</span>(<span class="params"><span class="built_in">string</span> letters</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> letters)</span><br><span class="line">    &#123;</span><br><span class="line">        result = result * <span class="number">26</span> + (c - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GetRowAndColumn(cell.CellReference, <span class="keyword">out</span> <span class="built_in">int</span> real_row, <span class="keyword">out</span> <span class="built_in">int</span> real_column);</span><br></pre></td></tr></table></figure><h2 id="读XML">读XML</h2><p>这个也可以读XML</p><h3 id="打开一个xml">打开一个xml</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">readResourceXmlTable</span>(<span class="params"><span class="built_in">string</span> xml_path, <span class="built_in">string</span> prefix_path, Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; id_to_texture_path</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XmlDocument xml_doc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        xml_doc.Load(xml_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Error: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问Sheet">访问Sheet</h3><p>用Excel打开一个表格，我们可以看到左下角有好多Sheet</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">XmlNamespaceManager ns_manager = <span class="keyword">new</span> XmlNamespaceManager(xml_doc.NameTable);</span><br><span class="line">ns_manager.AddNamespace(<span class="string">&quot;ss&quot;</span>, <span class="string">&quot;urn:schemas-microsoft-com:office:spreadsheet&quot;</span>);</span><br><span class="line">XmlNodeList work_sheet_nodes = xml_doc.SelectNodes(<span class="string">&quot;//ss:Worksheet&quot;</span>, ns_manager);</span><br><span class="line"><span class="keyword">foreach</span> (XmlNode work_sheet_node <span class="keyword">in</span> work_sheet_nodes)</span><br><span class="line">&#123;</span><br><span class="line">    XmlAttribute name_attribute = work_sheet_node.Attributes[<span class="string">&quot;ss:Name&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (name_attribute != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        XmlNode table_node = work_sheet_node.SelectSingleNode(<span class="string">&quot;ss:Table&quot;</span>, ns_manager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问行和列">访问行和列</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">XmlNode table_node = work_sheet_node.SelectSingleNode(<span class="string">&quot;ss:Table&quot;</span>, ns_manager);</span><br><span class="line">XmlAttribute row_count_attribute = table_node.Attributes[<span class="string">&quot;ss:ExpandedRowCount&quot;</span>];</span><br><span class="line">XmlNodeList row_nodes = table_node.SelectNodes(<span class="string">&quot;ss:Row&quot;</span>, ns_manager);</span><br><span class="line"><span class="keyword">foreach</span> (XmlNode row_node <span class="keyword">in</span> row_nodes)</span><br><span class="line">&#123;</span><br><span class="line">    XmlNodeList cell_nodes = row_node.SelectNodes(<span class="string">&quot;ss:Cell&quot;</span>, ns_manager);</span><br><span class="line">    <span class="keyword">foreach</span> (XmlNode column_node <span class="keyword">in</span> cell_nodes)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perforce入门</title>
      <link href="/program/P4%E5%85%A5%E9%97%A8/"/>
      <url>/program/P4%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>Perforce入门</h1><blockquote><p>Perforce又称P4、P4V</p></blockquote><h2 id="为什么要用P4">为什么要用P4</h2><p>游戏开发一定需要一个版本管理工具，除了保留编辑记录外，还可以保护资产，遇到一些严重崩溃可以回退，不然会出现引擎打不开了，蓝图数据全丢了，一天白干的情况</p><p>为什么不使用Git呢？因为Git对二进制支持很差，即使使用LFS，对于动辄几十G的项目也无能为力</p><p>而且P4与Git不同，Git是在状态间切换，一旦切分支、拉新，就要将所有文件更新到某个状态，而P4可以只更新某个文件</p><p>此外P4也有分支、合并等概念，对于代码的处理也是完全可以接受的，因为强推P4</p><h2 id="个人P4环境搭建">个人P4环境搭建</h2><blockquote><p>指服务器和客户端都搭在本机，仅用作版本管理，不考虑协作</p></blockquote><h3 id="1-下载P4D">1. 下载P4D</h3><p><a href="https://www.perforce.com/downloads/helix-core-p4d">Download Helix Core (P4D) | Perforce</a></p><p>这是P4的服务器，一路继续就可以，记住服务器端口（默认是1666）</p><h3 id="2-下载P4V">2. 下载P4V</h3><p><a href="https://www.perforce.com/downloads/helix-visual-client-p4v">Download Helix Visual Client (P4V) | Perforce</a></p><p>这是P4客户端，一路继续</p><h3 id="3-创建用户">3. 创建用户</h3><p>打开P4V后，会弹出一个连接选项</p><p>Server填P4D创建时的端口（这里就是1666），如果是远程服务器，就是远程的链接:端口</p><p>点击User右侧的New，创建用户</p><p>结束后按OK进行P4V</p><p><img src="/images/p4%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7.png" class="lazyload" data-srcset="/images/p4%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="p4创建用户"></p><h3 id="4-创建Depot">4. 创建Depot</h3><p>此时我们是什么都没有的，所以要先创建一个Depot，这是类似仓库根节点的东西</p><p>点击Tools–Administration打开管理员面版</p><p><img src="/images/%E6%89%93%E5%BC%80%E7%AE%A1%E7%90%86%E5%91%98%E9%9D%A2%E6%9D%BF.png" class="lazyload" data-srcset="/images/%E6%89%93%E5%BC%80%E7%AE%A1%E7%90%86%E5%91%98%E9%9D%A2%E6%9D%BF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="打开管理员面板"></p><p><img src="/images/p4%E5%88%9B%E5%BB%BAdepot.png" class="lazyload" data-srcset="/images/p4%E5%88%9B%E5%BB%BAdepot.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="p4创建depot"></p><h3 id="5-创建Stream">5. 创建Stream</h3><p>stream很类似于Git的分支，我们回到P4V的窗口，点击一个Depot后创建一个Stream</p><p><img src="/images/p4%E5%88%9B%E5%BB%BAstream.png" class="lazyload" data-srcset="/images/p4%E5%88%9B%E5%BB%BAstream.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="p4创建stream"></p><p>Stream是可以衍生出其他子分支的</p><p>你可以在Stream Graph窗口查看Stream的关系，注意需要按一下Apply来刷新显示</p><p><img src="/images/StreamGraph.png" class="lazyload" data-srcset="/images/StreamGraph.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="StreamGraph"></p><p>Stream上的小显示器，就是当前Workspace所在的位置，你可以拖动显示器到其他Stream，以实现分支切换</p><h3 id="6-创建Workspace">6. 创建Workspace</h3><p>前面的东西都还是在服务端的，Workspace才是本地的东西，对着一个Stream右键，New Workspace</p><p>在Advanced里有一些配置，比如文件换行符格式，建议都用Unix</p><h2 id="P4使用">P4使用</h2><h3 id="拉新">拉新</h3><p>Get Lastest</p><h3 id="强制拉新">强制拉新</h3><p>对着某个文件夹右键——Get Revison</p><p><img src="/images/%E5%BC%BA%E5%88%B6%E6%8B%89%E6%96%B0.png" class="lazyload" data-srcset="/images/%E5%BC%BA%E5%88%B6%E6%8B%89%E6%96%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="强制拉新"></p><h3 id="Checkout">Checkout</h3><blockquote><p>俗称锁了，一般这些二进制文件会被设置为只读，被checkout后才可写</p></blockquote><p>一些二进制文件，如果不Checkout，就不能修改</p><p>文件被checkout后，其他人也能看到这个文件被谁checkout，有的文件一旦被其他人checkout，就不能对其进行修改，于是经常遇到有人来找你解锁某个文件</p><h3 id="收集修改">收集修改</h3><blockquote><p>基本是最常用的功能，尤其是一个人用时</p></blockquote><p>对着某个文件夹右键——Reconcile Offline Work</p><p><img src="/images/%E6%94%B6%E9%9B%86%E4%BF%AE%E6%94%B9.png" class="lazyload" data-srcset="/images/%E6%94%B6%E9%9B%86%E4%BF%AE%E6%94%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="收集修改"></p><p>收集的修改会放在Pending中</p><h3 id="回退">回退</h3><p>右键——Revert</p><h3 id="提交修改">提交修改</h3><p>将Pending中某个修改提交，不要用default提交，注意写提交信息</p><h3 id="暂存修改">暂存修改</h3><p>将某个Pending的修改临时“回退”掉，不过这个回退其实会上传到服务器</p><p>这个功能最大的作用其实是私下传递资源，你可以把你的修改给其它他人，而不需要提交、污染主分支</p><p>其他人可以通过ID找到这个Shelve，按右键UnShelve就可以将这个Change应用到本地</p><p><img src="/images/%E6%9A%82%E5%AD%98%E4%BF%AE%E6%94%B9.png" class="lazyload" data-srcset="/images/%E6%9A%82%E5%AD%98%E4%BF%AE%E6%94%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="暂存修改"></p><h3 id="解决冲突">解决冲突</h3><h2 id="P4-Net-API">P4 .Net API</h2><p>P4所有操作其实都是通过命令实现的，在Log窗口可以看到，使用C# Api可以模拟这些接口，实现一些工具</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Perforce.P4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">P4DoNetApi</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">P4Utils</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> uri;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> user;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> workspace;</span><br><span class="line">        <span class="keyword">private</span> Repository repo;</span><br><span class="line">        <span class="keyword">private</span> Connection conn;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">P4Utils</span>(<span class="params"><span class="built_in">string</span> uri, <span class="built_in">string</span> user, <span class="built_in">string</span> workspace</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.uri = uri;</span><br><span class="line">            <span class="keyword">this</span>.user = user;</span><br><span class="line">            <span class="keyword">this</span>.workspace = workspace;</span><br><span class="line">            repo = <span class="keyword">new</span> Repository(<span class="keyword">new</span> Server(<span class="keyword">new</span> ServerAddress(uri)));</span><br><span class="line">            conn = repo.Connection;</span><br><span class="line">            conn.UserName = user;</span><br><span class="line">            conn.Client = <span class="keyword">new</span> Client &#123; Name = workspace &#125;;</span><br><span class="line">            conn.Connect(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取当前workspace所有changelist描述</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>描述名list<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">getAllChangeListDescription</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; result = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            <span class="comment">// p4 changes -L -c &#123;workspace&#125; -m 10 -u &#123;user&#125;</span></span><br><span class="line">            ChangesCmdOptions options = <span class="keyword">new</span> ChangesCmdOptions(ChangesCmdFlags.LongDescription, workspace, <span class="number">10</span>, ChangeListStatus.None, user);</span><br><span class="line">            IList&lt;Changelist&gt; changelists = repo.GetChangelists(options, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> change <span class="keyword">in</span> changelists)</span><br><span class="line">            &#123;</span><br><span class="line">                result.Add(change.Description);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">getAllFileDepotPathInChangeList</span>(<span class="params"><span class="built_in">int</span> changelistId</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; result = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            Changelist changelist = repo.GetChangelist(changelistId);</span><br><span class="line">            <span class="keyword">if</span>(changelist != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span>(<span class="keyword">var</span> fileMetaData <span class="keyword">in</span> changelist.Files)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.Add(fileMetaData.DepotPath.Path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Perforce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLSL 转 Metal</title>
      <link href="/graphics/MetalShader/"/>
      <url>/graphics/MetalShader/</url>
      
        <content type="html"><![CDATA[<h1>HLSL 转 Metal</h1><p>为了方便游戏移植到iOS和Mac，苹果近年推出了一个Metal shader converter工具，这个工具可以搭配微软的DXC工具，实现HLSL转化为Metal</p><ol><li>编写HLSL</li><li>DXC将<code>.hlsl</code>转化为<code>.dxil</code></li><li>MSC将<code>.dxil</code>转化为<code>.metallib</code></li></ol><h2 id="原生Metal">原生Metal</h2><p>在了解HLSL转Metal之前，我们需要先知道原生Metal长什么样，我感觉和HLSL还是有不少区别的</p><h3 id="桥接文件">桥接文件</h3><p>首先Metal是有一个桥接的<code>.h</code>文件，这个文件连接了shader和程序（OC、Swift、C++），在这个文件中定义的枚举和结构，在两者中都可以使用</p><blockquote><p>TODO：研究一下能不能使用enum class，这样写枚举污染命名空间</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Common.h</span></span><br><span class="line">#<span class="keyword">import</span> &lt;simd/simd.h&gt;</span><br><span class="line">typedef <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="type">VertexBuffer</span> <span class="operator">=</span> <span class="number">0</span>,</span><br><span class="line">    <span class="type">UVBuffer</span> <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">    <span class="type">ColorBuffer</span> <span class="operator">=</span> <span class="number">2</span>,</span><br><span class="line">    <span class="type">TangentBuffer</span> <span class="operator">=</span> <span class="number">3</span>,</span><br><span class="line">    <span class="type">BitangentBuffer</span> <span class="operator">=</span> <span class="number">4</span>,</span><br><span class="line">    <span class="type">TerrainBuffer</span> <span class="operator">=</span> <span class="number">6</span>,</span><br><span class="line">    <span class="type">UniformsBuffer</span> <span class="operator">=</span> <span class="number">11</span>,</span><br><span class="line">    <span class="type">ParamsBuffer</span> <span class="operator">=</span> <span class="number">12</span>,</span><br><span class="line">    <span class="type">LightBuffer</span> <span class="operator">=</span> <span class="number">13</span>,</span><br><span class="line">    <span class="type">MaterialBuffer</span> <span class="operator">=</span> <span class="number">14</span>,</span><br><span class="line">    <span class="type">IdBuffer</span> <span class="operator">=</span> <span class="number">15</span></span><br><span class="line">&#125; <span class="type">BufferIndices</span>;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 某个swift中，使得枚举可以直接转为Int</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">BufferIndices</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> index: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我在这个<code>Common.h</code>中定义了一个枚举，每个枚举值都有其对应的整数，我们可以在管线和shader都使用这个枚举</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是基于swift的管线代码，我们将UBO设置到UniformsBuffer.index的位置</span></span><br><span class="line">encoder.setVertexBytes(</span><br><span class="line">            <span class="operator">&amp;</span>uniforms,</span><br><span class="line">            length: <span class="type">MemoryLayout</span>&lt;<span class="type">Uniforms</span>&gt;.stride,</span><br><span class="line">            index: <span class="type">UniformsBuffer</span>.index)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是Metal shader，将ubo设置到UniformsBuffer所对应的位置</span></span><br><span class="line"><span class="function">vertex VertexOut <span class="title">vertex_main</span><span class="params">(VertexIn in [[stage_in]],</span></span></span><br><span class="line"><span class="params"><span class="function">                             constant Uniforms &amp;uniforms [[buffer(UniformsBuffer)]])</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="HLSL">HLSL</h2><h3 id="静态成员">静态成员</h3><p>HLSL可以在shader中创建并初始化一个静态成员，但是需要加<code>static</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> float3x2 _positions = &#123; <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="Resource-binding">Resource binding</h3><p>HLSL的资产绑定是基于寄存器的</p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>t</td><td>SRV</td><td><code>Texture2D _BaseMap : register(t1);</code></td></tr><tr><td>s</td><td>samplers</td><td><code>SamplerState _BaseMap_ST : register(s1);</code></td></tr><tr><td>u</td><td>UAV</td><td></td></tr><tr><td>b</td><td>CBV</td><td><code>cbuffer ubo : register(b0) { UBO ubo; }</code></td></tr></tbody></table><h3 id="SPIR-V拓展">SPIR-V拓展</h3><h4 id="vk-push-constant">[[vk::push_constant]]</h4><blockquote><p>HLSL中Push Constants其实也是一个cbuffer，只是不绑定任何寄存器，是一个$Global cbuffer，你可以直接</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cbuffer Constants</span><br><span class="line">&#123;</span><br><span class="line">    float4x4 g_WorldViewProj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>用于标记常量数据，使得可以被<code>vkCmdPushConstants</code>推送</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PushConstant</span></span><br><span class="line">&#123;</span><br><span class="line">    float4x4 modelMatrix;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[vk::push_constant]]PushConstant pushConstant;</span><br></pre></td></tr></table></figure><h2 id="环境搭建">环境搭建</h2><h3 id="DXC-on-Mac">DXC on Mac</h3><p>git clone</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/microsoft/DirectXShaderCompiler.git</span><br></pre></td></tr></table></figure><p>submodule init</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> DirectXShaderCompiler</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure><p>build（话说这一步还挺慢的，感觉我的M1该退役了）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -G <span class="string">&quot;Unix Makefiles&quot;</span> -DCMAKE_BUILD_TYPE=Release -C ../cmake/caches/PredefinedParams.cmake -DCMAKE_OSX_ARCHITECTURES=<span class="string">&quot;x86_64;arm64&quot;</span></span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>我们会得到一大堆生成内容，我们只需要<code>build/bin/dxc-3.7</code>和<code>build/lib/libdxcompiler.dylib</code></p><ul><li>将<code>build/bin/dxc-3.7</code>拷贝到<code>/usr/local/bin/</code></li><li>将<code>build/lib/libdxcompiler.dylib</code>拷贝到<code>/usr/local/lib</code></li></ul><p>打开命令行，发现可以使用dxc命令了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dxc-3.7 -E MainVS -T vs_6_0 -Fo <span class="string">&quot;grass.v.dxil&quot;</span> <span class="string">&quot;grass.hlsl&quot;</span></span><br></pre></td></tr></table></figure><h3 id="MSC">MSC</h3><p><a href="https://download.developer.apple.com/Developer_Tools/Metal_shader_converter_1.1/Metal_Shader_Converter_1.1.pkg">下载MSC</a>后，双击安装即可</p><blockquote><p>安装完毕你可以在<code>/usr/local/lib</code>找到对应的库，如果你的程序需要运行时生成 Metal Shader，可以将这个库嵌入项目中</p></blockquote><p>你可以使用命令行编译了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">metal-shaderconverter grass.v.dxil -o ./grass.metallib</span><br></pre></td></tr></table></figure><p>使用参数<code>--output-reflection-file</code>还可以生成反射信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">metal-shaderconverter triangle.v.dxil -o ./triangle.metallib --output-reflection-file a.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;EntryPoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MainVS&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;FunctionConstants&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;NeedsFunctionConstants&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Resources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ShaderID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9969595390685293918&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ShaderType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vertex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;TopLevelArgumentBuffer&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;instance_id_index&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_primitives_per_mesh_threadgroup&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;needs_draw_params&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vertex_id_index&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vertex_inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;columnCount&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;elementType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Float&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;position0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vertex_output_size_in_bytes&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vertex_outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;columnCount&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;elementType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Float&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sv_position0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="SPIRV">SPIRV</h3><p>除了官方的MSC，还可以使用SPIRV</p><blockquote><p>我不太清楚MSC要如何加入调试信息，但SPIRV可以很容易加入</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dxc-3.7 -E MainPS -spirv -Zi -Qembed_debug -O0 -T ps_6_0 -Fo <span class="string">&quot;triangle.frag.spirv&quot;</span> <span class="string">&quot;triangle.hlsl&quot;</span></span><br><span class="line">spirv-cross --msl triangle.frag.spirv --output triangle.frag.metal</span><br><span class="line">xcrun -sdk macosx metal -c -frecord-sources triangle.frag.metal -o triangle.frag.air</span><br><span class="line">xcrun -sdk macosx metallib triangle.frag.air -o triangle.frag.metallib</span><br></pre></td></tr></table></figure><p>通过安装<a href="https://developer.apple.com/download/all/?q=metal%20developer%20tools%20for%20windows">Metal Developer Tools For Windows</a>，可以在Window下使用metal和metallib工具</p><h2 id="MSC-2">MSC</h2><h3 id="片元着色器">片元着色器</h3><p>片元着色器比较好实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">&#123;</span><br><span class="line">    float4 position : SV_Position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">MainPS</span><span class="params">( v2f vin )</span> : SV_Target</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用DXC和MSC编译后，得到<code>triangle.f.metallib</code>，并放在路径<code>Metal-Tutorial/triangle.p.metallib</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MTL::Library* lib = metalDevice-&gt;<span class="built_in">newLibrary</span>(NS::String::<span class="built_in">string</span>(<span class="string">&quot;Metal-Tutorial/triangle.p.metallib&quot;</span>, NS::ASCIIStringEncoding), <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">MTL::Function* frag = lib-&gt;<span class="built_in">newFunction</span>(NS::String::<span class="built_in">string</span>(<span class="string">&quot;MainPS&quot;</span>, NS::ASCIIStringEncoding));</span><br><span class="line"></span><br><span class="line">MTL::RenderPipelineDescriptor* renderPipelineDescriptor = MTL::RenderPipelineDescriptor::<span class="built_in">alloc</span>()-&gt;<span class="built_in">init</span>();</span><br><span class="line">renderPipelineDescriptor-&gt;<span class="built_in">setFragmentFunction</span>(frag);</span><br></pre></td></tr></table></figure><h3 id="顶点着色器">顶点着色器</h3><p>metal有两种传入顶点信息的方式</p><h4 id="vertex-descriptor">vertex descriptor</h4><p>一种是使用VertexDescriptor描述VertexBuffer，shader大概长这样</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexIn</span> &#123;</span><br><span class="line">    float4 position [[<span class="built_in">attribute</span>(Position)]];</span><br><span class="line">    float3 normal [[<span class="built_in">attribute</span>(Normal)]];</span><br><span class="line">    float2 uv [[<span class="built_in">attribute</span>(UV)]];</span><br><span class="line">    float3 color [[<span class="built_in">attribute</span>(Color)]];</span><br><span class="line">    float3 tangent [[<span class="built_in">attribute</span>(Tangent)]];</span><br><span class="line">    float3 bitangent [[<span class="built_in">attribute</span>(Bitangent)]];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">vertex VertexOut <span class="title">vertex_main</span><span class="params">(VertexIn in [[stage_in]])</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>用HLSL写大概是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PSInput <span class="title">VSMain</span><span class="params">(float4 position : POSITION, float4 uv : TEXCOORD)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="binding-buffer">binding buffer</h4><p>另一种是binding一个buffer和vertexID，类似于instance</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    float3 position;</span><br><span class="line">    float3 normal;</span><br><span class="line">    float3 tangent;</span><br><span class="line">    float3 bitangent;</span><br><span class="line">    float2 textureCoordinate;</span><br><span class="line">    <span class="type">int</span> diffuseTextureIndex;</span><br><span class="line">    <span class="type">int</span> specularTextureIndex;</span><br><span class="line">    <span class="type">int</span> normalMapIndex;</span><br><span class="line">    <span class="type">int</span> emissiveMapIndex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">vertex OutData <span class="title">vertexShader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   uint vertexID [[vertex_id]],</span></span></span><br><span class="line"><span class="params"><span class="function">   constant Vertex* vertexData [[buffer(<span class="number">0</span>)]])</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>用HLSL写，大概是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexData</span></span><br><span class="line">&#123;</span><br><span class="line">    float4 position;</span><br><span class="line">    float4 normal;</span><br><span class="line">    float4 texcoord;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StructuredBuffer&lt;VertexData&gt; vertexData : <span class="built_in">register</span>(t0, space0);</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">MainVS</span><span class="params">( uint vertexId : SV_VertexID,</span></span></span><br><span class="line"><span class="params"><span class="function">            uint instanceId : SV_InstanceID )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VertexData vd = vertexData[ vertexId ];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小引擎接入简单刚体物理系统</title>
      <link href="/graphics/JoltPhysics/"/>
      <url>/graphics/JoltPhysics/</url>
      
        <content type="html"><![CDATA[<h1>Jolt Physics</h1><p>最近给小引擎接入了刚体物理系统，发现这个东西真的很简单，在此记录一下</p><h2 id="关于物理系统">关于物理系统</h2><p>主流的物理系统接口都很相似，而且制作的非常完善，像刚体物理这种比较基础的模块，接起来十分简单</p><p>目前大多数物理引擎，还是在CPU多线程模拟，英伟达有一套基于GPU的，但没有开源</p><p>我接入的是Jolt Physics，是一个非常轻量级的物理系统</p><h2 id="cmake">cmake</h2><p>代码拉取</p><p><a href="https://github.com/jrouwe/JoltPhysics.git">https://github.com/jrouwe/JoltPhysics.git</a></p><p>构建（动态库）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(NOT TARGET JoltPhysics)</span><br><span class="line">  <span class="built_in">set</span>(BUILD_SHARED_LIBS ON)</span><br><span class="line">  <span class="built_in">add_subdirectory</span>(JoltPhysics/Build)</span><br><span class="line">  <span class="built_in">set_property</span>(TARGET Jolt PROPERTY FOLDER <span class="string">&quot;ThirdParty&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br></pre></td></tr></table></figure><p>链接</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(Engine PUBLIC Jolt)</span><br></pre></td></tr></table></figure><h2 id="简单的刚体物理">简单的刚体物理</h2><h3 id="初始化">初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">JPH::<span class="built_in">RegisterDefaultAllocator</span>();</span><br><span class="line">JPH::Trace = PhysicsManager::TraceImpl;</span><br><span class="line">JPH::AssertFailed = PhysicsManager::AssertFailedImpl;</span><br><span class="line">JPH::Factory::sInstance = <span class="keyword">new</span> JPH::<span class="built_in">Factory</span>();</span><br><span class="line">JPH::<span class="built_in">RegisterTypes</span>();</span><br><span class="line">m_temp_allocator = <span class="keyword">new</span> JPH::<span class="built_in">TempAllocatorImpl</span>(<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">m_job_system = <span class="keyword">new</span> JPH::<span class="built_in">JobSystemThreadPool</span>(m_max_job_count, m_max_barrier_count, m_max_concurrent_job_count);</span><br><span class="line">m_physics_system = <span class="keyword">new</span> JPH::<span class="built_in">PhysicsSystem</span>();</span><br><span class="line">m_physics_system-&gt;<span class="built_in">Init</span>(m_max_body_count, m_max_body_count, m_max_body_pairs, m_max_contact_constraints,</span><br><span class="line">layer_interface, ob_layer_filter, oo_layer_filter);</span><br></pre></td></tr></table></figure><p>添加监听</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">body_activation_listener = <span class="keyword">new</span> <span class="built_in">MyBodyActivationListener</span>();</span><br><span class="line">m_physics_system-&gt;<span class="built_in">SetBodyActivationListener</span>(body_activation_listener);</span><br><span class="line">contact_listener = <span class="keyword">new</span> <span class="built_in">MyContactListener</span>();</span><br><span class="line">m_physics_system-&gt;<span class="built_in">SetContactListener</span>(contact_listener);</span><br></pre></td></tr></table></figure><p>设置重力方向（默认是y轴，我的小引擎是z轴朝上）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">JPH::Vec3 m_gravity&#123; <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">-9.8f</span> &#125;;</span><br><span class="line">m_physics_system-&gt;<span class="built_in">SetGravity</span>(m_gravity);</span><br></pre></td></tr></table></figure><h3 id="监听">监听</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContactListener</span> : <span class="keyword">public</span> JPH::ContactListener</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> JPH::ValidateResult<span class="title">OnContactValidate</span><span class="params">(<span class="type">const</span> JPH::Body&amp; inBody1, <span class="type">const</span> JPH::Body&amp; inBody2, JPH::RVec3Arg inBaseOffset, <span class="type">const</span> JPH::CollideShapeResult&amp; inCollisionResult)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnContactAdded</span><span class="params">(<span class="type">const</span> JPH::Body&amp; inBody1, <span class="type">const</span> JPH::Body&amp; inBody2, <span class="type">const</span> JPH::ContactManifold&amp; inManifold, JPH::ContactSettings&amp; ioSettings)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnContactPersisted</span><span class="params">(<span class="type">const</span> JPH::Body&amp; inBody1, <span class="type">const</span> JPH::Body&amp; inBody2, <span class="type">const</span> JPH::ContactManifold&amp; inManifold, JPH::ContactSettings&amp; ioSettings)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnContactRemoved</span><span class="params">(<span class="type">const</span> JPH::SubShapeIDPair&amp; inSubShapePair)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBodyActivationListener</span> : <span class="keyword">public</span> JPH::BodyActivationListener</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnBodyActivated</span><span class="params">(<span class="type">const</span> JPH::BodyID&amp; inBodyID, <span class="type">uint64_t</span> inBodyUserData)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnBodyDeactivated</span><span class="params">(<span class="type">const</span> JPH::BodyID&amp; inBodyID, <span class="type">uint64_t</span> inBodyUserData)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Interface">Interface</h3><p>物理系统有一个粗粒度的碰撞检测和逐物体的精细检测</p><p>粗粒度的原理是根据坐标轴简单判断，叫BroadPhase</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Layers</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> JPH::ObjectLayer NON_MOVING = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> JPH::ObjectLayer MOVING = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> JPH::ObjectLayer NUM_LAYERS = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> BroadPhaseLayers</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> JPH::BroadPhaseLayer <span class="title">NON_MOVING</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> JPH::BroadPhaseLayer <span class="title">MOVING</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">NUM_LAYERS</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Broadphase use Axis test</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BPLayerInterfaceImpl</span> <span class="keyword">final</span> : <span class="keyword">public</span> JPH::BroadPhaseLayerInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BPLayerInterfaceImpl</span>();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetNumBroadPhaseLayers</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> JPH::BroadPhaseLayer <span class="title">GetBroadPhaseLayer</span><span class="params">(JPH::ObjectLayer inLayer)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">GetBroadPhaseLayerName</span><span class="params">(JPH::BroadPhaseLayer inLayer)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">JPH::BroadPhaseLayer m_object_to_broad_phase[Layers::NUM_LAYERS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectVsBroadPhaseLayerFilterImpl</span> : <span class="keyword">public</span> JPH::ObjectVsBroadPhaseLayerFilter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">ShouldCollide</span><span class="params">(JPH::ObjectLayer inLayer1, JPH::BroadPhaseLayer inLayer2)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectLayerPairFilterImpl</span> : <span class="keyword">public</span> JPH::ObjectLayerPairFilter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">ShouldCollide</span><span class="params">(JPH::ObjectLayer inObject1, JPH::ObjectLayer inObject2)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构建物理场景">构建物理场景</h3><p>添加静态的Box和动态的Sphere</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">JPH::BodyInterface&amp; body_interface = m_physics_system-&gt;<span class="built_in">GetBodyInterface</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; scene.go_id_list.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> go_id = scene.go_id_list[i];</span><br><span class="line">Bounding&amp; bounding = scene.bounding_list[i];</span><br><span class="line"><span class="keyword">if</span> (bounding.type == BoundingType::Box)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">JPH::BoxShapeSettings <span class="title">floor_shape_settings</span><span class="params">(JPH::Vec3(bounding.data[<span class="number">0</span>], bounding.data[<span class="number">1</span>], bounding.data[<span class="number">2</span>]))</span></span>;</span><br><span class="line">JPH::ShapeSettings::ShapeResult floor_shape_result = floor_shape_settings.<span class="built_in">Create</span>();</span><br><span class="line">JPH::ShapeRefC floor_shape = floor_shape_result.<span class="built_in">Get</span>();</span><br><span class="line"><span class="function">JPH::BodyCreationSettings <span class="title">floor_settings</span><span class="params">(floor_shape, JPH::RVec3(bounding.position[<span class="number">0</span>], bounding.position[<span class="number">1</span>], bounding.position[<span class="number">2</span>]), </span></span></span><br><span class="line"><span class="params"><span class="function">JPH::Quat::sIdentity(), JPH::EMotionType::Static, Layers::NON_MOVING)</span></span>;</span><br><span class="line">JPH::Body* box = body_interface.<span class="built_in">CreateBody</span>(floor_settings);</span><br><span class="line">body_interface.<span class="built_in">AddBody</span>(box-&gt;<span class="built_in">GetID</span>(), JPH::EActivation::DontActivate);</span><br><span class="line">m_go_id_to_body_id[go_id] = box-&gt;<span class="built_in">GetID</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bounding.type == BoundingType::Sphere)</span><br><span class="line">&#123;</span><br><span class="line">JPH::BodyCreationSettings <span class="built_in">sphere_settings</span>(<span class="keyword">new</span> JPH::<span class="built_in">SphereShape</span>(bounding.data[<span class="number">0</span>]), JPH::<span class="built_in">RVec3</span>(bounding.position[<span class="number">0</span>], bounding.position[<span class="number">1</span>], bounding.position[<span class="number">2</span>]), </span><br><span class="line">JPH::Quat::<span class="built_in">sIdentity</span>(), JPH::EMotionType::Dynamic, Layers::MOVING);</span><br><span class="line">JPH::BodyID sphere_id = body_interface.<span class="built_in">CreateAndAddBody</span>(sphere_settings, JPH::EActivation::Activate);</span><br><span class="line">m_go_id_to_body_id[go_id] = sphere_id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_physics_system-&gt;<span class="built_in">OptimizeBroadPhase</span>();</span><br></pre></td></tr></table></figure><h3 id="模拟">模拟</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PhysicsManager::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">float</span> dt = Time::<span class="built_in">getInstance</span>().<span class="built_in">getDeltaTime</span>();</span><br><span class="line">m_physics_system-&gt;<span class="built_in">Update</span>(dt, <span class="number">1</span>, m_temp_allocator, m_job_system);</span><br><span class="line">    <span class="comment">// 用物理模拟的数据修改渲染场景信息</span></span><br><span class="line">JPH::BodyInterface&amp; body_interface = m_physics_system-&gt;<span class="built_in">GetBodyInterface</span>();</span><br><span class="line">JPH::RVec3 position = body_interface.<span class="built_in">GetCenterOfMassPosition</span>(m_go_id_to_body_id[<span class="number">1</span>]);</span><br><span class="line">m_scene.mesh_transform_list[<span class="number">1</span>].position = &#123; position.<span class="built_in">GetX</span>(), position.<span class="built_in">GetY</span>(), position.<span class="built_in">GetZ</span>() &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Physics </tag>
            
            <tag> Jolt Physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>头发渲染学习</title>
      <link href="/graphics/%E5%A4%B4%E5%8F%91%E6%B8%B2%E6%9F%93%E5%AD%A6%E4%B9%A0/"/>
      <url>/graphics/%E5%A4%B4%E5%8F%91%E6%B8%B2%E6%9F%93%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>头发渲染学习</h1><p>最近因为不了解头发渲染的流程，整了乌龙，把正确的结果当成错误了。于是打算学习一下头发渲染的流程</p><p>面片发是由大量非平面面片制作，他们的切线沿着头发丝的方向，渲染时开启双面绘制</p><h2 id="渲染方程">渲染方程</h2><h3 id="传入切线">传入切线</h3><p>UE5在绘制头发时，向GBuffer的法线位写入的是Tangent</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WriteGBuffer</span>(</span><br><span class="line">    Samples_Tangent,<span class="comment">// 写入切线而非法线</span></span><br><span class="line">    Samples_Specular,</span><br><span class="line">    Samples_BaseColor,</span><br><span class="line">    Samples_Roughnesss,</span><br><span class="line">    Samples_LightChannelMask,</span><br><span class="line">    Samples_Backlit,</span><br><span class="line">    Samples_Depth,</span><br><span class="line">    OutGBufferA,</span><br><span class="line">    OutGBufferB,</span><br><span class="line">    OutGBufferC,</span><br><span class="line">    OutGBufferD,</span><br><span class="line">    OutGBufferE,</span><br><span class="line">    OutDepth);</span><br></pre></td></tr></table></figure><p>美术在头发面片制作时，将切线沿着发丝方向，这些切线正好也是一根根发丝方向的切线，用于控制各项异性的高光</p><p><img src="/images/HairTangent.png" class="lazyload" data-srcset="/images/HairTangent.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="HairTangent"></p><h3 id="BSDF">BSDF</h3><p>如下图所示，毛发渲染通常由三部分组成：</p><ul><li>反射（R，下图1）</li><li>传播-传播（TT，下图2）</li><li>传播-反射-传播（TRT，下图3）</li></ul><p><img src="/images/HairDiagram.gif" class="lazyload" data-srcset="/images/HairDiagram.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="HairDiagram"></p><h2 id="参考">参考</h2><p><a href="https://cseweb.ucsd.edu/~ravir/paper_fur.pdf">Physically-Accurate Fur Reflectance: Modeling, Measurement and Rendering</a></p><p><a href="https://www.astroite.com/Graphics/Rendering/Hair/HairRendering.html#%E5%AD%A6%E6%9C%AF%E7%A0%94%E7%A9%B6">从理论到实现的头发渲染—基于UE4</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hair </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Rust与WebAssembly画三角形</title>
      <link href="/program/Rust-WebAssembly/"/>
      <url>/program/Rust-WebAssembly/</url>
      
        <content type="html"><![CDATA[<h1>使用Rust与WASM画三角形</h1><h2 id="概念">概念</h2><p>WASM是一种二进制格式，我们可以将一些语言编译为这种格式，使得代码可以在浏览器中运行</p><p>与Typescript转JavaScript不同，WASM是一种编译好的二进制，性能会比那些“编一句运行一句的代码”性能好</p><p>WASM最初是为了C/C++设计的，但也很适合使用Rust，如果你是一个Rust信徒，这套逻辑很适合你</p><h2 id="环境安装">环境安装</h2><blockquote><p>Windows 11 + Winget</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">winget install node.js</span><br><span class="line">winget install rustup   </span><br></pre></td></tr></table></figure><p>下载wasm-pack：[链接](<a href="https://rustwasm.github.io/wasm-pack/installer/">wasm-pack (rustwasm.github.io)</a>)</p><h2 id="项目初始化">项目初始化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init rust-webpack</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p><img src="/images/rust_init.png" class="lazyload" data-srcset="/images/rust_init.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="rust_init"></p><p>此时会自动弹出一个网页，按F12可以发现，控制台输出了Hello World！</p><p><img src="/images/wasm_init.png" class="lazyload" data-srcset="/images/wasm_init.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="wasm_init"></p><h2 id="绘制三角形">绘制三角形</h2><p>在<code>static/index.html</code>中添加一个canvas</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"><span class="addition">+  &lt;canvas id=&quot;canvas&quot; tabindex=&quot;0&quot; height=&quot;600&quot; width=&quot;600&quot;&gt;</span></span><br><span class="line"><span class="addition">+    Your browser does not support the canvas.</span></span><br><span class="line"><span class="addition">+  &lt;/canvas&gt;</span></span><br><span class="line">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>在<code>Cargo.toml</code>中添加web-sys依赖</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">[dependencies.web-sys]</span><br><span class="line">version = &quot;0.3.22&quot;</span><br><span class="line"><span class="deletion">-features = [&quot;console&quot;]</span></span><br><span class="line"><span class="addition">+features = [&quot;console&quot;, &quot;Window&quot;, &quot;Document&quot;, &quot;HtmlCanvasElement&quot;, &quot;CanvasRenderingContext2d&quot;, &quot;Element&quot;]</span></span><br></pre></td></tr></table></figure><p>在<code>src/lib.rs</code>中添加绘制命令</p><blockquote><p>wasm_bindgen会export main_js，以便JavaScript调用</p></blockquote><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">#[wasm_bindgen(start)]</span><br><span class="line">pub fn main_js() -&gt; Result&lt;(), JsValue&gt; &#123;</span><br><span class="line">    // This provides better error messages in debug mode.</span><br><span class="line">    // It&#x27;s disabled in release mode so it doesn&#x27;t bloat up the file size.</span><br><span class="line">    #[cfg(debug_assertions)]</span><br><span class="line">    console_error_panic_hook::set_once();</span><br><span class="line"><span class="addition">+    let window = web_sys::window().unwrap();</span></span><br><span class="line"><span class="addition">+    let document = window.document().unwrap();</span></span><br><span class="line"><span class="addition">+    let canvas = document</span></span><br><span class="line"><span class="addition">+        .get_element_by_id(&quot;canvas&quot;)</span></span><br><span class="line"><span class="addition">+        .unwrap()</span></span><br><span class="line"><span class="addition">+        .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()</span></span><br><span class="line"><span class="addition">+        .unwrap();</span></span><br><span class="line"><span class="addition">+    let context = canvas</span></span><br><span class="line"><span class="addition">+        .get_context(&quot;2d&quot;)</span></span><br><span class="line"><span class="addition">+        .unwrap()</span></span><br><span class="line"><span class="addition">+        .unwrap()</span></span><br><span class="line"><span class="addition">+        .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()</span></span><br><span class="line"><span class="addition">+        .unwrap();</span></span><br><span class="line"><span class="addition">+    context.move_to(300.0, 0.0); // top of triangle</span></span><br><span class="line"><span class="addition">+    context.begin_path();</span></span><br><span class="line"><span class="addition">+    context.line_to(0.0, 600.0); // bottom left of triangle</span></span><br><span class="line"><span class="addition">+    context.line_to(600.0, 600.0); // bottom right of triangle</span></span><br><span class="line"><span class="addition">+    context.line_to(300.0, 0.0); // back to top of triangle</span></span><br><span class="line"><span class="addition">+    context.close_path();</span></span><br><span class="line"><span class="addition">+    context.stroke();</span></span><br><span class="line"><span class="addition">+    context.fill();</span></span><br><span class="line"></span><br><span class="line">    // Your code goes here!</span><br><span class="line">    console::log_1(&amp;JsValue::from_str(&quot;Hello world!&quot;));</span><br><span class="line"></span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存代码，即可触发热更（前端就是好啊）</p><p><img src="/images/%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2.png" class="lazyload" data-srcset="/images/%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="绘制三角形"></p><h2 id="绘制分形体">绘制分形体</h2><p>添加分形体代码</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_triangle</span>(context: &amp;web_sys::CanvasRenderingContext2d, points: [(<span class="type">f64</span>, <span class="type">f64</span>); <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> [top, left, right] = points;</span><br><span class="line">    context.<span class="title function_ invoke__">move_to</span>(top.<span class="number">0</span>, top.<span class="number">1</span>);</span><br><span class="line">    context.<span class="title function_ invoke__">begin_path</span>();</span><br><span class="line">    context.<span class="title function_ invoke__">line_to</span>(left.<span class="number">0</span>, left.<span class="number">1</span>);</span><br><span class="line">    context.<span class="title function_ invoke__">line_to</span>(right.<span class="number">0</span>, right.<span class="number">1</span>);</span><br><span class="line">    context.<span class="title function_ invoke__">line_to</span>(top.<span class="number">0</span>, top.<span class="number">1</span>);</span><br><span class="line">    context.<span class="title function_ invoke__">close_path</span>();</span><br><span class="line">    context.<span class="title function_ invoke__">stroke</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">midpoint</span>(point_1: (<span class="type">f64</span>, <span class="type">f64</span>), point_2: (<span class="type">f64</span>, <span class="type">f64</span>)) <span class="punctuation">-&gt;</span> (<span class="type">f64</span>, <span class="type">f64</span>) &#123;</span><br><span class="line">    ((point_1.<span class="number">0</span> + point_2.<span class="number">0</span>) / <span class="number">2.0</span>, (point_1.<span class="number">1</span> + point_2.<span class="number">1</span>) / <span class="number">2.0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sierpinski</span>(context: &amp;web_sys::CanvasRenderingContext2d, points: [(<span class="type">f64</span>, <span class="type">f64</span>); <span class="number">3</span>], depth: <span class="type">u8</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">draw_triangle</span>(&amp;context, points);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">depth</span> = depth-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> [top, left, right] = points;</span><br><span class="line">    <span class="keyword">if</span> depth &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">left_middle</span> = <span class="title function_ invoke__">midpoint</span>(top, left);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">right_middle</span> = <span class="title function_ invoke__">midpoint</span>(top, right);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bottom_middle</span> = <span class="title function_ invoke__">midpoint</span>(left, right);</span><br><span class="line">        <span class="title function_ invoke__">sierpinski</span>(&amp;context, [top, left_middle, right_middle], depth);</span><br><span class="line">        <span class="title function_ invoke__">sierpinski</span>(&amp;context, [left_middle, left, bottom_middle], depth);</span><br><span class="line">        <span class="title function_ invoke__">sierpinski</span>(&amp;context, [right_middle, bottom_middle, right], depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删去之前所有绘制内容，改为<code>sierpinski</code></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[wasm_bindgen(start)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main_js</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), JsValue&gt; &#123;</span><br><span class="line">    <span class="meta">#[cfg(debug_assertions)]</span></span><br><span class="line">    console_error_panic_hook::<span class="title function_ invoke__">set_once</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">window</span> = web_sys::<span class="title function_ invoke__">window</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">document</span> = window.<span class="title function_ invoke__">document</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">canvas</span> = document</span><br><span class="line">        .<span class="title function_ invoke__">get_element_by_id</span>(<span class="string">&quot;canvas&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">context</span> = canvas</span><br><span class="line">        .<span class="title function_ invoke__">get_context</span>(<span class="string">&quot;2d&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">sierpinski</span>(&amp;context, [(<span class="number">300.0</span>, <span class="number">0.0</span>), (<span class="number">0.0</span>, <span class="number">600.0</span>), (<span class="number">600.0</span>, <span class="number">600.0</span>)], <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E7%BB%98%E5%88%B6%E5%88%86%E5%BD%A2%E4%BD%93.png" class="lazyload" data-srcset="/images/%E7%BB%98%E5%88%B6%E5%88%86%E5%BD%A2%E4%BD%93.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="绘制分形体"></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> WebAssembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20特性</title>
      <link href="/program/C++20/"/>
      <url>/program/C++20/</url>
      
        <content type="html"><![CDATA[<h1>C++20特性</h1><blockquote><p>现在是2023年，C++23都出来很久了（尽管很多编译器没有实现全功能），但还是有着大量C++11/17的老项目，出于人力和风险的考虑并没有上新标准，我作为一个C++菜鸡，也没想着去了解C++20都更新了什么，直到最近遇到了很多语言层面的问题，于是想着学习一下C++20特性</p><p>当然这里面不止C++20</p></blockquote><h2 id="语言特性">语言特性</h2><h3 id="指定初始化">指定初始化</h3><p>可以只初始化一部分，可以指定想要初始化的部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student s &#123; .name = <span class="string">&quot;Jack&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="Lambda">Lambda</h3><p><code>[=]</code>以前可以隐式获取<code>this</code>，现在需要改为<code>[=, this]</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++20以前</span></span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="keyword">auto</span>&amp;&amp; ...args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(std::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++20以后</span></span><br><span class="line"><span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> ...T&gt;(T&amp;&amp; ...args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(std::forward(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for循环支持初始化">for循环支持初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> data = <span class="built_in">getData</span>(); <span class="keyword">auto</span>&amp; v: data)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指引switch编译优化">指引switch编译优化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">break</span>;</span><br><span class="line">    [[likely]] <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;</span><br><span class="line">    [[unlikely]] <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计理念">设计理念</h2><p>由于宏有各种各样的坏处，C++20开始，打算逐渐废除宏。然而宏在C++程序中其实非常普遍，很多写法高度依赖于此，C++标准委员会给了很多功能用于绕过宏</p><h3 id="std-source-location">std::source_location</h3><p>用于传递函数调用者的信息，比调用者的函数名、文件名</p><p>这是传统的使用宏写Log的方法，宏在这里还拼接传递了<code>__FUNCTION__</code>和<code>__VA_ARGS__</code>，使得输出中自动包含了函数名，而不需要手动传入</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Logger instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">log</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(...) Logger::getInstance().log(std::format(<span class="string">&quot;[&#123;&#125;] &#123;&#125;&quot;</span>, __FUNCTION__, std::format(__VA_ARGS__)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello World!&quot;</span>);<span class="comment">// [main] Hello World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是C++20的写法，使用了<code>std::source_location</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;source_location&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log2</span><span class="params">(<span class="type">const</span> std::string_view message, <span class="type">const</span> std::source_location location = std::source_location::current())</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; location.<span class="built_in">function_name</span>() &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Logger::<span class="built_in">log2</span>(<span class="string">&quot;Hello World!&quot;</span>);<span class="comment">// [int main()] Hello World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-应用">C++应用</h2><h3 id="预处理include">预处理include</h3><blockquote><p>感觉不是很好用，建议不用</p></blockquote><p>判断能不能include一个文件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pch.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&quot;pch.h&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; NUMBER &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Modules-模块">Modules 模块</h3><blockquote><p>更高级的PCH，现阶段这东西大项目完全没法用</p></blockquote><h4 id="优点">优点</h4><ul><li>没有头文件，以及相关的依赖问题</li><li>引入模块时不需要像头文件那样指定路径</li><li>编译速度非常快（C++引用头文件会巨幅降低编译速度，于是很多人喜欢在头文件中只放一个类指针，到用到里面内容的时候在引用头文件，这样会大幅提高编译速度）</li><li>显示指定导入导出</li><li>模块引入顺序无关</li><li>与现有的头文件兼容</li><li>未来也许会像Python那样提供pip和包管理器？</li></ul><h4 id="缺点">缺点</h4><ul><li>除了最新的MSVC，其他编译器都没怎么实现这个功能</li><li>MSVC自己擅自主张，不按C++标准改了很多东西</li><li>IDE不支持全局modules的提示和跳转（VS2022在2023年10月支持了，clion至今还是垃圾）</li><li>需要反复引入std头文件（在C++23有快捷引入方式，但MSVC实现的很阴间）</li><li>对第三方库极度不友好</li><li>没有保存修改，IDE几乎没法解析，大多数情况IDE不给智能提示</li><li>和头文件、宏混用时容易报错</li><li>缺少std头文件时报错几乎无法阅读，大量匹配问题</li><li>cmake对其支持相当差</li><li>有的编译器无法将<code>.cpp</code>识别为modules？？？</li><li>import是局部的，每一个文件都需要反复import modules</li><li>一些静态变量、函数要到被用到时才会报错，build通过的代码不能保证能运行</li></ul><h4 id="用例">用例</h4><p>以MSVC的写法为例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// student.ixx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> Student;</span><br><span class="line"><span class="keyword">import</span> &lt;string&gt;;</span><br><span class="line"><span class="keyword">namespace</span> Demo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>();</span><br><span class="line">        ~<span class="built_in">Student</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string m_name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// student.cppm</span></span><br><span class="line"><span class="keyword">import</span> Student;<span class="comment">// MSVC擅自废弃了module Student的写法，很离谱</span></span><br><span class="line"><span class="keyword">import</span> &lt;string&gt;;<span class="comment">// 反复import std也阴间了，C++23赶快端上来吧</span></span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">namespace</span> Demo</span><br><span class="line">&#123;</span><br><span class="line">    Student::<span class="built_in">Student</span>()&#123;</span><br><span class="line">        m_name = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Student::~<span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line">    Student::<span class="built_in">display</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计模式">设计模式</h2><blockquote><p>记住单例就行</p></blockquote><h3 id="单例（Singleton）">单例（Singleton）</h3><p>也分懒汉式和饿汉式，最常用的设计模式，讲了很多次</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> GameManager* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">m_instance = <span class="keyword">new</span> <span class="built_in">GameManager</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> GameManager* m_instance;</span><br><span class="line">    <span class="built_in">GameManager</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="工厂（Factory）">工厂（Factory）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Weapon</span>(std::string name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeaponFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Weapon* <span class="title">createWeapon</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Weapon</span>(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="享元（Flyweight）">享元（Flyweight）</h3><p>共享相似数据，对象仅拥有指向，下面的示例不同的享元类共用了工厂中的“颜色”</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象享元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元类 - 圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string color;  <span class="comment">// 内部状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">const</span> std::string&amp; color) : <span class="built_in">color</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Draw a &quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot; circle at position (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元类 - 矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string color;  <span class="comment">// 内部状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">const</span> std::string&amp; color) : <span class="built_in">color</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Draw a &quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot; rectangle at position (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, Shape*&gt; shapes;  <span class="comment">// 享元对象池</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shape* <span class="title">getShape</span><span class="params">(<span class="type">const</span> std::string&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shapes.<span class="built_in">find</span>(color) == shapes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果池中没有该颜色的图形，创建并加入池中</span></span><br><span class="line">            <span class="keyword">if</span> (color == <span class="string">&quot;Red&quot;</span>) &#123;</span><br><span class="line">                shapes[color] = <span class="keyword">new</span> <span class="built_in">Circle</span>(color);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color == <span class="string">&quot;Blue&quot;</span>) &#123;</span><br><span class="line">                shapes[color] = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shapes[color];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ShapeFactory shapeFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在不同位置绘制相同颜色的圆形和矩形</span></span><br><span class="line">    Shape* redCircle = shapeFactory.<span class="built_in">getShape</span>(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    redCircle-&gt;<span class="built_in">draw</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    Shape* blueRectangle = shapeFactory.<span class="built_in">getShape</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    blueRectangle-&gt;<span class="built_in">draw</span>(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次在不同位置绘制相同颜色的圆形</span></span><br><span class="line">    Shape* anotherRedCircle = shapeFactory.<span class="built_in">getShape</span>(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    anotherRedCircle-&gt;<span class="built_in">draw</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：虽然外部状态不同，但相同颜色的圆形共享内部状态，从而减少了对象的创建</span></span><br><span class="line">    <span class="comment">// 这符合享元模式的思想，通过共享尽可能多的相似对象来减少内存或计算开销</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察者（Observer）">观察者（Observer）</h3><h3 id="状态机（State）">状态机（State）</h3><h3 id="代理（Proxy）">代理（Proxy）</h3><h3 id="装饰者（Decorator）">装饰者（Decorator）</h3><h3 id="迭代器（Iterator）">迭代器（Iterator）</h3><h3 id="适配器（Adapter">适配器（Adapter)</h3><h3 id="命令（Command）">命令（Command）</h3><h2 id="面向对象">面向对象</h2><h2 id="模板元">模板元</h2><blockquote><p>除非是库代码，不然用模板元去优化业务代码，属实是往代码里下毒</p><p>更详细的信息可以看<a href="https://reubensun.com/program/C++template">C++模板</a></p></blockquote><h3 id="Traits">Traits</h3><p>为了减少相似代码，实现泛型，我们需要模板</p><p>对于一些特殊类型，我们往往需要特殊对待，于是需要模板特化</p><p>于是我们需要知道类型的<strong>特征</strong>，这就是Type Traits的作用</p><p>C++ STL中 Type Traits是一堆形如<code>IsXxxx&lt;T&gt;::value</code>的东西</p><h4 id="原理">原理</h4><blockquote><p>下面是boost库一些traits实现</p></blockquote><p>创建一个默认的行为和一个特例，仅当模板类型是特例时，value才是true</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span> &#123; <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">false</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span>&lt; <span class="type">void</span> &gt;&#123; <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">true</span>; &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer</span> &#123; <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">false</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer</span>&lt; T* &gt;&#123; <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">true</span>; &#125;;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ans = is_void&lt;T&gt;::value;</span><br><span class="line"><span class="keyword">auto</span> ans2 = is_pointer&lt;T&gt;::value;</span><br></pre></td></tr></table></figure><h4 id="std-true-type与std-false-type">std::true_type与std::false_type</h4><p>下面是通过类型萃取，判断一个类中是否有某个成员函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个支持Check的类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Check</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Check::someFunction() called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个不支持Check的类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCheck</span> &#123;</span><br><span class="line">    <span class="comment">// 没有someFunction成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasFunction_Execute</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">check</span><span class="params">(U* ptr)</span> -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;U&gt;().Execute(), std::true_type&#123;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::false_type <span class="title">check</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">check</span>&lt;T&gt;(<span class="literal">nullptr</span>))::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasFunction_Execute&lt;Check&gt;::value) &#123;</span><br><span class="line">        Check obj;</span><br><span class="line">        obj.<span class="built_in">Execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试NoCheck类</span></span><br><span class="line">    <span class="keyword">if</span> (hasFunction_Execute&lt;NoCheck&gt;::value) &#123;</span><br><span class="line">        <span class="comment">// 不会执行到这里，因为NoCheck类没有someFunction成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TMP">TMP</h3><blockquote><p>template metaprogramming（TMP）：将其他程序的<strong>代码视为数据</strong>的编程技术</p><p>TMP通常意味着代码可以被其他程序读取、生成、分析、转化，甚至运行时修改</p></blockquote><p>C++ TMP是一种用编译速度和存储空间换运行时速度的技术，将计算放在编译期，可以提高运行时性能</p><h4 id="递归">递归</h4><p>C++ TMP很适合写递归，比如计算阶乘</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title">Factorial</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (X == <span class="number">0</span>) ? <span class="number">1</span> : X * <span class="built_in">Factorial</span>(X - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> x = <span class="built_in">Factorial</span>(<span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;<span class="comment">// 24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为汇编，发现程序并没有调用<code>Factorial</code>函数，而是直接找了一个立即数24</p><h4 id="构造函数">构造函数</h4><p>constexpr也可以修饰构造函数，创建编译器常量，以提高性能</p><p>使用该功能需要构造函数体的<strong>简单性</strong>，比如不能有虚函数，不能使用动态内存分配，条件语句，成员必须使用常量表达式初始化，递归必须在编译器能中止</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> : value(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; obj1.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串">字符串</h2><h3 id="std-string-view">std::string_view</h3><p>可以看作一个封装好的轻量级<code>const std::string&amp;</code>，只读、不拥有字符串所有权，性能很好，非常推荐使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_string_view</span><span class="params">(std::string_view str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string_view str_view = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="built_in">print_string_view</span>(str_view);</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="built_in">print_string_view</span>(str);</span><br><span class="line">    <span class="built_in">print_string_view</span>(<span class="string">&quot;Hello, World!&quot;</span>);<span class="comment">// 字符串常量字面量是一个左值，生命周期和整个程序一致，所以可以放心传</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL">STL</h2><h3 id="内存分配">内存分配</h3><p><code>&lt;memory&gt;</code>库提供了两个基础函数，<code>allocate()</code>和<code>deallocate()</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line"><span class="comment">// 开辟一个长度为10个int的空间</span></span><br><span class="line"><span class="type">int</span>* p = alloc.<span class="built_in">allocate</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 将数组第一个值构设为42</span></span><br><span class="line">std::allocator_traits&lt;std::allocator&lt;<span class="type">int</span>&gt;&gt;::<span class="built_in">construct</span>(alloc, p, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// 销毁这个数组</span></span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="concept-迭代器">concept 迭代器</h3><blockquote><p>C++迭代器已经是要被淘汰的概念了，但是新的C++标准仍然在对迭代器进行拓展</p></blockquote><p>concept可以对迭代器进行约束（也就是提要求<code>requires-expression</code>）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="keyword">concept</span> InputIterator = <span class="built_in">requires</span>(Iter iter) &#123;</span><br><span class="line">    &#123; iter++ &#125; -&gt; std::same_as&lt;Iter&gt;;<span class="comment">// 要求自增</span></span><br><span class="line">    &#123; iter != iter &#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;<span class="comment">// 要求能比较不等</span></span><br><span class="line">    &#123; ++iter &#125; -&gt; std::same_as&lt;Iter&amp;&gt;;<span class="comment">// 要求迭代器能前进</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;InputIterator Iter&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElements</span><span class="params">(Iter begin, Iter end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (begin != end) &#123;</span><br><span class="line">        std::cout &lt;&lt; *begin &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">printElements</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());<span class="comment">// 若不满足会编译报错</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式编程">函数式编程</h2><p>函数式编程将程序分解为函数（而非对象），使用表达式进行操作（而非语句）</p><p>函数式编程的核心是将一个大问题切成多个小问题</p><p>函数式编程更适合多线程</p><h3 id="std-function">std::function</h3><p>函数式编程将函数视为一等公民，常常将函数作为参数进行传递。不过一般公民通常需要有自己的成员和状态，函数指针无法满足我们的需求，重载类的<code>()</code>运算符有点太OOP了</p><p>C++提供了高阶函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::function&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">get_multiplier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::function&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [a](<span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> mul = <span class="built_in">get_multiplier</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">mul</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">10</span>)(<span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> mul3 = <span class="built_in">multiply</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">mul3</span>(<span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ranges-范围">Ranges 范围</h3><blockquote><p>感觉不同编译器对这个功能的支持差异好大</p></blockquote><ul><li>为std容器提供了简洁、强大、顺序可控的操作方式</li><li>引入view概念，运行创建一个惰性计算操作，不立即得到结果，提高内存利用率和性能</li><li>使用<code>|</code>和<code>-&gt;</code>操作符处理范围变量</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找array中偶数的数量</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> res = std::<span class="built_in">count_if</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);<span class="comment">// 2 个偶数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> res2 = arr | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : res2) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;<span class="comment">// 输出 2 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transform和filter返回的是一个range结构，而非容器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将vector中所有元素做平方，并去掉奇数项</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> square = [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i * i; &#125;;</span><br><span class="line"><span class="keyword">auto</span> odd = [](<span class="type">int</span> i)&#123; <span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> result = data | std::views::<span class="built_in">transform</span>(square) | std::views::<span class="built_in">filter</span>(odd);<span class="comment">// 1 9 25</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将一个二维数组展成一维</span></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; v2 = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> result2 = v2 | std::views::join;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个从1开始递增的数组，并对其进行平方，取前十个数（最后实际也只会计算十个数）</span></span><br><span class="line"><span class="keyword">auto</span> square = [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i * i; &#125;;</span><br><span class="line"><span class="keyword">auto</span> res = std::views::<span class="built_in">iota</span>(<span class="number">1</span>) |  std::views::<span class="built_in">transform</span>(square)| std::views::<span class="built_in">take</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : res) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">// 1 4 9 16 25 36 49 64 81 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="纯函数">纯函数</h3><blockquote><p>pure</p></blockquote><p>纯函数：不改变程序状态的函数</p><p>纯函数给定输入，无论执行多少次，都返回相同的结果</p><p>传函数不访问全局变量，仅使用输入的参数</p><h3 id="折叠">折叠</h3><p>折叠：将一组数据整合为数量更少的数据的方式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 一个累乘的示例</span></span><br><span class="line">    <span class="type">int</span> product = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">1</span>, std::<span class="built_in">multiplies</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product of elements: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::multiplies&lt;int&gt;()</code>可以替换为lambda表达式</p><h2 id="并发和多线程">并发和多线程</h2><blockquote><p>感觉不如TBB</p></blockquote><h3 id="std-thread">std::thread</h3><p>thread构造时就会启动线程</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_background</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Background: &quot;</span> &lt;&lt; i++ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread background&#123;print_background&#125;;</span><br><span class="line">    <span class="keyword">auto</span> j&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: &quot;</span> &lt;&lt; j++ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="join">join</h4><p>等待线程停止</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread tl</span><br><span class="line">    &#123;</span><br><span class="line">        [] &#123; std::cout &lt;&lt; <span class="string">&quot;A lambda passed to the thread&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    tl.<span class="built_in">join</span>();<span class="comment">// 等待 tl执行结束</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程结束后，与线程关联都是对象<code>tl</code>状态会被改变，此时调用<code>tl.joinable()</code>会返回<code>false</code>，你可以用<code>joinable()</code>来判断对象是否还在持有一个线程</p><h4 id="detach">detach</h4><blockquote><p>极其不推荐使用，多线程编程应该自行管理资源</p></blockquote><p>分离线程，线程对象将放弃对线程资源的所有权，线程将独立运行，结束后自动释放所有分配的资源</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tl.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure><h4 id="传参">传参</h4><p>构造时传参，这下参数会被传递到新线程的内存空间中</p><p>注意，即使参数标为引用，也是复制</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo2</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">int</span>&amp; a)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t1&#123; foo, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line">    std::thread t2&#123; foo2, <span class="number">3</span>, n &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用成员函数指针">使用成员函数指针</h4><p>成员函数指针也可以传给thread构造，自然也可以使用<code>std::bind</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Utils</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">task_run</span><span class="params">(<span class="type">int</span>)</span><span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Utils u;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">std::thread t&#123; &amp;Utils::task_run, &amp;u,n &#125;;</span><br><span class="line">std::thread t2&#123; std::<span class="built_in">bind</span>(&amp;Utils::task_run, &amp;u ,n) &#125;;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>成员指针必须和对象一起使用，不可以转换到函数指针单独使用</p><h3 id="std-this-thread">std::this_thread</h3><p>用于管理当前线程</p><h4 id="get-id">get_id</h4><p>打印当前线程id</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t&#123; [] &#123;</span><br><span class="line">        std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; &#125;;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sleep-for">sleep_for</h4><p>休眠一段时间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t&#123; [] &#123;</span><br><span class="line">        <span class="comment">// 打印休眠前时间戳</span></span><br><span class="line">        <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">auto</span> now_time = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current time:\t\t&quot;</span> &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_time), <span class="string">&quot;%H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 休眠2秒</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 打印休眠后时间戳</span></span><br><span class="line">        now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">        now_time = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current time:\t\t&quot;</span> &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_time), <span class="string">&quot;%H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125; &#125;;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>using namespace std::chrono_literals</code>，<code>3s</code>等同于<code>std::chrono::seconds(3)</code></p></blockquote><h4 id="sleep-until">sleep_until</h4><p>休眠到具体某个时间戳</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t&#123; [] &#123;</span><br><span class="line">        <span class="comment">// 打印休眠前时间戳</span></span><br><span class="line">        <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">auto</span> now_time = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current time:\t\t&quot;</span> &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_time), <span class="string">&quot;%H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 休眠到3秒以后</span></span><br><span class="line">        <span class="keyword">auto</span> wakeup_time = now + <span class="number">3</span>s;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_until</span>(wakeup_time);</span><br><span class="line">        <span class="comment">// 打印休眠后时间戳</span></span><br><span class="line">        now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">        now_time = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current time:\t\t&quot;</span> &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_time), <span class="string">&quot;%H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125; &#125;;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="yield">yield</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环等待isDone</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isDone</span>())&#123;</span><br><span class="line">    <span class="comment">// 使用yield可以减少CPU浪费，不会一直在这里高频空转</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-jthread">std::jthread</h3><blockquote><p>C++20提供的新线程库，可以完美替代std::thread</p></blockquote><p><code>std::jthread</code>在线程运行结束后再进行析构，可以确保线程安全退出</p><p>对异常和中断的支持更好</p><h4 id="RAII">RAII</h4><p>jthread与thread的一大不同：jthread在析构时会调用<code>join()</code></p><h4 id="主动停止">主动停止</h4><p>jthread可以主动请求某个线程结束，下面的代码在<code>Main</code>输出完毕后<code>background</code>也会停止输出</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_background</span><span class="params">(std::stop_token stoken)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stoken.<span class="built_in">stop_requested</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Background: &quot;</span> &lt;&lt; i++ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::jthread background&#123;print_background&#125;;</span><br><span class="line">    std::stop_token stoken = background.<span class="built_in">get_stop_token</span>();</span><br><span class="line">    <span class="keyword">auto</span> jx&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (jx &lt; <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: &quot;</span> &lt;&lt; jx++ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    background.<span class="built_in">request_stop</span>();<span class="comment">// 请求结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥信号量">互斥信号量</h3><p>多线程我们不可避免遇到线程竞争，尤其是读写</p><h4 id="lock">lock</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex locker;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_value&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">g</span><span class="params">(locker)</span></span>;<span class="comment">// 通过生命周期管理锁</span></span><br><span class="line">    global_value++;</span><br><span class="line">    std::cout &lt;&lt; global_value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t1&#123; inc &#125;;</span><br><span class="line">    std::thread t2&#123; inc &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try-lock">try_lock</h4><p>lock会立刻上锁，我们也可以进行尝试上锁，若锁已经被其他线程锁住，当前线程会立刻返回，可以去做其他事，而不是阻塞在这里</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex locker;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    <span class="keyword">if</span> (locker.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;线程：&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 获得锁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 临界区代码</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟临界区操作</span></span><br><span class="line">        locker.<span class="built_in">unlock</span>(); <span class="comment">// 解锁</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;线程：&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 释放锁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;线程：&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 获取锁失败 处理步骤&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="保护">保护</h4><p>不要将受保护数据传递给外部（比如通过指针、引用），这样保护就失去意义了</p><h4 id="死锁">死锁</h4><p>多个互斥信号量可能会导致死锁</p><h4 id="std-unique-lock">std::unique_lock</h4><h3 id="同步">同步</h3><p>future：在等待某一件事时做另一件事</p><h4 id="std-future">std::future</h4><p>与一个事件相关联</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">task</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;异步任务 ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = std::<span class="built_in">async</span>(task, <span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; f.<span class="built_in">valid</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; future.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; f.<span class="built_in">valid</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="std-shared-future">std::shared_future</h4><p>能关联多个事件</p><h4 id="std-async">std::async</h4><ul><li>deferred：惰性求值，不创建线程，等待调用wait、get再执行任务</li><li>async：在不同线程</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 这里的 auto 是 std::future&lt;void&gt;</span></span><br><span class="line"><span class="keyword">auto</span> f1 = std::<span class="built_in">async</span>(std::launch::deferred, f);<span class="comment">// 此时f1并不会执行</span></span><br><span class="line">f1.<span class="built_in">wait</span>();<span class="comment">// 主动让f1执行</span></span><br><span class="line"><span class="keyword">auto</span> f2 = std::<span class="built_in">async</span>(std::launch::async,f); <span class="comment">// 立刻开一个线程执行f2</span></span><br></pre></td></tr></table></figure><p>注意，<code>std::future</code>的析构会阻塞<code>std::async</code>，因此匿名Lambda并不能用了创建异步任务</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">async</span>(std::launch::async, []&#123; <span class="built_in">f</span>(); &#125;); <span class="comment">// 临时量的析构函数等待 f()</span></span><br><span class="line">std::<span class="built_in">async</span>(std::launch::async, []&#123; <span class="built_in">g</span>(); &#125;); <span class="comment">// f() 完成前不开始</span></span><br></pre></td></tr></table></figure><h3 id="协程">协程</h3><p>C++20引入了关键词<code>co_await</code>、<code>co_yield</code>、<code>co_return</code>，但是不能用，要到C++23以后才有相关的库</p><h2 id="参考">参考</h2><p><a href="https://blog.csdn.net/qq_41854911/article/details/119657617">C++11、14、17、20新增内容</a></p><p>《Expert C++》</p><p><a href="https://en.cppreference.com/w/cpp/20">CppReference</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan学习笔记</title>
      <link href="/graphics/Vulkan%E5%AD%A6%E4%B9%A0/"/>
      <url>/graphics/Vulkan%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>Vulkan学习笔记</h1><blockquote><p>在过去，我以为Vulkan只有高端安卓才会用，相当复杂，没有下定决心去学。后来发现很多桌面和主机游戏也在用Vulkan，Vulkan真的很出色很重要，于是这几天开始看<a href="https://github.com/nvpro-samples/build_all">英伟达nvpro</a>和<a href="https://vulkan-tutorial.com/Introduction">Vulkan官方教程</a>，打算自己敲一个小demo</p></blockquote><h2 id="我的Vulkan项目">我的Vulkan项目</h2><p>最近搓了一个<a href="https://github.com/Reuben-Sun/LiteEngine">Vulkan项目</a>，记录一下学习过程</p><p><img src="/images/2024_3_20.png" class="lazyload" data-srcset="/images/2024_3_20.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="2024_3_20"></p><h2 id="Vulkan-API">Vulkan API</h2><h3 id="Queue">Queue</h3><blockquote><p>参考 <a href="https://stackoverflow.com/questions/55272626/what-is-actually-a-queue-family-in-vulkan">what-is-actually-a-queue-family-in-vulkan</a></p></blockquote><p>Queue是将命令提交到GPU的入口，Command buffer会被提交到Queue中按顺序执行</p><p>你可以使用多个线程分别提交命令到多个Queue中</p><p>提交到不同Queue的命令，其执行顺序不确定，但可以使用Semaphore进行同步</p><p>Vulkan的命令有：</p><ul><li>vkCmdDraw</li><li>vkCmdDispatch：执行Compute Shader</li><li>vkCmdCopy</li><li>vkQueueBindSparse</li></ul><p>通常一个Queue只能处理某几种命令</p><p>一个硬件往往只有有限个Queue</p><h3 id="Render-Pass">Render Pass</h3><blockquote><p>画到哪</p></blockquote><p>Vulkan相较于OpenGL、DX11/12，一大特点就是有Render Pass这个概念</p><p>Render Pass的作用是描述绘制的目标（attachments，很像RT），比如color，比如depth</p><p>比如一个Forward Pass，他的目标可能就是一张color和一张depth，一个Deferred Pass，他的目标可能是GBuffer（一组color）和一个depth</p><h4 id="VkAttachmentDescription">VkAttachmentDescription</h4><p>值得注意的参数</p><ul><li>format：image view格式</li><li>samples：多采样次数</li><li>finalLayout：当renderpass绘制结束时，会将color转化为该格式<ul><li>画向Swapchain Image，finalLayout配置为<code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code></li><li>给其他pass的shader采样，设置为<code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code></li></ul></li></ul><h4 id="Subpass">Subpass</h4><p>一个像素在绘制单元绘制后，通常需要被拷贝出去，形成一张完整的RT，然后再由另一个绘制单元绘制</p><p>Subpass的一大特点是一个像素被一个Subpass绘制后，并不会立刻被拷贝出去，而是继续被另一个Subpass绘制</p><p><strong>优点：</strong></p><ol><li>减少了拷贝带来的带宽，减少延迟和发热，移动端延迟渲染常用该技术</li><li>像素间绘制彼此独立，不需要一整张RT绘制后再绘制下一张，提高并行效率，还能用来实现OIT和Zero Overdraw</li></ol><p><strong>缺点：</strong></p><ol><li>拿不到其他位置的RT的绘制内容，无法实现一些依赖RT的屏幕后效</li></ol><h3 id="Pipeline">Pipeline</h3><blockquote><p>怎么画</p></blockquote><p>用于设置管线的状态</p><table><thead><tr><th>参数</th><th>主要作用</th></tr></thead><tbody><tr><td>管线类型</td><td>图形管线还是计算管线</td></tr><tr><td>Shader Stage</td><td>指定绘制用的Shader</td></tr><tr><td>Vertex Input</td><td>顶点缓冲的结构</td></tr><tr><td>Input Assembly</td><td>输入的结构，比如三角形的拓扑规则</td></tr><tr><td>Viewport &amp; Scissors</td><td></td></tr><tr><td>Rasterizer</td><td>光栅化的规则，比如用线、用三角面绘制，是否背面剔除</td></tr><tr><td>Multisampling</td><td>多采样的规则</td></tr><tr><td>Depth Stencil</td><td>深度测试、模板测试的规则</td></tr><tr><td>Blending</td><td>颜色混合规则（半透明）</td></tr><tr><td>Pipeline Layout</td><td>管线的结构，比如UBO binding规则</td></tr></tbody></table><p>在Vulkan中，Render Pass是比Pipeline大的，这也很好理解，毕竟只要绘制目标没有改变，自然不需要改动Render Pass</p><p>而一个场景中有大量不同材质、Shader的对象，而且有的可能是线，有的是三角形，于是需要经常调整Pipeline，于是Vulkan的Pipeline就像Descriptor Set一样，可以随时改绑定的</p><p>Vulkan的Pipeline是很大的东西，实时创建大量开销过大，而大部分的Pipeline对象都很接近，可能就只有一小部分有差异。为了实现复用，Vulkan的Pipeline是可以动态修改、可以Cache、可以生成子类</p><h3 id="Descriptor-Set-Layout">Descriptor Set Layout</h3><blockquote><p>Shader中的资源位置</p></blockquote><p>Shader中会使用很多资源，比如UBO，比如贴图Sampler，需要指定绑定的位置</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform GlobalUBO &#123;</span><br><span class="line">    mat4 modelMatrix;</span><br><span class="line">    mat4 viewMatrix;</span><br><span class="line">    mat4 projectionMatrix;</span><br><span class="line">&#125; ubo;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">layout</span>(binding = <span class="number">1</span>) uniform sampler2D texSampler;</span><br></pre></td></tr></table></figure><h3 id="Descriptor-Set">Descriptor Set</h3><blockquote><p>资源</p></blockquote><p>简单理解为Vulkan管线能理解、使用的资源，比如UBO，比如贴图Sampler</p><p>在绘制时，我们可以绑定一个Descriptor Sets，里面包含多个Descriptor Set，其结构是Layout决定的</p><p>通常我们为每一个材质实例创建一个Descriptor Set（一个UBO或者贴图可以Update到多个Descriptor Set上）</p><p>我们可以单独更新某一个Set</p><table><thead><tr><th>VkDescriptorType</th><th>含义</th><th>类似DX12中的</th></tr></thead><tbody><tr><td>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</td><td>读图片</td><td>SRV</td></tr><tr><td>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</td><td>读写图片</td><td>UAV</td></tr><tr><td>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</td><td>读图片，并包含各种采样配置</td><td>SRV + Sampler</td></tr><tr><td>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</td><td>常量缓冲</td><td>UBO</td></tr></tbody></table><h3 id="Image">Image</h3><blockquote><p>Texure</p></blockquote><h4 id="Usage">Usage</h4><blockquote><p>图片的使用目的</p></blockquote><table><thead><tr><th>VkImageUsageFlagBits</th><th>含义</th></tr></thead><tbody><tr><td>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</td><td>Color渲染目标</td></tr><tr><td>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</td><td>深度缓冲、模板缓冲渲染目标</td></tr><tr><td>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</td><td>图像拷贝的源</td></tr><tr><td>VK_IMAGE_USAGE_TRANSFER_DST_BIT</td><td>图形拷贝的目标</td></tr><tr><td>VK_IMAGE_USAGE_SAMPLED_BIT</td><td>可以被着色器读</td></tr><tr><td>VK_IMAGE_USAGE_STORAGE_BIT</td><td>可以被着色器写</td></tr></tbody></table><h4 id="Layout">Layout</h4><blockquote><p>图形在内存的布局和排列，会影响拷贝、渲染等行为的可用性</p></blockquote><table><thead><tr><th>VkImageLayout</th><th>用途</th></tr></thead><tbody><tr><td>VK_IMAGE_LAYOUT_UNDEFINED</td><td>图形初始化</td></tr><tr><td>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</td><td>Color渲染目标</td></tr><tr><td>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</td><td>深度缓冲、模板缓冲渲染目标</td></tr><tr><td>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</td><td>Shader可读的贴图</td></tr></tbody></table><p>Image的Layout转化需要使用Pipeline Barrier</p><h3 id="Image-View">Image View</h3><h3 id="Fence">Fence</h3><p>用于隔离不同帧</p><p><img src="/images/fence.png" class="lazyload" data-srcset="/images/fence.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="fence"></p><h3 id="Semaphore">Semaphore</h3><p>用于隔离渲染和呈现</p><p><img src="/images/semaphore.png" class="lazyload" data-srcset="/images/semaphore.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="semaphore"></p><h2 id="Shader">Shader</h2><p>Vulkan使用SPIR-V作为着色语言，这是一种底层的二进制着色语言，可以使用glslang编译GLSL得到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将vert_shader.vert编译为vert_spv</span></span><br><span class="line"><span class="variable">$glslangValidator</span> -V vert_shader.vert</span><br><span class="line"><span class="comment"># 将vert_shader.vert编译为test.spv</span></span><br><span class="line"><span class="variable">$glslangValidator</span> -V vert_shader.vert -o test.spv</span><br></pre></td></tr></table></figure><p>可以使用<code>spirv-dis</code>查看一个spv文件的内容（如果编译时带有调试信息，可以看到源码）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spirv-dis test.spv</span><br></pre></td></tr></table></figure><h3 id="Vertex">Vertex</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(binding = <span class="number">0</span>) uniform GlobalUBO &#123;</span><br><span class="line">    mat4 modelMatrix;</span><br><span class="line">    mat4 viewMatrix;</span><br><span class="line">    mat4 projectionMatrix;</span><br><span class="line">&#125; ubo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 inPosition;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec3 inColor;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">2</span>) in vec2 inTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec3 fragColor;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) out vec2 uv0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = ubo.projectionMatrix * ubo.viewMatrix * ubo.modelMatrix * <span class="built_in">vec4</span>(inPosition, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">    uv0 = inTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fragment">Fragment</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 fragColor;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec2 uv0;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 outColor;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(binding = <span class="number">1</span>) uniform sampler2D texSampler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    outColor = <span class="built_in">texture</span>(texSampler, uv0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集成到cmake">集成到cmake</h3><h4 id="在VS文件夹中显示">在VS文件夹中显示</h4><p>Visual Studio安装glsl插件后，shader可以高亮和智能提示</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE HEADERS <span class="string">&quot;*.h&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES <span class="string">&quot;*.cpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SHADER_DIR <span class="string">&quot;../Shader/Source&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB VERT_SHADERS <span class="string">&quot;$&#123;SHADER_DIR&#125;/*.vert&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB FRAG_SHADERS <span class="string">&quot;$&#123;SHADER_DIR&#125;/*.frag&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(ALL_FILES <span class="variable">$&#123;HEADERS&#125;</span> <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(Engine STATIC <span class="variable">$&#123;ALL_FILES&#125;</span> <span class="variable">$&#123;VERT_SHADERS&#125;</span> <span class="variable">$&#123;FRAG_SHADERS&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(Engine PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">source_group</span>(TREE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span> FILES <span class="variable">$&#123;ALL_FILES&#125;</span>)</span><br><span class="line"><span class="comment"># 核心是这个</span></span><br><span class="line"><span class="keyword">source_group</span>(<span class="string">&quot;Shaders&quot;</span> FILES <span class="variable">$&#123;VERT_SHADERS&#125;</span> <span class="variable">$&#123;FRAG_SHADERS&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="项目构建时编译">项目构建时编译</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Compile shaders</span></span><br><span class="line"><span class="keyword">set</span>(SPV_TARGET_DIR <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../Shader/SPV&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(SHADER_FILE <span class="variable">$&#123;VERT_SHADERS&#125;</span>)</span><br><span class="line">    <span class="keyword">get_filename_component</span>(FILE_NAME <span class="variable">$&#123;SHADER_FILE&#125;</span> NAME)</span><br><span class="line">    <span class="keyword">string</span>(REPLACE <span class="string">&quot;.&quot;</span> <span class="string">&quot;_&quot;</span> OUTPUT_STRING <span class="variable">$&#123;FILE_NAME&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Compile vert shader: $&#123;FILE_NAME&#125; =&gt; $&#123;OUTPUT_STRING&#125;.spv&quot;</span>)</span><br><span class="line">    <span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> Engine POST_BUILD</span><br><span class="line">        <span class="keyword">COMMAND</span> glslangValidator -V -S vert <span class="variable">$&#123;SHADER_FILE&#125;</span> -o <span class="variable">$&#123;SPV_TARGET_DIR&#125;</span>/<span class="variable">$&#123;OUTPUT_STRING&#125;</span>.spv</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(SHADER_FILE <span class="variable">$&#123;FRAG_SHADERS&#125;</span>)</span><br><span class="line">    <span class="keyword">get_filename_component</span>(FILE_NAME <span class="variable">$&#123;SHADER_FILE&#125;</span> NAME)</span><br><span class="line">    <span class="keyword">string</span>(REPLACE <span class="string">&quot;.&quot;</span> <span class="string">&quot;_&quot;</span> OUTPUT_STRING <span class="variable">$&#123;FILE_NAME&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Compile frag shader: $&#123;FILE_NAME&#125; =&gt; $&#123;OUTPUT_STRING&#125;.spv&quot;</span>)</span><br><span class="line">    <span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> Engine POST_BUILD</span><br><span class="line">        <span class="keyword">COMMAND</span> glslangValidator -V -S frag <span class="variable">$&#123;SHADER_FILE&#125;</span> -o <span class="variable">$&#123;SPV_TARGET_DIR&#125;</span>/<span class="variable">$&#123;OUTPUT_STRING&#125;</span>.spv</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Copy Shader</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> Client POST_BUILD</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_directory</span><br><span class="line">        <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/Shader/SPV $&lt;TARGET_FILE_DIR:Client&gt;/Shaders)</span><br></pre></td></tr></table></figure><h2 id="ImGui">ImGui</h2><p>Vulkan ImGui本质是使用Vulkan API画平面，ImGui会帮你创建一个Pipeline，但是你需要自己准备Render Pass、Frame Buffer、Vulkan Context等内容</p><h3 id="ImGui版本选择">ImGui版本选择</h3><p>ImGui不同分支功能不同，其中最多人使用的docking分支，这个分支下ImGui可以用来做Editor</p><h3 id="Vulkan初始化">Vulkan初始化</h3><p>核心是需要一个Render Pass，这个Render Pass需要有一个Color Attachment，我建议单独开一个pass</p><h3 id="ImGui初始化">ImGui初始化</h3><p>可以认为这个过程是帮你创建以Render Pipeline</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">(<span class="type">void</span>)io;</span><br><span class="line">io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;</span><br><span class="line"><span class="built_in">setStyle</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_InitForVulkan</span>(rhi_context.m_window.<span class="built_in">getHandle</span>(), <span class="literal">true</span>);</span><br><span class="line">ImGui_ImplVulkan_InitInfo init_info = &#123;&#125;;</span><br><span class="line">init_info.Instance = rhi_context.m_instance-&gt;<span class="built_in">getHandle</span>();</span><br><span class="line">init_info.PhysicalDevice = rhi_context.m_device-&gt;<span class="built_in">getPhysicalDevice</span>();</span><br><span class="line">init_info.Device = rhi_context.m_device-&gt;<span class="built_in">getLogicalDevice</span>();</span><br><span class="line">init_info.QueueFamily = rhi_context.m_device-&gt;<span class="built_in">getGraphicsFamilyIndex</span>();</span><br><span class="line">init_info.Queue = rhi_context.m_device-&gt;<span class="built_in">getGraphicsQueue</span>();</span><br><span class="line">init_info.DescriptorPool = rhi_context.m_descriptor_pool-&gt;<span class="built_in">getHandle</span>();</span><br><span class="line">init_info.MinImageCount = rhi_context.m_swapchain-&gt;<span class="built_in">getImageCount</span>();<span class="comment">// 3</span></span><br><span class="line">init_info.ImageCount = rhi_context.m_swapchain-&gt;<span class="built_in">getImageCount</span>();<span class="comment">// 3;</span></span><br><span class="line"><span class="built_in">ImGui_ImplVulkan_Init</span>(&amp;init_info, render_pass.<span class="built_in">getHandle</span>());</span><br></pre></td></tr></table></figure><h3 id="绘制">绘制</h3><p>需要传入一个command buffer</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ImGui_ImplVulkan_NewFrame</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line">ImGui::<span class="built_in">DockSpaceOverViewport</span>(<span class="literal">nullptr</span>, ImGuiDockNodeFlags_PassthruCentralNode);</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Hierarchy&quot;</span>);</span><br><span class="line"><span class="comment">// draw something</span></span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">Render</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">ImGui_ImplVulkan_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>(), cmd.<span class="built_in">getHandle</span>(frame_index));</span><br></pre></td></tr></table></figure><h3 id="销毁">销毁</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ImGui_ImplVulkan_Shutdown</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_Shutdown</span>();</span><br><span class="line">ImGui::<span class="built_in">DestroyContext</span>();</span><br></pre></td></tr></table></figure><h2 id="Vulkan拓展">Vulkan拓展</h2><p>可以通过函数指针的方式引入一些Vulkan拓展</p><h3 id="Debug-Label">Debug Label</h3><p>在使用RenderDoc截帧时，我们可以看到一些绘制命令被分类命名，一些贴图也有调试名称</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PFN_vkCmdBeginDebugUtilsLabelEXT vkCmdBeginDebugUtilsLabelEXT = <span class="literal">nullptr</span>;</span><br><span class="line">PFN_vkCmdEndDebugUtilsLabelEXT vkCmdEndDebugUtilsLabelEXT = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RHIDevice::loadExtensionFunctions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vkCmdBeginDebugUtilsLabelEXT = <span class="built_in">reinterpret_cast</span>&lt;PFN_vkCmdBeginDebugUtilsLabelEXT&gt;(<span class="built_in">vkGetInstanceProcAddr</span>(m_instance.<span class="built_in">getHandle</span>(), <span class="string">&quot;vkCmdBeginDebugUtilsLabelEXT&quot;</span>));</span><br><span class="line">    vkCmdEndDebugUtilsLabelEXT = <span class="built_in">reinterpret_cast</span>&lt;PFN_vkCmdEndDebugUtilsLabelEXT&gt;(<span class="built_in">vkGetInstanceProcAddr</span>(m_instance.<span class="built_in">getHandle</span>(), <span class="string">&quot;vkCmdEndDebugUtilsLabelEXT&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RHIDevice::beginDebugUtilsLabel</span><span class="params">(VkCommandBuffer cmd, <span class="type">const</span> VkDebugUtilsLabelEXT&amp; label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vkCmdBeginDebugUtilsLabelEXT</span>(cmd, &amp;label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RHIDevice::endDebugUtilsLabel</span><span class="params">(VkCommandBuffer cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vkCmdEndDebugUtilsLabelEXT</span>(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# Attribute用法</title>
      <link href="/program/CSharpeAttribute/"/>
      <url>/program/CSharpeAttribute/</url>
      
        <content type="html"><![CDATA[<h1>C# Attribute用法</h1><h2 id="内建功能">内建功能</h2><h3 id="标记函数">标记函数</h3><p>比如标记函数已过时，再调用这个函数时会有绿色的波浪线，并提示你函数已过时</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Obsolete(<span class="string">&quot;This func is obsolete, use newFunc()&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OldFunc</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据验证">数据验证</h3><p>可以确保某个数据存在</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserModel</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">Required</span>(ErrorMessage = <span class="string">&quot;Username is required.&quot;</span>)]</span><br><span class="line">    <span class="keyword">public</span> string Username &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Required</span>(ErrorMessage = <span class="string">&quot;Password is required.&quot;</span>)]</span><br><span class="line">    <span class="keyword">public</span> string Password &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象，但是没有填充Required信息</span></span><br><span class="line"><span class="keyword">var</span> invalidUser = <span class="keyword">new</span> UserModel();</span><br><span class="line"><span class="keyword">var</span> validationResults = <span class="keyword">new</span> List&lt;System.ComponentModel.DataAnnotations.ValidationResult&gt;();</span><br><span class="line"><span class="built_in">bool</span> isValid = Validator.TryValidateObject(invalidUser, <span class="keyword">new</span> ValidationContext(invalidUser), validationResults, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (!isValid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> errorMessage = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> validationResult <span class="keyword">in</span> validationResults)</span><br><span class="line">    &#123;</span><br><span class="line">        errorMessage +=validationResult.ErrorMessage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出 &quot;Username is required.Password is required.&quot;</span></span><br><span class="line">    Console.WriteLine(errorMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化与反序列化">序列化与反序列化</h3><h4 id="WCF">WCF</h4><blockquote><p>Windows Communication Foundation</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DataContract</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DataMember</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DataMember</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> serializer = <span class="keyword">new</span> DataContractSerializer(<span class="keyword">typeof</span>(Person));</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> memoryStream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    serializer.WriteObject(memoryStream, person);</span><br><span class="line">    memoryStream.Position = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> serializedData = <span class="keyword">new</span> StreamReader(memoryStream).ReadToEnd();</span><br><span class="line">    LabelText = serializedData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = XmlReader.Create(<span class="keyword">new</span> StringReader(LabelText)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> deserializedPerson = (Person)serializer.ReadObject(reader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化的产物是一个xml：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.datacontract.org/2004/07/AttributeStudy&quot;</span> <span class="attr">xmlns:i</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">Age</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>John<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Serializable">Serializable</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person</span><br><span class="line">&#123;</span><br><span class="line">    Name = <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">    Age = <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化 Person 对象到文件</span></span><br><span class="line">System.Xml.Serialization.XmlSerializer serializer = <span class="keyword">new</span> System.Xml.Serialization.<span class="built_in">XmlSerializer</span>(<span class="built_in">typeof</span>(Person));</span><br><span class="line"><span class="built_in">using</span> (var stream = <span class="keyword">new</span> System.IO.<span class="built_in">FileStream</span>(<span class="string">&quot;F:\\person.xml&quot;</span>, System.IO.FileMode.Create))</span><br><span class="line">&#123;</span><br><span class="line">    serializer.<span class="built_in">Serialize</span>(stream, person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化从文件读取的数据</span></span><br><span class="line"><span class="built_in">using</span> (var stream = <span class="keyword">new</span> System.IO.<span class="built_in">FileStream</span>(<span class="string">&quot;F:\\person.xml&quot;</span>, System.IO.FileMode.Open))</span><br><span class="line">&#123;</span><br><span class="line">    Person deserializedPerson = (Person)serializer.<span class="built_in">Deserialize</span>(stream);</span><br><span class="line">    Console.<span class="built_in">WriteLine</span>($<span class="string">&quot;Name: &#123;deserializedPerson.Name&#125;, Age: &#123;deserializedPerson.Age&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化产物是一个xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Name</span>&gt;</span>John Doe<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Age</span>&gt;</span>30<span class="tag">&lt;/<span class="name">Age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="引入DLL">引入DLL</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">MessageBox</span>(<span class="params">IntPtr hWnd, <span class="built_in">string</span> text, <span class="built_in">string</span> caption, <span class="built_in">uint</span> type</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(IntPtr.Zero, <span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;Message&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义功能">自定义功能</h2><h3 id="插件">插件</h3><p>自定义属性</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class, AllowMultiple = false)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PluginAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PluginAttribute</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自定义的属性都形如xxxAttribute，在使用时只需要[xxx(“…”)]</p></blockquote><p>插件接口和插件实现</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPlugin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Plugin(<span class="string">&quot;MyPlugin&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPlugin</span> : <span class="title">IPlugin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyPlugin is executing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Plugin(<span class="string">&quot;MyPlugin2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPlugin2</span> : <span class="title">IPlugin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyPlugin2 is executing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到所有插件，并执行所有插件</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;IPlugin&gt; plugins = <span class="keyword">new</span> List&lt;IPlugin&gt;();</span><br><span class="line"><span class="comment">// 获取所有插件类型</span></span><br><span class="line"><span class="keyword">var</span> pluginTypes = Assembly.GetExecutingAssembly().GetTypes()</span><br><span class="line">.Where(type =&gt; type.GetCustomAttributes(<span class="keyword">typeof</span>(PluginAttribute), <span class="literal">true</span>).Length &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 实例化插件</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> pluginType <span class="keyword">in</span> pluginTypes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> pluginAttribute = (PluginAttribute)Attribute.GetCustomAttribute(pluginType, <span class="keyword">typeof</span>(PluginAttribute));</span><br><span class="line">    <span class="keyword">var</span> plugin = (IPlugin)Activator.CreateInstance(pluginType);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Loaded plugin: <span class="subst">&#123;pluginAttribute.Name&#125;</span>&quot;</span>);</span><br><span class="line">    plugins.Add(plugin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插件执行</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> plugin <span class="keyword">in</span> plugins)</span><br><span class="line">&#123;</span><br><span class="line">    plugin.Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake构建C#项目并使用DLL</title>
      <link href="/program/CSharpCmakeDLL/"/>
      <url>/program/CSharpCmakeDLL/</url>
      
        <content type="html"><![CDATA[<h1>CMake构建C#项目并使用DLL</h1><p>项目路径</p><blockquote><p>Windows cmd下使用<code>tree /f</code>即可生成文件路径</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">│  CMakeLists.txt</span><br><span class="line">│  Main.cs</span><br><span class="line">│  p4api.net.dll</span><br><span class="line">│  p4bridge.dll</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.23</span>)</span><br><span class="line"><span class="built_in">project</span>(P4Test CSharp)</span><br><span class="line"><span class="built_in">set_property</span>(GLOBAL PROPERTY VS_STARTUP_PROJECT P4Test)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_VS_EFFECTIVE_PLATFORMS x64) </span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(SOURCES</span><br><span class="line">    $&#123;CMAKE_SOURCE_DIR&#125;/Main.cs</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(P4Test $&#123;SOURCES&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set_property</span>(TARGET P4Test PROPERTY VS_DOTNET_TARGET_FRAMEWORK_VERSION <span class="string">&quot;v4.7.2&quot;</span>)</span><br><span class="line"><span class="built_in">set_property</span>(TARGET P4Test PROPERTY VS_DOTNET_REFERENCE_P4API <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/p4api.net.dll&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">add_custom_command</span>(</span><br><span class="line">    TARGET P4Test</span><br><span class="line">    POST_BUILD</span><br><span class="line">    COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_if_different</span><br><span class="line">        $&#123;CMAKE_SOURCE_DIR&#125;/p4api.net.dll</span><br><span class="line">        $&lt;TARGET_FILE_DIR:P4Test&gt;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">add_custom_command</span>(</span><br><span class="line">    TARGET P4Test</span><br><span class="line">    POST_BUILD</span><br><span class="line">    COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_if_different</span><br><span class="line">        $&#123;CMAKE_SOURCE_DIR&#125;/p4bridge.dll</span><br><span class="line">        $&lt;TARGET_FILE_DIR:P4Test&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Perforce.P4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> P4DoNetApi</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吸血鬼幸存者+战意</title>
      <link href="/game/%E5%90%B8%E8%A1%80%E9%AC%BC%E5%B9%B8%E5%AD%98%E8%80%85like/"/>
      <url>/game/%E5%90%B8%E8%A1%80%E9%AC%BC%E5%B9%B8%E5%AD%98%E8%80%85like/</url>
      
        <content type="html"><![CDATA[<h1>吸血鬼幸存者+战意</h1><h2 id="灵感起源">灵感起源</h2><p>最近在玩战意，感觉这游戏玩法设计的有问题</p><ol><li>主打将军梦的游戏，一次却只能带十几个兵，而且ACT玩法会给人一种这些小兵是具体的个体，而非抽象的军团，玩家扮演的是一个个十夫长（一个武将能杀几十个小兵，但绝不可能杀一个军团，但游戏中经常出现一个太刀侠杀一堆弓箭手）</li><li>小兵AI非常蠢，缺乏操作性，胜利基本取决于双方兵种的养成强度，而非操作</li><li>特别缺统御值，一场游戏只能带很少的兵，很快就成光杆司令，变成垃圾时间</li><li>攻防战体验非常糟糕，攻守不应该是等人数公平对战，攻城人数应该比守方多五到十倍</li><li>守方获胜的方式是等时间耗尽，没法主动出击快速结束游戏</li><li>游戏开始时攻方要推攻城塔，守方要等攻方进来，开局充满了垃圾时间</li><li>战斗区域大多在城内巷战，而现实中攻破城门其实基本宣告守城失败，主要战斗应该是野战夺旗</li><li>城防和工事基本没有用，战斗的本质是战旗，敌我双方把兵放在一起，让他们互砍</li><li>没有感受到明显的兵种克制，就算有克制，起码要让玩家每种兵开局各解锁一套，战斗时可以随时切换，现在一次只能带一队，变成猜拳游戏，希望对方不使用克制自己的兵，不是我的兵不强，只是我开局首发错了</li></ol><p>于是我打算从去年爆火的吸血鬼幸存者中吸取经验，做一个吸血鬼幸存者+战意的游戏</p><h2 id="玩法">玩法</h2><h3 id="背景">背景</h3><blockquote><p>你知道吗？拿破仑的法军都不带后勤的，敌人屯粮我屯枪，敌人就是我粮仓，去杀光烧光抢光吧，去征服整个大陆，你入关之后自有大儒辩经</p></blockquote><p>玩家出生在一个大陆上，这个大陆有很多国家（城市）和城邦。玩家需要收割麦子（掠夺农民），去城邦雇佣军队，攻打城市，最后统一整个大陆吧</p><h3 id="设计目标">设计目标</h3><p>体验一把中世纪掠夺者征服大陆，过足将军梦</p><h3 id="玩家目标">玩家目标</h3><p>收割麦子 —— 获得第一桶金 —— 去城邦购买军队 —— 控制军队攻打城市 —— 占领的城市会给玩家提供一次性的掠夺收入和持续的税收收入 —— 用收入去城邦买军队 —— 攻打其他城市 —— 统一整个大陆 —— 游戏结束</p><p>单局时长控制在二十分钟，玩家需要做的就是用鼠标左键控制主角移动，按按键指挥小兵</p><h3 id="游戏开始">游戏开始</h3><p>游戏开始时要选择地图和继承卡（如果没有可以不选择）</p><h3 id="继承卡">继承卡</h3><blockquote><p>类似于赛马娘</p></blockquote><p>游戏结束时会进行结算，获得一张继承卡，如果游戏胜利会获得更多的继承属性</p><p>继承卡中有各种因子，因子有三种，红因子（某种兵战斗力提升），黄因子（某种兵购买折扣），蓝因子（某种固有技能）</p><p>因子的获取是概率的，取决于你这把的得分</p><p>比如你这把买了很多骑兵，那么游戏结束就更有概率获得骑兵黄因子</p><p>如果这把骑兵杀了很多敌人，那么容易获得骑兵红因子</p><p>如果骑兵强化了很多次（去城邦买强化），那么容易得到骑兵蓝因子</p><h3 id="主角移动">主角移动</h3><p>TopDown俯视角游戏，主角始终保持在屏幕中间，通过鼠标左键点击移动</p><p><img src="/images/%E4%B8%BB%E8%A7%92%E7%A7%BB%E5%8A%A8.gif" class="lazyload" data-srcset="/images/%E4%B8%BB%E8%A7%92%E7%A7%BB%E5%8A%A8.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="主角移动"></p><h3 id="收割麦子">收割麦子</h3><p>主角走到麦子上即可获取麦子（就像捡地上的金币），麦子会转化为金钱（虚拟物品，在左上角显示）</p><h3 id="控兵">控兵</h3><p>主角不能直接控制兵，只能给兵发命令（不能像RTS那样框选，只能发指令，大部分情况都是自动战斗，以降低操作复杂度）</p><p>主角最多有控制四队兵，用1234切换，右侧会有小兵的状态（类似于原神）</p><p>兵有四种，铁剑、弓箭手、枪兵、骑兵</p><p>兵有三种状态，自由攻击、跟随攻击、驻扎攻击</p><p>士兵在驻扎期间可以缓慢恢复生命，提高向前的防御力，但不能移动</p><p>驻扎有形状（类似于战意中的X键）</p><p>骑兵可以像笔一样画移动方向（有些像红警的路径）</p><h3 id="城邦">城邦</h3><p>类似于吸血鬼幸存者中的箱子，玩家在靠近城邦后会弹出三张卡，支付金钱可以获得卡片收益，比如获得某个军队，升级某个军队</p><h3 id="敌方城市">敌方城市</h3><blockquote><p>初版认为城市的相同的</p></blockquote><p>当玩家靠近敌方城市时，敌方城市会开始刷兵，刷兵强度与玩家已经占领的城市数量有关</p><p>城市有一层塔皮，可以被攻击打掉，打光后成为我方城市，第一次占领可以获得一笔掠夺收益</p><p>敌方城市会射箭（类似于moba游戏的防御塔）</p><h3 id="我方城市">我方城市</h3><p>城市有塔皮，可以自动射箭攻击</p><p>塔皮被打光后会变回敌方城市</p><p>城市会为主角提供税金</p><h3 id="敌兵">敌兵</h3><p>敌兵会攻击我方的小兵和主角</p><p>杀死敌兵后会获得金币</p><h3 id="主角死亡">主角死亡</h3><p>主角死亡游戏失败，开下一把吧</p><h2 id="小兵">小兵</h2><h3 id="铁剑">铁剑</h3><p>均衡的小兵，最便宜</p><p>主打自由攻击</p><p>狂暴：提高攻击速度和移动速度</p><h3 id="枪兵">枪兵</h3><p>相较于铁剑，攻击距离更长，攻击频率更慢，更贵</p><p>克制枪兵</p><p>驻扎时正面防御力提高，有圆形驻扎、方形驻扎、长条形驻扎</p><p>齐攻：将所有小兵的攻击CD清空，向前挥出一个次长而有力的攻击（相较于普攻）</p><h3 id="骑士">骑士</h3><p>最贵</p><p>可以画线指挥路径</p><p>克制铁剑，被枪兵克制</p><h3 id="弓箭手">弓箭手</h3><p>比铁剑贵</p><p>发射箭矢攻击最近的敌人</p><p>驻扎攻击时提高攻速</p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译与链接</title>
      <link href="/program/%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
      <url>/program/%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1>C/C++编译与链接</h1><blockquote><p>《程序员的自我修养：链接、装载与库》阅读笔记</p></blockquote><h2 id="编译">编译</h2><p>编译可以被分为四个步骤：</p><ol><li>预编译（Prepressing）</li><li>编译（Compilation）</li><li>汇编（Assembly）</li><li>链接（Linking）</li></ol><h3 id="预编译">预编译</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure><ul><li>移除并展开所有<code>#define</code></li><li>处理所有条件预编译指令，如<code>#ifdef</code></li><li>递归处理<code>#include</code>指令，将被包含的文件拷贝到该指令位置</li><li>删除所有的注释</li><li>添加行号和文件名标识，便于产生调试和报错的行号信息</li><li>保留<code>#pragma</code>指令</li></ul><h3 id="编译-2">编译</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><ol><li>词法分析：扫描器使用有限状态机将源代码的字符切分为一系列记号（Token）</li><li>语法分析：分析记号，得到语法树，树的节点是表达式</li><li>语义分析：分析所有的<strong>静态语义</strong>，为表达式标注类型</li><li>中间语言生成：优化一些代码，比如2+6优化成8<ul><li>三地址码与P代码</li></ul></li><li>目标代码的生成与优化</li></ol><p>GCC可以将预编译和编译合成一个步骤</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cc1 hello.c</span><br></pre></td></tr></table></figure><h3 id="汇编">汇编</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure><h3 id="链接">链接</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ld -<span class="type">static</span> xxxx hello.o -xxxx</span><br></pre></td></tr></table></figure><p>链接的本质是替换指令中（对函数和变量）的地址引用</p><ol><li>地址和空间分配</li><li>符号决议</li><li>重定位</li></ol><p>main.c文件调用了func.c文件中的函数<code>foo()</code>，所以需要知道<code>foo()</code>的确切地址。但C++不同模块是单独编译的，因此编译main.c时不知道<code>foo()</code>的地址</p><p>于是编译器先将<code>foo()</code>的地址搁置，在链接的时候再逐个修正，填入<code>foo()</code>真实的地址</p><p>这个地址修复的过程也叫做重定位（Relocation），每一个需要修正的地方叫重定位入口（Relocation Entry）</p><h2 id="目标文件">目标文件</h2><p>编译器编译后生成的文件是目标文件（<code>.obj</code>和<code>.o</code>），结构跟可执行文件相同，只是还未链接</p><p>可执行文件、目标文件、动态库、静态库均采用相同的存储格式，在Windows下使用PE-COFF格式存储，在Linux下使用ELF格式存储</p><ul><li>Windows：PE-COFF（Probable Executable-Common File Format）</li><li>Linux：ELF（Executable Linkable Format）</li></ul><h3 id="目标文件格式">目标文件格式</h3><p>由四个部分组成：</p><ul><li>文件头（File Header）：文件可否执行、是静态链接还是动态链接、链接入口、目标硬件、目标操作系统、<strong>段表</strong>（Section Table）<ul><li>段表描述了文件中各个段的偏移位置和属性，用于找到代码段、数据段</li></ul></li><li>代码段（.text section）：编译得到的执行语句</li><li>数据段（.data section）：已初始化的静态/全局变量</li><li>.bss section：为未初始化的静态/全局变量预留位置，没有内容</li><li>.rodata section：只读数据，比如用const修饰的变量、字符串常量</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> global_inited_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, var);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_inited_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_uninit_var;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> local_inited_var = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> loacl_uninit_var;</span><br><span class="line">    <span class="built_in">func</span>(static_inited_var + static_uninit_var + local_inited_var + loacl_uninit_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="objdump-h-hello-o">objdump -h hello.o</h3><p>查看目标文件的结构</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hello.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000064</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000008</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a4  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000008</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>ac  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .rodata       <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>ac  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">4</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000b</span>0  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.GNU-stack <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>dc  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">6</span> .note.gnu.property <span class="number">00000020</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000e0</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">7</span> .eh_frame     <span class="number">00000058</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000100</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure><h3 id="objdump-s-d-hello-o">objdump -s -d hello.o</h3><p>将段内容以十六进制的形式打印出来，并将指令段反汇编</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hello.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> <span class="number">0000</span> f30f1efa <span class="number">554889e5</span> <span class="number">4883</span>ec10 <span class="number">897</span>dfc8b  ....UH..H....&#125;..</span><br><span class="line"> <span class="number">0010</span> <span class="number">45f</span>c89c6 <span class="number">488</span>d0500 <span class="number">00000048</span> <span class="number">89</span>c7b800  E...H......H....</span><br><span class="line"> <span class="number">0020</span> <span class="number">000000e8</span> <span class="number">00000000</span> <span class="number">90</span>c9c3f3 <span class="number">0f</span>1efa55  ...............U</span><br><span class="line"> <span class="number">0030</span> <span class="number">4889e548</span> <span class="number">83</span>ec10c7 <span class="number">45f</span>80100 <span class="number">00008b</span>15  H..H....E.......</span><br><span class="line"> <span class="number">0040</span> <span class="number">00000000</span> <span class="number">8b</span>050000 <span class="number">000001</span>c2 <span class="number">8b</span>45f801  .............E..</span><br><span class="line"> <span class="number">0050</span> c28b45fc <span class="number">01</span>d089c7 e8000000 <span class="number">00b</span>80000  ..E.............</span><br><span class="line"> <span class="number">0060</span> <span class="number">0000</span>c9c3                             ....</span><br><span class="line">Contents of section .data:</span><br><span class="line"> <span class="number">0000</span> <span class="number">54000000</span> <span class="number">55000000</span>                    T...U...</span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> <span class="number">0000</span> <span class="number">25640</span>a00                             %d..</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> <span class="number">0000</span> <span class="number">00474343</span> <span class="number">3</span>a202855 <span class="number">62756e74</span> <span class="number">75203131</span>  .GCC: (Ubuntu <span class="number">11</span></span><br><span class="line"> <span class="number">0010</span> <span class="number">2e332</span>e30 <span class="number">2</span>d317562 <span class="number">756e7475</span> <span class="number">317e3232</span>  <span class="number">.3</span><span class="number">.0</span><span class="number">-1u</span>buntu1~<span class="number">22</span></span><br><span class="line"> <span class="number">0020</span> <span class="number">2e303429</span> <span class="number">2031312</span>e <span class="number">332e3000</span>           <span class="number">.04</span>) <span class="number">11.3</span><span class="number">.0</span>.</span><br><span class="line">Contents of section .note.gnu.property:</span><br><span class="line"> <span class="number">0000</span> <span class="number">04000000</span> <span class="number">10000000</span> <span class="number">05000000</span> <span class="number">474e5500</span>  ............GNU.</span><br><span class="line"> <span class="number">0010</span> <span class="number">020000</span>c0 <span class="number">04000000</span> <span class="number">03000000</span> <span class="number">00000000</span>  ................</span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> <span class="number">0000</span> <span class="number">14000000</span> <span class="number">00000000</span> <span class="number">017</span>a5200 <span class="number">01781001</span>  .........zR..x..</span><br><span class="line"> <span class="number">0010</span> <span class="number">1b</span>0c0708 <span class="number">90010000</span> <span class="number">1</span>c000000 <span class="number">1</span>c000000  ................</span><br><span class="line"> <span class="number">0020</span> <span class="number">00000000</span> <span class="number">2b</span>000000 <span class="number">00450e10</span> <span class="number">8602430</span>d  ....+....E....C.</span><br><span class="line"> <span class="number">0030</span> <span class="number">06620</span>c07 <span class="number">08000000</span> <span class="number">1</span>c000000 <span class="number">3</span>c000000  .b..........&lt;...</span><br><span class="line"> <span class="number">0040</span> <span class="number">00000000</span> <span class="number">39000000</span> <span class="number">00450e10</span> <span class="number">8602430</span>d  ...<span class="number">.9</span>....E....C.</span><br><span class="line"> <span class="number">0050</span> <span class="number">06700</span>c07 <span class="number">08000000</span>                    .p......</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;func&gt;:</span><br><span class="line">   <span class="number">0</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64</span><br><span class="line">   <span class="number">4</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="number">5</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="number">8</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   c:   <span class="number">89</span> <span class="number">7</span>d fc                mov    %edi,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   f:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">12</span>:   <span class="number">89</span> c6                   mov    %eax,%esi</span><br><span class="line">  <span class="number">14</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rax        # <span class="number">1b</span> &lt;func+<span class="number">0x1b</span>&gt;</span><br><span class="line">  <span class="number">1b</span>:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">  <span class="number">1</span>e:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">23</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">28</span> &lt;func+<span class="number">0x28</span>&gt;</span><br><span class="line">  <span class="number">28</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">29</span>:   c9                      leave</span><br><span class="line">  <span class="number">2</span>a:   c3                      ret</span><br><span class="line"></span><br><span class="line"><span class="number">000000000000002b</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">2b</span>:   f3 <span class="number">0f</span> <span class="number">1</span>e fa             endbr64</span><br><span class="line">  <span class="number">2f</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">  <span class="number">30</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">  <span class="number">33</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">37</span>:   c7 <span class="number">45</span> f8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x1</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">3</span>e:   <span class="number">8b</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%edx        # <span class="number">44</span> &lt;main+<span class="number">0x19</span>&gt;</span><br><span class="line">  <span class="number">44</span>:   <span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">4</span>a &lt;main+<span class="number">0x1f</span>&gt;</span><br><span class="line">  <span class="number">4</span>a:   <span class="number">01</span> c2                   add    %eax,%edx</span><br><span class="line">  <span class="number">4</span>c:   <span class="number">8b</span> <span class="number">45</span> f8                mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">4f</span>:   <span class="number">01</span> c2                   add    %eax,%edx</span><br><span class="line">  <span class="number">51</span>:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">54</span>:   <span class="number">01</span> d0                   add    %edx,%eax</span><br><span class="line">  <span class="number">56</span>:   <span class="number">89</span> c7                   mov    %eax,%edi</span><br><span class="line">  <span class="number">58</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">5</span>d &lt;main+<span class="number">0x32</span>&gt;</span><br><span class="line">  <span class="number">5</span>d:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">62</span>:   c9                      leave</span><br><span class="line">  <span class="number">63</span>:   c3                      ret</span><br></pre></td></tr></table></figure><p>.data中<code>54000000</code>转化到十进制是84，<code>55000000</code>是85</p><h4 id="大小端">大小端</h4><p>注意十六进制的读法，0x54是最低位，后面三个0x00是更高的位，这种低位在前高位在后的字节序是<strong>小端序</strong>，有点反人类</p><h4 id="为什么要区分代码块和数据块呢？">为什么要区分代码块和数据块呢？</h4><ol><li>程序被装载后，数据区域是可读写的，而代码区域是只读的，将段进行分离，可以防止潜在的错误修改</li><li>数据集中存储，可以利用局部性原理提高缓存利用率</li><li>当系统同时运行多个同一文件时，可以共享只读的指令和数据，能大幅节省空间</li></ol><h3 id="readelf-h-hello-o">readelf -h hello.o</h3><p>查看elf文件头的详细信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              <span class="built_in">REL</span> (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x0</span></span><br><span class="line">  Start of program headers:          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1048</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of <span class="keyword">this</span> header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">14</span></span><br><span class="line">  Section header string table index: <span class="number">13</span></span><br></pre></td></tr></table></figure><p>魔术（Magic）用于区分ELF文件类型（与Windows里用后缀名区分不同）</p><h2 id="符号">符号</h2><h3 id="符号表">符号表</h3><p>如果目标文件B用到了目标文件A的函数<code>foo()</code>，我们称目标文件A定义（Define）了函数<code>foo()</code>，目标文件B引用（Reference）了函数<code>foo()</code></p><p>我们称函数、变量为符号（Symbol），他们的名字被称为符号名（Symbol Name），符号名独一无二</p><p>编译过程中每个目标文件都有一个符号表，每个符号能找到一个对应的符号值，对于变量和函数，符号值就是他们的地址</p><p>符号值的类型有：</p><ul><li><strong>定义在本文件内的全局符号</strong>，比如<code>global_inited_var</code>，<code>func</code></li><li><strong>定义在其他文件内，但是被本文件引用的全局符号</strong>，叫外部符号（External Symbol），比如<code>printf</code></li><li>段名，是段的起始地址</li><li>局部符号，比如<code>static_inited_var</code></li><li>行号</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">readelf -s hello.o</span><br></pre></td></tr></table></figure><h3 id="Name-Mangling">Name Mangling</h3><p>为了防止符号名冲突，C语言会加上命名空间等方法修饰符号，C++会做<strong>符号改编</strong>（Name Mangling）</p><p><strong>函数签名</strong>：由函数的名称、参数数量与类型、所在的类、所在的命名空间等组成</p><p>在C++进行编译链接时，会使用函数签名生成一个修饰后名称，使用这个修饰后名称作为符号名</p><p>C++允许使用函数重载，但是重载函数的参数不能完全相同</p><p>C++允许局部变量和全局变量重名，因为他们修饰后是两个不同的符号</p><blockquote><p>C++的Name Mangling规则取决于编译器版本，没有统一和公开</p></blockquote><h4 id="extern-“C”">extern “C”</h4><p>C++的符号十分复杂，C的符号兼容性会更好，于是我们可以使用<code>extern &quot;C&quot;</code>声明一个C符号，里面的符号不会被Name Mangling</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="强弱符号">强弱符号</h3><p>强符号：C++默认函数和初始化的全局变量为强符号，如果多个目标文件拥有相同名字的强符号，链接时会报符号重定义的错误</p><p>弱符号：C++未初始化的全局变量是弱符号</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;<span class="comment">// 不是强、弱符号，因为是外部文件定义的变量</span></span><br><span class="line"><span class="type">int</span> weak_var;<span class="comment">// 弱符号，未初始化的全局变量</span></span><br><span class="line"><span class="type">int</span> strong_var = <span class="number">1</span>;<span class="comment">// 强符号，初始化的全局变量</span></span><br><span class="line">__attribute__((weak)) weak_var2;<span class="comment">// 弱符号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">// main是强符号，函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则：</p><ul><li>不允许强符号重定义</li><li>弱符号会被强符号覆盖</li><li>若一个符号在所有文件中都是弱符号，则选择体积最大的符号去链接</li></ul><h4 id="强弱引用">强弱引用</h4><p>强引用：在链接时，如果没有找到强引用的符号，会报符号未定义的错误</p><p>弱引用：在链接时，若符号未定义，会给一个默认值0</p><p>弱符号、弱引用对于库来说十分有用，可以被用户自己定义的强符号所覆盖，也可以使得程序功能被剪裁组合</p><h2 id="静态链接">静态链接</h2><p>链接会将多个目标文件加工成一个可执行文件</p><h3 id="段合并">段合并</h3><p>相似段合并：将所有具有相同性质的段合并在一起，比如多个文件的.data段合在一个大的.data段中</p><h3 id="两步链接">两步链接</h3><ol><li>空间和地址分配</li><li><strong>符号解析</strong>和重定位</li></ol><h3 id="C-链接步骤">C++链接步骤</h3><ol><li>重复代码消除，一个模板可能在多个编译单元中被实例化，且实例化成相同的代码，将这些重复代码消除可以提高缓存利用率和节约空间</li><li>函数级别链接（选择性开启）：每一个函数都单独存储在一个段中，链接时按需添加到目标文件，可以减少包体，但是会降低编译链接速度</li></ol><h3 id="程序入口">程序入口</h3><p>Linux下程序的入口是<code>_start</code>，这是Glibc库的一部分，会进行程序的初始化，比如全局函数的创建，然后再去<code>main</code>函数执行</p><p>ELF有.init和.fini两个段，在这两个段中的代码会在<code>mian</code>前后执行</p><h3 id="ABI">ABI</h3><p>两个代码想要链接，需要使用相同的目标文件格式。我们将符号修饰、变量内存布局、函数调用方法等和二进制可执行文件兼容性相关的内容称为ABI（Application Binary Interface）</p><p>对于C语言，通过下列内容判断二进制兼容性：</p><ul><li>内置类型（int、char）的大小、字节序、对齐方式</li><li>组合类型（struct、array、union）的存储方式和内存分布</li><li>外部符号的解析方式，比如外部的<code>func</code>被解析为<code>_func</code></li><li>函数调用方式，比如参数入栈顺序，返回值如何保持</li><li>堆栈分布方式</li><li>寄存器使用约定</li></ul><p>对于C++还额外有：</p><ul><li>继承相关的内存分布</li><li>指向成员函数的指针的内存分布，如何通过成员函数指针调用成员函数，如何传递this指针</li><li>如何调用虚函数，虚表的内容及分布</li><li>模板如何实例化</li><li>Name Mangling</li><li>全局对象的构造与析构</li><li>异常</li><li>RTTI</li><li>inline</li></ul><p>C++的ABI不稳定，于是DLL建议使用C风格</p><h2 id="装载">装载</h2><p>可执行文件要装载到内存中才能被CPU执行</p><p>动态装入：许多情况下程序所需要的内存远超物理内存，为此我们会将一部分数据存储在磁盘里，内存中只保留最常用的部分。目前最常用的方法是页映射</p><h3 id="进程的创建">进程的创建</h3><ol><li>创建一个独立的虚拟内存空间<ul><li>分配页目录</li><li>虚拟内存区域（VMA）</li><li>段（Segment）</li></ul></li><li>读取可执行文件的头，建立虚拟空间和可执行文件的映射关系<ul><li>当程序发生<strong>缺页</strong>时，需要知道当前所需的页在可执行文件的哪一位置，这个位置信息存储在映射关系中</li><li>这是装载最核心的步骤，于是很多可执行文件也叫映像文件（Image）</li></ul></li><li>CPU指令寄存器设置为可执行文件的入口，程序运行</li></ol><h3 id="页错误">页错误</h3><p>当CPU开始执行一段指令时，发现所在地址的页面是一个空页面，这就是页错误</p><ol><li>此时操作系统会去读映射关系，找到当前页所在的VMA，计算出该页在可执行文件的位置</li><li>去物理内存中读这个页，并建立虚拟页和物理页的映射关系</li><li>回到先前的地址，继续执行指令</li></ol><h3 id="VMA">VMA</h3><p>VMA除了可以映射段，还会映射堆（Stack）和栈（Heap）</p><table><thead><tr><th>VMA类型</th><th>权限</th><th>能否执行</th></tr></thead><tbody><tr><td>代码VMA</td><td>只读</td><td>可执行</td></tr><tr><td>数据VMA</td><td>读写</td><td>可执行</td></tr><tr><td>堆VMA</td><td>读写</td><td>可执行</td></tr><tr><td>栈VMA</td><td>读写</td><td>不可执行</td></tr></tbody></table><h3 id="段地址对齐">段地址对齐</h3><p>x86处理器默认页的大小为4096字节，于是物理地址和虚拟地址进行映射时，虚拟内存空间的大小应该为4096字节的整数倍</p><h2 id="动态链接">动态链接</h2><p>静态链接浪费内存空间、磁盘空间、难以更新</p><p>动态链接将链接推迟到了运行（装载），能够实现库的复用，减少包体、提高缓存命中率</p><p>动态链接升级模块时，理论上只需要重新编译、替换动态库的模块，可以实现插件系统</p><p>Linux下动态库是动态共享对象（DSO），以<code>.so</code>结尾</p><p>Windows下动态库是动态链接库（DLL），以<code>.dll</code>结尾</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map</title>
      <link href="/program/map/"/>
      <url>/program/map/</url>
      
        <content type="html"><![CDATA[<h1>map</h1><blockquote><p>突然发现一个华科大佬的博客，学习一波</p></blockquote><p>map是一种映射结构，能够存取键值对（键是唯一的）</p><p>map通常有两种实现方式：哈希表（<code>std::unordered_map</code>）、红黑树（<code>std::map</code>）</p><h2 id="哈希表">哈希表</h2><p>哈希表的查找删除均为O(1)</p><p>哈希表是一种空间换时间的算法，现在我们要存储一组键值对，假设键的范围是0~99，那么我们就开辟一个大小为100的数组，数组中存储了指向值的指针，于是我们就可以通过Key去数组中找指针，再找到值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">value = a[key];</span><br></pre></td></tr></table></figure><p>不过开辟大小为100的数组过于昂贵了，只开辟大小为10的数组，Key去找值时先取模，再去数组中找指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">value = a[key%<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>不过这样也带来了一个问题，我们无法区分<code>key==21</code>和<code>key==31</code>，这种情况我们称之为<strong>哈希冲突</strong>，我们称21和31为同义词</p><p>解决哈希冲突的方式有：</p><ul><li>开放地址法</li><li>拉链法</li></ul><h3 id="拉链法">拉链法</h3><p>Key取模后去数组中找指针，这个指针是一个链表的头，遍历链表，找到对应Key的value</p><p>这种方法非同义词间不会影响</p><p><img src="/images/%E6%8B%89%E9%93%BE%E6%B3%95.jpg" class="lazyload" data-srcset="/images/%E6%8B%89%E9%93%BE%E6%B3%95.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="拉链法"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">point = a[key%<span class="number">10</span>];</span><br><span class="line"><span class="keyword">while</span>(point != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(point-&gt;key != key)</span><br><span class="line">    &#123;</span><br><span class="line">        point = point-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">break</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">value = point-&gt;value;</span><br></pre></td></tr></table></figure><h2 id="红黑树">红黑树</h2><p>红黑树的查找删除为O(logN)，但是空间效率更高</p><p>红黑树是一种自平衡的二叉搜索树，每个节点是黑色或红色</p><h3 id="二叉搜索树">二叉搜索树</h3><p>二叉搜索树（BST）：排序二叉树，任意一个根节点，其左子树Key均小于根，其右子树Key均大于根</p><p>BST的操作复杂度取决于树的高度，但某些情况下BST会退化为一条链</p><h3 id="平衡二叉树">平衡二叉树</h3><p>平衡二叉树（AVL）：左右子树的高度差不能大于1，操作过程中树一旦不稳定，就会进行旋转，以重新恢复平衡</p><p><img src="/images/avl-LL.jpg" class="lazyload" data-srcset="/images/avl-LL.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avl-LL"></p><p><img src="/images/avl-RR.jpg" class="lazyload" data-srcset="/images/avl-RR.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avl-RR"></p><p><img src="/images/avl-LR.jpg" class="lazyload" data-srcset="/images/avl-LR.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avl-LR"></p><p><img src="/images/avl-RL.jpg" class="lazyload" data-srcset="/images/avl-RL.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avl-RL"></p><h3 id="红黑树-2">红黑树</h3><p>红黑树左右子树高度差不能超过一倍</p><ol><li>所有null节点都认为是黑色。</li><li>一个红节点不能有红色孩子，即红色节点之间不能相邻。</li><li>红黑树中的节点到其任意叶子节点路径上的黑节点个数相同。</li><li>新插入的节点都是红色，在平衡过程中可能变色。</li></ol><p>红黑树比平衡二叉树更容易保持平衡，于是效率更高</p><p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91.png" class="lazyload" data-srcset="/images/%E7%BA%A2%E9%BB%91%E6%A0%91.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="红黑树"></p><h2 id="参考">参考</h2><p><a href="https://gufeijun.com/">辜飞俊的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BCN编码</title>
      <link href="/graphics/BCN%E7%BC%96%E7%A0%81/"/>
      <url>/graphics/BCN%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1>BCN编码</h1><blockquote><p>之前在知乎看到有美术在吵PNG和TGA哪一个更好用，但实际上引擎里使用的贴图是需要经过编码处理为GPU友好的资源格式，比如Windows上常用BCN编码，iOS常用ASTC编码</p></blockquote><h2 id="BCN原理">BCN原理</h2><blockquote><p>By storing some colors in their original size, and other colors using an encoding scheme, you can dramatically reduce the amount of memory required to store the image</p></blockquote><p>BCN是指一系列使用Block Compression技术的格式，比如BC3、BC7，在过去也被称为DXT</p><p>4x4的未压缩贴图在内存中会被排成一个长度为16的数组，如果一个像素要1bytes，那么未压缩的容量为16bytes</p><p><img src="/images/4x4%E8%B4%B4%E5%9B%BE.png" class="lazyload" data-srcset="/images/4x4%E8%B4%B4%E5%9B%BE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="4x4贴图"></p><p><img src="/images/4x4%E4%B8%8D%E5%8E%8B%E7%BC%A9.png" class="lazyload" data-srcset="/images/4x4%E4%B8%8D%E5%8E%8B%E7%BC%A9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="4x4不压缩"></p><h3 id="BCN-Format">BCN Format</h3><table><thead><tr><th>原始数据</th><th>编码精度需求 (单位bits)</th><th>推荐编码格式</th><th>每4x4像素大小</th></tr></thead><tbody><tr><td>RGBA</td><td>5 : 6 : 5 : 0 或 5 : 6 : 5 : 1</td><td>BC1</td><td>8</td></tr><tr><td>RGBA</td><td>5 : 6 : 5 : 4</td><td>BC2</td><td>16</td></tr><tr><td>RGBA</td><td>5 : 6 : 5 : 8</td><td>BC3</td><td>16</td></tr><tr><td>单通道灰度</td><td>8</td><td>BC4</td><td>8</td></tr><tr><td>双通道</td><td>8 : 8</td><td>BC5</td><td>16</td></tr><tr><td>RGB HDR</td><td>16 : 16 : 16</td><td>BC6H</td><td>16</td></tr><tr><td>RGB(A)</td><td>4 : 4 : 4 : (0~8) 或  7 : 7 : 7 : (0~8)</td><td>BC7</td><td>16</td></tr></tbody></table><p>DX9：BC1~3</p><p>DX10：BC4~5</p><p>DX11：BC7，BC6H</p><h3 id="BC1">BC1</h3><blockquote><p>下面这些图左边这个n bytes是指每一行是n bytes</p></blockquote><p>4x4的颜色被存储为两个color和16个index，每个index仅有两个比特位</p><p><img src="/images/BC1.png" class="lazyload" data-srcset="/images/BC1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC1"></p><p>color_0是这16个颜色中的最小值，color_1是最大值，我们先用这两个颜色生成两个中间值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">color_2 = <span class="number">2</span>/<span class="number">3</span>*color_0 + <span class="number">1</span>/<span class="number">3</span>*color_1</span><br><span class="line">color_3 = <span class="number">1</span>/<span class="number">3</span>*color_0 + <span class="number">2</span>/<span class="number">3</span>*color_1</span><br></pre></td></tr></table></figure><p>每个index只有两个比特位，只能存储四个信息，于是正好就可以存下这四个颜色的索引，对于每个像素，我们找到和他颜色最接近的color_x，并将他的index改为x</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">color_0 = <span class="number">00</span></span><br><span class="line">color_1 = <span class="number">01</span></span><br><span class="line">color_2 = <span class="number">10</span></span><br><span class="line">color_3 = <span class="number">11</span></span><br></pre></td></tr></table></figure><p>可以看出BC1的误差是相当大的，这个4x4个像素最后只有四种颜色</p><h3 id="BC2">BC2</h3><blockquote><p>BC2的RGB通道算法和BC1完全一致，然后为每一个像素加一个Alpha通道，也就是说，BC2的Alpha是完全没有被压缩的</p></blockquote><p><img src="/images/BC2.png" class="lazyload" data-srcset="/images/BC2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC2"></p><p>原理和BC1相同，都是用color_0和color_1生成四个颜色，每个index有两个位，存最相近的颜色的索引。唯一不同的是，BC2专门为每一个像素提供了一个 4位（0.5bytes）的Alpha通道</p><h3 id="BC3">BC3</h3><blockquote><p>BC2是完全不做Alpha的压缩，于是在BC3开始对其进行压缩，体现了技术的进步？</p></blockquote><p>BC3的RGB与BC1完全相同，Alpha使用类似思想进行压缩，将16个Alpha转化为两个alpha_x和16个index，两个alpha_x会插值出Alpha Table，16个像素各自去找最接近的Alpha，index记录他们的位数</p><p><img src="/images/BC3.png" class="lazyload" data-srcset="/images/BC3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC3"></p><p>为了精度，Alpha的位数是三个比特位，最多能表示八种Alpha，也就是说这16个像素最多会被分成八种Alpha</p><blockquote><p>alpha_0和alpha_1的大小对比提供了两个模式，使用第二个模式时可以直接得到0和255两个极值，而其他颜色还是在color间插值，效果会比所有颜色都直接在0和255两个极值间插8份更好，适用于颜色中存在极值的情况</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( alpha_0 &gt; alpha_1 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 6 interpolated alpha values.</span></span><br><span class="line">  alpha_2 = <span class="number">6</span>/<span class="number">7</span>*alpha_0 + <span class="number">1</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 010</span></span><br><span class="line">  alpha_3 = <span class="number">5</span>/<span class="number">7</span>*alpha_0 + <span class="number">2</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 011</span></span><br><span class="line">  alpha_4 = <span class="number">4</span>/<span class="number">7</span>*alpha_0 + <span class="number">3</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 100</span></span><br><span class="line">  alpha_5 = <span class="number">3</span>/<span class="number">7</span>*alpha_0 + <span class="number">4</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 101</span></span><br><span class="line">  alpha_6 = <span class="number">2</span>/<span class="number">7</span>*alpha_0 + <span class="number">5</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 110</span></span><br><span class="line">  alpha_7 = <span class="number">1</span>/<span class="number">7</span>*alpha_0 + <span class="number">6</span>/<span class="number">7</span>*alpha_1; <span class="comment">// bit code 111</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 4 interpolated alpha values.</span></span><br><span class="line">  alpha_2 = <span class="number">4</span>/<span class="number">5</span>*alpha_0 + <span class="number">1</span>/<span class="number">5</span>*alpha_1; <span class="comment">// bit code 010</span></span><br><span class="line">  alpha_3 = <span class="number">3</span>/<span class="number">5</span>*alpha_0 + <span class="number">2</span>/<span class="number">5</span>*alpha_1; <span class="comment">// bit code 011</span></span><br><span class="line">  alpha_4 = <span class="number">2</span>/<span class="number">5</span>*alpha_0 + <span class="number">3</span>/<span class="number">5</span>*alpha_1; <span class="comment">// bit code 100</span></span><br><span class="line">  alpha_5 = <span class="number">1</span>/<span class="number">5</span>*alpha_0 + <span class="number">4</span>/<span class="number">5</span>*alpha_1; <span class="comment">// bit code 101</span></span><br><span class="line">  alpha_6 = <span class="number">0</span>;                         <span class="comment">// bit code 110</span></span><br><span class="line">  alpha_7 = <span class="number">255</span>;                       <span class="comment">// bit code 111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BC4">BC4</h3><blockquote><p>BC4极少使用</p></blockquote><p>与BC1那种将4x4的像素转化为四种颜色不同，BC4是在两个颜色间做线性插值，red_0和red_1是最大最小颜色，像素数据转化为一个权重值（是一个0到1的float），使用这个权重值对red_0和red_1做线性插值即可还原颜色</p><p><img src="/images/BC4.png" class="lazyload" data-srcset="/images/BC4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC4"></p><p>不过三个比特位存一个0~1的浮点，精度其实很也很差吧，和离散的比没啥区别？</p><p>BC4_UNORM和BC4_SNORM仍然是使用BC3的离散Table算法</p><h3 id="BC5">BC5</h3><p>BC4的进阶版，简单来说就是将两个BC4拼在了一起</p><p><img src="/images/BC5.png" class="lazyload" data-srcset="/images/BC5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC5"></p><p>BC5_UNORM和BC5_SNORM也就是把对应的BC4拼起来</p><h4 id="法线贴图">法线贴图</h4><p>值得一提的是，BC5常用于压缩法线贴图，因为法线贴图有两个性质</p><ol><li>法线是归一化的$z=\pm\sqrt{1-x^2-y^2}$</li><li>法线各通道间是独立的</li></ol><p>BC1的方案将RGB三个通道进行杂糅，整体混合，这对于法线贴图来说是不可接受的，梯度太小，精度太差了，使用BC5存法线的两个通道，使用时再还原第三个通道，这些效果会更好</p><p><img src="/images/BC5%E6%B3%95%E7%BA%BF.png" class="lazyload" data-srcset="/images/BC5%E6%B3%95%E7%BA%BF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC5法线"></p><h3 id="承上启下">承上启下</h3><p>DX11提供了两个新的编码格式BC6H和BC7，再研究他们之前，我们先细数BC1压缩算法的问题吧</p><ol><li>信道不均，这很好理解，RGB通道分别被分了5 : 6 : 5位，这会导致三个通道全取最大值时会更偏绿（相较于三个通道相同尺寸）</li><li>精度太低，16个像素只能被转化位4种不同的颜色</li><li>三个通道耦合，且只使用两个颜色进行插值，这是一个线而非三角形</li></ol><p><img src="/images/BC1%E7%9A%84%E9%97%AE%E9%A2%98.png" class="lazyload" data-srcset="/images/BC1%E7%9A%84%E9%97%AE%E9%A2%98.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC1的问题"></p><h3 id="BC7">BC7</h3><p>核心思想</p><ol><li>存多个color，两个index</li><li>使用预计算的<strong>partition sets</strong>（调色盘）</li></ol><p>如果16个方块使用两个颜色涂抹，那么一共只会有$2^{16}$个情况，我们将这些情况全部离线存储在本地，并称之为调色盘（partition sets），使用一个索引即可得到对应的调色盘，还原出当前情况。</p><p>事实上由于颜色是存在连续性的，于是并不会出现这么多情况，于是我们可以大幅简化，使得几百种调色盘就足够使用。</p><p>更进一步，我们可以在调色盘种类和颜色数量间做平衡，使用更多种类的颜色和更少的调色盘种类，得到更丰富的模式</p><blockquote><p>BC7不同模式下总位数是确定的，于是color占的位数多了，调色盘占的位数就会变少</p></blockquote><p><img src="/images/BC7.png" class="lazyload" data-srcset="/images/BC7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC7"></p><p><img src="/images/BC7_2.png" class="lazyload" data-srcset="/images/BC7_2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC7_2"></p><p>BC7有很多模式（mode），我们可以为每块（4x4）选择一种模式，模式存储在BC7的开头（上图00001和1）</p><p>在不同的模式下，color数量和精度会改变，color越少越低精度，调色盘的选择就越多，反之color数据越多，调色盘选择就越少</p><p><img src="/images/BC7mode.jpg" class="lazyload" data-srcset="/images/BC7mode.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC7mode"></p><p>BC1是对两个color做个插值得到4个或者8个颜色，而BC7不做这个插值，需要多少颜色就存多少颜色，然后根据剩余的位数选择调色盘即可</p><p>![partition sets](/images/partition sets.jpg)</p><p>能看出下图上面一排只存了两个颜色，但调色盘变化更多样，下面一排存了三个颜色，调色盘变化略显单调</p><p><img src="/images/BC7_3.jpg" class="lazyload" data-srcset="/images/BC7_3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC7_3"></p><h3 id="BC6H">BC6H</h3><blockquote><p>干翻了RGBM，是BCN中唯一一个支持HDR的格式</p></blockquote><p>插值算法与BC7相同，用无符号整数来表示浮点数，将16位的数据的Sign位移除，加到Fraction位上，以提高float范围和精度</p><p><img src="/images/BC6H.png" class="lazyload" data-srcset="/images/BC6H.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BC6H"></p><h2 id="DDS">DDS</h2><blockquote><p>注意区分贴图Compress和zlib、lz4压缩</p></blockquote><p>使用BCN编码格式的文件在Windows操作系统下后缀为<code>.dds</code></p><p>DDS文件：DDS Header + DX10 Header + Mip0 raw data + Mip1 raw data + …</p><p>BCN是一种GPU友好型的数据格式，DDS文件大小仅与贴图大小、Mipmap数量、像素格式有关，一张1024x1024一级Mipmap一个像素4 bytes的贴图，无论其质量如何，<strong>其大小是确定的</strong>，都是1KB（Header） + 1024KB</p><p>尽管DDS比TGA小很多，但还是有进一步的压缩空间，UE使用Oodle进行BCN编码，通过设置RDO来影响数据的紧凑程度，经由lz4二压可以再降低10%~40%的包体大小</p><h3 id="DDS-Header">DDS Header</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PixelFormat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> fourCC;</span><br><span class="line">    <span class="type">uint32_t</span> RGBBitCount;</span><br><span class="line">    <span class="type">uint32_t</span> RBitMask;</span><br><span class="line">    <span class="type">uint32_t</span> GBitMask;</span><br><span class="line">    <span class="type">uint32_t</span> BBitMask;</span><br><span class="line">    <span class="type">uint32_t</span> ABitMask;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DDSHeader</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> Magic; <span class="comment">// Must be DDS_MAGIC</span></span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> height;</span><br><span class="line">    <span class="type">uint32_t</span> width;</span><br><span class="line">    <span class="type">uint32_t</span> pitchOrLinearSize;</span><br><span class="line">    <span class="type">uint32_t</span> depth;</span><br><span class="line">    <span class="type">uint32_t</span> num_mips;</span><br><span class="line">    <span class="type">uint32_t</span> reserved1[<span class="number">11</span>];</span><br><span class="line">    PixelFormat ddspf;</span><br><span class="line">    <span class="type">uint32_t</span> caps;</span><br><span class="line">    <span class="type">uint32_t</span> caps2;</span><br><span class="line">    <span class="type">uint32_t</span> caps3;</span><br><span class="line">    <span class="type">uint32_t</span> caps4;</span><br><span class="line">    <span class="type">uint32_t</span> reserved2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="DX10-Header">DX10 Header</h3><blockquote><p>在DX9中BC叫DXT，DX10以后才改为BC</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DX10Header</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> dxgi_format;</span><br><span class="line">    <span class="type">uint32_t</span> resource_dimension;</span><br><span class="line">    <span class="type">uint32_t</span> misc_flag; <span class="comment">// see D3D11_RESOURCE_MISC_FLAG</span></span><br><span class="line">    <span class="type">uint32_t</span> array_size;</span><br><span class="line">    <span class="type">uint32_t</span> misc_flag2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="dxgi-format">dxgi format</h4><p>dxgi_format：DirectX Graphics Infrastructure，格式为<code>DXGI_FORMAT_{编码类型}_{规范类型}</code>，比如<code>DXGI_FORMAT_BC1_UNORM</code>、<code>DXGI_FORMAT_R32_FLOAT</code></p><p>规范格式有：</p><ul><li>UNORM：Unsigned Normalized，无符号归一化</li><li>SNORM：Signed Normalized，有符号归一化</li><li>FLOAT：浮点数，动态范围更大，但储存空间更大</li><li>TYPELESS：没有具体的规范类型，用于运行时确定格式</li><li>UINT：无符号整数（不归一化）</li><li>SINT：有符号整数（不归一化）</li></ul><h2 id="BCN-Compress">BCN Compress</h2><p>常见的BCN压缩工具有Texconv、NVTT、Oodle</p><ul><li>这里面我感觉NVTT是优雅最方便的，很适合嵌入引擎或者小项目使用</li><li>Texconv有很浓厚的微软风格。。。</li><li>Oodle是商业软件，编码速度极慢，而且没有内置的Mipmap和贴图IO工具，他只会处理raw block data，说实话挺不方便的，而且网上资料特别少，用过的人也因为版权不敢去分享，传Github还会被删库，但是Oodle生成的dds二压后包体特别小，正式项目还是建议用Oodle</li></ul><p>下面是NVTT读TGA生成BC7格式DDS的样例代码，可以说非常地干净清晰</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nvtt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string raw_tga_path = <span class="string">&quot;D:\\art\\raw.tga&quot;</span>;</span><br><span class="line">std::string output_dds_path = <span class="string">&quot;D:\\art\\out\\nvtt_out.dds&quot;</span>;</span><br><span class="line">    <span class="type">int</span> mipmap_count = <span class="number">3</span>;</span><br><span class="line">    nvtt::Surface image;</span><br><span class="line">    image.<span class="built_in">load</span>(raw_tga_path.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="function">nvtt::Context <span class="title">context</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    nvtt::CompressionOptions compression_options;</span><br><span class="line">    compression_options.<span class="built_in">setFormat</span>(nvtt::Format_BC7);</span><br><span class="line">    nvtt::OutputOptions output_options;</span><br><span class="line">    output_options.<span class="built_in">setFileName</span>(output_dds_path.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!context.<span class="built_in">outputHeader</span>(image, mipmap_count, compression_options, output_options)) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Writing the DDS header failed!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compress and write the compressed data.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mipmap_index = <span class="number">0</span>; mipmap_index &lt; mipmap_count; mipmap_index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!context.<span class="built_in">compress</span>(image, <span class="number">0</span> , mipmap_index, compression_options, output_options)) </span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Compressing and writing the DDS file failed!&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mipmap_index == mipmap_count - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        image.<span class="built_in">toLinearFromSrgb</span>();</span><br><span class="line">        image.<span class="built_in">premultiplyAlpha</span>();</span><br><span class="line">        image.<span class="built_in">buildNextMipmap</span>(nvtt::MipmapFilter_Triangle);</span><br><span class="line">        image.<span class="built_in">demultiplyAlpha</span>();</span><br><span class="line">        image.<span class="built_in">toSrgb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://github.com/microsoft/DirectXTex">微软开源的贴图工具，包含Texconv</a></p><p><a href="https://learn.microsoft.com/en-us/windows/win32/direct3d10/d3d10-graphics-programming-guide-resources-block-compression">微软关于BCN的介绍</a></p><p><a href="https://github.com/nvpro-samples/nvtt_samples">英伟达开源的贴图工具NVTT</a></p><p><a href="http://www.radgametools.com/oodletexture.htm">UE使用的商业贴图工具Oodle官网</a></p><p><a href="https://sv-journal.org/2014-1/06/en/index.php?lang=en">BCN算法</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Texture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软光栅化遮挡剔除</title>
      <link href="/graphics/%E8%BD%AF%E5%85%89%E6%A0%85%E5%8C%96%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/"/>
      <url>/graphics/%E8%BD%AF%E5%85%89%E6%A0%85%E5%8C%96%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1>软光栅化遮挡剔除</h1><p>DrawCall和着色十分昂贵，于是我们希望可以剔除掉那些看不见的物体，以提高性能。而简单的视锥剔除并不能剃干净场景的物体，于是需要遮挡剔除。</p><p>这篇文章是一个CPU端的遮挡剔除，需要离线制作Occlusion Mesh，但不依赖各种GPU Driven的技术</p><p>Intel认为，CPU端使用GPU生成的Depth buffer做剔除，如果你不提前开一个Depth Only Pass画深度，那就要用上一帧的深度，一般而言，根据连续性，用上一帧的深度也没什么问题。但实际上CPU和GPU的Tick频率可能不同，两者间可能会差好几帧，于是用复用上一帧的深度不靠谱。</p><p>那什么靠谱呢？在CPU端用软光栅画一个Depth buffer，保证一定是当帧剔除。</p><h2 id="软光栅生成深度图">软光栅生成深度图</h2><p>Tile Base的软光栅</p><p>若三角形横跨多个Tile，则在每个Tile组中都加入这个三角形</p><p>Tile间互相独立，并行软光栅</p><p>对于三角形内的像素，通过重心公式插值出深度</p><p>如果软光栅得到的深度比深度缓冲更接近观察者，写深度</p><h2 id="剔除">剔除</h2><h3 id="1-近裁剪平面裁剪">1. 近裁剪平面裁剪</h3><p>若近裁剪平面设为1，顶点的齐次坐标为w，若$0 &lt; w &lt; 1$，则裁剪通过</p><h3 id="2-视锥剔除">2. 视锥剔除</h3><h3 id="3-深度测试">3. 深度测试</h3><p>若一个物体、AABB有像素可见，那么整体都可见</p><p>如一个物体、AABB完全被遮挡，那就继续检测这个物体所有的像素，直到发现这个物体所有像素均被遮挡</p><h2 id="优化">优化</h2><ul><li>Tile Base</li><li>视锥剔除</li><li>SSE intrinsics</li><li>TBB并行</li><li>遮挡物/被遮挡物大小阈值</li></ul><h2 id="参考">参考</h2><p><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/software-occlusion-culling.html">Intel Software Occlusion Culling</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Culling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep搜索lib文件</title>
      <link href="/program/grep/"/>
      <url>/program/grep/</url>
      
        <content type="html"><![CDATA[<h1>grep搜索lib</h1><h2 id="grep">grep</h2><p>前几天写代码发现链接不到某个函数，同事说我肯定少链接了一个<code>.lib</code>文件，然我却不知道少链接了谁</p><p>同事交给我一个小技巧，lib文件本质是一个代码压缩包，是可以对里面的内容进行搜索的，在Linux（WSL）中进入存放<code>.lib</code>的库，输入命令</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">grep -r &lt;函数名&gt; .</span><br></pre></td></tr></table></figure><p>就会匹配<code>vkCmdBeginDebugUtilsLabelEXT</code>这个函数在哪一个<code>.lib</code>中出现过</p><p>最后的输出是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">grep: ./&lt;库名&gt;.lib: binary file matches</span><br></pre></td></tr></table></figure><p>所以我少链接了这个.lib</p><h2 id="dumpbin">dumpbin</h2><p>然后大佬说我在windows下打开一个.lib其实用VS自带的dumpbin更好</p><blockquote><p>Visual Studio – 工具 – 命令行 – 开发者Powershell</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dumpbin /SYMBOLS .\imgui.lib | findstr.exe <span class="string">&quot;ImGui_ImplVulkan_CreatePipeline&quot;</span></span><br></pre></td></tr></table></figure><p>也可以输出到某个文件里</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dumpbin /SYMBOLS .\imgui.lib | findstr.exe <span class="string">&quot;ImGui_ImplVulkan_CreatePipeline&quot;</span> &gt; E:\a.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雨雪图</title>
      <link href="/graphics/%E9%9B%A8%E9%9B%AA%E5%9B%BE/"/>
      <url>/graphics/%E9%9B%A8%E9%9B%AA%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1>雨雪图</h1><p>现在游戏大多会有天气系统，尤其是雨天雪天</p><p>在雨天和雪天静态物上面要覆盖一层雪，可以参考Shadow Map的方法，从顶部向下绘制一张深度图（一般只收集静态物），运行时比较深度即可判断像素是否在最上面</p><p>值得注意的是玻璃等半透明物体按不透明的方式绘制深度图</p><h2 id="参考">参考</h2><p><a href="https://seblagarde.wordpress.com/2012/12/27/water-drop-2a-dynamic-rain-and-its-effects/">Water drop</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++获取CPU型号</title>
      <link href="/program/%E8%8E%B7%E5%8F%96CPU%E5%9E%8B%E5%8F%B7/"/>
      <url>/program/%E8%8E%B7%E5%8F%96CPU%E5%9E%8B%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1>C++获取CPU型号</h1><blockquote><p>不同CPU的指令集有所差异，尤其是在使用SIMD之类的feature时要十分注意，以MSVC获取CPU型号为例</p></blockquote><p>核心是使用指令<code>__cpuid</code>，其实你也可以<code>__asm {}</code>自己写汇编</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 4&gt; regs;</span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, 4&gt;&gt; data;</span><br><span class="line">    std::string vendor_string;</span><br><span class="line">    __cpuid(regs.<span class="built_in">data</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= regs[<span class="number">0</span>]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        __cpuidex(regs.<span class="built_in">data</span>(), i, <span class="number">0</span>);</span><br><span class="line">        data.<span class="built_in">push_back</span>(regs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> vendor[<span class="number">0x20</span>];</span><br><span class="line">    <span class="built_in">memset</span>(vendor, <span class="number">0</span>, <span class="built_in">sizeof</span>(vendor));</span><br><span class="line">    *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(vendor) = data[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(vendor + <span class="number">4</span>) = data[<span class="number">0</span>][<span class="number">3</span>];</span><br><span class="line">    *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(vendor + <span class="number">8</span>) = data[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    vendor_string = vendor;</span><br><span class="line">    <span class="keyword">if</span> (vendor_string == <span class="string">&quot;GenuineIntel&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Intel&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (vendor_string == <span class="string">&quot;AuthenticAMD&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AMD&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clustered Shading</title>
      <link href="/graphics/ClusteredShading/"/>
      <url>/graphics/ClusteredShading/</url>
      
        <content type="html"><![CDATA[<h1>Clustered Shading</h1><blockquote><p>《Clustered Deferred and Forward Shading》阅读笔记</p></blockquote><p>Cluster：组，簇，一堆物体的群集，将一个个零散的小物体整合为一个Cluster，可以加速剔除</p><p>Cluster的思路跟TBS思路很像，也是将view进行切分，但是每一个Cluster拥有一个固定的三维边界（坐标和法线），于是解决了Tiles退化的问题</p><p>光照计算时需要遍历物体和灯光，Clustered Shading的目的是剔除灯光</p><h2 id="Tile-base-Shading">Tile base Shading</h2><p>在讲Cluster前，先介绍什么是Tile base shading。TBS使用屏幕坐标将view切分为一个个小Tiles，单独绘制每一个Tiles，渲染结束后将所有Tiles合并呈现到屏幕上（得到framebuffer）</p><p>每一个Tiles会维护最小和最大深度，这两个深度和Tiles的屏幕UV就会组成一个粒度比较大的BV（Bound Volume），用于粗粒度的视锥剔除。在绘制每一个Tiles时，我只关注这个Tiles内的物体、灯光，不关心场景整体的复杂度，可以少遍历很多物体</p><p>此外这个Tiles之间是互相独立的，于是你可以自由控制他们的绘制顺序，比如如果某个像素上有两个半透明物体重叠，那么可以并行计算两个半透明物体的绘制结果，在最后一步混合时再手动排序</p><h3 id="优点">优点</h3><p>由于每次只需要绘制一个小Tiles，于是大幅减小的最大带宽（变得细水长流）</p><p>Tiles足够小，我们可以将Tiles放到片上缓存中，只需要调整着色器而无需移动资源位置（无需在显存和内存间传递，尤其是移动端这种共用全局内存的GPU），更进一步减少了带宽</p><img src="/images/AppleTBDR.png" class="lazyload" data-srcset="/images/AppleTBDR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="AppleTBDR" style="zoom:50%;" /><h3 id="问题">问题</h3><p>Tiles的BV是不确定的，通过屏幕UV采样深度得到的第三维边界是粗粒度的，不确定的。在某些极端相机视角下，min和max可能会差距很大，而内部的深度其实不连续（也就是最前面有个物体，最后面有个物体，结果得到了一个巨大的BV）</p><p>在这种情况下，BV就退化为一个平面，大幅降低了剔除效率</p><h2 id="相关技术">相关技术</h2><h3 id="Run-length-encoding">Run length encoding</h3><p>RLE（Run length encoding）是一种压缩算法，该算法依赖了数据的<strong>连续性</strong>，将一个一维的有重复值的数据进行压缩，能大幅减少数据量</p><p>此外当我们要对一个一维数组排序时，也可以将数组先做RLE，对压缩后的数据进行排序，排序结束后再展开</p><img src="/images/RLE.png" class="lazyload" data-srcset="/images/RLE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RLE" style="zoom:33%;" /><p>很多渲染技术都利用了数据的连续性，比如AA</p><h3 id="Virtual-Shadow-Maps">Virtual Shadow Maps</h3><p>VSMs是一张巨大的贴图（16k x16k），将这张巨大的贴图切成一个个小的Pages，仅当屏幕中有像素需要某个Pages时，才分配加载这个Pages</p><blockquote><p>于是出现了一个问题，要如何判定这个Pages被使用呢？</p></blockquote><h2 id="Clustered-Deferred-Shading">Clustered Deferred Shading</h2><blockquote><p>核心目标是剔除掉无用灯光</p></blockquote><ol><li>使用传统算法绘制GBuffer</li><li>分配Cluster（求切分后每一个Cluster的坐标）</li><li>找到唯一Cluster</li><li>分配灯光</li><li>着色</li></ol><h3 id="分配Cluster">分配Cluster</h3><p>根据连续性，若一个物体被某个灯光影响，其相邻的物体大概率也会被这个灯光影响</p><p>Cluster的本质就是将靠在一起的东西合并，光照计算时以Cluster为单位，而非Mesh/三角形。也就是说将这一组Mesh/三角形原子化（quantize）了</p><p>空间划分的方法有：</p><ul><li>世界坐标Grid切分<ul><li>数量过大，在远处存在浪费</li></ul></li><li>NDC空间按z均匀切分<ul><li>NDC非线性，近处Cluster过细，远处过粗</li></ul></li><li>View空间，按指数间隔切分深度</li></ul><p>最后作者选择了View空间按指数间隔切分深度，根据屏幕Tiles坐标$(i,j)$和深度等级$k$，每一个Cluster将拥有坐标$(i,j,k)$，他们在z轴方向上的距离间隔为$h_k$</p><img src="/images/指数间隔切分.png" class="lazyload" data-srcset="/images/指数间隔切分.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="指数间隔切分" style="zoom: 67%;" /><p>k是可以通过相机近平面、相机视角、该点深度和屏幕Tiles坐标求得</p><img src="/images/k的值.png" class="lazyload" data-srcset="/images/k的值.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="k的值" style="zoom:50%;" /><h3 id="找到唯一Cluster">找到唯一Cluster</h3><p>对每一个Tiles下的所有Cluster内物体进行排序</p><h3 id="分配灯光">分配灯光</h3><p>计算每一个Cluster受哪些光影响</p><p>在TBS中，我们可以直接遍历测试每一个Tiles和光源是否有覆盖，但这对于Cluster来说有些暴力了</p><ol><li>每一帧根据Z值顺序，将相邻的灯光（相邻32个灯）的BV合并，构建BVH（bounding volume hierarchy）</li><li>使用深度优先算法做Cluster和灯光BV的相交测试</li></ol><blockquote><p>英伟达GPU对32叉树更友好，而且32叉树深度更小，可以减少分支数</p></blockquote><p>这相较于Tiles Base有个好处是，当灯光特别特别多，均匀遍布在每一级深度中时，靠前的物体不需要再与靠后的灯光进行测试、着色（这是Tiles Base这种由最浅到最深构建的大BV无法做到的），能提升部分性能</p><h3 id="着色">着色</h3><p>用传统方案做着色计算</p><h2 id="作者的数据">作者的数据</h2><blockquote><p>我眼花了吗？作者对海量灯光的定义也太大了吧，这是12年的论文吧，同屏百万光源？手游项目同屏也就三四个点光吧</p></blockquote><p>在灯光数量较少时（比如同屏灯光少于1024个？？？），性能不如Tiles Base</p><p>在灯光特别多时（比如同屏灯光1048576个！！！），性能显著强于Tiles Base</p><h2 id="一点点想法">一点点想法</h2><p>延迟渲染光照计算次数 = 屏幕像素数 x 灯光数量，为了进一步提高着色效率，我们要剔掉一部分灯光</p><p>利用连续性原理，若一个像素被某个灯光影响，那么这个像素相邻的像素也可能被灯光影响，于是我们将view切分为一个个恰当尺寸的Cluster，每个Cluster只做一次灯光可见性测试，Cluster内部都使用相同的灯光list</p><p>与Tiles Base比，Cluster不仅对屏幕空间进行切分，还对深度进行切分，这使得被切分的空间复杂度是稳定的，和视角无关</p><p>不过Cluster与灯光测试比Tiles Base复杂了，而且Cluster的数据量更多，于是作者又基于深度构建了灯光的BVH，加速两个BV的测试</p><p>不过我们引入了两个3D场景描述结构，还使用了更复杂的相交测试方法，结果灯光较少时性能还更差了。。。移动端这两年苹果才刚开始大力推TBDR，感觉还是Tiles Base更有性价比</p><h2 id="参考">参考</h2><p><a href="https://developer.apple.com/documentation/metal/tailor_your_apps_for_apple_gpus_and_tile-based_deferred_rendering">Tailor Your Apps for Apple GPUs and Tile-Based Deferred Rendering</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视锥剔除</title>
      <link href="/graphics/%E8%A7%86%E9%94%A5%E5%89%94%E9%99%A4/"/>
      <url>/graphics/%E8%A7%86%E9%94%A5%E5%89%94%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1>视锥剔除</h1><blockquote><p>《Optimized View Frustum Culling Algorithms for Bounding Boxes》阅读笔记</p></blockquote><p>剔除的目的是减少要绘制不可见的物体，视锥剔除（View Frustum Culling，VFC）是使用一个平头四棱锥和场景中物体做可见性测试，实现快速剔除</p><p><img src="/images/%E8%A7%86%E9%94%A5%E5%89%94%E9%99%A4ue.png" class="lazyload" data-srcset="/images/%E8%A7%86%E9%94%A5%E5%89%94%E9%99%A4ue.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="视锥剔除ue"></p><p>为了加速视锥和场景物体的相交测试速度，我们会使用Bounding Volume（比如AABB、OBB、Sphere）来代替物体进行测试</p><p>视锥剔除可以并行计算，也可以使用BSP-trees加速</p><h2 id="基础数学知识">基础数学知识</h2><h3 id="点与面">点与面</h3><p>已知一个面的法线（已经归一化）为$\mathbf{n}$，沿着法线方向平移面，直到原点在面上，这个过程的移动距离为$d$</p><p>已知一个点的坐标$\mathbf{x}$，$\mathbf{x}$同时也是从原点指向这个点的向量，点到移动后的平面的距离是$\mathbf{n}\cdot\mathbf{x}$</p><p>所以，如果一个点在移动前的面上，那么应该满足<br>$$<br>\mathbf{n}\cdot\mathbf{x}+d=0<br>$$<br>通过这个公式，我们就可以快速判断点是否在平面上</p><h3 id="线与面">线与面</h3><p>一条线是两个点，如果两个点带入$\mathbf{n}\cdot\mathbf{x}+d$的符号是相反的，说明两个点在面的两侧，说明线与面相交</p><h3 id="AABB与面">AABB与面</h3><p>AABB是轴向包围盒，根据面的法线方向，就能知道AABB哪一个对角线轴最垂直于这个面，判读那这个对角线和面的关系，就能得到AABB和面的关系</p><p>我们还可以将这个对角线放在LUT里，加速之后几帧的相交检测（毕竟帧是连续的，我们可能会高频做相同面和对角线的相交检测）</p><h2 id="AABB视锥剔除">AABB视锥剔除</h2><h3 id="投影空间简单比较">投影空间简单比较</h3><p>还有一种和上述不同的方案，即将视锥和AABB转化到相机的透视投影空间，此时视锥变成一个立方体，于是就可以判断投影后的AABB和一个长方形视锥的相交关系，这个计算十分简单只需要算6次比较</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cube1_max[<span class="number">0</span>] &lt; cube2_min[<span class="number">0</span>] <span class="keyword">or</span> cube1_min[<span class="number">0</span>] &gt; cube2_max[<span class="number">0</span>] <span class="keyword">or</span></span><br><span class="line">    cube1_max[<span class="number">1</span>] &lt; cube2_min[<span class="number">1</span>] <span class="keyword">or</span> cube1_min[<span class="number">1</span>] &gt; cube2_max[<span class="number">1</span>] <span class="keyword">or</span></span><br><span class="line">    cube1_max[<span class="number">2</span>] &lt; cube2_min[<span class="number">2</span>] <span class="keyword">or</span> cube1_min[<span class="number">2</span>] &gt; cube2_max[<span class="number">2</span>]):</span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> True</span><br></pre></td></tr></table></figure><p>但这个方法缺点也很明显：需要做一个投影计算（很费）</p><p><img src="/images/AABB%E8%A7%86%E9%94%A5%E6%B5%8B%E8%AF%95.png" class="lazyload" data-srcset="/images/AABB%E8%A7%86%E9%94%A5%E6%B5%8B%E8%AF%95.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="AABB视锥测试"></p><h3 id="世界空间六个面替代视锥">世界空间六个面替代视锥</h3><p>我们可以将视锥是为六个平面，做六个平面和AABB的相交测试，若发现在AABB在视锥平面外，说明未相交，不可见</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">testVisible</span><span class="params">(AABB aabb, Camera camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 center = aabb.bound.center;</span><br><span class="line">    vec3 halfSize = <span class="built_in">abs</span>(aabb.bound.max - aabb.bound.min) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; plane : camera.frustumPlanes)</span><br><span class="line">    &#123;</span><br><span class="line">        SideResult side = <span class="built_in">testSide</span>(plane, center, halfSize);</span><br><span class="line">        <span class="keyword">if</span>(side == SideResult::OutSide)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作者的方案">作者的方案</h2><h3 id="八分检测">八分检测</h3><p>如图，我们使用轴将视锥切成八份，每一份是一个octant，每个octant都分到了三个外平面（图中加粗部分），若一个物体在视锥内，则必须在每一个octant的三个外平面的内侧</p><p><img src="/images/OctantTest.png" class="lazyload" data-srcset="/images/OctantTest.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="OctantTest"></p><p>对于一个AABB，他的中心点到corner的距离（其实就是半个主对角线长度）必须要小于视锥中心点到视锥平面的距离，也就是下图$d_2 \le d_1$。</p><p>这个检测的消耗特别小，不过不够准（必要不充分）</p><p>视锥中心点到六个平面的距离可以在每一帧计算前全局做一次</p><img src="/images/octantTest2.png" class="lazyload" data-srcset="/images/octantTest2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="octantTest2" style="zoom: 50%;" /><h3 id="标记视锥平面">标记视锥平面</h3><p>如果一个物体在一个视锥平面内侧，说明这个物体的所有子物体都在这个视锥平面内侧，那么我后面对子物体进行视锥剔除时不需要再用这个平面进行计算了</p><p>在AABB上维护一个bitfield，记录这个物体是被六个平面中哪些平面裁掉的</p><h3 id="连续性">连续性</h3><blockquote><p>TR：Translation and Rotation</p></blockquote><p>帧是连续的，我们让AABB记录一个bitfield和一个buffer，bitfield记录这个物体是被哪些平面裁掉，buffer记录AABB距离六个平面的距离</p><ul><li><p>如果一个物体在上一帧不可见，且视锥只移动了非常小的距离，那么这一帧这个物体大概率还是不可见</p></li><li><p>如果一个物体被视锥左平面剔除（可以复用“标记视锥平面”里的bitfield），那么视线向右转（不超过$180^{\circ}$）时，这个物体依然会不可见</p></li><li><p>如果相机只做移动，那么视锥平面到所有BV的最短距离均变化相同的值$\Delta d$（这个值可以全局只做一次），我们比较上一帧AABB到移动轴向两个平面的距离和$\Delta d$，即可判读这个物体可见性是否变化</p></li></ul><p><img src="/images/%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%89%94%E9%99%A4.png" class="lazyload" data-srcset="/images/%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%89%94%E9%99%A4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="连续性剔除"></p><h2 id="一点想法">一点想法</h2><p>一个基于连续性的剔除方法，能大幅减少剔除的次数和时间，只有第一帧在全场景遍历，后面都是增量改动。注意镜头快速移动时（比如setCameraPos）时主动重新全场景遍历一次吧</p><h2 id="参考">参考</h2><p><a href="https://docs.unrealengine.com/5.3/en-US/visibility-and-occlusion-culling-in-unreal-engine/#viewfrustum">UE5 View Frustum Document</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Culling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20下spdlog使用踩坑</title>
      <link href="/program/LogSystem/"/>
      <url>/program/LogSystem/</url>
      
        <content type="html"><![CDATA[<h1>C++20下spdlog使用踩坑</h1><p>spdlog是一个开源的被广泛使用的C++log系统，于是我模仿<a href="https://github.com/BoomingTech/Piccolo">Piccolo引擎</a>写了一个Log系统，结果由于C++不允许连续进行两次及以上的用户自定义的隐式构造，使得spdlog的log函数无法正确推断匹配<code>Args...</code>，最后在公司C++高手的帮助下成功解决了问题，于是在此记录一下踩坑历程</p><h2 id="最初的版本">最初的版本</h2><p>我参考开源项目的实现，使用spdlog写了一个简易的LogManager，将其添加到一共全局变量中，通过宏将不同类型的LOG封装，还传递了函数Module</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_HELPER(LOG_LEVEL, ...) \</span></span><br><span class="line"><span class="meta">    g_global_context.m_log_manager-&gt;log(LOG_LEVEL, <span class="string">&quot;[&quot;</span> + std::string(__FUNCTION__) + <span class="string">&quot;] &quot;</span> + __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(...) LOG_HELPER(LogManager::LogLevel::Debug, __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(...) LOG_HELPER(LogManager::LogLevel::Info, __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(...) LOG_HELPER(LogManager::LogLevel::Warn, __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(...) LOG_HELPER(LogManager::LogLevel::Error, __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FATAL(...) LOG_HELPER(LogManager::LogLevel::Fatal, __VA_ARGS__);</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogManager</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">LogLevel</span> : <span class="type">uint8_t</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug,</span><br><span class="line">        Info,</span><br><span class="line">        Warn,</span><br><span class="line">        Error,</span><br><span class="line">        Fatal</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogManager</span>();</span><br><span class="line">    ~<span class="built_in">LogManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">log</span><span class="params">(LogLevel level, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (level)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> LogLevel::Debug:</span><br><span class="line">            m_logger-&gt;<span class="built_in">debug</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LogLevel::Info:</span><br><span class="line">            m_logger-&gt;<span class="built_in">info</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LogLevel::Warn:</span><br><span class="line">            m_logger-&gt;<span class="built_in">warn</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LogLevel::Error:</span><br><span class="line">            m_logger-&gt;<span class="built_in">error</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LogLevel::Fatal:</span><br><span class="line">            m_logger-&gt;<span class="built_in">critical</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">fatalCallback</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> std::string format_str = std::format(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(format_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;spdlog::logger&gt; m_logger;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而当我测试时，却出现了错误</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LOG_INFO</span>(<span class="string">&quot;Scene Tick&#123;&#125;&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">error C7595<span class="punctuation">:</span> “fmt<span class="punctuation">:</span><span class="punctuation">:</span>v9<span class="punctuation">:</span><span class="punctuation">:</span>basic_format_string&lt;char<span class="punctuation">,</span>int&gt;<span class="punctuation">:</span><span class="punctuation">:</span>basic_format_string”<span class="punctuation">:</span> 对即时函数的调用不是常量表达式</span><br><span class="line">message <span class="punctuation">:</span> 因读取超过生命周期的变量而失败</span><br><span class="line">message <span class="punctuation">:</span> 请参见“&lt;args_0&gt;”的用法</span><br></pre></td></tr></table></figure><h2 id="fmt版本">fmt版本</h2><p>我求助了公司的C++高手，高手给我改成了这样，他将参数中函数Module分离出来，并将其和表达式宏拼接</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_HELPER(LOG_LEVEL, MODULE, FMT_STRING, ...) \</span></span><br><span class="line"><span class="meta">    g_global_context.m_log_manager-&gt;log(LOG_LEVEL, MODULE##FMT_STRING, __VA_ARGS__);</span></span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">template&lt;typename... Args&gt;</span><br><span class="line"><span class="addition">+void log(LogLevel level, const char* _module, Args&amp;&amp;... args)</span></span><br><span class="line">&#123;</span><br><span class="line">    switch (level)</span><br><span class="line">    &#123;</span><br><span class="line">    case LogLevel::Debug:</span><br><span class="line"><span class="addition">+        m_logger-&gt;debug(spdlog::fmt_runtime_string&lt;char&gt;&#123; _module &#125;, std::forward&lt;Args&gt;(args)...);</span></span><br><span class="line">        break;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并让我这样调用函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LOG_INFO</span>(__FUNCTION__, <span class="string">&quot;xxx&#123;&#125;&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>结果我发现，在高手电脑上可以正确运行的代码，在我本地缺会丢失<code>&quot;xxx1&quot;</code>这一部分，经过一段时间的排查，发现是我们的编译器预编译指令处理方式有区别，于是我修改cmake，让编译器使用符合C++标准的行为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">    <span class="built_in">target_compile_options</span>(core PUBLIC <span class="string">&quot;/Zc:preprocessor&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br></pre></td></tr></table></figure><p>添加后<code>&quot;xxx1&quot;</code>确实成功出现了</p><p>我本以为问题就这样解决，但C++高数却让我再实现一个可以只传字符串的重载（调另一个log接口），因为现在这个Log没法传入下面这种纯字符串内容</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LOG_INFO</span>(__FUNCTION__, <span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>我整个人傻眼了，心想spdlog这么厉害的库，肯定有很多人在C++20的环境下使用，怎么可能要这么丑陋的实现！</p><h2 id="std-fotmat版本">std::fotmat版本</h2><p>然后我翻看spdlog的源码，发现他有两个log的实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">const</span> T &amp;msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(level::debug, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">format_string_t</span>&lt;Args...&gt; fmt, Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(level::debug, fmt, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我就发现，原来我们之前一直想匹配到下面这个接口，却由于C++20在预编译处理上的一些改动，使我的代码十分复杂丑陋，而且还使用了spdlog内部的类型，我挺反感这种用一些模块内部类型的操作，我感觉好的工具类应该能黑箱地用</p><p>看着看着，我恍然大悟，C++20提供了<code>std::format</code>函数，我可以自己format字符串，传给spdlog一个普通字符串就行了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_HELPER(LOG_LEVEL, ...) \</span></span><br><span class="line"><span class="meta">    g_global_context.m_log_manager-&gt;log(LOG_LEVEL,<span class="string">&quot;[&quot;</span> __FUNCTION__ <span class="string">&quot;] &quot;</span> +std::format(__VA_ARGS__));</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogLevel level, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (level)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> LogLevel::Debug:</span><br><span class="line">        m_logger-&gt;<span class="built_in">debug</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉是时候深入学习C++20了</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glTF入门</title>
      <link href="/graphics/gltf%E5%85%A5%E9%97%A8/"/>
      <url>/graphics/gltf%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>glTF入门</h1><h2 id="glTF介绍">glTF介绍</h2><p>DCC生成的模型往往不能直接被渲染引擎使用，比如包含冗余数据、缺失场景数据、缺少动画状态机、压缩率不足等。许多引擎拥有一个Asset Pipeline，负责将不同DCC导出的各类数据转化为引擎可以直接使用的资源文件，比如UE的<a href="https://docs.unrealengine.com/4.26/zh-CN/SharingAndReleasing/Deployment/Cooking/">Cooking</a>操作</p><p>glTF是一种表示3D场景的模型格式，它的目标就是尽可能保留3D场景相关的数据（使用json描述场景），为渲染引擎提供无需解码的模型数据（使用二进制存储buffer和image）</p><h3 id="文本类型">文本类型</h3><p>glTF有二进制（.glb）和ASCII文本格式（.gltf）</p><p>一般而言，文本格式的glTF并不包含二进制内容（buffer和image），而是仅有一个uri链接，指向真正存储这些二进制数据的文件，这些数据已经被处理成GPU便于访问的格式</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;buffer01&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;byteLength&quot;</span><span class="punctuation">:</span> <span class="number">12352</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arraybuffer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;buffer01.bin&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;image01&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image01.png&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>正是因为glTF这种描述和存储分离的特点，我们可以用很小的文件就能得到场景的描述，当我们需要使用到某个buffer或image时再懒加载这个资源，于是很适合Web项目。现在很多基于WebGL的渲染器都使用glTF格式</p><p>值得注意的是，对于一些小模型，我们也可以将这些二进制嵌入到json中</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;buffers&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;uri&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;data:application/octet-stream;base64,AAABAAIAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAA=&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;byteLength&quot;</span> <span class="punctuation">:</span> <span class="number">44</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="json结构">json结构</h3><p><img src="/images/gltfJsonStructure.png" class="lazyload" data-srcset="/images/gltfJsonStructure.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="gltfJsonStructure"></p><h4 id="scene">scene</h4><p>scene是解析一个glTF的入口，一个glTF可以包含多个scene</p><p>一个scene中会有一个nodes，nodes是一个数组，指向多个node</p><p>一个node中会有mesh等元素</p><h4 id="mesh">mesh</h4><p>一个meshes包含多个primitives（图元），每个图元中有一个attributes（属性）和indices</p><p>attributes中包含着模型的顶点数据（vertices），比如POSITION、NORMAL、TEXCOORD_0</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;meshes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;primitives&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attributes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;POSITION&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;indices&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">      <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h4 id="accessor">accessor</h4><p>accessor（访问器），这是对资源的一种抽象封装，它存储了bufferView的结构，以及访问方法</p><p>对于mesh、skin、animation等数据，我们要通过accessor来访问。accessor中有一个bufferView，bufferView又指向存储真正二进制数据的buffer</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;accessors&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;bufferView&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;byteOffset&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;componentType&quot;</span> <span class="punctuation">:</span> <span class="number">5123</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;count&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;SCALAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;max&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">2</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;min&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">0</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;bufferView&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;byteOffset&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;componentType&quot;</span> <span class="punctuation">:</span> <span class="number">5126</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;count&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;VEC3&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;max&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">0.0</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;min&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">0.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">,</span> <span class="number">0.0</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h4 id="buffer">buffer</h4><blockquote><p>A buffer defines a block of raw, unstructured data with no inherent meaning</p></blockquote><p>为了便于渲染API的使用，glTF里的buffer是单纯的二进制，因此在解析时一定要明确读取的步长、类型</p><h4 id="bufferView">bufferView</h4><blockquote><p>A bufferView describes a “chunk” or a “slice” of the whole, raw buffer data</p></blockquote><p>bufferView将一个完整的巨大的二进制内容切割为一个个小片，可以实现一个buffer存储多种类型的数据，还可以实现字节对齐等功能</p><h2 id="一个简单的读mesh示例">一个简单的读mesh示例</h2><blockquote><p>这里我使用<a href="https://github.com/syoyo/tinygltf">tinygltf</a>库来加载glTF，这是一个基于cmake的纯头文件库</p></blockquote><p>举一个简单的glTF读取mesh的例子，仅读取index buffer和vertex buffer（只有POSITION和TEXCOORD_0）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GltfLoader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GltfLoader</span>(std::string model_path);</span><br><span class="line">    ~<span class="built_in">GltfLoader</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Index&gt; loaded_index_buffer;</span><br><span class="line">    std::vector&lt;Vertex&gt; loaded_vertex_buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    tinygltf::Model m_gltf_model;</span><br><span class="line">    tinygltf::TinyGLTF m_loader_context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GltfLoader::<span class="built_in">GltfLoader</span>(std::string model_path)</span><br><span class="line">&#123;</span><br><span class="line">    std::string gltf_load_error;</span><br><span class="line">    std::string gltf_load_warning;</span><br><span class="line">    <span class="type">bool</span> gltf_load_result = m_loader_context.<span class="built_in">LoadASCIIFromFile</span>(&amp;m_gltf_model, &amp;gltf_load_error, &amp;gltf_load_warning, model_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gltf_load_result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// load mesh</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; mesh : m_gltf_model.meshes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; primitive : mesh.primitives)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// vertex</span></span><br><span class="line">                <span class="type">int</span> vertex_count = <span class="number">0</span>;</span><br><span class="line">                std::vector&lt;Vertex&gt; local_vertex_buffer;</span><br><span class="line">                <span class="comment">// position</span></span><br><span class="line">                <span class="keyword">if</span> (primitive.attributes.<span class="built_in">find</span>(<span class="string">&quot;POSITION&quot;</span>) != primitive.attributes.<span class="built_in">end</span>()) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> accessor_index = primitive.attributes.<span class="built_in">at</span>(<span class="string">&quot;POSITION&quot;</span>);</span><br><span class="line">                    <span class="type">const</span> tinygltf::Accessor&amp; accessor = m_gltf_model.accessors[accessor_index];</span><br><span class="line">                    <span class="type">const</span> tinygltf::BufferView&amp; buffer_view = m_gltf_model.bufferViews[accessor.bufferView];</span><br><span class="line">                    <span class="type">const</span> tinygltf::Buffer&amp; buffer = m_gltf_model.buffers[buffer_view.buffer];</span><br><span class="line">                    <span class="type">const</span> <span class="type">float</span>* data_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">float</span>*&gt;(&amp;buffer.data[buffer_view.byteOffset + accessor.byteOffset]);</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> position_byte_stride = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                    vertex_count = accessor.count;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertex_count; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Vertex local_vertex;</span><br><span class="line">                        local_vertex.pos = glm::<span class="built_in">vec3</span>(data_ptr[i * position_byte_stride], data_ptr[i * position_byte_stride + <span class="number">1</span>], data_ptr[i * position_byte_stride + <span class="number">2</span>]);</span><br><span class="line">                        local_vertex_buffer.<span class="built_in">push_back</span>(local_vertex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// uv</span></span><br><span class="line">                <span class="keyword">if</span> (primitive.attributes.<span class="built_in">find</span>(<span class="string">&quot;TEXCOORD_0&quot;</span>) != primitive.attributes.<span class="built_in">end</span>()) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> accessor_index = primitive.attributes.<span class="built_in">at</span>(<span class="string">&quot;TEXCOORD_0&quot;</span>);</span><br><span class="line">                    <span class="type">const</span> tinygltf::Accessor&amp; accessor = m_gltf_model.accessors[accessor_index];</span><br><span class="line">                    <span class="type">const</span> tinygltf::BufferView&amp; buffer_view = m_gltf_model.bufferViews[accessor.bufferView];</span><br><span class="line">                    <span class="type">const</span> tinygltf::Buffer&amp; buffer = m_gltf_model.buffers[buffer_view.buffer];</span><br><span class="line">                    <span class="type">const</span> <span class="type">float</span>* data_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">float</span>*&gt;(&amp;buffer.data[buffer_view.byteOffset + accessor.byteOffset]);</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> uv_byte_stride = accessor.<span class="built_in">ByteStride</span>(buffer_view) ? (accessor.<span class="built_in">ByteStride</span>(buffer_view) / <span class="built_in">sizeof</span>(<span class="type">float</span>)) : tinygltf::<span class="built_in">GetNumComponentsInType</span>(TINYGLTF_TYPE_VEC2);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertex_count; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        local_vertex_buffer[i].texture_coord = glm::<span class="built_in">vec2</span>(data_ptr[i * uv_byte_stride], data_ptr[i * uv_byte_stride + <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// append local vertex buffer to loaded vertex buffer</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertex_count; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    loaded_vertex_buffer.<span class="built_in">push_back</span>(local_vertex_buffer[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// index</span></span><br><span class="line">                <span class="keyword">if</span> (primitive.indices &gt;= <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">const</span> tinygltf::Accessor&amp; accessor = m_gltf_model.accessors[primitive.indices];</span><br><span class="line">                    <span class="type">const</span> tinygltf::BufferView&amp; buffer_view = m_gltf_model.bufferViews[accessor.bufferView];</span><br><span class="line">                    <span class="type">const</span> tinygltf::Buffer&amp; buffer = m_gltf_model.buffers[buffer_view.buffer];</span><br><span class="line"></span><br><span class="line">                    <span class="type">const</span> <span class="type">void</span>* dataPtr = &amp;(buffer.data[buffer_view.byteOffset + accessor.byteOffset]);</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> elements_count = accessor.count;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// MARK: the component type is very important, common is TINYGLTF_PARAMETER_TYPE_UNSIGNED_SHORT</span></span><br><span class="line">                    <span class="keyword">switch</span> (accessor.componentType) </span><br><span class="line">                    &#123;</span><br><span class="line">                    <span class="keyword">case</span> TINYGLTF_PARAMETER_TYPE_UNSIGNED_INT:</span><br><span class="line">                        &#123;</span><br><span class="line">                        <span class="type">const</span> <span class="type">uint32_t</span>* buf = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint32_t</span>*&gt;(dataPtr);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elements_count; i++)</span><br><span class="line">                            &#123;</span><br><span class="line">                                Index local_index;</span><br><span class="line">                                local_index.index = buf[i];</span><br><span class="line">                                loaded_index_buffer.<span class="built_in">push_back</span>(local_index);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> TINYGLTF_PARAMETER_TYPE_UNSIGNED_SHORT: &#123;</span><br><span class="line">                        <span class="type">const</span> <span class="type">uint16_t</span>* buf = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint16_t</span>*&gt;(dataPtr);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elements_count; i++)</span><br><span class="line">                            &#123;</span><br><span class="line">                                Index local_index;</span><br><span class="line">                                local_index.index = buf[i];</span><br><span class="line">                                loaded_index_buffer.<span class="built_in">push_back</span>(local_index);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> TINYGLTF_PARAMETER_TYPE_UNSIGNED_BYTE: &#123;</span><br><span class="line">                        <span class="type">const</span> <span class="type">uint8_t</span>* buf = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(dataPtr);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elements_count; i++)</span><br><span class="line">                            &#123;</span><br><span class="line">                                Index local_index;</span><br><span class="line">                                local_index.index = buf[i];</span><br><span class="line">                                loaded_index_buffer.<span class="built_in">push_back</span>(local_index);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        std::cerr &lt;&lt; <span class="string">&quot;Index component type &quot;</span> &lt;&lt; accessor.componentType &lt;&lt; <span class="string">&quot; not supported!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> load children</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> load transform, material, texture, skin, skeleton, animtion, blendshape</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://github.khronos.org/glTF-Tutorials/gltfTutorial/">glTF Tutorials</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> glTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无状态方法</title>
      <link href="/program/%E6%97%A0%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/program/%E6%97%A0%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>无状态方法</h1><h2 id="线程安全">线程安全</h2><p>同事经常跟我强调线程安全的重要性，比如下面这段代码，id是一个静态成员变量，被所有Student类的对象共享，在多线程环境下可能会造成不确定行为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Student::id = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>我们可以加入一个锁以实现线程安全，std::lock_guard会通过其生命周期创建销毁锁</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::mutex id_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(id_mutex)</span></span>;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Student::id = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="无状态方法">无状态方法</h2><p>然后同事又跟我介绍了<strong>无状态方法</strong>（Stateless），即计算中不依赖先前的状态或上下文的方法。比如stl中大量的非成员函数，他们大多都是无状态方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种非成员函数是无状态的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">adder</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">adder</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过重载()运算符来实现adder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> c)&#123; <span class="keyword">this</span>-&gt;c = c; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="function">Adder <span class="title">adder</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">adder</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般而言，无状态方法只要输入是确定的，输出一般是可预料的（内部使用random相关函数的输出总体也是有期望的）</p><p>与无状态方法对应的是<strong>有状态方法</strong>（Stateful），比如一些读资源函数，我传入一个指针、Handle、索引，返回的结果取决于资源状态，输出的结果是不确定的。有状态方法一般要注意线程安全问题、空指针、索引越界等问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不好的设计，因为getCurrentDateText的结果与format的状态有关</span></span><br><span class="line"><span class="comment">// 尽管这样设计性能更好（不频繁创建新对象），一般也没人改format</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy.MM.dd&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getCurrentDateText</span><span class="params">()</span> </span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">return</span> format.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无状态方法，线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getCurrentDateText</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy.MM.dd&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://www.infoq.cn/news/2012/06/ugly-code-12">无状态方法</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分配</title>
      <link href="/program/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/program/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1>内存分配</h1><blockquote><p>最近看了一些关于内存分配的分享，发现操作系统相关的知识都忘光了，于是打算借助Linux内核的内存分配机制，简单复习一下内存分配相关的理论知识</p></blockquote><p>程序运行时不断进行内存的申请与释放，高效的分配方式不仅能提高内存的利用率，还能提高性能。</p><h2 id="Linux内存分配原理">Linux内存分配原理</h2><h3 id="地址">地址</h3><p>程序需要装入内存才能运行，程序开始的位置相较于内存0地址会有一段偏移，这个偏移被称为物理地址。</p><p>在程序内部，以程序开头为0地址，向后偏移得到的地址称为逻辑地址。</p><h3 id="分配">分配</h3><p>内存分配最大的问题是内存碎片问题，大的数据间总是残余一些小的空间，这些空间整体数量较多，但是单个空间较小，无法满足存入新的大数据，于是尽管我们还有大量空间没有被使用，但是无法分配给新的数据。</p><ul><li>连续分配（将程序放在一起）<ul><li>单一连续分配<ul><li>系统区</li><li>用户区</li></ul></li><li>固定分区分配</li><li>可变分区分配<ul><li>首次适应</li><li>最后适应</li><li>最佳适应</li><li>最坏适应</li></ul></li></ul></li><li>不连续分配（将程序分散放置）<ul><li>页式管理</li><li>段式管理</li></ul></li></ul><p>Intel CPU硬件支持段式管理和二层页式管理，Liunx主要使用二层页式管理。</p><h3 id="页式管理">页式管理</h3><blockquote><p>一本书有很多页，每一页都有页码，页码可以唯一标识一本书中的某一页，页式管理就是将数据分成一个个大小相等的页，每一页都有一个唯一的页码，通过页码可以找到对应的数据</p></blockquote><p>页式管理是一种不连续分配技术，将数据的逻辑地址拆成一个个大小相等的<strong>页面</strong>。将内存也拆成一个个大小相等的<strong>页框（物理块）</strong>，并为每个页框分配一个唯一的<strong>页框号</strong>。</p><p>程序被装入内存时，被拆成多个页，这些页会被放入内存中不连续的位置，通常只有最后一页会写不满，因此只会产生一个页内碎片。</p><p><img src="/images/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6.png" class="lazyload" data-srcset="/images/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="页表机制"></p><p>上图中间的是<strong>页表</strong>，存储着页号和物理块的对应关系，以实现页间寻址。<br>页内的数据通过虚地址（页号+页内偏移量）来实现页内寻址。</p><p>为了提速，页表含有一个缓存机制。</p><p>我们上面的页表是连续分配的，而对于一个32位系统，他拥有一个大小为$2^{32}$的逻辑空间，会形成一个巨大的页表。为此我们将页表也进行拆分，离散存储在内存中，使用一个外层目录表来存储页表的地址。当我们需要某一个页数据时，通过外层目录找到对应页表的地址，将该部分页表装入内存，再通过页表找到对应的页数据。这个方案叫做二级页表。</p><h2 id="常见内存分配器">常见内存分配器</h2><p>Linux内核为不同场景设计了不同的分配器，比如Slab、TLSF、Buddy，内存分配器需要在分配性能和空间利用率间做出权衡。</p><blockquote><p>我感觉这三个分配器并不是平级的关系，Buddy像是一个硬件级、操作系统级的分配器，进行页面级别的内存分配，他解决了程序要怎么分散放置在内存中。TLSF解决了如何具体分配一块指定大小的内存。Slab则为内存分配提供了缓存优化。</p></blockquote><h3 id="Buddy">Buddy</h3><blockquote><p>以内存页（4kb）为单位分配内存，本质还是一种空闲链表法</p></blockquote><p>Buddy系统将内存拆分为多个物理块，这些块的大小均为2的幂次方</p><p>Buddy分配器维护了一个空闲位图（也有用二叉树维护的），这个位图是一个数组，数组的每个元素是一个链表。链表中每一个元素均为$2^n$大小的空闲物理块，其中$n$为order的值。</p><p><img src="/images/buddy%E8%A1%A8.png" class="lazyload" data-srcset="/images/buddy%E8%A1%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Buddy位图"></p><p>当分配一个大小为k的内存时，分配器会找到比k大且order值最小的空闲块，如果这个最小的空闲块比k的两倍还大，那么将这个空闲块拆分为二，再次进行分配。</p><p>当释放一块内存时，将新的内存块放入对应链表中，若该链表中内存块过多，会进行合并操作</p><h3 id="TLSF">TLSF</h3><blockquote><p>用于分配介于512b和512kb的数据，实现可以参考<a href="https://github.com/mattconte/tlsf">tlsf</a></p></blockquote><p>TLSF（Two-Level Segregated Fit）的核心是使用两级链表。</p><p>第一级链表（下图f1）将空闲内存块大小根据二的幂次方进行分类（注意，这里表示的是内存的粗细粒度，而非要求内存块大小必须为二的幂次方），该行的内存块大小范围为$[2^i, 2^{i+1})$</p><p>第二级链表（下图s1）按照间隔，将索引$[2^i, 2^{i+1})$进行分段，以加速查找。二级链表的值是一个链表，链表中的每个元素是一个空闲内存块，大小和索引值相同。</p><p>FL_bitmap和SL_bitmaps[]的每一个bit表示是否被使用。</p><p>当我们需要分配一个大小为89Bytes的内存时，这个数据范围在$[64, 128)$，我们通过FL_bitmap判断出第6行是有空闲块的。然后通过SL_bitmaps[6]判断出$[88, 96)$这个范围中有空闲块，最后分配出89Bytes大小的内存块</p><p><img src="/images/TLSF%E4%B8%A4%E7%BA%A7%20%E7%B4%A2%E5%BC%95.jpg" class="lazyload" data-srcset="/images/TLSF%E4%B8%A4%E7%BA%A7%20%E7%B4%A2%E5%BC%95.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TLSF两级索引"></p><p><img src="/images/TLSF.png" class="lazyload" data-srcset="/images/TLSF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TLSF结构"></p><p>TLSF分配、释放、再分配复杂度均为稳定的O(1)，且适用于高负载和多线程环境。不过尽管操作复杂度都是常数级，但位图操作比较复杂，速度并不一定快</p><h3 id="Slab">Slab</h3><blockquote><p>用于小于512b、频繁被销毁创建的数据，</p></blockquote><p>上面的Buddy算法以页为单位进行分配，对于几字节的小文件，这十分浪费。Slab分配器用于在一个页框内分配小存储区，是对Buddy分配在小文件的补充。</p><p>Slab分配器是一种基于缓存的内存分配方法，对于一些高频使用的对象（比如进程描述符），将其放入Slab缓存中。</p><p>当需要创建一个对象时直接从缓存中拿去一份（所有权转移？）。当进程结束后，并不将对象所在的页框释放，而是重新放回Slab分配器中。</p><p>一个对象可以同时有着多个副本缓存，我们将同一个对象的所有缓存存入一个双向循环链表中，这个链表被称为“缓存链”。</p><p>通过着色技术提高缓存利用率。</p><h4 id="缓存着色技术">缓存着色技术</h4><p>缓存着色技术适用于组相联映射缓存</p><p>缓存的组织组织方式：</p><ul><li>直接映射</li><li>组相连映射（set associative cache）</li><li>全相连映射（full associative cache）</li></ul><p>直接映射：内存地址到缓存地址的映射是唯一的，通常为取模运算。这会导致相邻的内存会被映射到同一缓存地址，导致<strong>缓存冲突</strong>（conflict miss）</p><p>全相联映射：允许内存地址映射到任何缓存地址。但是为了检查特定地址是否在缓存中，需要整个便利。通常要实现一套LRU（最近最少使用）系统。全相联缓存硬件复杂，而且极其昂贵，一般都极其小。</p><p>组相联映射是对两者的折中，将整个缓存分成n个组，每个组中有m块。将内存做拆分，每个内存块有n行数据。内存中第i行的数据可以存在第i组缓存中，内存块和块之间共享m块缓存。当内存数据存入缓存时，通过取模运算得到组号，再便利组内数据，判断该数据是否已经在缓存中了。</p><p><img src="/images/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" class="lazyload" data-srcset="/images/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="组相连映射"></p><p>然后我们发现，如果同时多个数据他们的组号相同，他们还是会被映射到同一个组内，一旦数量超过了m条，就会引发缓存冲突。</p><p>缓存着色技术将内存、程序、缓存进行分行并标色，对于一段程序，操作系统会尽量将程序的某一行放到对应颜色的内存行、缓存行中（红色的程序行放在红色的缓存行中）。</p><p><img src="/images/%E7%BC%93%E5%AD%98%E7%9D%80%E8%89%B2.png" class="lazyload" data-srcset="/images/%E7%BC%93%E5%AD%98%E7%9D%80%E8%89%B2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="缓存着色"></p><h2 id="参考">参考</h2><p>《操作系统原理及应用（Linux）》王红</p><p><a href="https://www.gdcvault.com/play/1028734/Building-Night-City-The-Technology">Building Night City: The Technology of ‘Cyberpunk 2077’ - GDC 2021</a></p><p><a href="https://zhuanlan.zhihu.com/p/565768503">TLSF内存分配器</a></p><p><a href="https://blog.csdn.net/pwl999/article/details/118253758">TLSF内存分配原理</a></p><p><a href="https://stackoverflow.com/questions/30097648/difference-between-a-direct-mapped-cache-and-fully-associative-cache">组相联缓存机制</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数调用</title>
      <link href="/program/C++%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
      <url>/program/C++%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>C++函数调用</h1><p>C++支持两种函数调用方式，<code>__stdcall</code>和<code>__cdecl</code>，两者对栈帧（stack frame）的处理方式不同，<code>__stdcall</code>是由被调用函数来清理栈帧，<code>__cdecl</code>是由调用函数来清理栈帧。一旦混用，容易引发错误</p><blockquote><p>两者混用可能会导致栈帧没有被释放或者被连续释放两次</p></blockquote><h3 id="stack-frame">stack frame</h3><p>栈帧用于维护函数调用的上下文信息，在函数调用时，会在栈上分配一块内存，用于存储函数的参数、返回值、局部变量、调用者的栈指针等，函数返回后，栈帧会被销毁</p><h3 id="standard-call">standard call</h3><p><code>__stdcall</code>全称为standard call，是Pascal和Win32的默认调用方法，函数在调用时必须严格按照定义传递参数，参数从右向左入栈，在函数返回前执行出栈指令（retn x），清理栈帧</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// windef.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALLBACK   __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPI    __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPIV   __cdecl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APIENTRY   WINAPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APIPRIVATE  __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASCAL    __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cdecl _cdecl</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CDECL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CDECL _cdecl</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> __stdcall <span class="title">AddStdCall</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">AddStdCall</span>(<span class="number">5</span>, <span class="number">3</span>);        <span class="comment">// 使用stdcall调用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result using stdcall: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> __stdcall <span class="title">AddStdCall</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Declaration">C Declaration</h3><p><code>__cdecl</code>全称为C Declaration，是C/C++的缺省调用方法，该方法最大的特点是允许传入<strong>可变参数</strong>，函数返回后由调用者执行出栈指令（ret），清理栈帧</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> __cdecl <span class="title">SubtractCDecl</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">SubtractCDecl</span>(<span class="number">10</span>, <span class="number">4</span>);    <span class="comment">// 使用cdecl调用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result using cdecl: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">SubtractCDecl</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>extern的另一个作用是重新声明一个函数，如果我在另一个cpp中实现了一个函数/变量，却没有将对应的声明include到当前这个文件中，我可以使用extern重新声明这个函数，效果就跟include一样。思想和前向声明很像</p></blockquote><h3 id="封装">封装</h3><p>有的第三方库无可奈何地使用了<code>__stdcall</code>，而我们的项目使用的是<code>__cdecl</code>，这时候就需要对第三方库进行封装，以便能够正常调用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设第三方库提供的接口声明为以下形式（使用 __stdcall 调用约定）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> __stdcall <span class="title">ThirdPartyFunction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdPartyWrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CallFunction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ThirdPartyFunction</span>(a, b);    <span class="comment">// 调用第三方库函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = ThirdPartyWrapper::<span class="built_in">CallFunction</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result using third-party wrapper: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Windows函数调用约定">Windows函数调用约定</h3><blockquote><p>以<a href="https://learn.microsoft.com/zh-cn/cpp/build/x64-calling-convention?view=msvc-170">MSVC x64调用约定</a>为例</p></blockquote><p>x64 ABI使用四寄存器fast-call调用约定，在函数调用时将函数的参数存储在指定的寄存器中，参数和这些寄存器有着严格的对应关系。</p><ul><li>一个参数最多只能放在一个寄存器中</li><li>若一个参数的大小不是1、2、4、8字节，将会按引用传递</li></ul><blockquote><p>寄存器中整数右对齐，被调用方可以忽略寄存器中的高位数据，于是可以向下兼容（即1、2、4、8可以放进8字节的寄存器中）<br>为什么是8字节呢？因为8字节=64位，x64系统的寄存器大小为64位</p></blockquote><ul><li>整数参数使用RCX、RDX、R8、R9寄存器传递</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func1</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e, <span class="type">int</span> f);</span><br><span class="line"><span class="comment">// a in RCX, b in RDX, c in R8, d in R9, f then e pushed on stack</span></span><br></pre></td></tr></table></figure><ul><li>浮点参数使用XMM0-XMM3寄存器传递</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func2</span>(<span class="type">float</span> a, <span class="type">double</span> b, <span class="type">float</span> c, <span class="type">double</span> d, <span class="type">float</span> e, <span class="type">float</span> f);</span><br><span class="line"><span class="comment">// a in XMM0, b in XMM1, c in XMM2, d in XMM3, f then e pushed on stack</span></span><br></pre></td></tr></table></figure><p>整数和浮点数混合</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func3</span>(<span class="type">int</span> a, <span class="type">double</span> b, <span class="type">int</span> c, <span class="type">float</span> d, <span class="type">int</span> e, <span class="type">float</span> f);</span><br><span class="line"><span class="comment">// a in RCX, b in XMM1, c in R8, d in XMM3, f then e pushed on stack</span></span><br></pre></td></tr></table></figure><img src="/images/函数参数传递寄存器.png" class="lazyload" data-srcset="/images/函数参数传递寄存器.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="triangle" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文明6like</title>
      <link href="/game/%E6%96%87%E6%98%8E6like/"/>
      <url>/game/%E6%96%87%E6%98%8E6like/</url>
      
        <content type="html"><![CDATA[<h1>文明6like</h1><h2 id="4X游戏">4X游戏</h2><p>文明6是一个经典的历史类4x游戏</p><ul><li>e<strong>x</strong>plore（探索）</li><li>e<strong>x</strong>pand（扩张）</li><li>e<strong>x</strong>ploit（开发）</li><li>e<strong>x</strong>terminate（消灭）</li></ul><h2 id="文明6的体验">文明6的体验</h2><h3 id="游戏体验">游戏体验</h3><p>最近玩了几百小时的文明六，感觉意犹未尽，却又索然无味，想抽掉一些内容，自己做一个简易版的文明6，个人希望加强塔防、改良、贸易等元素，减少兵种操作、城市铺设。</p><p>我玩文明6，最让人兴奋的就是地块高额的产出（尤其是保护区单元格，太美丽了），我希望我的游戏也要着重地块产出和自肃</p><p>我玩文明6，最让人气愤的是AI起城墙，文明6的城墙等级几乎没用（历史上的城墙在不同时期有不同形态和意义），而城墙强度又过高（对远程和骑兵过于不友好），而且兵种和城墙间没有很好的联动，最近看了一些长城和棱堡的视频，感觉这谐内容很有意思</p><p>不过如果要做兵种和城墙这种微操，城市的数量不能太多，我打算将视角转化到城市，你拥有一个首都和少量卫星城市，从刀耕火种的营地，最后到世界级的城市</p><h3 id="感受文化">感受文化</h3><blockquote><p>参考<a href="https://www.bilibili.com/video/BV1Yr4y1G788/?spm_id_from=333.788&amp;vd_source=7cf90c391cc9c5398532df5ea93ccded">棱堡为什么消失</a>、</p></blockquote><p>文明6有一个目的是让玩家体验各个文明的特色和历史进程。通过玩文明6，我知道了蒙古除了擅长骑射外，还拥有一支庞大的重骑兵“怯薛歹”；我知道了长城除了据马、传信等功能外，还能掌控海关，在互市中实现剪刀差；我知道了马镫的出现使得骑兵成为战场上的大杀器，铁才是重骑兵生产需要的战略资源；我知道了火枪时代曾经有着排队枪毙的线列步兵，这个兵种让战争彻底平民化、综合国力化；诸如此类，数不胜数</p><p>我想让玩家体验的，其实是城墙的发展史</p><ol><li>远古城墙，是低矮的土墙，这些墙可以被人轻易翻过，但是无法让马越过，于是实现了拒马的作用</li><li>古典时期城墙变高，城墙上设有射击点，以增大攻城成本<ol><li>尤其是长城这类城墙，在军事上可以限制骑兵，可以逼迫攻城方带大型器械（对于游牧民族是很困难的），可以给中央反应时间，可以限制敌人行军路径（一般从哪里破城，劫掠后就从哪里出去，毕竟劫掠时不可能带着攻城器械），可以作为高速公路实现运兵（不用爬山了）；在经济上可以避免游牧劫掠，互市实现剪刀差，</li></ol></li><li>奥斯曼帝国时期，火药开始用于攻城，大炮对城墙的破坏力大大提高，此时（中世纪）城墙开始变矮变厚，此时城墙的拐角处往往会呈圆形突出，各个突出可以实现互相掩护，以降低射击死角</li></ol><p><img src="/images/%E4%B8%AD%E4%B8%96%E7%BA%AA%E5%9F%8E%E5%A2%99.png" class="lazyload" data-srcset="/images/%E4%B8%AD%E4%B8%96%E7%BA%AA%E5%9F%8E%E5%A2%99.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="中世纪城墙"></p><ol start="4"><li>文艺复兴时期，弹道学被发明，为了减少守军的射击死角，射击坡和棱堡出现了，拥有更大的控制区和更小的射击死角（但棱堡有些贵了）</li></ol><p><img src="/images/%E6%A3%B1%E5%A0%A1.png" class="lazyload" data-srcset="/images/%E6%A3%B1%E5%A0%A1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="棱堡"></p><p><img src="/images/%E6%A3%B1%E5%A0%A12.png" class="lazyload" data-srcset="/images/%E6%A3%B1%E5%A0%A12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="棱堡2"></p><ol start="6"><li>拿破仑时期发现城墙完全没有意义，因为法军会绕开坚城，直取首都，然后围点打援，于是在一战前，往往城市外面的山坡上设立一个个小的孤立要塞，敌人在攻城时这些要塞的大炮可以提供火力掩护，敌人在移动时也可以进行敌人探测和阻击，而且更<strong>便宜</strong></li></ol><p><img src="/images/%E8%A6%81%E5%A1%9E.png" class="lazyload" data-srcset="/images/%E8%A6%81%E5%A1%9E.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="要塞"></p><ol start="7"><li>南北战争时期，多边形城堡出现，除了射击坡外，一大特点是有地下隐藏火力点，敌人攻城时，除了受到正面的射击外，还会收到背后两侧的射击</li></ol><p><img src="/images/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A6%81%E5%A1%9E.png" class="lazyload" data-srcset="/images/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A6%81%E5%A1%9E.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="多边形要塞"></p><h2 id="我的游戏初设">我的游戏初设</h2><h3 id="游戏背景">游戏背景</h3><blockquote><p>有些类似动漫《异世界悠闲农家》</p></blockquote><p>玩家是从异世界穿越而来的勇者，能力是<strong>建造者</strong>。玩家出生在森林/雪山/海岛，这里离人类社会很远，充满了强大的魔物，主角的人物就是在出生点附近生活，建立城市，吸纳难民，开辟和其他友好部落的商路，抵御魔物的一轮轮进攻</p><h3 id="游戏目标">游戏目标</h3><p>军事胜利：击败魔王（魔王会在最后一轮进攻时出现，只要抵御所有伦次的进攻即可，不过也可以在探明魔王城后主动进攻）</p><h2 id="经济">经济</h2><h3 id="地块">地块</h3><p>游戏采用类似文明6的俯视角六边形地图，地块上绘制有地形和产出，每回合会产出对应数值</p><p>地块的产出有：</p><ul><li>粮食：1人口需要消耗1粮食，当粮食有剩余时，人口会缓慢增长</li><li></li></ul><h3 id="人口">人口</h3><p>游戏中的人口是纯概念，没有操作实体，可以锁在某个地块上</p><h2 id="科技">科技</h2><h2 id="军事">军事</h2><p>游戏中的军事单位有操作实体，类似于战旗游戏</p><p>军事单位有攻击力、生命值、移动力、等级经验等属性，攻击会消耗大量移动力，通常大部分单位一回合只能攻击一次</p><h3 id="兵种设置">兵种设置</h3><ul><li>剑士，近战单位，标准攻击力，标准移动力，兵种<strong>相邻会加力</strong></li><li>侦察兵，近战单位，拥有<strong>地图绘制能力</strong>，攻击力较弱，移动力较强，除非与敌人相邻，不然只能被其他侦察兵发现（类似于文明6中的潜艇）</li><li>弓箭手，远程单位，拥有攻击<strong>控制区</strong>，在控制区内的敌人会被减力减移动力，可以上城墙，攻击距离受地形影响</li><li>法师，远程攻城单位，拥有更强的攻击力，但<strong>无法移动攻击</strong>，能对城墙造成满额伤害</li><li>牧师，参考火焰纹章的治疗，消耗道具为一个单位<strong>回复生命值</strong></li><li>骑士，高移动力的近战单位，与敌人剑士相邻时，会<strong>消除敌人相邻加力</strong>（冲散队形）</li><li>天使，参考火焰纹章的天马，高移动力<strong>无视地形</strong>的单位，拥有地图绘制功能，并拥有更大的攻击范围（攻击方式类似于文明6的轰炸机），若攻击目标处于地方弓箭手的控制区内，会受伤。具有抗魔性。价格更高</li></ul><h4 id="控制区">控制区</h4><blockquote><p>目前是引入火力压制和火力支援的概念</p></blockquote><p>弓箭手周围区块会处于己方的控制区，使用计数法判定。每个我方弓箭手都会使得控制区内区块计数+1，每个敌方弓箭手会使计数-1</p><ul><li>若计数为负数，则处于敌方区域，我方减力、减移动力</li><li>若为正数，则处于我方区域，敌方减力、减移动力</li><li>若为0，则双方无影响</li></ul><h4 id="视野">视野</h4><blockquote><p>目的是让玩家使用侦察兵提前探路，避免陷入当前项羽进沼泽的窘境</p></blockquote><p>起初世界全是战争迷雾，普通单位仅有一格的视野，普通单位不能走进未探索地区（也就是说，把一个普通单位放在迷雾区内，会只有周围一圈的视野，且无论移动力多少，一回合只能走一个，但同时能获得新的视野）</p><blockquote><p>关于这个部分，我认为是结算依据是移动后周围六格是否有未探索的区域，若有，则失去所有移动力，刷新地图</p></blockquote><p>侦察单位的视野等同于移动力</p><h4 id="加力减力">加力减力</h4><h3 id="城防">城防</h3><ul><li>堡垒，城市外的防御塔，仅一格大小，可以驻扎一个单位，无法相邻建造，但可以用城墙相连</li><li>城墙</li><li>地堡，仅能被单侧攻击，却有三个攻击方向的建筑通常攻击方向朝向城市</li></ul>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用记录</title>
      <link href="/program/Git%E5%85%A5%E9%97%A8/"/>
      <url>/program/Git%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>Git 使用记录</h1><blockquote><p>记录一下平时使用Git的记录</p></blockquote><h3 id="为什么使用Git">为什么使用Git</h3><p>程序开发的第一步，就是做版本管理。频繁提交，可以便于环境恢复和Bug查找。分支开发，也能便于合作与多设备协同。配置Review规范，你还可以知道你的合作者在干什么，有效避免了因为开发者习惯能力差异导致的项目丑陋。配合CI的编译预检查，还能提高代码的稳健性。总之版本管理十分重要。</p><p>版本管理工具有很多，游戏开发由于拥有大量会频繁改动的二进制资源，于是常常使用SVN等工具，比如P4V。而引擎开发一般以代码为主，用Git管理，其中二进制文件（比如第三方库的超大号DLL）使用Git LFS管理</p><h3 id="Cherry-pick">Cherry pick</h3><p>常用于获取他人其他分支的某些改动，相较于Rebase，对于本地代码的破坏性更小，会保留commit信息</p><p>Cherry pick，摘樱桃，功能是将某个commit复制到当前分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Cherry pick 哈希值为8e8b...的commit</span></span><br><span class="line">git cherry-pick 8e8bd4a89063535cb91de56a57e3a1683927a3b1</span><br><span class="line"><span class="comment"># Cherry pick 哈希值从8e8b...到e652...的一系列连续的commit</span></span><br><span class="line">git cherry-pick e65275b5b2b71153ff08e865cd825e27b5d247b5^..8e8bd4a89063535cb91de56a57e3a1683927a3b1</span><br></pre></td></tr></table></figure><h3 id="设置别名">设置别名</h3><p>有时很多很常用的命令你感觉太长了，于是可以使用别名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置commit别名c，git c将等同于git commit</span></span><br><span class="line">git config --global alias.c commit</span><br><span class="line"><span class="comment"># 设置status别名s</span></span><br><span class="line">git config --global alias.s status</span><br></pre></td></tr></table></figure><h3 id="补丁">补丁</h3><p>常用于获取他人其他分支的某些改动，但并不会保存commit信息，你需要手动add、commit</p><h4 id="format-patch">format-patch</h4><p>获取上一次commit的补丁</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git format-patch -1</span><br></pre></td></tr></table></figure><p>获取某个commit的补丁</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git format-patch &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><p>获得某些commit的补丁</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git format-patch &lt;start-commit-hash&gt;..&lt;end-commit-hash&gt;</span><br></pre></td></tr></table></figure><h4 id="diff">diff</h4><p>差异，用于生成补丁文件（patch），补丁文件本身是个纯文本文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较branch1和2的最新提交间的差异，将差异保存在mypatch.patch文件中</span></span><br><span class="line">git diff branch1 branch2 &gt; mypatch.patch</span><br></pre></td></tr></table></figure><h4 id="apply">apply</h4><p>应用，用于应用补丁文件（patch），若出现冲突，会生成拒绝（reject）文件，你可以手动处理掉这些reject文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git apply xxx.ptach --reject</span><br></pre></td></tr></table></figure><h3 id="清理">清理</h3><p>手动进行垃圾回收，以释放本地存储空间</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git prune</span><br></pre></td></tr></table></figure><h3 id="网络443">网络443</h3><p>有的时候我们挂了梯子仍然连不上github服务器，报错</p><blockquote><p>fatal: unable to access ‘<a href="https://github.com/Reuben-Sun/ToolEngine.git/">https://github.com/Reuben-Sun/ToolEngine.git/</a>’: Failed to connect to <a href="http://github.com">github.com</a> port 443 after 21070 ms: Couldn’t connect to server</p></blockquote><p>此时我们可以先查看自己梯子的端口号，然后找到<code>.gitconfig</code>文件，添加代理设置（我这里以端口号为7890为例）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">user</span>]</span><br><span class="line"><span class="string">email</span> <span class="string">=</span> <span class="string">xxx@xxx.com</span></span><br><span class="line"><span class="string">name</span> <span class="string">=</span> <span class="string">xxx</span></span><br><span class="line">[<span class="string">http</span>]</span><br><span class="line"><span class="string">proxy</span> <span class="string">=</span> <span class="string">http://127.0.0.1:7890</span></span><br><span class="line">[<span class="string">https</span>]</span><br><span class="line"><span class="string">proxy</span> <span class="string">=</span> <span class="string">http://127.0.0.1:7890</span></span><br></pre></td></tr></table></figure><h3 id="ignore">ignore</h3><p>创建一个<code>.gitignore</code>文件，即可忽略部分文件，常用于ignore构建的二进制文件、临时文件、巨大的模型文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 忽略任何路径下的__pycache__文件夹</span><br><span class="line">**/__pycache__</span><br><span class="line"># 忽略build文件夹</span><br><span class="line">build</span><br><span class="line"># 忽略所有fbx后缀的文件</span><br><span class="line">*.fbx</span><br></pre></td></tr></table></figure><h3 id="LFS">LFS</h3><p>安装lfs</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git-lfs</span><br></pre></td></tr></table></figure><p>启用lfs</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><p>track某种文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git lfs track <span class="string">&quot;*.zip&quot;</span></span><br><span class="line">git lfs track <span class="string">&quot;*.mp4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="子模块">子模块</h3><p>在已有项目中添加子模块</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;</span><br></pre></td></tr></table></figure><p>克隆一个包含子模块的项目</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive &lt;仓库地址&gt;</span><br></pre></td></tr></table></figure><p>将一个已有的项目初始化子模块</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h3 id="tag">tag</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按时间排序显示tag</span></span><br><span class="line">git tag --<span class="built_in">sort</span>=creatordate</span><br><span class="line"><span class="comment"># checkout到某个tag</span></span><br><span class="line">git checkout &lt;tag name&gt;</span><br><span class="line"><span class="comment"># 基于某个tag创建一个新分支</span></span><br><span class="line">git checkout -b mybranch &lt;tag name&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity ECS 入门</title>
      <link href="/engine/UnityECS/"/>
      <url>/engine/UnityECS/</url>
      
        <content type="html"><![CDATA[<h1>Unity ECS 入门</h1><p>曾经待的项目使用了Unity ECS 0.5，那时候功能很不完善，几乎所有功能都从头写了一遍。现在Unity ECS 1.0发布了，有点失望。看了一圈感觉系统复杂性提高了很多，而且不能保证系统的稳定性（尤其是有错的代码编译），非常不适合独立游戏制作</p><h2 id="数据驱动">数据驱动</h2><blockquote><p>ECS的本质就是数据驱动的编程，随着守望先锋的爆火进入大家视野，结果现在守望2都凉了，Unity才把ECS端上来。。。</p></blockquote><h3 id="缓存友好">缓存友好</h3><blockquote><p><a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html">每一个程序员都应该知道的数字</a></p></blockquote><p>截至2020年，电脑访问数据的速度为</p><ul><li>L1缓存：1ns</li><li>分支预测错误：3ns</li><li>L2缓存：4ns</li><li>解/锁互斥锁：17ns</li><li>内存：100ns</li><li>固态硬盘随机读取：16,000ns</li><li>固态硬盘顺序读取1,000,000bytes：49,000ns</li><li>机械硬盘顺序读取1,000,000bytes：825,000ns</li></ul><img src="/images/程序员需要知道的数据.png" class="lazyload" data-srcset="/images/程序员需要知道的数据.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SSR噪点" style="zoom:50%;" /><p>我们发现缓存的访问速度远快于内存和硬盘，缓存友好的程序性能会更好</p><h4 id="OOP与DOP">OOP与DOP</h4><p>对于OOP（Object-Oriented Programming）来说，我们可能每次仅迭代对象的某一项属性，其他属性白白加载了，造成性能的浪费和缓存的不友好</p><p>而DOP（Data-Oriented Programming）的实体由多个纯数据组成，系统运行时收集并处理所需的数据，这些数据大多为密集的同质数据，缓存友好</p><h4 id="SOA">SOA</h4><blockquote><p>SOA不同于Unity ECS，放在这里用来抛砖引玉，便于理解数据驱动</p></blockquote><p>数据驱动有很多实现方式，比如SOA（Struct of Array），将原本同质的数据合并为数组。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AOS(Array of Struct)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Particle</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3 position;</span><br><span class="line">    Vector3 velocity;</span><br><span class="line">    Color color;</span><br><span class="line">    <span class="type">float</span> age;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; m_particles[N];</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SOA(Struct of Array)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Particles</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3 position[N];</span><br><span class="line">    Vector3 velocity[N];</span><br><span class="line">    Color color[N];</span><br><span class="line">    <span class="type">float</span> age[N];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; m_particles;</span><br></pre></td></tr></table></figure><ul><li>这种实现不需要为了对齐做padding即可完美对齐，能节省内存</li><li>可以使用SIMD（单指令多数据）加速读写</li></ul><blockquote><p>缓存对齐可以去看<a href="https://reubensun.com/math/Pro-TBB/?keyword=padding">TBB Padding</a>，可以使得两个相邻的数据位置更远，从而不出现在一个缓存行中，进而避免了<strong>假共享</strong>现象</p></blockquote><h3 id="易拓展">易拓展</h3><p>相较于面向对象，数据驱动更易拓展</p><h4 id="OOP的方案">OOP的方案</h4><p>对于面向对象的数据结构，如果要拓展一个新的字段，如果直接将数据放在类里面（不管这个字段会不会被用到），会增大对象大小，浪费内存，缓存不友好，最后导致系统越来越抗拒新的拓展</p><p>如果使用union，确实可以实现不同成员共享空间，省去了那些没有被用到的数据的大小。但需要我们预先决定哪些数据不会被同时使用，大幅提高了编程难度和出错率</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> dataType;   <span class="comment">// 用于标识数据类型</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> intValue;</span><br><span class="line">        <span class="type">float</span> floatValue;</span><br><span class="line">        <span class="type">char</span> stringValue[<span class="number">10</span>];</span><br><span class="line">    &#125; dataValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果使用哈希表，确实得到了弹性，但会产生成员进map的消耗</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    unordered_map&lt;Key, Variant&gt; kv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="SOA-Flexible-Table">SOA Flexible Table</h4><blockquote><p>个人感觉本质就是哈希表，使用起来很像处理JSON和XML</p></blockquote><p>运行时为table添加项，添加项时提供项的定义信息、初始值</p><p><img src="/images/FlexibleTable.png" class="lazyload" data-srcset="/images/FlexibleTable.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Flexible Table"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MetaTable meta;</span><br><span class="line"><span class="type">const</span> TypeID floatType = meta.<span class="built_in">AddType</span>(<span class="string">&quot;float&quot;</span>, <span class="number">4</span>, <span class="number">16</span>);</span><br><span class="line"><span class="type">const</span> AttributeID positionXAttribute = meta.<span class="built_in">AddAttribute</span>(<span class="string">&quot;positionX&quot;</span>, floatType, <span class="number">0.0f</span>);</span><br><span class="line"><span class="type">const</span> AttributeID positionYAttribute = meta.<span class="built_in">AddAttribute</span>(<span class="string">&quot;positionY&quot;</span>, floatType, <span class="number">0.0f</span>);</span><br><span class="line"><span class="type">const</span> AttributeID positionZAttribute = meta.<span class="built_in">AddAttribute</span>(<span class="string">&quot;positionZ&quot;</span>, floatType, <span class="number">0.0f</span>);</span><br><span class="line"><span class="type">const</span> AttributeID velocityXAttribute = meta.<span class="built_in">AddAttribute</span>(<span class="string">&quot;velocityX&quot;</span>, floatType, <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function">SOATable <span class="title">particles</span><span class="params">(meta)</span></span>;</span><br><span class="line">particles.<span class="built_in">ReserveRows</span>(N);</span><br><span class="line">particles.<span class="built_in">AppendRows</span>(N);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">&#123;</span><br><span class="line">    particles.<span class="built_in">SetValue</span>(i, positionXAttribute, ...);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GO与ECS">GO与ECS</h3><p>Unity的GO和ECS是对OOP和DOP的具体实现</p><p>传统的GO+Mono模式：场景中有大量的GO，他们拥有各自的脚本和组件，运行时遍历GO，按生命周期执行Mono脚本（一定是所有<code>OnEnable()</code>执行完后，再执行所有的<code>Start()</code>）</p><p>ECS模式，场景由Entity和System组成，这些Entity拥有纯数据的Component，而System负责收集其负责的Component，集中处理</p><p>能看出，ECS模式是数据密集型的，同类的数据集中存储，集中处理。而GO是一个相对完整独立的个体，每个GO都会处理自己的数据。</p><p>ECS缓存友好，适用于单指令多数据、并行、上下文切换等机制，于是在逻辑处理上会比GO强很多</p><h2 id="初始化">初始化</h2><h3 id="安装">安装</h3><p>之前0.5的时候，Unity ECS就一直藏在掖着，仿佛不肯用户发现安装一般，现在正式发售了，也没有放进包管理器里</p><ol><li>打开包管理器，点击按名字添加包</li><li>依次添加<code>com.unity.entities</code>和<code>com.unity.entities.graphics</code></li></ol><p><img src="/images/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.png" class="lazyload" data-srcset="/images/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="包管理器"></p><h3 id="打开快速Play">打开快速Play</h3><blockquote><p>真的很快</p></blockquote><p><img src="/images/%E8%BF%9B%E5%85%A5%E5%9C%BA%E6%99%AF%E8%AE%BE%E7%BD%AE.png" class="lazyload" data-srcset="/images/%E8%BF%9B%E5%85%A5%E5%9C%BA%E6%99%AF%E8%AE%BE%E7%BD%AE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="进入场景设置"></p><h3 id="打开Scene预览">打开Scene预览</h3><p>不开启这个，你运行时创建的Entity无法在Scene窗口查看</p><p><img src="/images/SceneView.png" class="lazyload" data-srcset="/images/SceneView.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SceneView"></p><h3 id="Rider">Rider</h3><blockquote><p>个人建议配合Rider2023的新UI使用啊，效率能大幅提高，而且还有DOTS类型模板</p></blockquote><img src="/images/RiderECS.png" class="lazyload" data-srcset="/images/RiderECS.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RiderECS" style="zoom:50%;" /><img src="/images/RiderECS2.png" class="lazyload" data-srcset="/images/RiderECS2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RiderECS2" style="zoom:50%;" /><p>不过一定要关闭自动保存，不然一切屏就报错</p><p><img src="/images/%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98.png" class="lazyload" data-srcset="/images/%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="关闭自动保存"></p><h2 id="入门">入门</h2><h3 id="SubScene">SubScene</h3><blockquote><p>这个SubScene很久以前就有，但以前我们可以通过主动加载Prefab的方式实现流式加载，于是很少用这个SubScene，但现在好像把Prefab转Entity这个工作流取消了？</p></blockquote><p>在Hierarchy节目按右键New Sub Scene即可创建，你可以像操作GO一样在SubScene中添加物体，会自动转化为Entity</p><p><img src="/images/SubScene.png" class="lazyload" data-srcset="/images/SubScene.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SubScene"></p><p>SubScene右侧有一个Checkbox，这个是用来加载/卸载场景的，SubScene最初的用法就是用来流式加载的</p><h3 id="Entity">Entity</h3><blockquote><p>这属实优化了不少</p></blockquote><p>现在Entity的制作流程极其简答，按GO的方式制作，然后会自动转化为Entity，为了方便你编辑，还提供了两套窗口，通过按右上角的圆圈，即可调整窗口</p><p>传统的GO界面（Authoring）</p><img src="/images/GO界面.png" class="lazyload" data-srcset="/images/GO界面.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GO界面" style="zoom:50%;" /><p>Entity界面（Runtime）</p><img src="/images/Entity界面.png" class="lazyload" data-srcset="/images/Entity界面.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Entity界面" style="zoom:50%;" /><h3 id="Component">Component</h3><blockquote><p>还是一如既往的脱裤子放屁，突出一个意义不明</p></blockquote><h4 id="IComponentData">IComponentData</h4><p>纯数据结构体</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> CubeProperties: IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector2 FieldSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CubeCount;</span><br><span class="line">    <span class="keyword">public</span> Entity CubePrefab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> CubeRandom : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Random Value;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MonoBehaviour">MonoBehaviour</h4><p><code>IComponentData</code>的数据无法在Editor面板上显示（why？），需要使用Mono封装传递（what？）</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeMono</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector2 FieldSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CubeCount;</span><br><span class="line">    <span class="keyword">public</span> GameObject CubePrefab;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">uint</span> RandomSeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeBaker</span> : <span class="title">Baker</span>&lt;<span class="title">CubeMono</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bake</span>(<span class="params">CubeMono authoring</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 为当前Entity添加Component，可以添加多个</span></span><br><span class="line">        AddComponent(<span class="keyword">new</span> CubeProperties</span><br><span class="line">        &#123;</span><br><span class="line">            FieldSize = authoring.FieldSize,</span><br><span class="line">            CubeCount = authoring.CubeCount,   </span><br><span class="line">            CubePrefab = GetEntity(authoring.CubePrefab)<span class="comment">// 这里做了Prefab转Entity</span></span><br><span class="line">        &#125;);</span><br><span class="line">        AddComponent(<span class="keyword">new</span> CubeRandom</span><br><span class="line">        &#123;</span><br><span class="line">            Value = Random.CreateFromIndex(authoring.RandomSeed)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将Mono脚本挂在Entity上，切换为Runtime界面，就能看到Component信息了</p><p><img src="/images/CubeProp.png" class="lazyload" data-srcset="/images/CubeProp.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CubeProp"></p><h3 id="Aspect">Aspect</h3><p>这次ECS还新增了一个<code>IAspect</code>，看上去好像是负责收集Component数据的转换层，可以将多个Component的数据结合在一起，方便System调用</p><blockquote><p>An aspect is an object-like wrapper that you can use to group together a subset of an entity’s components into a single C# struct</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ECS.Study</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">partial</span> <span class="keyword">struct</span> CubeAspect : IAspect</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">readonly</span> Entity Entity;</span><br><span class="line"><span class="comment">// TransformAspect 已经被取消</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> RefRW&lt;LocalTransform&gt; _localTransform; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> RefRO&lt;CubeProperties&gt; _cubeProperties;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> RefRW&lt;CubeRandom&gt; _cubeRandom;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> RefRW&lt;SphereSpawnPoints&gt; _sphereSpawnPoints;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> CubeCount =&gt; _cubeProperties.ValueRO.CubeCount;</span><br><span class="line">        <span class="keyword">public</span> Entity CubePrefab =&gt; _cubeProperties.ValueRO.CubePrefab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中心创建一个球，球内将不会创建Cube</span></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> SphereCreate</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SphereSpawnPointsIsCreated</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _sphereSpawnPoints.ValueRO.Value.IsCreated &amp;&amp; SphereSpawnPointsCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> SphereSpawnPointsCount =&gt; _sphereSpawnPoints.ValueRO.Value.Value.Value.Length;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 生成Cube的位置和朝向</span></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> Transform</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LocalTransform <span class="title">GetRandomCubeTransform</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LocalTransform</span><br><span class="line">            &#123;</span><br><span class="line">                Position = GetRandomPosition(),</span><br><span class="line">                Rotation = GetRandomRotation(),</span><br><span class="line">                Scale = GetRandomScale(<span class="number">0.5f</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> float3 <span class="title">GetRandomPosition</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            float3 randomPosition;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                randomPosition = _cubeRandom.ValueRW.Value.NextFloat3(MinCorner, MaxCorner);</span><br><span class="line">            &#125; <span class="keyword">while</span> (math.distancesq(_localTransform.ValueRO.Position, randomPosition) &lt;= CUBE_SAFETY_RADIUS_SQ);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> randomPosition;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> float3 HalfDimension =&gt; <span class="keyword">new</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            x = _cubeProperties.ValueRO.FieldSize.x * <span class="number">0.5f</span>,</span><br><span class="line">            y = <span class="number">0f</span>,</span><br><span class="line">            z = _cubeProperties.ValueRO.FieldSize.y * <span class="number">0.5f</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> float3 MinCorner =&gt; _localTransform.ValueRO.Position - HalfDimension;</span><br><span class="line">        <span class="keyword">private</span> float3 MaxCorner =&gt; _localTransform.ValueRO.Position + HalfDimension;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">float</span> CUBE_SAFETY_RADIUS_SQ = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> quaternion <span class="title">GetRandomRotation</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> quaternion.RotateY(_cubeRandom.ValueRW.Value.NextFloat(<span class="number">-0.25f</span>, <span class="number">0.25f</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="built_in">float</span> <span class="title">GetRandomScale</span>(<span class="params"><span class="built_in">float</span> min</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _cubeRandom.ValueRW.Value.NextFloat(min, <span class="number">1f</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> float2 <span class="title">GetRandomOffset</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _cubeRandom.ValueRW.Value.NextFloat2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Aspect.png" class="lazyload" data-srcset="/images/Aspect.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Aspect"></p><h3 id="System">System</h3><blockquote><p>要说System最大的改动，我感觉就是这东西好建不好删，这东西只要你写了，也不需要挂载，就会直接全局生效，我开着Editor删文件会报DLL被占用，也不好修改，没写好编译就会报错，然后Rider呼吁我Revert掉</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置初始化顺序，能在System界面看到</span></span><br><span class="line">[<span class="meta">UpdateInGroup(typeof(InitializationSystemGroup))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">struct</span> CubeGenerateSystem : ISystem</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCreate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 当场景中包含至少一个 CubeProperties 组件时，启用 Update</span></span><br><span class="line">        state.RequireForUpdate&lt;CubeProperties&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">state.Enabled = <span class="literal">false</span>;  <span class="comment">// 禁用 Update</span></span><br><span class="line">        <span class="keyword">var</span> cubeEntity = SystemAPI.GetSingletonEntity&lt;CubeProperties&gt;();</span><br><span class="line">        <span class="keyword">var</span> cube = SystemAPI.GetAspect&lt;CubeAspect&gt;(cubeEntity);</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> BlobBuilder(Allocator.Temp);</span><br><span class="line">        <span class="keyword">ref</span> <span class="keyword">var</span> spawnPoints = <span class="keyword">ref</span> builder.ConstructRoot&lt;SphereSpawnPointsBlob&gt;();</span><br><span class="line">        <span class="keyword">var</span> arrayBuilder = builder.Allocate(<span class="keyword">ref</span> spawnPoints.Value, cube.CubeCount);</span><br><span class="line">        <span class="keyword">var</span> spawnOffset = <span class="keyword">new</span> float3(<span class="number">0f</span>, <span class="number">-2f</span>, <span class="number">1f</span>);</span><br><span class="line">        <span class="comment">// 创建命令缓冲区</span></span><br><span class="line">        <span class="keyword">var</span> cmd = <span class="keyword">new</span> EntityCommandBuffer(Allocator.Temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cube.CubeCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将命令添加至命令缓冲区</span></span><br><span class="line">            <span class="keyword">var</span> newCube = cmd.Instantiate(cube.CubePrefab);</span><br><span class="line">            <span class="keyword">var</span> newTransform = cube.GetRandomCubeTransform();</span><br><span class="line">            cmd.SetComponent(newCube, newTransform);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> newSpawnPoint = newTransform.Position + spawnOffset;</span><br><span class="line">            arrayBuilder[i] = newSpawnPoint;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> blobAsset = builder.CreateBlobAssetReference&lt;SphereSpawnPointsBlob&gt;(Allocator.Persistent);</span><br><span class="line">        cmd.SetComponent(cubeEntity, <span class="keyword">new</span> SphereSpawnPoints&#123; Value = blobAsset &#125;);</span><br><span class="line">        builder.Dispose();</span><br><span class="line"></span><br><span class="line">        cmd.Playback(state.EntityManager);    <span class="comment">// 执行命令 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SphereSpawnPoints : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> BlobAssetReference&lt;SphereSpawnPointsBlob&gt; Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SphereSpawnPointsBlob</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> BlobArray&lt;float3&gt; Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/System.png" class="lazyload" data-srcset="/images/System.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="System"></p><p>此时启动游戏，会发现生成了一百个Cube，他们分布在一个正方形内部圆外部，转向随机</p><p><img src="/images/ECS-Scene2.png" class="lazyload" data-srcset="/images/ECS-Scene2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ECS-Scene2"></p><h3 id="Job">Job</h3><blockquote><p>用起来很像一个函数对象</p></blockquote><p>Job是从System发出的任务</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">struct</span> DoSomeJob: IJobEntity</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这两个public的成员用来传递参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> DeltaTime;</span><br><span class="line">    <span class="keyword">public</span> EntityCommandBuffer ECS;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">CubeAspect cubeAspect</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>System通过创建对象来调用这个任务</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> deltaTime = SystemAPI.Time.DeltaTime;</span><br><span class="line">    <span class="keyword">var</span> ecbSingleton = SystemAPI.GetSingleton&lt;BeginInitializationEntityCommandBufferSystem.Singleton&gt;();</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">new</span> DoSomeJob</span><br><span class="line">    &#123;</span><br><span class="line">        DeltaTime = deltaTime,</span><br><span class="line">        ECB = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged)</span><br><span class="line">    &#125;.Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SystemBase">SystemBase</h3><p>系统交互相关的系统</p><p>下面是一个相机盯着中心看，并做旋转的示例</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">CameraControllerSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> cameraSigleton = CameraSingleton.Instance;</span><br><span class="line">        <span class="keyword">if</span>(cameraSigleton == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">float</span> positionFactor =(<span class="built_in">float</span>) SystemAPI.Time.ElapsedTime * cameraSigleton.Speed;</span><br><span class="line">        <span class="built_in">float</span> scale = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> radius = cameraSigleton.RadiusAtScale(scale);</span><br><span class="line">        <span class="keyword">var</span> height = cameraSigleton.HeightAtScale(scale);</span><br><span class="line">        cameraSigleton.transform.position = <span class="keyword">new</span> UnityEngine.Vector3</span><br><span class="line">        &#123;</span><br><span class="line">            x = Mathf.Cos(positionFactor) * radius,</span><br><span class="line">            y = height,</span><br><span class="line">            z = Mathf.Sin(positionFactor) * radius</span><br><span class="line">        &#125;;</span><br><span class="line">        cameraSigleton.transform.LookAt(Vector3.zero, Vector3.up);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个代码要挂在场景中（建议挂在相机上）</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraSingleton</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CameraSingleton Instance &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Instance != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> startRadius;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> endRadius;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> startHeight;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> endHeight;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">RadiusAtScale</span>(<span class="params"><span class="built_in">float</span> scale</span>)</span> =&gt; Mathf.Lerp(startRadius, endRadius, <span class="number">1</span> - scale);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">HeightAtScale</span>(<span class="params"><span class="built_in">float</span> scale</span>)</span> =&gt; Mathf.Lerp(startHeight, endHeight, <span class="number">1</span> - scale);</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Speed =&gt; speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锐评">锐评</h2><p>就这个简单的小demo，我的编辑器就卡死崩溃了多次，尤其是当我保存编译一个有报错的System文件时，几乎必然要用任务管理器杀项目，太不稳定了</p><p>而且这个ECS不仅跟Mono差异巨大，还和0.5版本的ECS差异也巨大，所有人都对这个系统不熟，官方也没提供一些特别好的适普的教程</p><p>如果是用Unity做小项目，完全不需要ECS，你的性能瓶颈大概率是渲染和资产。把粒子特效砍一砍，查看一下场景中有没有面数惊人的模型，模型是否有LOD，是否针对设备做了渲染分级，控制场景中实时光源数量，砍掉一些昂贵而作用不明显的渲染feature（比如基于快速傅里叶的水，比如高精度的布料、破坏仿真）</p><p>此外我诚心建议Unity把重点放在Editor上，实现一套<strong>能用</strong>的地表编辑器、动画编辑器、资产编辑器、大世界分块编辑器。引擎好不好用，关键靠Editor，你就算架构设计的再好，再适合客制化，小公司没精力没技术魔改，大公司不稀罕你的原生功能，甚至很多公司跟你闹掰转UE了，你在大型项目中有半点优势吗？</p><h2 id="参考">参考</h2><p><a href="https://www.youtube.com/watch?v=IO6_6Y_YUdE">https://www.youtube.com/watch?v=IO6_6Y_YUdE</a></p><p><a href="https://www.tmg.dev/tuts/zombieupdate/">https://www.tmg.dev/tuts/zombieupdate/</a></p><p><a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html</a></p><p>《为实现极限性能的面向数据编程范式》叶劲峰 GDC 2005</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> ECS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity小球移动</title>
      <link href="/game/Catlike%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A8/"/>
      <url>/game/Catlike%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1>Unity小球移动</h1><blockquote><p>摘自<a href="https://catlikecoding.com/unity/tutorials/movement/">Catlike的Movement Tutorial</a></p></blockquote><h2 id="小球移动">小球移动</h2><h3 id="创建小球">创建小球</h3><blockquote><p>使用Input System包，在Package Manager中Unity包搜索即可</p></blockquote><p>创建Input Action资产</p><p><img src="/images/inputAction.gif" class="lazyload" data-srcset="/images/inputAction.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="inputAction"></p><p>创建小球，包含拖尾渲染器、Player Input组件、脚本<code>SphereMovement.cs</code></p><p><img src="/images/%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A8.png" class="lazyload" data-srcset="/images/%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="小球移动"></p><h3 id="移动脚本">移动脚本</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SphereMovement</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">FormerlySerializedAs(<span class="string">&quot;movementSpeed&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;Movement Setting&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField, Range(0f, 10f)</span>] <span class="keyword">private</span> <span class="built_in">float</span> maxSpeed = <span class="number">5f</span>;</span><br><span class="line">    [<span class="meta">SerializeField, Range(0f, 100f)</span>] <span class="keyword">private</span> <span class="built_in">float</span> maxAcceleration = <span class="number">10f</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] Rect allowedArea = <span class="keyword">new</span> Rect(<span class="number">-5f</span>, <span class="number">-5f</span>, <span class="number">10f</span>, <span class="number">10f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 Velocity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> PlayerInput _input;</span><br><span class="line">    <span class="keyword">private</span> Vector2 _moveInput;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _input = GetComponent&lt;PlayerInput&gt;();</span><br><span class="line">        Velocity = Vector3.zero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _moveInput = _input.actions[<span class="string">&quot;Move&quot;</span>].ReadValue&lt;Vector2&gt;();</span><br><span class="line">        <span class="comment">// 根据输入得到预期速度</span></span><br><span class="line">        Vector3 desiredVelocity = <span class="keyword">new</span> Vector3(_moveInput.x, <span class="number">0</span>, _moveInput.y) * maxSpeed;</span><br><span class="line">        <span class="comment">// 当前时间片速度的最大变化量</span></span><br><span class="line">        <span class="built_in">float</span> maxSpeedChange = maxAcceleration * Time.deltaTime;</span><br><span class="line">        <span class="comment">// |target - current| &lt;= maxDelta ? target : current + maxDelta</span></span><br><span class="line">        Velocity.x = Mathf.MoveTowards(Velocity.x, desiredVelocity.x, maxSpeedChange);</span><br><span class="line">        Velocity.z = Mathf.MoveTowards(Velocity.z, desiredVelocity.z, maxSpeedChange);</span><br><span class="line">        <span class="comment">// 新速度在当前时间片的位移</span></span><br><span class="line">        Vector3 displacement = Velocity * Time.deltaTime;</span><br><span class="line">        <span class="comment">// 判断新位置是否越界</span></span><br><span class="line">        Vector3 newPosition = transform.localPosition + displacement;</span><br><span class="line">        <span class="keyword">if</span> (newPosition.x &lt; allowedArea.xMin) &#123;</span><br><span class="line">            newPosition.x = allowedArea.xMin;</span><br><span class="line">            Velocity.x = <span class="number">0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newPosition.x &gt; allowedArea.xMax) &#123;</span><br><span class="line">            newPosition.x = allowedArea.xMax;</span><br><span class="line">            Velocity.x = <span class="number">0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newPosition.z &lt; allowedArea.yMin) &#123;</span><br><span class="line">            newPosition.z = allowedArea.yMin;</span><br><span class="line">            Velocity.z = <span class="number">0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newPosition.z &gt; allowedArea.yMax) &#123;</span><br><span class="line">            newPosition.z = allowedArea.yMax;</span><br><span class="line">            Velocity.z = <span class="number">0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改位置</span></span><br><span class="line">        transform.localPosition = newPosition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A81.gif" class="lazyload" data-srcset="/images/%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A81.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="小球移动1"></p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blender使用笔记</title>
      <link href="/dcc/blender%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/dcc/blender%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>Blender使用笔记</h1><h2 id="建模">建模</h2><h3 id="移动模型">移动模型</h3><blockquote><p>快捷键G</p></blockquote><h3 id="网格合并">网格合并</h3><p>选中模型，按快捷键<code>ctrl+J</code></p><h3 id="网格按材质切分">网格按材质切分</h3><ol><li>选中模型</li><li>进入Edit Mode</li><li>Mesh——Separate——By Material</li></ol><h3 id="Modify">Modify</h3><h4 id="布尔建模">布尔建模</h4><p>Object Mode——选中物体——Add Modifier——Boolean——Apply</p><p>有Difference、Union等选择</p><h4 id="曲面细分">曲面细分</h4><p>如果要制作圆弧形模型，可以先创建一些整N边形，然后添加Modifier曲面细分（注意要在Object Mode）</p><h4 id="Remesh">Remesh</h4><p>一些模型的拓扑非常糟糕，可以用Remesh进行重新拓扑，不过这对模型的破坏非常严重</p><p>Object Mode——选中物体——Add Modifier——Remesh——Apply</p><h4 id="减面">减面</h4><p>减面是一个非常普遍的需求</p><p>Object Mode——选中物体——Add Modifier——Decimate——Apply</p><h3 id="模型添加材质">模型添加材质</h3><img src="/images/模型材质.png" class="lazyload" data-srcset="/images/模型材质.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="模型材质" style="zoom:50%;" /><h4 id="吸附">吸附</h4><p>Object Mode——选中物体——Add Modifier——Shrinkwrap——选择Target——选择顶点组——Apply</p><p>如果不选择顶点组，就会整个模型全部吸附</p><h3 id="UV">UV</h3><h4 id="UV接缝">UV接缝</h4><p>在自动展开前，先选中面，Mark Seam（会有红色的线）</p><blockquote><p>比如一个圆柱，可以把环形切一下，然后在竖边切一条</p></blockquote><h4 id="自动展UV2">自动展UV2</h4><p>点击Mesh，在Data处添加UV Maps</p><p><img src="/images/%E6%B7%BB%E5%8A%A0uv%E9%9B%86.png" class="lazyload" data-srcset="/images/%E6%B7%BB%E5%8A%A0uv%E9%9B%86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="添加uv集"></p><p>选择要修改的uvmap（看不见的话向右拉）</p><p><img src="/images/%E9%80%89%E6%8B%A9uvmap.png" class="lazyload" data-srcset="/images/%E9%80%89%E6%8B%A9uvmap.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="选择uvmap"></p><p>点击UV Editor——按Table开启编辑模式——全选模型——设置Select Mode为面——对模型按右键——UV Unwrap Faces——Smart UV Project</p><p><img src="/images/%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80UV.png" class="lazyload" data-srcset="/images/%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80UV.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="自动展开UV"></p><h3 id="左侧栏工具">左侧栏工具</h3><h4 id="斜边">斜边</h4><blockquote><p>快捷键Ctrl+B</p></blockquote><p>进入Edit Mode——选择边——Edge——Bevel Edges——拖动鼠标</p><h4 id="抬升面">抬升面</h4><p>渐入Edit Mode——选中面——Shrink/Fatten（在左侧栏）</p><h4 id="环切">环切</h4><blockquote><p>快捷键Ctrl+R</p></blockquote><h4 id="插入面">插入面</h4><blockquote><p>快捷键 I，可以在一个圆面里切一个小圆</p></blockquote><p>进入Edit Mode——选择面——Inset Face——拖动鼠标</p><h4 id="拓展区域">拓展区域</h4><blockquote><p>快捷键 E，可以选中一个圈后复制一份，然后缩放、拖拽</p></blockquote><h3 id="选中一圈边">选中一圈边</h3><blockquote><p>按住shift alt后用鼠标点击一条边</p></blockquote><p>进入Edit Mode——选择一条边——Select——Select Loops——Edge Loops</p><h3 id="点吸附">点吸附</h3><blockquote><p>将一个点吸附到另一个点上，可以实现填补三角形的作用</p></blockquote><p>进入Edit Mode——选择两个点——按M——选择末端点</p><h3 id="桥接面">桥接面</h3><p>进入Edit Mode——选择两条边——Edge——Bridge Edge Loops</p><h3 id="Cursor">Cursor</h3><p>游标，一个有红白相间的圆，可以用于控制旋转、缩放中心，也可以指定新添加物体的位置</p><h4 id="设置游标">设置游标</h4><p>Mesh——Snap——Cursor to Selected</p><h4 id="使用游标为物体控制中心">使用游标为物体控制中心</h4><p>选中物体——Object——Set Origin——Origin to 3D Cursor</p><h3 id="吸附-2">吸附</h3><p>让一个物体按规则吸附在其他物体上</p><p><img src="/images/snap.jpeg" class="lazyload" data-srcset="/images/snap.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="snap"></p><h3 id="顶点组">顶点组</h3><p>在Vertex Group中新建组，选择顶点，设置权重，Assign到组中</p><h2 id="PCG">PCG</h2><p>PCG的核心是几何节点</p><h2 id="vrm">vrm</h2><blockquote><p>一组包含blendshape的模型</p></blockquote><p>最近在找带有脸部Blendshape的角色模型，尤其是使用了苹果ARKit标准，于是我发现了很多vrm模型</p><p>Blender不原生支持vrm模型，于是需要下一个插件</p><p><a href="https://github.com/saturday06/VRM-Addon-for-Blender">VRM Add on</a></p><p>安装后直接import模型</p><h3 id="导出到Unity">导出到Unity</h3><p>之前遇到一个问题，vrm模型导出fbx再导入Unity，却在Skin mesh renderer中看不到Blendshape</p><p>解决方案：在Blender中删掉多余的Modify，剩下Armature，再重新导出</p><p><img src="/images/%E5%88%A0%E9%99%A4modifier.png" class="lazyload" data-srcset="/images/%E5%88%A0%E9%99%A4modifier.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="删除modifier"></p><h2 id="MMD">MMD</h2><h3 id="安装">安装</h3><blockquote><p><a href="https://github.com/UuuNyaa/blender_mmd_tools/releases">blender_mmd_tools插件</a>下载地址</p></blockquote><p><img src="/images/blenderMMD1.jpg" class="lazyload" data-srcset="/images/blenderMMD1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blenderMMD1"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Edit &gt; Perferences &gt; Add-ons &gt; Install &gt; 选择第二步下载的压缩包</span><br></pre></td></tr></table></figure><ol start="4"><li>激活插件，找到导入的插件，点亮左边的checkbox即可</li></ol><p><img src="/images/blenderMMD2.jpg" class="lazyload" data-srcset="/images/blenderMMD2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blenderMMD2"></p><ol start="5"><li>当你看到如下内容，说明安装成功（这个小箭头确实不明显，容易找不到）</li></ol><p><img src="/images/blenderMMD3.jpg" class="lazyload" data-srcset="/images/blenderMMD3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blenderMMD3"></p><ol start="6"><li>点击下图的Import即可导入模型和动画，在mmd面板可以导出mmd信息，使用blender的File可以导出fbx模型，后续在Unity、AccuRog软件使用</li></ol><p><img src="/images/blenderMMD4.jpg" class="lazyload" data-srcset="/images/blenderMMD4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blenderMMD4"></p><h3 id="关闭IK">关闭IK</h3><p>有时我们发现MMD角色的腿不动，很有可能是因为定位到一个非常远的IK，关掉即可（变为灰色）</p><p><img src="/images/mmd_ik.jpeg" class="lazyload" data-srcset="/images/mmd_ik.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="mmd_ik"></p><h3 id="渲染视频">渲染视频</h3><h4 id="调整camera位置">调整camera位置</h4><p>使用选择的相机为View，这样可以进入相机视角</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择一个相机——View——Cameras——Activate Camera</span><br></pre></td></tr></table></figure><p>再次执行可以恢复自由相机</p><p>进入相机视角后，可以打开右侧面板（N），勾选View——View Lock——Camera to View，就可以很方便地调整相机视角</p><h4 id="调整输出">调整输出</h4><p>设置分辨率、Frame Rate、将渲染结果为FFmpeg Video，Encoding为MPEG-4就能输出mp4视频</p><p><img src="/images/blender%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91.jpeg" class="lazyload" data-srcset="/images/blender%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blender保存视频"></p><h4 id="渲染动画">渲染动画</h4><p>播放Frame Range的动画，并保存相机渲染结果为视频</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Render——Render Animation</span><br></pre></td></tr></table></figure><h2 id="Auto-Rig-Pro">Auto Rig Pro</h2><p>插件购买地址<a href="https://blendermarket.com/products/auto-rig-pro">Auto Rig Pro</a>，脚本开发建议使用bpy==3.6</p><h3 id="自动棒骨">自动棒骨</h3><blockquote><p>Auto Rig Pro可以绑定生成控制器，便于手动制作动画。如果单纯为了自动绑定人型骨骼，比如MMD2FBX，更适合AccuRig</p></blockquote><ol><li>准备模型</li></ol><p><img src="/images/%E5%87%86%E5%A4%87%E6%A8%A1%E5%9E%8B.png" class="lazyload" data-srcset="/images/%E5%87%86%E5%A4%87%E6%A8%A1%E5%9E%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="准备模型"></p><ol start="2"><li>Smart模型</li></ol><p><img src="/images/SmartRig.png" class="lazyload" data-srcset="/images/SmartRig.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SmartRig"></p><ol start="3"><li>添加点</li></ol><p><img src="/images/%E6%B7%BB%E5%8A%A0%E8%84%96%E5%AD%90.png" class="lazyload" data-srcset="/images/%E6%B7%BB%E5%8A%A0%E8%84%96%E5%AD%90.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="添加脖子"></p><p><img src="/images/%E6%B7%BB%E5%8A%A0%E7%82%B9.png" class="lazyload" data-srcset="/images/%E6%B7%BB%E5%8A%A0%E7%82%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="添加点"></p><ol start="4"><li>点击GO！完成</li></ol><p><img src="/images/Go.png" class="lazyload" data-srcset="/images/Go.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Go"></p><p><img src="/images/Rig%E6%95%88%E6%9E%9C.png" class="lazyload" data-srcset="/images/Rig%E6%95%88%E6%9E%9C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Rig效果"></p><ol start="5"><li>点击Match to Rig</li></ol><p><img src="/images/Match2Rig.png" class="lazyload" data-srcset="/images/Match2Rig.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Match2Rig"></p><ol start="6"><li>进入Edit模式，点击Mesh，点击Bind</li></ol><p><img src="/images/Bind.png" class="lazyload" data-srcset="/images/Bind.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Bind"></p><h3 id="模型导出">模型导出</h3><p>导出为Unity能使用的骨骼模型</p><p><img src="/images/%E5%AF%BC%E5%87%BAfbx.png" class="lazyload" data-srcset="/images/%E5%AF%BC%E5%87%BAfbx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="导出fbx"></p><h3 id="Remap动画">Remap动画</h3><p>将动画Remap到骨架上，是的Target骨架播放Source骨架的动画</p><blockquote><p>如果你没有remap.bmap，那么你需要在Object Mode同时选择动画骨架和模型骨架，进入Pose Mode，依次填写Target Bones内容，制作完成后可以Export bmap，以便后续使用</p></blockquote><p><img src="/images/%E5%8A%A8%E7%94%BBRemap.jpeg" class="lazyload" data-srcset="/images/%E5%8A%A8%E7%94%BBRemap.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="动画Remap"></p><p>如果原始动画的初始状态和目标模型的初始状态不同，比如一个是A-Pose，一个是T-Pose，我们需要使用第6步，依次点击动画骨架，点击Copy Selected Bones Rotation，即可将动画的初始姿态转为目标模型的初始姿态</p><p><img src="/images/copy_bone_rot.jpeg" class="lazyload" data-srcset="/images/copy_bone_rot.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="copy_bone_rot"></p><h2 id="脚本">脚本</h2><p><a href="https://zhuanlan.zhihu.com/p/525475118">Blender Python 简易参考</a></p><p>指Python bpy脚本，可以在Blender中使用，也可以在Python中作为一个Headless库使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install bpy</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">pip install bpy==4.0.0 --extra-index-url https://download.blender.org/pypi/</span><br></pre></td></tr></table></figure><blockquote><p>Windows和Linux下bpy版本不同，Windows下python3.11对应bpy==4.3</p></blockquote><h3 id="脚本类型">脚本类型</h3><p>blender脚本有很多种：</p><ul><li>在blender Scripting中使用</li><li>作为插件安装</li><li>python直接import bpy</li><li>blenderproc</li></ul><h4 id="import-bpy">import bpy</h4><p>脚本<code>test.py</code>，无需打开blender，可以在linux下使用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bpy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除场景</span></span><br><span class="line">bpy.ops.<span class="built_in">object</span>.select_all(action=<span class="string">&#x27;SELECT&#x27;</span>)</span><br><span class="line">bpy.ops.<span class="built_in">object</span>.delete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 模型</span></span><br><span class="line">bpy.ops.wm.obj_import(filepath=args.input_mesh)</span><br></pre></td></tr></table></figure><p>使用方式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python test.py</span><br></pre></td></tr></table></figure><h4 id="blenderproc">blenderproc</h4><p>也无需打开blender，可在linux使用，还能使用一些blender提供的库，如<code>bmesh</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> blenderproc <span class="keyword">as</span> bproc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mathutils <span class="keyword">import</span> Vector</span><br><span class="line"><span class="keyword">import</span> bpy, bmesh</span><br><span class="line"><span class="keyword">from</span> bpy <span class="keyword">import</span> context</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;--input_mesh&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--save_type&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;slice&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">bproc.init()</span><br><span class="line"></span><br><span class="line"><span class="comment"># bounding box helper methods</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bbox</span>(<span class="params">ob</span>):</span><br><span class="line">    <span class="keyword">return</span> (Vector(b) <span class="keyword">for</span> b <span class="keyword">in</span> ob.bound_box)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bbox_center</span>(<span class="params">ob</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(bbox(ob), Vector()) / <span class="number">8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bbox_axes</span>(<span class="params">ob</span>):</span><br><span class="line">    bb = <span class="built_in">list</span>(bbox(ob))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>(bb[i] <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slice</span>(<span class="params">bm, start, end, segments</span>):</span><br><span class="line">    <span class="keyword">if</span> segments == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">geom</span>(<span class="params">bm</span>):</span><br><span class="line">        <span class="keyword">return</span> bm.verts[:] + bm.edges[:] + bm.faces[:]</span><br><span class="line">    planes = [start.lerp(end, f / segments) <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, segments)]</span><br><span class="line">    <span class="comment">#p0 = start</span></span><br><span class="line">    plane_no = (end - start).normalized() </span><br><span class="line">    <span class="keyword">while</span>(planes): </span><br><span class="line">        p0 = planes.pop(<span class="number">0</span>)                 </span><br><span class="line">        ret = bmesh.ops.bisect_plane(bm, </span><br><span class="line">                geom=geom(bm),</span><br><span class="line">                plane_co=p0, </span><br><span class="line">                plane_no=plane_no)</span><br><span class="line">        bmesh.ops.split_edges(bm, </span><br><span class="line">                edges=[e <span class="keyword">for</span> e <span class="keyword">in</span> ret[<span class="string">&#x27;geom_cut&#x27;</span>] </span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(e, bmesh.types.BMEdge)])</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 删除初始物体</span></span><br><span class="line">bpy.ops.<span class="built_in">object</span>.select_all(action=<span class="string">&#x27;SELECT&#x27;</span>)</span><br><span class="line">bpy.ops.<span class="built_in">object</span>.delete(use_global=<span class="literal">False</span>, confirm=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 导入mesh</span></span><br><span class="line">bpy.ops.wm.obj_import(filepath=args.input_mesh)</span><br><span class="line"></span><br><span class="line">bm = bmesh.new()</span><br><span class="line">ob = context.<span class="built_in">object</span></span><br><span class="line">me = ob.data</span><br><span class="line">bm.from_mesh(me)</span><br><span class="line">o, x, y, z = bbox_axes(ob)        </span><br><span class="line">x_segments = <span class="number">2</span></span><br><span class="line">y_segments = <span class="number">2</span></span><br><span class="line">z_segments = <span class="number">1</span></span><br><span class="line"><span class="built_in">slice</span>(bm, o, x, x_segments)</span><br><span class="line"><span class="built_in">slice</span>(bm, o, y, y_segments)</span><br><span class="line"><span class="built_in">slice</span>(bm, o, z, z_segments)    </span><br><span class="line">bm.to_mesh(me)</span><br><span class="line">bpy.ops.<span class="built_in">object</span>.mode_set(mode=<span class="string">&#x27;EDIT&#x27;</span>)</span><br><span class="line">bpy.ops.mesh.separate(<span class="built_in">type</span>=<span class="string">&#x27;LOOSE&#x27;</span>)</span><br><span class="line">bpy.ops.<span class="built_in">object</span>.mode_set() </span><br><span class="line"></span><br><span class="line">bpy.ops.<span class="built_in">object</span>.select_all(action=<span class="string">&#x27;SELECT&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> bpy.data.objects:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name: &quot;</span>, obj.name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blenderproc run mesh_slice.py --input_mesh=<span class="string">&quot;9c11e109cd1b4a9a8c1978258aa97392.obj&quot;</span></span><br></pre></td></tr></table></figure><h3 id="打开提示">打开提示</h3><p>在偏好设置中打开Python Tooltips，将鼠标停滞在按钮、属性上时，都会提示要如何调用，在info窗口可以看到几乎每一次操作对应的命令，便于脚本开发</p><p><img src="/images/blenderPythonTooltips.png" class="lazyload" data-srcset="/images/blenderPythonTooltips.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blenderPythonTooltips"></p><p><img src="/images/pythonTooltips.png" class="lazyload" data-srcset="/images/pythonTooltips.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="pythonTooltips"></p><h3 id="安装插件">安装插件</h3><p>blender有很多好用的插件，也可以用在bpy脚本中</p><blockquote><p>如果不知道插件的名称，可以先UI启动Blender，安装并开关对应插件，在python窗口输入<code>print(bpy.context.preferences.addons.keys())</code>，变化的那一个包，就是你想要的插件的名称</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bpy.ops.preferences.addon_install(filepath=<span class="string">f&quot;<span class="subst">&#123;os.getcwd()&#125;</span>/xxx.zip&quot;</span>)</span><br><span class="line">bpy.ops.preferences.addon_enable(module=<span class="string">&quot;yyy&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(bpy.context.preferences.addons.keys())</span><br></pre></td></tr></table></figure><h3 id="输出场景内容">输出场景内容</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> bpy.context.scene.objects:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- <span class="subst">&#123;obj.name&#125;</span> (<span class="subst">&#123;obj.<span class="built_in">type</span>&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="删除初始状态">删除初始状态</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出python脚本所在位置</span></span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br><span class="line"><span class="comment"># 删除初始状态的几个物体</span></span><br><span class="line">bpy.ops.<span class="built_in">object</span>.select_all(action=<span class="string">&#x27;SELECT&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> bpy.data.objects:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name: &quot;</span>, obj.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Delete all objects&quot;</span>)</span><br><span class="line">bpy.ops.<span class="built_in">object</span>.delete(use_global=<span class="literal">False</span>, confirm=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="打开项目">打开项目</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bpy.ops.wm.open_mainfile(filepath=<span class="string">&quot;template/tapmo.blend&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="渲染视频-2">渲染视频</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output_path = <span class="string">&quot;output/&quot;</span></span><br><span class="line">os.makedirs(output_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line">bpy.context.scene.frame_start = <span class="number">1</span>  <span class="comment"># 动画开始帧</span></span><br><span class="line">bpy.context.scene.frame_end = <span class="number">120</span>  <span class="comment"># 动画结束帧</span></span><br><span class="line">bpy.context.scene.render.engine = <span class="string">&#x27;BLENDER_EEVEE&#x27;</span></span><br><span class="line">bpy.context.scene.render.filepath = output_path</span><br><span class="line">bpy.ops.render.render(animation=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="开关编辑模式">开关编辑模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到编辑模式</span></span><br><span class="line">bpy.ops.<span class="built_in">object</span>.mode_set(mode=<span class="string">&#x27;EDIT&#x27;</span>)</span><br><span class="line"><span class="comment"># 切换到对象模式</span></span><br><span class="line">bpy.ops.<span class="built_in">object</span>.mode_set(mode=<span class="string">&#x27;OBJECT&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="找到Mesh">找到Mesh</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> imported_objects:</span><br><span class="line">    <span class="keyword">if</span> obj.<span class="built_in">type</span> == <span class="string">&#x27;MESH&#x27;</span>:  <span class="comment"># 确保对象是网格类型</span></span><br><span class="line">        bpy.context.view_layer.objects.active = obj  <span class="comment"># 设置当前活动对象</span></span><br><span class="line">        bpy.ops.<span class="built_in">object</span>.shade_smooth()<span class="comment"># 平滑着色</span></span><br></pre></td></tr></table></figure><h3 id="remesh">remesh</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> bpy.context.selected_objects:</span><br><span class="line">    <span class="keyword">if</span> obj.<span class="built_in">type</span> == <span class="string">&#x27;MESH&#x27;</span>:  <span class="comment"># 确保对象是网格类型</span></span><br><span class="line">        bpy.context.view_layer.objects.active = obj  </span><br><span class="line">        <span class="comment"># 应用体素重构操作</span></span><br><span class="line">        bpy.context.<span class="built_in">object</span>.data.remesh_voxel_size = <span class="number">0.01</span></span><br><span class="line">        bpy.ops.<span class="built_in">object</span>.voxel_remesh()</span><br><span class="line">        bpy.ops.<span class="built_in">object</span>.shade_smooth()</span><br></pre></td></tr></table></figure><h3 id="obj">obj</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bpy.ops.wm.obj_import(filepath=input_path)</span><br><span class="line">obj_file_path = <span class="string">f&quot;<span class="subst">&#123;output_folder&#125;</span>/mesh.obj&quot;</span></span><br><span class="line">export_settings = &#123;</span><br><span class="line">    <span class="string">&quot;filepath&quot;</span>: obj_file_path,  <span class="comment"># 指定 OBJ 文件的保存路径</span></span><br><span class="line">    <span class="string">&quot;export_materials&quot;</span>: <span class="literal">True</span>,   <span class="comment"># 导出材质信息</span></span><br><span class="line">    <span class="string">&quot;path_mode&quot;</span>: <span class="string">&quot;COPY&quot;</span>,</span><br><span class="line">    <span class="string">&quot;filter_image&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">&quot;export_uv&quot;</span>: <span class="literal">True</span>,          <span class="comment"># 导出 UV 坐标</span></span><br><span class="line">    <span class="string">&quot;export_normals&quot;</span>: <span class="literal">True</span>,     <span class="comment"># 导出法线信息</span></span><br><span class="line">    <span class="string">&quot;global_scale&quot;</span>: <span class="number">1.0</span>,        <span class="comment"># 使用全局缩放</span></span><br><span class="line">    <span class="string">&quot;forward_axis&quot;</span>: <span class="string">&#x27;NEGATIVE_Z&#x27;</span>,       <span class="comment"># 使用 Blender 的默认轴向</span></span><br><span class="line">    <span class="string">&quot;up_axis&quot;</span>: <span class="string">&#x27;Y&#x27;</span>,             <span class="comment"># 使用 Blender 的默认轴向</span></span><br><span class="line">&#125;</span><br><span class="line">bpy.ops.wm.obj_export(**export_settings)</span><br></pre></td></tr></table></figure><h3 id="glb">glb</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入</span></span><br><span class="line">bpy.ops.import_scene.gltf(filepath=input_path, merge_vertices=<span class="literal">True</span>)</span><br><span class="line">imported_objects = bpy.context.selected_objects  <span class="comment"># 获取所有导入的对象</span></span><br><span class="line"><span class="comment"># 导出</span></span><br><span class="line">bpy.ops.export_scene.gltf(filepath=glb_file_path)</span><br></pre></td></tr></table></figure><h3 id="渲染顶部视角">渲染顶部视角</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> bpy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;Arguments&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--input_mesh&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--save_dir&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">exten = args.input_mesh.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">name = args.input_mesh.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">os.makedirs(args.save_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除场景</span></span><br><span class="line">bpy.ops.<span class="built_in">object</span>.select_all(action=<span class="string">&#x27;SELECT&#x27;</span>)</span><br><span class="line">bpy.ops.<span class="built_in">object</span>.delete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 模型</span></span><br><span class="line"><span class="keyword">if</span> exten == <span class="string">&#x27;obj&#x27;</span>:</span><br><span class="line">    bpy.ops.wm.obj_import(filepath=args.input_mesh)</span><br><span class="line"><span class="keyword">elif</span> exten == <span class="string">&#x27;glb&#x27;</span>:</span><br><span class="line">    bpy.ops.import_scene.gltf(filepath=args.input_mesh, merge_vertices=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加相机并设置顶部视角</span></span><br><span class="line">bpy.ops.<span class="built_in">object</span>.camera_add(location=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">camera = bpy.context.<span class="built_in">object</span></span><br><span class="line"><span class="comment"># camera.data.angle = math.radians(50)</span></span><br><span class="line">bpy.context.scene.camera = camera</span><br><span class="line"><span class="comment"># （可选）设置正交投影</span></span><br><span class="line">camera.data.<span class="built_in">type</span> = <span class="string">&#x27;ORTHO&#x27;</span></span><br><span class="line">camera.data.ortho_scale = <span class="number">1</span>  <span class="comment"># 根据模型大小调整</span></span><br><span class="line"><span class="comment"># camera.rotation_euler = (math.radians(60), 0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建太阳光</span></span><br><span class="line">light_data = bpy.data.lights.new(name=<span class="string">&quot;SunLight&quot;</span>, <span class="built_in">type</span>=<span class="string">&#x27;SUN&#x27;</span>)</span><br><span class="line">light_data.energy = <span class="number">2</span>  <span class="comment"># 设置光源强度，5 是常用值</span></span><br><span class="line">light_object = bpy.data.objects.new(name=<span class="string">&quot;SunLight&quot;</span>, object_data=light_data)</span><br><span class="line">bpy.context.collection.objects.link(light_object)</span><br><span class="line">light_object.location = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 设置光源旋转，使其从上向下照射（沿负 Z 轴）</span></span><br><span class="line">light_object.rotation_euler = (math.radians(<span class="number">30</span>), math.radians(<span class="number">30</span>), <span class="number">0</span>)  <span class="comment"># 默认朝下（负 Z 轴）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置渲染参数</span></span><br><span class="line">bpy.context.scene.render.resolution_x = <span class="number">1024</span></span><br><span class="line">bpy.context.scene.render.resolution_y = <span class="number">1024</span></span><br><span class="line">bpy.context.scene.render.filepath = <span class="string">f&quot;<span class="subst">&#123;args.save_dir&#125;</span>/<span class="subst">&#123;name&#125;</span>.png&quot;</span></span><br><span class="line"></span><br><span class="line">bpy.context.scene.render.engine = <span class="string">&#x27;CYCLES&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 CUDA 加速</span></span><br><span class="line">preferences = bpy.context.preferences</span><br><span class="line">cycles_preferences = preferences.addons[<span class="string">&quot;cycles&quot;</span>].preferences</span><br><span class="line">cycles_preferences.refresh_devices()</span><br><span class="line">devices = cycles_preferences.devices</span><br><span class="line"><span class="keyword">for</span> device <span class="keyword">in</span> devices:</span><br><span class="line">    <span class="keyword">if</span> device.<span class="built_in">type</span> == <span class="string">&quot;CUDA&quot;</span>:</span><br><span class="line">        device.use = <span class="literal">True</span></span><br><span class="line">cycles_preferences.compute_device_type = <span class="string">&quot;CUDA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置场景的 Cycles 设备为 GPU</span></span><br><span class="line">bpy.context.scene.cycles.device = <span class="string">&quot;GPU&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 渲染</span></span><br><span class="line">bpy.ops.render.render(write_still=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="渲染倾斜视角">渲染倾斜视角</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> blenderproc <span class="keyword">as</span> bproc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> bpy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;Arguments&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--input_mesh&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--save_dir&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">exten = args.input_mesh.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">name = args.input_mesh.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">os.makedirs(args.save_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除场景（可选）</span></span><br><span class="line">bpy.ops.<span class="built_in">object</span>.select_all(action=<span class="string">&#x27;SELECT&#x27;</span>)</span><br><span class="line">bpy.ops.<span class="built_in">object</span>.delete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 模型</span></span><br><span class="line"><span class="keyword">if</span> exten == <span class="string">&#x27;obj&#x27;</span>:</span><br><span class="line">    bpy.ops.wm.obj_import(filepath=args.input_mesh)</span><br><span class="line"><span class="keyword">elif</span> exten == <span class="string">&#x27;glb&#x27;</span>:</span><br><span class="line">    bpy.ops.import_scene.gltf(filepath=args.input_mesh, merge_vertices=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">material = bpy.data.materials.new(name=<span class="string">&quot;CustomMaterial&quot;</span>)</span><br><span class="line">material.use_nodes = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取材质节点树</span></span><br><span class="line">nodes = material.node_tree.nodes</span><br><span class="line">links = material.node_tree.links</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除默认节点</span></span><br><span class="line">nodes.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Principled BSDF节点</span></span><br><span class="line">bsdf = nodes.new(<span class="built_in">type</span>=<span class="string">&#x27;ShaderNodeBsdfPrincipled&#x27;</span>)</span><br><span class="line">bsdf.location = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Base Color为 #B8BFE7 (转换为RGB值)</span></span><br><span class="line">bsdf.inputs[<span class="string">&#x27;Base Color&#x27;</span>].default_value = (<span class="number">0.722</span>, <span class="number">0.749</span>, <span class="number">0.906</span>, <span class="number">1.0</span>)  <span class="comment"># RGB值</span></span><br><span class="line"><span class="comment"># 设置Roughness为1</span></span><br><span class="line">bsdf.inputs[<span class="string">&#x27;Roughness&#x27;</span>].default_value = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Material Output节点</span></span><br><span class="line">output = nodes.new(<span class="built_in">type</span>=<span class="string">&#x27;ShaderNodeOutputMaterial&#x27;</span>)</span><br><span class="line">output.location = (<span class="number">300</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接BSDF到Output</span></span><br><span class="line">links.new(bsdf.outputs[<span class="string">&#x27;BSDF&#x27;</span>], output.inputs[<span class="string">&#x27;Surface&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将材质赋给所有导入的对象</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> bpy.context.selected_objects:</span><br><span class="line">    <span class="keyword">if</span> obj.<span class="built_in">type</span> == <span class="string">&#x27;MESH&#x27;</span>:</span><br><span class="line">        <span class="comment"># 清除现有材质</span></span><br><span class="line">        obj.data.materials.clear()</span><br><span class="line">        <span class="comment"># 添加新材质</span></span><br><span class="line">        obj.data.materials.append(material)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加相机并设置顶部视角</span></span><br><span class="line">bpy.ops.<span class="built_in">object</span>.camera_add(location=(<span class="number">146</span>, -<span class="number">32</span>, <span class="number">134</span>))</span><br><span class="line">camera = bpy.context.<span class="built_in">object</span></span><br><span class="line"><span class="comment"># camera.data.angle = math.radians(50)</span></span><br><span class="line">bpy.context.scene.camera = camera</span><br><span class="line">camera.data.clip_start = <span class="number">0.1</span>  <span class="comment"># 近距离裁剪平面</span></span><br><span class="line">camera.data.clip_end = <span class="number">10000</span> </span><br><span class="line">camera.data.<span class="built_in">type</span> = <span class="string">&#x27;PERSP&#x27;</span></span><br><span class="line">camera.data.lens = <span class="number">75</span>  <span class="comment"># 设置焦距为75mm</span></span><br><span class="line">camera.rotation_euler = (math.radians(<span class="number">45</span>), math.radians(<span class="number">0</span>), math.radians(<span class="number">90</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的太阳光数据块</span></span><br><span class="line">light_data = bpy.data.lights.new(name=<span class="string">&quot;SunLight&quot;</span>, <span class="built_in">type</span>=<span class="string">&#x27;SUN&#x27;</span>)</span><br><span class="line">light_data.energy = <span class="number">3.3</span>  <span class="comment"># 设置光源强度</span></span><br><span class="line"><span class="comment"># 创建一个新的对象，并将光源数据块链接到该对象</span></span><br><span class="line">light_object = bpy.data.objects.new(name=<span class="string">&quot;SunLight&quot;</span>, object_data=light_data)</span><br><span class="line"><span class="comment"># 将光源对象链接到当前集合</span></span><br><span class="line">bpy.context.collection.objects.link(light_object)</span><br><span class="line"><span class="comment"># 设置光源位置（位置对太阳光影响较小，但仍需设置）</span></span><br><span class="line">light_object.location = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 设置光源旋转，使其从上向下照射（沿负 Z 轴）</span></span><br><span class="line">light_object.rotation_euler = (math.radians(<span class="number">7</span>), math.radians(<span class="number">7</span>), <span class="number">0</span>)  <span class="comment"># 默认朝下（负 Z 轴）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> bpy.context.scene.objects:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;- <span class="subst">&#123;obj.name&#125;</span> (<span class="subst">&#123;obj.<span class="built_in">type</span>&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置渲染参数</span></span><br><span class="line">bpy.context.scene.render.resolution_x = <span class="number">4096</span></span><br><span class="line">bpy.context.scene.render.resolution_y = <span class="number">2048</span></span><br><span class="line">bpy.context.scene.render.filepath = <span class="string">f&quot;<span class="subst">&#123;args.save_dir&#125;</span>/<span class="subst">&#123;name&#125;</span>.png&quot;</span></span><br><span class="line">bpy.context.scene.render.film_transparent = <span class="literal">True</span></span><br><span class="line">bpy.context.scene.render.engine = <span class="string">&#x27;CYCLES&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 CUDA 加速</span></span><br><span class="line">preferences = bpy.context.preferences</span><br><span class="line">cycles_preferences = preferences.addons[<span class="string">&quot;cycles&quot;</span>].preferences</span><br><span class="line">cycles_preferences.refresh_devices()</span><br><span class="line">devices = cycles_preferences.devices</span><br><span class="line"><span class="keyword">for</span> device <span class="keyword">in</span> devices:</span><br><span class="line">    <span class="keyword">if</span> device.<span class="built_in">type</span> == <span class="string">&quot;CUDA&quot;</span>:</span><br><span class="line">        device.use = <span class="literal">True</span></span><br><span class="line">cycles_preferences.compute_device_type = <span class="string">&quot;CUDA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置场景的 Cycles 设备为 GPU</span></span><br><span class="line">bpy.context.scene.cycles.device = <span class="string">&quot;GPU&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 渲染</span></span><br><span class="line">bpy.ops.render.render(write_still=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Blender </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3dmax使用笔记</title>
      <link href="/dcc/Max%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/dcc/Max%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>3dmax使用笔记</h1><p>3dmax是一个被广泛使用的DCC工具，我之前对这个软件不是很熟悉，于是记录一些平时遇到的常用操作</p><h3 id="材质编辑">材质编辑</h3><p>选中模型，按键盘<code>m</code>，打开材质界面。点击吸管后再点击模型，即可得到该网格所使用的材质列表</p><p><img src="/images/%E6%9D%90%E8%B4%A8%E9%9D%A2%E6%9D%BF.jpg" class="lazyload" data-srcset="/images/%E6%9D%90%E8%B4%A8%E9%9D%A2%E6%9D%BF.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="材质面板"></p><p>点击Modes——Slate Material Editor，即可打开材质连连看</p><p><img src="/images/%E6%9D%90%E8%B4%A8%E8%BF%9E%E8%BF%9E%E7%9C%8B.jpg" class="lazyload" data-srcset="/images/%E6%9D%90%E8%B4%A8%E8%BF%9E%E8%BF%9E%E7%9C%8B.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="材质连连看"></p><h3 id="网格塌缩">网格塌缩</h3><p>我们预览模型动画时，想要导出某一帧的网格，而且希望这个网格位置本身被修改，而非运行时被骨骼驱动，于是需要做塌缩</p><h4 id="选中网格">选中网格</h4><p>在窗口左侧，我们可以看到当前FBX是由哪些东西组成的（比如Mesh、骨骼），如果我们想同时选中所有的Mesh，可以按键盘<code>h</code>，打开快速选中界面，在最上一栏仅选择Mesh（图中蓝色背景的圆球），筛选的就是所有Mesh</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E9%80%89%E4%B8%AD.jpg" class="lazyload" data-srcset="/images/%E5%BF%AB%E9%80%9F%E9%80%89%E4%B8%AD.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="快速选中"></p><h4 id="塌缩">塌缩</h4><p>选中网格后对模型按右键——Convert To：——Convert to Editable Poly，即可完成塌缩</p><p><img src="/images/%E5%A1%8C%E7%BC%A9.jpg" class="lazyload" data-srcset="/images/%E5%A1%8C%E7%BC%A9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="塌缩"></p>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3dmax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模版</title>
      <link href="/program/C++template/"/>
      <url>/program/C++template/</url>
      
        <content type="html"><![CDATA[<h1>C++模版</h1><blockquote><p>《C++ Templates: The Complete Guide》笔记</p></blockquote><h2 id="为什么使用模版">为什么使用模版</h2><p>为了实现泛型</p><p>如果不使用泛型，对于一些通用的函数或容器，比如print、vector，我们可能需要逐个实现他们的函数，尽管这些函数的功能十分类似（可能相同），低效复杂而且难以维护</p><p>在C++标准库中使用了大量模版</p><h3 id="模板的缺点">模板的缺点</h3><ul><li>难以阅读、调试</li><li>容易触发编译报错（比如将<code>&lt;&lt;</code>运算符识别为模板展开）</li><li>闭源软件不友好（许多开源软件会提供<code>.h</code>和<code>.lib</code>，如果使用模板，头文件中就会暴露实现）</li></ul><h2 id="函数模版">函数模版</h2><h3 id="模版定义">模版定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">getMax</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">5</span>, <span class="number">6</span>) &lt;&lt; std::endl;<span class="comment">// 6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">5.1</span>, <span class="number">6.1</span>) &lt;&lt; std::endl;<span class="comment">// 6.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>T</code>是<strong>类型参数</strong>，我们可以使用任意字符，不过习惯上使用<code>T</code></p><p>处于历史原因，我们也可以使用<code>class</code>来代替<code>typename</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">getMax</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模版实例化">模版实例化</h3><p>在编译阶段，模版会被编译为多个独立的实体，比如我们调用<code>getMax(5, 6)</code>，编译器会编译出：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样用具体类型<code>int</code>取代类型参数<code>T</code>的过程叫做<strong>实例化</strong></p><h3 id="两阶段编译检查">两阶段编译检查</h3><p>模版分为两步编译：模版定义阶段、模版实例化阶段</p><p>在模版定义阶段，不会对类型参数做检查，比如你让两个<code>T</code>对象进行大小比较（<code>a &gt; b</code>），编译器不会去质疑<code>T</code>对象是否支持比较操作符</p><p>在模版实例化阶段，模版会再次被检查（尤其是类型参数），如果编译器发现<code>T</code>对象不支持比较操作符，就会报错</p><p>我们发现，当我们在实例化一个模版时，编译器需要看到模版的完整定义，但C++函数采用声明和实现分离的思想，函数在编译阶段只需要声明，这出现了冲突。简单的做法是<strong>将模版的实现写在头文件中</strong></p><h3 id="类型推断">类型推断</h3><p>我们在调用<code>getMax</code>时，会根据传入的参数类型，自动推断出<code>T</code>的类型，但这种推断是有限制的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getMax</span>(<span class="number">4</span>, <span class="number">5</span>);<span class="comment">// OK, T is int</span></span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">4.1</span>, <span class="number">5.1</span>);<span class="comment">// OK, T is double</span></span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">4</span>, <span class="number">5.1</span>);<span class="comment">// Error, 无法正确推断T的类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">2</span>, a);<span class="comment">// OK, T is int, a的const会被decay掉</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> &amp;c = b;</span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">2</span>, c);<span class="comment">// OK, T is int, c的引用会被decay掉</span></span><br></pre></td></tr></table></figure><h4 id="decay">decay</h4><p>退化（decay）是指<strong>数组变指针</strong>，<strong>函数变指针</strong>，<strong>左值变右值</strong>的过程</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="built_in">foo</span>(myArray);<span class="comment">// 等价于foo(&amp;myArray[0])</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码，数组<code>myArray</code>被转化为指向数组第一个元素的指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">void</span> (*ptr)() = foo;</span><br><span class="line">  <span class="built_in">ptr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码，函数<code>foo</code>被转化为函数指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> &amp;c = b;</span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">2</span>, a);<span class="comment">// OK, T is int, a的const会被decay掉</span></span><br><span class="line"><span class="built_in">getMax</span>(<span class="number">2</span>, c);<span class="comment">// OK, T is int, c的引用会被decay掉</span></span><br></pre></td></tr></table></figure><p>在上面这段代码，<code>int&amp;</code>和<code>const int&amp;</code>都被转化为对应的右值</p><p>我们可以使用type_traits库来检测decay的合法性</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">decay_equiv</span>: std::is_same&lt;<span class="keyword">typename</span> std::decay&lt;T&gt;::type, U&gt;::type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; std::boolalpha &lt;&lt; decay_equiv&lt;<span class="type">int</span>&amp;, <span class="type">int</span>&gt;::value &lt;&lt; std::endl;<span class="comment">// true</span></span><br><span class="line">  std::cout &lt;&lt; std::boolalpha &lt;&lt; decay_equiv&lt;<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">int</span>&gt;::value &lt;&lt; std::endl;<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>std::boolalpha的作用是将bool类型以true/false的形式打印出来，而非1/0</p></blockquote><h3 id="多个模板参数">多个模板参数</h3><p>当模板有多个参数时，我们可以用<code>&lt;&gt;</code>指定参数类型</p><p>在后面的类型，如果可以自动推断出来，可以不写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">RT <span class="title">getMax</span><span class="params">(T1 a, T2 b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>) &lt;&lt; std::endl;<span class="comment">// 7</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>) &lt;&lt; std::endl;<span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回类型推断">返回类型推断</h4><blockquote><p>极其推荐这样写</p></blockquote><p>上面的返回值类型是手动指定的，很容易出现编写错误，因此我们一般会让编译器来角色返回值类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getMax</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(a &gt; b ? a : b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">4</span>, <span class="number">7.2</span>) &lt;&lt; std::endl;<span class="comment">// 7.2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">8</span>, <span class="number">7.2</span>) &lt;&lt; std::endl;<span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现这样写的返回类型由<code>?:</code>运算符的执行结果决定，7.2大于4，于是返回类型为<code>double</code>，8大于7.2，于是返回类型为<code>int</code></p><p>进一步的，若传入的数据是引用类型，可以使用类型萃取，不过一般情况下，上面这种写法就够了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getMax2</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="keyword">typename</span> std::decay&lt; <span class="title">decltype</span><span class="params">(a &gt; b ? a : b)</span>&gt;::type</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公共类型">公共类型</h4><p>Common Type</p><p>C++11提供了一种更一般的类型，用于得到两个模板参数的公共类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">common_type_t</span>&lt;T1, T2&gt; <span class="title">getMax3</span><span class="params">(T1 a, T2 b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认参数类型">默认参数类型</h3><p>我们可以给参数指定默认值，但要同时给<code>T</code>一个对应默认参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T </span>= <span class="type">double</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T a = <span class="number">3.14</span>)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">15</span>);<span class="comment">// 15</span></span><br><span class="line">    <span class="built_in">foo</span>();<span class="comment">// 3.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载">重载</h3><p>函数模板可以与同名的普通函数共存，且优先调用普通函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">1</span>);<span class="comment">// int: 1</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">3.14</span>);<span class="comment">// 3.14 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板也可以和其他同名但参数类型数量不同的函数模板共存，但必须保证在调用模板时，<strong>有且仅有一个模板能匹配</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123; <span class="keyword">return</span> b &lt; a ? a : b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span></span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123; <span class="keyword">return</span> b &lt; a ? a : b; &#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><h4 id="使用值传递">使用值传递</h4><p>一般而言，函数参数中，简单类型值传递，复杂的类型引用传递。但在模板编程中，我们更倾向于使用值传递</p><p>值传递的优点：</p><ul><li>语法简单</li><li>编译器能更好地优化</li><li>移动一般比拷贝成本更低</li><li>某些情况没有移动或拷贝</li><li>模板既可以适用于复杂类型，也可以适用于简单类型，盲目使用引用会影响简单类型的使用</li><li>调用者可以主动使用<code>std::ref()</code>和<code>std::cref()</code></li><li>string literal和raw array使用引用传递会出现问题</li></ul><h2 id="类模板">类模板</h2><p>类也可以使用模板，STL中的容器就是这样实现的</p><p>类模版中的模版成员函数，只有在被调用时才会实例化</p><p>类模版的模版参数，要能支持模版函数中使用的各种操作和运算符</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elems.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;elem) &#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    elems.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T <span class="type">const</span>&amp; Stack&lt;T&gt;::<span class="built_in">top</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());     <span class="comment">// 断言语句，若条件不满足，程序会终止，仅在Debug模式生效</span></span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于历史原因，C++11以前的模版，两个相邻尖括号间要有空格，如<code>Stack&lt;Stack&lt;int&gt; &gt;</code>，在C++11之后就不再需要了</p></blockquote><h3 id="静态成员">静态成员</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Foo&lt;T&gt;::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo&lt;<span class="type">int</span>&gt;::count = <span class="number">10</span>;</span><br><span class="line">    Foo&lt;<span class="type">double</span>&gt;::count = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; Foo&lt;<span class="type">int</span>&gt;::count &lt;&lt; std::endl;<span class="comment">// 10</span></span><br><span class="line">    std::cout &lt;&lt; Foo&lt;<span class="type">double</span>&gt;::count &lt;&lt; std::endl;<span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特例化">特例化</h3><p>对于特定的类型，我们可以进行特例化，可以做针对性的优化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;std::string&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>特例化也可以部分特例化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T*&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以多模版参数特例化，可以给予默认模版参数</p><h3 id="类型别名">类型别名</h3><p>类型别名只是为已经存在的类型定义一个别名，并没有创建新类型，可以用<code>typedef</code>或<code>using</code>实现</p><p>typedef-name：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Stack&lt;<span class="type">int</span>&gt; IntStack;</span><br></pre></td></tr></table></figure><p>alias declaration</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> IntStack2 = Stack&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><p>alias declaration也可以被模版化，被称为alias templates</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyStack = Stack&lt;T&gt;;</span><br></pre></td></tr></table></figure><h2 id="非类型模版参数">非类型模版参数</h2><blockquote><p>所谓的非类型模版参数，就是不用typename T作为模版参数</p></blockquote><p>下面是使用<code>array</code>实现<code>Stack</code>的代码，用户可以手动指定栈容量，我们使用了<code>std::size_t</code>作为<strong>非类型模版参数</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, Maxsize&gt; elems;</span><br><span class="line">    std::<span class="type">size_t</span> elemCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elemCount == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elemCount; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line">Stack&lt;T, Maxsize&gt;::<span class="built_in">Stack</span>():  <span class="built_in">elemCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T, Maxsize&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;elem) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(elemCount &lt; Maxsize);</span><br><span class="line">    elems[elemCount] = elem;</span><br><span class="line">    ++elemCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T, Maxsize&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    --elemCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line">T <span class="type">const</span>&amp; Stack&lt;T, Maxsize&gt;::<span class="built_in">top</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems[elemCount<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>, <span class="number">10</span>&gt; st10;</span><br><span class="line">    st10.<span class="built_in">push</span>(<span class="number">15</span>);</span><br><span class="line">    std::cout &lt;&lt; st10.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，<code>Stack&lt;int, 10&gt;</code>和<code>Stack&lt;int, 20&gt;</code>是两种不同的类型，由于没有定义隐式或显示的转换规则，我们不能使用一个取代另一个，也不能把一个赋值给另一个</p><h3 id="有效类型">有效类型</h3><p>非类型模版参数只能是整形、枚举、指向对象/函数/成员的指针、指向对象/函数的左值引用、nullptr</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">double</span> VAT&gt;<span class="comment">//!!!, 这个是错误的，因为double不能作为非类型模版参数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">process</span><span class="params">(<span class="type">double</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v * VAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若表达式中使用了<code>&gt;</code>，要用<code>()</code>包裹起来</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> I, <span class="type">bool</span> B&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  C&lt;<span class="number">42</span>, <span class="built_in">sizeof</span> (<span class="type">int</span> &gt; <span class="number">4</span>)&gt; c;<span class="comment">// ERROR! 被截断为C&lt;42, sizeof (int &gt;了</span></span><br><span class="line">  C&lt;<span class="number">42</span>, (<span class="built_in">sizeof</span> (<span class="type">int</span>) &gt; <span class="number">4</span>)&gt; c;<span class="comment">// OK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="auto">auto</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, Maxsize&gt; elems;</span><br><span class="line">    std::<span class="type">size_t</span> elemCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">decltype</span>(Maxsize);<span class="comment">// !!!, 用于推断Maxsize类型</span></span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elemCount == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elemCount; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="变参模版">变参模版</h2><blockquote><p>就是接受一组数量可变的参数</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T first, Types... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(first);</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Index&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElems</span><span class="params">(C <span class="type">const</span>&amp; coll, Index... id)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(coll[id]...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">1314</span>);<span class="comment">// hello world 1314</span></span><br><span class="line">  <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">printElems</span>(a, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">// 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折叠表达式">折叠表达式</h3><p>几乎所有二元运算符都可以用于折叠表达式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getSum</span><span class="params">(T...s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (...+s);<span class="comment">// 等同于((s1 + s2) + s3)...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>) &lt;&lt; std::endl;<span class="comment">// 45</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础技巧">基础技巧</h2><h3 id="typename">typename</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T <span class="type">const</span>&amp; coll)</span></span>&#123;</span><br><span class="line">    T::const_interator pos;<span class="comment">// Error! 会被认为是静态成员</span></span><br><span class="line">  <span class="keyword">typename</span> T::const_interator pos;  <span class="comment">// OK! const_interator是定义在T内的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零初始化">零初始化</h3><p>若一个类型没有默认构造函数（比如基础类型和指针类型），被初始化前其值是<strong>未定义</strong>的，我们可以使用<strong>值初始化</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    T x &#123;&#125;;<span class="comment">// 零初始化</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    T x;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo2</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// 1, 为啥这是1啊, 因为未定义所以错了</span></span><br><span class="line">    <span class="built_in">foo2</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">foo1</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// 0, 通过零初始化所以对了</span></span><br><span class="line">    <span class="built_in">foo2</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// 0, 很难绷, 为啥你又变成0了？未定义果然不靠谱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在默认构造函数中使用零初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() : x&#123;&#125; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">    x.<span class="built_in">print</span>();<span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是非静态成员，也可以这样写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="this">this</h3><p>对于类模版，若基类也依赖于模版参数，那么子类在调用基类的成员时要使用<code>this-&gt;</code>或<code>Base&lt;T&gt;::</code>修饰</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>: Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">print</span>();<span class="comment">// !这里要使用this-&gt;不然调用不到Base的成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo&lt;<span class="type">int</span>&gt; f;</span><br><span class="line">    f.<span class="built_in">foo</span>();<span class="comment">// Hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员模版">成员模版</h3><p>类的成员也可以是模版，而且模版参数可以不同</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;T&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">    Stack&amp; <span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="type">const</span>&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Stack</span>;<span class="comment">// 为了访问其他Stack实例的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> Stack&lt;T2&gt; &amp;op2) &#123;</span><br><span class="line">    elems.<span class="built_in">clear</span>();</span><br><span class="line">    elems.<span class="built_in">insert</span>(elems.<span class="built_in">begin</span>(), op2.elems.<span class="built_in">begin</span>(), op2.elems.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">float</span>&gt; floatStack;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="type">float</span> n = <span class="number">3.14</span> * i;</span><br><span class="line">        floatStack.<span class="built_in">push</span>(n);</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">// 0 3.14 6.28 9.42 12.56 </span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">    intStack = floatStack;</span><br><span class="line">    <span class="keyword">while</span> (!intStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">// 12 9 6 3 0 </span></span><br><span class="line">        intStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lambda">lambda</h3><p>lambda表达式本质上是成员模版的简化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量模版">变量模版</h3><p>变量也可以使用模版，必须指定类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">long</span> <span class="type">double</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi &#123;<span class="number">3.1415926535897932385</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; pi&lt;&gt; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17中类型萃取就是使用了变量模版</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">bool</span> is_const_v = is_const&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模版参数模版">模版参数模版</h3><p>模版参数也可以是一个类模版</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem&gt; <span class="keyword">class</span> <span class="title class_">Cont</span> = std::deque&gt;</span><br><span class="line"><span class="keyword">class</span> Stack&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Cont&lt;T&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="移动语义">移动语义</h2><blockquote><p>移动的本质是所有权的转移，这里不过多赘述</p></blockquote><p>移动（move）：将原对象拷贝或赋值给目标对象时，若原对象马上要被销毁，可以将原对象对内部资源和状态的<strong>所有权</strong>直接转移给目标对象，避免了非必要的拷贝和临时对象</p><h3 id="禁用函数模版">禁用函数模版</h3><p>C++11提供了辅助模版<code>std::enable_if&lt;&gt;</code>，可以在编译期间忽略掉一些函数模版</p><blockquote><p>注意看，<code>foo()</code>前面的返回值类型是由<code>std::enable_if</code>决定的，</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;(<span class="built_in">sizeof</span> (T) &gt; <span class="number">4</span>)&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span> (T) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// Error! 没有找到foo, int size 4</span></span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="type">double</span>&gt;();<span class="comment">// OK, double size 8</span></span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;();<span class="comment">// OK, long long size 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若<code>(sizeof (T) &gt; 4)</code>为false，根据模版中SFINAE（substitute failure is not an error）规则，替换失败不是错误，而是会将这个函数模版忽略掉，于是<code>foo&lt;int&gt;()</code>会报找不到函数的错</p><p>若<code>(sizeof (T) &gt; 4)</code>为true，<code>std::enable_if&lt;&gt;</code>会被拓展为<code>void</code>，如果你给了第二个参数<code>T</code>，<code>std::enable_if&lt;&gt;</code>会被拓展为<code>T</code>类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;(<span class="built_in">sizeof</span> (T) &gt; <span class="number">4</span>), T&gt;</span><br><span class="line"><span class="built_in">foo</span>()&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span> (T) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更明智的写法是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfSizeGreater4 = std::<span class="type">enable_if_t</span>&lt;(<span class="built_in">sizeof</span> (T) &gt; <span class="number">4</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = EnableIfSizeGreater4&lt;T&gt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">foo</span>()&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span> (T) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="禁用构造函数模版">禁用构造函数模版</h3><p>由于转移语义的存在，构造函数的参数类型很可能是错误的，比如传入了一个右值引用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(std::string&amp;&amp; s);<span class="comment">// 我们希望禁用这个构造函数</span></span><br></pre></td></tr></table></figure><p>下面是一个例子</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString = std::<span class="type">enable_if_t</span>&lt;std::is_convertible_v&lt;T, std::string&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = EnableIfString&lt;STR&gt;&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(STR&amp;&amp; n) : <span class="built_in">name</span>(std::forward&lt;STR&gt;(n)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;模版构造函数 &quot;</span> &lt;&lt; name &lt;&lt; std::endl;    <span class="comment">// 使用了完美转发</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(Person <span class="type">const</span>&amp; p) : <span class="built_in">name</span>(p.name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝构造函数 &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(Person&amp;&amp; p) : <span class="built_in">name</span>(std::<span class="built_in">move</span>(p.name)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;移动构造函数 &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;sname&quot;</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(s)</span></span>;<span class="comment">// 模版构造函数 sname</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;temp&quot;</span>)</span></span>;<span class="comment">// 模版构造函数 temp</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>;<span class="comment">// 拷贝构造函数 sname</span></span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(std::move(p1))</span></span>;<span class="comment">// 移动构造函数 sname</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们没法禁用拷贝和移动构造函数，因为我们用成员函数来替代这些函数时，这些函数还会生成默认构造函数</p><h3 id="concept">concept</h3><p><code>enable_if</code>的语法非常丑，而且还额外使用了一个模版参数，使得代码不易读懂</p><p>我们需要的是一个能对函数施加限制的语言特性，当限制不满足时函数会被忽略掉，于是C++决定引入<code>concept</code></p><h2 id="模板元编程">模板元编程</h2><p>模板在编译器实例化，在实例化时可以进行简单的计算，这就是模板元编程</p><p>下面是用模板元判断一个数是不是质数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N, <span class="type">unsigned</span> <span class="type">int</span> Divisor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPrime</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = (N % Divisor != <span class="number">0</span>) &amp;&amp; IsPrime&lt;N, Divisor - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPrime</span>&lt;N, <span class="number">2</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = (N % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> isPrime = IsPrime&lt;N, N / <span class="number">2</span>&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> number = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span> (isPrime&lt;number&gt;) &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; is a prime number.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; is not a prime number.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="decltype">decltype</h3><p>选择合适的模板特化，也叫<strong>SFINAE</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;<span class="comment">// int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1.5</span>) &lt;&lt; std::endl;<span class="comment">// double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1.5f</span>) &lt;&lt; std::endl;<span class="comment">// float</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-constexpr">if constexpr</h3><p>编译器if</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">addIfFloat</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1.0f</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">addIfFloat</span>(<span class="number">1</span>) &lt;&lt; std::endl;<span class="comment">// 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">addIfFloat</span>(<span class="number">1.5f</span>) &lt;&lt; std::endl;<span class="comment">// 2.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型萃取">类型萃取</h2><blockquote><p>感觉不如C#的反射</p></blockquote><p>用于编译期获得模板参数的性质，下面是判断一个类中是否有成员函数<code>Execute()</code>的示例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasFunction_Execute</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">check</span><span class="params">(U* ptr)</span> -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;U&gt;().Execute(), std::true_type&#123;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::false_type <span class="title">check</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">check</span>&lt;T&gt;(<span class="literal">nullptr</span>))::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Check</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Check::someFunction() called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCheck</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasFunction_Execute&lt;Check&gt;::value) &#123;</span><br><span class="line">        Check obj;</span><br><span class="line">        obj.<span class="built_in">Execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFunction_Execute&lt;NoCheck&gt;::value) &#123;</span><br><span class="line">        <span class="comment">// 不会执行到这里，因为NoCheck类没有Execute成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里使用了<code>std::declval</code>，可以用作引用占位符</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银河恶魔城设计理念学习</title>
      <link href="/game/%E9%93%B6%E6%B2%B3%E6%81%B6%E9%AD%94%E5%9F%8E%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%AD%A6%E4%B9%A0/"/>
      <url>/game/%E9%93%B6%E6%B2%B3%E6%81%B6%E9%AD%94%E5%9F%8E%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>银河恶魔城设计理念学习</h1><blockquote><p>昨天跟魔方的策划沟通了一下，发现我之前的设计很不成熟，我所认为的Hook（比如“玩家因为缺少一个能力卡关了，于是去岔路口寻找其他能力”）原来只是这类游戏的共性（Pillar），</p></blockquote><h2 id="银河恶魔城">银河恶魔城</h2><h3 id="能力锁">能力锁</h3><p>银河恶魔城大量使用了能力锁，使用低纬度的能力构成高纬度的钥匙，服务于后续游玩，能与关卡产生协同效应</p><ul><li>道具锁（Item-Lock）：比如找到一把具体的钥匙道具开门开箱子，真实但不好玩，只能提供很低的心智挑战，或者带来一些消耗资源管理，比如做成一个玩家理论上可以通过，但由于玩家现在太弱了/太穷了而无法通过的软锁</li><li>谜题锁（Puzzle-Lock）：一段和游戏流程无关的解密，比如战神中敲钟、荒野之息中呀哈哈，能产生一次性的解密体验，常用于调整玩家游戏节奏</li><li>挑战锁（Challenge-Lock）：一段结合游戏中战斗、行动技巧的挑战，比如GTA中骑摩托车跑酷，荒野之息限时射箭</li><li>能力锁（Utility-Lock）：新能力解锁新区域，比如玩家得到了二段跳后，能跳到原来不能到达的平台，于是开放了更多的可探索内容</li></ul><img src="/images/目标挑战奖励.png" class="lazyload" data-srcset="/images/目标挑战奖励.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="目标挑战奖励" style="zoom:50%;" /><blockquote><p>以打开桃色门为例：目标是打开桃色门，挑战锁得到开门的能力/钥匙，奖励是新区域。新区域中会有新的游玩内容，新的奖励/能力，于是形成了正反馈，形成扩张式探索</p></blockquote><h3 id="回路探索">回路探索</h3><p>银河恶魔城一般关键能力的获取顺序、关键boss的击杀顺序是固定的，因此流程是线性的。同时该游戏存在破序玩法，可收集道具和某些能力不是必须的，流程又是开放的</p><p>银河恶魔城中由于能力锁的存在，玩家无法通过某个房间后，会回到岔路探索其他房间，获得相关能力后再通过原本无法探索的房间，这个过程就是回路探索。一个探索过的房间，当玩家拥有更新的能力后，会有新的体验。（让我想到一些游戏，当你通关后来到新手村，很多人对你的称呼和态度发生变化，原本的困难的敌人也能做到一击必杀，故地重游也能有新的体验）</p><blockquote><p>他建议我在设计地图时，先设计大块的区域功能和区域间的联系，再设计每个房间的整体设计，画出角色第一次进入房间的行为热线。</p><p>每个房间的作用围绕资源的布置、节奏的控制来分配；每个房间的内部结构结合这个区域的核心机制进行设计</p></blockquote><img src="/images/线性开发.jpg" class="lazyload" data-srcset="/images/线性开发.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线性开发" style="zoom: 50%;" /><p>一张绘制区域内小房间的布局；玩家从首次进入、取得能力、击败boss、进入下一区域的一个动线</p><img src="/images/热线.png" class="lazyload" data-srcset="/images/热线.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="热线" style="zoom:50%;" /><h2 id="游戏目标">游戏目标</h2><h3 id="游戏目标-2">游戏目标</h3><p>游戏中玩家目标和设计师的目标可能不一致，从用户出发设计师最先注意的是体验目标</p><img src="/images/游戏目标.png" class="lazyload" data-srcset="/images/游戏目标.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="游戏目标" style="zoom:50%;" /><p>玩家目标：玩家在游戏设置的情景中被要求达到的结果（比如打到魔王、赚到一万个金币）</p><p>体验目标：设计师希望玩家通过游戏体验到的内容（比如了解某个文明的文化，掌握超人力量的满足感，感到恐惧、好奇）</p><p>设计目标：设计师希望通过具体的设计手法达到特定的产品效果（比如为长期运营创造空间，简洁扁平的交互设计）</p><h3 id="GMT">GMT</h3><p>G（Goal）：目标</p><p>M（Means）：达成目标的高阶手段</p><p>T（Tools）：将手段细分的具体可执行的低阶要素</p><p>GMT分为玩家目标的GMT和体验目标的GMT</p><h2 id="关卡设计">关卡设计</h2><h2 id="参考">参考</h2><p><a href="https://zhuanlan.zhihu.com/p/515008876">银河恶魔城入门</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3MTQzOTY3OQ==&amp;mid=2247494931&amp;idx=1&amp;sn=f1d6cde58404aee53598de4b7016630b&amp;chksm=eac36f43ddb4e6557c4c2d87e3ec93a049da01b15cbad57b86f913eda11987081f75a3c78280&amp;scene=21#wechat_redirect">游戏设计逻辑</a></p><p><a href="https://www.youtube.com/watch?v=7ITtPPE-pXE">关卡设计</a></p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>银河战士like开发日志</title>
      <link href="/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
      <url>/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1>银河战士like开发日志</h1><p>终于把毕设忙完了，开始填坑了，首先就是这个银河战士like的游戏，说实话我已经很长时间没做过Gameplay开发了，上来就做这种高难度的动作射击，感觉有些蠢。不过多亏了Mix and Jam开源了一个教程，少走不少弯路。为了自我监督，把开发日志记录在案。说实话我GP水平很差，这个日志应该会踩不少坑</p><blockquote><p>Unity 2021.3.22 URP Windows11，使用内置的Plastic SCM做版本管理（Unity对Plastic SCM支持较好，尽管我更喜欢Git和P4V）</p></blockquote><h3 id="1-添加角色模型">1. 添加角色模型</h3><blockquote><p>使用Package Manager添加插件Input System，Player Input组件和Input Action文件均属于该插件</p></blockquote><p>从<a href="%5BMixamo%5D(https://www.mixamo.com/#/)">Mixamo</a>找一个人物模型，放入场景中</p><p>添加组件Character Controller（该组件会自带一个胶囊碰撞体，可以调整尺寸以适配角色）</p><p>添加组件Player Input</p><p>添加一个脚本<code>PlayerController.cs</code></p><p><img src="/images/mixamo.png" class="lazyload" data-srcset="/images/mixamo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="mixamo"></p><img src="/images/characterController.png" class="lazyload" data-srcset="/images/characterController.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="characterController" style="zoom:50%;" /><h3 id="2-配置Input-Action文件">2. 配置Input Action文件</h3><p>创建一个Input Action，添加一个Vector2类型的移动，一个跳跃按钮</p><p><img src="/images/inputAction.gif" class="lazyload" data-srcset="/images/inputAction.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="inputAction"></p><p>将该文件拖入Player Input组件的Actions上</p><h3 id="3-编写移动脚本">3. 编写移动脚本</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PlayerInput input;</span><br><span class="line">    <span class="keyword">private</span> CharacterController controller;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;Movement Settings&quot;</span>)</span>] </span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;水平移动速度&quot;</span>)</span>] </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> movementSpeed = <span class="number">6f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Vector2 moveInput;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取角色身上的组件</span></span><br><span class="line">        input = GetComponent&lt;PlayerInput&gt;();</span><br><span class="line">        controller = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读按键输入</span></span><br><span class="line">        moveInput = input.actions[<span class="string">&quot;Move&quot;</span>].ReadValue&lt;Vector2&gt;();</span><br><span class="line"><span class="comment">// 若输入不为空，则使用CharacterController进行移动</span></span><br><span class="line">        <span class="built_in">bool</span> isMoving = Mathf.Abs(moveInput.normalized.x) &gt; <span class="number">0.01f</span>;</span><br><span class="line">        <span class="keyword">if</span> (isMoving)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> hDir = moveInput.x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            controller.Move(Vector3.right * hDir * Mathf.Abs(moveInput.normalized.x * movementSpeed) * Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入游戏后按AD键可以实现左右移动（注意坐标系，Unity的2D游戏通常会以x轴正方向为右，y轴正方向为上）</p><h3 id="4-移动动画">4. 移动动画</h3><p>去mixamo找几段动画（动画存放在fbx文件中，将fbx导入unity后可以将动画片段抽离、切分），并创建一个Animation Controller</p><img src="/images/动画.png" class="lazyload" data-srcset="/images/动画.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="动画" style="zoom:50%;" /><p>双击打开Animation Controller后，右键创建一个BlendTree，将该BlendTree与Entry相连，并修改BlendTree的参数名为<code>MoveInput</code></p><p><img src="/images/animator.png" class="lazyload" data-srcset="/images/animator.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="animator"></p><p>双击进入BlendTree，按右键添加多个Motion，并调整他们的Threshold信息</p><p><img src="/images/blendtree.png" class="lazyload" data-srcset="/images/blendtree.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="blendtree"></p><p>在角色上添加Animator组件，并将上面创建的Animation Controller拖到上面</p><img src="/images/人物动画.png" class="lazyload" data-srcset="/images/人物动画.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="人物动画" style="zoom:50%;" /><p>修改<code>PlayerController.cs</code>脚本，根据输入设置动画参数，并处理转向</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private PlayerInput input;</span><br><span class="line">private CharacterController controller;</span><br><span class="line"><span class="addition">+private Animator animator;</span></span><br><span class="line"></span><br><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">    input = GetComponent&lt;PlayerInput&gt;();</span><br><span class="line">    controller = GetComponent&lt;CharacterController&gt;();</span><br><span class="line"><span class="addition">+    animator = GetComponent&lt;Animator&gt;();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    moveInput = input.actions[&quot;Move&quot;].ReadValue&lt;Vector2&gt;();</span><br><span class="line"></span><br><span class="line">    bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f;</span><br><span class="line">    if (isMoving)</span><br><span class="line">    &#123;</span><br><span class="line">        float hDir = moveInput.x &gt; 0 ? 1 : -1;</span><br><span class="line">        controller.Move(Vector3.right * hDir * Mathf.Abs(moveInput.normalized.x * movementSpeed) * Time.deltaTime);</span><br><span class="line"><span class="addition">+        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(moveInput.x != 0 ? Vector3.right * moveInput.normalized.x : Vector3.right * hDir), 0.1f);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+    animator.SetFloat(&quot;MoveInput&quot;, Mathf.Abs(moveInput.normalized.x * movementSpeed), 0.2f, Time.deltaTime);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下，感觉运动停止时有点粘滞感，还需要细调</p><p><img src="/images/%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8.gif" class="lazyload" data-srcset="/images/%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="左右移动"></p><h3 id="5-跳跃">5. 跳跃</h3><p>跳跃是该游戏的核心，这只是我估摸着做的第一版，有一说一，手感稀烂</p><h4 id="碰撞状态检测">碰撞状态检测</h4><p>创建脚本<code>CollisionState.cs</code>，并绑定到角色身上。该脚本用于判断角色和场景的关系，目前只做了和水平地表的检测</p><blockquote><p>nearGround的作用是为了连跳</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CollisionState</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;地表的碰撞层&quot;</span>)</span>] <span class="keyword">private</span> LayerMask groundLayer;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;在地表上的检测距离&quot;</span>)</span>] <span class="keyword">private</span> <span class="built_in">float</span> testDistance = <span class="number">0f</span>;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;靠近地表的检测距离&quot;</span>)</span>] <span class="keyword">private</span> <span class="built_in">float</span> nearDistance = <span class="number">0.2f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> onGround;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> nearGround;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> offset = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        onGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, testDistance + offset, groundLayer);</span><br><span class="line">        nearGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, nearDistance + offset, groundLayer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环境设置">环境设置</h4><p>添加Ground碰撞层，并将场景物体设置为Ground（场景物体要有碰撞体）</p><p><img src="/images/GroundLayer.gif" class="lazyload" data-srcset="/images/GroundLayer.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GroundLayer"></p><p>注意设置角色身上的Ground Layer类型</p><p><img src="/images/GroundLayer2.png" class="lazyload" data-srcset="/images/GroundLayer2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GroundLayer2"></p><h4 id="角色跳跃">角色跳跃</h4><p>下面修改<code>PlayerController.cs</code>，添加跳跃逻辑</p><p>首先获取CollisionState脚本，以判断是否能进行跳跃</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">private Animator animator;</span><br><span class="line"><span class="addition">+private CollisionState collisionState;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    animator = GetComponent&lt;Animator&gt;();</span><br><span class="line"><span class="addition">+    collisionState = GetComponent&lt;CollisionState&gt;();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加一些跳跃要用到的参数</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">[Header(&quot;Movement Settings&quot;)] </span><br><span class="line">[SerializeField, Tooltip(&quot;水平移动速度&quot;)] </span><br><span class="line">private float movementSpeed = 6f;</span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;重力&quot;)] </span></span><br><span class="line"><span class="addition">+private float gravity = -9.8f;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;大跳的跳跃高度&quot;)] </span></span><br><span class="line"><span class="addition">+private float jumpHeight = 5f;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;开始加速下落时的速度&quot;)] </span></span><br><span class="line"><span class="addition">+private float fallingSpeedup = 10f;</span></span><br><span class="line"></span><br><span class="line">private Vector2 moveInput;</span><br><span class="line"><span class="addition">+private bool jumpPressed = false;</span></span><br><span class="line"><span class="addition">+private bool jumpPressDown = false;</span></span><br><span class="line"><span class="addition">+private float verticalVelocity;</span></span><br><span class="line"><span class="addition">+private bool moveAfterJump  = false;    // 移动中跳跃，还是跳跃后移动</span></span><br><span class="line"><span class="addition">+private float herizontalDirection = 1f;</span></span><br><span class="line"><span class="addition">+private bool keepJump = false;  // 保持滞空</span></span><br></pre></td></tr></table></figure><p>跳跃，包含起跳、滞空、落地三个过程。</p><ul><li><p>nearGround比真实地表要高一点，于是可以在接近落地时跳跃，优化连跳手感</p></li><li><p>若按下跳跃键后不放，重力会比直接松开小，因而跳的更高，拥有更长的滞空时间。此外若向下掉落的速度小于fallingSpeedup，仍受较小的重力。</p></li><li><p>当向下落地时遇到地面，速度为0</p></li></ul><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    moveInput = input.actions[&quot;Move&quot;].ReadValue&lt;Vector2&gt;();</span><br><span class="line"><span class="addition">+    jumpPressDown = input.actions[&quot;Jump&quot;].WasPressedThisFrame();</span></span><br><span class="line"><span class="addition">+    jumpPressed = input.actions[&quot;Jump&quot;].IsPressed();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    #region 跳跃</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    // 起跳</span></span><br><span class="line"><span class="addition">+    if (jumpPressDown &amp;&amp; collisionState.nearGround)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        verticalVelocity = Mathf.Sqrt(2 * Mathf.Abs(gravity) * jumpHeight);</span></span><br><span class="line"><span class="addition">+        moveAfterJump = Mathf.Abs(moveInput.normalized.x) &lt; 0.3f;   // 判断起跳时移动速度</span></span><br><span class="line"><span class="addition">+        keepJump = true;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    // 滞空</span></span><br><span class="line"><span class="addition">+    if (keepJump &amp;&amp; verticalVelocity &gt; -fallingSpeedup)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        verticalVelocity += gravity * Time.deltaTime;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else if(!collisionState.onGround)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        verticalVelocity += 3 * gravity * Time.deltaTime;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    if (!jumpPressed)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        keepJump = false;// 松开后不能重新滞空</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    // 落地</span></span><br><span class="line"><span class="addition">+    if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        verticalVelocity = 0;</span></span><br><span class="line"><span class="addition">+        moveAfterJump = false;</span></span><br><span class="line"><span class="addition">+        keepJump = false;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    // 运动</span></span><br><span class="line"><span class="addition">+    controller.Move(Vector3.up * verticalVelocity * Time.deltaTime);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+    #endregion</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更真实，我希望角色原地起跳时更难左右移动，于是在这种情况下水平移动速度减半</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+    #region 水平移动</span></span><br><span class="line"></span><br><span class="line">    bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f;</span><br><span class="line">    if (isMoving)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="addition">+        float herizontalSpeed = Mathf.Abs(moveInput.normalized.x * movementSpeed);</span></span><br><span class="line"></span><br><span class="line">        float hDir = moveInput.x &gt; 0 ? 1 : -1;</span><br><span class="line"><span class="addition">+        if (moveAfterJump)</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            herizontalSpeed /= 2;   // 原地起跳，在空中动能很少，按理说应该走不动</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        controller.Move(Vector3.right * hDir * herizontalSpeed * Time.deltaTime);</span></span><br><span class="line">        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(moveInput.x != 0 ? Vector3.right * moveInput.normalized.x : Vector3.right * hDir), 0.1f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">animator.SetFloat(&quot;MoveInput&quot;, Mathf.Abs(moveInput.normalized.x * movementSpeed), 0.2f, Time.deltaTime);</span><br><span class="line"><span class="addition">+    #endregion</span></span><br></pre></td></tr></table></figure><p><img src="/images/%E8%B7%B3%E8%B7%83%E7%AC%AC%E4%B8%80%E7%89%88.gif" class="lazyload" data-srcset="/images/%E8%B7%B3%E8%B7%83%E7%AC%AC%E4%B8%80%E7%89%88.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="跳跃第一版"></p><h3 id="6-跳跃动画">6. 跳跃动画</h3><blockquote><p>动画状态机比我想象中要麻烦好多。。。我也不知道我这样做对不对。。。</p><p>由于没找到合适的动画资源，这一节不少动画是我自己做的，花了相当长时间，结果效果也不太行</p></blockquote><p>按下图所示在Any State后连接跳跃状态，并添加Jump、FallLand、FastJump、FastFallLand四个动画Trigger</p><p><img src="/images/Animator2.png" class="lazyload" data-srcset="/images/Animator2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Animator2"></p><p>当开始跳跃时会进入JumpStart/RollStart（仅播放一次），播放完后进入滞空动画Jumping/Rolling（这段动画会循环播放），当落地时会进入JumpEnd/RollEnd动画</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// 起跳</span><br><span class="line">if (jumpPressDown &amp;&amp; collisionState.nearGround)</span><br><span class="line">&#123;</span><br><span class="line">    verticalVelocity = Mathf.Sqrt(2 * Mathf.Abs(gravity) * jumpHeight);</span><br><span class="line">    moveAfterJump = Mathf.Abs(moveInput.normalized.x) &lt; 0.3f;   // 判断起跳时移动速度</span><br><span class="line">    keepJump = true;</span><br><span class="line">    herizontalDirection = moveInput.x &gt; 0 ? 1 : -1;</span><br><span class="line"><span class="addition">+    if (moveAfterJump)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        animator.SetTrigger(&quot;Jump&quot;);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        animator.SetTrigger(&quot;FastJump&quot;);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">// 落地</span><br><span class="line">if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround)</span><br><span class="line">&#123;</span><br><span class="line"><span class="addition">+    if (moveAfterJump)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        animator.SetTrigger(&quot;FallLand&quot;);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        animator.SetTrigger(&quot;FastFallLand&quot;);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">    verticalVelocity = 0;</span><br><span class="line">    moveAfterJump = false;</span><br><span class="line">    keepJump = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E8%B7%B3%E8%B7%83%E5%8A%A8%E7%94%BB.gif" class="lazyload" data-srcset="/images/%E8%B7%B3%E8%B7%83%E5%8A%A8%E7%94%BB.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="跳跃动画"></p><h3 id="7-相机">7. 相机</h3><blockquote><p>使用插件Cinemachine，现在只做一个简易的版本</p></blockquote><p>在Hierarchy面板按右键——Cinemachine——Virtual Camera</p><p>设置虚拟相机，让其Follow角色，并设置死区</p><img src="/images/cinemachine.png" class="lazyload" data-srcset="/images/cinemachine.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cinemachine" style="zoom:50%;" /><p><img src="/images/cinemachine2.png" class="lazyload" data-srcset="/images/cinemachine2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cinemachine2"></p><p>效果如下（额，这跳跃的边缘检测还是有问题）</p><p><img src="/images/%E7%9B%B8%E6%9C%BA.gif" class="lazyload" data-srcset="/images/%E7%9B%B8%E6%9C%BA.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="相机"></p><h3 id="8-爬墙">8. 爬墙</h3><p>有的平台我们差一点点就能跳上去，我希望在这个边缘向左右拉动摇杆，可以实现爬墙的功能，暂时吸附在墙体上</p><p>在角色前添加一个空对象ClimbWallPoint（图中蓝色），在前上添加一个空对象PassablePoint（图中红色），这两个点将用于发射碰撞检测射线</p><p><img src="/images/%E7%88%AC%E5%A2%99%E7%82%B9.png" class="lazyload" data-srcset="/images/%E7%88%AC%E5%A2%99%E7%82%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="爬墙点"></p><p>修改<code>CollisionState.cs</code>脚本，添加爬墙检测逻辑</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">[SerializeField, Tooltip(&quot;靠近地表的检测距离&quot;)] private float nearDistance = 0.2f;</span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;爬墙检测点&quot;)] private Transform climbWallPoint;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;爬墙检测距离&quot;)] private float climbTestDistance = 0.2f;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;可通行检测点&quot;)] private Transform passablePoint;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;通行检测距离&quot;)] private float passableTestDistance = 1f;</span></span><br><span class="line"></span><br><span class="line">private float offset = 0.05f;</span><br><span class="line"><span class="addition">+private float lookRight;</span></span><br><span class="line"></span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    onGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, testDistance + offset, groundLayer);</span><br><span class="line">    nearGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, nearDistance + offset, groundLayer);</span><br><span class="line"><span class="addition">+    lookRight = (climbWallPoint.position.x - transform.position.x) &gt; 0 ? 1 : -1;</span></span><br><span class="line"><span class="addition">+    climbWall = Physics.Raycast(climbWallPoint.position, Vector3.right * lookRight, climbTestDistance, groundLayer);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+public bool GetPassable()</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+    bool passable = !Physics.Raycast(passablePoint.position, Vector3.right * lookRight, passableTestDistance, groundLayer);</span></span><br><span class="line"><span class="addition">+    return passable;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure><p>修改<code>PlayerController.cs</code>脚本，感觉角色状态越来越复杂，有些难以管理了，之后要做一个角色状态机</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private bool keepJump = false;  // 保持滞空</span><br><span class="line"><span class="addition">+private bool jumping = false;   // 处于跳跃状态</span></span><br><span class="line"><span class="addition">+private bool climbing = false;  // TODO: 角色状态机</span></span><br><span class="line"></span><br><span class="line">private void Update()&#123;</span><br><span class="line">...</span><br><span class="line">// 起跳</span><br><span class="line">    if (jumpPressDown &amp;&amp; collisionState.nearGround)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">        keepJump = true;</span><br><span class="line"><span class="addition">+        jumping = true;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...    </span><br><span class="line">if (!jumpPressed)</span><br><span class="line">    &#123;</span><br><span class="line">        keepJump = false;   // 松开后不能重新滞空</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+    // 爬墙</span></span><br><span class="line"><span class="addition">+    if (jumping &amp;&amp; collisionState.climbWall &amp;&amp; collisionState.GetPassable() &amp;&amp; Mathf.Abs(moveInput.normalized.x) &gt; 0.7)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        climbing = true;</span></span><br><span class="line"><span class="addition">+        verticalVelocity = 0;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        climbing = false;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line">    // 落地</span><br><span class="line">    if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        keepJump = false;</span><br><span class="line"><span class="addition">+        jumping = false;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f;</span><br><span class="line"><span class="addition">+    if (isMoving &amp;&amp; !climbing)</span></span><br><span class="line">    &#123;</span><br><span class="line">    float herizontalSpeed = Mathf.Abs(moveInput.normalized.x * movementSpeed);</span><br><span class="line">    ...</span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下（论动画的重要性）</p><p><img src="/images/%E7%88%AC%E5%A2%99.gif" class="lazyload" data-srcset="/images/%E7%88%AC%E5%A2%99.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="爬墙"></p><h3 id="9-抓墙动画">9. 抓墙动画</h3><p>我继续沿用老办法做抓墙动画，结果却发现手很难抓住墙壁，于是我改用Animation Rigging的方式实现</p><p><img src="/images/%E6%8A%93%E5%A2%99%E7%AC%AC%E4%B8%80%E7%89%88.gif" class="lazyload" data-srcset="/images/%E6%8A%93%E5%A2%99%E7%AC%AC%E4%B8%80%E7%89%88.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="抓墙第一版"></p><blockquote><p>骨骼的本质是矩阵树，运行时变化矩阵从根节点开始正向改变网格顶点（蒙皮），变化矩阵包含位移旋转缩放信息，Animation Rigging可以让部分骨骼不受动画影响，而是被反向动力学等方式驱动</p></blockquote><h4 id="安装插件">安装插件</h4><p>首先通过包管理器安装Animation Rigging，我们发现窗口上方出现了Animation Rigging栏</p><h4 id="配置Rig">配置Rig</h4><p>找到并选中角色后，点击Animation Rigging——Bone Renderer Setup，我们发现角色身上多了一个Bone Renderer组件，骨骼也被绘制出来</p><img src="/images/boneRender.png" class="lazyload" data-srcset="/images/boneRender.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="boneRender" style="zoom:50%;" /><img src="/images/boneRender2.png" class="lazyload" data-srcset="/images/boneRender2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="boneRender2" style="zoom:50%;" /><p>选中角色后点击Animation Rigging——Rig Setup，发现角色出现了一个子物体：Rig1</p><p>将Rig重命名为RigHand，并创建子节点RightHand，为RightHand添加组件Two Bone IK Constraint</p><p>再RightHand下面创建空的子节点，名叫Target，为了容易观察，让其拥有球形Shape</p><p><img src="/images/Target.gif" class="lazyload" data-srcset="/images/Target.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Target"></p><p>找到骨骼树中想要被反向驱动的三根骨骼，拖至Two Bone IK Constraint组件上，并将Target也拖到该组件上。现在播放动画，我们发现右手不会被动画驱动，而是被Target反向驱动</p><p><img src="/images/rig.gif" class="lazyload" data-srcset="/images/rig.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="rig"></p><p>通常状态不需要Rig，于是我们将Rig的权重设为0</p><h4 id="脚本设置手部落地">脚本设置手部落地</h4><p>修改脚本<code>CollisionState.cs</code>，添加手与墙壁的相交位置</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">public bool GetPassable()</span><br><span class="line">&#123;</span><br><span class="line">    bool passable = !Physics.Raycast(passablePoint.position, Vector3.right * lookRight, passableTestDistance, groundLayer);</span><br><span class="line">    return passable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+public Vector3 GetClimbTouchPosition()</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+    Ray ray = new Ray(climbWallPoint.position, Vector3.right * lookRight);</span></span><br><span class="line"><span class="addition">+    Physics.Raycast(ray, out RaycastHit hit);</span></span><br><span class="line"><span class="addition">+    return hit.point;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure><p>修改脚本<code>PlayerController.cs</code>，实现贴墙时修改Target的位置和Rig权重</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">[SerializeField, Tooltip(&quot;开始加速下落时的速度&quot;)] </span><br><span class="line">private float fallingSpeedup = 10f;</span><br><span class="line"></span><br><span class="line"><span class="addition">+[SerializeField] private Transform rightHandPosition;</span></span><br><span class="line"><span class="addition">+[SerializeField] private Rig rightHandRig;</span></span><br><span class="line"></span><br><span class="line">private Vector2 moveInput;</span><br><span class="line">...</span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">// 爬墙</span><br><span class="line">    if (jumping &amp;&amp; collisionState.climbWall &amp;&amp; collisionState.GetPassable() &amp;&amp; Mathf.Abs(moveInput.normalized.x) &gt; 0.7)</span><br><span class="line">    &#123;</span><br><span class="line">        climbing = true;</span><br><span class="line">        verticalVelocity = 0;</span><br><span class="line"><span class="addition">+        rightHandPosition.position = collisionState.GetClimbTouchPosition();</span></span><br><span class="line"><span class="addition">+        rightHandPosition.rotation = Quaternion.LookRotation(moveInput.x &gt; 0 ? Vector3.right : Vector3.left);</span></span><br><span class="line"><span class="addition">+        rightHandRig.weight = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        climbing = false;</span><br><span class="line"><span class="addition">+        rightHandRig.weight = 0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%8A%93%E5%A2%99%E7%AC%AC%E4%BA%8C%E7%89%88.gif" class="lazyload" data-srcset="/images/%E6%8A%93%E5%A2%99%E7%AC%AC%E4%BA%8C%E7%89%88.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="抓墙第二版"></p><p>尽管还存在臂力惊人单手悬空的问题，但相比上一版已经好了不少</p><h3 id="10-上平台">10. 上平台</h3><p>抓墙的目的自然是为了上平台，修改<code>PlayerController.cs</code>脚本</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">[SerializeField, Tooltip(&quot;开始加速下落时的速度&quot;)] </span><br><span class="line">private float fallingSpeedup = 10f;</span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;爬墙时向上跳的初速度&quot;)]</span></span><br><span class="line"><span class="addition">+private float climbingJumpSpeed = 10f;</span></span><br><span class="line">...</span><br><span class="line">private bool climbing = false;  // TODO: 角色状态机</span><br><span class="line"><span class="addition">+private bool climbingJump = false;  // 抓墙时跳跃</span></span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // 起跳</span><br><span class="line">    if (jumpPressDown &amp;&amp; collisionState.nearGround)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">        jumping = true;</span><br><span class="line"><span class="addition">+        climbingJump = false;</span></span><br><span class="line">        if (moveAfterJump)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetTrigger(&quot;Jump&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    // 爬墙</span><br><span class="line"><span class="addition">+    if (jumping &amp;&amp; collisionState.climbWall &amp;&amp; collisionState.GetPassable() &amp;&amp; Mathf.Abs(moveInput.normalized.x) &gt; 0.7 &amp;&amp; !climbingJump)</span></span><br><span class="line">    &#123;</span><br><span class="line">        climbing = true;</span><br><span class="line">        verticalVelocity = 0;</span><br><span class="line">        rightHandPosition.position = collisionState.GetClimbTouchPosition();</span><br><span class="line">        rightHandPosition.rotation = Quaternion.LookRotation(moveInput.x &gt; 0 ? Vector3.right : Vector3.left);</span><br><span class="line">        rightHandRig.weight = 1;</span><br><span class="line"><span class="addition">+        animator.SetBool(&quot;Climbing&quot;, climbing);</span></span><br><span class="line"><span class="addition">+        if (jumpPressDown)</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            rightHandRig.weight = 0;</span></span><br><span class="line"><span class="addition">+            verticalVelocity = climbingJumpSpeed;</span></span><br><span class="line"><span class="addition">+            animator.SetTrigger(&quot;ClimbingUp&quot;);</span></span><br><span class="line"><span class="addition">+            climbingJump = true;</span></span><br><span class="line"><span class="addition">+            climbing = false;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        climbing = false;</span><br><span class="line">        rightHandRig.weight = 0;</span><br><span class="line"><span class="addition">+        animator.SetBool(&quot;Climbing&quot;, climbing);</span></span><br><span class="line">    &#125;</span><br><span class="line">    // 落地</span><br><span class="line">    if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">        jumping = false;</span><br><span class="line"><span class="addition">+        climbingJump = false;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>感觉状态已经麻烦到难以管理了，是时候重构状态机了</p></blockquote><p><img src="/images/%E7%88%AC%E5%A2%99%E4%B8%8A%E5%B9%B3%E5%8F%B0.gif" class="lazyload" data-srcset="/images/%E7%88%AC%E5%A2%99%E4%B8%8A%E5%B9%B3%E5%8F%B0.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="爬墙上平台"></p><h3 id="11-瞄准射击">11. 瞄准射击</h3><h4 id="建模">建模</h4><p>首先打开blender</p><ol><li>创建一个圆柱1，按tab进入编辑模式，选中上表面，按s将上表面进行缩放，变成一个类似“圆锥”的东西</li><li>在圆锥上侧创建一个球，下侧创建一个圆柱2</li><li>使用布尔操作，球布尔Difference，圆柱2布尔Union（注意操作后隐藏球和圆柱）</li></ol><p><img src="/images/%E5%B8%83%E5%B0%94%E5%BB%BA%E6%A8%A12.gif" class="lazyload" data-srcset="/images/%E5%B8%83%E5%B0%94%E5%BB%BA%E6%A8%A12.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="布尔建模2"></p><p>于是得到了枪的建模（相当粗糙）</p><img src="/images/布尔建模.png" class="lazyload" data-srcset="/images/布尔建模.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="布尔建模" style="zoom:50%;" /><p>你可以为模型添加材质</p><img src="/images/模型材质.png" class="lazyload" data-srcset="/images/模型材质.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="模型材质" style="zoom:50%;" /><p>将模型导出至Unity后</p><img src="/images/Gun.png" class="lazyload" data-srcset="/images/Gun.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Gun" style="zoom:50%;" /><h4 id="持枪">持枪</h4><p>将枪放在左臂骨骼处，于是实现了左手和枪的绑死，播放动画时枪也跟着动，不过做的有些穿模</p><img src="/images/持枪2.png" class="lazyload" data-srcset="/images/持枪2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="持枪2" style="zoom:50%;" /><p>枪能随着手部正常运动</p><p><img src="/images/%E6%8C%81%E6%9E%AA%E5%8A%A8%E7%94%BB.gif" class="lazyload" data-srcset="/images/%E6%8C%81%E6%9E%AA%E5%8A%A8%E7%94%BB.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="持枪动画"></p><h4 id="瞄准">瞄准</h4><ol><li>动画状态机添加瞄准动画</li><li>Input System绑定左肩键为Aiming</li></ol><img src="/images/InputBumping.png" class="lazyload" data-srcset="/images/InputBumping.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="InputBumping" style="zoom:50%;" /><ol start="3"><li>为持枪的手臂添加Rig</li></ol><img src="/images/枪rig.png" class="lazyload" data-srcset="/images/枪rig.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="枪rig" style="zoom:50%;" /><ol start="4"><li>修改脚本<code>PlayerController.cs</code>，按下左肩键后手臂水平前举，根据左摇杆输入以角色左肩膀为圆心画圆，此外我希望瞄准时角色不要移动</li></ol><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+[SerializeField] private Transform gunHandPosition;</span></span><br><span class="line"><span class="addition">+[SerializeField] private Rig gunHandRig;</span></span><br><span class="line"><span class="addition">+[SerializeField] private Transform gunAimCenter;</span></span><br><span class="line"><span class="addition">+[SerializeField, Tooltip(&quot;枪距离角色肩膀的距离&quot;)] private float gunToShoulderDistance = 2f;</span></span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">private bool jumpPressDown = false;</span><br><span class="line"><span class="addition">+private bool aiming = false;</span></span><br><span class="line">...</span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    jumpPressed = input.actions[&quot;Jump&quot;].IsPressed();</span><br><span class="line"><span class="addition">+    aiming = input.actions[&quot;Aim&quot;].IsPressed();</span></span><br><span class="line">...</span><br><span class="line">#region 水平移动</span><br><span class="line"></span><br><span class="line">    bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f;</span><br><span class="line">    if (isMoving &amp;&amp; !climbing)</span><br><span class="line">    &#123;</span><br><span class="line">        float herizontalSpeed = Mathf.Abs(moveInput.normalized.x * movementSpeed);</span><br><span class="line"></span><br><span class="line">        float hDir = moveInput.x &gt; 0 ? 1 : -1;</span><br><span class="line">        if (moveAfterJump)</span><br><span class="line">        &#123;</span><br><span class="line">            herizontalSpeed /= 2;   // 原地起跳，在空中动能很少，按理说应该走不动</span><br><span class="line">        &#125;</span><br><span class="line"><span class="addition">+        if (!aiming)</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line">            controller.Move(Vector3.right * hDir * herizontalSpeed * Time.deltaTime);</span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line">        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(moveInput.x != 0 ? Vector3.right * moveInput.normalized.x : Vector3.right * hDir), 0.1f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    animator.SetFloat(&quot;MoveInput&quot;, Mathf.Abs(moveInput.normalized.x * movementSpeed), 0.2f, Time.deltaTime);</span><br><span class="line">    #endregion</span><br><span class="line"></span><br><span class="line"><span class="addition">+    #region 瞄准射击</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    if (aiming)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+       Vector3 targetPos;</span></span><br><span class="line"><span class="addition">+        if (moveInput.magnitude &lt; 0.1f)</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;</span></span><br><span class="line"><span class="addition">+            targetPos = new Vector3(gunAimCenter.position.x + gunToShoulderDistance * hDir, gunAimCenter.position.y, gunAimCenter.position.z);</span></span><br><span class="line"><span class="addition">+            gunHandPosition.position = targetPos;</span></span><br><span class="line"><span class="addition">+            gunHandPosition.rotation = Quaternion.LookRotation(new Vector3(1,-1,0));</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        else</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;</span></span><br><span class="line"><span class="addition">+            targetPos = new Vector3(gunAimCenter.position.x + gunToShoulderDistance * moveInput.normalized.x, gunAimCenter.position.y + gunToShoulderDistance * moveInput.normalized.y, gunAimCenter.position.z);</span></span><br><span class="line"><span class="addition">+            gunHandPosition.position = targetPos;</span></span><br><span class="line"><span class="addition">+            gunHandPosition.rotation = Quaternion.LookRotation(targetPos - gunAimCenter.position);</span></span><br><span class="line"><span class="addition">+            gunHandPosition.Rotate(90f, 0f, 0f);</span></span><br><span class="line"><span class="addition">+ animator.SetBool(&quot;Aiming&quot;, true);</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        gunHandRig.weight = 0;</span></span><br><span class="line"><span class="addition">+ animator.SetBool(&quot;Aiming&quot;, false);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+    #endregion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E7%9E%84%E5%87%86%E5%8A%A8%E7%94%BB.gif" class="lazyload" data-srcset="/images/%E7%9E%84%E5%87%86%E5%8A%A8%E7%94%BB.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="瞄准动画"></p><p>稍微有些生硬，不过另一只手之后要拿近战武器，所以还好。</p><h4 id="瞄准辅助线">瞄准辅助线</h4><p>在角色身上添加LineRenderer组件，设置组件的线Width、材质</p><img src="/images/线渲染器.png" class="lazyload" data-srcset="/images/线渲染器.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线渲染器" style="zoom:50%;" /><p>修改脚本<code>PlayerController.cs</code></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private CollisionState collisionState;</span><br><span class="line"><span class="addition">+private LineRenderer lineRenderer;</span></span><br><span class="line">...</span><br><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    collisionState = GetComponent&lt;CollisionState&gt;();</span><br><span class="line"><span class="addition">+    lineRenderer = GetComponent&lt;LineRenderer&gt;();</span></span><br><span class="line">&#125;</span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">if (aiming)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 targetPos;</span><br><span class="line"><span class="addition">+        Vector3 deltaPos;</span></span><br><span class="line">        if (moveInput.magnitude &lt; 0.1f)</span><br><span class="line">        &#123;</span><br><span class="line">            float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;</span><br><span class="line"><span class="addition">+            deltaPos = new Vector3(gunToShoulderDistance * hDir, 0, 0);</span></span><br><span class="line"><span class="addition">+            targetPos = gunAimCenter.position + deltaPos;</span></span><br><span class="line">            gunHandPosition.position = targetPos;</span><br><span class="line">            gunHandPosition.rotation = Quaternion.LookRotation(new Vector3(1,-1,0));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;</span><br><span class="line"><span class="addition">+            deltaPos = new Vector3(gunToShoulderDistance * moveInput.normalized.x, gunToShoulderDistance * moveInput.normalized.y, 0);</span></span><br><span class="line"><span class="addition">+            targetPos = gunAimCenter.position + deltaPos;</span></span><br><span class="line">            gunHandPosition.position = targetPos;</span><br><span class="line">            gunHandPosition.rotation = Quaternion.LookRotation(targetPos - gunAimCenter.position);</span><br><span class="line">            gunHandPosition.Rotate(90f, 0f, 0f);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="addition">+        lineRenderer.SetPositions(new []&#123;targetPos, targetPos + deltaPos * 12&#125;);</span></span><br><span class="line"><span class="addition">+        lineRenderer.enabled = true;</span></span><br><span class="line">        animator.SetBool(&quot;Aiming&quot;, true);</span><br><span class="line">        gunHandRig.weight = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"><span class="addition">+        lineRenderer.enabled = false;</span></span><br><span class="line">        gunHandRig.weight = 0;</span><br><span class="line">        animator.SetBool(&quot;Aiming&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/激光.png" class="lazyload" data-srcset="/images/激光.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="激光" style="zoom:50%;" /><h4 id="发射子弹">发射子弹</h4><ol><li><p>Input System将手柄X键绑定为Fire开火键</p></li><li><p>使用Sphere创建子弹预制体，注意关闭阴影、重力，材质我选用了一个自发光的半透明材质，并为子弹添加了一个碰撞层Bullet，同时设置其Tag为Bullet，碰撞体采用Trigger</p></li><li><p>编写子弹脚本<code>Bullet.cs</code>，子弹在碰撞到物体时会被销毁，超过一段时间后也会被销毁（具体的碰撞逻辑之后再写）</p></li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bullet</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;子弹销毁时间&quot;</span>)</span>] <span class="keyword">private</span> <span class="built_in">float</span> lifeTime = <span class="number">5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> remainingTime;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        remainingTime = lifeTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        remainingTime -= Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (remainingTime &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>编写子弹发射脚本<code>FireManager.cs</code></li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FireManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;子弹速度&quot;</span>)</span>] <span class="keyword">private</span> <span class="built_in">float</span> bulletSpeed = <span class="number">10f</span>;</span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;普通子弹&quot;</span>)</span>] <span class="keyword">private</span> GameObject commonBullet;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FireCommonBullet</span>(<span class="params">Vector3 initPosition, Quaternion initRotation</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject bullet = Instantiate(commonBullet, initPosition, initRotation);</span><br><span class="line">        bullet.GetComponent&lt;Rigidbody&gt;().AddForce(bullet.transform.forward * bulletSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>修改<code>PlayerController.cs</code></li></ol><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private LineRenderer lineRenderer;</span><br><span class="line"><span class="addition">+private FireManager fireManager;</span></span><br><span class="line">...</span><br><span class="line">private bool aiming = false;</span><br><span class="line"><span class="addition">+private bool firePressDown = false;</span></span><br><span class="line">...</span><br><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    lineRenderer = GetComponent&lt;LineRenderer&gt;();</span><br><span class="line"><span class="addition">+    fireManager = GetComponent&lt;FireManager&gt;();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">aiming = input.actions[&quot;Aim&quot;].IsPressed();</span><br><span class="line"><span class="addition">+    firePressDown = input.actions[&quot;Fire&quot;].WasPressedThisFrame();</span></span><br><span class="line">if (aiming)</span><br><span class="line">    &#123;</span><br><span class="line">        #region 瞄准动作</span><br><span class="line"></span><br><span class="line">        Vector3 targetPos;</span><br><span class="line">        Vector3 deltaPos;</span><br><span class="line">        if (moveInput.magnitude &lt; 0.1f)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line"><span class="addition">+        #region 射击</span></span><br><span class="line"><span class="addition">+        if (firePressDown)</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            fireManager.FireCommonBullet(targetPos, Quaternion.LookRotation(targetPos - gunAimCenter.position));</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        #endregion</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GIF的帧率太低了。。。</p></blockquote><p><img src="/images/%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9.gif" class="lazyload" data-srcset="/images/%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="发射子弹"></p><blockquote><p>注意，现在角色跳跃是也能射击，爬墙时也能射击，但是抓墙时不能自由射击，因为反向后角色会掉下来。我在考虑是否在跳跃时射击添加时停，抓墙时添加按左肩键可以自由射击，不会掉下来。</p><p>银河战士抓墙后不需要一直按左摇杆，可以自由射击，但银河战士是可以变成一格高的球的，有些狭小的管道正常姿势无法射击，于是设计了抓墙射击。而我不打算做变成球，我所有的通道都至少两格宽，很纠结</p></blockquote><h3 id="12-可被射击破环的方块">12. 可被射击破环的方块</h3><h4 id="方块预制体">方块预制体</h4><p>首先创建可被射击的方块预制体，拥有碰撞盒、VFX和一个脚本</p><img src="/images/可被射击方块.png" class="lazyload" data-srcset="/images/可被射击方块.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="可被射击方块" style="zoom:50%;" /><p>创建脚本<code>InteractiveCube.cs</code>，我希望当方块被子弹击中时会隐藏渲染和碰撞，并播放粒子效果，一段时间后再复原</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InteractiveCube</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> recoverTime = <span class="number">20f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> MeshRenderer meshRenderer;</span><br><span class="line">    <span class="keyword">private</span> Collider boxcollider;</span><br><span class="line">    <span class="keyword">private</span> VisualEffect visualEffect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentDeadTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        meshRenderer = GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">        boxcollider = GetComponent&lt;Collider&gt;();</span><br><span class="line">        visualEffect = GetComponent&lt;VisualEffect&gt;();</span><br><span class="line">        visualEffect.Stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collision other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.gameObject.CompareTag(<span class="string">&quot;Bullet&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            meshRenderer.enabled = <span class="literal">false</span>;</span><br><span class="line">            boxcollider.enabled = <span class="literal">false</span>;</span><br><span class="line">            visualEffect.Play();</span><br><span class="line">            currentDeadTime = recoverTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentDeadTime &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentDeadTime -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (currentDeadTime &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                meshRenderer.enabled = <span class="literal">true</span>;</span><br><span class="line">                boxcollider.enabled = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特效">特效</h4><blockquote><p>现在的特效是随便做的，之后要重写，我希望方块被射击会有破碎效果，复原时会有溶解效果</p><p>破碎效果使用Unity VFX插件</p></blockquote><p>首先去Package Manager安装Visual Effect Graph</p><p>右键Visual Effect——Visual Effect Graph，创建一个特效，双击后进入面板，配置为单次发射（Single Burst）、设置发射方向、粒子生命周期、添加重力</p><img src="/images/粒子特效.png" class="lazyload" data-srcset="/images/粒子特效.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="粒子特效" style="zoom:50%;" /><blockquote><p>有点绷不住了</p></blockquote><p><img src="/images/%E5%B0%84%E5%87%BB%E6%96%B9%E5%9D%97.gif" class="lazyload" data-srcset="/images/%E5%B0%84%E5%87%BB%E6%96%B9%E5%9D%97.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="射击方块"></p><h3 id="13-近战攻击">13. 近战攻击</h3><p>近战攻击相当复杂，我问了几个动作策划，给了我好几种方法：</p><ul><li>在武器上绑定胶囊体碰撞盒</li><li>在武器附近射线检测</li><li>在打击区域绘制方形碰撞盒</li><li>逐帧修改判定区域</li><li>怪物读玩家指令</li></ul><img src="/images/动作碰撞盒.jpg" class="lazyload" data-srcset="/images/动作碰撞盒.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="动作碰撞盒" style="zoom:50%;" /><p>在银河战士里，近战多用于反击远程单位（我的游戏也是这样设计的），感觉做成读指令会更方便。但我又想</p><h4 id="Timeline">Timeline</h4><blockquote><p>Timeline是Unity的时间线工具，常用于制作过场动画、相机蒙太奇，我们这里用来制作打击动作</p></blockquote><p>打开Timeline面板</p><img src="/images/timeline.png" class="lazyload" data-srcset="/images/timeline.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="timeline" style="zoom:50%;" /><p>为角色创建Timeline（此时角色身上会添加PlayableDirector组件），将近战动画clip拖入时间线中，并设置动画的Ease In/Out，这样可以使得Timeline动画和动画状态机的动画混合</p><img src="/images/easeInOut.png" class="lazyload" data-srcset="/images/easeInOut.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="easeInOut" style="zoom:50%;" /><blockquote><p>注意要关掉Timeline的Play On Awake</p></blockquote><p>我们在角色面前创建一个方形碰撞区域（有着Box Collider和锁死旋转和位移的Rigidbody），添加Tag为Hit，并默认设为unactive。</p><img src="/images/创建碰撞区域.png" class="lazyload" data-srcset="/images/创建碰撞区域.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="创建碰撞区域" style="zoom:50%;" /><img src="/images/碰撞区域.png" class="lazyload" data-srcset="/images/碰撞区域.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="碰撞区域" style="zoom:50%;" /><p>在Timeline中创建Control Track，在片段期间该物体将设为活跃，结束后恢复隐藏</p><p><img src="/images/timeline%E5%8A%A8%E4%BD%9C.png" class="lazyload" data-srcset="/images/timeline%E5%8A%A8%E4%BD%9C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="timeline动作"></p><p>点击播放键可以预览效果</p><h4 id="控制">控制</h4><p>修改脚本<code>PlayerController.cs</code></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">private FireManager fireManager;</span><br><span class="line"><span class="addition">+private PlayableDirector director;</span></span><br><span class="line">...</span><br><span class="line">private bool firePressDown = false;</span><br><span class="line"><span class="addition">+private bool hitPressDown = false;</span></span><br><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="addition">+    director = GetComponent&lt;PlayableDirector&gt;();</span></span><br><span class="line">&#125;</span><br><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="addition">+hitPressDown = input.actions[&quot;Hit&quot;].WasPressedThisFrame();</span></span><br><span class="line">...</span><br><span class="line"><span class="addition">+if (hitPressDown &amp;&amp; collisionState.onGround)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        director.Play();</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E8%BF%91%E6%88%98.gif" class="lazyload" data-srcset="/images/%E8%BF%91%E6%88%98.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="近战"></p><h3 id="14-可被近战破坏的方块">14. 可被近战破坏的方块</h3><p>修改脚本<code>InteractiveCube.cs</code></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+public enum CubeType</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+    Shoot,</span></span><br><span class="line"><span class="addition">+    Hit</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line">public class InteractibleCube : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    [SerializeField] private float recoverTime = 20f;</span><br><span class="line"><span class="addition">+    [SerializeField] private CubeType cubeType;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="addition">+    private string TagName</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        get</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            if(cubeType == CubeType.Shoot)</span></span><br><span class="line"><span class="addition">+                return &quot;Bullet&quot;;</span></span><br><span class="line"><span class="addition">+            else</span></span><br><span class="line"><span class="addition">+                return &quot;Hit&quot;;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">...</span><br><span class="line">    private void OnTriggerEnter(Collision other)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="addition">+        if (other.gameObject.CompareTag(TagName))</span></span><br><span class="line">        &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E8%BF%91%E6%88%98%E6%96%B9%E5%9D%97.gif" class="lazyload" data-srcset="/images/%E8%BF%91%E6%88%98%E6%96%B9%E5%9D%97.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="近战方块"></p><h3 id="15-零美术成本更换角色模型">15. 零美术成本更换角色模型</h3><blockquote><p>适合完全不会绑骨刷权重K帧的非美术，mmd的模型骨骼一般都十分复杂，并且和mixamo不一致</p></blockquote><p>去模之屋等网站获取mmd模型，导入blender中（详情可见blender mmd tools），个人建议选择短发角色</p><p>将角色姿态设为T Pose（你可以进入姿态模式，用手掰，可以放一个水平盒子当辅助线），T Pose很重要！</p><p>导出<strong>仅含网格</strong>的fbx模型</p><img src="/images/TPose.png" class="lazyload" data-srcset="/images/TPose.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TPose" style="zoom:50%;" /><p>打开mixamo，选择小红人，点击UPLOAD CHARACTOR（导入模型），按步骤完成</p><img src="/images/选择小红人.png" class="lazyload" data-srcset="/images/选择小红人.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="选择小红人" style="zoom:50%;" /><p>即可得到自动绑骨刷权重的角色模型，并能够完美使用mixamo的动画</p><img src="/images/mixamo导入模型.png" class="lazyload" data-srcset="/images/mixamo导入模型.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="mixamo导入模型" style="zoom:50%;" /><blockquote><p>我这里除了更换角色模型外，还使用了卡渲Shader和后效，网上关于卡渲的项目和教程相当多，这里就按下不表了</p></blockquote><p><img src="/images/%E6%9B%B4%E6%8D%A2%E8%A7%92%E8%89%B2%E6%A8%A1%E5%9E%8B.gif" class="lazyload" data-srcset="/images/%E6%9B%B4%E6%8D%A2%E8%A7%92%E8%89%B2%E6%A8%A1%E5%9E%8B.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="更换角色模型"></p><h3 id="16-地面敌人AI">16. 地面敌人AI</h3><blockquote><p>使用插件Behavior Trees，Asset Store 45刀，参考<a href="https://www.youtube.com/watch?v=X7VwAGvAOIw">空洞骑士BOSS战</a></p><p>敌人移动混用了DoTween插件和Charactor Controller</p><p>感觉这一节用文字讲好乏力。。。</p></blockquote><h4 id="创建角色单例">创建角色单例</h4><p>创建脚本<code>PlayerInfo.cs</code>，并将其绑定到Player上，该脚本控制了角色血量和是否处于无敌状态</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerInfo</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 单例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PlayerInfo instance;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PlayerInfo</span>()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Health &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = <span class="number">100f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Prop</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;处于无敌状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> invincible = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;无敌时间&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> invincibleTime = <span class="number">2f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;无敌时闪烁间隔时间&quot;</span>)</span>] </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> blinkTime = <span class="number">0.1f</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">SerializeField, Tooltip(<span class="string">&quot;角色渲染&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> SkinnedMeshRenderer playerRenderer;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Member</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无敌还剩多长时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentInvincibleTime = <span class="number">0f</span>;</span><br><span class="line">    <span class="comment">// 闪烁控制时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentBlinkTime = <span class="number">0.1f</span>;</span><br><span class="line">    <span class="comment">// 闪烁控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> blinkVisible = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PlayerInfo Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = FindObjectOfType&lt;PlayerInfo&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 PlayerPosition</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> transform.position;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HitPlayer</span>(<span class="params"><span class="built_in">float</span> damage, Vector3 enemyPosition</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invincible)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Vector3 moveDirection = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(enemyPosition.x &gt; transform.position.x)</span><br><span class="line">        &#123;</span><br><span class="line">            moveDirection.x = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            moveDirection.x = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gameObject.GetComponent&lt;CharacterController&gt;().Move(moveDirection);</span><br><span class="line">        Health -= damage;</span><br><span class="line">        currentInvincibleTime = invincibleTime;</span><br><span class="line">        currentBlinkTime = blinkTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(currentInvincibleTime &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            invincible = <span class="literal">true</span>;</span><br><span class="line">            currentInvincibleTime -= Time.deltaTime;</span><br><span class="line">            currentBlinkTime -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(currentBlinkTime &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                currentBlinkTime = blinkTime;</span><br><span class="line">                blinkVisible = !blinkVisible;</span><br><span class="line">                playerRenderer.enabled = blinkVisible;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            invincible = <span class="literal">false</span>;</span><br><span class="line">            playerRenderer.enabled = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建敌人">创建敌人</h4><p>创建脚本<code>EnemyInfo.cs</code>，并挂到敌人身上，此外敌人身上同时挂在Character Controller、Animator、Behaviour（这个稍后再讲）、BoxCollider（这个碰撞盒是用于被攻击的）</p><p>添加碰撞层Enemy，并将敌人设为Enemy（在项目设置中，设置Enemy和玩家不发生碰撞）</p><img src="/images/敌人信息2.png" class="lazyload" data-srcset="/images/敌人信息2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="敌人信息2" style="zoom:50%;" /><img src="/images/敌人信息.png" class="lazyload" data-srcset="/images/敌人信息.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="敌人信息" style="zoom:50%;" /><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyInfo</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxHealth = <span class="number">30.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentHealth;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> findPlayerDistance = <span class="number">10.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmos</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.color = Color.red;</span><br><span class="line">        Gizmos.DrawWireSphere(transform.position, findPlayerDistance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.tag == <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth -= other.GetComponent&lt;Bullet&gt;().damage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建敌人攻击碰撞球">创建敌人攻击碰撞球</h4><blockquote><p>我们将敌人受攻击（Box）、敌人和场景的碰撞（CC）、敌人攻击玩家的碰撞（Sphere）分开了</p></blockquote><p>为敌人创建一个子物体叫HitSphere，拥有一个球形碰撞盒和一个碰撞处理脚本，该碰撞球用于攻击玩家</p><p>添加碰撞层EnemyHit，该碰撞层仅和玩家碰撞</p><img src="/images/HitSphere.png" class="lazyload" data-srcset="/images/HitSphere.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="HitSphere" style="zoom:50%;" /><p>创建脚本<code>EnemyHitCube.cs</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyHitCube</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> playerInfo = other.GetComponent&lt;PlayerInfo&gt;();</span><br><span class="line">        <span class="keyword">if</span> (playerInfo != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            playerInfo.HitPlayer(<span class="number">10</span>, transform.position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建行为树">创建行为树</h4><p>寻找敌人后打开Behaviour Designer面板，添加任意行为后敌人身上会出现一个Behaviour Tree组件</p><p><img src="/images/%E8%A1%8C%E4%B8%BA%E6%A0%91.png" class="lazyload" data-srcset="/images/%E8%A1%8C%E4%B8%BA%E6%A0%91.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="行为树"></p><p>行为树是由一个个节点组成，当这些节点被执行时，会向其父节点返回执行成功、失败、正在执行等结果</p><ul><li><p>Repeater表示循环执行（我开启了无限循环）</p></li><li><p>Selector是一个或组件，其子节点从左向右开始执行，只要有一个为成功，则返回成功</p></li><li><p>Sequence表示顺序执行，其子节点从左向右执行，直到一个节点返回失败</p></li></ul><p>我为怪物添加了三个行为：</p><ol><li>血量小于0时<code>IsHealthUnder</code>，播放死亡动画，并销毁GameObject</li><li>否则<ol><li>若敌人周围有玩家<code>IsFindPlayer</code>，则追逐玩家<code>EnemyPursuit</code></li><li>否则在周围徘徊<code>EnemyMove</code></li></ol></li></ol><h4 id="创建敌人行为和条件基类">创建敌人行为和条件基类</h4><p>创建脚本<code>EnemyAction.cs</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyAction</span> : <span class="title">Action</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Animator animator;</span><br><span class="line">    <span class="keyword">protected</span> EnemyInfo info;</span><br><span class="line">    <span class="keyword">protected</span> CharacterController controller;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnAwake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        info = GetComponent&lt;EnemyInfo&gt;(); </span><br><span class="line">        controller = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建脚本<code>EnemyConditional.cs</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyConditional</span>: <span class="title">Conditional</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> EnemyInfo info;</span><br><span class="line">    <span class="keyword">protected</span> Animator animator;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnAwake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        info = GetComponent&lt;EnemyInfo&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建角色移动、追击、死亡行为">创建角色移动、追击、死亡行为</h4><p>创建脚本<code>EnemyMove.cs</code>，该脚本能使得敌人左右徘徊</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyMove</span> : <span class="title">EnemyAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> SharedBool lookRight;</span><br><span class="line">    <span class="keyword">public</span> SharedFloat currentMoveTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveUseTime = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> rotateUseTime = <span class="number">0.5f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Tween rotateTween;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TaskStatus <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> direction = lookRight.Value ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        currentMoveTime.Value += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (currentMoveTime.Value &gt; moveUseTime)</span><br><span class="line">        &#123;</span><br><span class="line">            lookRight.Value = !lookRight.Value;</span><br><span class="line">            currentMoveTime.Value = <span class="number">0</span>;</span><br><span class="line">            rotateTween = DOVirtual.DelayedCall(<span class="number">0</span>, () =&gt; transform.DORotateQuaternion(Quaternion.LookRotation(Vector3.right * -direction), rotateUseTime), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        controller.Move(Vector3.right * direction * moveSpeed * Time.deltaTime);</span><br><span class="line">        <span class="keyword">return</span> TaskStatus.Success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建脚本<code>EnemyPursuit.cs</code>，该脚本能使得敌人向玩家追击</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyPursuit</span> : <span class="title">EnemyAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> rotateUseTime = <span class="number">0.5f</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TaskStatus <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> direction = PlayerInfo.Instance.PlayerPosition.x &gt; transform.position.x ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        DOVirtual.DelayedCall(<span class="number">0</span>, () =&gt; transform.DORotateQuaternion(Quaternion.LookRotation(Vector3.right * direction), rotateUseTime), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        controller.Move(Vector3.right * direction * moveSpeed * Time.deltaTime);</span><br><span class="line">        <span class="keyword">return</span> TaskStatus.Success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建脚本<code>EnemyDead.cs</code>，该脚本能使敌人死亡</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyDead</span> : <span class="title">EnemyAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> deadDelayTime = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isDeadFinish = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        DOVirtual.DelayedCall(deadDelayTime, () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Object.Destroy(gameObject);</span><br><span class="line">            isDeadFinish = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TaskStatus <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> isDeadFinish ? TaskStatus.Success : TaskStatus.Running;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建敌人行为条件">创建敌人行为条件</h4><p>创建脚本<code>IsFindPlayer.cs</code>，该脚本用于判断敌人周围是否有角色，如果是刚刚发现，会出发一段动画</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IsFindPlayer</span> : <span class="title">EnemyConditional</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> SharedBool firstFindPlayer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TaskStatus <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((transform.position - PlayerInfo.Instance.PlayerPosition).magnitude &lt; info.findPlayerDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstFindPlayer.Value)</span><br><span class="line">            &#123;</span><br><span class="line">                animator.SetTrigger(<span class="string">&quot;FindPlayer&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            firstFindPlayer.Value = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> TaskStatus.Success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            firstFindPlayer.Value = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> TaskStatus.Failure;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建脚本<code>IsHealthUnder.cs</code>，该脚本用于判断角色血量是否低于某个数值</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IsHealthUnder</span> : <span class="title">EnemyConditional</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> underNumber = <span class="number">0f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TaskStatus <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.currentHealth &lt;= underNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TaskStatus.Success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TaskStatus.Failure;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果">效果</h4><p><img src="/images/%E6%80%AA%E7%89%A9AI.gif" class="lazyload" data-srcset="/images/%E6%80%AA%E7%89%A9AI.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="怪物AI"></p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有意思的代码</title>
      <link href="/program/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>/program/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1>有意思的代码</h1><p>记录一下平时遇到的有意思的代码，不定期更新</p><h3 id="在注释中的立方体">在注释中的立方体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="number">001</span>-----<span class="number">-101</span></span><br><span class="line">   / |     / |</span><br><span class="line">  /  |    /  |</span><br><span class="line"><span class="number">011</span>-----<span class="number">-111</span> |</span><br><span class="line"> |  <span class="number">000</span>--|-<span class="number">-100</span></span><br><span class="line"> |  /    |  /</span><br><span class="line"> | /     | /</span><br><span class="line"><span class="number">010</span>-----<span class="number">-110</span></span><br></pre></td></tr></table></figure><h3 id="消除未使用变量">消除未使用变量</h3><blockquote><p>有人会认为C++的警告（Warming）等同于报错，于是会通过一些宏关掉一些警告</p></blockquote><p>将变量转化为void类型，相当于明确告诉编译器我不打算使用这个变量，消除“变量未使用”的警告</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNUSED(x) (void)(x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="built_in">UNUSED</span>(x);<span class="comment">// 不使用x</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速Acos">快速Acos</h3><p>Acos是一个常见的三角函数，其作用是将[-1, 1]的值转换为所对应的弧度</p><p>这个是一个使用Eberly的一阶多项式逼近计算反余弦函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max absolute error 9.0x10^-3</span></span><br><span class="line"><span class="comment">// Eberly&#x27;s polynomial degree 1 - respect bounds</span></span><br><span class="line"><span class="comment">// 4 VGPR, 12 FR (8 FR, 1 QR), 1 scalar</span></span><br><span class="line"><span class="comment">// input [-1, 1] and output [0, PI]</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">acosFast</span><span class="params">(<span class="type">float</span> inX)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> x = <span class="built_in">abs</span>(inX);</span><br><span class="line">    <span class="type">float</span> res = <span class="number">-0.156583f</span> * x + (<span class="number">0.5</span> * PI);</span><br><span class="line">    res *= <span class="built_in">sqrt</span>(<span class="number">1.0f</span> - x);</span><br><span class="line">    <span class="keyword">return</span> (inX &gt;= <span class="number">0</span>) ? res : PI - res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SWIG实现Python调用C++</title>
      <link href="/program/python%E8%B0%83%E7%94%A8C++/"/>
      <url>/program/python%E8%B0%83%E7%94%A8C++/</url>
      
        <content type="html"><![CDATA[<h1>SWIG实现Python调用C++</h1><p>在实际项目开发中，我们经常有跨语言交互的需求，比如使用Python/Lua脚本调用引擎代码。常用的方案有很多，我们来介绍SWIG</p><table><thead><tr><th></th><th>语言</th><th>特点</th></tr></thead><tbody><tr><td>C++/CLI</td><td>C++和C#</td><td>微软为.NET平台高度定制的拓展，允许C++调用托管代码</td></tr><tr><td>SWIG</td><td>多语言</td><td>跨平台多语言，需要写<code>.i</code>文件，有一定侵入性</td></tr><tr><td>Boost</td><td>Python和C++</td><td></td></tr><tr><td>JNI</td><td>Java和C++</td><td></td></tr></tbody></table><h2 id="SWIG">SWIG</h2><h3 id="简介">简介</h3><p>SWIG（Simplified Wrapper and Interface Generato）是一种包装器，通过配置<code>.i</code>文件，自动生成Wrapper文件，以实现其他语言调用C++代码</p><h3 id="Interface-file">Interface file</h3><p><code>.i</code>文件格式如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 模块名</span></span><br><span class="line">%<span class="keyword">module</span> example</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 头文件和声明</span></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_controller.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">%&#125;</span><br><span class="line"><span class="comment">// 引用其他.i文件</span></span><br><span class="line">%include &lt;windows.i&gt;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. swig特性</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 代码拓展</span></span><br><span class="line"><span class="comment">// 将C++中的bool数组封装为BoolArray类</span></span><br><span class="line">%<span class="built_in">array_class</span>(<span class="type">bool</span>, BoolArray);</span><br><span class="line"><span class="comment">// 将C++中的std::vector&lt;std::string&gt;封装为StringVector类，所有vector向量都应该像这样封装</span></span><br><span class="line">%<span class="built_in">template</span>(StringVector) std::vector&lt;std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 要包装的内容，可以用头文件全部包装</span></span><br><span class="line"><span class="comment">// 特别注意，.h文件要按依赖顺序从上到下排布！</span></span><br><span class="line">%include <span class="string">&quot;example.h&quot;</span></span><br><span class="line">%include <span class="string">&quot;example_controller.h&quot;</span></span><br></pre></td></tr></table></figure><h3 id="环境安装">环境安装</h3><blockquote><p>我的环境是Mac M1，安装了brew和python3</p></blockquote><ol><li>安装swig</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install swig</span><br></pre></td></tr></table></figure><ol start="2"><li>检测是否安装成功</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swig -version</span><br></pre></td></tr></table></figure><h2 id="样例代码">样例代码</h2><p>实现了在python中调用C++定义的<code>add</code>函数</p><ol><li>C++代码</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>SWIG代码</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.i</span></span><br><span class="line">%<span class="keyword">module</span> example</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%include <span class="string">&quot;example.h&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>执行命令，我们会生成一个<code>.py</code>文件和一个<code>.cxx</code>文件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swig -c++ -python example.i</span><br></pre></td></tr></table></figure><ol start="4"><li>为了方便使用，我们将生成的<code>.py</code>文件构建为<code>.so</code>文件，创建一个setup.py文件，使用<a href="https://docs.python.org/3/library/distutils.html">distutils</a>进行编译</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setup.py</span></span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">example_module = Extension(<span class="string">&#x27;_example&#x27;</span>,</span><br><span class="line">                           sources=[<span class="string">&#x27;example_wrap.cxx&#x27;</span>, <span class="string">&#x27;example.cpp&#x27;</span>],</span><br><span class="line">                           )</span><br><span class="line"> </span><br><span class="line">setup (name = <span class="string">&#x27;example&#x27;</span>,</span><br><span class="line">       version = <span class="string">&#x27;0.1&#x27;</span>,</span><br><span class="line">       author      = <span class="string">&quot;SWIG Docs&quot;</span>,</span><br><span class="line">       description = <span class="string">&quot;&quot;&quot;Simple swig example from docs&quot;&quot;&quot;</span>,</span><br><span class="line">       ext_modules = [example_module],</span><br><span class="line">       py_modules = [<span class="string">&quot;example&quot;</span>],</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><p>执行命令，即会生成一些文件，其中包含一个<code>.so</code>文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><ol start="5"><li>将<code>.so</code>文件放入环境变量中（不推荐），或者放在python脚本同一个目录中（推荐），即可被调用</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example_test.py</span></span><br><span class="line"><span class="keyword">import</span> example</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用C++函数</span></span><br><span class="line">result = example.add(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;3 + 4 =&quot;</span>, result)</span><br></pre></td></tr></table></figure><h2 id="C-包装">C++包装</h2><h3 id="函数">函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.i</span></span><br><span class="line">%<span class="keyword">module</span> example</span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line">%include <span class="string">&quot;example.h&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example_test.py</span></span><br><span class="line"><span class="keyword">import</span> example</span><br><span class="line"><span class="comment"># 调用C++函数</span></span><br><span class="line">result = example.add(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;3 + 4 =&quot;</span>, result)</span><br></pre></td></tr></table></figure><h3 id="常量">常量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.i</span></span><br><span class="line">%<span class="keyword">module</span> example</span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159265358979323846</span></span><br><span class="line">%constant <span class="type">int</span> Foo = <span class="number">42</span>;</span><br><span class="line">%constant <span class="type">const</span> <span class="type">char</span> *path = <span class="string">&quot;/usr/local/include&quot;</span>;</span><br><span class="line"></span><br><span class="line">%include <span class="string">&quot;example.h&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example_test.py</span></span><br><span class="line"><span class="keyword">import</span> example</span><br><span class="line"><span class="built_in">print</span>(example.PI)<span class="comment"># 3.141592653589793</span></span><br><span class="line"><span class="built_in">print</span>(example.path)<span class="comment"># /usr/local/include</span></span><br></pre></td></tr></table></figure><h3 id="结构体">结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example_test.py</span></span><br><span class="line"><span class="keyword">import</span> example</span><br><span class="line"></span><br><span class="line">p = example.Point()</span><br><span class="line">p.x = <span class="number">1</span></span><br><span class="line">p.y = <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="类">类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSize</span><span class="params">(<span class="type">double</span> s)</span> </span>&#123; size = s;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example_test.py</span></span><br><span class="line"><span class="keyword">import</span> example</span><br><span class="line"></span><br><span class="line">s = example.Shape()</span><br><span class="line">s.setSize(<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(s.getSize())</span><br></pre></td></tr></table></figure><h2 id="资料">资料</h2><p><a href="https://www.swig.org/Doc4.1/SWIGDocumentation.html#Python">SWIG 4.1 Doc</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CXX </tag>
            
            <tag> SWIG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FBX SDK入门</title>
      <link href="/dcc/FbxSDK/"/>
      <url>/dcc/FbxSDK/</url>
      
        <content type="html"><![CDATA[<h1>FBX SDK</h1><p>FBX是一种主流的三维模型格式，格式闭源，但可以通过免费的FBX SDK编辑模型</p><h2 id="开发环境">开发环境</h2><ul><li>Visual Studio 2022</li><li>Cmake</li><li>安装<a href="https://www.autodesk.com/developer-network/platform-technologies/fbx-sdk-2020-3-4">FBX SDK</a>，我根据环境安装的是2020 VS2022</li></ul><h2 id="cmake构建">cmake构建</h2><p>在FBX SDK安装位置，能看到include、lib等，这里使用动态库构建</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"><span class="keyword">project</span>(FBXStudy)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> FbxLoader.h FbxLoader.cpp Main.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/FBXSDK/include&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/FBXSDK/lib/libfbxsdk.lib&quot;</span>)</span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span> POST_BUILD </span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/FBXSDK/bin/libfbxsdk.dll&quot;</span> </span><br><span class="line">    $&lt;TARGET_FILE_DIR:<span class="variable">$&#123;PROJECT_NAME&#125;</span>&gt;)</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE FBXSDK_SHARED)</span><br></pre></td></tr></table></figure><p>值得注意的是，当你使用动态库链接FBX SDK时，需要添加编译选项<code>FBXSDK_SHARED</code>，不然会报符号重定义的错误</p><img src="/images/FBX样例.PNG" class="lazyload" data-srcset="/images/FBX样例.PNG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="FBX样例"  /><h2 id="资料">资料</h2><p><a href="https://help.autodesk.com/view/FBX/2020/ENU/?guid=FBX_Developer_Help_welcome_to_the_fbx_sdk_html">FBX SDK 2020 文档</a></p>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FBX </tag>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Physically Based Shading at Disney</title>
      <link href="/graphics/DisneyBRDF/"/>
      <url>/graphics/DisneyBRDF/</url>
      
        <content type="html"><![CDATA[<h1>《Physically Based Shading at Disney》阅读笔记</h1><p>2012年SIGGRAPH，迪士尼提出了迪士尼规则的基于物理的渲染，立刻成为行业标准，被各大游戏厂商和游戏引擎所采用</p><blockquote><p>本文采用第一人称，我们是指迪士尼</p></blockquote><h2 id="介绍">介绍</h2><p>当时场景渲染还在使用ad-hoc着色模型和punctual灯光，我们渴望一套<strong>一致性</strong>的、美术友好的着色模型。受毛发渲染启发，我们推出了符合迪士尼规则的PBR模型。</p><p>迪士尼PBR模型提供了多种不同的渲染方程，但美术不需要关心渲染的底层逻辑，不需要针对不同的方程调整参数。</p><h2 id="微表面模型">微表面模型</h2><p>BRDF（双向反射分布函数）表示反射光与入射光的能量关系，是某方向出射光辐射率（Radiance）和入射光辐照度（Irradiance）的比值。</p><p>微表面模型认为材质表面由无数个理想镜面排列组成，如果某个观察方向上能观察到反射光，那么必然有一些微表面，他们的法线能平分入射光方向和观察方向（几何光学），我们将这些微表面的法线方向称为半向量（half vector）。顾名思义，半向量是入射光和观察方向的一半。<br>$$<br>\mathbf{h}=\frac{\mathbf{l}+\mathbf{v}}{|\mathbf{l}+\mathbf{v}|}<br>$$<br><img src="/images/microfacet.png" class="lazyload" data-srcset="/images/microfacet.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="microfacet" style="zoom:50%;" /></p><p>一个各向同性的BRDF模型如下，由菲涅尔项、微表面法线分布项、几何遮挡项组成<br>$$<br>\rho\left(\mathbf{l}, \mathbf{v} \right)= \mathrm{diffuse} +  \frac{F\left( \theta_d \right) D\left( \theta_h \right) G\left( \theta_l,\theta_v \right) }{ 4\cos\theta_l\cos\theta_v}<br>$$</p><ul><li>$\theta_d$是入射光和半向量的夹角，d是difference的意思</li><li>$\theta_h$是半向量和法线的夹角</li><li>$\theta_l$是入射光和法线的夹角</li><li>$\theta_v$是观察方向和法线的夹角</li></ul><h2 id="BRDF可视化">BRDF可视化</h2><p>我们制作了一个BRDF可视化工具，并将扫描材质转化为Image slice</p><img src="/images/image-slice.png" class="lazyload" data-srcset="/images/image-slice.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-slice" style="zoom:50%;" /><ul><li>在最底侧$\theta_d=0$，入射光和视线重合</li><li>在最左侧$\theta_h=0$，视线位于反射最强烈的部分，是高光项</li><li>在最上侧$\theta_d$最大，模拟光线射到材质边缘是的菲涅尔现象</li></ul><h2 id="观察材质">观察材质</h2><h3 id="漫反射项">漫反射项</h3><p>漫反射是灯光进入材质后经过折射、散射后重新发散到材质外部的过程。BRDF并没有考虑光线进出材质的位置变化，没有模拟次表面散射。</p><p>下图为随着$\theta_h$的增大，反射强度的衰减程度，光滑材质反射强度衰减的极快。而粗糙材质就比较慢，甚至有些材质的反射强度与方向无关。部分粗糙材质在掠射角有菲涅尔现象</p><p><img src="/images/%E5%85%89%E6%BB%91%E4%B8%8E%E7%B2%97%E7%B3%99%E6%9D%90%E8%B4%A8%E7%9A%84D%E9%A1%B9.png" class="lazyload" data-srcset="/images/%E5%85%89%E6%BB%91%E4%B8%8E%E7%B2%97%E7%B3%99%E6%9D%90%E8%B4%A8%E7%9A%84D%E9%A1%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="光滑与粗糙材质的D项"></p><p>微表面理论认为材质表面由大量理想镜面组成，光线呈掠射角入射时，入射光线与模型边缘的一些“竖直的”微表面相遇，使许多光发生了反射，形成了菲涅尔效应，更多的能量被用于反射，而非散射。</p><h3 id="微表面法线分布项">微表面法线分布项</h3><p>微表面项描述了沿着半向量方向的微表面占总面积的比例。对于光滑材质，大多数微表面法线与宏观法线方向一致，随着$\theta_h$增大，面积会迅速减少，而粗糙材质减少就很慢，有着更长的尾部。</p><p>下图左为GGX（红）、Beckmann（绿）、Blinn Phong（蓝，注意和绿重叠了）、chrome（黑）四种D项的描述，右图从左到右分别为点光照射chrome、GGX、Beckmann项的结果。</p><p><img src="/images/%E8%A7%82%E5%AF%9FD%E9%A1%B9.png" class="lazyload" data-srcset="/images/%E8%A7%82%E5%AF%9FD%E9%A1%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="观察D项"></p><h3 id="高光菲涅尔项">高光菲涅尔项</h3><p>菲涅尔项描述了光线发生反射和折射的比例，当光线由光疏材质射向光密材质时，随着入射角的增大，反射会越来越强。对于光滑材质，掠射角时菲涅尔项接近100%，对于粗糙材质，尽管无法达到100%，但也增长迅速。</p><img src="/images/air-to-glass.png" class="lazyload" data-srcset="/images/air-to-glass.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="air-to-glass" style="zoom: 50%;" /><img src="/images/高光菲涅尔.png" class="lazyload" data-srcset="/images/高光菲涅尔.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="高光菲涅尔" style="zoom:50%;" /><p>人们发现有些材质的菲涅尔曲线在掠射角处比菲尼尔方程预测的更陡峭，为此引入了几何遮挡项，该项将方法菲涅尔效应。</p><h3 id="几何遮挡项">几何遮挡项</h3><p>实践中难以测量出几何遮挡项，于是是通过先测量出F项和D项，再计算出G项。</p><p>Smith根据D项推导出了一种G项，不过Smith的G项仅再某些情况下有解析式，大部分情况下使用预积分+图表的方式近似。</p><h2 id="迪士尼BRDF">迪士尼BRDF</h2><h3 id="材质参数">材质参数</h3><p>参数直观、数量少，参数范围通常在0~1但允许超出范围，所有参数组合都是鲁棒合理的</p><table><thead><tr><th>参数名称</th><th>含义</th></tr></thead><tbody><tr><td>baseColor</td><td>基础色</td></tr><tr><td>subsurface</td><td>通过次表面控制漫反射形状</td></tr><tr><td>metallic</td><td>金属度，所有材质是金属和非电介质根据金属度的混合，0为非金属，1为金属</td></tr><tr><td>specular</td><td>incident specular amount.  This is in lieu of an explicit index-of-refraction</td></tr><tr><td>specularTint</td><td>美术可以通过该参数将高光色调向基础色</td></tr><tr><td>roughness</td><td>粗糙度</td></tr><tr><td>anisotropic</td><td>各项异性比，用于控制高光形状，0为各项同性，1为各项异性</td></tr><tr><td>sheen</td><td>光泽，用于布料渲染</td></tr><tr><td>sheenTint</td><td>美术可以通过该参数将光泽调向基础色</td></tr><tr><td>clearcoat</td><td>薄膜图层的高光色</td></tr><tr><td>clearcoatGloss</td><td>薄膜图层的粗糙度</td></tr></tbody></table><img src="/images/迪士尼材质.png" class="lazyload" data-srcset="/images/迪士尼材质.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="迪士尼材质" style="zoom:67%;" /><h3 id="漫反射模型">漫反射模型</h3><p>漫反射的本质是光线进入材质后重新射出，因此至少发生了两次折射，于是有两个菲涅尔项。这两个菲涅尔还能让材质边缘变亮。<br>$$<br>\rho_d=\frac{baseColor}{\pi}(1+(F_{D90}-1)(1-\cos \theta_l)^5)(1+(F_{D90}-1)(1-\cos \theta_v)^5)<br>$$</p><p>$$<br>F_{D90}=0.5+2roughness\cos^2\theta_d<br>$$</p><h3 id="高光D项">高光D项</h3><p>我们认为目前最流行的GGX拖尾仍不够长，最后选择了GTR<br>$$<br>D_{GTR}=c/(\alpha^2\cos^2\theta_h+\sin^2\theta_h)^{\gamma}<br>$$</p><ul><li>$c$：缩放常数</li><li>$\alpha$：粗糙度参数，0为光滑，1为完全粗糙</li></ul><img src="/images/GTR.png" class="lazyload" data-srcset="/images/GTR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GTR" style="zoom:50%;" /><h3 id="高光F项">高光F项</h3><p>$$<br>F_{\mathrm{Schlick}}=F_0+(1-F_0)(1-\cos\theta_d)^5<br>$$</p><h3 id="高光G项">高光G项</h3><p>使用GGX模型作为G项，但对粗糙度进行映射<br>$$<br>\alpha_g=(0.5+roughness/2)^2<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PBR </tag>
            
            <tag> SIGGRAPH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法线切线次切线的计算</title>
      <link href="/graphics/%E6%B3%95%E7%BA%BF%E5%88%87%E7%BA%BF%E6%AC%A1%E5%88%87%E7%BA%BF/"/>
      <url>/graphics/%E6%B3%95%E7%BA%BF%E5%88%87%E7%BA%BF%E6%AC%A1%E5%88%87%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1>法线切线次切线的计算</h1><h3 id="顶点法线的计算">顶点法线的计算</h3><p>模型顶点构成了多个三角面，使用三角面的顶点坐标等得到两条边的向量，求两个向量的叉积能够得到（归一化的）<strong>面法线</strong>。<br>$$<br>\mathbf{N}=\frac{(\mathbf{P}_1-\mathbf{P}_0)\times(\mathbf{P}_2-\mathbf{P}_0)}{||(\mathbf{P}_1-\mathbf{P}_0)\times(\mathbf{P}_2-\mathbf{P}_0)||}<br>$$<br>点的顺序与法线方向满足右手螺旋定则，点呈顺逆时针时法线垂直直面向外。</p><img src="/images/triangle.png" class="lazyload" data-srcset="/images/triangle.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="triangle" style="zoom:50%;" /><p>顶点法线可以在DCC中手动指定，也可以用面法线做平滑着色。一般来说某个顶点会参与构成多个三角面，选取这些三角面的面法线做算术平均值，这个过程被称为平滑着色。</p><blockquote><p>硬边上的点属于不同的平滑组，在计算法线时不能平均，在导出时会被拆分为互相重叠的点，各自拥有一个法线、纹理坐标。</p></blockquote><p>如果对未经过归一化的面法线求均值，能实现含权重的顶点法线，三角面面积越大，影响越强。</p><h3 id="切线空间">切线空间</h3><p>为了得到更高精度的法线，我们会使用切线空间的法线贴图，对顶点法线进行扰动。</p><p>切线空间由三个基向量组成，分别为切线$X$、次切线$Y$、法线$Z$，这三个基向量不一定正交，但视为正交。</p><p>在不进行扰动时，切线空间的法线为$(0,0,1)$，是顶点法线的方向。切线和次切线所形成的平面与物体表面相切，方向与UV有关，但存在偏差。</p><img src="/images/切线空间.png" class="lazyload" data-srcset="/images/切线空间.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="切线空间" style="zoom:50%;" /><p>三个向量可以构成TBN矩阵，该矩阵能将切线空间法线转化为物体空间/世界空间<br>$$<br>\begin{bmatrix}T_{x}&amp;B_{x}&amp;N_{x}\\ T_{y}&amp;B_{y}&amp;N_{y}\\ T_{z}&amp;B_{z}&amp;N_{z}\end{bmatrix}<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">float3 normalValue = normalTexture.<span class="built_in">sample</span>(textureSampler, uv * params.tiling).xyz * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">        normal = <span class="built_in">float3x3</span>(tangentWS, bitangentWS, normalWS) * normalValue;</span><br></pre></td></tr></table></figure><h3 id="计算切线和次切线">计算切线和次切线</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> triangleCount = indices.Count / <span class="number">3</span>;</span><br><span class="line">List&lt;float3&gt; sDirList;</span><br><span class="line">List&lt;float3&gt; tDirList;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; triangleCountl; ++i)&#123;</span><br><span class="line">  <span class="comment">// 三角形的三个顶点</span></span><br><span class="line">  <span class="type">int</span> vertexID0 = indices[i * <span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> vertexID1 = indices[i * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">  <span class="type">int</span> vertexID2 = indices[i * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 顶点UV</span></span><br><span class="line">  float2 uv0 = uvs[vertexID0];</span><br><span class="line">  float2 uv1 = uvs[vertexID1];</span><br><span class="line">  float2 uv2 = uvs[vertexID2];</span><br><span class="line">  <span class="comment">// 顶点坐标</span></span><br><span class="line">  float3 pos0 = positions[vertexID0];</span><br><span class="line">  float3 pos1 = positions[vertexID1];</span><br><span class="line">  float3 pos2 = positions[vertexID2];</span><br><span class="line">  <span class="comment">// UV差值</span></span><br><span class="line">  float2 s = <span class="built_in">float2</span>(uv1.x - uv0.x, uv2.x - uv0.x);</span><br><span class="line">  float2 t = <span class="built_in">float2</span>(uv1.y - uv0.y, uv2.y - uv0.y);</span><br><span class="line">  <span class="comment">// 坐标差值</span></span><br><span class="line">  float3 deltaPos0 = pos1 - pos0;</span><br><span class="line">  float3 deltaPos1 = pos2 - pos0;</span><br><span class="line">  <span class="type">float</span> r = <span class="number">1.0f</span> / (s.x * t.y - s.y * t.x);</span><br><span class="line">  float3 sDir = <span class="built_in">float3</span>(</span><br><span class="line">    r* (t.y * deltaPos0.x - t.x * deltaPos1.x),</span><br><span class="line">    r* (t.y * deltaPos0.y - t.x * deltaPos1.y),</span><br><span class="line">    r* (t.y * deltaPos0.z - t.x * deltaPos1.z)</span><br><span class="line">  );</span><br><span class="line">  float3 tDir = <span class="built_in">float3</span>(</span><br><span class="line">  r* (-s.y * deltaPos0.x + s.x * deltaPos1.x),</span><br><span class="line">    r* (-s.y * deltaPos0.y + s.x * deltaPos1.y),</span><br><span class="line">    r* (-s.y * deltaPos0.z + s.x * deltaPos1.z)</span><br><span class="line">  );</span><br><span class="line">  tDirList[vertexID0] += tDir;</span><br><span class="line">  tDirList[vertexID1] += tDir;</span><br><span class="line">  tDirList[vertexID2] += tDir;</span><br><span class="line">  sDirList[vertexID0] += sDir;</span><br><span class="line">  sDirList[vertexID1] += sDir;</span><br><span class="line">  sDirList[vertexID2] += sDir;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertexCount; ++i)&#123;</span><br><span class="line">  float3 normal = normals[vertexID0];</span><br><span class="line">  float3 tDir = tDirList[i];</span><br><span class="line">  <span class="comment">// 切线</span></span><br><span class="line">  float3 tangent = tDir - <span class="built_in">dot</span>(normal, tDir);</span><br><span class="line">  <span class="comment">// 次切线</span></span><br><span class="line">  float3 bitangent = <span class="built_in">cross</span>(normal, tangent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="https://zhuanlan.zhihu.com/p/139593847">切线空间（Tangent Space）完全解析</a></p><p>《3D游戏与计算机图形学中的数学方法》</p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac开发环境配置</title>
      <link href="/program/mac%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/program/mac%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1>Mac开发环境配置</h1><blockquote><p>前几天遇到一个问题，某个VPN软件开启后无法正常关闭，而强行关闭后并没有还原网络配置，导致我只有开着VPN才能连接网络，一时间没有好的办法，于是将Mac重装了系统，记录一下环境配置，没准以后还会用到</p></blockquote><blockquote><p>我的设备是Macbook Air M1，主要用于Metal开发和写博客</p></blockquote><h2 id="Mac重装系统">Mac重装系统</h2><ol><li>重要文件注意备份（放在iCloud最方便）</li><li>在关机状态下长按电源键，此时会提示你继续长按进入启动选项</li><li>你会看到两个启动选项，一个是当前系统的启动盘，一个是齿轮形状的选项</li><li>进入选项，进入磁盘工具，选择要抹除的内容盘，点右上角的抹除</li><li>回到齿轮选项界面，点击重装macOS，这个过程需要联网</li><li>等待即可</li></ol><h2 id="基础开发环境">基础开发环境</h2><h3 id="brew">brew</h3><p>MacOS最常用的包管理器，用于下载各种开发环境、软件、三方库</p><p>出于网络原因，建议使用国内镜像安装，打开终端输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure><p>按输出操作即可</p><h3 id="Python3">Python3</h3><p>安装brew后输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install python3</span><br></pre></td></tr></table></figure><p>不仅仅是python，可以说大部分的环境都可以用<code>brew install xxx</code>安装</p><h2 id="常用工具">常用工具</h2><h3 id="Xcode">Xcode</h3><blockquote><p>免费使用，但是打包需要付费账户</p></blockquote><p>无需多说，Mac上开发必备环境，可以直接去App Store安装，值得注意的是，商店里的Xcode是最新版，需要你的系统保持最新</p><h3 id="Typora">Typora</h3><blockquote><p>付费，15刀永久</p></blockquote><p>一款所见即所得的markdown编辑器，界面简洁优美，而且对latex等支持非常好</p><img src="/images/typora2.png" class="lazyload" data-srcset="/images/typora2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="typora" style="zoom:50%;" /><p>安装激活后打开某个markdown文件，选中后按<code>command+i</code>打开简介，配置该类文件的打开方式</p><img src="/images/typora.png" class="lazyload" data-srcset="/images/typora.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="typora" style="zoom:50%;" /><p>此外最好也配置一下图片的引用方式，比如使用相对路径，自动复制到文件夹之类的</p><h3 id="GitKraken">GitKraken</h3><blockquote><p>学生免费，公共仓库免费，商用私有仓库订阅收费</p></blockquote><p>最好的图形界面，功能齐全，看diff也十分方便</p><p><img src="/images/gitkraken.png" class="lazyload" data-srcset="/images/gitkraken.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="gitkraken"></p><p>LFS功能需要单独安装，在终端输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install git-lfs</span><br></pre></td></tr></table></figure><h3 id="VS-Code">VS Code</h3><blockquote><p>免费</p></blockquote><p>无需多说，一个完美的文本编辑器，如果你不安装VS Code，很有可能用Xcode打开一些文件</p><h4 id="Github-Copilot">Github Copilot</h4><blockquote><p>学生免费</p></blockquote><p>强烈建议安装，编程效率提升数倍，不会使用AI的程序员必然被AI取代</p><p>在一个Python脚本中，我刚输入md5，就帮我写好了代码</p><img src="/images/CopilotMD5.png" class="lazyload" data-srcset="/images/CopilotMD5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CopilotMD5" style="zoom:50%;" /><h3 id="右键助手">右键助手</h3><blockquote><p>免费，App Store搜索即可</p></blockquote><p>我只使用了少量功能，比如新建文件，在当前路径打开终端</p><img src="/images/右键助手.png" class="lazyload" data-srcset="/images/右键助手.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="右键助手" style="zoom:50%;" /><h3 id="Hidden-Bar">Hidden Bar</h3><blockquote><p>免费，App Store搜索即可</p></blockquote><p>用于折叠顶部图标，眼不见心不烦</p><p><img src="/images/HiddenBar.png" class="lazyload" data-srcset="/images/HiddenBar.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="HiddenBar"></p><h3 id="ClashX">ClashX</h3><blockquote><p>免费，开源，当然订阅需要自己去找</p></blockquote><p>一个非常好用的VPN软件</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Character Creator 插件开发</title>
      <link href="/dcc/Character%20Creator/"/>
      <url>/dcc/Character%20Creator/</url>
      
        <content type="html"><![CDATA[<h1>Character Creator 插件开发</h1><blockquote><p>最近在CC 4/iClone 8开发Python插件，真的是小刀拉屁股，开了眼了，都不知道该从哪里开始吐槽，如果说maya脚本开发叫恶心，CC脚本开发就是阴间</p><ul><li>去年CC 4发布，改动了大量API，大部分API都变成Experimental API，之前（指五六年前）的样例代码大多失效，并不不再维护（不会改你可以不改）</li><li>官方文档简陋无比，大部分函数和参数没有用法和解释，写满了<code># No example</code></li><li>给官方发邮件（这是花了钱的）问Python相关的东西，官方只会复读“脚本还在开发，可能有功能不全，你可以尝试去论坛问”</li><li>官方论文发言需要审核，我提了两个问题都被拒绝发布（我发邮件你让我去论坛，我去论坛你堵我嘴）</li><li>脚本功能不全，有些功能可以读写，有些是只读（像maya你的每一步操作都是由命令实现的，甚至会在窗口将当前命令输出出来）</li></ul></blockquote><h2 id="介绍">介绍</h2><p>Character Creator是reallusion推出的一款商业捏脸软件，可以制作表情动作、动作捕捉等。使用成本比较高，大部分公司都不会使用，网上的信息远少于Maya、3DMax这类DCC。</p><p><img src="/images/cc.png" class="lazyload" data-srcset="/images/cc.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cc"></p><p>CC支持使用Python编写脚本、插件，可以通过顶部导航栏中<code>Script--Load Python</code>加载脚本，通过<code>Script--Console Log </code>打开Log面板，不过这个Log面板远不如Maya的面板信息齐全。</p><p>iClone是该公司的另一款软件，用于制作动画，功能与CC十分接近，可以参考<a href="https://wiki.reallusion.com/IC8_Python_API:Modules">iClone的文档</a>编写插件</p><h2 id="环境配置">环境配置</h2><blockquote><p>可以参考maya python脚本的环境配置，当时使用的是PyCharm，这里我们使用VS Code</p></blockquote><ol><li>VS Code安装Python插件</li></ol><p><img src="/images/vscode-python.PNG" class="lazyload" data-srcset="/images/vscode-python.PNG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="vscode-python"></p><ol start="2"><li>选择Python解释器（按<code>ctrl+shift+p</code>打开命令界面）</li></ol><p><img src="/images/python%E8%A7%A3%E9%87%8A%E5%99%A8.PNG" class="lazyload" data-srcset="/images/python%E8%A7%A3%E9%87%8A%E5%99%A8.PNG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="python解释器"></p><p><img src="/images/python%E8%A7%A3%E9%87%8A%E5%99%A82.PNG" class="lazyload" data-srcset="/images/python%E8%A7%A3%E9%87%8A%E5%99%A82.PNG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="python解释器2"></p><h2 id="编写脚本">编写脚本</h2><blockquote><p>脚本本身不难写，主要是文档和论坛信息太少，某些API的使用可以参考<a href="https://wiki.reallusion.com/IC8_Python_API:Modules">iClone的文档</a>，下面是我认为值得处理的东西</p></blockquote><h3 id="创建带有按钮的窗口">创建带有按钮的窗口</h3><p>加载脚本后会出现一个对话框，对话框中有一个Label和一个按钮，当按按钮时可以输出”Hello World“</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RLPy</span><br><span class="line"><span class="keyword">from</span> shiboken2 <span class="keyword">import</span> wrapInstance</span><br><span class="line"><span class="keyword">from</span> PySide2 <span class="keyword">import</span> QtWidgets</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似于main函数，是脚本的入口，加载脚本时自动执行该函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_script</span>():</span><br><span class="line">    <span class="comment"># 创建一个对话框</span></span><br><span class="line">    rl_dialog = RLPy.RUi.CreateRDialog()</span><br><span class="line">    <span class="comment"># 设置对话框名称</span></span><br><span class="line">    rl_dialog.SetWindowTitle(<span class="string">&quot;Main Dialog&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pyside_dialog = wrapInstance(<span class="built_in">int</span>(rl_dialog.GetWindow()), QtWidgets.QDialog)</span><br><span class="line">    <span class="comment"># 设置对话框宽度</span></span><br><span class="line">    pyside_dialog.setFixedWidth(<span class="number">200</span>)</span><br><span class="line">    sample_layout = pyside_dialog.layout()</span><br><span class="line"><span class="comment"># 一个Label</span></span><br><span class="line">    label_hello = QtWidgets.QLabel(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="comment"># 一个Button</span></span><br><span class="line">    button_run = QtWidgets.QPushButton(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    <span class="comment"># Button绑定事件函数 run</span></span><br><span class="line">    button_run.clicked.connect(run)</span><br><span class="line"></span><br><span class="line">    sample_layout.addWidget(label_hello)</span><br><span class="line">    sample_layout.addWidget(button_run)</span><br><span class="line"></span><br><span class="line">    rl_dialog.Show()</span><br></pre></td></tr></table></figure><p><img src="/images/cc_dialog.jpg" class="lazyload" data-srcset="/images/cc_dialog.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cc_dialog"></p><h3 id="定时任务">定时任务</h3><p>定时任务十分重要，通过开启计时，就会定时执行<code>Timeout()</code>内到操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计时器回调</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimerCallback</span>(RLPy.RPyTimerCallback):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        RLPy.RPyTimerCallback.__init__(self)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Timeout</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="comment"># 类似于Update</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Timeout&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># timer，计时器应当放在全局</span></span><br><span class="line">timer = RLPy.RPyTimer()</span><br><span class="line"><span class="comment"># 设置间隔为 1000 ms</span></span><br><span class="line">timer.SetInterval(<span class="number">1000</span>) </span><br><span class="line"><span class="comment"># 定时器设为可以重复触发</span></span><br><span class="line">timer.SetSingleShot(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 注册事件</span></span><br><span class="line">timer_callback = TimerCallback()</span><br><span class="line">timer.RegisterPyTimerCallback(timer_callback)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply</span>():</span><br><span class="line">    <span class="comment"># 开始计时</span></span><br><span class="line">    timer.Start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cancel</span>():</span><br><span class="line">    <span class="comment"># 暂停计时</span></span><br><span class="line">    timer.Stop()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_script</span>():</span><br><span class="line">    <span class="comment"># menu</span></span><br><span class="line">    rl_dialog = RLPy.RUi.CreateRDialog()</span><br><span class="line">    rl_dialog.SetWindowTitle(<span class="string">&quot;main_dialog&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pyside_dialog = wrapInstance(<span class="built_in">int</span>(rl_dialog.GetWindow()), QtWidgets.QDialog)</span><br><span class="line">    pyside_dialog.setFixedWidth(<span class="number">200</span>)</span><br><span class="line">    sample_layout = pyside_dialog.layout()</span><br><span class="line"></span><br><span class="line">    button_apply = QtWidgets.QPushButton(<span class="string">&quot;Apply&quot;</span>)</span><br><span class="line">    button_apply.clicked.connect(apply)</span><br><span class="line">    button_cancel = QtWidgets.QPushButton(<span class="string">&quot;Cancel&quot;</span>)</span><br><span class="line">    button_cancel.clicked.connect(cancel)</span><br><span class="line"></span><br><span class="line">    sample_layout.addWidget(button_apply)</span><br><span class="line">    sample_layout.addWidget(button_cancel)</span><br><span class="line"></span><br><span class="line">    rl_dialog.Show()</span><br></pre></td></tr></table></figure><h3 id="导出当前模型">导出当前模型</h3><blockquote><p>官网甚至还在用iClone7的老东西误导你，太可恶了！</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">export</span>():</span><br><span class="line">  <span class="comment"># 获取当前场景所有的人物模型（一般只有一个）</span></span><br><span class="line">    all_avatars = RLPy.RScene.GetAvatars(RLPy.EAvatarType_All)</span><br><span class="line">    avatar_name = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> _iter_avatar <span class="keyword">in</span> all_avatars:</span><br><span class="line">        avatar_name = _iter_avatar.GetName()</span><br><span class="line">    avatar = RLPy.RScene.FindObject(RLPy.EObjectType_Avatar, avatar_name)</span><br><span class="line">    <span class="comment"># 导出选项</span></span><br><span class="line">    export_option = RLPy.EExportFbxOptions__None</span><br><span class="line">    export_option2 = RLPy.EExportFbxOptions2__None</span><br><span class="line">    export_option3 = RLPy.EExportFbxOptions3__None</span><br><span class="line">    export_option = export_option | RLPy.EExportFbxOptions_AutoSkinRigidMesh</span><br><span class="line">    export_option2 = export_option2 | RLPy.EExportFbxOptions2_ResetBoneScale</span><br><span class="line">    original_size = RLPy.EExportTextureSize_Original</span><br><span class="line">    default_format = RLPy.EExportTextureFormat_Default </span><br><span class="line"></span><br><span class="line">    setting = RLPy.RExportFbxSetting()</span><br><span class="line">    setting.SetOption(export_option)</span><br><span class="line">    setting.SetOption2(export_option2)</span><br><span class="line">    setting.SetOption3(export_option3)</span><br><span class="line">    setting.SetTextureSize(original_size)</span><br><span class="line">    setting.SetTextureFormat(default_format)</span><br><span class="line">    setting.EnableExportMotion(<span class="literal">True</span>)<span class="comment"># 开启动画导出，启动后默认导出当前Pose</span></span><br><span class="line">setting.SetExportMotionFps(RLRy.RFps(<span class="number">60</span>))<span class="comment"># 设置导出动画的帧率，会影响动画数据的精度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 导出文件</span></span><br><span class="line">    result = RLPy.RFileIO.ExportFbxFile(avatar, <span class="string">f&quot;D://Art/man/<span class="subst">&#123;file_name&#125;</span>.fbx&quot;</span>, setting)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Success export fbx&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Export error&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银河战士like</title>
      <link href="/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike/"/>
      <url>/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike/</url>
      
        <content type="html"><![CDATA[<h1>银河战士like</h1><h2 id="银河战士">银河战士</h2><p>我接触银河战士比较晚，还是NS OLED发售时才了解这款游戏，结果上手后立即爱不释手，连续玩了三四天才把普通难度打通。这个游戏的关卡设计给了我极其深刻的印象，我就像做理综试卷一样，揣摩设计者的意图，在没有明确引导的情况下也能找到下一步的目标。</p><p>自此一直想做一个类似的游戏，但做了一两年引擎TA后，对策划和GamePlay已经一窍不通了，最近发现Mix-Jim做过Metroid的教程，于是燃起了我做独立游戏的热情，在这里记录一下（2023.4.5），等到毕设做完后就着手开发。</p><p>我玩银河战士的心态变化就是：</p><p>初始关卡玩家惯性思维向右走，结果发现走到了头，走不动了，然而他惊奇地发现，人物居然能往左走！</p><p>走到左边发现还是走不到，有一个小台阶，台阶上面有个宝箱，然后玩家惊讶得发现，人物居然能跳！</p><p>打开宝箱后你获得了一个能力，但你还不知道是什么，你继续往左走，看到一个房间，房间门太矮了，你过不去，然后你发现，你刚刚获得的能力是变成球！</p><p>靠这种润物细无声的方式，你最后得到了一切，打败了boss，游戏通关，然后告诉你主角是一个比基尼美女，你通关越快，她游戏结束时穿的越裸露！</p><p>你想看裸体吗？赶快二周目吧！</p><h2 id="剧情">剧情</h2><h3 id="游戏剧情">游戏剧情</h3><p>【逆熵科技】宣布打破了能量守恒定律，发明了【无尽能源】，并在某地建造了全球最大的发电厂。奇怪的是，这个发电厂没有人类员工，也不需要输送原材料，更没有污染排放，就能为全世界提供电力，仿佛他们真的发明了无尽能源。随着时间的推移，该发电厂成为地球上最重要也最神秘的设施。</p><p>你是一名特警，你在调查一系列【超自然现象】引发的事件，这个事件已经导致多个城市的毁灭，大量生物的绝种，绝症发病率的倍增。经过多年的研究，你发现自从发电厂出现后，超自然事件的发生频率大幅提高，并且事件发生地仿佛以电厂为中心放射分布，于是你申请调查电厂。</p><p>不出意外，电厂的调查令并没有批准，你的调查进入僵局，有人暗示你放弃调查。然而一天晚上，电厂出现了事故，收到了求救信号，你作为最近的警官到达了现场，结果却看到非常诡异的画面，电厂的外观变成了【xxx】</p><p>你进入电厂后电厂大门立刻锁死，随即又遇到了机械怪物，手枪子弹完全无法伤害他们。你逃到一个房间里，发现了【xxx】，你的手枪接触后形状发生改变，能无需弹药发射脉冲子弹，可以对怪物造成伤害。</p><p>你在电厂不断探索，获得了多种【超自然力量】，最后找到求救信息的来源，结果你发现信号来自一扇门，而这个门一直在向外输送能量。</p><h3 id="背景">背景</h3><p>门的那头连接着一个平行世界，那个世界是一个魔法的世界，构成世界的基础物质中有【魔力】的存在，而那个世界正面临着【魔力短缺】的现象。</p><p>【魔力】有高能和低能之分，就像我们世界的能量一样，【魔力】由高到低，可以对现实产生影响，被称为【魔法】，而随着【魔法】的普及与滥用，他们世界的【魔力】质量越来越差，他们越来越难以使用魔法。</p><p>为了缓解【魔力短缺】，他们向我们这个世界开启了一道门，这个门在将我们世界的物质搬运到他们世界。这个过程影响了双方世界的稳定，我们的世界沉默的【魔力】得到苏醒，引发了基础粒子的分裂，【魔力】吸收了原子释放的部分核能，而其他能量被【逆熵科技】用于发电。传送门将被激化的【魔力】送至他们世界，。</p><p>看似双赢，我们得到了能量，他们得到了【魔力】，实则双输。</p><ul><li><p>对于我们</p><ul><li>部分【魔力】停留在我们世界中，引起了【超自然现象】，产生了大量次生灾害。</li><li>由于我们世界的生物、环境在演变过程中没有【魔力】，因此这些【魔力】无法被我们所使用，反而像辐射一样在破坏我们的细胞结构，影响了人类生存。</li></ul></li><li><p>对于他们</p><ul><li>吸收核能的【魔力】强度过高，而且传送门的位置不像我们这样集中在一个门中，现在他们世界任意一个地方都有可能发生一场小型核爆，可能在天空，可能在地底，也可能在某个人肚子里。他们的世界就像经历核战争一样，到处都是废墟和坑洞。</li></ul></li></ul><p>他们世界大部分设施被摧毁，没有能力关闭传送门，于是他们只能向我们世界发送消息，希望我们可以关闭或改善这个流程，拯救两个世界</p><h3 id="设定">设定</h3><p>电厂被魔化为活物，于是方块被破环后会修复</p><p>电厂具有自我保护意识，当核心被抢夺/破环时会召唤boss杀死入侵者（角色拿到一个增强时会进入boss战）</p><h2 id="开发计划">开发计划</h2><h3 id="角色">角色</h3><ul><li>跑</li><li>跳<ul><li>快跳（跑起来跳）</li><li>慢跳（原地起跳，横向移动速度比跑跳慢一半）</li></ul></li><li>抓墙（差一点点就能跳上的平台，如果手能抓住平台上部，可以抓在墙上）<ul><li>上平台（抓在墙上按跳跃能上平台）</li></ul></li><li>瞄准射击（按做肩键开启瞄准设计模式，用红线瞄准）<ul><li>射击为红色激光</li><li>按右肩键开启畏缩射击模式，伤害能低，但小怪被击中后会畏缩</li></ul></li><li>近战攻击（两段光剑挥砍，一次从下向上，一次从上向下，第二段后期可以解锁剑气）<ul><li>近战为蓝色光剑</li></ul></li><li>跟随镜头</li><li>无敌时间<ul><li>被攻击时会触发，角色有菲涅尔描边，此时角色和敌人不会有碰撞</li></ul></li></ul><h3 id="场景物体">场景物体</h3><ul><li>普通方块（白色方块）</li><li>可被设计破环的方块<ul><li>破环前不可通行，破环后可以通行，方块被破环后20秒会复原，恢复时有融解恢复特效</li><li>射击破环方块（红色方块）<ul><li>破环时有粒子溅射特效</li></ul></li><li>近战破环方块（蓝色方块）<ul><li>方块破环时播放破碎动画</li></ul></li></ul></li></ul><h3 id="敌人">敌人</h3><ul><li>小怪<ul><li>怪物与角色接触时会向后击飞角色，并给角色0.5秒的无敌时间</li><li>飞行怪物<ul><li>一次仅会有一个飞行怪物攻击角色，并有明显的攻击前摇</li><li>前摇攻击时能被近战一击必杀</li><li>被畏缩畏缩后会变成一个垫脚石，不再移动，可以被踩踏，20秒后复原</li></ul></li><li>地面怪物<ul><li>地面角色有一个出生点，平时在出生点左右移动，看到角色后会向角色方向追击</li><li>当追击失去视线后，会回到出生点附近，并恢复所有生命</li><li>当被畏缩射击后会停止移动一段时间，但角色踩上仍会扣血</li></ul></li></ul></li><li>Boss<ul><li>当角色每拿到一个强化，镜头、手柄开始震动，然后boss出现</li><li>boss总是可以被刚刚拿到的强化克制</li><li>击败boss后会增强角色的最大生命值</li></ul></li></ul><h3 id="场景管理">场景管理</h3><ul><li>以（0，0，0）为原点，并设为二维平面的左下角，将场景切分为一个个1x1x1方块组成的世界</li><li>分层管理</li><li>场景要能导出为scriptableobject</li></ul><h3 id="场景编辑">场景编辑</h3><ul><li>Gizmos绘制场景网格，其中每五格加粗（id % 5 == 0）</li><li>摆放吸附</li><li>根据起始和终止位置批量生成物体</li></ul><h3 id="地图">地图</h3><ul><li>地图作为单独的全屏界面，目前不打算在游戏屏幕上绘制小地图</li><li>地图包含两级缩放<ul><li>全局地图（展示的是关卡间的关系）</li><li>局部地图（展示的是当前关卡的信息，每一个方块都要被绘制）</li></ul></li></ul><h3 id="渲染">渲染</h3><ul><li><p>尽量使用URP内置的功能</p></li><li><p>角色要单独写Shader，支持开关菲涅尔描边</p></li><li><p>全局动态Light Probe，均匀摆放Probe，可以用odin写一个批量摆放插件，注意不要进墙</p></li><li><p>色调映射和Lut调色</p></li><li><p>SSAO</p></li><li><p>抗锯齿</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Simplygon插件尝鲜</title>
      <link href="/dcc/Simplygon/"/>
      <url>/dcc/Simplygon/</url>
      
        <content type="html"><![CDATA[<h1>Simplygon插件尝鲜</h1><blockquote><p>出于性能等考虑，大型项目往往会使用LOD功能，根据相机距离切换模型精度。而海量的3D模型靠人力拆分LOD显然过于昂贵，因此非常有必要使用模型减面工具，所幸业界已经有非常成熟的商业插件，比如InstaLOD和Simplygon，对于个人开发者，Simplygon提供每日200次的免费使用次数，足够用了</p></blockquote><h2 id="安装">安装</h2><blockquote><p>环境为Windows系统+支持Vulkan的显卡</p></blockquote><ol><li>安装<a href="https://aka.ms/vs/17/release/vc_redist.x64.exe">VC Redist</a>，这个组件包含了Visual C++的运行时库，VC项目正常运行需要该组件</li><li>安装<a href="https://sdk.lunarg.com/sdk/download/latest/windows/vulkan-sdk.exe">Vulkan SDK</a></li><li>下载<a href="https://downloads.simplygon.com/SimplygonSDK_10.1.8000.0.exe">Simplygon</a></li><li>选择Free License激活，每个微软账号能有一个Seat，每日200次使用次数</li></ol><img src="/images/simplygon.png" class="lazyload" data-srcset="/images/simplygon.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="simplygon" style="zoom:50%;" /><h2 id="第一个项目">第一个项目</h2><blockquote><p>以C#控制台实现模型减面为例</p></blockquote><ol><li>Visual Studio创建一个.Net控制台项目</li></ol><p><img src="/images/%E6%96%B0%E5%BB%BACSharp%E9%A1%B9%E7%9B%AE.png" class="lazyload" data-srcset="/images/%E6%96%B0%E5%BB%BACSharp%E9%A1%B9%E7%9B%AE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="新建CSharp项目"></p><ol start="2"><li>添加COM依赖，引入转义文件<code>SimplygonDotNetWapper.dll</code></li></ol><img src="/images/添加COM依赖.png" class="lazyload" data-srcset="/images/添加COM依赖.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="添加COM依赖" style="zoom: 80%;" /><p><img src="/images/Simplygon%E4%BE%9D%E8%B5%96.png" class="lazyload" data-srcset="/images/Simplygon%E4%BE%9D%E8%B5%96.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Simplygon依赖"></p><ol start="3"><li>在项目中添加<code>SimplygonLoader.cs</code>和减面用的模型</li></ol><p><img src="/images/Loader%E4%BD%8D%E7%BD%AE.png" class="lazyload" data-srcset="/images/Loader%E4%BD%8D%E7%BD%AE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Loader位置"></p><p><img src="/images/%E6%B7%BB%E5%8A%A0Loader.png" class="lazyload" data-srcset="/images/%E6%B7%BB%E5%8A%A0Loader.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="添加Loader"></p><ol start="4"><li>编写代码，实现模型按比例减面</li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查是否Load Simplygon</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> sg = Simplygon.Loader.InitSimplygon(<span class="keyword">out</span> <span class="keyword">var</span> errorCode, <span class="keyword">out</span> <span class="keyword">var</span> errorMessage);</span><br><span class="line">    <span class="keyword">if</span> (errorCode != Simplygon.EErrorCodes.NoError)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Failed to initialize Simplygon: ErrorCode(<span class="subst">&#123;(<span class="built_in">int</span>)errorCode&#125;</span>) <span class="subst">&#123;errorMessage&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">int</span>)errorCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 运行减面程序</span></span><br><span class="line">    RunReduction(sg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunReduction</span>(<span class="params">Simplygon.ISimplygon sg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 加载模型/场景         </span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Load scene to process.&quot;</span>);</span><br><span class="line">    Simplygon.spScene sgScene = LoadScene(sg, <span class="string">&quot;../../../SimplygonMan.obj&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">using</span> Simplygon.spReductionProcessor sgReductionProcessor = sg.CreateReductionProcessor();</span><br><span class="line">    sgReductionProcessor.SetScene(sgScene);</span><br><span class="line">    <span class="keyword">using</span> Simplygon.spReductionSettings sgReductionSettings = sgReductionProcessor.GetReductionSettings();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减面设置</span></span><br><span class="line">    sgReductionSettings.SetReductionTargets(Simplygon.EStopCondition.All, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 三角面变为50%</span></span><br><span class="line">    sgReductionSettings.SetReductionTargetTriangleRatio(<span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行        </span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Start the reduction process.&quot;</span>);</span><br><span class="line">    sgReductionProcessor.RunProcessing();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存模型，通过修改后缀可以实现导出obj, fbx, usd等类型的模型         </span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Save processed scene.&quot;</span>);</span><br><span class="line">    SaveScene(sg, sgScene, <span class="string">&quot;Output.obj&quot;</span>);</span><br><span class="line">       </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Check log for any warnings or errors.&quot;</span>);</span><br><span class="line">    CheckLog(sg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Simplygon.<span class="function">spScene <span class="title">LoadScene</span>(<span class="params">Simplygon.ISimplygon sg, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create scene importer </span></span><br><span class="line">    <span class="keyword">using</span> Simplygon.spSceneImporter sgSceneImporter = sg.CreateSceneImporter();</span><br><span class="line">    sgSceneImporter.SetImportFilePath(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run scene importer. </span></span><br><span class="line">    <span class="keyword">var</span> importResult = sgSceneImporter.Run();</span><br><span class="line">    <span class="keyword">if</span> (Simplygon.Simplygon.Failed(importResult))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.Exception(<span class="string">&quot;Failed to load scene.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Simplygon.spScene sgScene = sgSceneImporter.GetScene();</span><br><span class="line">    <span class="keyword">return</span> sgScene;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveScene</span>(<span class="params">Simplygon.ISimplygon sg, Simplygon.spScene sgScene, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create scene exporter. </span></span><br><span class="line">    <span class="keyword">using</span> Simplygon.spSceneExporter sgSceneExporter = sg.CreateSceneExporter();</span><br><span class="line">    <span class="built_in">string</span> outputScenePath = <span class="built_in">string</span>.Join(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;output\\&quot;</span>, <span class="string">&quot;Reduction&quot;</span>, <span class="string">&quot;_&quot;</span>, path &#125;);</span><br><span class="line">    sgSceneExporter.SetExportFilePath(outputScenePath);</span><br><span class="line">    sgSceneExporter.SetScene(sgScene);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run scene exporter. </span></span><br><span class="line">    <span class="keyword">var</span> exportResult = sgSceneExporter.Run();</span><br><span class="line">    <span class="keyword">if</span> (Simplygon.Simplygon.Failed(exportResult))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.Exception(<span class="string">&quot;Failed to save scene.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckLog</span>(<span class="params">Simplygon.ISimplygon sg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check if any errors occurred. </span></span><br><span class="line">    <span class="built_in">bool</span> hasErrors = sg.ErrorOccurred();</span><br><span class="line">    <span class="keyword">if</span> (hasErrors)</span><br><span class="line">    &#123;</span><br><span class="line">        Simplygon.spStringArray errors = sg.CreateStringArray();</span><br><span class="line">        sg.GetErrorMessages(errors);</span><br><span class="line">        <span class="keyword">var</span> errorCount = errors.GetItemCount();</span><br><span class="line">        <span class="keyword">if</span> (errorCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Errors:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">uint</span> errorIndex = <span class="number">0</span>; errorIndex &lt; errorCount; ++errorIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> errorString = errors.GetItem((<span class="built_in">int</span>)errorIndex);</span><br><span class="line">                Console.WriteLine(errorString);</span><br><span class="line">            &#125;</span><br><span class="line">            sg.ClearErrorMessages();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No errors.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if any warnings occurred. </span></span><br><span class="line">    <span class="built_in">bool</span> hasWarnings = sg.WarningOccurred();</span><br><span class="line">    <span class="keyword">if</span> (hasWarnings)</span><br><span class="line">    &#123;</span><br><span class="line">        Simplygon.spStringArray warnings = sg.CreateStringArray();</span><br><span class="line">        sg.GetWarningMessages(warnings);</span><br><span class="line">        <span class="keyword">var</span> warningCount = warnings.GetItemCount();</span><br><span class="line">        <span class="keyword">if</span> (warningCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Warnings:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">uint</span> warningIndex = <span class="number">0</span>; warningIndex &lt; warningCount; ++warningIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> warningString = warnings.GetItem((<span class="built_in">int</span>)warningIndex);</span><br><span class="line">                Console.WriteLine(warningString);</span><br><span class="line">            &#125;</span><br><span class="line">            sg.ClearWarningMessages();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No warnings.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error out if Simplygon has errors. </span></span><br><span class="line">    <span class="keyword">if</span> (hasErrors)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.Exception(<span class="string">&quot;Processing failed with an error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行，检查减面效果</li></ol><p>减面前：</p><p><img src="/images/%E5%87%8F%E9%9D%A2%E5%89%8D.png" class="lazyload" data-srcset="/images/%E5%87%8F%E9%9D%A2%E5%89%8D.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="减面前"></p><p>50%减面</p><p><img src="/images/%E5%87%8F%E9%9D%A2%E5%90%8E.png" class="lazyload" data-srcset="/images/%E5%87%8F%E9%9D%A2%E5%90%8E.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="减面后"></p><p>10%减面</p><p><img src="/images/%E5%87%8F%E9%9D%A210.png" class="lazyload" data-srcset="/images/%E5%87%8F%E9%9D%A210.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="减面10"></p><p>能看出三角面和顶点数按比例减少了</p><blockquote><p>在使用过程中，发现相同精度的模型，fbx顶点数比obj小，是两者顶点buffer组织的差异导致的吗？还是Win11自带的模型预览器统计方式有问题</p></blockquote><h2 id="其他功能">其他功能</h2><p>Simplygon还提供了许多功能，除了基础的静态模型减面生成LOD外，还支持人物模型LOD（保留权重），骨骼缩减，远景、树草替代物生成（如Billboard），遮蔽物减面，详情可以参考<a href="https://documentation.simplygon.com/SimplygonSDK_10.1.8000.0/api/examples/gettingstarted.html#prerequisites">官方文档</a>，这里仅抛砖引玉</p>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C与C++的DLL</title>
      <link href="/program/C++DLL/"/>
      <url>/program/C++DLL/</url>
      
        <content type="html"><![CDATA[<h1>C与C++的DLL</h1><blockquote><p>今天中午跟同事吃饭时，有人分享他在清理项目中的Warming，其中包括C++风格的DLL，我才知道，DLL建议写C风格的</p></blockquote><p>根本原因是，C++功能复杂，更依赖Name Mangling，而三大编译器具体实现不尽相同，使得ABI不确定</p><h2 id="DLL">DLL</h2><blockquote><p>我们都知道，代码到可执行文件，要先代码<strong>编译</strong>得到目标文件，目标文件<strong>链接</strong>得到可执行文件。但其实可执行文件在执行时，还会进行<strong>装载</strong></p></blockquote><p>DLL的本质其实是<strong>目标文件</strong>的打包，由目标文件和三张表组成</p><h3 id="编译">编译</h3><p>代码会编译为目标文件<code>.obj</code>，目标文件中包含<strong>导出符号表</strong>，这些符号会有明确的地址</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test1.cpp</span></span><br><span class="line"><span class="type">int</span> a;<span class="comment">// 在test1.obj文件中a有明确的地址</span></span><br></pre></td></tr></table></figure><p>有的文件中会有只声明，没有实现的符号，放在<strong>未解决符号表</strong>中。在这些符号没有明确的地址，需要去其他目标文件中寻找</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;<span class="comment">// 在test2.obj文件中a没有明确的地址</span></span><br></pre></td></tr></table></figure><h3 id="链接与装载">链接与装载</h3><p>若程序为<strong>静态链接</strong>，编译器会在链接阶段扫描导出符号表中的符号地址，将计算后的地址写给未解决符号表中的符号，这个过程被称为重定位</p><p>也就是说，从<code>test1.obj</code>中得到<code>a</code>的地址，经过计算，写给<code>test2.obj</code>中的<code>a</code>，这个过程会记录在<strong>地址重定向表</strong>中</p><p>若程序为<strong>动态链接</strong>，程序会在装载阶段做地址重定向</p><h2 id="ABI">ABI</h2><blockquote><p>ABI（Application binary interface）</p><p>API（Application Programming Interface）</p></blockquote><p>为了保证动态库的版本兼容性，大部分平台会要与DLL函数编写时，要符合ABI</p><p>ABI包含了二进制的结构布局、访问方法，应用程序可以通过ABI访问库中的二进制数据，代码编译出的ABI与编程语言、操作系统、编译器有关，通常是不确定的</p><h3 id="二进制文件格式">二进制文件格式</h3><p>不同操作系统的二进制可执行文件格式不同，因此无法兼容</p><p>ELF（Executable and Linkable Format），可执行可链接格式，是Linux系统的二进制可执行文件格式</p><p>PE（Portable Executable），可移植可执行格式，是Windows系统的二进制可执行文件格式</p><h3 id="Name-Mangling">Name Mangling</h3><p>Name Mangling会对名字进行重新编码，以实现名字的唯一性</p><p>C++支持函数重载、类、命名空间、模版，一个类中可以有多个重名函数、重名成员变量，这些名称编译后本质是不同的二进制，因此要做更复杂的Name Mangling</p><p>很不幸的是，C++没有对Name Mangling做硬性规定，于是三大编译器g++、MSVC、clang的实现不同，相同的代码可能编出不同的ABI，当你使用跨编译器的dll时，很容易出现错误</p><h3 id="C的DLL">C的DLL</h3><p>和C++相比，C就简单得多</p><p>大多数语言都提供了一些简单的方法调用C的DLL，而且C++编译器也支持导出C语言的DLL</p><h2 id="生成DLL">生成DLL</h2><p>Windows下生成DLL会得到三个产物：include头文件，dll文件，import library文件</p><blockquote><p>注意import library文件的后缀是<code>.lib</code>，但这个文件只是存储了符号表，并不是其他平台的静态库</p></blockquote><h3 id="MT与MD">MT与MD</h3><blockquote><p>操作系统将一些高频使用的代码写成DLL，并永远加载在内存中，称为CRT库</p></blockquote><p>在VS生成DLL时，有MT和MD两个选项</p><p>MD指动态C运行时，程序执行时依赖于操作系统提供的CRT</p><p>MT指静态C运行时，程序会将操作系统的一些CRT静态链接到程序中，运行时就不需要从操作系统那里装载</p><p>值得注意的是，如果一个程序混用MT和MD，很容易出现版本不兼容的错误（尤其是在使用编译好的第三方库时）</p><h3 id="C-生成DLL">C++生成DLL</h3><p>CMakeList.txt</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIB_SRC ./<span class="keyword">Math</span>.h ./<span class="keyword">Math</span>.cpp)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY ../libMath)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(MathDLL SHARED <span class="variable">$&#123;LIB_SRC&#125;</span>)</span><br><span class="line"><span class="keyword">INSTALL</span>(TARGETS MathDLL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(MathDLL PROPERTIES LINKER_LANGUAGE C</span><br><span class="line">        RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span></span><br><span class="line">        LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span></span><br><span class="line">        OUTPUT_NAME <span class="string">&quot;MathDLL&quot;</span></span><br><span class="line">        PREFIX <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>Math.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_EXPORT extern <span class="string">&quot;C&quot;</span> __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="type">int</span> <span class="title">MathAdd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>Math.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MathAdd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态加载DLL">动态加载DLL</h2><p>windows下DLL加载：</p><ol><li>分析可执行文件的导入符号表，查找所需要的dll文件</li><li>为dll文件开辟虚拟地址空间</li><li>当dll被真正调用时，将dll文件加载到内存中</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pfnAdd)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HINSTANCE handle = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;../lib/libMath/MathDLL.dll&quot;</span>));</span><br><span class="line">    pfnAdd pAdd = (pfnAdd) <span class="built_in">GetProcAddress</span>(handle, <span class="string">&quot;MathAdd&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">pAdd</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="https://stackoverflow.com/questions/16730284/dll-written-in-c-vs-the-same-written-in-c">DLL written in C vs the same written in C++</a></p><p><a href="https://stackoverflow.com/questions/2171177/what-is-an-application-binary-interface-abi">What is an application binary interface (ABI)?</a></p><p><a href="https://github.com/JasonkayZK/cpp-learn/tree/dll">使用CMake生成动态链接库DLL</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：前缀和</title>
      <link href="/program/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/program/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1>前缀和</h1><blockquote><p>本人没有算法基础，以下均为春招刷Leetcode的笔记，仅用于记录，侵权勿喷</p></blockquote><p>前缀和本质是一种预积分手段，运行时只需要得到边界值，就能快速、无损地获得区间积分值，二维的前缀和SAT在图形学中也有重要的运用</p><ul><li>注意数组越界，尤其是前缀乘</li><li>明确索引的含义，这关系着数组的长度是否需要+1</li><li>前缀和可以使用哈希表加速查找</li></ul><h3 id="除自身以外数组的乘积">除自身以外数组的乘积</h3><p><a href="https://leetcode.cn/problems/product-of-array-except-self/">leetcode</a></p><blockquote><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p><p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p><p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p></blockquote><h4 id="特点">特点</h4><p>使用左右两个前缀和</p><h4 id="思路">思路</h4><blockquote><p>最简单的方法自然是求所有数的总乘积，<code>ans[i] = total / nums[i]</code>，不过这道题让我们不要用除法（如果数中有0，这种做法也是错的）</p></blockquote><ol><li><p>我们从左做一次前缀乘，<code>left[i]</code>表示以<code>0~i</code>的前缀乘，从右开始做一次前缀乘，<code>right[i]</code>表示以<code>i~n-1</code>的前缀乘</p></li><li><p><code>ans[i]</code>将数组切分为三个部分，他自己，左边和右边，左边等于<code>0~i-1</code>的总乘积，右边等于<code>i+1～n-1</code>的总乘积，左右相乘即可得到最终结果</p></li><li><p>对于边界做特殊处理</p></li></ol><h4 id="实现">实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        right[n<span class="number">-1</span>] = nums[n<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 求左右前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>] * nums[i];</span><br><span class="line">            right[n-i<span class="number">-1</span>] = right[n-i] * nums[n-i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="comment">// 边界处理</span></span><br><span class="line">        ans[<span class="number">0</span>] = right[<span class="number">1</span>];</span><br><span class="line">        ans[n<span class="number">-1</span>] = left[n<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            ans[i] = left[i<span class="number">-1</span>] * right[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="和为k的子数组">和为k的子数组</h3><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">leetcode</a></p><blockquote><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em></p><p><code>-1000 &lt;= nums[i] &lt;= 1000</code></p></blockquote><h4 id="特点-2">特点</h4><p>数组有正有负，因此前缀和不递增</p><h4 id="思路-2">思路</h4><p>固定右端点，向左找左端点，若存在和为<code>k</code>的连续子数组，我们能找到一个左端点，使得左右端点前缀和之差为<code>k</code></p><p>由于数组中包含负数，因此左端点可能有多个</p><p>于是问题转化为从右端点出发，寻找值为<code>ps[j] - k</code>的左端点</p><p>当遍历完<code>i</code>后，当前右端点<code>preSum[i]</code>未来也可能是左端点，于是加入哈希表中</p><h4 id="实现-2">实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preSum</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">// value：key出现过的次数</span></span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            preSum[i+<span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            ans += mp[preSum[i]-k];</span><br><span class="line">            ++mp[preSum[i]];<span class="comment">// 在遍历完i之前，我们还没遇到过i</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：区间重叠</title>
      <link href="/program/%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/"/>
      <url>/program/%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<h1>区间重叠</h1><blockquote><p>本人没有算法基础，以下均为春招刷Leetcode的笔记，仅用于记录，侵权勿喷</p></blockquote><p>今天刷题时发现一类区间重叠题，思路很巧妙，理解后做起来非常简单</p><p>这类题的特点就是给你一组区间，求最多多少个区间重叠</p><h3 id="会议室Ⅱ">会议室Ⅱ</h3><p><a href="https://leetcode.cn/problems/meeting-rooms-ii/submissions/">leetcode</a></p><blockquote><p>给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间，返回 所需会议室的最小数量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[0,30],[5,10],[15,20]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure></blockquote><h4 id="思路">思路</h4><p>我们将区间转化为两次操作，对于每一个区间，区间开始会申请一个会议室，区间结束会释放一个会议室</p><p>将操作按发生时间排序，依次执行，记录占用会议室的最大数量</p><h4 id="实现">实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : intervals)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;i[<span class="number">0</span>], <span class="number">1</span>&#125;);<span class="comment">// 区间开始申请一个会议室</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;i[<span class="number">1</span>], <span class="number">-1</span>&#125;);<span class="comment">// 区间结束释放一个会议室</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">// 将操作按发生时刻排序，对于同时发生的操作，先释放再申请</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sort(v.begin(), v.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)-&gt;bool&#123;</span></span><br><span class="line"><span class="comment">            if(a[0] == b[0])&#123;</span></span><br><span class="line"><span class="comment">                return a[1] &lt; b[1];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return a[0] &lt; b[0];</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            cur += v[i][<span class="number">1</span>];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拼车">拼车</h3><p><a href="https://leetcode.cn/problems/car-pooling/">leetcode</a></p><blockquote><p>车上最初有 capacity 个空座位。车只能向一个方向行驶（也就是说，不允许掉头或改变方向）</p><p>数组每一项包含三个数，上车人数，上车时刻，下车时刻</p><p>当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：trips = [[2,1,5],[3,3,7]], capacity = 4</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure></blockquote><h4 id="思路-2">思路</h4><p>与上题基本相同，不过每次操作的数量改变了</p><h4 id="实现-2">实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">carPooling</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trips, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t: trips)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;t[<span class="number">1</span>], t[<span class="number">0</span>]&#125;);</span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;t[<span class="number">2</span>], -t[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            cur += v[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cur &gt; capacity)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google C++代码规范</title>
      <link href="/program/GoogleC++/"/>
      <url>/program/GoogleC++/</url>
      
        <content type="html"><![CDATA[<h1>Google C++ 代码规范</h1><p><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></p><p>Google提出的一套代码规范，能提高代码的可读性，减少出错。建议配合<a href="/2023/01/31/program/Effective%20C++/">Effective C++</a>阅读</p><h2 id="头文件">头文件</h2><h3 id="所有头文件都应该自给自足（self-contained）">所有头文件都应该自给自足（self-contained）</h3><blockquote><p>self-contained : compile on their own</p></blockquote><p>确保你的header files包含了你需要的所有东西，而不是假设你#include进来的某个（些）headers帮你包含了你需要的东西。</p><p>A.h包含了B.h和C.h，而B.h也包含了C.h，那么在A.h中使用C.h时，会难以判断到底该用哪一个</p><h3 id="define-保护">#define 保护</h3><p>每个头文件都要使用<code>#pragma once</code>保护</p><h3 id="前置声明">前置声明</h3><p>我个人理解的前置声明，是指在一个<code>.h</code>文件中开头声明另一个<code>.h</code>文件中的类，以此来实现类似<code>#include</code>某个文件的某一部分</p><p>与之对应的是直接使用<code>#include</code>引入文件，但这样实际会增加编译工作量，降低编译速度，于是我们非必要不<code>#include</code></p><blockquote><p>Google建议要避免使用前置声明，因为使用前置声明会影响类的修改，也容易产生错误</p><p>但使用前置声明可以提高编译速度，因此需要按情况选择</p></blockquote><p>优点</p><ul><li>节省编译时间，避免很多不必要的（因为头文件改动而导致的）重新编译</li></ul><p>缺点</p><ul><li>隐藏了依赖关系</li><li>头文件改动时会破坏后续，影响开发者改动API（比如当你要添加一个形参时）<ul><li>但这个是不是可以通过宏的方法避免？<code>#define Func Func</code></li></ul></li></ul><h4 id="两个类互相引用">两个类互相引用</h4><p>前置声明（Forward Declarations）基本仅用于两个类互相引用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    B b;<span class="comment">//A中使用了B，因此</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">A* a;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="失去依赖关系">失去依赖关系</h4><p>前置声明最大的问题是失去依赖关系</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B &#123;&#125;;<span class="comment">//这里的D继承自B</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="comment">// 如果使用前置声明替换掉#include，就会出现错误</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(D* x)</span> </span>&#123; <span class="built_in">f</span>(x); &#125;  <span class="comment">// Calls f(B*)</span></span><br></pre></td></tr></table></figure><h3 id="内联函数">内联函数</h3><p>除非是极其高频调用，确定是性能瓶颈的地方，不然不用内联函数</p><p>不要内敛超过十行的函数</p><p>析构函数远比表面要长，因为他隐式调用着成员和基类的析构函数</p><h3 id="include路径">#include路径</h3><p>按照源码目录树结构排列，避免使用UNIX的快捷目录，比如<code>.</code>（当前目录）和<code>..</code>（上级目录）</p><h3 id="include顺序">#include顺序</h3><ol><li>C头文件</li><li>C++头文件</li><li>第三方库头文件</li><li>本项目头文件</li></ol><h2 id="作用域">作用域</h2><p>命名空间将全局作用域细分为独立具体的作用域，可以有效防止全局命名冲突</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyNamespace</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;    <span class="comment">//namespace MyNamespace</span></span><br></pre></td></tr></table></figure><h3 id="请在命名空间最后注释出命名空间的名字">请在命名空间最后注释出命名空间的名字</h3><h3 id="不要污染命名空间">不要污染命名空间</h3><ul><li>不要在std命名空间中声明任何东西</li><li>不要使用<code>using namespace xxx</code></li><li>不要在头文件中使用命名空间别名，如<code>namespace bbb = ::Foo::Bar::Baz</code></li></ul><h3 id="静态变量">静态变量</h3><p>不要在.h文件中声明静态变量，至少不能用全裸的静态变量</p><p>不要定义静态存储周期<strong>非</strong>POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中静态变量的构造和析构顺序不确定，会导致bug（除非你使用constexpr）</p><p>原生数据类型（POD，Olain Old Data），如int、char、float，int*、int[]、结构体</p><p>在同一编译单元，静态初始化会优先于动态初始化，并按照声明顺序初始化，以逆序销毁</p><p>但是不同编译单元，初始化、销毁顺序是未定义行为</p><h2 id="类">类</h2><h3 id="构造函数不要调用虚函数">构造函数不要调用虚函数</h3><p>在类被完全初始化前，这个类其实是基类+其他部分，此时调用虚函数不一定会指向子类的重载，可能会报错、出错</p><p>优点</p><ul><li>不需要考虑类是否被完全初始化</li><li>初始化的对象可以为const类型</li></ul><p>如果你想进行有意义的non-trivial初始化，可以使用明确的Init()方法，或者工厂模式</p><blockquote><p>与之对应，析构函数要设为虚函数</p></blockquote><h3 id="不要隐式类型转换">不要隐式类型转换</h3><p>不要使用隐式类型转换</p><ul><li>隐式转换会降低代码可读性，由于是存在函数重载时，让人难以判断到底在用哪一个函数</li><li>隐式转化可能会导致类型不匹配的错误</li></ul><p>使用explict关键词（常用于<strong>单参数</strong>构造函数和类型转化操作符），可以使当前类型只能被显示类型转换，如果使用隐式转化，会报错</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;    <span class="comment">//这个类型不能被隐式转化，调用Func(&#123;42, 3.14&#125;)会报错</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(Foo f)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="拷贝和移动">拷贝和移动</h3><p>如果你的类型需要拷贝和支持，就请实现它，否则禁用它（<code>=delete</code>）</p><p><code>std::unique_ptr&lt;int&gt; </code>可移动，但是不能复制</p><ul><li>可拷贝类型，可以使用相同类型的另一对象进行初始化，当前对象会得到相同的值，同时不改变源对象。<ul><li>用户通过定义拷贝构造函数、拷贝赋值操作符实现</li></ul></li><li>可移动对象，可以使用相同类型的临时对象进行初始化，当前对象会得到相同的值<ul><li>用户通过定义移动构造函数、移动赋值操作符实现</li></ul></li></ul><p>不要为任何有可能有子类的类型提供拷贝和移动，可能会导致对象割裂</p><h3 id="除了数据成员，其他一律用class">除了数据成员，其他一律用class</h3><p>C++的class和struct很像，大部分功能相同，不过</p><ul><li>struct可以拥有成员变量，但不能拥有成员函数（你可以写非成员函数+引用）</li><li>struct成员为public，而class可以拥有private成员</li><li>struct的继承方式为public，比class少（尽管全世界C++项目99%的继承都是public继承）</li></ul><h3 id="struct与pairs、tuples">struct与pairs、tuples</h3><p>struct的字段名更具可读性，当数据有意义时，尽量使用struct</p><p>不过pairs和tuples更适用于泛型编程</p><h3 id="组合与继承">组合与继承</h3><p>组合很好用，能用接口用接口，如果非要用继承，请public继承</p><p>对于虚函数进行重载时，用override、final标记，尽管这个关键字没有什么作用，但能提高代码可读性</p><blockquote><p>全世界C++项目99%的继承都是public继承</p><p>public、protected、private继承你可以理解为设限</p><p>如果是public继承，那么子类访问父类成员的存取类型都不会超高public（废话），父类的public、protected、private成员，对于子类为public、protected、private</p><p>如果是protected继承，那么子类访问父类成员的存取类型都不会超高protected，父类的public、protected、private成员，对于子类为protected、protected、private</p></blockquote><p>请不要使用多重继承，不过你能继承多个接口</p><p>关于接口</p><ul><li>接口是用interface标记的类，只有纯虚数和静态函数，没有非静态成员</li><li>接口不能被直接实例化，也不需要定义构造函数</li><li>请为接口实现虚析构函数</li><li>请不要为其添加函数实现或非静态成员数据</li></ul><h3 id="操作符重载">操作符重载</h3><p>尽量别重载</p><h3 id="访问控制">访问控制</h3><p>类的数据成员应该为private，除非是一个常量</p><blockquote><p>数据成员设为private，然后编写public的访问函数，不过感觉不如C#的属性优雅</p></blockquote><h3 id="声明顺序">声明顺序</h3><blockquote><p>随便找个<code>.h</code>文件，看看类的声明是怎么写的</p></blockquote><ul><li>相似的声明放在一起，并按以下顺序<ul><li>类型及类型别名（<code>typedef, using, enum </code>，嵌套的结构体和类）</li><li>静态常量</li><li>工厂函数</li><li>构造函数和赋值运算符</li><li>析构函数</li><li>其他函数</li><li>数据成员</li></ul></li><li>先写public，再写protected、private</li></ul><p>不要将大段的函数定义写在类定义中，建议<code>.h</code>声明，<code>.cpp</code>定义</p><h2 id="函数">函数</h2><h3 id="参数">参数</h3><blockquote><p>见名知意，知行合一</p><p>看到函数名就能知道这是干什么的，比如Get、Set，如果一个函数是Get，那就做Get的事</p></blockquote><ul><li>优先使用返回值而非输出参数，这能提高可读性和性能</li><li>不要返回空指针（除非你是这样设计的）</li><li>输入参数、不需要改变的参数可以用const引用</li><li>输出参数、可以被修改的参数可以用指针</li><li>参数需要排序，输入先于输出，无默认值先于有默认值</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::string&amp; in_str, std::string* out_str)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="简短的函数">简短的函数</h3><blockquote><p>个人感觉完全没必要，尤其是对于C#、Java，40行好干什么</p></blockquote><p>简短的函数能提高代码可读性，提高调试效率，在函数式编程很常用</p><h3 id="函数重载">函数重载</h3><p>函数重载能够使同一作用域中，有一组相同函数名、不同参数列表的函数，常用于命名一组功能相似的函数</p><p>不过如果函数仅靠参数类型进行重载，就会涉及匹配、派生类之类的问题，让人感受困惑</p><blockquote><p>如果要重载Append()，其实可以在函数名上添加类型信息，比如AppendInt()、AppendString()</p></blockquote><h3 id="缺省参数">缺省参数</h3><blockquote><p>写缺省不如写重载</p></blockquote><p>缺省本质上就是一种函数重载，所有不适合使用重载的地方，都不适合使用缺省</p><p>由于缺省参数会干扰函数指针，因此一定不要在虚函数中使用缺省参数</p><h3 id="函数返回值的后置写法">函数返回值的后置写法</h3><blockquote><p>后置写法本身没问题，swift、js等语言都是这样写的，但是对于C++来说是一种“很新的东西”，容易让人感到困惑</p></blockquote><p>C++11后，C++的函数可以使用后置返回类型，不过除了lambda表达式，一般不这样写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置写法</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> -&gt; <span class="type">int</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda只能后置写法</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br></pre></td></tr></table></figure><p>在泛型编程中，当返回类型依赖于模版参数时，也可以使用后置写法，能提高可读性</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置写法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;())</span> <span class="title">add</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置写法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="所有权和智能指针">所有权和智能指针</h3><blockquote><p>关于所有权和智能指针，可以参考<a href="https://reubensun.com/engine/GC/">垃圾回收</a>中引用计数法</p><p>C++标准鼓励我们使用智能指针管理资源</p></blockquote><p>对于一个动态的对象，我们更倾向于让其拥有单一、固定所有权（ownership），并使用指南指针做所有权转换</p><ul><li><code>std::unique_ptr</code>，独占资源<ul><li>当指针离开作用域，资源就会被销毁</li><li>无法复制（copy），但能转移（move）所有权</li></ul></li><li><code>std::shared_ptr</code>，共享资源<ul><li>当资源失去所有引用时，资源被销毁</li><li>可以复制，共享所有权（无需转移）</li></ul></li></ul><p>好处</p><ul><li>有的对象甚至没法复制，只能转移</li><li>转移通常比复制更高效，尤其是一些const对象，转移比深拷贝高效得多</li><li>使用智能指针能提高可读性，也减少了内存泄漏</li></ul><h2 id="其他">其他</h2><h3 id="右值引用">右值引用</h3><blockquote><p>关于左右值，建议阅读<a href="https://reubensun.com/program/C++11/">C++11</a></p></blockquote><p>只在定义移动构造函数和移动赋值操作时使用右值引用</p><p>推荐使用<code>std::move</code>，不要使用<code>std::forward</code>（除非你在模版编程）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> string &amp; var1, <span class="type">const</span> string &amp; var2)</span></span>&#123;</span><br><span class="line">  m_var1 = var1;</span><br><span class="line">  m_var2 = var2;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// move</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(string &amp;&amp; var1, string &amp;&amp; var2)</span></span>&#123;</span><br><span class="line">  m_var1 = std::<span class="built_in">move</span>(var1);  </span><br><span class="line">  m_var2 = std::<span class="built_in">move</span>(var2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// forward</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(T1 &amp;&amp; var1, T2 &amp;&amp; var2)</span></span>&#123;</span><br><span class="line">  m_var1 = std::forward&lt;T1&gt;(var1);</span><br><span class="line">  m_var2 = std::forward&lt;T2&gt;(var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>forward的作用是什么？</p><p>如果不使用forward，我们需要同时定义copy和move函数，在处理左值时调用copy，处理右值调用move，这增加了代码量，如果使用forward，我们只需要写一份</p><p>但forward让一个函数能干两种事，这不符合“知行合一”，为了代码可读性，我们通常不会使用。如果我们明确这个函数要move，那就用move</p></blockquote><h3 id="友元">友元</h3><p>友元：在定义一个类时，可以将一些（定义在外部的）函数声明为友元，这些友元函数可以访问该类的private、protected成员</p><ul><li>友元扩大了类的封装，在OOP中很忌讳，但只要合理，还是可以用的<ul><li>原本是private的成员，对于友元类、函数，都是public的</li><li>友元类似一种许可，当一个类设置友元后，相当于给友元开了管理员权限，能随意访问原本受保护的成员</li></ul></li><li>如果你要用，请写在同一个文件中</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Child</span>() &#123; name = <span class="string">&quot;default name&quot;</span>; &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Mother</span>;<span class="comment">// 母亲有权利修改孩子的名字，尽管setName是private的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string nn)</span> </span>&#123; name = nn; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mother</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Child child;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">renameChild</span><span class="params">(string nn)</span></span>&#123; child.<span class="built_in">setName</span>(nn); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mother mother;</span><br><span class="line">    Child child;</span><br><span class="line">    mother.child = child;</span><br><span class="line"><span class="comment">// child.setName()的访问控制为private，你没法在这里调用</span></span><br><span class="line">    cout &lt;&lt; mother.child.<span class="built_in">getName</span>() &lt;&lt; endl;<span class="comment">// default name</span></span><br><span class="line">    mother.<span class="built_in">renameChild</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    cout &lt;&lt; mother.child.<span class="built_in">getName</span>() &lt;&lt; endl;<span class="comment">// Tom</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常">异常</h3><blockquote><p>谷歌不使用C++异常，让异常Let it crash。不过异常在C#、Java、Swift中很常用，</p></blockquote><p>抛异常可能会导致一些未定义行为，比如不要在析构函数中使用异常</p><p>不使用异常，如果出错常用方法为：</p><ul><li>直接<code>abort()</code></li><li>吞异常，Let it crash</li></ul><h3 id="RTTI">RTTI</h3><p>不使用运行时类型识别，不使用<code>typeid</code>和<code>dynamic_cast</code></p><p>运行时类型识别会使代码难以维护，如果你需要用RTTI（除了单元测试），说明你的类设计的不好</p><h3 id="类型转化">类型转化</h3><p>使用C++风格的类型转化（而非C风格的）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> double_value;</span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(double_value);</span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="type">float</span> f2 = (<span class="type">float</span>)double_value;</span><br></pre></td></tr></table></figure><ul><li>使用<code>static_cast</code>做值转换、子类指针转父类指针</li><li>使用<code>const_cast</code>去掉const限定符</li><li>使用<code>reinterpret_cast</code>做指针和整型、指针和指针间的转换（仅在你会用时使用）</li><li>不使用<code>dynamic_cast</code></li></ul><h4 id="严格别名">严格别名</h4><blockquote><p>C++的<code>reinterpret_cast</code>不会编译为任何CPU指令，会编译为纯汇编，于是你可以像汇编一样操作指向内存的指针地址，破坏了C++对汇编对抽象</p></blockquote><p>严格别名（strict aliasing）规定：只有同一种类型的指针，才可以出现别名，总之没事别做不相干类型的指针转化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span>* f;</span><br><span class="line"><span class="type">int</span>* i;</span><br><span class="line"><span class="comment">// 编译器优化时会假定 f != i</span></span><br><span class="line"><span class="comment">// 若你的代码让 f == i （比如使用reinterpret_cast），那就是未定义行为，违反严格别名规则</span></span><br></pre></td></tr></table></figure><p>当你通过指针，将一个struct塞到一个buffer中，或者将一个buffer塞到struct中，在这个过程中，指针的类型发生转换，从buffer转化为struct</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; Msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* p = x;</span><br><span class="line"></span><br><span class="line">    Msg* msg = (Msg*)p;<span class="comment">// Msg* msg = reinterpret_cast&lt;Msg*&gt;(p);</span></span><br><span class="line">    cout &lt;&lt; msg-&gt;a &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; msg-&gt;b &lt;&lt; endl;<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个过程干了什么？你知道这个buffer的内存地址、长度，你想直接用这些信息访问内存，这是对的，但是某些情况下这就是未定义行为</p><h3 id="流">流</h3><p>谷歌认为除了日志接口需要，不要使用流</p><p>说实话我感觉流挺方便的，只要能保持输出的一致性就行，而且C++的Stream类型安全，用起来十分方便，尤其是输出字符串和对象时</p><h3 id="自增与自减">自增与自减</h3><p>谷歌建议一律使用前置自增自减，尤其是迭代器</p><p>一般而言，使用前置自增<code>++i</code>能提高性能，后置会生成临时对象和拷贝复制</p><blockquote><p>不过，如果自增自减后变量并没有被用到，仅仅是用于记录迭代次数，编译器会对后置自增自减进行优化，性能一样，而且后置更像自然语言，可读性更强</p></blockquote><h3 id="const">const</h3><p>在任何能使用const的地方使用const或constexpr</p><h3 id="整型">整型</h3><p>C++内置的整型只，只使用<code>int</code></p><p>如果需要明确长度，那就用<code>&lt;cstdint</code>中的<code>int16_t</code>、<code>int64_t</code></p><p>如果你不确定用何种大小的int，那么用最大的</p><h3 id="可移植性">可移植性</h3><p>代码应该对32位和64位系统友好，在处理打印、比较、结构体对齐时要注意</p><p>不是所有人都在用64位系统（不过iOS这种封闭平台确实做到了完全禁用32位）</p><h3 id="预处理宏">预处理宏</h3><blockquote><p>尽管在图形Shader中，用宏进行条件变异很常用，但这其实是因为GPU对分支的处理不好，因此我们通过编译多份代码来避免运行时使用分支。不过这对CPU代码纯属是提高包体，降低可读性，增加调试难度，不推荐使用</p></blockquote><ul><li><p>宏具有全局作用域，使你看到的和编译器看到的内容不同，尽量用内联、const进行替换</p></li><li><p>不要使用宏做条件编译</p></li><li><p>不要在<code>.h</code>文件中定义宏</p></li><li><p>使用完<code>#define</code>后要立刻<code>#undef</code></p></li><li><p>不要使用展开后让C++构造不稳定的宏</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">max</span>(++x, ++y);<span class="comment">// 本质为 int n = (++x &gt; ++y ? ++x : ++y)，和预期不一致</span></span><br></pre></td></tr></table></figure><ul><li>不要在宏后面写单行注释</li><li>不要用<code>##</code>处理函数、类、变量的名字，可读性很差</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用##将两个宏拼起来，很trick的写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONS(a,b)   int(a##e##b)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">CONS</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;<span class="comment">// 输出2000，因为CONS宏将2和3拼成了2e3</span></span><br></pre></td></tr></table></figure><h3 id="nullptr">nullptr</h3><p>空指针用nullptr，数值用0（或者0.0），<code>std::string</code>用<code>\0</code></p><p>绝对不要用NULL</p><h3 id="sizeof">sizeof</h3><p>sizeof用于获取类型的大小，不过不建议对类型使用，而是对varname使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyStruct data;</span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(MyStruct));<span class="comment">// 对类型使用，不推荐</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data));<span class="comment">// 对varname使用，推荐</span></span><br><span class="line"><span class="comment">// 如果有人改动了data的类型，比如改成了MyStruct2，第二种方法不会出错</span></span><br></pre></td></tr></table></figure><h3 id="类型推断">类型推断</h3><h4 id="函数模版参数类型推断">函数模版参数类型推断</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">// f&lt;int&gt;(0)</span></span><br></pre></td></tr></table></figure><h4 id="类模版类型推断">类模版类型推断</h4><p>Class Template Argument Deduction（CTAD）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">// a is a std::array&lt;int, 3&gt;</span></span><br></pre></td></tr></table></figure><h4 id="auto变量类型推断">auto变量类型推断</h4><p>若一个变量被声明为auto，那么它的类型会自动匹配成初始化表达式的类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">42</span>;<span class="comment">// a is an int</span></span><br><span class="line"><span class="keyword">auto</span>&amp; b = a;<span class="comment">// b is an int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> d &#123;<span class="number">42</span>&#125;;<span class="comment">// d is an int, not a std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">// il is a std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>有的变量类型巨长（尤其是使用模版和命名空间时），而且一次初始化要写两遍，使用auto能提高可读性</p><ul><li>仅在局部变量中使用auto，比如for循环</li><li>仅在一眼能看出类型的地方使用auto</li><li>不要列表初始化auto变量</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: list)&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="函数返回值类型推断">函数返回值类型推断</h4><p>不要用于函数返回值，除非你是lambda使用后置返回值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="指定的初始化">指定的初始化</h3><blockquote><p>C++20才加入的新东西，感觉大家的项目基本都没法用吧</p></blockquote><p>可以方便的生成高可读性高聚合的初始化表达式，尤其对一些字段顺序不明显的结构</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="type">float</span> x = <span class="number">0.0</span>;</span><br><span class="line">  <span class="type">float</span> y = <span class="number">0.0</span>;</span><br><span class="line">  <span class="type">float</span> z = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p = &#123;</span><br><span class="line">  .x = <span class="number">1.0</span>,</span><br><span class="line">  .y = <span class="number">2.0</span>,</span><br><span class="line">  <span class="comment">// z will be 0.0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式">Lambda表达式</h3><ul><li>将所有的捕获显示写出来</li><li>只有lambda声明周期很短时，才使用<code>[&amp;]</code></li><li>使用<code>[=]</code>显式捕获</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[=](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;<span class="comment">// 默认捕获方式，不好</span></span><br><span class="line">[n](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;<span class="comment">// 显式捕获方式，好</span></span><br><span class="line"></span><br><span class="line">[&amp;] &#123; foo.<span class="built_in">doSomething</span>(); &#125;<span class="comment">// 不好</span></span><br><span class="line">[&amp;foo] &#123; foo.<span class="built_in">doSomething</span>(); &#125;<span class="comment">// 好</span></span><br></pre></td></tr></table></figure><h3 id="泛型编程">泛型编程</h3><p>避免复杂的泛型编程，这东西可读性相当差，调试难度相当高</p><h3 id="别名">别名</h3><p>别名（Aliases）能让复杂类型的名字变简单，尤其是那些带有命名空间的类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Foo Bar;<span class="comment">// 传统方法</span></span><br><span class="line"><span class="keyword">using</span> Bar = Foo;<span class="comment">// C++11后推荐的用法</span></span><br></pre></td></tr></table></figure><ul><li>不要在公共区域使用别名，除非你写对其写详细注释</li><li>不要在公共区域引入命名空间别名</li></ul><h2 id="命名规范">命名规范</h2><blockquote><p>命名规范因项目而异，只要保持一致性即可，谷歌的命名规范我个人不习惯，可能我C#、Swift写的比较多，感觉好奇怪</p></blockquote><h3 id="通用规范">通用规范</h3><p>命名别嫌长，要见名知意</p><blockquote><p>你看看人家Java的方法名长度</p></blockquote><p>不要用汉语拼音</p><blockquote><p>你要记住，英语是表音文字，因此可以靠读音/26个字母排列明确意义，而汉字是象形文字，形状才能明确意义，只靠汉语拼音无法明确区分同音字词。</p><p>而且汉语拼音是新中国扫盲、普及普通话的工具，不仅外国人看不懂，甚至一些说方言的人也看不懂</p></blockquote><p>慎用缩写</p><blockquote><p>日本人用假名翻译“龙”，还省去了几个词，结果/ˈdræɡən/硬是读成了“多拉贡”</p></blockquote><h2 id="注释">注释</h2><blockquote><p>见名知意，自文档的代码确实好，但有时你还是需要写注释，以提高可读性</p></blockquote><ul><li>每个文件开头写入版权公告（不要轻易删除原作者的信息）</li><li>代码段行前注释，描述类行后注释，行后注释要对齐</li><li>假设读代码的人水平比你高，有些过于明显的API解释，不要写（不会有人给<code>i++</code>写注释吧）</li><li>标点、换行（对于python，yml很重要）建议依赖IDE，统一即可</li><li>写TODO（比如Xcode就支持<code>TODO:</code>和<code>MARK:</code>，很多IDE都能检查）</li><li>如果一个接口被弃用，可以写弃用注释<code>DEPRECATED</code></li></ul><h2 id="格式">格式</h2><blockquote><p>个人建议格式依赖IDE，如果你有自己的坚持，那么先配置IDE</p></blockquote><ul><li>一行不能太长，不然别人要缩放屏幕或者拖动水平滚动条，<code>#include</code>语句除外</li><li>使用UTF-8编码（GB-2312的中文注释用UTF-8打开就是乱码）</li><li>只使用空格而非制表符，IDE都支持将制表符替换为空格，建议一个制表符=4个空格</li><li>返回类型，函数名，前几个参数都放在头一行</li><li>空行不要超过两行</li></ul>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学复习</title>
      <link href="/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
      <url>/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>光学复习</h1><h2 id="复习重点">复习重点</h2><ul><li>[x] 相速度</li><li>[x] 偏振态</li><li>[x] 费马原理</li><li>[x] 横向放大率</li><li>[x] 薄透镜成像</li><li>[ ] 透镜组成像（做图法）</li><li>[ ] 反射过程中的相移</li><li>[ ] 布鲁斯特角</li><li>[ ] 反射光与折射光的偏振态</li><li>[x] 全反射</li><li>[x] 相干条件</li><li>[x] 杨氏双缝干涉</li><li>[x] 时间、空间相干性</li><li>[x] 等倾干涉</li><li>[x] 等厚干涉</li><li>[ ] 迈克尔逊干涉仪</li><li>[ ] 多光束干涉</li><li>[x] 增反膜与增透膜</li><li>[x] 惠更斯-菲涅尔原理</li><li>[x] 衍射的分类</li><li>[ ] 衍射与傅立叶变换</li><li>[ ] 单缝衍射</li><li>[x] 圆孔衍射</li><li>[ ] Airy斑</li><li>[ ] 瑞丽判据</li><li>[ ] 多缝衍射</li><li>[x] 光栅方程</li><li>[ ] Abbe成像原理</li><li>[ ] 最小分辨距离、角度</li><li>[x] 光栅</li><li>[x] 双折射</li><li>[x] 惠更斯作图法</li><li>[ ] 波片</li><li>[x] 光偏振态的改变与检测</li><li>[x] 黑体辐射与光量子</li></ul><h2 id="作业解析">作业解析</h2><h3 id="3-32">3.32</h3><blockquote><p>一个4.0 v白炽手电筒灯泡消耗0.25 A，将约1.0%的耗散功率转化为光(λ≈550 nm)。如果梁的截面积是10平方厘米，近似圆柱形</p><p>(a)每秒发射多少光子?(b)每米光束中有多少光子?©光束离开手电筒时的通量密度是多少?</p></blockquote><h4 id="a">a</h4><p>根据功率和光的能量公式<br>$$<br>P=UI<br>$$</p><p>$$<br>n\hslash c/\lambda=0.01P<br>$$</p><p>求出n</p><h4 id="b">b</h4><p>每米光子数=光子总数/长度<br>$$<br>nt=ct<br>$$</p><p>$$<br>c=3.0\times 10^8<br>$$</p><h4 id="c">c</h4><p>$$<br>密度=0.01P/S<br>$$</p><h3 id="8-4">8.4</h3><blockquote><p>描述下列光的偏振态</p></blockquote><img src="/images/求下列偏振态.png" class="lazyload" data-srcset="/images/求下列偏振态.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="求下列偏振态" style="zoom:50%;" /><p>根据xy的振幅和相位判断偏振态<br>$$<br>\delta=(E_x/E_y)\Delta \varphi<br>$$</p><h4 id="ab">ab</h4><p>$$<br>E_x/E_y=-1<br>$$</p><p>$$<br>phase(E_x)=phase(E_y)<br>$$</p><p>偏振方向为<br>$$<br>-\pi/4<br>$$</p><h4 id="c-2">c</h4><p>$$<br>E_x/E_y=1<br>$$</p><p>$$<br>phase(E_x)=phase(E_y)+\pi/4<br>$$</p><p>偏振方向为<br>$$<br>\pi/4<br>$$</p><h4 id="d">d</h4><p>$$<br>E_x/E_y=1<br>$$</p><p>$$<br>phase(E_x)=phase(E_y)-\pi/2<br>$$</p><p>偏振方向为<br>$$<br>-\pi/2<br>$$</p><h4 id="记偏振态的技巧">记偏振态的技巧</h4><p>$\delta = 0$时，是一个左下到右上的线偏振，随着$\delta$增大，偏振的形状呈正弦形状，左顺右逆</p><p><img src="/images/%E5%B7%A6%E9%A1%BA%E5%8F%B3%E9%80%86.png" class="lazyload" data-srcset="/images/%E5%B7%A6%E9%A1%BA%E5%8F%B3%E9%80%86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="左顺右逆"></p><h3 id="7-36">7.36</h3><blockquote><p>证明组速度可以写成</p></blockquote><p>$$<br>v_g=\frac{c}{n}+\frac{\lambda c}{n^2}\frac{\mathrm{d}n}{\mathrm{d}\lambda}<br>$$</p><p>证明</p><img src="/images/求证组速度表示.png" class="lazyload" data-srcset="/images/求证组速度表示.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="求证组速度表示" style="zoom: 33%;" /><h3 id="5-5">5.5</h3><h2 id="考试例题">考试例题</h2><h3 id="求反射光偏振">求反射光偏振</h3><img src="/images/求反射光偏振.png" class="lazyload" data-srcset="/images/求反射光偏振.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="求反射光偏振" style="zoom:50%;" /><ol><li>根据shell公式求折射角</li></ol><p>$$<br>1 \times \sin \theta = n\sin \gamma<br>$$</p><p>$$<br>\gamma = 18.7^{\circ}<br>$$</p><ol start="2"><li>根据菲涅尔公式求出反射光ps偏振比</li></ol><p>$$<br>r_p=\frac{\tan (\alpha - \gamma)}{\tan (\alpha + \gamma)}=0.176<br>$$</p><p>$$<br>r_s=-\frac{\sin (\alpha - \gamma)}{\sin (\alpha + \gamma)}=-0.261<br>$$</p><ol start="3"><li>得到反射光ps分量</li></ol><p>$$<br>E_p=r_pE_0\cos 45^\circ<br>$$</p><p>$$<br>E_s=r_sE_0\sin 45^\circ<br>$$</p><ol start="4"><li>求反射光的偏振和入射面的夹角$\theta’$</li></ol><p>$$<br>\theta’=\arctan|\frac{r_s}{r_p}|=\arctan 1.483=56^\circ<br>$$</p><ol start="5"><li>由于入射角小于布鲁斯特角</li></ol><p>$$<br>\alpha_B = \arctan n=57.3^\circ<br>$$</p><p>所以ps都有相位移，合成后仍在13象限</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：光源</title>
      <link href="/optics/%E5%85%89%E6%BA%90/"/>
      <url>/optics/%E5%85%89%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1>十一：光源</h1><h2 id="内容概述">内容概述</h2><ul><li>黑体辐射</li><li>光电效应</li><li>波粒二象性</li></ul><h2 id="黑体辐射">黑体辐射</h2><blockquote><p>室温下的铁是黑灰色，高温下是暗红色，极高温下是橙色</p></blockquote><p>任何温度大于绝对零度的物体，都会发出热辐射（Thermal radiation），这是由带电粒子随机运动产生的</p><p>处于平衡状态的物体，能量吸收率等于释放率，高吸收伴随着高释放</p><h3 id="基尔霍夫辐射定律">基尔霍夫辐射定律</h3><p>将一个物体置于一个等温真空室中，物体会吸收真空室中的热辐射，达到相同的温度（无论物体和环境的材质）</p><p>处于热平衡的物体满足<br>$$<br>R/\alpha=I<br>$$</p><ul><li>$R$，Radiation，物体的辐射率</li><li>$I$：Irradiance，真空室的辐照度</li><li>$\alpha$：吸收率</li></ul><p>基尔霍夫辐射定律：在热平衡状态下，光谱辐照度和光谱吸收系数之间的比值仅与辐射波长和温度有关，与辐射物体本身的性质无关。<br>$$<br>f(\lambda, T)=\frac{r(\lambda, T)}{\alpha(\lambda, T)}<br>$$<br>联系两个方程可得：好的吸收器是好的发光器（A good absorber is a good emitter）</p><h3 id="黑体">黑体</h3><p>黑体：在任何温度和波长下，吸收率$\alpha$都为1的材质<br>$$<br>\alpha \equiv 1<br>$$<br>黑体辐射实验</p><img src="/images/黑体辐射.png" class="lazyload" data-srcset="/images/黑体辐射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="黑体辐射" style="zoom: 33%;" /><img src="/images/黑体辐射曲线.png" class="lazyload" data-srcset="/images/黑体辐射曲线.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="黑体辐射曲线" style="zoom:50%;" /><h2 id="光电效应">光电效应</h2><h3 id="光量子假说">光量子假说</h3><p>爱因斯坦提出光量子假说，成功解释了光电效应的实验现象</p><img src="/images/光电效应.png" class="lazyload" data-srcset="/images/光电效应.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="光电效应" style="zoom:50%;" /><h3 id="康普顿散射">康普顿散射</h3><blockquote><p>1923年，康普顿发现，当x射线穿过石墨和金属等材料时，除了波长不变的散射外，还存在散射光子，随着散射角的增大，其波长也会变大。</p></blockquote><img src="/images/康普孙散射.png" class="lazyload" data-srcset="/images/康普孙散射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="康普孙散射" style="zoom:50%;" /><h2 id="波粒二象性">波粒二象性</h2><h2 id="激光">激光</h2><p>原子能级跃迁，从高能态到低能态，会发射激光</p><p>激光（Laser，<strong>L</strong>ight <strong>A</strong>mplification by <strong>S</strong>timulated <strong>E</strong>mission of <strong>R</strong>adiation）</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：各项异性</title>
      <link href="/optics/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7/"/>
      <url>/optics/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1>十：各向异性</h1><h2 id="内容概述">内容概述</h2><ul><li>光在各向异性的介质中的传播</li><li>偏振</li></ul><h2 id="双折射晶体">双折射晶体</h2><p>透过双折射晶体（比如方解石晶体），在某些角度只有一个像，在某些角度会有两个像</p><h3 id="双折射">双折射</h3><p>现象：一束光经过晶体后被分为了两束光</p><p>我们称之为o光和e光</p><ul><li>o光：按折射定律传播的光</li><li>e光：不按折射定律传播的光</li></ul><p>光轴：光束沿着光轴传播时，o光和e光不分开（这个方向两个折射率是相同的）</p><img src="/images/方解石.png" class="lazyload" data-srcset="/images/方解石.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="方解石" style="zoom:50%;" /><ul><li><p>主截面：界面法线和光轴构成的平面</p></li><li><p>主平面：晶体内光线和光轴构成的平面</p></li></ul><p>o光和e光都是线偏振光，o光的振动方向与主平面垂直，e光的振动方向与主平面平行</p><ul><li>单轴晶体：只有一个光轴的晶体，比如方解石、石英</li><li>双轴晶体：有两个光轴方向的晶体，比如云母、蓝宝石、硫磺</li></ul><p>o光和e光的光速不同，波面形状也不同</p><ul><li>o光沿各个方向的传播速度相同，于是波面是一个球</li><li>e光沿着不同方向传播速度不同，我们特别的选取垂直于光轴的面作为e光的波面，这个波面是一个椭圆<ul><li>这两个椭圆是相切的，但大小不确定</li><li>若o光比e光大，那么是正晶体</li><li>若o光比e光小，那么是负晶体</li></ul></li></ul><img src="/images/正负晶体.png" class="lazyload" data-srcset="/images/正负晶体.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="正负晶体" style="zoom:50%;" /><h2 id="惠更斯作图法">惠更斯作图法</h2><img src="/images/惠更斯绘图.png" class="lazyload" data-srcset="/images/惠更斯绘图.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="惠更斯绘图" style="zoom:50%;" /><ul><li>偏振态：我们在光线上各距离绘制短线和圆点，用来表示偏振<ul><li>短线表示偏振沿着纸面</li><li>点表示偏振垂直纸面</li><li>自然光横线和点的数量应该一样多</li></ul></li></ul><h3 id="绘制折射光">绘制折射光</h3><ol><li>过A点做边缘光线的垂线AB，垂足为B</li><li>我们能求出光线的传播时间$t=\overline{BB’}/c $</li><li>以A为圆心，做一个半径为$\mathrm{v}_o t$的圆，这是o光波面</li><li>以A为中心，做一个半轴为$\mathrm{v}_o t 和 \mathrm{v}_e t$的椭圆，椭圆要和圆在光轴处相切</li><li>从B’出发做圆和椭圆的切线，切点为$A’_o,A’_e$</li><li>o光折射光为$AA’_o$</li><li>e光折射光为$AA’_e$</li></ol><h2 id="光的偏振">光的偏振</h2><p>由于晶体可以分离o光和e光，因此可以做成偏振器</p><h3 id="光的偏振状态">光的偏振状态</h3><blockquote><p>回忆一下</p></blockquote><p>光有五种偏振状态</p><ul><li>自然光</li><li>部分偏振光</li><li>线偏振光</li><li>圆偏振光</li><li>椭圆偏振光</li></ul><p>光偏振状态的检验：将光通过检偏器，旋转检偏器，通过光强的变化判断</p><ul><li>无变化：自然光、圆偏振光</li><li>有变化但没有消光：部分偏振光、椭圆偏振光</li><li>有变化且有消光，线偏振光</li></ul><p>仅通过检偏，只能简单分出三类光，无法更近一步区分偏振态，而<strong>使用晶体可以明确知道偏振态</strong></p><p><strong>马吕斯定律</strong>：线偏振光经过检偏器，光强满足<br>$$<br>I=I_0\cos^2\varphi<br>$$<br><strong>布鲁斯特定律</strong>：光线以大于布鲁斯特角入射，反射光是线偏振光<br>$$<br>\tan i_B=\frac{n_2}{n_1}<br>$$</p><h3 id="光在晶体中的传播">光在晶体中的传播</h3><h4 id="洛匈棱镜">洛匈棱镜</h4><p>由两块冰洲石构成</p><ul><li>左侧光轴平行纸平面和入射光，光线进入时不会发生双折射</li><li>右侧光轴垂直纸平面，光线进入后o光变e光，e光变o光</li></ul><img src="/images/洛匈棱镜.png" class="lazyload" data-srcset="/images/洛匈棱镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="洛匈棱镜" style="zoom:50%;" /><h4 id="沃拉斯顿棱镜">沃拉斯顿棱镜</h4><img src="/images/沃拉斯顿棱镜.png" class="lazyload" data-srcset="/images/沃拉斯顿棱镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="沃拉斯顿棱镜" style="zoom:50%;" /><ul><li>光线进入左侧，o光和e光方向不变，速度改变，e光会比o光快</li></ul><h4 id="尼科尔棱镜">尼科尔棱镜</h4><p><img src="/images/niker.gif" class="lazyload" data-srcset="/images/niker.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="niker"></p><h3 id="偏振光的获取和检验">偏振光的获取和检验</h3><p>核心思想为<strong>垂直振动和合成</strong>，任何一个偏振态，都是两个垂直振动的合成</p><p>所有偏振态都是由两垂直的线偏振光合成，两者的相位差$\delta$将决定合成的是何种偏振光</p><p>$\lambda/4$波晶片能带来$\pi/2$的相位差</p><img src="/images/偏振光的相位差.png" class="lazyload" data-srcset="/images/偏振光的相位差.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="偏振光的相位差" style="zoom:50%;" /><p>光通过晶体时，o光和e光可能方向不变，相位差改变，通过调整两者间相位差，就能得到圆偏振、椭圆偏振</p><h4 id="求出射光偏振态">求出射光偏振态</h4><p>出射光相位差=入射光相位差+波晶片相位差</p><img src="/images/出射偏振态.png" class="lazyload" data-srcset="/images/出射偏振态.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="出射偏振态" style="zoom:50%;" /><h3 id="偏振光检验">偏振光检验</h3><ol><li>使用偏振片将五种偏振光变为三组</li><li>对于自然光和圆偏振光那一组<ol><li>光线继续通过$\lambda/4$波晶片，如果变为线偏振光，则为圆偏振光</li></ol></li><li>对于部分偏振光和椭圆偏振光那一组<ol><li>将偏振片旋转至光强最强处</li><li>将$\lambda/4$波晶片光轴旋转至与偏振片透振方向平行</li><li>去除偏振片，光线继续通过$\lambda/4$波晶片</li><li>此时o光和e光与椭圆主轴一致，若变为线偏振光，则为椭圆偏振光</li></ol></li></ol><img src="/images/偏振光检验.png" class="lazyload" data-srcset="/images/偏振光检验.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="偏振光检验" style="zoom: 67%;" /><h3 id="左右旋检验">左右旋检验</h3><p>一个圆偏振片，通过$\lambda/4$波晶片，再通过透振方向为斜对角线的偏振片</p><ol><li>旋转偏振片，若发现有消光位置，则停止旋转（圆偏振通过波晶片变线偏振，透过偏振片会有消光），此时透振方向和线偏振光偏振方向垂直</li><li>若透振方向为一三象限，入射光为右旋</li><li>若透振方向为二四象限，入射光为左旋</li></ol><img src="/images/区分左右旋.png" class="lazyload" data-srcset="/images/区分左右旋.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="区分左右旋" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：傅立叶变化光学</title>
      <link href="/optics/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E5%8C%96%E5%85%89%E5%AD%A6/"/>
      <url>/optics/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E5%8C%96%E5%85%89%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1>八：傅立叶变换光学</h1><h2 id="内容概述">内容概述</h2><ul><li>衍射系统的屏函数</li><li>夫朗禾费衍射的傅立叶频谱分析</li><li>阿贝成像原理和相衬显微镜</li></ul><h2 id="变换光学">变换光学</h2><p>前面几章，我们使用波的叠加来分析描述干涉衍射，而傅立叶变化光学中，我们使用光场变换的观点来看待干涉衍射</p><p>傅立叶光学的本质就是将复杂的光学现象切分为多个不同频率、不同取向的正弦光栅之和</p><blockquote><p>傅立叶展开的本质是将复杂的函数切分为多个三角函数之和</p></blockquote><h3 id="屏函数">屏函数</h3><p>衍射屏左侧的空间叫照明空间，其中的场被称为入射场$\tilde{U}_1$</p><p>衍射屏右侧的空间叫衍射空间，其中的场被称为衍射场$\tilde{U}_2$</p><p>接收屏处的场叫接收场$\tilde{U}$</p><img src="/images/傅立叶衍射.png" class="lazyload" data-srcset="/images/傅立叶衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="傅立叶衍射" style="zoom:50%;" /><p>使用<strong>屏函数</strong>$\tilde{t}$来描述衍射屏对入射光的波前的改变</p><p>$$<br>\tilde{t}(x,y)=\frac{\tilde{U}_1}{\tilde{U}_2}=t(x,y)\exp [i\varphi_t(x,y)]<br>$$</p><ul><li>$t(x,y)$是屏函数的模，若模为固定值，则该衍射屏为相位型。比如透镜、棱镜</li><li>$\varphi_t$是屏函数的相位，若相位为固定值，则该衍射屏为振幅型。比如单孔、圆孔</li></ul><h3 id="相因子判断法">相因子判断法</h3><h2 id="正弦光栅衍射">正弦光栅衍射</h2><p>正弦光栅从数学上，就是傅立叶级数的基函数</p><h3 id="光栅">光栅</h3><p>光栅：具有周期性的空间结构或光学性能的衍射屏统称为光栅</p><p>光栅的种类：</p><ul><li>透射光栅、反射光栅</li><li>平面光栅、凹面光栅</li><li>黑白光栅、正弦光栅</li><li>一维、二维、三维光栅</li></ul><h2 id="阿贝成像原理">阿贝成像原理</h2><p>衍射屏的屏函数可以展开为傅立叶级数</p><img src="/images/傅立叶屏函数.png" class="lazyload" data-srcset="/images/傅立叶屏函数.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="傅立叶屏函数" style="zoom:50%;" /><h2 id="相衬显微镜">相衬显微镜</h2><p>显微镜看的切片都很薄，对光的吸收很小，如果不染色，很难引起透射光振幅的变化，因此显微镜是相位型的</p><p>如果我们想要显微镜看东西更清楚，可以通过增加相位移的方式增大图像的反衬度（衬比度）</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：衍射</title>
      <link href="/optics/%E8%A1%8D%E5%B0%84/"/>
      <url>/optics/%E8%A1%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1>七：衍射</h1><h2 id="内容概述">内容概述</h2><ul><li>衍射（Diffraction），光在传播途中偏移直线传播，强度重新分布的过程</li><li>惠更斯-菲涅尔原理</li><li>定量分析衍射</li><li>统一衍射和直线传播</li></ul><h2 id="衍射">衍射</h2><p>衍射是光在传播途中偏移直线传播，强度重新分布的过程</p><blockquote><p>物体遮挡光线，就会产生阴影</p><p>在几何光学中，平行光只会被完全遮挡/完全不遮挡，因此阴影应该是清晰的</p><p>但现实中的平行光阴影是软阴影，其实就是发生了衍射</p><p>点、面光源的软阴影是由于光源由尺寸</p></blockquote><img src="/images/光的衍射.png" class="lazyload" data-srcset="/images/光的衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="光的衍射" style="zoom:50%;" /><p>一组平行的波阵面通过小孔，会变成圆形</p><img src="/images/衍射.png" class="lazyload" data-srcset="/images/衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="衍射" style="zoom:50%;" /><p>波长越长，越容易观测到衍射</p><ul><li>小孔尺寸在波长的1000倍左右时衍射现象不明显</li><li>小孔尺寸在波长的10倍左右时衍射十分明显</li><li>小孔尺寸和波场相近时会发生散射</li></ul><h3 id="衍射的分类">衍射的分类</h3><ul><li>菲尼尔衍射（近场衍射）：光源和接收屏距离有限</li><li>夫朗禾费衍射（远场衍射）：光源和接收屏距离无限（也就是入射光是平行光）</li></ul><p>夫朗禾费衍射需要用透镜将平行光汇聚</p><img src="/images/三种衍射.png" class="lazyload" data-srcset="/images/三种衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="三种衍射" style="zoom:50%;" /><h3 id="光栅衍射">光栅衍射</h3><p>多光束干涉和单缝衍射的混合</p><p>多光束干涉决定明条纹位置<br>$$<br>d\sin \theta=k\lambda<br>$$<br>缺级<br>$$<br>k=\frac{d}{a}k’<br>$$</p><h3 id="干涉与衍射的关系">干涉与衍射的关系</h3><p>相同：</p><ul><li>干涉和衍射都是相干叠加</li></ul><p>不同：</p><ul><li>干涉是离散点光源叠加求和，衍射是连续次波源叠加积分</li><li>干涉满足几何光学规律，衍射不满足几何光学规律</li></ul><h2 id="惠更斯-菲涅尔原理">惠更斯-菲涅尔原理</h2><h3 id="惠更斯">惠更斯</h3><p>惠更斯：波阵面上每一个点，本质上是一个球面次级小波的发射源，下一个波阵面实际上是这些球面的包络线（envelope）</p><img src="/images/惠更斯原理.png" class="lazyload" data-srcset="/images/惠更斯原理.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="惠更斯原理" style="zoom: 33%;" /><p>理论的作用</p><ul><li>根据这个理论，给定一个波阵面，我们可以画出下一个波阵面</li><li>解释了光在各向同性介质中的传播原理</li><li>解释了反射和折射公式</li></ul><p>局限性</p><ul><li>无法区分光沿直线传播和发生衍射的条件</li><li>无法定量分析衍射强度</li><li>根据该理论，应该会有反转波</li></ul><h3 id="菲涅尔">菲涅尔</h3><p>菲涅尔修正了惠更斯的理论</p><ul><li>波阵面上每一个（无阻塞）点都是球面波的发射源，频率与主波相同</li><li>不在波阵面上的点，都是由小波相干叠加得到的</li></ul><p><strong>衍射是无数干涉的叠加</strong></p><h4 id="倾斜因子">倾斜因子</h4><p>惠更斯的理论会应该会存在向后的波，菲涅尔引入了倾斜因子（Tilt factor）<br>$$<br>F(\theta_0, \theta)=\frac{1}{2}(\cos\theta_0+\cos \theta)<br>$$<br><img src="/images/倾斜因子.png" class="lazyload" data-srcset="/images/倾斜因子.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="倾斜因子" style="zoom:50%;" /></p><p>倾斜因子的引入使得向后的波强度为0，自然就不会出现反转波</p><p>不过倾斜因子的引入是纯经验，这也是菲涅尔理论的局限性</p><h3 id="基尔霍夫积分定律">基尔霍夫积分定律</h3><p>基尔霍夫在倾斜因子的基础上添加了一个常数K，提供了一个$-\pi/2$的相位差<br>$$<br>K=\frac{e^{-i\pi/2}}{\lambda}<br>$$<br>于是衍射积分公式转化为：</p><img src="/images/基尔霍夫求解波动方程.png" class="lazyload" data-srcset="/images/基尔霍夫求解波动方程.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="基尔霍夫求解波动方程" style="zoom:50%;" /><h3 id="巴俾涅原理">巴俾涅原理</h3><p>两个互补的衍射屏叠加，效果等同于自由传播</p><h2 id="半波带法">半波带法</h2><p>下图为单缝夫朗禾费衍射，计算方法为半波带法</p><img src="/images/单缝夫朗禾费.png" class="lazyload" data-srcset="/images/单缝夫朗禾费.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="单缝夫朗禾费" style="zoom:50%;" /><img src="/images/夫朗禾费衍射.png" class="lazyload" data-srcset="/images/夫朗禾费衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="夫朗禾费衍射" style="zoom: 33%;" /><p>波带数<br>$$<br>\frac{a \sin \theta}{\lambda/2}<br>$$</p><ul><li>a是衍射屏孔径</li></ul><p>暗纹位置（暗纹准确，明纹不准确）<br>$$<br>a \sin \theta = \pm k \lambda<br>$$<br>中央明纹宽度<br>$$<br>\Delta x_0=2f\frac{\lambda}{a}<br>$$</p><h2 id="衍射图样">衍射图样</h2><h3 id="单缝衍射">单缝衍射</h3><h3 id="圆孔衍射">圆孔衍射</h3><p>圆孔衍射：亮暗相间的同心圆环，中心可能是暗也可能是亮的</p><p>中心强度与孔径明暗，与屏幕距离不敏感</p><img src="/images/圆孔衍射.jpeg" class="lazyload" data-srcset="/images/圆孔衍射.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="圆孔衍射" style="zoom:60%;" /><p>Airy斑：中心圆斑</p><p>瑞丽判据：如果一个物点的Airy斑的边缘在另一个Airy斑中心上，那么这两个物点恰好可分辨</p><h3 id="圆屏衍射">圆屏衍射</h3><p>圆屏衍射：亮暗相间的同心圆环，但中心总是一个亮点</p><p>亮点与物体大小、屏幕距离都无关，这个亮点我们称为柏松亮斑</p><img src="/images/圆屏衍射.png" class="lazyload" data-srcset="/images/圆屏衍射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="圆屏衍射" style="zoom:50%;" /><blockquote><p>一个圆球的影子，中心居然会有一个亮点，衍射，很神奇吧</p></blockquote><h3 id="光栅衍射-2">光栅衍射</h3><h2 id="菲涅尔波带片">菲涅尔波带片</h2><p>根据菲尼尔衍射原理，将偶数个半波带遮挡住，就能得到菲涅尔波带片（就是对一个平整的圆形玻璃，将其表面部分图黑一个个同心圆环）</p><img src="/images/菲涅尔波带片.png" class="lazyload" data-srcset="/images/菲涅尔波带片.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="菲涅尔波带片" style="zoom:50%;" /><p>若一个波带片有20个半波带，遮挡偶数个半波带，轴上中心点的光强为<br>$$<br>A’=A_1+A_2+A_3+A_4+A_{19}\approx 10A_1=20A_0<br>$$</p><p>$$<br>I’=A’^2=400A_0^2=400I<br>$$<br>我们发现中心点的光强变强，因此菲涅尔波带片相当于透镜，可以汇聚光强</p><h3 id="涂黑半径">涂黑半径</h3><p>$$<br>\rho_K=\sqrt{k}\rho_1<br>$$</p><ul><li>k取1,2,3…</li></ul><h3 id="成像公式">成像公式</h3><p>$$<br>\frac{1}{R}+\frac{1}{b}=\frac{1}{f}<br>$$</p><ul><li>R：点光源到波带片的距离</li><li>b：波带片到汇聚点到距离</li></ul><h3 id="波带片与透镜">波带片与透镜</h3><ul><li>相同<ul><li>都能汇聚能量</li></ul></li><li>不同<ul><li>透镜只有一个汇聚点，波带片有多个实汇聚点和虚汇聚点</li><li>透镜满足等光程性，波带片相邻波带片间有一个波长的光程差</li><li>波带片面积大、轻便、可折叠</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：干涉</title>
      <link href="/optics/%E5%B9%B2%E6%B6%89/"/>
      <url>/optics/%E5%B9%B2%E6%B6%89/</url>
      
        <content type="html"><![CDATA[<h1>六：干涉</h1><h2 id="内容概述">内容概述</h2><ul><li>干涉（Interference），光的叠加不满足线性叠加，证明了光的波性</li><li>干涉条件</li><li>干涉方法与装置</li><li>干涉仪</li></ul><h2 id="干涉">干涉</h2><p>干涉让光学从线性光学变成非线性光学</p><h3 id="线性光学">线性光学</h3><p>在几何光学中，我们认为光是独立传播的</p><p>光是一种横波，光在介质中传播会引起介质粒子振动，若独立传播成立，那么两束光的交叉区域，粒子的振动是两个振动的叠加，这就是<strong>叠加原理</strong></p><p>光的叠加实际上是介质的性质（因为描述的是介质粒子振动的叠加）</p><ul><li>线性介质：在该介质中，波满足叠加原理</li><li>非线性介质：在该介质中，波不满足叠加原理</li></ul><p>违反叠加原理的介质是非线性介质，现象是非线性现象，学科是非线性光学</p><p>此外，叠加原理只有在低强度光下才成立，因此激光发明后，非线性光学才蓬勃发展</p><h3 id="复振幅叠加法">复振幅叠加法</h3><p>求解相干光强有三种方法，实际分析时通常使用复振幅法</p><ul><li>三角函数法：波可以由三角函数表示，对三角函数做恒等变化，即可求相干光强</li><li>矢量图解法</li><li>复振幅法</li></ul><p>首先将三角函数表示为复振幅<br>$$<br>\tilde{\mathbf{E}_i}=\mathbf{A}_i e^{i\varphi <em>i}<br>$$<br>复振幅的叠加<br>$$<br>\tilde{\mathbf{E}}=\sum</em>{i=1}^n\tilde{\mathbf{E}_i}<br>$$<br>合光强<br>$$<br>I = \tilde{\mathbf{E}}\cdot \tilde{\mathbf{E}}^*<br>$$</p><h3 id="相干叠加">相干叠加</h3><p>现在有两个相同频率（frequency）相同偏振（polarization）的光波，下面是他们电场强度随时间的变化（用复数表示三角函数）<br>$$<br>\mathbf{E_1}=\mathbf{A_1} e^{i(kr_1-\omega t+\varphi _{01})}<br>$$</p><p>$$<br>\mathbf{E_2}=\mathbf{A_2} e^{i(kr_2-\omega t+\varphi _{02})}<br>$$</p><p>他们相交于点P，根据叠加原理，P点点电场强度为<br>$$<br>\mathbf{E}=\mathbf{E_1}+\mathbf{E_2}=[\mathbf{A_1}e^{i(kr_1+\varphi_{01})} + \mathbf{A_2}e^{i(kr_2+\varphi_{02})}]e^{-i\omega t}<br>$$<br>显然，振幅为<br>$$<br>\tilde{\mathbf{E}}=\mathbf{A_1}e^{i(kr_1+\varphi_{01})} + \mathbf{A_2}e^{i(kr_2+\varphi_{02})}<br>$$<br>由于光过于高频，我们没法实时进行光电场强度的检测，于是我们使用光强（intensity，$I$）来进行推导</p><p>$$<br>I \propto \tilde{\mathbf{E}}\cdot \tilde{\mathbf{E}}^*=\mathbf{A_1}^2+\mathbf{A_2}^2+2\mathbf{A_1A_2}\cos(kr_1-kr_2+\varphi_{01}-\varphi_{02})<br>$$</p><p>$$<br>I = I_1+ I_2 + 2\sqrt{I_1I_2}\cos \delta<br>$$</p><p>$$<br>\delta=kr_1-kr_2+\varphi_{01}-\varphi_{02}<br>$$</p><p>我们发现，两个光波进行叠加，光强不只是简单叠加，还有一个尾巴，这个尾巴就是<strong>干涉</strong></p><p>干涉：因波的叠加引起强度重新分布的现象</p><p>并且我们发现：</p><ul><li><p>干涉强度与时间无关，与空间位置有关，且保持不变</p></li><li><p>当$\delta=2m\pi$，干涉强度最大，我们称之为构造干涉（constructive interference）</p></li></ul><p>$$<br>I=(\mathbf{A_1}+\mathbf{A_2})^2<br>$$</p><ul><li>当$\delta=(2m+1)\pi$，干涉强度最小，我们称之为相消干涉（destructive interference）</li></ul><p>$$<br>I=(\mathbf{A_1}-\mathbf{A_2})^2<br>$$</p><h3 id="非相干叠加">非相干叠加</h3><p>一般而言，两个光频率和偏振不一样，经过推导<br>$$<br>I_{12}=2\mathbf{A_1}\cdot \mathbf{A_2} \cos [(\omega_2 - \omega_1)t + \theta_1 - \theta_2]<br>$$<br>我们到处干涉强度为0的条件</p><ul><li>两个光频率不同，$\cos[…]$的均值为0</li><li>两个光光矢量垂直，$\mathbf{A_1}\cdot \mathbf{A_2}=0$</li><li>两个光夹角（相位差）迅速且无序变化，$\cos[…]$的均值为0</li></ul><h3 id="干涉条件">干涉条件</h3><p>因此我们总结出发生干涉的条件</p><ul><li>频率相同</li><li>相同的平行分量</li><li>固定的相位差</li></ul><p>如果不满足干涉条件，那么平均下来<br>$$<br>I=I_1+I_2<br>$$</p><h2 id="杨氏干涉">杨氏干涉</h2><p>普通光源：普通光源的发光单位为原子、分子，不同原子间的发光是独立的，他们的频率、偏振、相位都是不同的，因此他们的光是不会发生干涉的</p><p>有干涉条件我们可以得出两种获得干涉光的方法：</p><ul><li>分波前法（杨氏干涉）</li><li>分振幅法（薄膜等厚干涉）</li></ul><p>使用杨氏干涉实验、菲涅尔双棱镜、劳埃德镜可以将普通光源变成干涉光</p><p><img src="/images/%E6%99%AE%E9%80%9A%E5%85%89%E6%BA%90%E7%9B%B8%E5%B9%B2%E5%85%89.png" class="lazyload" data-srcset="/images/%E6%99%AE%E9%80%9A%E5%85%89%E6%BA%90%E7%9B%B8%E5%B9%B2%E5%85%89.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="普通光源相干光"></p><p>杨氏干涉，两束光的出相相同，因此干涉光的相位差只取决于光程差<br>$$<br>\Delta \varphi= \frac{2\pi  }{\lambda}\Delta OPL=k\delta<br>$$</p><ul><li>k：波数，$k=\frac{2\pi}{\lambda}$</li><li>$\delta$：光程差</li></ul><h3 id="衬比度">衬比度</h3><blockquote><p>衬比度，也可以叫做可见度</p></blockquote><p>干涉条纹的衬比度（constrast）定义为<br>$$<br>\gamma = \frac{I_\max-I_\min}{I_\max + I_\min}<br>$$<br>用于描述条纹的反差程度，当可见性为1时最清晰，当为0时完全不可分辨</p><h3 id="杨氏双缝干涉实验">杨氏双缝干涉实验</h3><p>杨氏实验是通过两个点波光源进行干涉实验的典型</p><p>如果光是一种波，那么光在传播过程中应该会有波前（传播最靠前的波阵面），提取一个波前，并将其分为两部分，就能得到两个相干光</p><p>现在有一个非常窄的单色光源，经过两个带缝平面，会生成两个相干光，进而发生衍射现象，在平面留下明暗条纹</p><p><img src="/images/%E6%9D%A8%E6%B0%8F%E5%8F%8C%E7%BC%9D%E5%B9%B2%E6%B6%89.png" class="lazyload" data-srcset="/images/%E6%9D%A8%E6%B0%8F%E5%8F%8C%E7%BC%9D%E5%B9%B2%E6%B6%89.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="杨氏双缝干涉"></p><p>$$<br>I=A^2=4I_1\cos^2\frac{\pi \Delta}{\lambda}<br>$$</p><ul><li>若$\Delta=m\lambda, I=I_{max}=4I_1$，呈现亮条纹</li><li>若$\Delta=(2m-1)\lambda/2, I=I_{min}=0$，呈现暗条纹</li></ul><p>杨氏干涉实验的衬比度为<br>$$<br>\gamma = \frac{2(A_1/A_2)}{1+(A_1/A_2)^2}<br>$$<br><img src="/images/杨氏干涉.png" class="lazyload" data-srcset="/images/杨氏干涉.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="杨氏干涉" style="zoom: 50%;" /></p><p>当间距不大时，角度比较小，缝间距是相同的，间距为<br>$$<br>\Delta x=\frac{D}{d}\lambda<br>$$</p><h3 id="判断一点的暗亮">判断一点的暗亮</h3><blockquote><p>看上图</p></blockquote><p>在杨氏干涉实验中，给定$d,D,x$，判断点在明条纹中还是暗条纹中</p><p>核心思想就是：判断光程差是半波长的偶数倍还是奇数倍，偶数为明条纹，基数为暗条纹</p><ol><li>以P点为圆心，$S_1P$为半径画一个圆，圆和$S_2P$相交于点$S’$，那么$S_2S’$就是光程差</li><li>不过$S_2S’$很难求，于是我们进行近似，我们从$S_1$出发做$S_2P$的垂线，垂足可以近似为点$S’$</li><li>我们知道斜边长度为d，只要知道$\angle S_2S_1S’$，就能求出光程差</li><li>不过$\angle S_2S_1S’$还是太难求了，我们用角$\theta$来近似</li><li>$\sin \theta \approx \tan \theta = x/D$</li><li>有了光程差，就能知道这是几个波长，是明是暗</li></ol><h3 id="可见条纹的最大级数">可见条纹的最大级数</h3><p>$$<br>j_\max= d/\lambda<br>$$</p><h3 id="求P点光强">求P点光强</h3><p>$$<br>I=A_1^2+A_2^2+2A_1A_2\cos \Delta\varphi<br>$$</p><p>$$<br>\Delta \varphi = k \cdot \delta<br>$$</p><h3 id="干涉条纹的移动">干涉条纹的移动</h3><p>我们不仅观测到明暗条纹，还观测到条纹的移动和变化</p><ul><li><p>移动光源，对于屏幕上一点，求多少个条纹经过该点</p><ul><li>对于屏幕上点P，经过点P的条纹数取决于两条相干光线的光程差（OPL）</li><li>当光程差增减一个$\lambda$时，就会经过一条条纹</li></ul></li><li><p>移动光源，对于特定的一个条纹，求其移动了多长距离</p><ul><li>杨氏双缝中</li></ul></li></ul><p>$$<br>\delta x = -\frac{D}{R}\delta s<br>$$</p><img src="/images/条纹移动.png" class="lazyload" data-srcset="/images/条纹移动.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="条纹移动" style="zoom:50%;" /><h3 id="其他干涉仪器">其他干涉仪器</h3><p>本质都是杨氏双缝干涉，条纹间距都满足<br>$$<br>\Delta x=\frac{D}{d}\lambda<br>$$</p><p>这些干涉仪器相比起杨氏干涉，不使用狭缝过滤光，因此光线强度更高</p><h4 id="菲涅尔双平面镜">菲涅尔双平面镜</h4><img src="/images/菲尼尔双平面镜.png" class="lazyload" data-srcset="/images/菲尼尔双平面镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="菲尼尔双平面镜" style="zoom:50%;" /><h4 id="劳埃德镜">劳埃德镜</h4><img src="/images/劳埃德镜.png" class="lazyload" data-srcset="/images/劳埃德镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="劳埃德镜" style="zoom:67%;" /><h4 id="菲涅尔双棱镜">菲涅尔双棱镜</h4><img src="/images/菲涅尔双棱镜.png" class="lazyload" data-srcset="/images/菲涅尔双棱镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="菲涅尔双棱镜" style="zoom:50%;" /><h4 id="彩色光杨氏双缝">彩色光杨氏双缝</h4><p>如果传入的是白光，条纹将为彩色</p><img src="/images/杨氏干涉彩色条纹.png" class="lazyload" data-srcset="/images/杨氏干涉彩色条纹.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="杨氏干涉彩色条纹" style="zoom:50%;" /><h2 id="时空相干性">时空相干性</h2><p>现实中的普通光源的发光单元为原子、分子，靠自发辐射发光（激光光源靠受激辐射），这是一个随机过程，产生的光是随机、无规律、不相干的。看起来我们无法用普通光源做干涉实验，但实际上杨氏双缝是可以使用普通光源的，因为杨氏双缝中两个光都是由同一束光分割而成的</p><p>尽管普通光源的相位随机，但是杨氏双缝两束光的相位差与原光源相位无关，仅与空间位置有关</p><p>不过，光源的尺寸和光谱尺寸仍然会对杨氏干涉产生影响</p><p>在杨氏干涉中，我们使用了很窄的单色光源，然而现实中光源总是有尺寸，其颜色也不是单色而是光谱中一小段</p><p>空间相干性：光源尺寸对干涉强度的影响</p><p>时间相干性：光谱尺寸对干涉强度的影响（也就是说光不是真的纯色）</p><h3 id="空间相干性">空间相干性</h3><p>任何光源都有一定的宽度，我们将其视为多个不相干的点光源排布，屏幕上的总强度为各个光源的干涉条纹的线性叠加</p><p>我们发现沿着x轴方向的长度会让条纹模糊</p><p>沿着y轴方向的长度会让亮纹和亮纹重叠，于是条纹更清晰</p><p>我们在做杨氏双缝时常常使用平行于y轴方向的光</p><img src="/images/光源宽度.png" class="lazyload" data-srcset="/images/光源宽度.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="光源宽度" style="zoom:50%;" /><img src="/images/空间相干性.JPG" class="lazyload" data-srcset="/images/空间相干性.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="空间相干性" style="zoom:50%;" /><h3 id="时间相干性">时间相干性</h3><p>现实中光不是纯色光，光的波长不同，干涉条纹长度不同，于是不同波长的干涉条纹就会发生重叠，进而降低条纹的衬比度</p><h2 id="薄膜干涉">薄膜干涉</h2><p>薄膜（film）一种透明介质，将空间划分三个折射率不同的区域，其中中间的区域不能过厚</p><p>薄膜干涉（Thin film interference）：光在薄膜表面发生反射和折射，下表面的反射光和上表面的折射光发生干涉</p><blockquote><p>比如彩色太阳眼镜和阳光下的七彩肥皂泡</p></blockquote><p>光线在射向薄膜后会发生反射和透射，透射光可能会再次反射透射，返回薄膜表面，进而和入射光相遇，发生干涉</p><ul><li>等厚干涉：发散的入射光（点光）和透射光干涉，干涉发生在薄膜表面</li><li>等倾干涉：平行的透射光干涉，干涉发生在无穷远，需要用透镜汇聚，形状为同心条纹</li></ul><p>特别注意！等厚和等倾是指的条纹间距，而不是薄膜形状，等厚的条纹需要上下不平行的薄膜</p><h3 id="等厚度干涉">等厚度干涉</h3><img src="/images/薄膜干涉.png" class="lazyload" data-srcset="/images/薄膜干涉.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="薄膜干涉" style="zoom:50%;" /><p>等厚干涉发生在薄膜表面</p><p>厚度不均匀的薄膜发生的干涉，入射光为<strong>平行光</strong>，决定条纹间距的是因厚度不均带来的光程差<br>$$<br>\delta = 2nh\sqrt{n^2-n_0^2\sin^2 i_1} +\lambda/2<br>$$</p><ul><li>$i$是折射角</li></ul><p>常见的等厚干涉有</p><ul><li>劈尖：光线垂直入射<ul><li>角度越大，条纹数量越多</li><li>折射率越大，条纹间距越大</li></ul></li></ul><p><img src="/images/%E7%A9%BA%E6%B0%94%E5%8A%88%E5%B0%96.png" class="lazyload" data-srcset="/images/%E7%A9%BA%E6%B0%94%E5%8A%88%E5%B0%96.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="空气劈尖"></p><ul><li>牛顿环</li></ul><p><img src="/images/%E7%89%9B%E9%A1%BF%E7%8E%AF.png" class="lazyload" data-srcset="/images/%E7%89%9B%E9%A1%BF%E7%8E%AF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="牛顿环"></p><h3 id="增透膜与高反膜">增透膜与高反膜</h3><blockquote><p>汽油膜，肥皂泡，昆虫翅膀</p></blockquote><p>厚度均匀的薄膜发生的干涉，入射光为<strong>平行光</strong>，各个方向的干涉增强被分离出去</p><h4 id="增透膜">增透膜</h4><p>n2的反射光被干涉相消，根据能量守恒，透射光会更多</p><p>折射率<br>$$<br>n=\sqrt{n_1n_2}<br>$$<br>$$<br>n_1 &lt; n &lt; n_2<br>$$</p><p>厚度<br>$$<br>h=\frac{\lambda_0}{4n}<br>$$</p><img src="/images/增透膜.png" class="lazyload" data-srcset="/images/增透膜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="增透膜" style="zoom:50%;" /><h4 id="增反膜">增反膜</h4><p>反射被干涉增强，透射光会减少</p><p>折射率<br>$$<br>n &gt; n_1 且 n &gt; n_2<br>$$<br>厚度<br>$$<br>h=\frac{\lambda_0}{4n}<br>$$</p><h3 id="等倾斜角干涉">等倾斜角干涉</h3><img src="/images/等倾干涉.png" class="lazyload" data-srcset="/images/等倾干涉.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="等倾干涉" style="zoom:50%;" /><p>等倾干涉发生在无穷远处</p><p>上下表面平行的薄膜发生的干涉，入射光为<strong>点光源</strong><br>$$<br>\delta = 2nh\cos i_2<br>$$</p><h4 id="半波损失">半波损失</h4><p>波从光疏射向光密，在反射过程中会产生$\pi$个相位跃变，我们称之为<strong>半波损失</strong></p><p>由于半波损失的存在，薄膜干涉明暗条纹的产生条件实际上与杨氏双缝相反<br>$$<br>\delta = 2nh\cos i_2 + \lambda/2<br>$$</p><h4 id="等倾图样">等倾图样</h4><p>内高外低，内疏外密</p><img src="/images/等倾图样.png" class="lazyload" data-srcset="/images/等倾图样.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="等倾图样" style="zoom: 67%;" /><h2 id="干涉仪">干涉仪</h2><h3 id="多光束干涉">多光束干涉</h3><img src="/images/多光束干涉.png" class="lazyload" data-srcset="/images/多光束干涉.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="多光束干涉" style="zoom:50%;" />$$\Delta L=2nh\cos i$$光在介质内不断反射折射，新的反射折射光强度成等比数列<h3 id="迈克耳孙干涉仪">迈克耳孙干涉仪</h3><p>使用分振幅法将两个相互垂直的平面镜等效为空气薄膜，空气薄膜可以等倾，也可以等厚</p><img src="/images/迈克耳孙.png" class="lazyload" data-srcset="/images/迈克耳孙.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="迈克耳孙" style="zoom:50%;" /><h3 id="法布里-珀罗干涉仪">法布里-珀罗干涉仪</h3><p>由两个梯形透镜组成，用于生成等倾干涉条纹</p><img src="/images/法布里-珀罗.png" class="lazyload" data-srcset="/images/法布里-珀罗.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="法布里-珀罗" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的智慧</title>
      <link href="/program/AskQuestion/"/>
      <url>/program/AskQuestion/</url>
      
        <content type="html"><![CDATA[<h1>提问的智慧</h1><p>提问的方式，可能会很大程度影响你是否能得到有用的回答</p><h3 id="树立好的形象">树立好的形象</h3><p>当你想问问题，一定要树立你的形象：我已经做了努力，我不是一个不劳而获且浪费别人时间的提问者</p><p>你可以做的努力有</p><ul><li>网上搜素</li><li>查看文档、手册、issuse</li><li>看看源码</li><li>自己先做试验</li></ul><h3 id="问题不要带有错误的预设">问题不要带有错误的预设</h3><p>草率的发问只会得到草率的回答，如果你的预设错了，下面的尝试和思考都是无用功</p><blockquote><p>很多民科认为自己推翻了相对论、微积分，很有可能是使用了一个错误的预设</p></blockquote><blockquote><p>not even wrong</p><p>Q：你是哪个省的</p><p>Right：四川省</p><p>Wrong：西藏省</p><p>Not even wrong：妈妈生的</p></blockquote><h3 id="不要明知故问">不要明知故问</h3><p>特别要批评哪些为了“耍存在感”而明知自问，列举了一大串知识试图诱导他人的思路，然后在最后向别人进行提问</p><h3 id="不要认为自己够格得到回答">不要认为自己够格得到回答</h3><p>如果你没有为这个问题付费，那你不要期待自己一定能得到好的回答，你需要通过靠提出有内涵的、有趣的、有思维激励作用的问题<strong>挣得</strong>回答</p><h3 id="选择正确的提问地点">选择正确的提问地点</h3><p>不要在主题不和的论坛贴出你的问题</p><blockquote><p>比如在NS吧问原神好不好玩，在A9问XGPU是否值得购买</p></blockquote><p>不要在进阶的论坛中问低级问题，反之亦然</p><blockquote><p>比如你认为火箭燃料应该用水洗煤，在太空应该用铅笔替代</p></blockquote><p>不要在不同的论坛反复问同一件事</p><blockquote><p>这让人感觉你在大喊大叫</p></blockquote><p>不要向陌生人发私人邮件</p><blockquote><p>你没有付费，别人就没有必要回答，更不要说私聊对方让他“加班”</p></blockquote><p>可以试一试在Stack Overflow问程序相关的问题</p><h3 id="向一个群体提问，而非个人">向一个群体提问，而非个人</h3><p>个人没有义务回答你的问题</p><p>向群体问一个好问题能对整个群体有益，你的提问可以被后来者看到</p><p>向群体问问题能减轻某个个人的压力</p><h3 id="描述问题">描述问题</h3><h4 id="使用有意义的标题">使用有意义的标题</h4><p>使用<code>目标-差异</code>做标题</p><blockquote><p><a href="http://X.org">X.org</a> 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形</p></blockquote><h4 id="言之有物">言之有物</h4><p>低声下气不如清晰地说明情况</p><p>不要使用</p><blockquote><p>大佬，求救</p><p>在线等，很急</p><p>我是一个菜鸡，呜呜呜</p><p>有人能帮帮我吗</p></blockquote><p>如果你真的很菜，你可以去一些更入门的论坛去搜寻答案（菜的远远不止你一个人，因此你遇到的问题很可能其他人也会遇到）</p><h4 id="不要擅自声称找到bug">不要擅自声称找到bug</h4><p>如果你没有非常明确的根据，不要擅自声称找到了bug（很可能是因为你不会用导致的）</p><p>如果你对该软件还没有足够的了解，就声称自己遇到的困难是bug，这可能会惹恼软件作者</p><p>即使真的有bug，你最好要写的像是你做错了什么，给开发者一个台阶下，他可能反过来给你说抱歉</p><h4 id="不要进行猜测">不要进行猜测</h4><p>如果你的猜测有效，那还用向别人求助吗？</p><p>你认为问题是怎么来的并不重要，重要地是描述问题本身，你的错误推测甚至可能会影响回答者的思路</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下…</p></blockquote><h4 id="按时间顺序描述问题症状">按时间顺序描述问题症状</h4><h4 id="描述目标而非过程">描述目标而非过程</h4><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。</p></blockquote><h3 id="问题解决后">问题解决后</h3><p>问题解决后你应该感谢帮助你的人</p><p>将标题修改为<strong>已解决</strong>，并在最后补充说明，你是如何解决问题的</p><h3 id="参考">参考</h3><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">How to Ask Question</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSSR</title>
      <link href="/graphics/SSSR/"/>
      <url>/graphics/SSSR/</url>
      
        <content type="html"><![CDATA[<h1>《Stochastic Screen Space Reflections》阅读笔记</h1><p>2015年SIGRAPH，EA提出了SSSR，用于《镜之边缘》中镜面反射</p><p>需求有</p><ul><li>支持清晰（sharp）和模糊（blurry）反射</li><li>邻接性，越近反射越清晰（contact hardening）</li><li>高光拉伸</li><li>逐像素的粗糙度和法线</li></ul><h2 id="相关工作">相关工作</h2><h3 id="mirror-only-SSR">mirror-only SSR</h3><p>我们先回顾传统的SSR</p><ol><li>从屏幕像素开始RayMarching（需要View空间的世界坐标和法线）</li><li>根据深度可以很轻松找到第一个落点，根据法线很容易求出反射光线的角度</li><li>使用简单的线性步进，求反射光线的命中点<ol><li>反射光线向前步进一段距离，到达C点</li><li>通过三角形边角性质，可以求出C点距离镜头的距离，这其实就是View空间的深度</li><li>若C点距离镜头的距离小于等于深度，则说明命中</li></ol></li><li>将命中位置进行透视投影，使用上一帧的渲染结果作为反射颜色</li></ol><img src="/images/SSR.png" class="lazyload" data-srcset="/images/SSR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SSR" style="zoom:50%;" /><h3 id="glossy-SSR">glossy SSR</h3><h4 id="模糊滤波">模糊滤波</h4><p>杀戮尖塔提供了一种glossy SSR，就是对反射像素做一次卷积模糊，但这种模糊是一视同仁的模糊，没有实现越近越清晰</p><h4 id="重要性采样">重要性采样</h4><p>相对于普通的SSR，这里根据法线求反射光线方向时，加入一些随机偏差，反射光线形成了一个锥形，进而实现了模糊的SSR</p><p>当物体离反射面比较近时，根据正弦定理，滤波的像素数量更少，于是清晰度更高</p><p>但是在光线数量比较少的情况下，会有大量噪点，效果很差</p><img src="/images/SSR噪点.png" class="lazyload" data-srcset="/images/SSR噪点.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SSR噪点" style="zoom:50%;" /><h2 id="作者的算法">作者的算法</h2><img src="/images/SSSR.png" class="lazyload" data-srcset="/images/SSSR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SSSR" style="zoom: 67%;" /><ol><li>将屏幕划分为Tile，进行一次低分辨率的光线步进，评估Tile的重要性，需要多少射线</li><li>根据材质粗糙度判断使用何种的RayMarching<ul><li>昂贵的射线：借助Hi-Z的精确tracing，能得到准确的命中点<ul><li>用于smooth表面</li></ul></li><li>便宜的射线：简单的线性步进<ul><li>用于粗糙表面（反正会做严重的滤波，不需要高精度）</li></ul></li></ul></li><li>使用BRDF重要性采样决定射线方向</li><li>使用邻居的采样信息进行模糊</li><li>TAA</li></ol><h2 id="Tile评估">Tile评估</h2><ol><li>对于每一个Tile以1/8分辨率发射射线</li><li>判断射线（的反射光线）是否击中<ol><li>若所有光线都没命中，则跳过这个Tile的步进</li><li>根据命中的比例和命中信息的差异，判断这个Tile中的像素需要多少个光线</li></ol></li></ol><h2 id="Hi-Z-tracing">Hi-Z tracing</h2><blockquote><p>详情可以去看《GPU Pro 5》</p></blockquote><p>Hi-Z使用四叉树组织屏幕深度，将层次关系存储在MipMap层级中，用于加速反射光线的求交</p><p>Hi-Z的构建时，对屏幕尺寸的深度进行滤波，每次保存2x2像素中最浅的像素，也就是说最高级别的Hi-Z存储着整张图中最浅的深度</p><p>用C点表示光线在步进过程中的头坐标，我们射线求交的原理就是判断C点距离相机的距离和该点深度图的深度关系，相交处必然是一侧比C点深，一侧比C点浅</p><p>此外还有几条经验：</p><ul><li>从相机出发的射线，落点位置是View空间该方向最浅的位置</li><li>从相机出发的射线，与落点位置的法线夹角应该大于$45^{\circ}$<ul><li>若夹角小于$45^{\circ}$，那么反射信息来自相机身后的内容，屏幕空间没有这些信息（可以用Cubemap补充信息）</li><li>若夹角大于$45^{\circ}$，那么我们基本可以认为，反射光线在步进过程中，深度在不断变深</li></ul></li><li>我们实际寻找的是，光线在步进过程中，比C点要深的最浅位置（更深，但只能深一点点）</li><li>由于起初我们位于最浅的位置，而步进的光线越来越深，因此第一个min-Z小于C点深度的位置，就是交点位置，我们只需要一直向右，不用回头<ul><li>这样得到的Mip等级比较高，我们通过降低Mip等级，每次取比C深中最浅的那一个，直到Mip为0</li></ul></li></ul><img src="/images/HiZTrace.png" class="lazyload" data-srcset="/images/HiZTrace.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="HiZTrace"  /><p>算法复杂度为$O(\log n)$</p><h2 id="重要性采样-2">重要性采样</h2><blockquote><p>重要性采样是蒙特卡洛积分中用于减少方差的算法，详情可以去看PBRT</p><p>简单来说就是我们有一个积分，我们不得不实时求这个积分，于是我们将这个积分很多项分离出去，最后变成了 复杂离散项 x 一段简单函数的积分</p></blockquote><h3 id="蒙特卡洛积分">蒙特卡洛积分</h3><img src="/images/三角形积分.png" class="lazyload" data-srcset="/images/三角形积分.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="三角形" style="zoom: 33%;" /><p>这是一个三角形，如果我们想求三角形的面积，可以对三角形的高度函数做积分</p><ul><li>第一种切分方法：均匀切分，三角形被分为等宽的长方形，每个长方形长$\Delta x$，高$\sqrt{1-x^2}$</li></ul><p>$$<br>S=\sum _{i=0}^N \Delta x \times h_i<br>$$</p><ul><li>第二种切分方法：重要性切分，左侧长方形更窄，右侧更宽</li></ul><p>$$<br>S=\sum _{i=0}^N x_i \times h_i<br>$$</p><p>三角形切被分为一个个长方形，长方形的面积代表贡献。很显然，左侧的长方形高度越高，相同宽度面积越大，贡献越多。也就是说，相同的x轴变化，左侧部分对积分的影响越明显，越高频</p><p>能看出（在同等误差下）重要性采样所需要的采样次数比均匀采样要小</p><p>重要性采样的思想就是，在高频处我们进行更多次的采样，低频处进行更少的采样，最后根据权重合并，就能在采样次数比较少的情况下，得到最精确的积分值</p><ul><li>高度函数$h_i$就是采样值</li><li>宽度函数$x_i$就是重要性权重</li><li>面积$S$就是在当前概率分布下的采样期望</li></ul><h3 id="概率密度函数">概率密度函数</h3><p>详情可以去看<a href="/2023/01/31/math/%E6%A6%82%E7%8E%87%E8%AE%BA/">概率论</a></p><p>在上一步，我们将连续函数的积分，转化为离散的采样值 x 重要性权重，然后我们发现，这个重要性权重怎么求？</p><p>还是上面的三角形，我们发现横坐标可以取[0, r]中任意值（r为三角形边长）</p><p>因此具体到某个点（随机变量），被取到的概率为$\frac{\mathrm{d}x}{r}$（这里其实不怎么精确，概率论中点取到的概率为0，这里实际上是一段很小的区域被取到的概率）</p><p>对于一个区域[a, b]，我们进行积分，得到随机变量取到该区域的概率P<br>$$<br>P(a &lt; X \le b)=F(b)-F(a)=\int_a^b \frac{1}{r}\mathrm{d}x=\frac{b-a}{r}<br>$$</p><ul><li><p>分布函数：$F(x)$</p></li><li><p>概率密度函数：$1/r$，我们用$p(x)$表示</p></li><li><p>概率：$P(a &lt; X \le b)$</p></li></ul><p>哦，现在我们知道了这个重要性权重有多大了<br>$$<br>x_i=\Delta x/P=1/p(x)<br>$$<br>进而我们可以写出这个三角形面积的期望<br>$$<br>S=\sum _{i=0}^N x_i \times h_i=\lim <em>{N \rightarrow \infty}\frac{1}{N}\sum</em>{k=1}^{N}\frac{f(x_k)}{p(x)}<br>$$</p><p>不过，值得注意的是，我们上面使用的PDF是均匀的，其实并能很好地加速收敛，实际会使用一个和原函数形状类似的PDF来加速收敛（PDF的选择不会影响最终结果，但是会影响收敛速度）</p><img src="/images/重要性采样.png" class="lazyload" data-srcset="/images/重要性采样.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="重要性采样" style="zoom:67%;" /><h3 id="BRDF生成射线方向">BRDF生成射线方向</h3><p>BRDF，双向反射分布函数，用于描述光线进出材质后能量的变化</p><p>我们在实现BRDF时，通常会实现以下接口</p><ul><li>eval：给定入射光方向和视线方向，求BRDF值</li><li>sample：生成射线方向</li><li>pdf：返回sample生成的射线的PDF</li></ul><p>我们以最简单的phong着色为例</p><p>在<a href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html">RTOW</a>中，我们朝着随机半球方向生成向量，该向量就是新射线的方向，同时求出该方向的PDF</p><blockquote><p>我个人理解，射线方向是随机生成的，每个方向出现的可能性相同，但是他们的PDF不同，你可以理解为重要性采样求三角形面积时，每个大长方形是由内部多个（数量相同）等高的小长方形拼成的，但是小长方形的宽度不一致，1/PDF就是小长方形的宽度。越重要的地方，长方形宽度越小，越密集，于是实现了重要性采样</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; alb, ray&amp; scattered, <span class="type">double</span>&amp; pdf)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">            <span class="comment">// Catch degenerate scatter direction</span></span><br><span class="line">            <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">                scatter_direction = rec.normal;</span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">unit_vector</span>(scatter_direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">            alb = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">            pdf = <span class="built_in">dot</span>(rec.normal, scattered.<span class="built_in">direction</span>()) / pi;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面生成新射线方向时，使用法线+球面向量，最后的形状就类似下图红色</p><img src="/images/法线+球.png" class="lazyload" data-srcset="/images/法线+球.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="法线+球" style="zoom:80%;" /><p>还清除了朝下（射向材质内部的）的射线</p><h3 id="随机数">随机数</h3><p>作者使用了<a href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/The_Halton_Sampler">Halton Sequences</a>生成随机数，并引入了截断，角度有最大值，这样能减弱BRDF的长尾巴（Tail）对结果的影响（这些尾巴会带来很多噪点）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">float2 u = <span class="built_in">halton</span>(sampleIdx);</span><br><span class="line">u.x = <span class="built_in">lerp</span>(u.x, <span class="number">1.0</span>, bias);</span><br><span class="line"><span class="built_in">importanceSample</span>(u);</span><br></pre></td></tr></table></figure><img src="/images/截断.png" class="lazyload" data-srcset="/images/截断.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="截断" style="zoom:67%;" /><h3 id="过滤重要性采样">过滤重要性采样</h3><p>一种基于预计算的光追，我们假设射线是圆锥形，我们可以根据MipMap层级得到滤波结果</p><img src="/images/coneRayTrace.png" class="lazyload" data-srcset="/images/coneRayTrace.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="coneRayTrace" style="zoom:67%;" /><h2 id="复用邻居光线">复用邻居光线</h2><h3 id="复用">复用</h3><p>上面提到glossy ssr会导致严重的噪点问题，即使使用重要性采样，每个像素仍需要大量光线才能得到低噪点的结果</p><p>我们注意到，相邻像素，他们的位置相近，可见性应该也是接近的，那么邻居像素朝某方向发射的光线，其实也可以被当前像素复用</p><p>当然直接做模糊（比如用高斯滤波）会导致很多光斑，经过很多数学推导和近似后，给出了以下公式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">result = <span class="number">0.0</span>;</span><br><span class="line">weightSum = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pixel : neighborhood)&#123;</span><br><span class="line">    weight = <span class="built_in">localBRDF</span>(pixel.hit) / pixel.hitPDF;</span><br><span class="line">    result += <span class="built_in">color</span>(pixel.hit) * weight;</span><br><span class="line">    weightSum += weight;</span><br><span class="line">&#125;</span><br><span class="line">result /= weightSum;</span><br></pre></td></tr></table></figure><h3 id="稀疏">稀疏</h3><p>受邻居光线的启发，我们完全没必要每个像素都做射线，只需要在低分辨率下某些点做多次射线，其邻居使用这个射线结果就可以</p><h3 id="TAA">TAA</h3><p>我们不仅在空间上做射线的复用，也可以在时间上及逆行复用</p><h2 id="参考">参考</h2><p><a href="https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html">SSR</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> SIGGRAPH </tag>
            
            <tag> GI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Probe-based Lighting in Unity Enemies</title>
      <link href="/graphics/UnityEnemies/"/>
      <url>/graphics/UnityEnemies/</url>
      
        <content type="html"><![CDATA[<h1>《Probe-based Lighting in Unity Enemies》阅读笔记</h1><p>2022年SIGGRAPH，Unity发布了一个数字人项目，在头发、眼球、GI方面效果非常好，我们来分析一下他的Probe-based GI</p><p><a href="http://advances.realtimerendering.com/s2022/SIGGRAPH2022-Advances-Enemies-Ciardi%20et%20al.pdf">论文地址</a></p><blockquote><p>感觉原理上就是在Volume GI的基础上，存了遮罩信息用于偏移采样点，使用紧凑哈希提高了空间利用率，感觉手游大世界完全可以上这个</p></blockquote><img src="/images/Enemies.png" class="lazyload" data-srcset="/images/Enemies.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Enemies" style="zoom:50%;" /><h3 id="不用Lightmap">不用Lightmap</h3><ul><li>难以处理复杂的集合体，难以处理LOD</li><li>烘焙速度慢，严重制约开发效率</li><li>无法处理动态物体，无法提供统一的光照</li><li>无法处理人物</li><li>Worse directional quality</li></ul><h3 id="Adaptive-Probe-Volumes">Adaptive Probe Volumes</h3><p>将空间划分为相同大小的cell，将cell作为分块烘焙、分块加载的最小单位</p><p>cell被细分为brick，在几何体密集的地方，brick越细分</p><img src="/images/adaptive.png" class="lazyload" data-srcset="/images/adaptive.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="adaptive" style="zoom:50%;" /><img src="/images/cell.png" class="lazyload" data-srcset="/images/cell.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cell" style="zoom:50%;" /><img src="/images/稀疏网格.png" class="lazyload" data-srcset="/images/稀疏网格.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="稀疏网格" style="zoom:67%;" /><h4 id="细分">细分</h4><blockquote><p>可以参考Lumen中Build Voxel Faces，本质就是推箱子</p></blockquote><p>细分的原理是使用Raycast判断一个区域有没有物体（命中点），我们使用SDF加速射线检测</p><img src="/images/SDF推箱子.png" class="lazyload" data-srcset="/images/SDF推箱子.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SDF推箱子" style="zoom:50%;" /><ol><li>我们将一个cell划分为4x4的brick，这样就有16条起始边界，这些边界构成了一个正方形</li><li>每一条边界向内发射一条长度为一的射线（使用SDF加速），若没有命中，则向内移动一格</li><li>直到所有边界都命中后，我们得到右图所示的brick</li></ol><h4 id="数据结构">数据结构</h4><p>感觉很类似与VolumeGI，由索引buffer和3DTexture组成，通过紧凑哈希来降低存储</p><ul><li>An indirection buffer存储了cell信息，cell索引→SH指针</li><li>Spherical Harmonics Pool中存储SH信息，SH指针→SH系数</li></ul><img src="/images/IndirectionBuffer.png" class="lazyload" data-srcset="/images/IndirectionBuffer.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IndirectionBuffer" style="zoom:50%;" /><h4 id="采样">采样</h4><p>采样流程：World Position → Cell Indirection → Per-Cell Brick Indirection→ Brick UVW →Trilinear Sample SH Data</p><ol><li>基于着色点posWS生成cellPos</li><li>加载cell信息</li><li>找到该着色点位于cell中哪一个brick（brick的最低层级可能是由相机距着色点距离决定的）</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> localBrickIndex = <span class="built_in">floor</span>(residualPosWS / (_MinBrickSize * <span class="built_in">pow</span>(<span class="number">3</span>, minFoundBrickLevel)));<span class="comment">//若minFoundBrickLevel=1，那么cell被细分为3x3个brick</span></span><br><span class="line">localBrickIndex -= validArea.min;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>加载brick信息</p></li><li><p>通过brick信息+offset采样3DTexture</p></li></ol><h3 id="接缝">接缝</h3><p>我们根据场景几何体密度构建空间八叉树，对于稀疏空间使用精度更低的高Subdiv Level存储Probe信息，在Level交界处有时会有明显的接缝问题</p><p>解决方法：采样时加入抖动</p><h3 id="黑斑">黑斑</h3><p>当我们做Probe摆放时，由于按网格和brick摆放，经常会出现Probe放在墙内的情况，这会导致墙面、地板发黑</p><p>Unity的做法是一种辐照度驱动的摆放，通过判断Probe位置处四周backface比例，来判断这个Probe的有效性</p><img src="/images/Probe评分.png" class="lazyload" data-srcset="/images/Probe评分.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Probe评分" style="zoom:50%;" /><p>对于有效性低/无效的Probe，Unity给出的解决方案就是，<strong>让墙内的Probe变亮</strong></p><h4 id="Post-Bake">Post-Bake</h4><ol><li>烘焙后遍历Probe，找到在墙内的无效Probe</li><li>搜索其邻居Probe，使用其中<strong>有效</strong>Probe进行加权插值，权重是距离的平方反比</li><li>于是墙内的Probe就成功变亮了</li></ol><img src="/images/Dilation2.png" class="lazyload" data-srcset="/images/Dilation2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Dilation2" style="zoom:67%;" /><h4 id="Pre-Bake">Pre-Bake</h4><blockquote><p>参考《The lighting technology of Detroit Become Human》</p></blockquote><p>使用Post-Bake后，确实黑斑少了，但是我们发现墙体出现了漏光，为此我们加入了Virtual Offset（bake阶段的offset），在烘焙时，将Probe移至墙外，最后再将墙外烘焙的信息写入墙内Probe中，于是既没有破坏网格结构，也实现了墙内Probe变亮</p><img src="/images/probeoffset.png" class="lazyload" data-srcset="/images/probeoffset.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="probeoffset" style="zoom:50%;" /><h3 id="漏光">漏光</h3><blockquote><p>我感觉防漏光的本质就是让墙体“变厚”，无论是摆放层面上的遮光板，烘焙时期的Virtual Offset，还是是采样层面的偏移</p></blockquote><p>传统的Probe采样，薄墙体由于使用了墙壁另一面的Probe信息发生漏光。为了避免漏光，采样时通常对采样位置进行偏移（Biases）</p><ul><li>Normal Bias，采样点沿着法线方向偏移<ul><li>这样做实际上让物体沿着法线方向变大了</li><li>偏移的过多/过少，都会影响效果</li><li>难以调优</li></ul></li><li>View Bias，采样点朝着相机方向偏移<ul><li>依赖于相机</li><li>难以调优</li></ul></li></ul><h4 id="Validity-Based-Weighting">Validity Based Weighting</h4><p>而Unity使用了Validity Based Weighting技术来减弱漏光，本质还是对采样点进行偏移</p><p>原理上是通过标记遮罩得出偏移方向，使得偏移方向基于辐照度，而非模型法线、视线，</p><ul><li>每一个Probe存储者8bit的遮罩，用于记录其八个方向（2x2x2）的邻居是否有效</li><li>若某个邻居无效，则推动采样点远离那个邻居（计算偏移的方向和大小）</li></ul><p>但我们现在其实只得到了偏移的方向，不知道偏移的距离</p><h4 id="遮光板">遮光板</h4><p>美术可以手动摆放一个遮光板，使得某些位置上的Probe失效</p><img src="/images/遮光板.png" class="lazyload" data-srcset="/images/遮光板.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="遮光板" style="zoom:50%;" /><p>这确实让房顶下面不再漏光，但是这让房顶上面的物体过黑了</p><p>Unity的做法是对遮光板内Probe的邻居进行判断</p><ul><li>若邻居Probe都不在室内（Occluding objects），那么不会使用遮光板，使用原本的数据</li><li>若邻居有在室内的，室内物体用到该Probe时才会变黑</li></ul><h3 id="场景管理">场景管理</h3><p>将球偕信息编码在3DTexture中比较好做Streaming</p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> SIGGRAPH </tag>
            
            <tag> GI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metal：TBDR</title>
      <link href="/graphics/TiledDeferred/"/>
      <url>/graphics/TiledDeferred/</url>
      
        <content type="html"><![CDATA[<h1>Tile Base Deferred Rendering</h1><p>基于Apple M1和Metal图形库</p><h3 id="移动端GPU渲染架构">移动端GPU渲染架构</h3><p><img src="/images/%E7%A7%BB%E5%8A%A8%E7%AB%AFGPU.png" class="lazyload" data-srcset="/images/%E7%A7%BB%E5%8A%A8%E7%AB%AFGPU.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="移动端GPU"></p><ul><li>IMR（Immediate Mode Rending），即时模式渲染，按drawcall顺序绘制</li><li>TBR（Tile Base Rendering）<ul><li>将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上</li><li>FS读信息，渲染每一个tile</li><li>当FS将所有的tile渲染完毕后，将完成的frame信息写入System Memory中</li></ul></li></ul><p>TBR相较于IMR能省带宽，而移动端的性能瓶颈在于带宽</p><p>值的注意的是，TBR产生带宽优势的核心是片上存储，而非Tile</p><blockquote><p>我个人感觉为什么要使用Tile，可能是因为移动端GPU规模太小，难以放下整张RT。毕竟理论上使用一张大RT的采样成本更低，比如将一组TextureArray转化为VSM，能很明显提高滤波速度</p><p>我在实际测试中发现当你隐式使用TBR时也会自动切分Tile，手动指定Tile尺寸反而增大了带宽和GPU时间（我也不清楚为什么，希望有人能给我解释一些）</p></blockquote><h3 id="On-Chip-Memory">On-Chip Memory</h3><p>片上存储（on-chip memory），是集成在GPU上的存储空间</p><p>GPU中有多种存储数据的结构，访问速度从快到慢排依次是</p><ol><li>Register Memory（RMEM）<ul><li>访问极快，不需要消耗时钟周期（除非发生了冲突或者先写后读）</li><li>只对负责对其进行读写的线程可见</li></ul></li><li>Shared Memory（SMEM）<ul><li>对处于同一个block所有的线程都是可见的，所以常用与数据交换</li></ul></li><li>Constant Memory（CMEM）<ul><li>用于存储常量数据</li></ul></li><li>Texture Memory（TMEM）<ul><li>用于存储常量数据</li></ul></li><li>Local Memory（LMEM）和Global Memory（GMEM）<ul><li>LMEM只是对GMEM的一个抽象，两者存取速度上一样的</li><li>只对负责对其进行读写的线程可见</li><li>一般用来存储automatic变量<ul><li>automatic变量是一种大尺寸的数据结构/数组</li></ul></li><li>有缓存机制（类比cache）</li></ul></li></ol><p>其中<strong>RMEM与SMEM是集成在GPU芯片上的</strong>，其他的则是存储在显存中的（你可以类比寄存器，cache和内存）</p><h4 id="Metal使用On-Chip-Mem">Metal使用On-Chip Mem</h4><p>Metal使用On-Chip Mem最大的变化就是，你不再需要在RenderPass中读取上一个Pass的贴图，传递给下一个Pass，Shader的输入值可以直接替换为上一个Pass的输出结果，并直接使用</p><blockquote><p>上一个Pass的结果你也可以通过<code>imageblock&lt;GBufferOut&gt; img_blk_gBuffer</code>访问</p></blockquote><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-fragment float4 fragment_deferredSun(VertexOut in [[stage_in]],</span></span><br><span class="line"><span class="addition">+fragment float4 fragment_tiled_deferredSun(VertexOut in [[stage_in]],</span></span><br><span class="line">        constant Params &amp;params [[buffer(ParamsBuffer)]],</span><br><span class="line">        constant Light *lights [[buffer(LightBuffer)]],</span><br><span class="line"><span class="deletion">-        texture2d&lt;float&gt; albedoTexture [[texture(BaseColor)]],</span></span><br><span class="line"><span class="deletion">-        texture2d&lt;float&gt; normalTexture [[texture(NormalTexture)]],</span></span><br><span class="line"><span class="deletion">-        texture2d&lt;float&gt; positionTexture [[texture(NormalTexture + 1)]])</span></span><br><span class="line"><span class="addition">+GBufferOut gBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint2 coord = uint2(in.position.xy);</span><br><span class="line"><span class="deletion">-    float4 albedo = albedoTexture.read(coord);</span></span><br><span class="line"><span class="addition">+ float4 albedo = gBuffer.albedo;</span></span><br><span class="line"><span class="deletion">-    float3 normal = normalTexture.read(coord).xyz;</span></span><br><span class="line"><span class="addition">+ float3 normal = gBuffer.normal.xyz;</span></span><br><span class="line"><span class="deletion">-    float3 position = positionTexture.read(coord).xyz;</span></span><br><span class="line"><span class="addition">+ float3 position = gBuffer.position.xyz;</span></span><br><span class="line">    Material material &#123;</span><br><span class="line">        .baseColor = albedo.xyz,</span><br><span class="line">        .specularColor = float3(0),</span><br><span class="line">        .shininess = 500</span><br><span class="line">    &#125;;</span><br><span class="line">    float3 color = phongLighting(normal,</span><br><span class="line">                                 position,</span><br><span class="line">                                 params,</span><br><span class="line">                                 lights,</span><br><span class="line">                                 material);</span><br><span class="line">    color *= albedo.a;</span><br><span class="line">    return float4(color, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Single-RednerPass">Single RednerPass</h3><blockquote><p>类比Vulkan的SubPass</p></blockquote><p>传统的延迟渲染，是一个多Pass渲染。GBufferPass生成MRT，传递给LightingPass着色输出，这个过程中会有大量的贴图IO带宽</p><img src="/images/传统延迟.png" class="lazyload" data-srcset="/images/传统延迟.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="传统延迟" style="zoom:50%;" /><p>TBDR（Tile Base Deferred Rendering）利用了Metal图形库Single RenderPass的特性</p><ul><li>在一个Single Pass中有多个小Pass，小Pass共享一组片上存储</li><li>一个Pass运行后，会在片上生成一些临时贴图，其他Pass可以直接访问这些贴图</li></ul><img src="/images/MetalTBDR.png" class="lazyload" data-srcset="/images/MetalTBDR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="MetalTBDR" style="zoom:50%;" /><blockquote><p>TBDR是Apple芯片的功能，对于安卓GPU</p><p>Adreno：frameBuffer fetch deferred，提前绑定（开辟）好MRT，使用时RT不动，Pass动</p><p>Mali：pixel loacl storage deferred，将GBuffer存在on-clip mem上，于是就减少了IO消耗</p></blockquote><h3 id="drawable">drawable</h3><p>当我们使用MTKView呈现渲染结果时，需要指定currentDrawable</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">unc draw(cullingResult: <span class="type">CullingResult</span>, <span class="keyword">in</span> view: <span class="type">MTKView</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> commandBuffer <span class="operator">=</span> <span class="type">RHI</span>.commandQueue.makeCommandBuffer(),</span><br><span class="line">              <span class="keyword">let</span> descriptor <span class="operator">=</span> view.currentRenderPassDescriptor <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        updateUniforms(cullingResult: cullingResult)</span><br><span class="line">        updateParams(cullingResult: cullingResult, options: options)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阴影投射</span></span><br><span class="line">        shadowRenderPass.draw(commandBuffer: commandBuffer,</span><br><span class="line">                              cullingResult: cullingResult,</span><br><span class="line">                              uniforms: uniforms,</span><br><span class="line">                              params: params,</span><br><span class="line">                              options: options)</span><br><span class="line">        <span class="comment">// TBDR</span></span><br><span class="line">        tiledDeferredRenderPass.skyboxCube <span class="operator">=</span> cullingResult.skybox</span><br><span class="line">        tiledDeferredRenderPass.shadowTexture <span class="operator">=</span> shadowRenderPass.shadowTexture</span><br><span class="line">        tiledDeferredRenderPass.descriptor <span class="operator">=</span> descriptor</span><br><span class="line">        tiledDeferredRenderPass.draw(commandBuffer: commandBuffer,</span><br><span class="line">                                     cullingResult: cullingResult,</span><br><span class="line">                                     uniforms: uniforms,</span><br><span class="line">                                     params: params,</span><br><span class="line">                                     options: options)</span><br><span class="line">        <span class="comment">// Post-Process</span></span><br><span class="line">        postProcessRenderPass.drawableTexture <span class="operator">=</span> view.currentDrawable<span class="operator">?</span>.texture</span><br><span class="line">        postProcessRenderPass.preTexture <span class="operator">=</span> tiledDeferredRenderPass.finalTexture</span><br><span class="line">        postProcessRenderPass.draw(commandBuffer: commandBuffer,</span><br><span class="line">                                   cullingResult: cullingResult,</span><br><span class="line">                                   uniforms: uniforms,</span><br><span class="line">                                   params: params,</span><br><span class="line">                                   options: options)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> drawable <span class="operator">=</span> view.currentDrawable <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        commandBuffer.present(drawable)</span><br><span class="line">        commandBuffer.commit()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们在TBDR时，将GBuffer和Depth设为<code>.messoryless</code>，并不保存，这些RT将放置在Color1～4中</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">albedoTexture <span class="operator">=</span> <span class="keyword">Self</span>.makeTexture(</span><br><span class="line">            size: size,</span><br><span class="line">            pixelFormat: .bgra8Unorm,</span><br><span class="line">            label: <span class="string">&quot;Albedo Texture&quot;</span>,</span><br><span class="line">            storageMode: .memoryless)</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">for</span> (index, texture) <span class="keyword">in</span> textures.enumerated() &#123;</span><br><span class="line">            <span class="keyword">let</span> attachment <span class="operator">=</span></span><br><span class="line">            descriptor.colorAttachments[<span class="type">RenderTarget0</span>.index <span class="operator">+</span> index]</span><br><span class="line">            attachment<span class="operator">?</span>.texture <span class="operator">=</span> texture</span><br><span class="line">            attachment<span class="operator">?</span>.loadAction <span class="operator">=</span> .clear</span><br><span class="line">            attachment<span class="operator">?</span>.storeAction <span class="operator">=</span> .dontCare</span><br><span class="line">            attachment<span class="operator">?</span>.clearColor <span class="operator">=</span></span><br><span class="line">            <span class="type">MTLClearColor</span>(red: <span class="number">0.73</span>, green: <span class="number">0.92</span>, blue: <span class="number">1</span>, alpha: <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>GBuffer Pass不输出Color0，Light Pass输出Color0，保存后传递给Post-Process Pass</p><p>其实你也可以直接将Light Pass的Color0设置为<code>view.currentDrawable?.texture</code>，这样Light Pass的结果会直接呈现在View上</p><blockquote><p>之前在这一步卡了很久，如果你不显式保存Color0，那么最后一个Pass的Color0就会成为drawable</p><p>但如果你将Color0保存，你会发现屏幕变品红色，没有报错，截帧会崩溃，其实就是你保存Color0后没有显式指定view.currentDrawable?.texture = Color0，View没有东西可以显示</p></blockquote><img src="/images/IMRtoTBDR.png" class="lazyload" data-srcset="/images/IMRtoTBDR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMRtoTBDR" style="zoom:50%;" /><h3 id="参考">参考</h3><p><a href="https://developer.apple.com/videos/play/wwdc2020/10632/">WWDC 2020</a></p><p><a href="https://github.com/kodecocodes/met-materials">Metal by Tutorials</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Render </tag>
            
            <tag> Metal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPH：入门</title>
      <link href="/graphics/SPH/"/>
      <url>/graphics/SPH/</url>
      
        <content type="html"><![CDATA[<h1>SPH入门</h1><p>SPH（Smoothed Particle Hydrodynamics）光滑粒子流体力学</p><blockquote><p>A mesh-free method for the discretization of functions and partial differential operators</p></blockquote><p>SPH是一种基于拉格朗日视角的算法，是一种空间离散化的算法，常用于连续介质的数值模拟</p><ul><li><p>材质导数的坐标</p><ul><li><p>拉格朗日坐标：视角随着介质移动而移动（粒子模拟）</p></li><li><p>欧拉坐标：视角是固定的，检测穿过视角的介质流速（网格模拟）</p></li></ul></li></ul><p><img src="/images/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5.png" class="lazyload" data-srcset="/images/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="拉格朗日"></p><p>SPH进行简单流体模拟，简单来说就是</p><ol><li>介质离散化，使用多个质点来表示流体（离散化）</li><li>对于每一个粒子，找到它附近的粒子（临域搜索）</li><li>计算密度（质量密度估计）</li><li>计算压强（控制方程，如理想气体状态方程+动量守恒），压强差、粘滞力等</li><li>更新运动状态</li><li>水体渲染（Marching Cube）</li></ol><h2 id="离散化">离散化</h2><h3 id="狄拉克函数">狄拉克函数</h3><p>狄拉克$\delta$函数，这是一个广义函数，其在整个定义域中积分值都集中在原点<br>$$<br>\delta (\mathbf{r})= \begin{cases}<br>\infty &amp; |\mathbf{r}|=0 \\<br>0 &amp; otherwise<br>\end{cases}<br>$$<br>该函数仅在积分中有意义，可以通过高斯钟形函数（正态分布）逼近</p><p><img src="/images/%E9%AB%98%E6%96%AF%E9%92%9F%E5%BD%A2.png" class="lazyload" data-srcset="/images/%E9%AB%98%E6%96%AF%E9%92%9F%E5%BD%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="高斯钟形"></p><p>在物理学中我们常用质点表示物体，但是因此使得密度函数失去了意义（因为质点没有空间），此时密度函数就塌缩成了狄拉克函数</p><p>空间中任何标量场函数，都可以用狄拉克函数表示：<br>$$<br>A(\mathbf{x})=(A*\delta)(\mathbf{x})=\int A(\mathbf{x}‘)\delta (\mathbf{x}-\mathbf{x}’)dv’<br>$$</p><ul><li>$dv’$是$\mathbf{x}'$对应的体积积分变量</li><li>$A(\mathbf{x}): \mathbb{R}^d \rightarrow \mathbb{R}$，d是维度，意思就是这是一个空间函数</li></ul><blockquote><p>$\mathbb{R}$是实数集</p><p>$\mathbb{R}^+$是正实数集（不含0）</p><p>$\mathbb{R}^d$是d维实数集</p></blockquote><h3 id="光滑核函数">光滑核函数</h3><p>我们有了狄拉克函数，想要把连续函数来离散表示</p><p>核函数（kernel functions，smoothing kernels）是一种随着距离而衰减的函数，与高斯函数要在整个作用域积分不同，核函数是有最大影响半径的，最大影响半径用$h$表示</p><img src="/images/核函数.png" class="lazyload" data-srcset="/images/核函数.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="核函数" style="zoom:50%;" /><p>核函数满足</p><ol><li>归一化</li><li>狄拉克条件</li><li>非负性</li><li>对称性</li><li>有界性</li></ol><p><img src="/images/%E6%A0%B8%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8.png" class="lazyload" data-srcset="/images/%E6%A0%B8%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="核函数性质"></p><p>一个经典的核函数是三次样条器（cubic spline kernel）</p><p><img src="/images/%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%99%A8.png" class="lazyload" data-srcset="/images/%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%99%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="三次样条器"></p><ul><li>其中$q=\frac{1}{h}||\mathbf{r}||$</li></ul><h3 id="离散化-2">离散化</h3><blockquote><p>有个数学大佬告诉我，这里就是“在某个i点处求所有其他j点按核函数加权的平均值，只不过离散化的时候划成了区块赋予了密度和体积”</p><p>换句话说，这其实就是一次卷积（数学家真是不讲人话）</p></blockquote><p>参考上面那张核函数的图，离散化就是对于$i$点，我们求该点附近场密度函数值和核函数（一堆$j$点）的加权平均值</p><img src="/images/离散化.png" class="lazyload" data-srcset="/images/离散化.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="离散化" style="zoom:50%;" /><p>在数学上，$\langle A(x)\rangle $表示平均值</p><h3 id="质量密度估计">质量密度估计</h3><p>粒子不需要携带质量密度函数，对于空间中任意位置的点，都可以通过离散化求出该点密度</p><p>对于$\mathbf{x}_i$位置处的点，其密度为：</p><p>$$<br>\rho_{i} =\sum_{j} m_{j}W_{ij}<br>$$<br>不过在流体边界，这样求密度会导致数据偏小，需要做边界处理</p><p>下图绿色点临域完整，得到正确的密度，而红色点只能得到一个较小的密度</p><img src="/images/流体边界.png" class="lazyload" data-srcset="/images/流体边界.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="流体边界" style="zoom:50%;" /><h3 id="微分算子的离散化">微分算子的离散化</h3><p>上面我们已经实现场函数的离散化，实现了质量密度估计。但除此之外，还有一些空间微分算子（导数）值得离散化<br>$$<br>\nabla A_{i}\approx \sum_{j} A_{j}\frac{m_{j}}{\rho_{j} } \nabla W_{ij}<br>$$</p><blockquote><p>关于拉普拉斯算符，可以去看<a href="/2023/01/31/math/Nabla%E7%AE%97%E5%AD%90/">Nabla算子</a>，简单来说这东西是将标量场转化为向量场，一阶算符就是梯度，二阶是散度，用于得到数据变化最快的方向。文中也实现了拉普拉斯算符的离散化</p></blockquote><p>文章介绍了两种最常用的梯度的近似方法，并给了适用范围</p><ul><li>差分公式（Difference Formula）：用于近似速度的散度</li><li>对称公式（Symmetric Formula）：用于近似力、脉冲的梯度</li></ul><h4 id="差分公式">差分公式</h4><p>在高中学微积分时，我们用两个相邻的点组成的线来逼近切线，以此引入了极限、导数的概念。在实际应用中，这两个点不可能无穷近，于是存在误差</p><p>使用差分表示导数（导数就是），我们只能把$h$取到一个很小的值，而不是无穷小，因此这个导数是有误差的<br>$$<br>f’(x)=\lim_{h \rightarrow0}\frac{f(x+h/2)-f(x-h/2)}{h}<br>$$<br>我们需要衡量这个误差的大小，于是我们将$f(x\pm h/2)$泰勒展开后带入上式，得到<br>$$<br>f’(x)=\lim_{h \rightarrow0}\frac{f’(x)h+O(h^3)}{h}=f’(x)+O(h^2)<br>$$<br>误差大小为$O(h^2)$</p><blockquote><p>经计算，二阶导数的误差也是$O(h^2)$</p></blockquote><h4 id="对称公式">对称公式</h4><h2 id="临域搜索">临域搜索</h2><p>这里介绍最简单的，不做空间优化的临域搜索，进阶内容可以看<a href="2023/02/06/graphics/%E9%82%BB%E5%9F%9F%E6%90%9C%E7%B4%A2/">临域搜索</a></p><p>由于核函数存在作用范围，我们在积分时，只需要遍历核半径内其他粒子的信息。这样相较于nxn的全遍历，能大幅减少计算，为此我们需要构建临域表</p><h3 id="网格化">网格化</h3><p>临域搜索是一种基于网格（grid）构建粒子拓扑关系的算法，找到该粒子所在位置和其相邻位置有哪些粒子</p><p>我们将整个（粒子作用的）场景均匀切分为一个个三维网格，每个网格为立方体，边长等于核半径$\hslash $，</p><p>每个网格拥有一个坐标$(i,j,k)$，用于表示网格在场景中的位置</p><p>对于任意一个粒子，其核函数的作用范围是一个球，临域搜索就是计算球内有哪些粒子</p><img src="/images/grid.png" class="lazyload" data-srcset="/images/grid.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="grid" style="zoom: 33%;" /><ol><li>空间网格化</li><li>遍历粒子，记录每个网格中有多少个粒子，有哪些粒子</li><li>遍历粒子，建立临域表<ol><li>求该粒子的核函数球位于哪些网格中</li><li>遍历那些网格，取出网格中所有粒子，计算距离</li><li>将距离小于核半径的粒子id存储在临域表中</li></ol></li></ol><h3 id="数据结构">数据结构</h3><table><thead><tr><th>名称</th><th>Key</th><th>Value</th></tr></thead><tbody><tr><td>_neighbourList</td><td>id.x * maximumParticlesPerCell * 8 + _neighbourTracker[id.x]++</td><td>临居的id</td></tr><tr><td>_neighbourTracker</td><td>id.x</td><td>当前粒子有多少个临居</td></tr><tr><td>_hashGrid</td><td>hashCellIdx * maximumParticlesPerCell + previousCount</td><td>id.x</td></tr><tr><td>_hashGridTracker</td><td>hashCellIdx</td><td>该网格中的粒子数</td></tr></tbody></table><ul><li>id.x：当前粒子id</li><li>hashCellIdx：网格坐标的Hash值</li><li>maximumParticlesPerCell：每个网格的的粒子最大数量（提前留好空）</li><li>previousCount：空里有几个粒子</li></ul><h3 id="球作用于哪些网格">球作用于哪些网格</h3><p>我们发现核函数球最少位于8个网格中（一个2x2x2的立方体），最多位于27个网格中（一个3x3x3的立方体），我们只需要找出核函数球位于哪些网格中，就能减少很多便利</p><p>在这里，我们只使用8个网格作为临域（舍弃那些不重要的网格），很显然，球心向哪个方向靠，我们就使用哪8个网格</p><ol><li>找到球心所在网格坐标，构建临域坐标表，临域坐标初始均设为球心位置</li><li>判断中心网格的中心坐标与球心的坐标位置关系</li><li>存储临域Hash Key</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNearbyKeys</span><span class="params">(int3 originIndex, float3 position, out <span class="type">int</span> nearbyKeys[<span class="number">8</span>])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int3 nearbyBucketIndices[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[i] = originIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((originIndex.x + <span class="number">0.5f</span>) * CellSize &lt;= position.x) </span><br><span class="line">    &#123;        </span><br><span class="line">        nearbyBucketIndices[<span class="number">4</span>].x += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">5</span>].x += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">6</span>].x += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].x += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[<span class="number">4</span>].x -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">5</span>].x -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">6</span>].x -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].x -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((originIndex.y + <span class="number">0.5f</span>) * CellSize &lt;= position.y) </span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[<span class="number">2</span>].y += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">3</span>].y += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">6</span>].y += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].y += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[<span class="number">2</span>].y -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">3</span>].y -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">6</span>].y -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].y -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((originIndex.z + <span class="number">0.5f</span>) * CellSize &lt;= position.z) </span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[<span class="number">1</span>].z += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">3</span>].z += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">5</span>].z += <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].z += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nearbyBucketIndices[<span class="number">1</span>].z -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">3</span>].z -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">5</span>].z -= <span class="number">1</span>;</span><br><span class="line">        nearbyBucketIndices[<span class="number">7</span>].z -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) </span><br><span class="line">    &#123;</span><br><span class="line">        int3 nbcellIndex = nearbyBucketIndices[j];</span><br><span class="line">        <span class="keyword">if</span> (nbcellIndex.x &lt; <span class="number">0</span> || nbcellIndex.x &gt;= Dimensions || nbcellIndex.y &lt; <span class="number">0</span> || nbcellIndex.y &gt;= Dimensions || nbcellIndex.z &lt; <span class="number">0</span> || nbcellIndex.z &gt;= Dimensions) </span><br><span class="line">        &#123;</span><br><span class="line">            nearbyKeys[j] = <span class="number">-1</span>;<span class="comment">//出界了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            nearbyKeys[j] = <span class="built_in">Hash</span>(nearbyBucketIndices[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将三维坐标转化为一维hash key</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(int3 cell)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cell.x + Dimensions * (cell.y + Dimensions * cell.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建临域表">构建临域表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">numthreads</span>(<span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildNeighbourList</span><span class="params">(uint3 id : SV_DispatchThreadID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _neighbourTracker[id.x] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> int3 cell = <span class="built_in">GetCell</span>(_particles[id.x].position);</span><br><span class="line">    <span class="type">int</span> cells[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">GetNearbyKeys</span>(cell, _particles[id.x].position, cells);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cells[j] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// Grid does not contain cell.</span></span><br><span class="line">        <span class="type">const</span> uint numberOfParticlesInCell = <span class="built_in">min</span>(_hashGridTracker[cells[j]], maximumParticlesPerCell); ;</span><br><span class="line">        <span class="keyword">for</span> (uint index = <span class="number">0</span>; index &lt; numberOfParticlesInCell; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> uint potentialNeighbour = _hashGrid[cells[j] * maximumParticlesPerCell + index];</span><br><span class="line">            <span class="keyword">if</span> (potentialNeighbour == id.x) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">const</span> float3 v = _particles[potentialNeighbour].position - _particles[id.x].position;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dot</span>(v, v) &lt; radius2) <span class="comment">// Use squared length (= dot) instead of length for performance.</span></span><br><span class="line">            &#123;</span><br><span class="line">                _neighbourList[id.x * maximumParticlesPerCell * <span class="number">8</span> + _neighbourTracker[id.x]++] = potentialNeighbour;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制方程">控制方程</h2><p>尽管物体在微观层面（比如原子）是离散的，但在宏观层面上，流体、固体表现为连续介质</p><blockquote><p>continuum, a region of continuously distributed mass</p></blockquote><p>根据定义，一个连续介质可以被切分为多个小的连续介质（类比实数的稠密性，任意两个实数间总存在第三个实数），而不影响其性质</p><p>材料粒子（material particle）：a portion of matter contained in an infinitesimal volume</p><h3 id="连续性方程">连续性方程</h3><p>连续性方程描述了物体的密度与时间的关系<br>$$<br>\frac{D\rho}{Dt}=-\rho(\nabla \cdot \mathbf{v})<br>$$</p><h3 id="随体导数">随体导数</h3><p>随体导数（material derivative）：$\frac{D(\cdot)}{Dt}$</p><p>随体导数描述了材质点的场量随着时间的变化率</p><p>在制作不可压缩的介质中，必须始终保持<br>$$<br>\frac{D\rho}{Dt}=0<br>$$<br>随体导数与坐标系有关，常见的坐标系有：拉格朗日坐标系和欧拉坐标系</p><h3 id="线性动量守恒定律">线性动量守恒定律</h3><p>高中物理就学过的碰撞时动量守恒，力作用在物体上，会改变物体的动量</p><p>将运动公式（equation of motion）用积分的形式写出来就是<br>$$<br>\rho \frac{D^2\mathbf{x}}{Dt^2}=\nabla \cdot \mathbf{T}+\mathbf{f}_{ext}<br>$$</p><ul><li>$\mathbf{T}$：应力张量（stress tensor）</li><li>$\mathbf{f}_{ext}$：体积力（body forces），穿越空间作用在所有流体元上的非接触力，例如重力、惯性力、电磁力</li></ul><h4 id="理解应力张量">理解应力张量</h4><p>对于材质内部一个微小平面，这个平面会受材质中其他点的作用力，这个力可能不与平面垂直。其中垂直于平面的力叫正向应力，平行于平面的力叫剪应力</p><p>矢量是一种一维张量，由大小和一个方向组成。然而对于应力，我们没法使用矢量进行表示，于是改用二维张量来表示，一个方向是应力的指向，一个方向是应力所在的平面方向</p><p>对于材质内一个点，它可能处于无数个平面中，我们需要用一种平面无关的方式来表示其受力状态。在三维空间中，我们选择了三组正交基底$(\mathbf{e}_1,\mathbf{e}_2,\mathbf{e}_3)$构建坐标系，应用中给定一个方向$\mathbf{e}$，就能求出该方向的应力矢量</p><img src="/images/应力张量.png" class="lazyload" data-srcset="/images/应力张量.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="应力张量" style="zoom:50%;" /><p>其中$\mathbf{T}$为应力矢量，$\sigma $为柯西应力张量（一个3x3的矩阵）</p><p>$\sigma_{xy}$的意思是，处于yz平面，指向y方向</p><img src="/images/柯西应力张量.png" class="lazyload" data-srcset="/images/柯西应力张量.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="柯西应力张量" style="zoom:50%;" /><img src="/images/三维应力.png" class="lazyload" data-srcset="/images/三维应力.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="三维应力" style="zoom:50%;" /><blockquote><p>柯西应力张量只适用于材料微小变形的情况</p></blockquote><h4 id="Navier-Stokes方程">Navier-Stokes方程</h4><p>一个经典的不可压缩流体的张力表示方法<br>$$<br>\mathbf{T}=-p+\mu (\nabla \mathbf{v}+\nabla  \mathbf{v}^T)<br>$$</p><ul><li>$p$：压强</li><li>$\mu$：粘度（viscosity ）</li></ul><p>我们将该液体的应力张量公式带入牛顿运动公式，得到速度的公式<br>$$<br>\rho \frac{D\mathbf{v}}{Dt}=-\nabla p + \mu \nabla^2 \mathbf{v}+\mathbf{f}_{ext}<br>$$<br>压强可以由密度表示，根据理想气体压强公式，我们得知压强与密度呈线性关系，于是我们取一个静止状态下的密度$\rho_0$，通过与当前状态密度做差值，就能得出压强</p><blockquote><p>理想气体压强公式，初中就学了，$pV=nRT$</p></blockquote><p>$$<br>p=B((\frac{\rho}{\rho_0})^{\gamma}-1)<br>$$</p><ul><li>$B$：体积模量（bulk modulus）</li></ul><h4 id="弹力">弹力</h4><p>拥有弹力的固体，应力张量来自于固体的形变，之后会展开讲</p><h2 id="积分求解">积分求解</h2><h3 id="混合初始边界值问题">混合初始边界值问题</h3><p>我们上面给出了控制方程，但是想要求解运动问题，必须给定初始位置和速度（场）</p><p>一般而言，混合初始边界值问题（Mixed Initial-Boundary Value Problem）没有解析解，只有数值解</p><blockquote><p>得嘞，这一节就这一句话，这一句话一个字都看不懂</p></blockquote><h4 id="混合边界">混合边界</h4><blockquote><p>简单来说，就是要想求解运动问题，必须既要给初始位置，也要给初始速度（场）</p></blockquote><p>边界条件也叫定解条件，是微分方程里的概念，给定初始值才能求控制方程、偏微分方程的解（比如带入解中的未知数）</p><p>放在物理学中叫临界条件，就是物体处于某两种状态间的交界处，比如冰水混合物</p><p>边界条件对于解决物理问题（比如求极值）十分重要</p><p>有三类边界条件</p><ul><li>第一类边界条件（迪利克雷边界条件，Dirichlet boundary condition）<ul><li>直接告诉你边界值，比如热传递中告诉你边界处温度</li></ul></li><li>第二类边界（若依曼边界条件，Neumann boundary condition）<ul><li>告诉你边界处的梯度，比如热传递中告诉你热流密度（温度的梯度）</li></ul></li><li>混合边界条件<ul><li>第一二类边界的混合，比如热对流微分公式，公式中既有温度，也有梯度，只有同时给出两者，才能求解</li></ul></li></ul><p>$$<br>q=h(T_0-T_a)<br>$$</p><h4 id="解析解与数值解">解析解与数值解</h4><ul><li>解析解（analytic solution），形如一个函数，给定变量就能得出任意位置的解</li><li>数值解（numerical solution），这是一个数，是采用有限元、数值逼近、插值等方法得到的解</li></ul><blockquote><p>据说在数学家和物理学家眼里，解析解才是真正的解，更高贵，美丽</p><p>让我突然想到三体力魏成想要求出三体问题的解析解，结果最后发现这个问题只有数值解</p></blockquote><h3 id="算子分裂">算子分裂</h3><p>就是使用分治的算法，将一个复杂的偏微分方程（PDE），分解为几个连续的子问题</p><img src="/images/算子分解.png" class="lazyload" data-srcset="/images/算子分解.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="算子分解"  /><p>在实践中证明，像这样每步操作依赖于上一步，一步一步操作，能提高系统的稳定性</p><h3 id="时间积分">时间积分</h3><p>在实时渲染中，和精度相比，性能、稳定性和鲁棒性更重要</p><p>在GAMES201开篇讲弹簧质点模型时，关于质点的运动方程，给出了两种积分器：显式积分器和隐式积分器</p><h4 id="显式积分器">显式积分器</h4><p>从过去的状态得到现在的状态，表示简单容易实现</p><p>$$<br>\mathbf{v}_{t+1}=\mathbf{v}_t+\Delta t \frac{\mathbf{f}_t}{m}<br>$$</p><!----><p>$$<br>\mathbf{x}_{t+1}=\mathbf{x}<em>t+\Delta t \mathbf{v}</em>{t+1}<br>$$</p><p>但是显式积分器有一个问题，就是容易爆炸，于是$\Delta t$不能太大，应满足<br>$$<br>\Delta t \le c\sqrt{\frac{m}{k}} \ \ (c \sim 1)<br>$$</p><h5 id="CFL条件">CFL条件</h5><p>这是CFL条件（Courant–Friedrichs–Lewy condition），是某些偏微分方程的收敛条件，它决定了显式积分器中粒子在单位时间内走过的距离，必须小于粒子大小（或者说质点间的间距）<br>$$<br>\Delta t \le \lambda \frac{\tilde{h}}{|\mathbf{v}^{\max}|}<br>$$</p><ul><li>$\tilde{h}$：粒子大小（质点间的间距）</li><li>$\lambda$：一个常量</li><li>$\mathbf{v}^{\max}$：粒子运动的最快速度</li></ul><h4 id="隐式积分器">隐式积分器</h4><p>现在的状态依赖于现在的状态（求$t+1$时刻的信息，结果需要$t+1$时刻的信息），难以实现，但鲁棒性强</p><!----><p>$$<br>\mathbf{v}_{t+1}=\mathbf{v}<em>t+\Delta t \mathbf{M}^{-1}\mathbf{f}(\mathbf{x}</em>{t+1})<br>$$</p><!----><p>$$<br>\mathbf{x}_{t+1}=\mathbf{x}<em>t+\Delta t \mathbf{v}</em>{t+1}<br>$$</p><ul><li>$\mathbf{M}$：质量矩阵</li></ul><h2 id="Marching-Cube">Marching Cube</h2><h2 id="符号表">符号表</h2><p><img src="/images/%E7%AC%A6%E5%8F%B7.png" class="lazyload" data-srcset="/images/%E7%AC%A6%E5%8F%B7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="符号"></p><h2 id="参考">参考</h2><p><a href="https://interactivecomputergraphics.github.io/physics-simulation/">Physics Simulation in Visual Computing</a></p><p><a href="https://www.bilibili.com/video/BV1ZK411H7Hc">GAMES201</a></p><p><a href="https://zhuanlan.zhihu.com/p/426566636">MrKill的知乎</a></p><p><a href="https://github.com/alen-cell/PhysicsEngine">alen-cell</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Physics </tag>
            
            <tag> SPH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是谁</title>
      <link href="/%E6%88%91%E6%98%AF%E8%B0%81/"/>
      <url>/%E6%88%91%E6%98%AF%E8%B0%81/</url>
      
        <content type="html"><![CDATA[<h1>一个渴望得到认同的怪兽</h1><p>大家好，我叫孙政，是一个渴望得到认同的怪兽。</p><p>在小学时就很有表达欲，在班级制作并发售了一款宝可梦卡牌。上大学后加入了游戏开发社团，最初想做游戏策划，但在一次GameJam中了解了Shader，于是学了一些图形学知识，在字节做TA，毕业去做自研游戏引擎</p><p>平时有在做一些游戏demo，但严重缺乏美术资源，基本都是写了策划案搓了点demo就放弃了。LLM和AIGC的兴起，让我找到独立游戏开发的新动能，AI在游戏行业必然大有所为。</p><h3 id="经历">经历</h3><ul><li>多模态算法工程师 阶跃星辰 2024.4~至今</li><li>游戏引擎 不鸣科技 2022.12~2024.4</li><li>技术美术实习 字节朝夕光年 2021.12~2022.9</li><li>游戏策划实习 字节朝夕光年</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11特性</title>
      <link href="/program/C++11/"/>
      <url>/program/C++11/</url>
      
        <content type="html"><![CDATA[<h1>C++11特性</h1><p>都什么年代了，还在整C++11？八股害人啊</p><h2 id="一：C-11的“新”特性">一：C++11的“新”特性</h2><h3 id="nullptr">nullptr</h3><p>一个新关键字，用于表示指针指向no value，可以被自动转化为各种指针类型，但是不会被转化为整数</p><p><em>比NULL好，因为NULL的本质就是整数0</em></p><h3 id="auto">auto</h3><p>通过auto声明变量、对象，可以自动推到其类型，在处理表达式时有奇效</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> l = [](<span class="type">int</span> x) -&gt; &#123;...&#125;;</span><br></pre></td></tr></table></figure><h3 id="一致性初始化">一致性初始化</h3><p>一致性初始化（Uniform Initiallization），简单来说就是可以用大括号来做初始化</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> v[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c&#123;<span class="number">4.0</span>, <span class="number">3.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>但是这个操作不支持<strong>窄化（narrowing）</strong>，即</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5.3</span>;<span class="comment">//x == 5</span></span><br><span class="line"><span class="type">int</span> y &#123;<span class="number">5.3</span>&#125;;<span class="comment">//Error</span></span><br></pre></td></tr></table></figure><h3 id="新的for循环">新的for循环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item: lists)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="左值右值">左值右值</h3><h4 id="左值">左值</h4><p>左值：占用一定内存，具有可辨认身份（可以被取地址、引用）的对象（表达式结束后仍然存在的持久对象），C++中绝大多数变量都是左值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;<span class="comment">// i 是左值</span></span><br><span class="line"><span class="type">int</span> *p = &amp;i;<span class="comment">// i 的地址是可辨认的</span></span><br><span class="line">i = <span class="number">2</span>; <span class="comment">// i 在内存中的值可以改变</span></span><br><span class="line">A a; <span class="comment">// 用户自定义类实例化的对象也是左值</span></span><br><span class="line">++i=<span class="number">0</span>;<span class="comment">// i 是左值，会先自增，再赋值为0</span></span><br></pre></td></tr></table></figure><h4 id="右值">右值</h4><p>右值：左值以外的所有对象，分为亡值（xvalue, eXpiring Value，任务完成后就会被销毁）和纯右值（prvalue,Pure Rvalue，在表达式结束后就会被销毁）</p><p>亡值尽管也很快销毁，但是在生命周期内也是具有可辨识身份的，因此属于广义左值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">2</span>;<span class="comment">// 2 这种字面量，是纯右值</span></span><br><span class="line"><span class="type">int</span> x = i + <span class="number">2</span>; <span class="comment">// (i + 2) 这种运算表达式，是纯右值</span></span><br><span class="line">A a = <span class="built_in">A</span>(); <span class="comment">// A() 这种函数非引用返回的临时对象，是纯右值，是一个临时对象，在a构造完成后会被销毁</span></span><br><span class="line">A&amp;&amp; a = <span class="built_in">A</span>();<span class="comment">// a是一个右值引用，A是一个返回右值引用的函数，A()返回的对象是一个亡值，在右值引用的帮助下，生命周期变的和a一致</span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// sum(1, 2) 是右值</span></span><br></pre></td></tr></table></figure><p>不能对右值赋值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i + <span class="number">2</span> = <span class="number">4</span>; <span class="comment">// 错误，不能对右值赋值</span></span><br></pre></td></tr></table></figure><p>不能对右值取地址</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;(i + <span class="number">2</span>);<span class="comment">// 错误，不能对右值取地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">square1</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;<span class="keyword">return</span> a * a;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span> </span>&#123;<span class="keyword">return</span> a * a;&#125; </span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">square1</span>(i); <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">square1</span>(<span class="number">2</span>); <span class="comment">// 错误，不能对右值取地址</span></span><br><span class="line"><span class="built_in">square2</span>(<span class="number">2</span>);<span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h4 id="常量左值引用">常量左值引用</h4><p>为什么可以<code>const int &amp;a = 2;</code>呢？这里一个常量左值引用（a）被绑定到了一个右值（2）上，这导致右值<code>2</code>的生命周期变得和<code>a</code>相同</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = <span class="number">2</span>;<span class="comment">// 可以</span></span><br><span class="line"><span class="type">int</span>&amp; b = <span class="number">2</span>;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h3 id="转移语意">转移语意</h3><p>转移语意（move semantic），本质是所有权的转移，将即将销毁的对象转移给他人，避免非必要的拷贝和临时对象</p><p>比如一个函数定义为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> T&amp; v)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>当我们调用时</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T t;</span><br><span class="line"><span class="built_in">fun</span>(t);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">fun</span>(t+<span class="number">1</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>我们发现，第一种调用时，直接传了引用，没有拷贝和临时变量，而第二种，实际上是</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T temp = t+<span class="number">1</span>;<span class="comment">//T temp(t+1)或者 T temp.T(t+1)</span></span><br><span class="line"><span class="built_in">fun</span>(temp);</span><br></pre></td></tr></table></figure><p>总之是调用了拷贝构造函数和生成了临时变量，这不是我们想要的，于是引入了左右值和转移语意的概念，然后就诞生了一种新的调用方式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fun</span>(std::<span class="built_in">move</span>(t+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><code>std::move</code>的作用是将其参数<code>t+1</code>变成一个<strong>右值引用（rvalue reference）</strong>，是一个<code>T&amp;&amp;</code>的类型</p><p>一旦一个类型被“标记”为右值，就意味着这是一个临时对象，你可以随意使用它的内容和资源</p><p>然后我们可以优化一下这个函数的定义</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">T</span> (<span class="type">const</span> T&amp; lvalue);<span class="comment">// 通过左值拷贝构造（根传统C++一样）</span></span><br><span class="line">  <span class="built_in">T</span> (T&amp;&amp; rvalue);<span class="comment">// 通过右值move构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; v)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>右值被move以后，就变成有效但不确定的状态</p><h3 id="字符串字面量">字符串字面量</h3><h4 id="Raw-String-Literal">Raw String Literal</h4><p>以R开头的字符串，可以换行，不需要转义，用于正则表示式有奇效</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">R&quot;(\\n)&quot;</span>;<span class="comment">//等于 &quot;\\\\n&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Encoded-String-Literal">Encoded String Literal</h4><p>用于国际化</p><h3 id="noexcept">noexcept</h3><p>让函数无法抛出异常，遇到未定义事件会直接<code>abort</code>，这相当于假定了这个函数是绝对不会出现异常的，标准库中大量函数均有这种要求</p><p>noexcept后面可以跟一个bool条件，为true时就不抛异常</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(T&amp; x, T&amp; y)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(x.swap(y)))</span></span>&#123;</span><br><span class="line">    x.<span class="built_in">swap</span>(y);</span><br><span class="line">    <span class="comment">//这个函数意味着，只要xy交换不抛异常，那么下面这些函数体做任何事都不会抛异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constexpr">constexpr</h3><p>用于让表达式核定与编译期，能助力TMP编程</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> a[<span class="built_in">square</span>(<span class="number">9</span>)];</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前的写法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++11写法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value&#123; n * Factorial&lt;n - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="新的模板">新的模板</h3><h4 id="不定个数的参数">不定个数的参数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T , <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; first, <span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; first &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">f</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板别名">模板别名</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;<span class="comment">//等价于std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll;</span></span><br></pre></td></tr></table></figure><h3 id="Lambda">Lambda</h3><p>允许函数的定义式被用作一个参数、local对象</p><h4 id="定义与调用">定义与调用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;<span class="comment">//这是一个lambda表达式</span></span><br><span class="line"></span><br><span class="line">[]&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;();<span class="comment">//定义并直接调用表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> l = []&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">l</span>();<span class="comment">//调用表达式</span></span><br></pre></td></tr></table></figure><h4 id="含参">含参</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> l2 = [](<span class="type">const</span> std::string&amp; s)&#123;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">l</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="返回值">返回值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部作用域">外部作用域</h4><p>分值传递和引用传递两种，值传递不能进行修改</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> l = [x, &amp;y] &#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    ++y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">l</span>();<span class="comment">//调用，注意xy不是参数，不需要写在括号里</span></span><br></pre></td></tr></table></figure><h4 id="mutable">mutable</h4><p>这个关键词是const的反义词，意思是可变的，于是让值传递也可变</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> l = [x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">l</span>();</span><br></pre></td></tr></table></figure><h3 id="decltype">decltype</h3><p>自动推导表达式的类型，大号typeof</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) b = <span class="number">2</span>; <span class="comment">// b是const int&amp;</span></span><br></pre></td></tr></table></figure><h4 id="推断返回类型">推断返回类型</h4><p>可以将返回类型的声明放在参数列之后</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带领域的枚举">带领域的枚举</h3><h3 id="promise与future">promise与future</h3><p><code>std::promise</code>意思为共享状态，是C++11提供的在两个异步任务间传递数据的方式，常与<code>std::future</code>一起使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生产者端</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Producer\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 设置共享数据为 42</span></span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="comment">// 将 promise 与 future 绑定</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = p.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer, std::ref(p))</span></span>;</span><br><span class="line">    <span class="comment">// 分离执行线程</span></span><br><span class="line">    producer_thread.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="type">int</span> result = f.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>std::thread</code>用于表示一个执行线程，这个线程可以选择在主线程执行<code>join()</code>或者另一个线程中执行<code>detach()</code>。</p><p>若使用<code>join()</code>，则主线程会等待子线程执行完毕后再继续执行，若使用<code>detach()</code>，则主线程会直接执行，而子线程会在后台执行，两者不会相互影响。</p></blockquote><h2 id="二：一般概念">二：一般概念</h2><h3 id="可被调用的对象">可被调用的对象</h3><p>Callable Object，一种对象，可以通过某些方式调用其某些函数，它可以是</p><ul><li>函数</li><li>指向成员函数的指针</li><li>函数对象</li><li>lambda表达式</li></ul><h2 id="三：通用工具">三：通用工具</h2><h3 id="pair">pair</h3><p>本质是一个struct</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.first + p.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">42</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tuple">tuple</h3><p>大号pair，可以有多个值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t) + <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t) + <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能指针">智能指针</h3><p>智能指针智能在，它能知道自己是不是指向某物的最后一个指针</p><ul><li>shared_ptr：共享式拥有<ul><li>多个指针可以指向一个资源，通过引用计数法GC</li><li>为了解决引用计数法的缺点（比如循环引用），提供weak_ptr等辅助类</li></ul></li><li>unique_ptr：独占式拥有<ul><li>同一时间只能有一个unique_ptr指向某个资源，可以进行拥有权的移交</li></ul></li></ul><h3 id="极值">极值</h3><p>Numeric Limit</p><p>用于得到当前平台下，一些数值类型的长度（大小）</p><h3 id="Trait">Trait</h3><p>是一种技术方案，用来为同一类数据提供统一的操作函数，核心就是使用另外的模版类<code>type_traits</code>存储不同数据类型的<code>type</code>，这样就可以兼容各种数据类型</p><h3 id="外覆器">外覆器</h3><h4 id="Reference-Wrapper">Reference Wrapper</h4><p>允许函数模板可以操作引用，不需要写特化版本</p><p>具体有两个函数</p><ul><li>ref：隐式转化为<code>T&amp;</code></li><li>cref：隐式转化为<code>const T &amp;</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">fun</span>(std::<span class="built_in">ref</span>(x));<span class="comment">//此时T为int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">fun</span>(std::<span class="built_in">cref</span>(x));<span class="comment">//此时T为const int&amp;</span></span><br></pre></td></tr></table></figure><h4 id="Function-Type-Wrapper">Function Type Wrapper</h4><p>允许将可调用对象当作最高级对象（first-class object）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; tasks;<span class="comment">//一个存储多个可调用对象的vector</span></span><br><span class="line">tasks.<span class="built_in">push_back</span>(func);<span class="comment">//void func(int x, int y);</span></span><br><span class="line">tasks.<span class="built_in">push_back</span>([] (<span class="type">int</span> x, <span class="type">int</span> y) &#123;...&#125;);<span class="comment">//添加一个lambda表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(function&lt;<span class="built_in">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f : tasks)&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">36</span>, <span class="number">36</span>);<span class="comment">//遍历所有的可调用对象，并调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辅助函数">辅助函数</h3><ul><li>min</li><li>max</li><li>swap</li><li>operator<ul><li><code>==</code></li><li><code>!=</code></li><li><code>&gt;</code></li><li><code>&lt;</code></li><li><code>&gt;=</code></li><li><code>&lt;=</code></li></ul></li></ul><h3 id="编译期分数运算">编译期分数运算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ratio&lt;<span class="number">5</span>, <span class="number">5</span>&gt; one;</span><br><span class="line">cout &lt;&lt; one.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; one.den &lt;&lt; endl;<span class="comment">// 1/1</span></span><br><span class="line"></span><br><span class="line">ratio&lt;<span class="number">5</span>, <span class="number">3</span>&gt; two;</span><br><span class="line">cout &lt;&lt; two.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; two.den &lt;&lt; endl;<span class="comment">// 5/3</span></span><br></pre></td></tr></table></figure><h3 id="随机数">随机数</h3><p>引入了比rand更好的随机数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::random_device rd; <span class="comment">// 真随机数设备</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">// 伪随机数生成器</span></span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 1到100的均匀分布</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">dis</span>(gen) &lt;&lt; std::endl; <span class="comment">// 生成并打印随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随机分布</p><ul><li><code>std::uniform_int_distribution</code>：均匀分布</li><li><code>std::normal_distribution</code>：正态分布</li><li><code>std::poisson_distribution</code>：泊松分布</li></ul><h2 id="四：STL">四：STL</h2><p>STL是C++标准库的核心，是一个泛型（generic）程序库，由三部分组成</p><ul><li>容器（Container）</li><li>迭代器（Iterator）</li><li>算法（Algorithm）</li></ul><h3 id="有序容器">有序容器</h3><p>顺序与插入顺序有关，与元素值无关，常常通过array、linked list实现</p><ul><li>array</li><li>vector</li><li>deque</li><li>list</li><li>forward_list</li></ul><h3 id="关联式容器">关联式容器</h3><p>在内部进行排序的集合，位置取决于value，常常通过二叉树实现</p><ul><li>set</li><li>multiset（mult的意思是元素可以重复）</li><li>map</li><li>multimap（mult的意思是key可以重复）</li></ul><h3 id="无序容器">无序容器</h3><p>元素位置无关紧要，重要的是元素是否在容器内，常常通过哈希表实现</p><ul><li>unordered_set</li><li>unordered_multiset</li><li>unordered_map</li><li>unordered_multmap</li></ul><h4 id="让一个类可以作为unordered-map的key">让一个类可以作为unordered_map的key</h4><p>核心是特化<code>std</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> id, std::string name) : <span class="built_in">m_id</span>(id), <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hash</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(m_id) ^ std::<span class="built_in">hash</span>&lt;std::string&gt;()(m_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Student&amp; other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_id == other.m_id &amp;&amp; m_name == other.m_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_id;</span><br><span class="line">std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Student&amp; student)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> student.<span class="built_in">hash</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;Student, <span class="type">int</span>&gt; student_score_map;</span><br><span class="line"><span class="function">Student <span class="title">student1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">student2</span><span class="params">(<span class="number">2</span>, <span class="string">&quot;Bob&quot;</span>)</span></span>;</span><br><span class="line">student_score_map.<span class="built_in">emplace</span>(student1, <span class="number">100</span>);</span><br><span class="line">student_score_map.<span class="built_in">emplace</span>(student2, <span class="number">90</span>);</span><br></pre></td></tr></table></figure><h3 id="其他容器">其他容器</h3><ul><li>string</li><li>寻常的数组（一种type，而非class）</li></ul><h3 id="迭代器">迭代器</h3><p>迭代器是一个可以遍历STL容器全部、部分元素的对象</p><h4 id="操作">操作</h4><ul><li><code>*</code>：取元素</li><li><code>++</code>：迭代器前进至下一个元素<ul><li>注意，<code>++i</code>比<code>i++</code>效率高一点点，因为后者要创建临时对象</li></ul></li><li><code>==</code>、<code>!=</code>：判断两个迭代器是否指向同一个位置</li><li><code>=</code>：赋值</li></ul><h3 id="种类">种类</h3><table><thead><tr><th></th><th>R/W</th><th>读写次数</th><th>跳转</th><th>举例</th></tr></thead><tbody><tr><td>输入/输出迭代器</td><td>只读/只写</td><td>能且仅能读写一次</td><td>i++</td><td>istream_iterators、ostream_iterators</td></tr><tr><td>前向/双向迭代器</td><td>读写</td><td>能读写多次</td><td>i++</td><td>STL的set、map</td></tr><tr><td>随机访问迭代器</td><td>读写</td><td>能读写多次</td><td>i += n</td><td>vector、deque、string、array</td></tr></tbody></table><p>从上到下，迭代器能力越来越强（他们间有继承关系，前向 is a 输入）</p><h3 id="算法">算法</h3><p>大多为非成员函数，思想是泛型编程（而不是OOP）</p><h3 id="函数对象">函数对象</h3><p>一个行为像函数的对象，思想是泛型编程</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">X fo;</span><br><span class="line"><span class="built_in">fo</span>(arg1, arg2);<span class="comment">//等同于fo.operator()(arg1, arg2);</span></span><br></pre></td></tr></table></figure><ul><li>函数对象是一个带状态的函数</li><li>函数对象有自己的类型</li><li>函数对象速度通常比普通函数快（编译期间有更好的优化）</li></ul>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>profile工具</title>
      <link href="/graphics/profile%E5%B7%A5%E5%85%B7/"/>
      <url>/graphics/profile%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1>Profile工具</h1><p>工具手册</p><table><thead><tr><th>工具</th><th>优点</th><th>评价</th></tr></thead><tbody><tr><td>Unity profiler</td><td>用起来最简单，可以网络远程测试</td><td>功能不是很全</td></tr><tr><td>Xcode</td><td>功能全，而且使用简单</td><td>只能iOS，而且iOS打包很折磨</td></tr><tr><td>RenderDoc</td><td></td><td>安卓利器</td></tr><tr><td>snapdragon</td><td></td><td>只能用于高通骁龙soc，使用时注意有无adb</td></tr><tr><td>Nsight</td><td></td><td>贼难用（可能是Unity图形API的锅）</td></tr><tr><td>PIX</td><td></td><td>调试DX12也就这个好使</td></tr></tbody></table><h3 id="Xcode">Xcode</h3><h4 id="配置Xcode项目">配置Xcode项目</h4><p>Xcode想要截帧需要依赖Xcode源项目</p><ul><li><p>签名配置（略，这玩意贼恶心，尤其是别人的项目）</p></li><li><p>配置截帧</p><ul><li>Edit Scheme</li></ul></li></ul><p><img src="/images/EditScheme.png" class="lazyload" data-srcset="/images/EditScheme.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Edit Scheme"></p><ul><li>CaptureMetal</li></ul><p><img src="/images/CaptureMetal.png" class="lazyload" data-srcset="/images/CaptureMetal.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CaptureMetal"></p><ul><li>API Validation</li></ul><p><img src="/images/APIValidation.png" class="lazyload" data-srcset="/images/APIValidation.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="API Validation"></p><h4 id="截帧">截帧</h4><p><img src="/images/Metal%E6%88%AA%E5%B8%A7.png" class="lazyload" data-srcset="/images/Metal%E6%88%AA%E5%B8%A7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Metal截帧"></p><h4 id="截帧信息分析">截帧信息分析</h4><ul><li>GPU时间（首页就有）</li><li>带宽</li></ul><p><img src="/images/Xcode%E5%B8%A6%E5%AE%BD.png" class="lazyload" data-srcset="/images/Xcode%E5%B8%A6%E5%AE%BD.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Xcode带宽"></p><h4 id="截帧分享">截帧分享</h4><p>找到这个文件，分享给其他人</p><p><img src="/images/Xcode%E6%88%AA%E5%B8%A7%E5%88%86%E4%BA%AB.png" class="lazyload" data-srcset="/images/Xcode%E6%88%AA%E5%B8%A7%E5%88%86%E4%BA%AB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Xcode截帧分享"></p><h3 id="Nsight">Nsight</h3><h4 id="连接Unity-Editor">连接Unity Editor</h4><ul><li><p>以管理员身份打开</p></li><li><p>配置</p><ul><li><p>Application Executable：Unity.exe所在的绝对路径</p></li><li><p>Command Line Arguements：-projectPath ”项目根路径“</p><ul><li>项目根路径：文件夹内有Asset、Package的那个文件夹</li></ul></li></ul></li><li><p>启动</p><ul><li>点击Launch Frame Debugger</li><li>注意，请将Unity和Unity Hub都关掉</li></ul></li></ul><p><img src="/images/NSight_Unity.png" class="lazyload" data-srcset="/images/NSight_Unity.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="NSight_Unity"></p><h4 id="注意">注意</h4><p>Unity HDRP使用了<code>D3D11On12</code>，在使用NSight时会报Warm，暂时先别管</p><h3 id="Snapdragon">Snapdragon</h3><h4 id="连接安卓APP">连接安卓APP</h4><ul><li>Connect to a device<ul><li>如果找不到设备，检查有无adb命令，或者直接用adb连接</li></ul></li><li>Realtime看带宽<ul><li>从左下角Process中挑</li></ul></li><li>Trace Capture看GPU时间</li></ul><h3 id="RenderDoc">RenderDoc</h3><h4 id="连接安卓APP-2">连接安卓APP</h4><ul><li>手机连接电脑，电脑打开RenderDoc</li><li>Connect</li><li>打开Launch Application窗口<ul><li>Program——Executable Path——选择要截帧的APP</li></ul></li></ul><p><img src="/images/RenderDoc%E5%AE%89%E5%8D%93.jpg" class="lazyload" data-srcset="/images/RenderDoc%E5%AE%89%E5%8D%93.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RenderDoc安卓"></p><h4 id="连接Unity-Editor-2">连接Unity Editor</h4><ul><li>右键Scene，Load RenderDoc</li><li>按小相机截帧</li></ul><h3 id="PIX">PIX</h3><h4 id="权限配置">权限配置</h4><ul><li>开启Window开发者模式</li></ul><img src="/images/开发者模式.png" class="lazyload" data-srcset="/images/开发者模式.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="开发者模式" style="zoom: 80%;" /><ul><li>开启英伟达开发者模式（以管理员身法打开英伟达控制面板）<ul><li>注意，更换模式时，请注意关闭、保存Unity（和显卡相关的软件会崩掉）</li></ul></li></ul><p><img src="/images/%E8%8B%B1%E4%BC%9F%E8%BE%BE%E8%AE%BE%E7%BD%AE.png" class="lazyload" data-srcset="/images/%E8%8B%B1%E4%BC%9F%E8%BE%BE%E8%AE%BE%E7%BD%AE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="英伟达设置"></p><h4 id="连接Unity-Editor-3">连接Unity Editor</h4><ul><li><p>以管理员身份打开PIX</p></li><li><p>Attach Unity Editor（配置方式同NSight）</p></li></ul><p><img src="/images/PIX.jpg" class="lazyload" data-srcset="/images/PIX.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PIX"></p><ul><li>按GPU Capture截帧</li></ul>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake入门</title>
      <link href="/program/CMake%E5%85%A5%E9%97%A8/"/>
      <url>/program/CMake%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>CMake</h1><h2 id="快速入门">快速入门</h2><p>一个大项目（Project）内嵌多个子项目（SubProject）</p><p>一个子项目内有src、include、CMakeLists.txt，其中有一个子项目中有main.cpp</p><img src="/images/C++项目结构.png" class="lazyload" data-srcset="/images/C++项目结构.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="C++项目结构" style="zoom:50%;" /><p>最外面的CMakeLists.txt，负责连接所有子项目：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">Project</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(subProject1)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(subProject2)</span><br></pre></td></tr></table></figure><p>subProject1（main.cpp所在的子项目）下面的CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_executable</span>(subProject1 <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(subProject1 PUBLIC <span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(subProject1 PUBLIC subProject2)</span><br></pre></td></tr></table></figure><p>subProject2下面的CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_library</span>(subProject2 STATIC <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(subProject2 PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p>生成sln项目</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cmake</span> -G <span class="string">&quot;Visual Studio 16 2019&quot;</span></span><br></pre></td></tr></table></figure><p>用vs打开sln项目能看到2+n个项目，其中</p><ul><li><code>ALL_BUILD</code>：编译该项目会编译整个工程</li><li><code>ZERO_CHECK</code>：监视<code>CMakeLists.txt</code>的变化，一旦改变会告诉编译器重新构建工程</li></ul><p>或者可以用make构建项目</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cmake</span> -H. -Bbuild</span><br></pre></td></tr></table></figure><h2 id="一：CMake基础语法">一：CMake基础语法</h2><h3 id="CMakeLists-txt">CMakeLists.txt</h3><p>我们将CMake指令放在<code>CMakeLists.txt</code>文件中</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置CMake所需最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="comment">#设置项目名称为CMakeStudy，支持的语言为C++（CXX表示C++）</span></span><br><span class="line"><span class="keyword">project</span>(CMakeStudy LANGUAGES CXX)</span><br><span class="line"><span class="comment">#设置创建的新目标名称：一个名叫CMakeStudy的可执行文件</span></span><br><span class="line"><span class="comment">#这个可执行文件是通过编译和链接源文件main.cpp生成的</span></span><br><span class="line"><span class="keyword">add_executable</span>(CMakeStudy main.cpp)</span><br></pre></td></tr></table></figure><ul><li>CMake语言不区分大小写，但参数区分大小写</li><li>CMake的缺省默认语言为C++</li></ul><h3 id="构建">构建</h3><p>写好<code>CMakeLists.txt</code>文件后，在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">cmake -H. -Bbuild</span></span><br></pre></td></tr></table></figure><p>这个命令会搜索当前目录下的根<code>CMakeLists.txt</code>文件，创建一个<code>build</code>目录，在其中生成所有的代码</p><p>然后再build目录中输入命令，以完成编译</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">cmake --build .</span></span><br></pre></td></tr></table></figure><p>一般我们不会在源码内部构建，因为这会污染源码的目录树</p><h3 id="链接">链接</h3><p>如果项目中有多个文件，如</p><p><img src="/images/%E9%93%BE%E6%8E%A5.png" class="lazyload" data-srcset="/images/%E9%93%BE%E6%8E%A5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="链接"></p><p>可以改目标生成</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello main.cpp <span class="keyword">Message</span>.cpp <span class="keyword">Message</span>.h)</span><br></pre></td></tr></table></figure><p>但是这种改法太麻烦了，每添加一个文件就要在后面添一端，最后这东西会特别长</p><p>我们可以把这个类编译成一个（静态）库，然后再将库链接到可执行文件中（你还记得c++编译器的编译步骤吗？）</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(CMakeStudy LANGUAGES CXX)</span><br><span class="line"><span class="comment">#将两个文件编译成库</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span> STATIC <span class="keyword">Message</span>.h <span class="keyword">Message</span>.cpp)</span><br><span class="line"><span class="comment">#目标不变</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp)</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello <span class="keyword">message</span>)</span><br></pre></td></tr></table></figure><p>此外，我们能在buid目录中找到一个名为/形如<code>libmessage.a</code>的文件，这就是编译得到的静态库</p><h4 id="add-library">add_library</h4><p>生成一个名叫<code>message</code>的库</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span> STATIC <span class="keyword">Message</span>.h <span class="keyword">Message</span>.cpp)</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是目标名，后续可以使用该名来引用库</p></li><li><p>第二个参数是库的种类</p><ul><li>STATIC：静态库</li><li>SHARED：动态库</li><li>OBJECT：对象库（将代码编译到可执行文件内部的静态库）</li><li>MODULE：一种不会链接到项目中任何目标的动态共享对象（DSO），可以运行时动态加载</li></ul></li></ul><p>此外CMake还有一些不会出现在构建系统里的库</p><ul><li>IMPORTED：项目外部的库，用于对现有依赖项进行构建，认为是不可变的</li><li>INTERFACE：也是项目之外的库，但是可变</li><li>ALIAS：对已有的库做别名</li></ul><h4 id="条件语句">条件语句</h4><p>在讲链接时，我们给出了两种编译方法，我们希望能在两种方式间切换</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(CMakeStudy LANGUAGES CXX)</span><br><span class="line"><span class="comment">#引入一个新变量USE_LIBRARY，设置为OFF</span></span><br><span class="line"><span class="keyword">set</span>(USE_LIBRARY <span class="keyword">OFF</span>)</span><br><span class="line"><span class="comment">#打印信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Compile sources into a library? $&#123;USE_LIBRARY&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="comment">#引入一个list变量: _sources，包含两个文件</span></span><br><span class="line"><span class="keyword">list</span>(APPEND _sources <span class="keyword">Message</span>.h <span class="keyword">Message</span>.cpp)</span><br><span class="line"><span class="comment">#判断，若USE_LIBRARY为真，则编译成库</span></span><br><span class="line"><span class="keyword">if</span>(USE_LIBRARY)</span><br><span class="line">    <span class="keyword">add_library</span>(<span class="keyword">message</span> <span class="variable">$&#123;_sources&#125;</span>)</span><br><span class="line">    <span class="keyword">add_executable</span>(hello main.cpp)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(hello <span class="keyword">message</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">add_executable</span>(hello main.cpp <span class="variable">$&#123;_sources&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h4 id="逻辑变量">逻辑变量</h4><ul><li>true：<code>1</code>、<code>ON</code>、<code>YES</code>、<code>true</code>、<code>Y</code>、非零数</li><li>false：<code>0</code>、<code>OFF</code>、<code>NO</code>、<code>false</code>、<code>N</code>、<code>IGNORE</code>、<code>NOTFOUND</code>、空字符串、以<code>-NOTFOUND</code>为后缀</li></ul><h4 id="全局变量">全局变量</h4><p>CMake有一些全局变量，修改他们可以起到配置作用，这里设置的</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">OFF</span>)</span><br></pre></td></tr></table></figure><p>当设置为OFF时，可以使<code>add_library</code>不用传递第二个参数</p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>CMAKE_RUNTIME_OUTPUT_DIRECTORY</td><td>.exe、.dll文件的输出路径</td></tr><tr><td>CMAKE_ARCHIVE_OUTPUT_DIRECTORY</td><td>.a文件的输出路径</td></tr><tr><td>CMAKE_LIBRARY_OUTPUT_DIRECTORY</td><td>.so文件的输出路径</td></tr><tr><td>CMAKE_CURRENT_SOURCE_DIR</td><td>当前CMakeLists.txt所在路径</td></tr><tr><td>PROJECT_NAME</td><td>项目名字</td></tr><tr><td>CMAKE_MODULE_PATH</td><td>cmake模块所在路径</td></tr></tbody></table><h3 id="用户选项">用户选项</h3><p>在上面我们引入了一个条件语句，但是是硬编码的。我们希望用户可以控制<code>USE_LIBRARY</code>，于是可以使用<code>option</code></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#set(USE_LIBRARY OFF)</span></span><br><span class="line"><span class="keyword">option</span>(USE_LIBRARY <span class="string">&quot;Compile sources into a library&quot;</span> <span class="keyword">OFF</span>)</span><br></pre></td></tr></table></figure><p>将上面下面的<code>set</code>替换为<code>option</code>，运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">cmake -D USE_LIBRARY=ON</span></span><br></pre></td></tr></table></figure><p>如果是Clion可以配置</p><p><img src="/images/Clion-Option.png" class="lazyload" data-srcset="/images/Clion-Option.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Clion-Option"></p><h3 id="构建类型">构建类型</h3><table><thead><tr><th>类型</th><th>有无优化</th></tr></thead><tbody><tr><td>Debug</td><td>没有优化，带调试符号</td></tr><tr><td>Release</td><td>有优化，没有调试符号</td></tr><tr><td>RelWithDebInfo</td><td>有少量优化，带调试符号</td></tr><tr><td>MinSizeRel</td><td>不增加代码大小来优化</td></tr></tbody></table><h3 id="编译选项">编译选项</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(CMakeStudy LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(APPEND flags <span class="string">&quot;-fPIC&quot;</span> <span class="string">&quot;-Wall&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> WIN32)</span><br><span class="line">    <span class="keyword">list</span>(APPEND flags <span class="string">&quot;-Wextra&quot;</span> <span class="string">&quot;-Wpedantic&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment">#添加一个库</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span></span><br><span class="line">    STATIC</span><br><span class="line">        <span class="keyword">Message</span>.h</span><br><span class="line">        <span class="keyword">Message</span>.cpp</span><br><span class="line">)</span><br><span class="line"><span class="comment">#为库设置编译选项</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(<span class="keyword">message</span></span><br><span class="line">    PRIVATE</span><br><span class="line">        <span class="variable">$&#123;flags&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">#添加可执行目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp)</span><br><span class="line"><span class="comment">#为可执行目标设置编译选项</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(hello</span><br><span class="line">    PRIVATE</span><br><span class="line">        <span class="string">&quot;-fPIC&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello <span class="keyword">message</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>可见性</th><th>含义</th></tr></thead><tbody><tr><td>PRIVATE</td><td>编译选项仅对目标生效，不会传递（hello链接了message，但不会接受message的编译选项）</td></tr><tr><td>INTERFACE</td><td>编译选项对目标生效，并传递给相关目标</td></tr><tr><td>PUBLIC</td><td>编译选项对目标和使用它的目标生效</td></tr></tbody></table><p><code>-Wall</code>、<code>-Wextra</code>等是警告标志</p><blockquote><p>如果A模块链接了core模块，B模块链接了A模块，如果B模块想用core的头文件，A在链接core时需要是PUBLIC</p></blockquote><h4 id="MSVC">MSVC</h4><p>配置MSVC编译选项</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(my_executable PRIVATE /EHs-c-)  <span class="comment"># 禁用异常处理</span></span><br><span class="line">    <span class="keyword">target_compile_options</span>(my_executable PRIVATE /W4 /WX)  <span class="comment"># 设置警告级别为 4，并将警告视为错误</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h3 id="循环">循环</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(_source <span class="variable">$&#123;sources_with_lower_optimization&#125;</span>)</span><br><span class="line">  <span class="keyword">get_source_file_property</span>(_flags <span class="variable">$&#123;_source&#125;</span> COMPILE_FLAGS)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Source $&#123;_source&#125; has the following extra COMPILE_FLAGS: $&#123;_flags&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><h3 id="命令">命令</h3><p>cmake中可以添加一些自定义命令，常用于实现编译前文件拷贝操作，比如将第三方<code>.dll</code>文件复制到可执行文件到项目根路径</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span> </span><br><span class="line">                   POST_BUILD </span><br><span class="line">                   <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E </span><br><span class="line">                   copy “<span class="variable">$&#123;xxx.dll&#125;</span>” $&lt;TARGET_FILE_DIR:<span class="variable">$&#123;PROJECT_NAME&#125;</span>&gt;</span><br><span class="line">                   )</span><br></pre></td></tr></table></figure><p>命令执行时机：</p><ul><li><code>POST_BUILD</code>：生成目标文件后</li><li><code>PRE_BUILD</code>：编译前</li><li><code>PRE_LINK</code>：链接前</li></ul><p>执行的命令是Linux Command，比如<code>copy ${source} ${target}</code>，<code>echo ${output_string}</code></p><h3 id="搜索">搜索</h3><p>我们不可能将每一个文件都以单文件的形式写进<code>CMakeLists.txt</code>中，于是我们需要按照某种规则搜索所有的文件</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SRC_FILES_H <span class="string">&quot;$&#123;SOURCE_DIR&#125;/*.h&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SRC_FILES_CPP <span class="string">&quot;$&#123;SOURCE_DIR&#125;/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(ALL_FILES <span class="variable">$&#123;SRC_FILES_H&#125;</span> <span class="variable">$&#123;SRC_FILES_CPP&#125;</span>)</span><br></pre></td></tr></table></figure><p>排除SRC中部分文件</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(FILTER SRC EXCLUDE REGEX <span class="string">&quot;/ui/*&quot;</span>)</span><br><span class="line"><span class="keyword">list</span>(FILTER SRC EXCLUDE REGEX <span class="string">&quot;/core/+&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="二：环境检查">二：环境检查</h2><h3 id="检查平台">检查平台</h3><p>我们要处理如下的C++源码（hello-world.cpp）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IS_WINDOWS</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from Windows!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_LINUX</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from Linux!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_MACOS</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from macOS!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from an unknown system!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMake可以加入</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询操作系统</span></span><br><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line"><span class="comment">#设置宏</span></span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_LINUX&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Darwin&quot;</span>)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_MACOS&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_WINDOWS&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h3 id="检查编译器">检查编译器</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> Intel)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> GNU)</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="检查处理器架构">检查处理器架构</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_SIZEOF_VOID_P <span class="keyword">EQUAL</span> <span class="number">8</span>)</span><br><span class="line"><span class="comment">#64bits</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line"><span class="comment">#32bits</span></span><br><span class="line">endlf()</span><br></pre></td></tr></table></figure><h2 id="三：链接外部库">三：链接外部库</h2><h3 id="语法">语法</h3><h4 id="find-package">find_package</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找名为OpenCV的包，如果没找到就报错</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br></pre></td></tr></table></figure><p>该函数的本质就是去（先去标准路径）寻找一个<code>包名-config.cmake</code>文件</p><p>在mac，找OpenCV找的可能就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/cmake/OpenCV/OpenCVConfig.cmake</span><br></pre></td></tr></table></figure><p>如果你安装的位置不是标准路径，你可以</p><ul><li>在build时手动指定<code>-xxx_DIR=&quot;aaa/lib/cmake/xxx&quot;</code><ul><li>只有第一次指定，只要不删掉build目录，就不需要重新指定</li></ul></li><li>可以在CMakeLists.txt<strong>最开头</strong>写<code>set(xx_DIR &quot;aaa/lib/cmake/xxx&quot;)</code>、</li><li>可以给<code>xxx_DIR</code>设置环境变量</li></ul><h3 id="链接静态库">链接静态库</h3><ol><li>在项目根目录新建lib文件夹</li><li>将要链接的静态库（<code>test_library.a</code>）复制到lib文件夹中</li><li>找包</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_library</span>(TEXT_LIBRARY test_library lib)</span><br></pre></td></tr></table></figure><ol start="4"><li>链接</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(testapp LINK_PUBLIC &amp;&#123;TEST_LIBRARY&#125;)</span><br></pre></td></tr></table></figure><h3 id="链接动态库">链接动态库</h3><h3 id="常用库">常用库</h3><h4 id="Eigen">Eigen</h4><p>Eigen是一个纯头文件实现的线性代数库，在mac上可以使用brew安装</p><ol><li>安装（记住eigen的版本）</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">brew install eigen</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将Eigen链接到系统文件夹（brew一般会自动链接）</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">brew <span class="built_in">link</span> --overwrite eigen</span></span><br></pre></td></tr></table></figure><ol start="3"><li>链接</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#寻找Eigen包，并附带包版本</span></span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 <span class="number">3.4</span> REQUIRED CONFIG)</span><br><span class="line"><span class="comment">#若找到，则打印信息</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">TARGET</span> Eigen3::Eigen)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Eigen3 $&#123;EIGEN3_VERSION_STRING&#125; found in $&#123;EIGEN3_INCLUDE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"><span class="comment">#目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(path-info main.cpp)</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(path-info</span><br><span class="line">        PUBLIC</span><br><span class="line">        Eigen3::Eigen</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dim = std::<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    Eigen::MatrixXd A = Eigen::MatrixXd::<span class="built_in">Random</span>(dim, dim);</span><br><span class="line">    std::cout &lt;&lt; A;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="brew的用法">brew的用法</h3><p>这里提一嘴Homebrew，这是一个mac上非常好用的包管理器，可以非常“优雅”地安装软件</p><p>brew会把软件安装在<code>/usr/local/Cellar</code>目录</p><ul><li>安装目录软链接到<code>/usr/local/opt</code></li><li>bin目录执行文件链接到<code>/usr/local/bin</code>中（opt也有可能在根目录）</li></ul><p>常用命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew -v     <span class="comment"># 安装完成后可以查看版本</span></span><br><span class="line">$ brew --<span class="built_in">help</span> <span class="comment"># 简洁命令帮助</span></span><br><span class="line">$ man brew    <span class="comment"># 完整命令帮助</span></span><br><span class="line"></span><br><span class="line">$ brew search git    <span class="comment"># 搜索软件包</span></span><br><span class="line">$ brew info git      <span class="comment"># 查看软件包信息</span></span><br><span class="line">$ brew home git      <span class="comment"># 访问软件包官方站(用浏览器打开)</span></span><br><span class="line"></span><br><span class="line">$ brew install git   <span class="comment"># 安装软件包(这里是示例安装Git版本控制)</span></span><br><span class="line">$ brew uninstall git <span class="comment"># 卸载软件包</span></span><br><span class="line">$ brew list          <span class="comment"># 显示已经安装的所有软件包</span></span><br><span class="line">$ brew list --versions <span class="comment"># 查看你安装过的包列表（包括版本号）</span></span><br><span class="line"></span><br><span class="line">$ brew update        <span class="comment"># 同步远程最新更新情况，对本机已经安装并有更新的软件用*标明</span></span><br><span class="line">$ brew outdated      <span class="comment"># 查看已安装的哪些软件包需要更新</span></span><br><span class="line">$ brew upgrade git   <span class="comment"># 更新单个软件包</span></span><br><span class="line">$ brew deps php      <span class="comment"># 显示包依赖</span></span><br><span class="line"></span><br><span class="line">$ brew cleanup       <span class="comment"># 清理所有已安装软件包的历史老版本</span></span><br><span class="line">$ brew cleanup git   <span class="comment"># 清理单个已安装软件包的历史版本</span></span><br><span class="line">$ brew cleanup -n    <span class="comment"># 查看哪些软件包要被清除</span></span><br></pre></td></tr></table></figure><h3 id="拷贝动态库">拷贝动态库</h3><p>有时为了可拓展性和编译速度，我们会将一个项目切分为多个模块，这些模块编译为dll，然后拷贝到主程序（exe）所在的目录</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 OptickCore.dll拷贝到 client.exe所在路径</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> client POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different</span><br><span class="line">    $&lt;TARGET_FILE:OptickCore&gt;</span><br><span class="line">    $&lt;TARGET_FILE_DIR:client&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="四：项目">四：项目</h2><h3 id="模块">模块</h3><p>我们可以将一个大的CMake源码分成一个个模块，将这些模块放在<code>cmake</code>文件夹里，后缀为<code>.cmake</code></p><p>如下的项目结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmake</span><br><span class="line">│     └── colors.cmake</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><p><code>cmake/colors.cmake</code>文件内包含了一个色彩输出的定义</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">macro</span>(define_colors)</span><br><span class="line">  <span class="keyword">if</span>(WIN32)</span><br><span class="line">    <span class="comment"># has no effect on WIN32</span></span><br><span class="line">    <span class="keyword">set</span>(ColourReset <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(ColourBold <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Red <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Green <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Yellow <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Blue <span class="string">&quot;&quot;</span>)</span><br><span class="line">   ...</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">string</span>(ASCII <span class="number">27</span> Esc)</span><br><span class="line">    <span class="keyword">set</span>(ColourReset <span class="string">&quot;$&#123;Esc&#125;[m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(ColourBold <span class="string">&quot;$&#123;Esc&#125;[1m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Red <span class="string">&quot;$&#123;Esc&#125;[31m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Green <span class="string">&quot;$&#123;Esc&#125;[32m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Yellow <span class="string">&quot;$&#123;Esc&#125;[33m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Blue <span class="string">&quot;$&#123;Esc&#125;[34m&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure><p>在<code>CMakeLists.txt</code>引用</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将/cmake目录添加到路径列表</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"><span class="comment">#引入colors.cmake</span></span><br><span class="line"><span class="keyword">include</span>(colors)</span><br><span class="line"><span class="comment">#使用定义</span></span><br><span class="line">define_colors()</span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(函数名 参数<span class="number">1</span> 参数<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p><a href="https://www.jetbrains.com/help/clion/quick-cmake-tutorial.html?keymap=secondary_macos#seealso">Clion CMake</a></p><p><a href="https://www.bookstack.cn/read/CMake-Cookbook/content-preface-preface-chinese.md">CMake菜谱</a></p><p><a href="https://www.bilibili.com/video/BV1V84y117YU">小鹏老师</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WPF中的C#</title>
      <link href="/program/Csharpe/"/>
      <url>/program/Csharpe/</url>
      
        <content type="html"><![CDATA[<h1>WPF中的C#</h1><h2 id="C-语法">C#语法</h2><h3 id="字符串">字符串</h3><h4 id="字符串替换">字符串替换</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> raw = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> pre_str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> new_str = <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> pre_str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> ans = raw.Replace(pre_str, new_str);<span class="comment">// 匹配大小写</span></span><br><span class="line"><span class="built_in">string</span> ans2 = Regex.Replace(raw, pre_str, new_str, RegexOptions.IgnoreCase);<span class="comment">// 大小写无关</span></span><br></pre></td></tr></table></figure><h3 id="Console">Console</h3><p>Console可以设置输出的wei’zhi，在初始化等待时，在同一行反复输出等待的时间</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DateTime startTime = DateTime.Now;</span><br><span class="line">Init();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Init...&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(!InitSuccess())</span><br><span class="line">&#123;</span><br><span class="line">    TimeSpan elapsedTime = DateTime.Now - startTime;</span><br><span class="line">    Console.SetCursorPosition(<span class="number">0</span>, Console.CursorTop - <span class="number">1</span>);</span><br><span class="line">    Console.Write(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&#x27; &#x27;</span>, Console.WindowWidth));</span><br><span class="line">    Console.SetCursorPosition(<span class="number">0</span>, Console.CursorTop - <span class="number">1</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Waiting <span class="subst">&#123;elapsedTime.TotalSeconds&#125;</span> s&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容器">容器</h3><blockquote><p>C#容器和其他语言接近，这里只列出一些我感觉很有意思的写法</p></blockquote><h4 id="ConcurrentDictionary">ConcurrentDictionary</h4><p>线程安全地修改key所对应的List，若Key不存在，则新建一个</p><p>这是一种线程安全的哈希表，使用分段锁机制实现并发访问</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">object</span>&gt;&gt; instanceDictionary = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">object</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">string</span> key ,<span class="built_in">object</span> instance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instanceDictionary.AddOrUpdate(key, </span><br><span class="line">        k =&gt; <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt; &#123; instance &#125;, </span><br><span class="line">        (k, exitingList)=&gt; &#123; exitingList.Add(instance); <span class="keyword">return</span> exitingList; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcurrentBag">ConcurrentBag</h4><p>线程安全的集合类型，底层基于ConcurrentDictionary实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string[] files = ...;</span><br><span class="line">var bag = <span class="keyword">new</span> <span class="built_in">ConcurrentBag</span>&lt;CSVLine&gt;();</span><br><span class="line">Parallel.<span class="built_in">ForEach</span>(Partitioner.<span class="built_in">Create</span>(<span class="number">0</span>, files.Length), range =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = range.Item1; i &lt; range.Item2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bag.<span class="built_in">Add</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式">正则表达式</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> source = <span class="string">&quot;building.lod0.mesh&quot;</span></span><br><span class="line"><span class="built_in">string</span> pattern = <span class="string">@&quot;lod(\d).mesh&quot;</span>;</span><br><span class="line">Match match = Regex.Match(source, pattern);</span><br><span class="line"><span class="keyword">if</span>(match.Success)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> ans = match.Value;<span class="comment">// &quot;lod0.mesh&quot;</span></span><br><span class="line">    <span class="built_in">string</span> level = match.Groups[<span class="number">1</span>].Value;<span class="comment">// &quot;0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="委托">委托</h3><p>C#的委托类似于C++的函数指针，C#中，将参数<code>a,b</code>委托给了对象adder的Add方法，委托本质上是一种支持<code>()</code>运算符的<strong>对象</strong>。既然是对象，就可以有自己的成员和状态</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Adder</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> c = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Adder</span>(<span class="params"><span class="built_in">int</span> c</span>)</span>&#123; <span class="keyword">this</span>.c = c; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123; <span class="keyword">return</span> a+b+c; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Main()&#123;...</span></span><br><span class="line">Adder adder = <span class="keyword">new</span> Adder(<span class="number">1</span>);</span><br><span class="line">Fun f = adder.Add;</span><br><span class="line">f(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//return 6</span></span><br></pre></td></tr></table></figure><p>C#委托支持匿名委托和lambda表达式</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line"><span class="comment">//Main()&#123;...</span></span><br><span class="line">Fun f = <span class="built_in">delegate</span>(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">  cout &lt;&lt; a+b &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">Fun f2 = (<span class="built_in">int</span> a, <span class="built_in">int</span> b)=&gt;&#123;</span><br><span class="line">  cout &lt;&lt; a+b &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="C-的函数指针">C++的函数指针</h4><p>C/C++的函数指针是一个指向函数入口的指针，不具有对象的性质，只能指向非成员函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*Func)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    Func func = Add;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//cout 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果加上类型限制符，还是可以指向成员函数的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Multiple</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(Multiple::*Fm)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    Multiple multiple;</span><br><span class="line">    Fm f = &amp;Multiple::Mul;</span><br><span class="line">    std::cout &lt;&lt; (multiple.*f)(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想让C++对委托具有对象的性质，我们可以重载<code>()</code>操作符</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> c)&#123; <span class="keyword">this</span>-&gt;c = c; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="function">Adder <span class="title">adder</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">adder</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Action泛型委托">Action泛型委托</h4><p>C#一种无返回值的泛型委托</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;</span><br></pre></td></tr></table></figure><p>无参数<code>Action xxx = 函数</code></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Name</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> InstanceName&#123; <span class="keyword">private</span> <span class="keyword">set</span>; <span class="keyword">get</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Name</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    InstanceName = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayName</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;I&#x27;m <span class="subst">&#123;InstanceName&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Name testName = <span class="keyword">new</span> Name(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">  Action showName = testName.DisplayName;</span><br><span class="line">  showName();</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure><p>有参数<code>Action&lt;参数类型&gt; xxx = 函数</code></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Name</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> InstanceName&#123; <span class="keyword">private</span> <span class="keyword">set</span>; <span class="keyword">get</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Name</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    InstanceName = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayName</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;I&#x27;m <span class="subst">&#123;InstanceName&#125;</span>, <span class="subst">&#123;str&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Name testName = <span class="keyword">new</span> Name(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">  Action&lt;<span class="built_in">string</span>&gt; showName = testName.DisplayName;</span><br><span class="line">  showName(<span class="string">&quot;HHH&quot;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h4 id="Func泛型委托">Func泛型委托</h4><p>C#一种有返回值的泛型委托</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">out</span> <span class="title">TResult</span>&gt;()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Adder</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> c;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Adder</span>(<span class="params"><span class="built_in">int</span> c</span>)</span> &#123; <span class="keyword">this</span>.c = c; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Adder adder = <span class="keyword">new</span> Adder(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//第一个参数是返回值类型，后面的参数是输入参数类型</span></span><br><span class="line">  Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; method = adder.Add;</span><br><span class="line">  <span class="comment">//使用时不需要写返回值参数</span></span><br><span class="line">  Console.WriteLine(method(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件">事件</h3><p><em>这里的事件指CLR事件模型，详细内容见下文</em></p><p>委托：把工作委托给了某个函数，可以直接调用</p><p>事件：订阅者侦听发行者，发行者可以通过回调函数间接让订阅者干事（而且订阅者具体干什么，要看订阅者心情，发行者无权过问）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEventArgs</span>: <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Args</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">    <span class="keyword">get</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyEventArgs</span>(<span class="params"><span class="built_in">string</span> args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    Args = args;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件发行者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSource</span></span><br><span class="line">&#123;</span><br><span class="line">  MyEventArgs eventArgs;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EventSource</span>(<span class="params"><span class="built_in">string</span> args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    eventArgs = <span class="keyword">new</span> MyEventArgs(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">handlerEvent</span>(<span class="params">Object sender, MyEventArgs args</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">event</span> handlerEvent m_handler_event;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handler</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_handler_event?.Invoke(<span class="keyword">this</span>, eventArgs);</span><br><span class="line">    <span class="comment">//也可以写成 m_handler_event(this, eventArgs);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    EventSource source = <span class="keyword">new</span> EventSource(<span class="string">&quot;Event had been raised!&quot;</span>);</span><br><span class="line">    source.Name = <span class="string">&quot;Tim&quot;</span>;</span><br><span class="line">    source.m_handler_event += <span class="keyword">new</span> EventSource.handlerEvent(writeHello);</span><br><span class="line">    <span class="comment">//也可以写成 source.m_handler_event += writeHello;</span></span><br><span class="line">    source.Handler();<span class="comment">//输出：Hello Tim, Event had been raised!</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeHello</span>(<span class="params">Object sender, MyEventArgs args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    EventSource source = sender <span class="keyword">as</span> EventSource;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Hello <span class="subst">&#123;source.Name&#125;</span>, <span class="subst">&#123;args.Args&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初我很好奇，我们注册了一个处理函数，<code>source.m_handler_event += writeHello</code>，但是好像没看到怎么传参进去。</p><p>其实是因为C#的委托本质是一个支持<code>()</code>运算符的对象，所有处理函数形式上跟委托一致，参数是委托对象的成员变量</p><p>一个事件可以注册多个处理函数，于是事件也称为多重委托</p><h3 id="模式匹配">模式匹配</h3><p>一种更好的if else</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义形状基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义圆形类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Drawing a circle with radius <span class="subst">&#123;Radius&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义矩形类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Width &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Drawing a rectangle with width <span class="subst">&#123;Width&#125;</span> and height <span class="subst">&#123;Height&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Shape[] shapes =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Circle &#123; Radius = <span class="number">5.0</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> Rectangle &#123; Width = <span class="number">4.0</span>, Height = <span class="number">6.0</span> &#125;,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">// 添加一个 null 值来演示常量模式</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> shape <span class="keyword">in</span> shapes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 is 表达式进行模式匹配</span></span><br><span class="line">            <span class="keyword">if</span> (shape <span class="keyword">is</span> Circle circle)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Found a circle with radius <span class="subst">&#123;circle.Radius&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">is</span> Rectangle rectangle)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Found a rectangle with width <span class="subst">&#123;rectangle.Width&#125;</span> and height <span class="subst">&#123;rectangle.Height&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Found a null shape&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Unknown shape&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 switch 表达式进行模式匹配</span></span><br><span class="line">            <span class="built_in">string</span> description = shape <span class="keyword">switch</span></span><br><span class="line">            &#123;</span><br><span class="line">                Circle c =&gt; <span class="string">$&quot;A circle with radius <span class="subst">&#123;c.Radius&#125;</span>&quot;</span>,</span><br><span class="line">                Rectangle r =&gt; <span class="string">$&quot;A rectangle with width <span class="subst">&#123;r.Width&#125;</span> and height <span class="subst">&#123;r.Height&#125;</span>&quot;</span>,</span><br><span class="line">                <span class="literal">null</span> =&gt; <span class="string">&quot;A null shape&quot;</span>,</span><br><span class="line">                _ =&gt; <span class="string">&quot;An unknown shape&quot;</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(description);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WPF客户端">WPF客户端</h2><p>WPF客户端的入口是一个继承了<code>Application</code>的类，通常是<code>App.xaml</code>和<code>App.xaml.cs</code></p><h3 id="App-xaml">App.xaml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Application</span> <span class="attr">x:Class</span>=<span class="string">&quot;WpfApp1.App&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:x</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:local</span>=<span class="string">&quot;clr-namespace:WpfApp1&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">StartupUri</span>=<span class="string">&quot;MainWindow.xaml&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--定义全局的资源、样式、主题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若<code>App.xaml</code>中配置了<code>StartupUri=&quot;MainWindow.xaml&quot;</code>，程序开始时打开窗口<code>MainWindow.xaml</code></p><h3 id="App-xaml-cs">App.xaml.cs</h3><p><code>App.xaml.cs</code>内定义了一个类<code>App</code>，这个类继承自<code>Application</code></p><p>可以重载函数，以控制程序开始、结束时的行为</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WpfApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStartup</span>(<span class="params">StartupEventArgs e</span>)</span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params">ExitEventArgs e</span>)</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如<code>App.xaml</code>中不配置<code>StartupUri</code>，也可以在此手动创建窗口</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStartup</span>(<span class="params">StartupEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnStartup(e);</span><br><span class="line">        <span class="built_in">string</span>[] commandLineArgs = e.Args;</span><br><span class="line">        <span class="comment">// parser commandLineArgs</span></span><br><span class="line">        MainWindow mainWindow = <span class="keyword">new</span> MainWindow();</span><br><span class="line">        mainWindow.Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行WPF项目">运行WPF项目</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> exePath = <span class="string">&quot;WpfApp1.exe&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> arguments = <span class="string">&quot;/param1 value1 /param2 value2&quot;</span>;</span><br><span class="line">ProcessStartInfo startInfo = <span class="keyword">new</span> ProcessStartInfo</span><br><span class="line">&#123;</span><br><span class="line">    FileName = exePath,</span><br><span class="line">    Arguments = arguments,</span><br><span class="line">    UseShellExecute = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">Process.Start(startInfo);</span><br></pre></td></tr></table></figure><h2 id="Binding">Binding</h2><h3 id="逻辑层与UI层">逻辑层与UI层</h3><p>程序 = 数据 + 算法</p><p>三层结构：存储、逻辑、展示（UI）</p><p>逻辑层可以访问UI层的数据，但展示层不能访问逻辑层，UI层能显示信息，靠的是绑定逻辑层数据</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.textBoxName.SetBinding(TextBox.TextProperty, <span class="keyword">new</span> Binding(<span class="string">&quot;Name&quot;</span>) &#123; Source = stu = <span class="keyword">new</span> Student() &#125;);</span><br></pre></td></tr></table></figure><p>UI层不仅可以绑定逻辑层数据，也可以绑定UI层数据</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为 Text属性设置 Binding为 slider1的...</span></span><br><span class="line">&lt;TextBox x:Name=<span class="string">&quot;textBox2&quot;</span> Text=<span class="string">&quot;&#123;Binding Value, ElementName=slider1&#125;&quot;</span> BorderBrush=<span class="string">&quot;Black&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>在XAML中加入</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">xmlns:local=<span class="string">&quot;clr-namespace:BindingStudy&quot;</span></span><br></pre></td></tr></table></figure><p>即可在XAML中使用BindingStudy命名空间里C#定义的类</p><h3 id="绑定的实现">绑定的实现</h3><p>绑定实现的机制：源对象的属性（Property）发生改变时，会Invoke一个事件，Binding负责侦听这个事件</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">INotifyPropertyChanged</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.PropertyChanged != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.PropertyChanged.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Path">Path</h3><p>源对象往往会有多个属性，我们可以使用Path，设置绑定那些属性，而且Path支持多级路径（简单说就是一直点下去）和索引器（Indexer）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;TextBox x:Name=<span class="string">&quot;textBoxName&quot;</span> BorderBrush=<span class="string">&quot;Black&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br><span class="line">&lt;TextBox x:Name=<span class="string">&quot;textBox1&quot;</span> Text=<span class="string">&quot;&#123;Binding Path=Text.Length, ElementName=textBoxName, Mode=OneWay&#125;&quot;</span> BorderBrush=<span class="string">&quot;Black&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;          </span><br><span class="line">&lt;TextBox x:Name=<span class="string">&quot;textBox2&quot;</span> Text=<span class="string">&quot;&#123;Binding Path=Text.[3], ElementName=textBoxName, Mode=OneWay&#125;&quot;</span> BorderBrush=<span class="string">&quot;Black&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/Path.png" class="lazyload" data-srcset="/images/Path.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Path"></p><p>此外Path也支持多级斜线（也是可以一直斜线下去，其中&quot;/&quot;就是自身）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.textBoxName.SetBinding(TextBox.TextProperty, <span class="keyword">new</span> Binding(<span class="string">&quot;/Length&quot;</span>) &#123; Source = stringList &#125;);</span><br></pre></td></tr></table></figure><p>当源数据本身就是数据（比如int、string类型），我们可以不写Path，或者将Path省略为&quot;.&quot;</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.textBlock1.SetBinding(TextBlock.TextProperty, <span class="keyword">new</span> Binding(<span class="string">&quot;.&quot;</span>) &#123; Source = str &#125;);</span><br></pre></td></tr></table></figure><h3 id="集合">集合</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">StackPanel</span> <span class="attr">x:Name</span>=<span class="string">&quot;stackPanel&quot;</span> <span class="attr">Background</span>=<span class="string">&quot;LightBlue&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;Student ID:&quot;</span> <span class="attr">FontWeight</span>=<span class="string">&quot;Bold&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBox</span> <span class="attr">x:Name</span>=<span class="string">&quot;textBoxId&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;Student List:&quot;</span> <span class="attr">FontWeight</span>=<span class="string">&quot;Bold&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListBox</span> <span class="attr">x:Name</span>=<span class="string">&quot;listBoxStudents&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;110&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ListBox.ItemTemplate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">StackPanel</span> <span class="attr">Orientation</span>=<span class="string">&quot;Horizontal&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Path=Id&#125;&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Path=Name&#125;&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;60&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Path=Age&#125;&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ListBox.ItemTemplate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ListBox</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">public MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    List<span class="tag">&lt;<span class="name">Student</span>&gt;</span> stuList = new List<span class="tag">&lt;<span class="name">Student</span>&gt;</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        new Student()&#123;Id=0, Name=&quot;赵&quot;, Age=21&#125;,</span><br><span class="line">        new Student()&#123;Id=1, Name=&quot;钱&quot;, Age=22&#125;,</span><br><span class="line">        new Student()&#123;Id=2, Name=&quot;孙&quot;, Age=11&#125;,</span><br><span class="line">        new Student()&#123;Id=3, Name=&quot;李&quot;, Age=50&#125;,</span><br><span class="line">        new Student()&#123;Id=4, Name=&quot;周&quot;, Age=44&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    this.listBoxStudents.ItemsSource = stuList;</span><br><span class="line">    //this.listBoxStudents.DisplayMemberPath = &quot;Name&quot;;</span><br><span class="line"></span><br><span class="line">    Binding binding = new Binding(&quot;SelectedItem.Id&quot;) &#123; Source = this.listBoxStudents &#125;;</span><br><span class="line">    this.textBoxId.SetBinding(TextBox.TextProperty, binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E9%9B%86%E5%90%88.png" class="lazyload" data-srcset="/images/%E9%9B%86%E5%90%88.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="集合"></p><h3 id="XML">XML</h3><p>SOAP（Simple Object Access Protocel，简单对象访问协议）：一种基于XML的数据交换协议</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">StudentList</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Name</span>&gt;</span>赵<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Name</span>&gt;</span>钱<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Name</span>&gt;</span>孙<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Name</span>&gt;</span>李<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Name</span>&gt;</span>周<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">StudentList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ListView</span> <span class="attr">x:Name</span>=<span class="string">&quot;listViewStudents&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;130&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView.View</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">GridView</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">GridViewColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Id&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;80&quot;</span> <span class="attr">DisplayMemberBinding</span>=<span class="string">&quot;&#123;Binding XPath=@Id&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">GridViewColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Name&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;120&quot;</span> <span class="attr">DisplayMemberBinding</span>=<span class="string">&quot;&#123;Binding XPath=Name&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">GridView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ListView.View</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">Content</span>=<span class="string">&quot;Load Click&quot;</span> <span class="attr">Click</span>=<span class="string">&quot;Button_Click&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;25&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5,0&quot;</span>/&gt;</span></span><br><span class="line"> private void Button_Click(object sender, RoutedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    XmlDataProvider xdp = new XmlDataProvider();</span><br><span class="line">    xdp.Source = new Uri(@&quot;D:\code\BindingStudy\BindingStudy\RawData.xml&quot;);</span><br><span class="line">    xdp.XPath = @&quot;/StudentList/Student&quot;;</span><br><span class="line"></span><br><span class="line">    this.listViewStudents.DataContext = xdp;</span><br><span class="line">    this.listViewStudents.SetBinding(ListView.ItemsSourceProperty, new Binding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/xml.png" class="lazyload" data-srcset="/images/xml.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="xml"></p><h3 id="LINQ">LINQ</h3><p>LINQ（Language-Integrated Query，语言集成查询）：一种对象查询机制，查询的结果为IEnumerable<T>类型</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">StudentList</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Class</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;0&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Tim&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;29&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Tom&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Mess&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;9&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Class</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Tony&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;4&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Viv&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Student</span> <span class="attr">Id</span>=<span class="string">&quot;5&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Oio&quot;</span> <span class="attr">Age</span>=<span class="string">&quot;88&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">StudentList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ListView</span> <span class="attr">x:Name</span>=<span class="string">&quot;listViewStudents&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;130&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView.View</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">GridView</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">GridViewColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Id&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;80&quot;</span> <span class="attr">DisplayMemberBinding</span>=<span class="string">&quot;&#123;Binding Id&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">GridViewColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Name&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;120&quot;</span> <span class="attr">DisplayMemberBinding</span>=<span class="string">&quot;&#123;Binding Name&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">GridViewColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Age&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;80&quot;</span> <span class="attr">DisplayMemberBinding</span>=<span class="string">&quot;&#123;Binding Age&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">GridView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ListView.View</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></span><br><span class="line">private void Button_Click(object sender, RoutedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    XDocument doc = XDocument.Load(@&quot;D:\code\BindingStudy\BindingStudy\RawData.xml&quot;);</span><br><span class="line">    this.listViewStudents.ItemsSource =</span><br><span class="line">        from element in doc.Descendants(&quot;Student&quot;)</span><br><span class="line">        where element.Attribute(&quot;Name&quot;).Value.StartsWith(&quot;T&quot;)</span><br><span class="line">        select new Student()</span><br><span class="line">        &#123;</span><br><span class="line">            Id = int.Parse(element.Attribute(&quot;Id&quot;).Value),</span><br><span class="line">            Name = element.Attribute(&quot;Name&quot;).Value,</span><br><span class="line">            Age = int.Parse(element.Attribute(&quot;Age&quot;).Value)</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public int Age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/LINQ.png" class="lazyload" data-srcset="/images/LINQ.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="LINQ"></p><h3 id="校验">校验</h3><p>“你永远不能相信来自前端的数据”</p><p>我们认为Source的数据一定是正确的，但Target的数据是有可能出现问题的</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        Binding binding = <span class="keyword">new</span> Binding(<span class="string">&quot;Value&quot;</span>) &#123; Source = <span class="keyword">this</span>.slider1 &#125;;</span><br><span class="line">        binding.UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged;    <span class="comment">//当源数据改变时进行校验</span></span><br><span class="line">        RangeValidationRule rvr = <span class="keyword">new</span> RangeValidationRule();</span><br><span class="line">        rvr.ValidatesOnTargetUpdated = <span class="literal">true</span>;    <span class="comment">//当Target数据改变时进行校验</span></span><br><span class="line">        binding.ValidationRules.Add(rvr);</span><br><span class="line">        binding.NotifyOnValidationError = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.textBox1.SetBinding(TextBox.TextProperty, binding);</span><br><span class="line">        <span class="keyword">this</span>.textBox1.AddHandler(Validation.ErrorEvent, <span class="keyword">new</span> RoutedEventHandler(<span class="keyword">this</span>.ValidationError));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若校验失败，将失败信息添加到 ToolTip上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ValidationError</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Validation.GetErrors(<span class="keyword">this</span>.textBox1).Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.textBox1.ToolTip = Validation.GetErrors(<span class="keyword">this</span>.textBox1)[<span class="number">0</span>].ErrorContent.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.textBox1.ToolTip = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;StackPanel x:Name=<span class="string">&quot;stackPanel&quot;</span> Background=<span class="string">&quot;LightBlue&quot;</span>&gt;</span><br><span class="line">    &lt;TextBox x:Name=<span class="string">&quot;textBox1&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br><span class="line">    &lt;Slider x:Name=<span class="string">&quot;slider1&quot;</span> Minimum=<span class="string">&quot;-10&quot;</span> Maximum=<span class="string">&quot;110&quot;</span> Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">RangeValidationRule</span> : <span class="title">ValidationRule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对数据范围进行校验，仅当在[0,100]时校验通过，校验失败时返回信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ValidationResult <span class="title">Validate</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, CultureInfo cultureInfo</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">double</span>.TryParse(<span class="keyword">value</span>.ToString(), <span class="keyword">out</span> d))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d &gt;= <span class="number">0</span> &amp;&amp; d &lt;= <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ValidationResult(<span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValidationResult(<span class="literal">false</span>, <span class="string">&quot;Validation Failed!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%A0%A1%E9%AA%8C.png" class="lazyload" data-srcset="/images/%E6%A0%A1%E9%AA%8C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="校验"></p><h3 id="数据转换">数据转换</h3><p>Slider的Value是double类型，TextBox的Text是string类型，但是Binding后数据往来自如，是因为数据转化机制</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ClassAToClassBConverter</span> : <span class="title">IValueConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Convert</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">ConvertBack</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;Window x:Class=<span class="string">&quot;BindingStudy.MainWindow&quot;</span></span><br><span class="line">        ...</span><br><span class="line">    &lt;Window.Resources&gt;</span><br><span class="line">        &lt;local:ClassAToClassBConverter x:Key=<span class="string">&quot;atb&quot;</span>/&gt;</span><br><span class="line">    &lt;/Window.Resources&gt;</span><br><span class="line">    &lt;StackPanel x:Name=<span class="string">&quot;stackPanel&quot;</span> Background=<span class="string">&quot;LightBlue&quot;</span>&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;../../images Width=<span class="string">&quot;20&quot;</span> Height=<span class="string">&quot;20&quot;</span> Source=<span class="string">&quot;&#123;Binding Path=A, Converter=&#123;StaticResource atb&#125;&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/StackPanel&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><h2 id="属性">属性</h2><h3 id="英语中的属性">英语中的属性</h3><p>Property是物体自带的属性</p><p>Attribute是物体的描述属性</p><p>张三是中国人，身上有一百块钱。中国人是张三的Attribute, 100块钱是张三的property</p><h3 id="C-中的属性">C#中的属性</h3><p>将字段设为private，使用一对非private的方法来包装它，以实现<strong>高内聚</strong></p><p>C#中提供语法糖，将Get和Set合并为了属性（Property），这种属性也被称为CLR（Common Language Runtime）属性</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外反编译后发现，属性的本质是两个函数，并不会增加字段数量（不额外占内存）</p><h3 id="依赖属性">依赖属性</h3><p>（WPF属性加强版）</p><p>依赖属性（Dependency Property）可以自己没有值，通过Binding从数据源获得值</p><p>拥有依赖属性的对象被称为依赖对象</p><p>传统开发中，对象所占用的内存在进行实例化时就确定（分配）了，而依赖属性可以允许对象不分配部分空间</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//依赖对象的 CLR封装</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="built_in">string</span>)GetValue(NameProperty); &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; SetValue(NameProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//依赖对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty NameProperty = DependencyProperty.Register(<span class="string">&quot;Name&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Student));  </span><br><span class="line">    <span class="comment">//Binding封装</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BindingExpressionBase <span class="title">SetBinding</span>(<span class="params">DependencyProperty dp, BindingBase binding</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingOperations.SetBinding(<span class="keyword">this</span>, dp, binding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>“Name”：指明使用哪一个 CLR属性作为这个依赖属性的包装器 (Wrapper)</li><li>typeof(string)：指明此依赖属性用来储存什么类型的值</li><li>typeof(Student))：指明此依赖属性要注册关联到谁身上</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">StackPanel</span> <span class="attr">x:Name</span>=<span class="string">&quot;stackPanel&quot;</span> <span class="attr">Background</span>=<span class="string">&quot;LightBlue&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBox</span> <span class="attr">x:Name</span>=<span class="string">&quot;textBox1&quot;</span> <span class="attr">BorderBrush</span>=<span class="string">&quot;Black&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBox</span> <span class="attr">x:Name</span>=<span class="string">&quot;textBox2&quot;</span> <span class="attr">BorderBrush</span>=<span class="string">&quot;Black&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">public partial class MainWindow : Window</span><br><span class="line">&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    public MainWindow()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        stu = new Student();</span><br><span class="line">        stu.SetBinding(Student.NameProperty, new Binding(&quot;Text&quot;) &#123; Source = textBox1 &#125;);</span><br><span class="line">        textBox2.SetBinding(TextBox.TextProperty, new Binding(&quot;Name&quot;) &#123; Source = stu &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还发现，依赖对象并没有实现INotifyPropertyChanged接口，但是当期值发生改变时，与之相关的Binding对象依然可以得到通知，于是依赖对象是天生的合格源数据</p><p>在VS中，输入propdp并按两次tab，就能得到一个依赖属性模板</p><h4 id="依赖属性的注册">依赖属性的注册</h4><p>前文我们获得依赖对象的实例时，是通过<code>DependencyProperty.Register</code>注册得到：</p><ol><li>创建DependencyProperty实例，并使用其CLR属性名的哈希异或宿主类型的哈希，得到key（通过其他算法，保证唯一）</li><li>将key和实例存储到一张全局的HashTable上</li></ol><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GlobalIndex = CLR属性名的HaseCode XOR 宿主类型HashCode</span><br></pre></td></tr></table></figure><p>于是运行时只要知道CLR属性名和宿主，就能找到依赖对象实例</p><h4 id="依赖属性的读写">依赖属性的读写</h4><p>依赖属性对象的作用是检索真正的属性值，而非存储属性值</p><p>每个DependencyObject实例都自带一个数组，当某个依赖属性的值要被读取时，算法会在这个数组中检索。而用于检索的键值，实际上就是依赖属性的GlobalIndex</p><p>也就是说，这个被static readonly修饰的属性，它的作用是一个“标记”，当你需要找某个东西时，就来这里拼一个id，用id查数组</p><h3 id="附加属性">附加属性</h3><p>附加属性（Attached Properties）：一个属性本不属于某个对象，但由于某种需求后来附加上。换句话说，将对象放入一个特定环境后，才会具有出来的属性</p><p>举个例子，比如Human这个类，它可以有很多很多种属性，现在我们想在里面加入一个新的需求，如果我们直接改动这个类，过于繁琐。而如果提前留好空，那么有时候又会空间浪费</p><p>附加属性的作用就是让宿主和属性解耦，让宿主的设计更为灵活</p><h2 id="事件-2">事件</h2><h3 id="消息">消息</h3><p>事件的前身是消息（Message），Windows系统就是一个消息驱动的操作系统，后来微软为了降低开发难度，将消息系统封装为了事件模型</p><h3 id="CLR事件模型">CLR事件模型</h3><p>CLR事件模型由三部分组成</p><ul><li>事件的拥有者：即消息的发送者</li><li>事件的响应者：即消息的接收者，它可以使用事件处理器（Event Handler）对事件做相应</li><li>事件的订阅关系：事件的拥有者可以随时激发事件，但只有关注（订阅）了这个事件的响应者会对此产生反应</li></ul><p>事件本质上就是一个使用event关键字修饰的委托（Delegate）类型成员变量，事件处理器是一个函数</p><p>A订阅了B，实际上就是让B.Event和A.EventHandler关联起来</p><p>事件激发就是B.Event被调用</p><h4 id="举例">举例</h4><p>Windows Form按按钮</p><table><thead><tr><th>事件的拥有者</th><th>button</th></tr></thead><tbody><tr><td>事件</td><td>button.Click</td></tr><tr><td>事件的响应者</td><td>窗体</td></tr><tr><td>事件处理器</td><td>this.button_Click()</td></tr><tr><td>订阅关系</td><td>this.button.Click += new System.EventHandler(this.button_Click)</td></tr></tbody></table><h3 id="路由事件">路由事件</h3><p>（WPF事件加强版）</p><p>路由事件没有显示订阅关系</p><ul><li>事件拥有者只负责激发事件，至于谁会倾听，他并不知道</li><li>事件响应者装有事件倾听器，若有事件传递于此，可以决定事件是否可以继续传递<ul><li>如果事件不归他管，那就踢给下一个人，继续传播</li><li>若事件归他管，那就进行处理，并判断是否还需要传给下一个人</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ButtonBase</span> : <span class="title">ContentControl</span>, <span class="title">ICommandSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明并注册路由事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> RoutedEvent ClickEvent = EventManager.RegisterRoutedEvent(<span class="string">&quot;Click&quot;</span>, </span><br><span class="line">        RoutingStrategy.Bubble, <span class="keyword">typeof</span>(RoutedEventHandler), <span class="keyword">typeof</span>(ButtonBase));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为路由事件添加 CLR事件包装器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> RoutedEventHandler Click</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">add</span> &#123; <span class="keyword">this</span>.AddHandler(ClickEvent, <span class="keyword">value</span>); &#125;</span><br><span class="line">        <span class="keyword">remove</span> &#123; <span class="keyword">this</span>.RemoveHandler(ClickEvent, <span class="keyword">value</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//激活路由事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        RoutedEventArgs newEvent = <span class="keyword">new</span> RoutedEventArgs(ButtonBase.ClickEvent, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.RaiseEvent(newEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WPF路由事件有三种策略</p><ul><li>Bubble：冒泡式，激发者向其上级一层一层路由，直到到根，路径是确定且唯一</li><li>Tunnel：隧道式，激发者向其下级一层一层路由，路径有很多，但朝向响应者移动，就像形成一个隧道</li><li>Direct：直达式，类似CLR事件，直接向响应者发送事件</li></ul><h2 id="命令">命令</h2><p>事件不具有约束力，事件接收者使用自己的行为响应事件</p><p>命令具有约束力，当命令到达某个组件时，会主动调用组件的某个方法</p><h3 id="命令系统">命令系统</h3><ul><li>命令（Command）：实现ICommand接口</li><li>命令源（Command Source）：实现ICommandSource接口</li><li>命令目标（Command Target）：实现IInputElement接口</li><li>命令关联（Command Binding）</li></ul><h2 id="其他功能">其他功能</h2><h3 id="获取当前应用程序域的基础目录">获取当前应用程序域的基础目录</h3><blockquote><p>获得.exe文件所在的文件夹目录</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> path = System.AppDomain.CurrentDomain.BaseDirectory；</span><br></pre></td></tr></table></figure><h3 id="动态加载程序集">动态加载程序集</h3><blockquote><p>加载一个C# DLL文件，然后就可以使用反射来调用API</p></blockquote><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个库项目，将被构建为 MathUtils.DLL</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MathUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MathUtils</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载DLL</span></span><br><span class="line"><span class="built_in">string</span> dllPath = <span class="string">&quot;MathUtils.dll&quot;</span>;</span><br><span class="line"><span class="built_in">byte</span>[] buffer = File.ReadAllBytes(dllPath);</span><br><span class="line">Assembly assembly = Assembly.Load(buffer);</span><br><span class="line"><span class="comment">// 获得类型</span></span><br><span class="line">Type mathType = assembly.GetType(<span class="string">&quot;MathUtils.MathUtils&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(mathType != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得方法</span></span><br><span class="line">    MethodInfo method = mathType.GetMethod(<span class="string">&quot;Add&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (method != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行函数</span></span><br><span class="line">        <span class="built_in">object</span>[] parameters = <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="built_in">object</span> result = method.Invoke(<span class="literal">null</span>, parameters);</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Activator">Activator</h3><p>这是一个动态创建对象实例的类型，可以实现泛型</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FirstName = firstName;</span><br><span class="line">        LastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;FirstName&#125;</span> <span class="subst">&#123;LastName&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于 Activator的泛型工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">CreateInstance</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">object</span>[] constructorArgs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 Activator.CreateInstance 创建泛型类型的实例</span></span><br><span class="line">            <span class="keyword">return</span> (T)Activator.CreateInstance(<span class="keyword">typeof</span>(T), constructorArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Failed to create instance: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">default</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用样例</span></span><br><span class="line">ObjectFactory&lt;Person&gt; personFactory = <span class="keyword">new</span> ObjectFactory&lt;Person&gt;();</span><br><span class="line">Person person = personFactory.CreateInstance(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line">person.DisplayInfo();</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的时，C#的泛型类型也是在编译期确定的（与C++相同），这样可以提供编译检查等功能</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pro-TBB</title>
      <link href="/program/Pro-TBB/"/>
      <url>/program/Pro-TBB/</url>
      
        <content type="html"><![CDATA[<h1>Pro TBB</h1><p>在摩尔定律逐渐失效的今日，CPU主频和单核性能提升越来越不明显，为了得到跟高的性能，我们走向了并行计算的道路</p><h2 id="概念">概念</h2><h3 id="并发和并行">并发和并行</h3><ul><li><p>并发（Concurrent）：happening during the same time span，处理器在两件事间快速切换，宏观上看，就像是同时发生的（下图AB）</p></li><li><p>并行（Parallel）：happening at the same time，多个处理器一起做事（下图CD）</p></li></ul><p><img src="Image/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C.png" class="lazyload" data-srcset="Image/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="并发和并行"></p><h2 id="TBB基础">TBB基础</h2><p>TBB（Threading Building Blocks）是一个非常流行的C++并行编程（parallel programming）方案</p><ul><li><p>使用Task而非Thread</p><ul><li>Thread与硬件相关，直接编写难以跨平台，而且线程间通信过于频繁，过于繁琐</li><li>TBB使用Task编程，运行时会将程序映射到硬件上（该方法对嵌套并行的支持很不错）</li><li>TBB任务调度使用<strong>工作窃取</strong>，当一个任务队列执行完毕后，核心会去其他任务队列中窃取任务，于是可以提高核心的利用率</li></ul></li><li><p>TBB实现了可组合性（Composability）</p><ul><li>简单来说就是支持for循环</li></ul></li><li><p>方便移植（portable）</p></li></ul><h3 id="Mac上安装使用TBB">Mac上安装使用TBB</h3><ol><li>安装tbb</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$brew</span> install tbb</span><br></pre></td></tr></table></figure><ol start="2"><li>链接tbb</li></ol><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#寻找tbb包</span></span><br><span class="line"><span class="keyword">find_package</span>(TBB REQUIRED)</span><br><span class="line">...</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(TimeStudy TBB::tbb)</span><br></pre></td></tr></table></figure><ol start="3"><li>引用头文件</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="在Ubuntu上安装TBB">在Ubuntu上安装TBB</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> apt-get install libtbb-dev</span><br></pre></td></tr></table></figure><h3 id="调用函数">调用函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func0, [...,] <span class="keyword">typename</span> FuncN&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_invoke</span><span class="params">(<span class="type">const</span> Func0&amp; f0, [...,] <span class="type">const</span> FuncN&amp; fN)</span></span>;</span><br></pre></td></tr></table></figure><p>一个简单的TBB示例，并行输出两行字符串</p><p>通过<code>tbb::parallel_invoke</code>实现任务、函数粒度的并行</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_invoke</span>(</span><br><span class="line">            []()&#123;std::cout &lt;&lt; <span class="string">&quot;TBB!&quot;</span> &lt;&lt; std::endl;&#125;,</span><br><span class="line">            []()&#123;std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里使用lambda表达式创建了匿名（anonymous）函数，可以大幅简化TBB编写</p><h4 id="快排示例">快排示例</h4><p>传统快排算法（升序）</p><ol><li>在数列中取一个数作为基准数</li><li>比基准小的放在基准左边，大的放在右边</li><li>对左右两边分别快排，直到只剩一个数（左右重合）</li></ol><p>能看出，这个算法采用了分治的思想，很适合并行</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> QV = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="comment">//传统快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(QV::iterator left, QV::iterator right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="type">int</span> pivot_value = *left;</span><br><span class="line">    QV::iterator i = left, j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i != j &amp;&amp; pivot_value &lt; *j) --j;    <span class="comment">//从右向左找，直到找到一个比基准小的</span></span><br><span class="line">        <span class="keyword">while</span>(i != j &amp;&amp; pivot_value &gt;= *i) ++i;   <span class="comment">//从左往右找，直到找到一个比基准大的</span></span><br><span class="line">        std::<span class="built_in">iter_swap</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">iter_swap</span>(left, i);</span><br><span class="line">    <span class="built_in">quickSort</span>(left, i);</span><br><span class="line">    <span class="built_in">quickSort</span>(j+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并行快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallelQuicksort</span><span class="params">(QV::iterator left, QV::iterator right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="type">int</span> pivot_value =  *left;</span><br><span class="line">    QV::iterator i = left, j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i != j &amp;&amp; pivot_value &lt; *j) --j;</span><br><span class="line">        <span class="keyword">while</span> (i != j &amp;&amp; pivot_value &gt;= *i) ++i;</span><br><span class="line">        std::<span class="built_in">iter_swap</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">iter_swap</span>(left, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call</span></span><br><span class="line">    tbb::<span class="built_in">parallel_invoke</span>(</span><br><span class="line">      <span class="comment">//lambda表达式[=]表示传入当前函数所有的成员</span></span><br><span class="line">            [=]() &#123; <span class="built_in">parallelQuicksort</span>(left, i); &#125;,</span><br><span class="line">            [=]() &#123; <span class="built_in">parallelQuicksort</span>(i + <span class="number">1</span>, right); &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用cutoff</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallelCutoffQuicksort</span><span class="params">(QV::iterator left, QV::iterator right)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cutoff = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; cutoff) &#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(right, left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> pivot_value =  *left;</span><br><span class="line">        QV::iterator i = left, j = right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i != j &amp;&amp; pivot_value &lt; *j) --j;</span><br><span class="line">            <span class="keyword">while</span> (i != j &amp;&amp; pivot_value &gt;= *i) ++i;</span><br><span class="line">            std::<span class="built_in">iter_swap</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">iter_swap</span>(left, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call</span></span><br><span class="line">        tbb::<span class="built_in">parallel_invoke</span>(</span><br><span class="line">                [=]() &#123; <span class="built_in">parallelQuicksort</span>(left, i); &#125;,</span><br><span class="line">                [=]() &#123; <span class="built_in">parallelQuicksort</span>(i + <span class="number">1</span>, right); &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; ++i)&#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//warmup</span></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="number">10</span>, [](<span class="type">int</span>) &#123;</span><br><span class="line">        tbb::tick_count t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">while</span> ((tbb::tick_count::<span class="built_in">now</span>() - t0).<span class="built_in">seconds</span>() &lt; <span class="number">0.01</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums2 = nums;</span><br><span class="line">    tbb::tick_count t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Normal Time=&quot;</span> &lt;&lt; (tbb::tick_count::<span class="built_in">now</span>() - t0).<span class="built_in">seconds</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    tbb::tick_count t1 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">parallelQuicksort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Parallel Time=&quot;</span> &lt;&lt; (tbb::tick_count::<span class="built_in">now</span>() - t1).<span class="built_in">seconds</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果，当数组比较大的时候，并行快排速度会更快一点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Normal Time=0.0023285</span><br><span class="line">Parallel Time=0.00110846</span><br></pre></td></tr></table></figure><p>此外tbb进行任务分配也会有开销，因此我们往往将大任务分成若干个小任务后，让小任务串型执行，上文中的cutoff就是起到这个作用，这样往往能得到更高的性能</p><h3 id="时刻查询">时刻查询</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//t0时刻</span></span><br><span class="line">tbb::tick_count t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//当前时刻-t0时刻=经过了多长时间段（并转化为秒）</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; (tbb::tick_count::<span class="built_in">now</span>() - t0).<span class="built_in">seconds</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>并行开发中动态内存管理十分复杂、危险（内存泄漏），这里推荐使用C++11的智能指针（自带GC）</p><h3 id="Flow-Graph">Flow Graph</h3><p>将函数执行制作成Graph，实现消息驱动的并行（有些类似FrameGraph）</p><p><img src="Image/FlowGraph.jpeg" class="lazyload" data-srcset="Image/FlowGraph.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="FlowGraph"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fig1_10</span><span class="params">(<span class="type">const</span> std::vector&lt;ImagePtr&gt;&amp; image_vector)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> tint_array[] = &#123;<span class="number">0.75</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    tbb::flow::graph g;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意，source_node已经失效</span></span><br><span class="line">    tbb::<span class="function">flow::input_node&lt;ImagePtr&gt; <span class="title">src</span><span class="params">(g,</span></span></span><br><span class="line"><span class="params"><span class="function">        [&amp;i, &amp;image_vector](tbb::flow_control &amp;fc) -&gt; ImagePtr &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span>(i &lt; image_vector.size())&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> image_vector[i++];</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">else</span>&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                fc.stop();</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> &#123;&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    tbb::<span class="function">flow::function_node&lt;ImagePtr, ImagePtr&gt; <span class="title">gamma</span><span class="params">(g,</span></span></span><br><span class="line"><span class="params"><span class="function">        tbb::flow::unlimited, [] (ImagePtr img) -&gt; ImagePtr&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> applyGamma(img, <span class="number">1.4</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    tbb::<span class="function">flow::function_node&lt;ImagePtr, ImagePtr&gt; <span class="title">tint</span><span class="params">(g,</span></span></span><br><span class="line"><span class="params"><span class="function">        tbb::flow::unlimited, [tint_array] (ImagePtr img) -&gt; ImagePtr&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> applyTint(img, tint_array);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    tbb::<span class="function">flow::function_node&lt;ImagePtr&gt; <span class="title">write</span><span class="params">(g,</span></span></span><br><span class="line"><span class="params"><span class="function">         tbb::flow::unlimited, [] (ImagePtr img)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                writeImage(img);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line">    tbb::flow::<span class="built_in">make_edge</span>(src, gamma);</span><br><span class="line">    tbb::flow::<span class="built_in">make_edge</span>(gamma, tint);</span><br><span class="line">    tbb::flow::<span class="built_in">make_edge</span>(tint, write);</span><br><span class="line">    src.<span class="built_in">activate</span>();</span><br><span class="line">    g.<span class="built_in">wait_for_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后该程序会以<strong>流水线</strong>的形式执行，当第一张图片完成gamma矫正，去执行tint着色时，第二张图片开始执行gamma矫正（每张图片间互不影响）</p><p>相比于TimeStudy的串型执行，流水线执行效率会更快</p><h3 id="循环">循环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Index, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">Func <span class="title">parallel_for</span><span class="params">(Index frist, Index last, [Index step,] <span class="type">const</span> Func&amp; f)</span></span>;</span><br></pre></td></tr></table></figure><p>上面的代码，我们将图片处理切分为几个小块，但小块内部仍然是单线程</p><p>我们注意到，在图片处理时，有一个很大的循环在遍历图片上的像素点，那么能不能并行做这件事？</p><p>我们并行处理每一行</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, height,</span><br><span class="line">                  [&amp;in_rows, &amp;out_rows, width, gamma](<span class="type">int</span> i)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; ++j)&#123;</span><br><span class="line">                      <span class="type">const</span> ImageLib::Image::Pixel&amp; p = in_rows[i][j];</span><br><span class="line">                      <span class="type">double</span> v = <span class="number">0.3</span> * p.bgra[<span class="number">2</span>] + <span class="number">0.59</span> * p.bgra[<span class="number">1</span>] + <span class="number">0.11</span> * p.bgra[<span class="number">0</span>];</span><br><span class="line">                      <span class="type">double</span> res = <span class="built_in">pow</span>(v, gamma);</span><br><span class="line">                      <span class="keyword">if</span>(res &gt; ImageLib::MAX_BGR_VALUE)&#123;</span><br><span class="line">                        res = ImageLib::MAX_BGR_VALUE;</span><br><span class="line">                      &#125;</span><br><span class="line">                      out_rows[i][j] = ImageLib::Image::<span class="built_in">Pixel</span>(res, res, res);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                 );</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, height,</span><br><span class="line">                  [&amp;in_rows, &amp;out_rows, width, tints](<span class="type">int</span> i)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; ++j)&#123;</span><br><span class="line">                      <span class="type">const</span> ImageLib::Image::Pixel&amp; p = in_rows[i][j];</span><br><span class="line">                      std::<span class="type">uint8_t</span> b = (<span class="type">double</span>)p.bgra[<span class="number">0</span>] + (ImageLib::MAX_BGR_VALUE - p.bgra[<span class="number">0</span>]) * tints[<span class="number">0</span>];</span><br><span class="line">                      std::<span class="type">uint8_t</span> g = (<span class="type">double</span>)p.bgra[<span class="number">0</span>] + (ImageLib::MAX_BGR_VALUE - p.bgra[<span class="number">1</span>]) * tints[<span class="number">1</span>];</span><br><span class="line">                      std::<span class="type">uint8_t</span> r = (<span class="type">double</span>)p.bgra[<span class="number">0</span>] + (ImageLib::MAX_BGR_VALUE - p.bgra[<span class="number">2</span>]) * tints[<span class="number">2</span>];</span><br><span class="line">                      out_rows[i][j] = ImageLib::Image::<span class="built_in">Pixel</span>(</span><br><span class="line">                        (b &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : b,</span><br><span class="line">                        (g &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : g,</span><br><span class="line">                        (r &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : r</span><br><span class="line">                      );</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                 );</span><br></pre></td></tr></table></figure><p>M1 Mac Xcode Clang至今不支持C++17的std::execution，对OpenMP的支持也相当差</p><h3 id="归约">归约</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Func, <span class="keyword">typename</span> Reduction&gt;</span></span><br><span class="line"><span class="function">Value <span class="title">parallel_reduce</span><span class="params">(<span class="type">const</span> Range&amp; range, <span class="type">const</span> Value&amp; identity, <span class="type">const</span> Func&amp; func, <span class="type">const</span> Reduction&amp; reduction)</span></span>;</span><br></pre></td></tr></table></figure><p>树形规约</p><img src="Image/树形归并.png" class="lazyload" data-srcset="Image/树形归并.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="树形归并" style="zoom:50%;" /><p><img src="Image/reduce.png" class="lazyload" data-srcset="Image/reduce.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="reduce"></p><h4 id="求最大值">求最大值</h4><p>下面是一个vector求最大值的示例，实现机制就是将整个数组分成一个个小块（chunks），分别对小块求最值，然后将小块归约（reduce），最后求得最值（形成了一个树型结构）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pmax</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> max_value = tbb::<span class="built_in">parallel_reduce</span>(</span><br><span class="line">      <span class="comment">//range，扫描范围</span></span><br><span class="line">            tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, arr.<span class="built_in">size</span>()),</span><br><span class="line">      <span class="comment">//identity，小块数据的初始值，这里赋值为int类型的最小值-2147483648</span></span><br><span class="line">            std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>(),</span><br><span class="line">      <span class="comment">//func，每个小块的处理方式</span></span><br><span class="line">            [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">int</span>&gt; &amp;r, <span class="type">int</span> init) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">                    init = std::<span class="built_in">max</span>(init, arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> init;</span><br><span class="line">            &#125;,</span><br><span class="line">      <span class="comment">//reduction，小块间合并的处理方式</span></span><br><span class="line">            [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">max</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> max_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这是一个求PI的示例</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">calcPI</span><span class="params">(<span class="type">int</span> degree)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = <span class="number">1.0</span> / degree;</span><br><span class="line">    <span class="type">double</span> sum = tbb::<span class="built_in">parallel_reduce</span>(</span><br><span class="line">      <span class="comment">//range，扫描范围</span></span><br><span class="line">            tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, degree),</span><br><span class="line">      <span class="comment">//identity，小块数据的初始值，这里赋值为0</span></span><br><span class="line">            <span class="number">0.0</span>,</span><br><span class="line">      <span class="comment">//func，每个小块的处理方式</span></span><br><span class="line">            [=](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">int</span>&gt; &amp;r, <span class="type">double</span> init) -&gt; <span class="type">double</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">                    <span class="type">double</span> x = (i + <span class="number">0.5</span>)*dx;</span><br><span class="line">                    <span class="type">double</span> h = std::<span class="built_in">sqrt</span>(<span class="number">1</span> - x*x);  <span class="comment">//勾股定理</span></span><br><span class="line">                    init += h * dx;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> init;</span><br><span class="line">            &#125;,</span><br><span class="line">      <span class="comment">//reduction，小块间合并的处理方式</span></span><br><span class="line">            [](<span class="type">double</span> x, <span class="type">double</span> y) -&gt; <span class="type">double</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x+y;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扫描">扫描</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Scan, <span class="keyword">typename</span> Combine&gt;</span></span><br><span class="line"><span class="function">Value <span class="title">parallel_scan</span><span class="params">(<span class="type">const</span> Range&amp; range, <span class="type">const</span> Value&amp; identity, <span class="type">const</span> Scan&amp; scan, <span class="type">const</span> Combine&amp; combine)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="前缀和">前缀和</h4><p><em>前缀和在图形领域也有很大的用处</em></p><p>对于一个数组，我们将其分为三个小块ABC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A.init=0, B.init=0</span><br><span class="line">scan(A), scan(B)</span><br><span class="line"></span><br><span class="line">B.init = A.ans</span><br><span class="line">C.init = A.ans + B.ans</span><br><span class="line">scan(B), scan(C)</span><br></pre></td></tr></table></figure><p>最后我们只用了串行2/3的扫描时间，但是多做了1/3的扫描工作，时间减少了，但是工作量变大了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">parallelPrefix</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;v, std::vector&lt;<span class="type">int</span>&gt; &amp;psum)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N = v.<span class="built_in">size</span>();</span><br><span class="line">    psum[<span class="number">0</span>] = v[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> final_sum = tbb::<span class="built_in">parallel_scan</span>(</span><br><span class="line">      <span class="comment">//range</span></span><br><span class="line">            tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, N),</span><br><span class="line">      <span class="comment">//identity</span></span><br><span class="line">            (<span class="type">int</span>)<span class="number">0</span>,</span><br><span class="line">      <span class="comment">//scan body</span></span><br><span class="line">            [&amp;v, &amp;psum](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">int</span>&gt; &amp;r, <span class="type">int</span> sum, <span class="type">bool</span> is_final_scan) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">                    sum += v[i];</span><br><span class="line">                    <span class="keyword">if</span>(is_final_scan)&#123;</span><br><span class="line">                        psum[i] = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;,</span><br><span class="line">      <span class="comment">//combine body</span></span><br><span class="line">            [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;</span><br><span class="line">                <span class="keyword">return</span> x+y;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> final_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可见性">可见性</h4><p>如图，等间距摆放一个个薄板（厚度忽略不计），从最右上角向左看，能看到哪些薄板？</p><img src="Image/sight.png" class="lazyload" data-srcset="Image/sight.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="sight" style="zoom:50%;" /><p>解题的本质就是比较夹角大小，只要夹角一直递增，就能看到</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">visibility</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;heights, std::vector&lt;<span class="type">bool</span>&gt; &amp; visible, <span class="type">double</span> dx)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">double</span> max_angle = std::<span class="built_in">atan2</span>(dx, heights[<span class="number">0</span>] - heights[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> final_max_angle = tbb::<span class="built_in">parallel_scan</span>(</span><br><span class="line">      <span class="comment">//range</span></span><br><span class="line">            tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, N),</span><br><span class="line">      <span class="comment">//identity</span></span><br><span class="line">            <span class="number">0.0</span>,</span><br><span class="line">      <span class="comment">//scan body</span></span><br><span class="line">            [&amp;heights, &amp;visible, dx](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">int</span>&gt; &amp;r, <span class="type">double</span> max_angle, <span class="type">bool</span> is_final_scan) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">                    <span class="type">double</span> my_angle = <span class="built_in">atan2</span>(i * dx, heights[<span class="number">0</span>] - heights[i]);</span><br><span class="line">                    <span class="keyword">if</span>(my_angle &gt;= max_angle)&#123;</span><br><span class="line">                        max_angle = my_angle;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(is_final_scan)&#123;</span><br><span class="line">                        visible[i] = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> max_angle;</span><br><span class="line">            &#125;,</span><br><span class="line">      <span class="comment">//combine body</span></span><br><span class="line">            [](<span class="type">double</span> a, <span class="type">double</span> b)&#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">max</span>(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parallel-for-each">parallel_for_each</h3><p>parallel_for在使用时必须指定range，但如果要处理的item数量不确定（比如在执行过程中修改itemList），那么就不能使用，这个时候我们可以使用parallel_for_each</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typaname InputIterator, <span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_for_each</span><span class="params">( InputIterator first, InputIterator last, Body body )</span></span>;</span><br></pre></td></tr></table></figure><p>下面是一个遍历树的示例，若一个节点的<code>v.first</code>为prime，将其<code>v.second</code>修改为true。我们不知道树有多大，于是采用递归遍历</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(PrimesTreeElement::Ptr root)</span></span>&#123;</span><br><span class="line">  PrimesTreeElement::Ptr tree_arry[] = &#123;root&#125;;</span><br><span class="line">  <span class="comment">//tbb::parallel_do已经废弃</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(</span><br><span class="line">        tree_array,</span><br><span class="line">        [](PrimesTreeElement::Ptr e, </span><br><span class="line">        <span class="comment">//tbb::parallel_do_feeder已被废弃</span></span><br><span class="line">        tbb::feeder&lt;PrimesTreeElement::Ptr&gt;&amp; feeder)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e)&#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">isPrime</span>(e-&gt;v.first)) e-&gt;v.second = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span>(e-&gt;left) feeder.<span class="built_in">add</span>(e-&gt;left);</span><br><span class="line">          <span class="keyword">if</span>(e-&gt;right) feeder.<span class="built_in">add</span>(e-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;                 </span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前向替换">前向替换</h4><p>前向替换（Forward Substitution）是线性代数中一种求解线性方程组的方法</p><p>一般解线性方程组有两种方法：</p><ul><li>直接法<ul><li>高斯消元法</li><li>LU分解法</li></ul></li><li>迭代法</li></ul><p>高斯消元法：初中就学了，就是两个方程变化后相加减（也可以换元），消除变量，直到得到解。这个方法可以拓展到矩阵中，就是把线性方程转化为行阶梯矩阵（中间那个矩阵），然后简化为简化行阶梯矩阵（右边那个矩阵）</p><p>$$<br>\left[<br>\begin{matrix}<br>2 &amp; 1 &amp; -1 &amp;|&amp; 8\\<br>-3 &amp; -1 &amp; 2 &amp; | &amp; -11 \\<br>-2 &amp; 1 &amp; 2 &amp; | &amp; -3<br>\end{matrix}<br>\right]<br>=&gt;<br>\left[<br>\begin{matrix}<br>2 &amp; 1 &amp; -1 &amp;|&amp; 8\\<br>0 &amp; 1/2 &amp; 1/2 &amp; | &amp; 1 \\<br>0 &amp; 0 &amp; -1 &amp; | &amp; 1<br>\end{matrix}<br>\right]<br>=&gt;<br>\left[<br>\begin{matrix}<br>1 &amp; 0 &amp; 0 &amp;|&amp; 2\\<br>0 &amp; 1 &amp; 0 &amp; | &amp; 3 \\<br>0 &amp; 0 &amp; 1 &amp; | &amp; -1<br>\end{matrix}<br>\right]<br>$$</p><p>前向替换法就是得到行阶梯矩阵后</p><img src="/images/前向替换.png" class="lazyload" data-srcset="/images/前向替换.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="前向替换" style="zoom:50%;" /><p>能写出以下式子</p><p>$$<br>\begin{cases}<br>x_1 = b_1/a_{11} \\<br>x_2 = (b_2-a_{21}x_1)/a_{22}\\<br>\ \vdots\\<br>x_n = (b_n -a_{n1}x_1-a_{n2}x_2 - \cdots -a_{nn-1}x_{n-1})/a_{nm}<br>\end{cases}<br>$$</p><p>于是我们只需要从第一个式子开始，逐步向下替换，就能求出方程的解</p><p><em>如果是下三角矩阵，那就是后向替换</em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a是一个下三角矩阵，x、b是向量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serialFS</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt;&amp; x, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; a, std::vector&lt;<span class="type">double</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            b[i] -= a[j + i*N] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">        x[i] = b[i] / a[i + i*N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入分块和并行后：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallelFS</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt; &amp;x, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;a,</span></span></span><br><span class="line"><span class="params"><span class="function">                std::vector&lt;<span class="type">double</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = x.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> block_size = <span class="number">512</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> num_blocks = N / block_size;</span><br><span class="line">  <span class="comment">//tbb::atomic已经废弃</span></span><br><span class="line">  std::vector&lt;std::atomic&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">ref_count</span>(num_blocks * num_blocks);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; num_blocks; ++r) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt;= r; ++c) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line">        ref_count[r * num_blocks + c] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span> || r == c)</span><br><span class="line">        ref_count[r * num_blocks + c] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ref_count[r * num_blocks + c] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> BlockIndex = std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt;;</span><br><span class="line">  <span class="function">BlockIndex <span class="title">top_left</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="comment">//tbb::parallel_do已经废弃</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(&amp;top_left, &amp;top_left + <span class="number">1</span>,</span><br><span class="line">                         [&amp;](<span class="type">const</span> BlockIndex &amp;bi, tbb::feeder&lt;BlockIndex&gt; &amp;feeder) &#123;</span><br><span class="line">                           <span class="type">size_t</span> r = bi.first;</span><br><span class="line">                           <span class="type">size_t</span> c = bi.second;</span><br><span class="line">                           <span class="type">int</span> i_start = r * block_size, i_end = i_start + block_size;</span><br><span class="line">                           <span class="type">int</span> j_start = c * block_size, j_max = j_start + block_size - <span class="number">1</span>;</span><br><span class="line">                           <span class="keyword">for</span> (<span class="type">int</span> i = i_start; i &lt; i_end; ++i) &#123;</span><br><span class="line">                             <span class="type">int</span> j_end = (i &lt;= j_max) ? i : j_max + <span class="number">1</span>;</span><br><span class="line">                             <span class="keyword">for</span> (<span class="type">int</span> j = j_start; j &lt; j_end; ++j) &#123;</span><br><span class="line">                               b[i] -= a[j + i * N] * x[j];</span><br><span class="line">                             &#125;</span><br><span class="line">                             <span class="keyword">if</span> (j_end == i) &#123;</span><br><span class="line">                               x[i] = b[i] / a[i + i * N];</span><br><span class="line">                             &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// add successor to right if ready</span></span><br><span class="line">                           <span class="keyword">if</span> (c + <span class="number">1</span> &lt;= r &amp;&amp; --ref_count[r * num_blocks + c + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                             feeder.<span class="built_in">add</span>(<span class="built_in">BlockIndex</span>(r, c + <span class="number">1</span>));</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// add succesor below if ready</span></span><br><span class="line">                           <span class="keyword">if</span> (r + <span class="number">1</span> &lt; (<span class="type">size_t</span>) num_blocks &amp;&amp; --ref_count[(r + <span class="number">1</span>) * num_blocks + c] == <span class="number">0</span>) &#123;</span><br><span class="line">                             feeder.<span class="built_in">add</span>(<span class="built_in">BlockIndex</span>(r + <span class="number">1</span>, c));</span><br><span class="line">                           &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流水线">流水线</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_pipeline</span><span class="params">( <span class="type">size_t</span> max_number_of_live_tokens, <span class="type">const</span> filter&lt;<span class="type">void</span>,<span class="type">void</span>&gt;&amp; filter_chain )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="type">filter_t</span>&lt;T, U&gt; <span class="title">make_filter</span><span class="params">(filter::mode mode, <span class="type">const</span> Func&amp; f)</span></span>;</span><br></pre></td></tr></table></figure><p>管线（pipeline）是过滤器（filters）的线性序列，物体（items）在通过过滤器时，会被处理</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并行 将字符串中大写变小写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fig_2_27</span><span class="params">(<span class="type">int</span> num_tokens, std::ofstream &amp;caseBeforeFile, std::ofstream &amp;caseAfterFile)</span> </span>&#123;</span><br><span class="line">  tbb::<span class="built_in">parallel_pipeline</span>(</span><br><span class="line">    <span class="comment">//tokens</span></span><br><span class="line">    num_tokens,</span><br><span class="line">    <span class="comment">//第一个filter，负责创建字符串</span></span><br><span class="line">    tbb::<span class="built_in">make_filter</span>&lt;<span class="type">void</span>, CaseStringPtr&gt;(</span><br><span class="line">        <span class="comment">//tbb::filter::serial_in_order已经废弃</span></span><br><span class="line">        tbb::filter_mode::serial_in_order,</span><br><span class="line">        <span class="comment">//filter body</span></span><br><span class="line">        [&amp;](tbb::flow_control &amp;fc) -&gt; CaseStringPtr &#123;</span><br><span class="line">            CaseStringPtr s_ptr = <span class="built_in">getCaseString</span>(caseBeforeFile);</span><br><span class="line">            <span class="keyword">if</span> (!s_ptr)</span><br><span class="line">              fc.<span class="built_in">stop</span>();</span><br><span class="line">            <span class="keyword">return</span> s_ptr;</span><br><span class="line">        &#125;) </span><br><span class="line">    </span><br><span class="line">    &amp; <span class="comment">// 链接</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二个filter，负责修改字符串</span></span><br><span class="line">    tbb::<span class="built_in">make_filter</span>&lt;CaseStringPtr, CaseStringPtr&gt;(</span><br><span class="line">        <span class="comment">//filter node</span></span><br><span class="line">        tbb::filter_mode::parallel,</span><br><span class="line">        <span class="comment">//filter body</span></span><br><span class="line">        [](CaseStringPtr s_ptr) -&gt; CaseStringPtr &#123;</span><br><span class="line">        std::<span class="built_in">transform</span>(s_ptr-&gt;<span class="built_in">begin</span>(), s_ptr-&gt;<span class="built_in">end</span>(), s_ptr-&gt;<span class="built_in">begin</span>(),</span><br><span class="line">                       [](<span class="type">char</span> c) -&gt; <span class="type">char</span> &#123;</span><br><span class="line">                         <span class="keyword">if</span> (std::<span class="built_in">islower</span>(c))</span><br><span class="line">                           <span class="keyword">return</span> std::<span class="built_in">toupper</span>(c);</span><br><span class="line">                         <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">isupper</span>(c))</span><br><span class="line">                           <span class="keyword">return</span> std::<span class="built_in">tolower</span>(c);</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                           <span class="keyword">return</span> c;</span><br><span class="line">                       &#125;);</span><br><span class="line">        <span class="keyword">return</span> s_ptr;</span><br><span class="line">      &#125;) </span><br><span class="line">    </span><br><span class="line">      &amp; <span class="comment">//链接</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第三个filter，负责写字符串</span></span><br><span class="line">    tbb::<span class="built_in">make_filter</span>&lt;CaseStringPtr, <span class="type">void</span>&gt;(</span><br><span class="line">          <span class="comment">//filter node</span></span><br><span class="line">          tbb::filter_mode::serial_in_order,</span><br><span class="line">          <span class="comment">//filter body</span></span><br><span class="line">          [&amp;](CaseStringPtr s_ptr) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="built_in">writeCaseString</span>(caseAfterFile, s_ptr);</span><br><span class="line">          &#125;)</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flow-Graphs">Flow Graphs</h2><p>并行编程另一个问题是混乱，传统并行编程为了避免程序混乱（messy），我们需要事无巨细地管理每一件事。但在上一节简单提到的Flow Graphs，提供了一个简单的管理方法</p><p>Flow Graphs允许我们用图（DAG）来描述程序，相比于<code>parallel_do</code>和<code>parallel_pipeline</code>，FlowGraphs自由度更高，推荐使用。</p><ul><li>每个节点是一个并行函数，箭头代表数据的流向/消息传递，我们将这个图称为数据流向图（data flow graphs）</li><li>图也可以描述操作的前后顺序，进而可以构建一些传统方法难以表示的独立结构体，这种图被称为依赖图（dependency graphs）</li></ul><h3 id="预热">预热</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">warmupTBB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tbb::task_scheduler_init::default_num_threads()已经弃用</span></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, tbb::this_task_arena::<span class="built_in">max_concurrency</span>(), [](<span class="type">int</span>) &#123;</span><br><span class="line">        tbb::tick_count t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">while</span> ((tbb::tick_count::<span class="built_in">now</span>() - t0).<span class="built_in">seconds</span>() &lt; <span class="number">0.01</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是web服务器、CPU/GPU并行计算，深度学习，都有warmup的概念</p><p>对于一个项目，如果采用冷启动的方式，从零瞬间增加计算量，可能会把系统压垮，于是我们可以使用warmup，逐步提高项目负荷。</p><h3 id="数据流图">数据流图</h3><ol><li>构建图对象</li><li>创建节点，填充节点信息</li><li>链接节点</li><li>发送消息</li><li>等待图完成</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">graphSample</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建图对象</span></span><br><span class="line">    tbb::flow::graph g;</span><br><span class="line">    <span class="comment">//创建节点</span></span><br><span class="line">    tbb::<span class="function">flow::function_node&lt;<span class="type">int</span>, std::string&gt; <span class="title">my_first_node</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            g, tbb::flow::unlimited,</span></span></span><br><span class="line"><span class="params"><span class="function">            [](<span class="type">const</span> <span class="type">int</span> &amp;in) -&gt; std::string&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;first node received: &quot;</span> &lt;&lt; in &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> std::to_string(in);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    tbb::<span class="function">flow::function_node&lt;std::string&gt; <span class="title">my_second_node</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            g, tbb::flow::unlimited,</span></span></span><br><span class="line"><span class="params"><span class="function">            [](<span class="type">const</span> std::string &amp;in)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;second node received: &quot;</span> &lt;&lt; in &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    <span class="comment">//链接</span></span><br><span class="line">    tbb::flow::<span class="built_in">make_edge</span>(my_first_node, my_second_node);</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    my_first_node.<span class="built_in">try_put</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//等待图完成</span></span><br><span class="line">    g.<span class="built_in">wait_for_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节点">节点</h4><p>Flow Graphs有三种节点</p><ul><li>functional</li><li>control flow</li><li>buffering</li></ul><h5 id="function-node">function_node</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body&gt;</span></span><br><span class="line"><span class="function"><span class="title">function_node</span><span class="params">(graph&amp; g, <span class="type">size_t</span> concurrency, Body body)</span></span>;</span><br></pre></td></tr></table></figure><p>函数节点，当消息传递到该节点，会被函数处理，并将输出值传递给后继者</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入一个int类型，输出一个std::string类型</span></span><br><span class="line">tbb::<span class="function">flow::function_node&lt;<span class="type">int</span>, std::string&gt; <span class="title">my_first_node</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//图对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">            g, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//节点的并发限制，0是无限制(unlimited)，1是串行(serial)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  tbb::flow::unlimited,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//body</span></span></span></span><br><span class="line"><span class="params"><span class="function">            [](<span class="type">const</span> <span class="type">int</span> &amp;in) -&gt; std::string&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;first node received: &quot;</span> &lt;&lt; in &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> std::to_string(in);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br></pre></td></tr></table></figure><p>函数节点可以从他所连接（edges）其他节点获取消息，也可以使用<code>try_put</code>手动向其传递消息</p><h5 id="join-node">join_node</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body, <span class="keyword">typename</span>... Bodies&gt;</span><br><span class="line"><span class="built_in">join_node</span>(graph&amp;, Body, Bodies...)-&gt;join_node&lt;std::tuple&lt;std::<span class="type">decay_t</span>&lt;<span class="type">input_t</span>&lt;Body&gt;&gt;, std::<span class="type">decay_t</span>&lt;<span class="type">input_t</span>&lt;Bodies&gt;&gt;...&gt;, key_matching&lt;<span class="type">output_t</span>&lt;Body&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure><p>流控制节点，当消息传递到该节点，会创建一个消息元组（tuple），然后将元组广播给所有后继者</p><p><img src="Image/join.jpg" class="lazyload" data-srcset="Image/join.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="join"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//my_node，输入int，输出std::string</span></span><br><span class="line">tbb::flow::function_node&lt;<span class="type">int</span>, std::string&gt; my_node&#123;...&#125;;</span><br><span class="line"><span class="comment">//my_other_node，输入int，输出double</span></span><br><span class="line">tbb::flow::function_node&lt;<span class="type">int</span>, <span class="type">double</span>&gt; my_other_node&#123;...&#125;;</span><br><span class="line"><span class="comment">//join节点，这里的作用是将两个节点的输出整合，传递给my_final_node</span></span><br><span class="line">tbb::flow::join_node&lt;std::tuple&lt;std::string, <span class="type">double</span>&gt;,</span><br><span class="line">            tbb::flow::queueing&gt; my_join_node&#123;g&#125;;</span><br><span class="line"><span class="comment">//my_final_node，输入一个元组</span></span><br><span class="line">tbb::flow::function_node&lt;std::tuple&lt;std::string, <span class="type">double</span>&gt;, <span class="type">int</span>&gt; my_final_node&#123;g,</span><br><span class="line">                   tbb::flow::unlimited,</span><br><span class="line">                   [](<span class="type">const</span> std::tuple&lt;std::string, <span class="type">double</span>&gt;&amp; in) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">                     std::cout &lt;&lt; <span class="string">&quot;final: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(in)</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(in) &lt;&lt; std::endl;</span><br><span class="line">                     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                  &#125;;</span><br></pre></td></tr></table></figure><p>有的时候，我们需要保证<code>join_node</code>的输入的对应的。比如我想将两张照片拼成一张，我开两个节点并行读项目，再用<code>join_node</code>整合后传入merge函数节点，然而在这个过程中，我必须保证传入的两个像素点在同一位置，为此，我们可以添加一个frameNumber做标记（tags）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用函数对象作为tags，可以用input_port&lt;i&gt;读出来</span></span><br><span class="line">tbb::flow::join_node&lt;std::tuple&lt;Image, Image&gt;, tbb::flow::tag_matching &gt;</span><br><span class="line">    <span class="built_in">join_images_node</span>(g, [] (Image left) &#123; <span class="keyword">return</span> left.frameNumber; &#125;,</span><br><span class="line">                        [] (Image right) &#123; <span class="keyword">return</span> right.frameNumber; &#125; );</span><br><span class="line">...</span><br><span class="line">tbb::flow::<span class="built_in">make_edge</span>(increase_left_node, tbb::flow::<span class="built_in">input_port</span>&lt;<span class="number">0</span>&gt;(join_images_node));</span><br><span class="line">tbb::flow::<span class="built_in">make_edge</span>(increase_right_node, tbb::flow::<span class="built_in">input_port</span>&lt;<span class="number">1</span>&gt;(join_images_node));</span><br><span class="line">tbb::flow::<span class="built_in">make_edge</span>(join_images_node, merge_images_node);</span><br></pre></td></tr></table></figure><h4 id="链接">链接</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Message&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_edge</span><span class="params">( sender&lt;Message&gt; &amp;p, receiver&lt;Message&gt; &amp;s )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MultiOutputNode, <span class="keyword">typename</span> MultiInputNode &gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_edge</span><span class="params">( MultiOutputNode&amp; output, MultiInputNode&amp; input )</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>make_edge</code>链接两个节点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的input_port是一种sender，跟节点差不多，都能互相链接</span></span><br><span class="line"><span class="built_in">make_edge</span>(my_node, tbb::flow::<span class="built_in">input_port</span>&lt;<span class="number">0</span>&gt;(my_join_node));</span><br><span class="line"><span class="built_in">make_edge</span>(my_other_node, tbb::flow::<span class="built_in">input_port</span>&lt;<span class="number">1</span>&gt;(my_join_node));</span><br><span class="line"><span class="built_in">make_edge</span>(my_join_node, my_final_node);</span><br></pre></td></tr></table></figure><h4 id="激活">激活</h4><p>为了激活图，我们需要向图中传递消息，除了前文的<code>try_put</code>，我们也可以使用<code>input_port</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//my_node是一个input_node</span></span><br><span class="line">my_node.<span class="built_in">activate</span>();<span class="comment">//将其设为活动状态，启用消息生成</span></span><br></pre></td></tr></table></figure><h4 id="等待">等待</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g.<span class="built_in">wait_for_all</span>();</span><br></pre></td></tr></table></figure><h3 id="性能限制">性能限制</h3><p>Flow Graphs是一个基于Task的并行框架，当消息到达一个节点时，根据节点的并发限制，创建Task。生成的Task会进一步映射为线程（跟上一节讲的循环、算法的机制一样）</p><p>真正限制Flow Graphs性能的有</p><ul><li>串行节点（serial node）</li><li>工作线程数</li><li>任务复杂度</li></ul><h3 id="依赖图">依赖图</h3><p><em>很像RenderGraph</em></p><table><thead><tr><th></th><th>数据流向图</th><th>依赖图</th></tr></thead><tbody><tr><td>Edges含义</td><td>表示数据流向</td><td>表示节点的先后顺序</td></tr><tr><td>信息传递方式</td><td>消息</td><td>shared memory</td></tr><tr><td>节点类型</td><td>function_node</td><td>continue_node</td></tr></tbody></table><ul><li><p>节点的先后顺序，描述的是依赖关系，只有前面节点执行结束后，后面节点才能安全、正确地执行</p></li><li><p>依赖图不使用函数节点，而是继续节点<code>continue_node</code>，节点间的消息传递使用，当传入<code>continue_node</code>的消息（<code>continue_msg</code>）数量等于该节点需要的消息数量，节点内的函数会开始执行</p></li><li><p><code>continue_node</code>只关心传入的消息数量，不关心消息源。这导致依赖图必须是非循环的（acyclic），因为一个物体循环发出两次消息，（在这里）等同于两个物体各发出一次消息</p></li></ul><p>构建依赖图</p><ol><li>创建图对象</li><li>创建节点</li><li>链接</li><li>发送信息</li><li>等待图完成</li></ol><h4 id="前向替换-2">前向替换</h4><p>之前我们使用<code>parallel_for_each</code>实现了一份前向替换，我们现在用依赖图再实现一次</p><p><img src="Image/%E5%89%8D%E5%90%91%E6%9B%BF%E6%8D%A2.jpg" class="lazyload" data-srcset="Image/%E5%89%8D%E5%90%91%E6%9B%BF%E6%8D%A2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="前向替换"></p><p>经观察，我们发现辅对角线的块/迭代器是相互独立的，他们之间没有依赖关系（上图(b)，块BC间没有依赖，他们只需要在A之后执行就可以正确运算）</p><p>经观察，同时并行计算的最大块数为辅对角线的长度，也就是图中标注的 a set of independent blocks</p><p>经观察，上图(b)中每一个块需要接受两个msg，正好与block_sizes大小相等</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Node = tbb::flow::continue_node&lt;tbb::flow::continue_msg&gt;;</span><br><span class="line"><span class="keyword">using</span> NodePtr = std::shared_ptr&lt;Node&gt;;</span><br><span class="line"><span class="function">NodePtr <span class="title">createNode</span><span class="params">(tbb::flow::graph &amp;g, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> block_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::vector&lt;<span class="type">double</span>&gt; &amp;x, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;a, std::vector&lt;<span class="type">double</span>&gt; &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdges</span><span class="params">(std::vector&lt;NodePtr&gt; &amp;nodes, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> block_size, <span class="type">int</span> num_blocks)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dependencyGraphFS</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt; &amp;x, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;a, std::vector&lt;<span class="type">double</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> block_size = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_blocks = N / block_size;</span><br><span class="line"><span class="comment">//创建num_blocks * num_blocks个节点，只不过我们只会用到下半部分</span></span><br><span class="line">    <span class="function">std::vector&lt;NodePtr&gt; <span class="title">nodes</span><span class="params">(num_blocks * num_blocks)</span></span>;</span><br><span class="line">    <span class="comment">//创建图对象</span></span><br><span class="line">    tbb::flow::graph g;</span><br><span class="line">  <span class="comment">//我们从最下面一行开始向上构建</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r = num_blocks<span class="number">-1</span>; r &gt;= <span class="number">0</span>; --r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c = r; c &gt;= <span class="number">0</span>; --c)&#123;</span><br><span class="line">            <span class="comment">//创建图节点</span></span><br><span class="line">            nodes[r * num_blocks + c] = <span class="built_in">createNode</span>(g, r, c, block_size, x, a, b);</span><br><span class="line">            <span class="comment">//链接</span></span><br><span class="line">            <span class="built_in">addEdges</span>(nodes, r, c, block_size, num_blocks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入消息</span></span><br><span class="line">    nodes[<span class="number">0</span>]-&gt;<span class="built_in">try_put</span>(tbb::flow::<span class="built_in">continue_msg</span>());</span><br><span class="line">    <span class="comment">//等待完成</span></span><br><span class="line">    g.<span class="built_in">wait_for_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NodePtr <span class="title">createNode</span><span class="params">(tbb::flow::graph &amp;g, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> block_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::vector&lt;<span class="type">double</span>&gt; &amp;x, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;a, std::vector&lt;<span class="type">double</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Node&gt;(</span><br><span class="line">            g,</span><br><span class="line">            [r, c, block_size, N, &amp;x, &amp;a, &amp;b](<span class="type">const</span> tbb::flow::continue_msg &amp; msg)&#123;</span><br><span class="line">                <span class="type">int</span> i_start = r * block_size, i_end = i_start + block_size;</span><br><span class="line">                <span class="type">int</span> j_start = c * block_size, j_max = j_start + block_size <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">//对于每个块，串行进行正向替换计算</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = i_start; i &lt; i_end; ++i)&#123;</span><br><span class="line">                    <span class="type">int</span> j_end = (i &lt;= j_max) ? i : j_max+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = j_start; j &lt; j_end; ++j)&#123;</span><br><span class="line">                        b[i] -= a[j + i*N] * x[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j_end == i)&#123;</span><br><span class="line">                        x[i] = b[i] / a[i + i*N];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> msg;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdges</span><span class="params">(std::vector&lt;NodePtr&gt; &amp;nodes, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> block_size, <span class="type">int</span> num_blocks)</span></span>&#123;</span><br><span class="line">    NodePtr np = nodes[r * num_blocks + c];</span><br><span class="line">  <span class="comment">//每个块链接自己的下面和右边，最下面和最右边不链接</span></span><br><span class="line">    <span class="keyword">if</span>(c + <span class="number">1</span> &lt; num_blocks &amp;&amp; r != c)&#123;</span><br><span class="line">        tbb::flow::<span class="built_in">make_edge</span>(*np, *nodes[r * num_blocks + c + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r + <span class="number">1</span> &lt; num_blocks)&#123;</span><br><span class="line">        tbb::flow::<span class="built_in">make_edge</span>(*np, *nodes[(r+<span class="number">1</span>) * num_blocks + c]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PSTL">PSTL</h2><p>parallel_sort</p><h2 id="同步">同步</h2><p>在并行编程中，我们要极力避免同步（Synchronization）和互斥（exclusion），这会严重影响性能</p><p>但是很多情况下，我们不得不同步，书中称其为“必要之恶”（necessary evil）</p><h3 id="写冲突">写冲突</h3><p>比如我们想要统计一张图中各种颜色出现的次数，如果是串行处理，我们就遍历每一个像素，用一个数组存储统计值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">  hist[image[i]]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但当我们想要并行处理遍历像素时，就会出现问题。如果两个线程同时读到了同一种颜色，于是都想执行<code>hist[p]++</code>，而如果该操作不支持原子（atomic）操作，就会出现写冲突</p><h4 id="RMW">RMW</h4><p>现代操作系统将很多操作设置为原子操作，该操作被视为一个完成的操作，不可分割，因此是线程安全的。比如对齐读（Aligned Read），对齐写（Aligned Write）</p><p><em>原子的本意就是不可分割的意思，当年化学家和物理学家认为原子是最小的粒子（尽管并非如此）</em></p><p>Read-Modify-Write（RMW）设计原则，可以让复杂操作原子化，当多个线程想要对某个内存进行修改时，保证线程安全并只执行一次</p><p>windows原子操作的实现原理（_InterlockedIncrement）</p><ol><li>读内存</li><li>计算得到新值</li><li>若内存位置仍然是原始值，则将新值写入该内存位置<ul><li>若不是原始值，则在下一个循环周期中重新操作</li></ul></li></ol><h4 id="锁">锁</h4><p>解决并行写冲突最简单的方法就是加锁，我们给对象加一个互斥锁（mutex），写之前上锁，写完解锁，其他线程无法操作锁住的对象。而上锁解锁操作中间的代码被称为临界区（critical section），是被锁保护的部分。</p><p>锁会影响性能</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tbb::task_scheduler_init init&#123;nth&#125;已经弃用，用于设置最大线程数</span></span><br><span class="line"><span class="function">tbb::global_control <span class="title">global_limit</span><span class="params">(tbb::global_control::max_allowed_parallelism, nth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="type">my_mutex_t</span>=tbb::spin_mutex;</span><br><span class="line"><span class="type">my_mutex_t</span> my_mutex;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">hist_p</span><span class="params">(num_bins)</span></span>;</span><br><span class="line"><span class="built_in">parallel_for</span>(tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&#123;<span class="number">0</span>, image.<span class="built_in">size</span>()&#125;,</span><br><span class="line">             [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//这种写法比my_lock.acquire(my_mutex)、my_lock.release()好</span></span><br><span class="line">                 <span class="type">my_mutex_t</span>::scoped_lock my_lock&#123;my_mutex&#125;;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">                   hist_p[image[i]]++;</span><br><span class="line">             &#125;);</span><br></pre></td></tr></table></figure><h4 id="原子操作">原子操作</h4><p>锁过于消耗性能，原子操作效果会好一些，只不过这样还是比线性慢，而且不是真共享（Sharing）</p><p>什么是原子？原子的原意就是不可分割的基本粒子，我们在实现<code>a++</code>时，本质是分了三步</p><ol><li>取a</li><li>加法运算</li><li>写a</li></ol><p>由于并行计算，其他线程可能在你完整完成这三步期间进行操作，于是就会出现冲突。而原子操作就是将这三步视为一步，不可分割，在完整完成这三部之前，其他线程无权访问，等到操作结束</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::atomic&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">hist_p2</span>(num_bins);</span><br><span class="line"><span class="built_in">parallel_for</span>(tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&#123;<span class="number">0</span>, image.<span class="built_in">size</span>()&#125;, </span><br><span class="line">             [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">                 &#123;</span><br><span class="line">                     hist_p2[image[i]]++;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">            );</span><br></pre></td></tr></table></figure><h3 id="Thread-Local-Storage">Thread Local Storage</h3><p>一个较好的解决方案是私有化（Privatization）和归并（Reduction）</p><p>我感觉这个的设计理念就是：如果不得不同步，那就尽可能让更多更复杂的计算并行执行，最后对统一、规范、简单的数据进行同步</p><p>前面并行统计Image像素信息时，会出现多个线程写冲突。但如果让每个线程都有一个Image副本，线程对自己的副本进行操作（私有化），最后将这些副本进行归并。</p><p>私有化确实不会出现写冲突了，尽管归并仍然存在同步问题，但这个归并更简单，毕竟归并几个数，远远比处理几个线程冲突要简单，性能开销小</p><p>TBB提供了多种私有化+归并的的方案，其中归并模板（parallel_reduce）在TBB基础时就讲了</p><ul><li>Thread Local Storage（TLS）：让每一个线程拥有一份副本，只不过存储开销过大，不宜过多使用<ul><li>enumerable_thread_specific（ETS）</li><li>combinable</li></ul></li></ul><h4 id="ETS">ETS</h4><p><code>tbb::enumerable_thread_specific&lt;T&gt;</code>对象是一个大容器，容器内包含者每一个线程所对应的副本，我们可以使用迭代器进行访问</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">vector_t</span> = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="type">priv_h_t</span> = tbb::enumerable_thread_specific&lt;<span class="type">vector_t</span>&gt;;</span><br><span class="line"><span class="type">priv_h_t</span> priv_h&#123;num_bins&#125;;</span><br><span class="line"><span class="comment">//私有化</span></span><br><span class="line"><span class="built_in">parallel_for</span>(tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&#123;<span class="number">0</span>, image.<span class="built_in">size</span>()&#125;,</span><br><span class="line">             [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//若该线程第一次使用local，那么会创建一个新的vector&lt;int&gt;，初始值为0</span></span><br><span class="line">                 <span class="type">priv_h_t</span>::reference my_hist = priv_h.<span class="built_in">local</span>();</span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">                     <span class="comment">//my_hist是引用，实际上是在修改priv_h[xxx]，以此将数据传递到线程外</span></span><br><span class="line">                     my_hist[image[i]]++;</span><br><span class="line">                 &#125;     </span><br><span class="line">             &#125;);</span><br><span class="line"><span class="comment">//归并</span></span><br><span class="line"><span class="function"><span class="type">vector_t</span> <span class="title">hist_p3</span><span class="params">(num_bins)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i=priv_h.<span class="built_in">begin</span>(); i!=priv_h.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;num_bins; ++j) &#123;</span><br><span class="line">    hist_p3[j]+=(*i)[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用STL算法替代循环，进行归并</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以使用transform替代循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i: priv_h) &#123; <span class="comment">// i traverses all private vectors</span></span><br><span class="line">    std::<span class="built_in">transform</span>(hist_p3.<span class="built_in">begin</span>(),    <span class="comment">// source 1 begin</span></span><br><span class="line">                   hist_p3.<span class="built_in">end</span>(),      <span class="comment">// source 1 end</span></span><br><span class="line">                   i.<span class="built_in">begin</span>(),          <span class="comment">// source 2 begin</span></span><br><span class="line">                   hist_p3.<span class="built_in">begin</span>(),    <span class="comment">// destination begin</span></span><br><span class="line">                   std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;() ); <span class="comment">// binary operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于归并过于常用，TBB也对归并做了封装</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用combine_each</span></span><br><span class="line">priv_h.<span class="built_in">combine_each</span>([&amp;](<span class="type">vector_t</span> i)&#123;</span><br><span class="line">        std::<span class="built_in">transform</span>(hist_p3.<span class="built_in">begin</span>(),   <span class="comment">// source 1 begin</span></span><br><span class="line">                   hist_p3.<span class="built_in">end</span>(),      <span class="comment">// source 1 end</span></span><br><span class="line">                   i.<span class="built_in">begin</span>(),         <span class="comment">// source 2 begin</span></span><br><span class="line">                   hist_p3.<span class="built_in">begin</span>(),    <span class="comment">// destination begin</span></span><br><span class="line">                   std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;() );<span class="comment">// binary operation</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//或者使用combine</span></span><br><span class="line"><span class="type">vector_t</span> hist_p = priv_h.<span class="built_in">combine</span>([](<span class="type">vector_t</span> a, <span class="type">vector_t</span> b) -&gt; <span class="type">vector_t</span> &#123;</span><br><span class="line">      std::<span class="built_in">transform</span>(a.<span class="built_in">begin</span>(),         <span class="comment">// source 1 begin</span></span><br><span class="line">                     a.<span class="built_in">end</span>(),           <span class="comment">// source 1 end</span></span><br><span class="line">                     b.<span class="built_in">begin</span>(),         <span class="comment">// source 2 begin</span></span><br><span class="line">                     a.<span class="built_in">begin</span>(),         <span class="comment">// destination begin</span></span><br><span class="line">                     std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;() );<span class="comment">// binary operation</span></span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="combinable">combinable</h4><p><code>combinable&lt;T&gt;</code>对象也是一个容器，每一个线程对应一个instance</p><p>但是与ETS不同，<code>combinable&lt;T&gt;</code>并不能使用迭代器访问，这样设计的目的是不向外暴露对象，这样归并结束后大容器和其中的数据都释放了，以此节省局部空间</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//combinable</span></span><br><span class="line">tbb::combinable&lt;<span class="type">vector_t</span>&gt; priv_h2&#123;[num_bins]()&#123;<span class="keyword">return</span> <span class="built_in">vector_t</span>(num_bins);&#125;&#125;;</span><br><span class="line"><span class="comment">//私有化</span></span><br><span class="line"><span class="built_in">parallel_for</span>(tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&#123;<span class="number">0</span>, image.<span class="built_in">size</span>()&#125;,</span><br><span class="line">             [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="type">vector_t</span>&amp; my_hist = priv_h2.<span class="built_in">local</span>();</span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">                     my_hist[image[i]]++;</span><br><span class="line">             &#125;);</span><br><span class="line"><span class="comment">//归并</span></span><br><span class="line"><span class="function"><span class="type">vector_t</span> <span class="title">hist_p4</span><span class="params">(num_bins)</span></span>;</span><br><span class="line">priv_h2.<span class="built_in">combine_each</span>([&amp;](<span class="type">vector_t</span> i)</span><br><span class="line">                     &#123; <span class="comment">// for each priv histogram a</span></span><br><span class="line">                         std::<span class="built_in">transform</span>(hist_p4.<span class="built_in">begin</span>(),     <span class="comment">// source 1 begin</span></span><br><span class="line">                                        hist_p4.<span class="built_in">end</span>(),      <span class="comment">// source 1 end</span></span><br><span class="line">                                        i.<span class="built_in">begin</span>(),          <span class="comment">// source 2 begin</span></span><br><span class="line">                                        hist_p4.<span class="built_in">begin</span>(),    <span class="comment">// destination begin</span></span><br><span class="line">                                        std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;() ); <span class="comment">// binary operation</span></span><br><span class="line">                     &#125;);</span><br></pre></td></tr></table></figure><p>最终性能比较，能看出TLS能大幅提高性能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Serial:       0.399203</span><br><span class="line">Parallel:     2.01466</span><br><span class="line">Atomic:       0.500326</span><br><span class="line">ETC:          0.0348115</span><br><span class="line">combinable:   0.0339478</span><br></pre></td></tr></table></figure><h3 id="parallel-reduce">parallel_reduce</h3><p>最简单的归并，还是给用tbb封装好的模板，该算法的本质是树形规约</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parallel_reduce</span></span><br><span class="line"><span class="keyword">using</span> image_iterator = std::vector&lt;<span class="type">uint8_t</span>&gt;::iterator;</span><br><span class="line">t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">vector_t</span> hist_p5 = <span class="built_in">parallel_reduce</span> (</span><br><span class="line">    <span class="comment">/*range*/</span>    </span><br><span class="line">    tbb::blocked_range&lt;image_iterator&gt;&#123;image.<span class="built_in">begin</span>(), image.<span class="built_in">end</span>()&#125;,</span><br><span class="line">    <span class="comment">/*identity*/</span> </span><br><span class="line">    <span class="built_in">vector_t</span>(num_bins),</span><br><span class="line">    <span class="comment">// 1st Lambda: Parallel computation on private histograms</span></span><br><span class="line">    [](<span class="type">const</span> tbb::blocked_range&lt;image_iterator&gt;&amp; r, <span class="type">vector_t</span> v) &#123;</span><br><span class="line">        std::for_each(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>(),</span><br><span class="line">                      [&amp;v](<span class="type">uint8_t</span> i) &#123;v[i]++;&#125;);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 2nd Lambda: Parallel reduction of the private histograms</span></span><br><span class="line">    [num_bins](<span class="type">vector_t</span> a, <span class="type">const</span> <span class="type">vector_t</span> &amp; b) -&gt; <span class="type">vector_t</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num_bins; ++i) a[i] += b[i];</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="并发容器">并发容器</h2><p>在上一节我们遇到了同步问题，处理同步会大幅降低性能，为此我们使用了TLS等方法实现了高效的显式同步，而这一节，我们将介绍TBB的核心，并发（Concurrent）</p><p>TBB提供了一些高效、线程安全的并发容器，他们大多是使用细粒度的锁或者无锁设计</p><ul><li>细粒度锁：指锁定真正需要锁定的地方（其实还是挺低效的），比如一个数组我们只锁我们需要的某一个元素，其他线程如果不访问我这个元素，就能正常并行</li><li>无锁：有的线程负责操作，有的线程负责纠错</li></ul><p>TBB的并发容器并发性能很好，但串行性能不如STL</p><ul><li>顺序表（Sequences）<ul><li><code>concurrent_vector</code></li></ul></li><li>队列（Queues）<ul><li><code>concurrent_queue</code></li><li><code>concurrent_bounded_queue</code></li><li><code>concurrent_priority_queue</code></li></ul></li><li>无序关联容器（Unordered associative containers）<ul><li><code>concurrent_hash_map</code></li><li><code>map/multimap</code></li><li><code>set/multiset</code></li></ul></li><li>有序关联容器（Ordered associative containers）<ul><li><code>map/multimap</code></li><li><code>set/multiset</code></li></ul></li></ul><h3 id="concurrent-hash-map">concurrent_hash_map</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T,</span><br><span class="line">                 <span class="keyword">typename</span> HashCompare = tbb_hash_compare&lt;Key&gt;,</span><br><span class="line">                 <span class="keyword">typename</span> Allocator = tbb_allocator&lt;std::pair&lt;<span class="type">const</span> Key, T&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> concurrent_hash_map &#123;..&#125;</span><br></pre></td></tr></table></figure><p>这是一个字符串-Int的哈希表</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashCompare必须有hash函数和equal函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyHashCompare</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">hash</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)&#123;</span><br><span class="line">            h = (h*<span class="number">17</span>)^c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> std::string&amp; x, <span class="type">const</span> std::string&amp; y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//hash map</span></span><br><span class="line"><span class="keyword">typedef</span> tbb::concurrent_hash_map&lt;std::string, <span class="type">int</span>, MyHashCompare&gt; StringTable;</span><br><span class="line"><span class="comment">//一个函数对象，用于记录table内元素数量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tally</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StringTable&amp; table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tally</span>(StringTable&amp; table_): <span class="built_in">table</span>(table_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> tbb::blocked_range&lt;std::string*&gt; range)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(std::string* p = range.<span class="built_in">begin</span>(); p != range.<span class="built_in">end</span>(); ++p)&#123;</span><br><span class="line">          <span class="comment">//accessor类似于锁、智能智能，在accessor完成前，其他线程不能lookup这个key</span></span><br><span class="line">            StringTable::accessor a;</span><br><span class="line">            table.<span class="built_in">insert</span>(a, *p);</span><br><span class="line">            a-&gt;second += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringTable table;</span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>( tbb::<span class="built_in">blocked_range</span>&lt;std::string*&gt;( Data, Data+N, <span class="number">1000</span> ), <span class="built_in">Tally</span>(table) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( StringTable::iterator i=table.<span class="built_in">begin</span>();</span><br><span class="line">         i!=table.<span class="built_in">end</span>();</span><br><span class="line">         ++i )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,i-&gt;first.<span class="built_in">c_str</span>(),i-&gt;second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存分配">内存分配</h2><p>内存分配最重要的是正确，TBB提供了一套可拓展的内存分配</p><p>现代C++推荐使用智能指针进行内存管理，不推荐使用malloc和new。TBB完全适配所有版本的C++标准，也推荐使用智能指针进行内存分配</p><p>TBB动态内存分配的核心是线程内存池（memory pooling by threads），该内存池可以避免内存分配带来的性能下降，也不苛求“避免cache间不必要的数据移动”</p><p>TBB还提供了可拓展的缓存对齐，比<code>std::aligned_alloc</code>使用更简单方便。只不过滥用缓存对齐可能会带了巨大的内存浪费</p><p>在并行编程中，内存分配的主要问题是：分配器的争用，缓存效果</p><ul><li>分配器争用：C++内存分存储在两个位置，堆和栈。传统的非线程分配器只能在单个全局堆中分配和释放内存，这个过程配合锁以实现互斥，很低效</li><li>缓存效应：某些操作可能会把缓存中的数据移动到缓存的另一处，这是很无效的行为，要避免</li></ul><h3 id="缓存填充（对齐）">缓存填充（对齐）</h3><p>用于解决假共享（我们在同步那一节解决了真共享带来的问题）</p><p>基于局部性原则，当CPU查询某个数据时：</p><ol><li>若cache中没有找到，就会去内存中寻找</li><li>找到后会将该数据写入cache（时间局部性，刚刚被引用过的一个内存位置容易再次被引用）</li><li>并将其相邻元素也写入cache（空间局部性，一个内存位置被引用，其相邻位置很可能马上被引用）</li></ol><p><img src="Image/%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7.png" class="lazyload" data-srcset="Image/%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="空间局部性"></p><p>如上图，CPU访问a时，先去cache去找，如果cache中没有，就会去内存中寻找，找到后将a和相邻的b写入cache的<strong>同一行</strong>。但问题出现了，如果当前cache的其他行里，已经有b了呢？</p><p>另一个线程也拥有一缓存行，里面存储了b，结果b却被移动到a那一行了，于是这个线程要访问b，又要去内存中找，增加了cache miss。此外多线程中，a那个线程多半是不会用到b的，于是平白做了cache位置的移动。</p><p>这个现象被称为假共享（false sharing），a和b并不是共享对象，但是由于他们靠的太近了，以至于在一个缓存行中，其中一个对象的更新，会强制另一个对象更新。</p><p>在多线程中，假共享可以通过缓存填充（cache padding）解决。缓存填充，就是在缓存中两个变量中间填充一些没有意义的数据，于是导致这两个变量不会处于同一个缓存行中，于是避免了假共享。</p><p>我们还是以统计图片像素为例，我们发现这种方法比直接用原子操作要快一些</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bin</span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; count; <span class="comment">//4 bytes</span></span><br><span class="line">    <span class="type">uint8_t</span> padding[<span class="number">64</span> - <span class="built_in">sizeof</span>(count)];    <span class="comment">//60 bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//cache padding</span></span><br><span class="line">std::vector&lt;bin, tbb::cache_aligned_allocator&lt;bin&gt;&gt; <span class="built_in">hist_p6</span>(num_bins);</span><br><span class="line">t0 = tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line"><span class="built_in">parallel_for</span>(tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&#123;<span class="number">0</span>, image.<span class="built_in">size</span>()&#125;,</span><br><span class="line">             [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">             &#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">               &#123;</span><br><span class="line">                 hist_p6[image[i]].count++;</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">            );</span><br></pre></td></tr></table></figure><p>我们可以用C++特性来创建结构体：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bin</span>&#123;</span><br><span class="line">    <span class="comment">//C++17后，可以用std::hardware_destructive_interference_size替代64</span></span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;<span class="type">int</span>&gt; count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代理">代理</h3><p>TBB的TBBmalloc库使用代理方法，可以实现在不同操作系统，不改变代码，只需要配置一些动态库、代理库、环境变量，就可以实现全局替换new、malloc等分配函数，这对跨平台真的很重要</p><h2 id="Task调度">Task调度</h2><p>Chapter10</p><h2 id="资料">资料</h2><p><a href="https://github.com/Apress/pro-TBB">Pro TBB</a></p><p><a href="https://spec.oneapi.io/versions/latest/elements/oneTBB/source/nested-index.html">API Document</a></p><p><a href="https://github.com/Reuben-Sun/TBB--Programing-Sample">代码仓库</a></p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
            <tag> 并行计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya插件开发</title>
      <link href="/dcc/maya%E6%8F%92%E4%BB%B6/"/>
      <url>/dcc/maya%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1>Maya</h1><p>maya，老东西，行业标准，真难用（不是）</p><p><a href="https://zhuanlan.zhihu.com/p/76957745">腾讯巨神级TA</a>、<a href="http://www.zt-page.com/?p=109">碧血红天的blog</a>、<a href="https://www.cnblogs.com/3lina/p/11672415.html">Pycharm环境搭建</a></p><h3 id="创建一个python工具">创建一个python工具</h3><p>Python插件和Unity Editor那种工具不太一样，这个其实本质就是一个嵌入式的脚本，通过命令调用maya指令，就算有UI也是现绘制的，也不需要什么项目结构，就一个py文件</p><h4 id="创建一个python文件">创建一个python文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> maya.cmds <span class="keyword">as</span> cmds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createWindow</span>():</span><br><span class="line">    <span class="keyword">if</span> cmds.window(<span class="string">&#x27;mywindow&#x27;</span>, exists=<span class="literal">True</span>):</span><br><span class="line">        cmds.deleteUI(<span class="string">&#x27;mywindow&#x27;</span>)</span><br><span class="line">    windowvar = cmds.window(<span class="string">&#x27;mywindow&#x27;</span>)</span><br><span class="line">    cmds.columnLayout()</span><br><span class="line">    checkButton = cmds.button(l=<span class="string">&#x27;Test&#x27;</span>, command=<span class="string">&#x27;testFunc()&#x27;</span>)</span><br><span class="line">    cmds.showWindow(<span class="string">&#x27;mywindow&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testFunc</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">createWindow()</span><br></pre></td></tr></table></figure><h4 id="添加到工具栏">添加到工具栏</h4><p>当你的代码完成后，可以将其固定到工具架上</p><p><img src="/images/maya%E4%BF%9D%E5%AD%98%E5%B7%A5%E5%85%B7%E6%A0%8F.png" class="lazyload" data-srcset="/images/maya%E4%BF%9D%E5%AD%98%E5%B7%A5%E5%85%B7%E6%A0%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="maya保存工具栏"></p><h4 id="怎么写">怎么写</h4><p>这应该是很多人写maya插件最大的疑惑，我的建议是先学美术，开着脚本编辑器，按照美术流程走一遍，你会发现你每一次操作，脚本编辑器都会输出一个指令，这个应该能让你深受启发</p><p><img src="/images/maya%E8%84%9A%E6%9C%AC.png" class="lazyload" data-srcset="/images/maya%E8%84%9A%E6%9C%AC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="maya脚本"></p><p>如果你的脚本编辑器没有显示，那么在脚本编辑器中设置<strong>显示二者</strong></p><p><img src="/images/%E6%98%BE%E7%A4%BA%E4%BA%8C%E8%80%85.png" class="lazyload" data-srcset="/images/%E6%98%BE%E7%A4%BA%E4%BA%8C%E8%80%85.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="显示二者"></p><h3 id="常用API">常用API</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> maya.cmds <span class="keyword">as</span> cmds<span class="comment">#这是一个将MEL指令用python封装的库，适合面向过程编程</span></span><br><span class="line"><span class="keyword">import</span> maya.OpenMaya <span class="keyword">as</span> om<span class="comment">#拥有cmd没有的功能，运行效率更高</span></span><br></pre></td></tr></table></figure><ul><li><p>删除：<code>cmds.delete(p)</code></p></li><li><p>选中：<code>p = cmds.ls('Name')</code></p></li><li><p>创建</p><ul><li>Cube：<code>pCube = cmds.polyCube(w=10, h=10, d=10, name='myCube')</code></li></ul></li><li><p>移动（到指定位置）</p><ul><li>平移：<code>cmds.move(0, 10, 0, pCube)</code></li><li>缩放：<code>cmds.scale(2, 2, 2, pCube)</code></li><li>旋转：<code>cmds.rotate(45, 45, 0, pCube)</code></li></ul></li><li><p>选择（得到的是对象数组）</p><ul><li>当前选择：<code>list = cmds.ls(selection=True)</code></li></ul></li><li><p>读参数</p><ul><li>位置：<code>cmds.getAttr('%s.translate ' % (p))</code></li><li>位置（某一维）：<code>y = cmds.getAttr('%s.translateY ' % (p))</code></li></ul></li><li><p>写参数</p><ul><li>位置（某一维）：<code>cmds.setAttr('%s.translateX' % (p), 10)</code></li></ul></li></ul><p>想知道maya物体的参数，可以通过表达式编辑器查看（窗口-动画编辑器-表达式编辑器）</p><p><img src="/images/maya%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8.png" class="lazyload" data-srcset="/images/maya%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="maya表达式编辑器"></p><ul><li>得到顶点数据</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printVertexPos</span>():</span><br><span class="line">    selectObjectList = cmds.ls(selection=<span class="literal">True</span>)</span><br><span class="line">    VertexArray = cmds.ls(<span class="string">&#x27;&#123;&#125;.vtx[:]&#x27;</span>.<span class="built_in">format</span>(selectObjectList[<span class="number">0</span>]), fl = <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> VertexArray:</span><br><span class="line">        <span class="built_in">print</span> cmds.xform(v, query = <span class="literal">True</span>, translation = <span class="literal">True</span>, worldSpace = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="工具实例">工具实例</h3><h4 id="平滑法线">平滑法线</h4><p><a href="https://github.com/Reuben-Sun/Note-of-Graphics/blob/main/Code/MayaPython/SmoothNormal.py">平滑法线</a></p><h4 id="模型展2UV">模型展2UV</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个名称为sph的多边形</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createFunc</span>():</span><br><span class="line">   cmds.polySphere(n=<span class="string">&#x27;sph&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除除了map1以外所有的uvmap</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deleteUVs</span>():</span><br><span class="line">    au = cmds.polyUVSet(query=<span class="literal">True</span>, allUVSets=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(au)-<span class="number">1</span>):</span><br><span class="line">        cmds.polyUVSet(delete=<span class="literal">True</span>, uvSet=au[j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#自动展选中物体的2UV，并命名为map2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pickUV2</span>():</span><br><span class="line">    <span class="built_in">list</span> = cmds.ls(dag=<span class="number">1</span>, selection=<span class="literal">True</span>)</span><br><span class="line">    au = cmds.polyUVSet(query=<span class="literal">True</span>, allUVSets=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(au) == <span class="number">1</span>):</span><br><span class="line">        cmds.polyAutoProjection(<span class="built_in">list</span>[<span class="number">1</span>] + <span class="string">&#x27;.f[*]&#x27;</span>, cm = <span class="number">1</span>, uvs= <span class="string">&#x27;map2&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;map2 has been exited&quot;</span></span><br></pre></td></tr></table></figure><h4 id="动画clip">动画clip</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输出选中的动画片段的开始帧和结束帧</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printClip</span>():</span><br><span class="line"><span class="built_in">list</span> = cmds.ls(selection=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        start = cmds.getAttr(<span class="string">&#x27;%s.clipStart &#x27;</span> % (p))</span><br><span class="line">        end = cmds.getAttr(<span class="string">&#x27;%s.clipStart &#x27;</span> % (p)) + cmds.getAttr(<span class="string">&#x27;%s.clipDuration &#x27;</span> % (p))</span><br><span class="line">        <span class="built_in">print</span> start</span><br><span class="line">        <span class="built_in">print</span> end</span><br></pre></td></tr></table></figure><h4 id="打开文件">打开文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">openFile</span>():</span><br><span class="line">   path = <span class="string">&#x27;C:/Users/Admin/Desktop/多边形.fbx&#x27;</span></span><br><span class="line">   cmds.file(path, i=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="开关UV编辑器">开关UV编辑器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">openUVPanel</span>():</span><br><span class="line">   <span class="keyword">if</span> cmds.window(<span class="string">&#x27;polyTexturePlacementPanel1Window&#x27;</span>, ex=<span class="number">1</span>):</span><br><span class="line">        cmds.deleteUI(<span class="string">&#x27;polyTexturePlacementPanel1Window&#x27;</span>)</span><br><span class="line">        mel.<span class="built_in">eval</span>(<span class="string">&#x27;toggleUVToolkit;&#x27;</span>)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">        mel.<span class="built_in">eval</span>(<span class="string">&#x27;texturePanelShow;&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收</title>
      <link href="/engine/GC/"/>
      <url>/engine/GC/</url>
      
        <content type="html"><![CDATA[<h1>垃圾回收</h1><h3 id="前言">前言</h3><p>《垃圾回收的算法与实现》读书笔记，其中的代码大多为伪代码</p><h3 id="一：概念">一：概念</h3><p>GC，Garbage Collection，垃圾回收</p><p>功能</p><ul><li>找到内存中的垃圾</li><li>回收垃圾</li></ul><h4 id="为什么需要GC">为什么需要GC</h4><p>如果没有GC，程序员需要手动进行内存管理，开发麻烦，容易引发内存泄漏、野指针，而且因此导致的BUG很难被定位，修复麻烦</p><p>如果有GC，就可以避免这些问题</p><h4 id="GC的种类">GC的种类</h4><ul><li>保守式GC：不能识别指针和非指针时，一律视为非指针</li><li>准确式GC</li></ul><h4 id="GC的算法">GC的算法</h4><ul><li>标记清除法：标记活动对象，其他的都回收</li><li>引用计数法：回收引用值为0的对象</li><li>GC复制法：复制活动对象，其他的都回收</li></ul><h4 id="GC的选取">GC的选取</h4><ul><li>最大暂停时间短：游戏</li><li>整体处理时间短：音频编码</li></ul><h4 id="对象">对象</h4><p>这里的对象并不是OOP里的Object，而是<strong>被应用程序使用的数据的集合</strong>，对象由<strong>头</strong>和<strong>域</strong>构成</p><ul><li><p>头（header）：包含对象的大小和种类</p></li><li><p>域（field）：参考OOP里的成员</p></li></ul><p>对象分为活动对象和非活动对象，GC会保留活动对象，销毁非活动对象</p><h4 id="mutator">mutator</h4><p>可以简单理解为应用程序，在程序运行过程中，会分配/调用/改变对象（只能操作活动对象），伴随着mutator运行，会产生垃圾</p><h4 id="GC算法的评估标准">GC算法的评估标准</h4><ul><li>吞吐量（throughput）：单位时间的处理能力</li><li>最大暂停时间（在进行GC时，mutator会被暂停）</li><li>堆使用效率</li><li>访问局部性</li></ul><h3 id="二：标记清除法">二：标记清除法</h3><p><em>学这一节之前想想操作系统里文件系统</em></p><p>该算法分为两步</p><ol><li>标记阶段：将所有活动对象做上标记</li><li>清除阶段：将所有没被标记的对象回收</li></ol><h4 id="标记阶段">标记阶段</h4><ol><li>通过根，找到直接引用的对象，标记</li><li>递归标记所有能访问到的对象（常用深搜，因为内存使用量更少）</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mark</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!obj.mark) </span><br><span class="line">        obj.mark = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(child: obj.children) </span><br><span class="line">        <span class="built_in">mark</span>(*child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清除阶段">清除阶段</h4><p>遍历堆，回收所有没有被标记的对象，并将其放入空闲链表，以备分配</p><h4 id="分配策略">分配策略</h4><p>在创建新对象<code>obj</code>时，遍历空闲链表，寻找合适的块，这里使用First-fit算法（因为快）</p><ul><li>First-fit：找到第一个能放下<code>obj</code>的块</li><li>Best-fit：找到最小的能放下<code>obj</code>的块</li><li>Worst-fit：找到最大的能放下<code>obj</code>的块</li></ul><h4 id="合并策略">合并策略</h4><p>分配和回收会导致大量小的分块，于是需要合并，在这里直接遍历堆，将连续的空闲块合并</p><h4 id="评价">评价</h4><p>优点</p><ul><li>实现简单</li><li>与保守式GC兼容（因为对象不会被移动）</li></ul><p>缺点</p><ul><li>碎片化，导致空间浪费，访问性能降低</li><li>不支持<strong>写时复制</strong>（比如UNIX中的<code>fork()</code>）</li></ul><h4 id="优化方案">优化方案</h4><h5 id="分级空闲链表">分级空闲链表</h5><p>使用多个空闲链表，分别只连接不同大小的分块，分配时先找所对应的区间，可以提高性能</p><h5 id="BiBOP（Big-Bag-Of-Pages）">BiBOP（Big Bag Of Pages）</h5><p>将大小相近的对象整理成固定大小的块进行管理</p><ul><li>碎片化的原因之一是杂乱散布的大小各异的对象，如果将堆固定分割，就可以减缓碎片化</li></ul><h5 id="位图标记">位图标记</h5><p>不直接堆对象进行标记，而是记录对象的标志位，存储在一个表格中</p><ul><li>与写时复制技术兼容（因为不会修改对象本身，可以复用）</li><li>清除标志位更高效（只需要把表中要清除的对象的标志位改成一个特殊值）</li></ul><h5 id="延迟标记清除法">延迟标记清除法</h5><ul><li>分配时，先调用清除，如果能清出足够的空间来分配，则直接分配，否则进行普通的标记操作</li><li>清除时，同样是First-fit遍历堆，但遍历的起点是上次开始的地点的右侧</li><li>延迟的内核是不主动清除，而是等到要分配时再清除</li></ul><h3 id="三：引用计数法">三：引用计数法</h3><p><em>学这一节前，想想智能指针</em></p><p>引用计数法中，对象会记录自己被引用次数，主要分为两个阶段</p><ol><li>创建新对象：分配内存，将对象引用次数设为1</li><li>更新指针：先增后减计数器值，若引用次数为0则回收</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新指针ptr，让其指向obj</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_ptr</span><span class="params">(ptr, obj)</span></span>&#123;</span><br><span class="line"><span class="built_in">inc_ref_cnt</span>(obj);<span class="comment">//obj要被ptr引用了，所以obj计数值++</span></span><br><span class="line">    <span class="built_in">dec_ref_cnt</span>(*ptr);<span class="comment">//ptr之前引用的东西不再被引用</span></span><br><span class="line">    *ptr = obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dec_ref_cnt</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    obj.ref_cnt--;<span class="comment">//obj不再被引用，所以计数值--</span></span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)&#123;<span class="comment">//如果obj没人用了，obj就要被清除</span></span><br><span class="line">        <span class="keyword">for</span>(child: obj.children)&#123;<span class="comment">//obj被清除了，那obj引用的对象，被引用次数要--</span></span><br><span class="line">            <span class="built_in">dec_ref_cnt</span>(*child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reclaim</span>(obj);<span class="comment">//执行回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="评价-2">评价</h4><p>优点：</p><ul><li>对象变成垃圾时立刻被回收（延迟标记清除算法要等到分块用尽后才开始回收垃圾）</li><li>最大暂停时间短（只有在更新指针的时候才会打断mutator）</li><li>减少延根指针遍历所有子节点的次数（尤其在分布式系统中，效果显著）</li></ul><p>缺点</p><ul><li>频繁进行计数值的操作</li><li>计数器本身空间比较大（32位系统的计数器就要32位大小）</li><li><strong>循环引用无法回收</strong><ul><li>如果两个物体互相引用，并不和其他对象有联系，于是他们成为了一座“孤岛”，成为了事实意义上的垃圾，但是却无法被回收（因为只要被引用，就不算垃圾）</li></ul></li></ul><h4 id="优化方案-2">优化方案</h4><h5 id="延迟引用计数法">延迟引用计数法</h5><p>解决频繁操作</p><ul><li>使用ZCT表（Zero Count Table），记录所有执行<code>dec_ref_cnt</code>后计数值变成0的对象（也就是说计数值变成0，不会立刻被视为垃圾回收），当ZCT表满了以后，开始回收表中的对象</li><li>优点：延迟了根引用的计数（只有要回收时才会一起操作），降低了计数值的操作频率</li><li>缺点<ul><li>不再能即刻回收垃圾（你可以理解为以前有垃圾就仍，现在要先堆一波垃圾再扔）</li><li>最大暂停时间延长（<code>scan_zct()</code>要访问整个ZCT，这个过程muator是被中断的）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dec_ref_cnt</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    obj.ref_cnt--;</span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)&#123;<span class="comment">//计数值变为0，可能会变成垃圾</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_full</span>($zct))&#123;</span><br><span class="line">            <span class="built_in">scan_zct</span>();<span class="comment">//如果zct表满了，就扫描zct，并回收</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push</span>($zct, obj);<span class="comment">//将obj放入zct表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scane_zct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fot</span>(r: $root)&#123;</span><br><span class="line">        (*r).ref_cnt++;<span class="comment">//根直接引用的对象的计数器++，直接引用计数时，根会极频繁改动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(obj: $zct)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">remove</span>($zct, obj);</span><br><span class="line">            <span class="built_in">delete</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fot</span>(r: $root)&#123;</span><br><span class="line">        (*r).ref_cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Sticky引用计数法">Sticky引用计数法</h5><p>解决空间浪费</p><p>32位电脑意味着可以有$2^{32}$个对象，这些对象可能都会引用<code>obj</code>，所以<code>obj</code>的计数位应当可以记录被引用$2^{32}$次，所以计数位要有32位</p><p>如果计数位太少，一些比较大的对象就无法正常表示（直接做饱和运算，汽车速度超过速度计的最大值会停在最大值处），一旦出现这种情况，我们可以</p><ul><li>什么都不做<ul><li>这会导致如果一个物体被引用的次数特别多，超出了目前表示的范围，即使他变成了垃圾也无法回收</li><li>但是，事实上绝大多数对象计数值一直在0和1间变化（生成后立刻回收），所以很少出现溢出</li><li>而且一个对象被频繁引用，说明他十分重要，十分重要的东西被回收的概率并不大</li><li>很多时候不需要保证内存永不泄露，只需要保证一段时间内不泄露就行，很多软件，用户不会一直开着的</li></ul></li><li>结合使用标记清除算法<ul><li>什么都不做，可能会导致内存耗尽，如果耗尽，那就用标记清除法清一次（相当于垃圾太多了，管不来了，就干脆来一次大扫除）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mark</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(r: $roots)&#123;</span><br><span class="line">        <span class="built_in">push</span>(*r, $stack);<span class="comment">//将所有根直接引用对象入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!$stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        obj = <span class="built_in">pop</span>($stack);</span><br><span class="line">        obj.ref_cnt++;</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt == <span class="number">1</span>)&#123;<span class="comment">//这说明obj只进栈一次</span></span><br><span class="line">            <span class="keyword">for</span>(child: obj.children)&#123;</span><br><span class="line">                <span class="built_in">push</span>(*child, $stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sweep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    index = $heap_top;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; $heap_end)&#123;<span class="comment">//遍历整个堆</span></span><br><span class="line">        <span class="keyword">if</span>(index.ref_cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">reclaim</span>(index);<span class="comment">//回收计数值为0的对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        index += index.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一位引用计数法">一位引用计数法</h5><p>是Sticky的极端，计数位只有一位（两个tag，一个MULTIPLE，一个UNIQUE），而且将计数位放在指针上，而非放在对象上</p><p><img src="/images/%E4%B8%80%E4%BD%8D%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.png" class="lazyload" data-srcset="/images/%E4%B8%80%E4%BD%8D%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="一位引用计数"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy_ptr</span><span class="params">(dest_ptr, src_ptr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">delete_ptr</span>(dest_ptr);</span><br><span class="line">    *dest_ptr = *src_ptr;</span><br><span class="line">    <span class="built_in">set_tag</span>(dest_ptr, MULTIPLE);</span><br><span class="line">    <span class="keyword">if</span>(src_ptr.tag == UNIQUE)&#123;</span><br><span class="line">        <span class="built_in">set_tag</span>(src_ptr, MULTIPLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_ptr</span><span class="params">(ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr.tag == UNIQUE)</span><br><span class="line">        <span class="built_in">reclaim</span>(*ptr);<span class="comment">//如果对象以前只被引用一次，那么这次就要被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点</p><ul><li>cache命中率高</li></ul><p>缺点</p><ul><li>同Sticky，而且更严重</li></ul><h5 id="部分标记清除法">部分标记清除法</h5><p>解决循环引用</p><p>只对可能会有循环引用的对象使用标记清除法，其他对象使用引用计数法</p><p>每个对象会有两个状态位（于是就有四个状态），分别为</p><ul><li>BLACK：绝对不是垃圾的对象（初始值）</li><li>WHILE：绝对是垃圾的对象</li><li>GRAY：搜索完毕的对象</li><li>HATCH：可能是循环垃圾的对象</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dec_ref_cnt</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    obj.ref_cnt--;</span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">delete</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(obj.color != HATCH)&#123;</span><br><span class="line">        obj.color = HATCH;</span><br><span class="line">        queue.<span class="built_in">push</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对放入队列的对象进行标记清除算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">new_obj</span><span class="params">(size)</span></span>&#123;</span><br><span class="line">    obj = <span class="built_in">pickup_chunk</span>(size);<span class="comment">//分配内存</span></span><br><span class="line">    <span class="keyword">if</span>(obj != null)&#123;<span class="comment">//如果分配成功</span></span><br><span class="line">        obj.color = BLACK;</span><br><span class="line">        obj.ref_cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!queue.<span class="built_in">empty</span>())&#123;<span class="comment">//说明现在空间不足，要回收垃圾，先看是否存在HATCH物体</span></span><br><span class="line">        <span class="built_in">scan_hatch_queue</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new_obj</span>(size);<span class="comment">//回收queue内后重新尝试分配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">allocation_fall</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scan_hatch_queue</span><span class="params">()</span></span>&#123;<span class="comment">//循环扫描队列，直至队列为空</span></span><br><span class="line">    obj = queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(obj.color == HATCH)&#123;</span><br><span class="line">        <span class="built_in">paint_gray</span>(obj);<span class="comment">//把obj和其孩子变为GRAY，孩子们引用值--</span></span><br><span class="line">        <span class="built_in">scan_gray</span>(obj);<span class="comment">//引用值&gt;0涂黑，等于0涂白</span></span><br><span class="line">        <span class="built_in">collect_while</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">scane_hatch_queue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paint_gray</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == (BLACK | HATCH))&#123;</span><br><span class="line">        obj.color = GRAY;</span><br><span class="line">        <span class="keyword">for</span>(child: obj.children)&#123;</span><br><span class="line">            (*child).ref_cnt--;</span><br><span class="line">            <span class="built_in">paint_gray</span>(*child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scan_gray</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == GRAY)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">paint_black</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            obj.color = WHITE;</span><br><span class="line">            <span class="keyword">for</span>(child: <span class="built_in">children</span>(obj))&#123;</span><br><span class="line">                <span class="built_in">scan_gray</span>(*child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paint_black</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">     obj.color = BLACK;</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))&#123;</span><br><span class="line">(*child).ref_cnt++</span><br><span class="line"><span class="keyword">if</span>((*child).color != BLACK)&#123;</span><br><span class="line"><span class="built_in">paint_black</span>(*child)            </span><br><span class="line">        &#125;          </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">collect_while</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == WHILE)&#123;</span><br><span class="line">        obj.color = BLACK;</span><br><span class="line">        <span class="keyword">for</span>(child: obj.children)&#123;</span><br><span class="line">            <span class="built_in">collect_while</span>(*child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reclaim</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点</p><ul><li>可以回收循环引用</li></ul><p>缺点</p><ul><li>一个对象要被查找三次，导致最大暂停时间+++</li></ul><h3 id="四：GC复制法">四：GC复制法</h3><p><em>想一下渲染中的双缓冲</em></p><p>先把整个空间分为等大的两部分，From和To，我们用From空间分配活动对象</p><p>GC时，把所有活动对象（递归）复制到其他空间（To空间），然后把原空间（From空间）所有对象回收，然后把空间互换</p><h4 id="评价-3">评价</h4><p>优点</p><ul><li>吞吐量大</li><li>分配速度快（Frist-fit）</li><li>不会发生碎片化（每次回收时，都会把所有对象重新排在From空间的开头，这个操作被称为<strong>压缩</strong>）</li><li>兼容缓存</li></ul><p>缺点</p><ul><li>堆效率低（因为二等分后，只能利用其中一半）</li><li>不兼容保守式GC</li><li>复制对象时要递归复制，会消耗栈，可能导致栈溢出</li></ul><h4 id="优化方案-3">优化方案</h4><h5 id="Cheney-GC复制法">Cheney GC复制法</h5><p>从递归复制改为迭代复制（基于队列的广度优先搜索）</p><p>下图搜索顺序：A BC DEFG HIJKLMNO</p><p>![Cheney GC](/images/Cheney GC.png)</p><p>优点</p><ul><li>从递归变成迭代，降低栈压力</li></ul><p>缺点</p><ul><li>不利于缓存（在上图，我们假设每个页最多存放三个块，我们发现有引用关系的对象很可能不在同一个块中）</li></ul><h5 id="近似深度优先搜索方法">近似深度优先搜索方法</h5><p>在页间做深度优先搜索，在页内做广度优先搜索</p><p>下图搜索顺序：ABC DHI EJK FLM GNO</p><p><img src="/images/%E8%BF%91%E4%BC%BC%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88.png" class="lazyload" data-srcset="/images/%E8%BF%91%E4%BC%BC%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="近似深度优先"></p><h5 id="多空间复制法">多空间复制法</h5><p>把空间分成十份，一个From，一个To，八个标记清除法</p><h3 id="五：标记压缩法">五：标记压缩法</h3><p>结合了标记清除法的标记+GC复制法的压缩</p><h4 id="Lisp2算法">Lisp2算法</h4><p><em>类比原地删除数组中某个元素</em></p><p>标记方法和标记清除法一样，标记后遍历堆，将所有活动对象压缩到左侧</p><p><img src="/images/Lisp2%E6%A0%87%E8%AE%B0.png" class="lazyload" data-srcset="/images/Lisp2%E6%A0%87%E8%AE%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Lisp2标记"></p><p><img src="/images/Lisp2%E5%8E%8B%E7%BC%A9.png" class="lazyload" data-srcset="/images/Lisp2%E5%8E%8B%E7%BC%A9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Lisp2压缩"></p><p><img src="/images/Lisp2%E7%BB%93%E6%9D%9F.png" class="lazyload" data-srcset="/images/Lisp2%E7%BB%93%E6%9D%9F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Lisp2结束"></p><p>优点</p><ul><li>比GC复制法堆效率高，比标记压缩法碎片少</li></ul><p>缺点</p><ul><li>三次遍历堆，效率过低</li></ul><h4 id="Two-Finger算法">Two-Finger算法</h4><p>这个算法优缺点很明显，所以先说优缺点，再谈实现</p><p>优点</p><ul><li>只需要两次遍历堆</li><li>不需要额外的forward指针（Lisp2的对号）</li></ul><p>缺点</p><ul><li>对象大小必须一致（可以与BiBOP结合使用）</li><li>压缩时破坏排序（一般有引用关系的对象会放在一起），于是不适合缓存</li></ul><p>在Lisp2算法中，可以说几乎每一个活动对象都需要移动，一般来说越靠近左边，移动的概率、距离越小，而越后面则越大（可以类比幽灵堵车）</p><p>我们能不能固定前面的对象，只移动后面的对象，从而实现压缩呢？（如果后面的对象和前面的对象大小一致，完全可以）</p><p><img src="/images/Two-Finger.png" class="lazyload" data-srcset="/images/Two-Finger.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Two-Finger"></p><h4 id="表格算法">表格算法</h4><p>算法分为三部：移动对象群，构建间隙表格，更新指针</p><ul><li>移动对象群（Lisp2一次移动一个对象，这个一次移动所有相邻对象）</li></ul><p><img src="/images/%E8%A1%A8%E6%A0%BC%E7%AE%97%E6%B3%95%E7%A7%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1%E7%BE%A4.png" class="lazyload" data-srcset="/images/%E8%A1%A8%E6%A0%BC%E7%AE%97%E6%B3%95%E7%A7%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1%E7%BE%A4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="表格算法移动对象群"></p><ul><li>构建间隙表格（设一个小格子尺寸为50）<ul><li>a到b：live在B开头，scan在D开头，于是将B的初始位置和B向左移动的距离$(100,100)$写到D处</li><li>b到c：<ul><li>先把间隙表格向后移动，移到FG之后，于是H处写入$(100,100)$</li><li>FG的初始位置和向左移动的距离为$(550,300)$，写入H之后（后是左边的G）</li></ul></li></ul></li></ul><p><img src="/images/%E6%9E%84%E5%BB%BA%E9%97%B4%E9%9A%99%E8%A1%A8%E6%A0%BC.png" class="lazyload" data-srcset="/images/%E6%9E%84%E5%BB%BA%E9%97%B4%E9%9A%99%E8%A1%A8%E6%A0%BC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="构建间隙表格"></p><ul><li>更新指针</li></ul><h4 id="ImmixGC算法">ImmixGC算法</h4><h3 id="六：保守式GC">六：保守式GC</h3><p>把疑似指针的一律视为指针</p><h4 id="不明确的根">不明确的根</h4><p>常见的根有</p><ul><li>寄存器</li><li>调用栈</li><li>全局变量空间</li></ul><p>在c++等语言里，<code>int</code>这种内置变量（非指针）和<code>void*</code>指针都存放在栈里，GC无法区分两者的区别，保守式GC就干脆不区分两者</p><p>存储着不确定对象的根，称为不明确的根，而基于这些根的GC算法，被称为保守式GC（ambiguous GC）</p><h4 id="检查内容">检查内容</h4><ul><li>是否<strong>位对齐</strong>（32位CPU，指针是4的倍数，64位CPU，指针是8的倍数）<ul><li>不对齐的一定是非指针</li></ul></li><li>是否指向堆内<ul><li>对象放在堆中，所以指针一定指向堆</li></ul></li><li>是否指向对象开头</li></ul><p>我们发现，有的时候我们会遇到一些格式与指针一致的非指针，我们称之为<strong>貌似指针的非指针（false pointer）</strong></p><p>在标记清除算法中，遇到这种貌似指针的非指针，会胡乱找到一个对象，我们不知道这个对象是活动对象还是非活动对象，所以<strong>一律视为活动对象</strong>，进行标记</p><p>注意：保守GC是只有当判断不出来到底是不是指针时才将其视为指针，而不是把所有对象都视为指针（迫不得已，凑合凑合用）</p><h4 id="评价-4">评价</h4><p>优点</p><ul><li>开发容易，程序员不需要意识到GC的存在</li></ul><p>缺点</p><ul><li>识别指针和非指针需要付出代价（检查内容）</li><li>将false pointer指向的错误对象视为活动对象，这些东西不会被用到，却进栈了</li><li>支持保守GC的算法不多</li></ul><h4 id="准确式GC">准确式GC</h4><p>正确的根（exact roots）可以精确地识别指针和非指针</p><p>基于正确的根的GC被称为<strong>准确式GC</strong></p><h5 id="构建正确的根的方法：打标签">构建正确的根的方法：打标签</h5><ul><li>32位CPU指针的值是4的倍数，那么其<strong>低2位</strong>一定是0</li><li>我们可以将所有非指针左移1位，然后将其<strong>低1位</strong>置为1</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打标签</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addTag</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    a = a &lt;&lt; <span class="number">1</span>;<span class="comment">//小心溢出，如果会溢出，就用一个更大的数据结构</span></span><br><span class="line">a = a|<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去标签（在使用时需要恢复成正常数值），而且使用完后还有再次打标签</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    a  = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了打标签，还可以专门构建一个只存放指针的根，比如一些使用虚拟机（VM）的语言</p><h5 id="评价-5">评价</h5><p>优点</p><ul><li>不需要判断是否为指针，没有判断带来的性能代价</li><li>堆中只会存在指针，可以适用于一些移动对象的GC算法</li></ul><p>缺点</p><ul><li>构建准确的根需要性能成本</li><li>语言使用时更麻烦</li></ul><h4 id="间接引用">间接引用</h4><p>为什么保守式GC不能移动对象？因为一个false pointer可能是一个非指针，移动会导致问题</p><h5 id="句柄">句柄</h5><p>如图，即使我们移动了堆中的对象，也却不会改变根内的内容</p><img src="/images/句柄.jpeg" class="lazyload" data-srcset="/images/句柄.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="句柄" style="zoom:50%;" /><p>优点：</p><ul><li>可以使用复制算法</li></ul><p>缺点：</p><ul><li>访问一个对象需要访问两次内存</li></ul><h4 id="MostlyCopyingGC">MostlyCopyingGC</h4><p>保守式GC复制算法</p><h4 id="黑名单">黑名单</h4><p>有的false pointer即使是非指针，错把他当指针用也可以找到一个对象（尽管这个过程是未定义的），如果这个非指针可以做到这个事，拿我们就把这个非指针指向的地址存放到<strong>黑名单</strong>中</p><p>黑名单中存放的是地址，如果在这些地址中分配空间，可能会导致未定义事件</p><p>所以在这些地址上分配对象时要十分小心，比如只能分配小对象、只能分配没有子对象的小对象，因为这些对象比较小，即使变成垃圾，被错误识别了，危害也比较小</p><h3 id="七：分代垃圾回收">七：分代垃圾回收</h3><p>引入了年龄这一概念，优先回收那些容易成为垃圾的对象</p><h4 id="年龄">年龄</h4><p>我们在引用计数法中提到过，绝大多数的对象生成后立刻会被回收，而被引用次数多多对象很难变成垃圾</p><p>于是我们引入年龄这一概念，初始为0，每经历一次GC算法，如果没有被回收，则年龄+1</p><p>我们发现年龄越大，说明对象越重要，越不容易被回收，于是年龄越大，参与回收的频率就越低</p><h4 id="评价-6">评价</h4><p>优点</p><ul><li>提高吞吐量</li></ul><p>缺点</p><ul><li>很多对象出生立刻回收只是一个经验，不适合所有程序，一旦某程序对象比较“长寿”，会起反作用</li></ul><h3 id="八：增量式垃圾回收">八：增量式垃圾回收</h3><p><em>想一想单核CPU并行的本质，就是将线程切分，来回切换</em></p><p>通过逐步推进垃圾回收来控制最大暂停时间，不一次执行完GC，而是执行一会mutator，执行一会GC</p><img src="/images/增量式GC.jpeg" class="lazyload" data-srcset="/images/增量式GC.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="增量式GC" style="zoom:50%;" /><ul><li>三色标记法</li></ul><h4 id="评价-7">评价</h4><p>优点</p><ul><li>降低最大暂停时间</li></ul><p>缺点</p><ul><li>降低了吞吐量</li></ul><h3 id="九：RC-Immix算法">九：RC Immix算法</h3><p><em>这是一个2013年的算法，听懂掌声</em></p><p>将合并型引用计数法和Immix组合到一起，改善了引用计数法的吞吐量</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大象无形UE笔记</title>
      <link href="/engine/%E5%A4%A7%E8%B1%A1%E6%97%A0%E5%BD%A2UE%E7%AC%94%E8%AE%B0/"/>
      <url>/engine/%E5%A4%A7%E8%B1%A1%E6%97%A0%E5%BD%A2UE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>UE学习笔记</h1><h2 id="基类">基类</h2><h3 id="UObject">UObject</h3><p>一切对象的基类。UE为UObject类提供了</p><ul><li>垃圾回收GC<ul><li>被<code>UProperty</code>标记的变量会自动进行生命周期管理</li><li>非UObject可以使用C++标准推荐的智能指针</li></ul></li><li>引用计数</li><li>反射</li><li>序列化<ul><li>资源的存储与加载</li></ul></li><li>自动检测默认变量的更改</li><li>自动变量初始化</li><li>与Editor的交互</li><li>运行时类型识别<ul><li>UE禁用了C++的<code>dynamic_cast</code>，你可以使用<code>Cast&lt;&gt;</code>替代</li></ul></li><li>网络复制</li></ul><h4 id="反射">反射</h4><p>反射分为静态反射和动态反射，C++没有该机制（尽管C++可以在编译时进行类型推导，但远不如Java那种<strong>Class对象</strong>的机制好用），于是UE自己做了一套</p><ul><li><p>功能</p><ul><li><p>运行时知道类、函数的所有相关信息（属性表，函数表），进而实现可视化编程（蓝图，面板）</p></li><li><p>通过函数名/类名+连续数据块访问对应函数/类</p></li></ul></li></ul><p>反射说白了就是将类、函数的信息（用哈希表）存储，运行时根据函数名、类名（key）查找信息，UE的反射是通过UBT和UHT实现的</p><ul><li>通过宏标记C++代码</li><li>UHT生成<code>.generated.h</code>和<code>.generated.cpp</code>文件</li><li>引擎初始化时注册反射信息</li></ul><h3 id="Actor">Actor</h3><p>一切实体的基类。能够被挂载组件（U）</p><h4 id="Component">Component</h4><p>基类：<code>UActorComponent</code></p><p>Component是一种属性+行为的集合</p><p><img src="/images/UEComponent.png" class="lazyload" data-srcset="/images/UEComponent.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UEComponent"></p><h4 id="通讯">通讯</h4><p>Actor之间要进行通讯，Unity可以通过获得GO引用、获得GO的组件的方式进行通讯</p><p>UE Actor的通讯方式有</p><ul><li>获取引用</li><li>Cast</li><li>接口</li><li>事件</li></ul><h3 id="Pawn">Pawn</h3><p>英语意思为棋子，指可以被操控的兵卒（可以被玩家操控，也可以被AI操控）</p><h4 id="Charactor">Charactor</h4><p>继承自Pawn，是一个更复杂的可操控角色，该角色的特点是有一种特殊的组件，Charactor Movement</p><h3 id="Controller">Controller</h3><p>控制器，负责控制Pawn、Charactor的行为</p><h2 id="命名原则">命名原则</h2><p>通过类的前缀来区分类的类型</p><table><thead><tr><th>前缀</th><th>意义</th></tr></thead><tbody><tr><td>F</td><td>纯C++类，通常为功能类</td></tr><tr><td>U</td><td>继承自UObject，但不继承自Actor</td></tr><tr><td>A</td><td>继承自Actor</td></tr><tr><td>S</td><td>Slate控件</td></tr><tr><td>H</td><td>HitResult相关类</td></tr><tr><td>T</td><td>模版类</td></tr><tr><td>E</td><td>枚举类</td></tr></tbody></table><h2 id="对象">对象</h2><h3 id="创建对象">创建对象</h3><ul><li>F类，使用new</li><li>U类，使用NewObject</li><li>A类，使用SpawnActor</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">FClass</span>();</span><br><span class="line"><span class="built_in">NewObject</span>&lt;UxxxClass&gt;();</span><br><span class="line"><span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AxxxClass&gt;();</span><br></pre></td></tr></table></figure><h3 id="UObject-2">UObject</h3><p>生命周期</p><h4 id="创建">创建</h4><ul><li>内存分配，返回一个分配好尺寸但没有初始化的指针（你steam下游戏也是先清出一片区域，再正式下载）</li><li>对象构建<ul><li>创建<code>FObjectInitializer</code></li><li>将<code>FObjectInitializer</code>作为参数传递给函数指针<code>ClassConstructor</code>，得到对象</li></ul></li></ul><h4 id="反序列化">反序列化</h4><ul><li>获取类信息<code>GetClass</code></li><li>判断类信息是否载入，若没有载入则进行预载</li><li>载入名字、Outer、类信息（类信息保存在ObjClass对象中，感觉和Java的类对象机制很接近）</li><li>载入脚本成员变量信息</li></ul><p>反序列化的规则：</p><ul><li>只反序列化<code>UPROPERTY</code>标记，且不等于默认值的数据</li><li>先创建出对象，再反序列化（还原数据）</li><li>对象具有所属关系</li><li>若一个对象所有信息和原始对象相同，尽管他们在内存的位置不同（指针值不同），该对象就是原始对象</li></ul><h4 id="释放消亡">释放消亡</h4><p>UObject无法手动释放，但是可以被请求，将其标记后等待引擎将其释放</p><p>GC分为两步，析构、回收</p><h2 id="蓝图">蓝图</h2><ul><li>UPROPERTY：注册成员变量到蓝图</li><li>UFUNCTION：注册函数到蓝图</li></ul><h2 id="引擎基础功能">引擎基础功能</h2><h3 id="正则表达式">正则表达式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Regex.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function">FString <span class="title">TextStr</span><span class="params">(<span class="string">&quot;This is a string&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">FRegexPattern <span class="title">TestPattern</span><span class="params">(TEXT(<span class="string">&quot;C.+H&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">FRegexMatcher <span class="title">TestMatcher</span><span class="params">(TestPattern, TextStr)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(TestMatcher.<span class="built_in">FindNext</span>())&#123;</span><br><span class="line">  <span class="built_in">UE_LOG</span>(MyLog, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;找到匹配内容 %d -%d&quot;</span>), </span><br><span class="line">        TestMatcher.<span class="built_in">GetMatchBeginning</span>(),</span><br><span class="line">        TestMatcher.<span class="built_in">GetMatchEnding</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径">路径</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取xxx目录路径</span></span><br><span class="line"><span class="function">FString <span class="title">FPaths::xxxDir</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断文件是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FPaths::FileExists</span><span class="params">(<span class="type">const</span> FString&amp; InPath)</span></span>;</span><br><span class="line"><span class="comment">//相对路径转化为绝对路径</span></span><br><span class="line"><span class="function">FString <span class="title">ConvertRelativePathToFull</span><span class="params">(<span class="type">const</span> FString&amp; BasePath, FString&amp;&amp; InPath)</span>；</span></span><br></pre></td></tr></table></figure><h3 id="XML">XML</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">name</span>=<span class="string">&quot;Ami&quot;</span> <span class="attr">age</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">line</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span>&gt;</span>world<span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>FXmlFile</code>或者<code>FastXML</code>操作xml文件</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FString xmlFilePath = <span class="built_in">TEXT</span>(<span class="string">&quot;xxx/Test.xml&quot;</span>);</span><br><span class="line">FXmlFile* xml = <span class="keyword">new</span> <span class="built_in">FXmlFile</span>();</span><br><span class="line">xml-&gt;<span class="built_in">LoadFile</span>(xmlFilePath);</span><br><span class="line">FXmlNode* RootNode = xml-&gt;<span class="built_in">GetRootNode</span>();</span><br><span class="line">FString from_content = RootNode-&gt;<span class="built_in">FindChildNode</span>(<span class="string">&quot;from&quot;</span>)-&gt;<span class="built_in">GetContent</span>();</span><br><span class="line">FString note_name  = RootNode-&gt;<span class="built_in">GetAttribute</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">TArray&lt;FXmlNode*&gt; list_node = RootNode-&gt;<span class="built_in">FindChildNode</span>(<span class="string">&quot;list&quot;</span>)-&gt;<span class="built_in">GetChildrenNodes</span>();</span><br></pre></td></tr></table></figure><h3 id="JSON">JSON</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FString JsonStr = <span class="string">&quot;[&#123;\&quot;author\&quot;: \&quot;Tim\&quot;&#125;, &#123;\&quot;age\&quot;: \&quot;100\&quot;&#125;]&quot;</span>;</span><br><span class="line">TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParsed;</span><br><span class="line">TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::<span class="built_in">Create</span>(JsonStr);</span><br><span class="line"><span class="type">bool</span> BFlag = FJsonSerializer::<span class="built_in">Deserialize</span>(JsonReader, JsonParsed);</span><br><span class="line">&#123;</span><br><span class="line">  FString FStringAutor = JsonParsed[<span class="number">0</span>]-&gt;<span class="built_in">AsObject</span>()-&gt;<span class="built_in">GetStringField</span>(<span class="string">&quot;autor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件">文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FPlatformFileManager::<span class="built_in">Get</span>()-&gt;<span class="built_in">GetPlatformFile</span>();</span><br></pre></td></tr></table></figure><h3 id="GConfig">GConfig</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//写配置</span><br><span class="line">GConfig-&gt;SetString(TEXT(&quot;Section&quot;), TEXT(&quot;Key&quot;), TEXT(&quot;Value&quot;), FPaths::xxxDir()/&quot;Config.ini&quot;);</span><br><span class="line">//读配置</span><br><span class="line">FString Result;</span><br><span class="line">GConfig-&gt;GetString(TEXT(&quot;Section&quot;), TEXT(&quot;Key&quot;), Result, FPaths::xxxDir()/&quot;Config.ini&quot;);</span><br></pre></td></tr></table></figure><h3 id="UE-LOG">UE_LOG</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UE_LOG</span>(log分类，log类型，log内容)；</span><br></pre></td></tr></table></figure><h3 id="字符串">字符串</h3><table><thead><tr><th></th><th>能否修改</th><th>大小写敏感</th><th>语意</th></tr></thead><tbody><tr><td>FName</td><td>无法修改</td><td>不敏感</td><td>名字，在整个字符串表只出现一次</td></tr><tr><td>FText</td><td>无法修改</td><td>敏感</td><td>被显示的字符串</td></tr><tr><td>FString</td><td>能够修改</td><td>敏感</td><td>普通字符串</td></tr></tbody></table><h3 id="图片">图片</h3><p><code>../../imagesrWrapper</code></p><h2 id="模块">模块</h2><h3 id="模块-2">模块</h3><p>模块就像Unity的Package，用于整理文件结构，便于编译</p><p>一个模块包含</p><ul><li><code>Public</code>文件夹<ul><li><code>.h</code>文件</li></ul></li><li><code>Private</code>文件夹<ul><li><code>.cpp</code>文件</li></ul></li><li><code>模块名.build.cs</code>文件（继承自<code>ModuleRules</code>类）</li></ul><h3 id="UBT">UBT</h3><p><code>Unreal Build Tool.cs</code>中有Main函数，主要做三个功能</p><ol><li>收集信息：环境变量、目录信息等</li><li>确定生成的目标类型</li><li>生成构建</li></ol><h3 id="UHT">UHT</h3><p><code>Unreal Header Tool</code>，一个基于引擎代码，但不需要引擎完全启动，编译后得到一个<code>.exe</code>文件的程序</p><h2 id="引擎核心">引擎核心</h2><p><a href="https://dev.epicgames.com/community/learning/paths/0w/beginplay">UE Begin Play</a></p><h3 id="内存分配">内存分配</h3><p>提供了多套内存分配器，其中包含TBB（TBB的内存分配一大特点就是可以通过代理的方式全局替换new、malloc等操作符），TBB见《高性能C+++》笔记，那边有详细介绍</p><p>TBB内存分配主要包括</p><ul><li>LTS，线程内存池，每个线程会独立拥有一个局部的内存池，互不影响，但最后需要归约</li><li>缓存对齐，通过在变量间填充大量无效信息，使得不同变量处于不同缓存行中，于是避免了假共享问题</li></ul><h3 id="引擎初始化">引擎初始化</h3><ul><li>PreInit<ul><li>接收cmd命令，判断启动模式</li><li>初始化游戏主线程（将当前线程当作主线程）</li><li>初始化随机数</li><li>初始化TaskGraph系统，设置线程数量，启动线程池</li><li>调用<code>LoadCoreModules</code>，启动<code>CoreUObject</code>模块</li><li>启动引擎、渲染、动画蓝图、Slate、贴图压缩、地形模块</li></ul></li><li>Init<ul><li>各个模块初始化，并执行所有<code>PostEngineInit</code>函数</li><li>进入主循环</li></ul></li></ul><h3 id="主循环">主循环</h3><p>UE是一个多线程引擎，将游戏逻辑、渲染、声音、IO等系统分离</p><p>主线程是游戏逻辑线程，内含一个while循环，循环内有一个<code>Trick</code>，可以类比Unity的Update</p><p>渲染线程数游戏逻辑线程的从属，接收来自主线程的命令，进行渲染绘制。渲染线程比逻辑线程慢一帧</p><h3 id="并发并行">并发并行</h3><ul><li><p>线程</p></li><li><p>并行</p></li><li><p>并发</p></li><li><p>Task Graph</p><ul><li>UE最强大的多线程框架，将任务抽象为Task</li><li>UE内部使用了TBB，感觉这部分内容和TBB基本一致</li><li>详情见<code>FBaseGraphTask</code>、<code>FTaskThreadBase</code></li></ul></li><li><p><code>FRunnableThread+FRunnable</code></p><ul><li>详情见<code>QueuedThreadPoolWrapper.h</code>，并不是很好用</li></ul></li></ul><h2 id="渲染">渲染</h2><h3 id="渲染线程">渲染线程</h3><p>UE的游戏线程和渲染线程分离（事实上现在基本所有引擎都这样），渲染线程是游戏线程的“附庸”</p><p>在引擎Init时，会调用<code>StartRenderingThread</code>函数，启动渲染线程</p><p>该函数主要做：</p><ol><li>创建渲染线程</li><li>从TaskGraph中取任务</li><li>注册渲染线程</li><li>注册Trick</li></ol><h3 id="运行">运行</h3><p>渲染线程的主要执行内容在<code>RenderingThreadMain</code>中，游戏线程可以通过<code>EQUEUE_Render_COMMAND</code>等宏命令向渲染线程的TaskMap中添加渲染任务，渲染线程提取这些命令后将其添加到<code>RHICommandList</code>中，最后传递到GPU中</p><p><img src="/images/%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E4%B8%8ERHI.png" class="lazyload" data-srcset="/images/%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E4%B8%8ERHI.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="渲染线程与RHI"></p><h3 id="RHI">RHI</h3><p>RHI（Render Hardware Interface），对图形库的一种封装，以供上层使用</p><table><thead><tr><th></th><th>UE5中含义</th></tr></thead><tbody><tr><td>FRenderResource</td><td>渲染线程中的资源，如贴图、顶点buffer、顶点id</td></tr><tr><td>FRHIResource</td><td>GPU侧的资源，如Texture2D、3D、Cube</td></tr><tr><td>DynamicRHI</td><td>所有图形API适配器的基类</td></tr><tr><td>RHI</td><td></td></tr><tr><td>RHIContext</td><td>RHI命令上下文</td></tr><tr><td>RHICommandList</td><td>RHI指令队列</td></tr><tr><td>FRHICommandListExecutor</td><td>将RHI指令翻译为图形API</td></tr></tbody></table><h3 id="多线程">多线程</h3><h4 id="DX11">DX11</h4><p>DX11尝试从硬件层面解决多线程渲染，提供了两种设备上下文：即时上下文（Immediate Context）和延迟上下文（Deferred Context）</p><p>延迟上下文多线程并行，最后将生成的CommandList归约到即时上下文中，由即时上下文Execute</p><p>对于某些支持硬件级加速的驱动，延迟上下文可以将CommandList也直接提交给图形驱动</p><p><img src="/images/DX11%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" class="lazyload" data-srcset="/images/DX11%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DX11多线程"></p><p>DX11的多线程，感觉就是一种简单的异步，仅仅是加速了指令录制，减少了等待</p><h4 id="DX12">DX12</h4><p>取消了DX11的渲染上下文，不再使用DrawCall，而是直接使用CommandList来调用图形驱动</p><ol><li>DX12渲染线程并行进行指令录制，生成一些命令列表（CommandList）</li><li>然后将这些命令列表提交给命令队列（CommandQueue）中</li><li>命令队列根据指令类型，将指令放入不同的GPU引擎中</li></ol><p>命令队列有三种：复制队列（Copy Queue）、计算队列（Compute Queue）、3D队列</p><p>GPU引擎有三种：复制引擎、计算引擎、3D引擎</p><p>命令队列和GPU引擎都可以并行执行</p><img src="/images/DX12多线程.png" class="lazyload" data-srcset="/images/DX12多线程.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DX12多线程" style="zoom: 50%;" /><h3 id="渲染管线">渲染管线</h3><p><img src="/images/UE5RenderingPipeline.jpg" class="lazyload" data-srcset="/images/UE5RenderingPipeline.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UE5RenderingPipeline"></p><h2 id="物理">物理</h2><p>UE5使用Chaos替代PhysX作为新的物理引擎</p><table><thead><tr><th>Chaos</th><th>PhysX</th></tr></thead><tbody><tr><td>基于位置（PBD）</td><td>基于速度</td></tr><tr><td>支持大世界坐标（LWC）</td><td>不支持</td></tr><tr><td>支持网络同步</td><td>不支持</td></tr></tbody></table><h3 id="异步">异步</h3><p>UE5可以启用异步物理模拟，物理线程会作为单独的线程运行（类似渲染线程）</p><p>由于是独立线程，物理模拟可以以固定的间隔运行，既可以提高精确度，也方便C/S网络同步</p><p>但开启异步后物理线程无法即时获取游戏线程的输入，有可能影响游戏逻辑</p><h3 id="功能">功能</h3><ul><li>布料</li><li>破坏</li><li>载具</li><li>场</li></ul><h3 id="PBD">PBD</h3><p><a href="https://matthias-research.github.io/pages/publications/PBDBodies.pdf">论文</a></p><h3 id="大世界">大世界</h3><p>World partition</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nabla算子</title>
      <link href="/math/Nabla%E7%AE%97%E5%AD%90/"/>
      <url>/math/Nabla%E7%AE%97%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1>Nabla算子</h1><p><a href="https://www.bilibili.com/video/BV1a541127cX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a72e0e57d1aa2c57c64020832e1cde7e">参考</a></p><p>$\nabla$：Nabla算子，将数量场变成向量场</p><ul><li><p>当其作用于函数，如$\nabla F(x)$，意思为求该函数梯度</p></li><li><p>当其点乘函数，如$\nabla \cdot F(x)$，意思为求该函数的散度</p></li><li><p>当其叉乘（三维）函数，如$\nabla \times F(x)$，意思为求该函数的旋度</p></li></ul><h3 id="函数可视化">函数可视化</h3><p>对于函数$f(x,y)=x^2+y^2$，我们有两种可视化方法，第一种叫做图像：<br>$$<br>{(\vec{x}, f(\vec{x}))|\vec{x} \in D}<br>$$<br><img src="/images//%E5%9B%BE%E5%83%8F.png" class="lazyload" data-srcset="/images//%E5%9B%BE%E5%83%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图像"></p><p>第二种叫做等值面:<br>$$<br>{\vec{x}|f(\vec{x})=c}<br>$$<br><img src="/images//%E7%AD%89%E5%80%BC%E9%9D%A2.png" class="lazyload" data-srcset="/images//%E7%AD%89%E5%80%BC%E9%9D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="等值面"></p><p>等值面只需要二维空间就能表示三维数据</p><h3 id="梯度">梯度</h3><p>Nabla算子其实是一个向量：<br>$$<br>\nabla =\left[</p><p>\frac{\partial }{\partial x_1}, \frac{\partial }{\partial x_2 },\cdots,\frac{\partial }{\partial x_n }</p><p>\right]^{T}<br>$$<br>Nabla算子作用于函数（标量场），可以将标量场转化为向量场，我们称该向量场为<strong>梯度</strong><br>$$<br>\nabla f=<br>\left[<br>\begin{array}{c}<br>\frac{\partial f}{\partial x_1}\\<br>\frac{\partial f}{\partial x_2}\\<br>\vdots\\<br>\frac{\partial f}{\partial x_n}\\<br>\end{array}<br>\right]<br>$$<br><img src="/images//%E6%A2%AF%E5%BA%A6.png" class="lazyload" data-srcset="/images//%E6%A2%AF%E5%BA%A6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="梯度"></p><p>梯度垂直于等值面，意义为变化最快的方向（图中黄色箭头）</p><h3 id="散度">散度</h3><p>我们知道向量和向量间可以进行点乘，其结果为一个标量，那么Nabla算子和向量相乘，我们称所得到的标量为<strong>散度</strong><br>$$<br>\vec{f}=\left[<br>\begin{array}{c}<br>f_1\\<br>f_2\\<br>\vdots\\<br>f_n\\<br>\end{array}<br>\right]<br>$$</p><p>$$<br>\nabla \cdot \vec{f}=\frac{\partial f_1}{\partial x_1}+\frac{\partial f_2}{\partial x_2}+\cdots +\frac{\partial f_n}{\partial x_n}<br>$$</p><p><img src="/images//%E6%95%A3%E5%BA%A6.png" class="lazyload" data-srcset="/images//%E6%95%A3%E5%BA%A6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="散度"></p><p>上图的白色箭头表示一个向量，我们发现这些箭头都是在朝外扩散，而散度就是用来衡量箭头向外扩散的程度</p><p>散度的物理意义是通量的局部描述。我们在图上画一个圈，我们发现会有向量进入这个圈，也有向量离开这个圈，那么进出之合，我们就称之为通量（比如磁通量），我们将通量除以圈的面积，就得到了通量的体密度。若这个圆取无穷小，那么体密度的极限值就是该点的散度</p><p>是不是突然很好理解麦克斯韦方程中$\nabla \cdot \mathbf{E}=0$的原因了？</p><p><img src="/images//%E7%94%B5%E8%8D%B7%E5%9C%BA%E6%BA%90.png" class="lazyload" data-srcset="/images//%E7%94%B5%E8%8D%B7%E5%9C%BA%E6%BA%90.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="电荷场源"></p><p>其实这个公式就是高斯公式</p><p><img src="/images//Gauss%E5%85%AC%E5%BC%8F.png" class="lazyload" data-srcset="/images//Gauss%E5%85%AC%E5%BC%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Gauss公式"></p><h3 id="旋度">旋度</h3><p>向量不仅可以点乘，其实也可以叉乘，两个三维向量叉乘，能得到一个3x3的行列式。最后得到一个矩阵，我们称为<strong>旋度</strong></p><p><img src="/images//%E6%97%8B%E5%BA%A6.png" class="lazyload" data-srcset="/images//%E6%97%8B%E5%BA%A6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="旋度"></p><p>旋度的物理意义就是环量的面密度。现在有一个在旋转的场，我们在场上画一个圈，场在这个圈内会做功，这个功就是环量，我们求出单位面积上环量，这个极限值描述了漩涡的强度。旋度就是旋转最快的方向</p><p><img src="/images//%E6%97%8B%E5%BA%A62.png" class="lazyload" data-srcset="/images//%E6%97%8B%E5%BA%A62.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="旋度2"></p><p><img src="/images//%E6%96%AF%E6%89%98%E5%85%8B%E6%96%AF%E5%85%AC%E5%BC%8F.png" class="lazyload" data-srcset="/images//%E6%96%AF%E6%89%98%E5%85%8B%E6%96%AF%E5%85%AC%E5%BC%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="斯托克斯公式"></p><h3 id="梯度的散度">梯度的散度</h3><p>nabla算子和自己做内积，于是会得到一个数量场，意义为求梯度的散度</p><p>这个操作为$\nabla\cdot \nabla$，也可以写作$\nabla^2、\nabla^T \nabla$，但为了避免歧义，我们引入了一个新的符号，拉普拉斯算子<br>$$<br>\Delta=\nabla \cdot\nabla<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复变函数</title>
      <link href="/math/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"/>
      <url>/math/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>复变函数</h1><h2 id="复变函数">复变函数</h2><h3 id="复数">复数</h3><p>复数可以表示为实数和纯虚数的和</p><p>代数式：<br>$$<br>z=x+\mathrm{i}y<br>$$</p><ul><li>x：实部，记为Re z</li><li>y：虚部，记为Im z</li></ul><p>复平面：</p><p><img src="/images/%E5%A4%8D%E5%B9%B3%E9%9D%A2.png" class="lazyload" data-srcset="/images/%E5%A4%8D%E5%B9%B3%E9%9D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="复平面"></p><p>极坐标下<br>$$<br>\begin{cases}<br>\rho=\sqrt{x^2+y^2} \<br>\varphi=\arctan (y/x)<br>\end{cases}<br>$$</p><p>$$<br>\begin{cases}<br>x=\rho \cos \varphi  \<br>y=\rho \sin \varphi<br>\end{cases}<br>$$</p><p>于是复数可以表示为三角式<br>$$<br>z=\rho (\cos \varphi+ \mathrm{i}\sin \varphi )=\rho e^{\mathrm{i}\varphi}<br>$$</p><ul><li><p>$\rho$：模，记为$|z|$</p></li><li><p>$\varphi$：辐角，记为Arg z</p></li><li><p>复数的辐角有无穷多个，彼此间差$2k\pi$，于是我们约定在$[0,2\pi)$的辐角为主辐角</p></li><li><p>复数<strong>零</strong>的辐角没有意义</p></li></ul><h4 id="复数的运算">复数的运算</h4><p>加减（满足交换律、结合律）<br>$$<br>z_1\pm z_2=(x_1 \pm x_2)+\mathrm{i}(y_1\pm y_2)<br>$$<br>乘（满足交换律、结合律、分配律）<br>$$<br>z_1z_2=(x_1x_2-y_1y_2)+\mathrm{i}(x_1y_2-x_2y_1)<br>$$</p><p>$$<br>z_1z_2=\rho_1 \rho_2 e^{\mathrm{i}(\varphi_1+\varphi_2)}<br>$$</p><p>除（是乘的逆运算）<br>$$<br>\frac{z_1}{z_2}=\frac{x_1x_2+y_1y_2}{x_2^2+y_2^2}+\mathrm{i}\frac{x_2y_1+x_1y_2}{x_2^2+y_2^2}<br>$$</p><p>$$<br>\frac{z_1}{z_2}=\frac{\rho_1}{\rho_2} e^{\mathrm{i}(\varphi_1-\varphi_2)}<br>$$</p><p>n次幂<br>$$<br>z^n=\rho^n e^{\mathrm{i}n\varphi}<br>$$<br>n次根式<br>$$<br>\sqrt[n]{z}=\sqrt[n]{\rho}\ e^{\mathrm{i}\frac{\varphi}{n}}<br>$$</p><h3 id="复变函数-2">复变函数</h3><p>$$<br>\omega=f(z)<br>$$</p><ul><li>z为$\omega$的宗量，$z\in E$</li></ul><h4 id="区域">区域</h4><p>在解析函数论中，函数的定义域不是一般的点集，而是满足一定条件的点击，称为区域，用B表示</p><ul><li>邻域：以复数$z_0$为圆心，画一个半径为任意小正实数的圆，圆内所有点被称为$z_0$的邻域</li><li>内点：若某点及其邻域都属于点集E，那么该点是点集E的内点</li><li>外点：若某点及其邻域都不属于点集E，那么该点是点集E的外点</li><li>边界点：若某点及其邻域既有属于点集E的点，也有不属于的点，那么该点是点集E的边界点</li><li>边界线：全体边界点构成边界线</li></ul><p>区域是满足以下两条件的点集</p><ul><li>全由内点组成</li><li>具有连通性，点集内任意两点都联通，且路径上的点都在该点集</li></ul><p>闭区域：区域+边境线组成的点集</p><h4 id="连续">连续</h4><p>$$<br>当z\rightarrow z_0时，f(z)\rightarrow f(z_0)<br>$$</p><h3 id="导数">导数</h3><p>实变数$\Delta x$只能沿着实轴趋近0，但复变数$\Delta z$可以沿着复平面上任意一曲线逼近0</p><p>若极限<br>$$<br>\lim _{\Delta z \rightarrow 0}\frac{f(z+\Delta z)-f(z)}{\Delta z}<br>$$<br>存在，且与$\Delta z \rightarrow 0$的方式无关，则称函数$\omega=f(z)$在$z$点可导（也称单演），这个极限被称为函数在该点的导数（也叫微商）</p><ul><li>若$\Delta z$沿着平行于实轴方向逼近0，$\Delta y \equiv 0,\Delta z=\Delta x \rightarrow 0$</li></ul><p>$$<br>\lim _{\Delta z \rightarrow 0}\frac{\Delta\omega}{\Delta z}=\frac{\partial v}{\partial x}+\mathrm{i}\frac{\partial u}{\partial x}<br>$$</p><ul><li>若$\Delta z$沿着平行于虚轴方向逼近0，$\Delta x \equiv 0,\Delta z=\mathrm{i}\Delta y \rightarrow 0$</li></ul><p>$$<br>\lim _{\Delta z \rightarrow 0}\frac{\Delta\omega}{\Delta z}=\frac{\partial v}{\partial y}-\mathrm{i}\frac{\partial u}{\partial y}<br>$$</p><p>要想让在该点可导，这两个极限必须同时存在且相等，于是<br>$$<br>\begin{cases}<br>\frac{\partial u}{\partial x}=\frac{\partial v}{\partial y} \<br>\frac{\partial v}{\partial x}=-\frac{\partial u}{\partial y}<br>\end{cases}<br>$$<br>这个方程被称为<strong>柯西-黎曼方程</strong>，或者<strong>柯西-黎曼条件（C-R条件）</strong>，这个方程是复变函数可导的<strong>必要条件</strong></p><p>充要条件为：函数的偏导存在且连续，且满足C-R条件</p><h3 id="解析函数">解析函数</h3><p>若函数$f(z)$在点$z_0$及其邻域上处处可导，则称$f(z)$在$z_0$点<strong>解析</strong></p><p>若$f(z)$在区域B上处处解析，那么称$f(z)$是区域B上的解析函数</p><p>解析函数是一类具有特殊性质的复变函数</p><h4 id="正交性">正交性</h4><p>若函数$f(z)=u+\mathrm{i}v$在区域B上解析，则<br>$$<br>u(x,y)=C_1,v(x,y)=C_2<br>$$<br>是B上的两组正交曲线族，即梯度$\nabla u$（其直角坐标分量为$\frac{\partial u}{\partial x}$和$\frac{\partial u}{\partial y}$）与梯度$\nabla v$（其直角坐标分量为$\frac{\partial v}{\partial x}$和$\frac{\partial v}{\partial y}$）正交</p><h4 id="调和函数">调和函数</h4><p>若函数$f(z)=u+\mathrm{i}v$在区域B上解析，则$u,v$均为B上的<strong>调和函数</strong></p><ul><li>若函数$H(x,y)$存在二阶连续偏导数，且满足拉普拉斯方程$\nabla^2H=0$，则该函数为调和函数</li></ul><h4 id="应用">应用</h4><p>给定一个二元的调和函数，将其看作某个解析函数的实部，利用C-R条件求出对应的虚部，于是就构建了一个解析函数</p><ul><li>曲线积分法</li><li>凑全微分显式法</li><li>不定积分法</li></ul><h3 id="多值函数">多值函数</h3><p>根式函数、对数函数就是一种多值函数</p><p>黎曼面</p><h2 id="傅里叶变换">傅里叶变换</h2><h3 id="傅里叶级数">傅里叶级数</h3><p>我们已经学过，周期函数可以唯一展开为以三角函数为基本函数族的级数</p><p>这些三角函数满足任意两个函数的乘积在一个周期内的积分为0，即正交性</p><p>利用三角函数的正交性，我们求出展开系数，这个系数被称为傅里叶系数</p><p>这个三角函数族是<strong>完备</strong>的</p><ul><li>完备的充要条件：任意一平方可积函数的傅里叶级数均值收敛于它本身</li></ul><h4 id="傅里叶级数收敛定理">傅里叶级数收敛定理</h4><p>若一周期函数$f(x)$满足<strong>狄里希利条件</strong>，则函数的傅里叶级数收敛（也就是函数可以用傅里叶级数表示），且收敛值为</p><ul><li>当$x$是$f(x)$的连续点时，级数收敛于$f(x)$</li><li>当$x$是$f(x)$的间断点时，级数收敛于$\frac{1}{2}[f(x-0)+f(x+0)]$</li></ul><h4 id="傅里叶级数的复数表示">傅里叶级数的复数表示</h4><p>$$<br>\sum^{\infty}_{n=-\infty}c_ne^{\mathrm{i}\frac{n\pi x}{l}}<br>$$</p><p>$$<br>c_n=\frac{1}{2l}\int^l_{-l}f(x)e^{-\mathrm{i}\frac{n\pi x}{l}}\mathrm{d}x<br>$$</p><h3 id="傅里叶积分">傅里叶积分</h3><p>一般来说非周期函数不能展开为傅里叶级数，但是如果我们将这个函数视为周期趋近于无穷的函数<br>$$<br>f(x)=\int_0^{\infty}A(\omega)\cos \omega \mathrm{d}\omega+\int_0^{\infty}B(\omega)\sin \omega \mathrm{d}\omega<br>$$<br>其中<br>$$<br>A(\omega)=\frac{1}{\pi}\int^{\infty}_{-\infty}f(\xi)\cos \omega\xi\mathrm{d}\xi<br>$$</p><p>$$<br>B(\omega)=\frac{1}{\pi}\int^{\infty}_{-\infty}f(\xi)\sin \omega\xi\mathrm{d}\xi<br>$$</p><p>上面的公式是<strong>傅里叶积分</strong>，这两个参数函数称为<strong>傅里叶变换式</strong></p><h4 id="傅里叶积分定理">傅里叶积分定理</h4><p>若函数$f(x)$在区间$(-\infty,\infty)$满足</p><ul><li>$f(x)$在任意一有限区间内满足<strong>狄里希利条件</strong></li><li>在$(-\infty,\infty)$绝对可积（即$\int^{\infty}_{-\infty}|f(x)|\mathrm{d}x$收敛）</li></ul><p>则$f(x)$可以用傅里叶积分表示，且积分值为$\frac{1}{2}[f(x-0)+f(x+0)]$</p><h4 id="傅里叶积分的复数表示">傅里叶积分的复数表示</h4><p>$$<br>f(x)=\int^{\infty}<em>{-\infty}F(\omega)e^{\mathrm{i}\omega x}\mathrm{d}\omega<br>=\frac{1}{\sqrt{2\pi}}\int^{\infty}</em>{-\infty}F(\omega)e^{\mathrm{i}\omega x}\mathrm{d}\omega<br>$$</p><p>$$<br>F(\omega)=<br>\begin{cases}<br>\frac{1}{2}[A(\omega)-\mathrm{i}B(\omega)] &amp; (\omega\ge 0) \<br>\frac{1}{2}[A(|\omega|)+\mathrm{i}B(|\omega|)] &amp; (\omega&lt; 0)<br>\end{cases}<br>$$</p><p>$$<br>F(\omega)=\frac{1}{\sqrt{2\pi}}\int^{\infty}_{-\infty}f(x)[e^{\mathrm{i}\omega x}]^{*}\mathrm{d}\omega<br>$$</p><ul><li>这里的$[]^*$是复数的共轭的意思，实际上就是直接给虚部加一个符号</li></ul><p>我们称$f(x)$为<strong>原函数</strong>，$F(\omega)$为<strong>像函数</strong></p><h5 id="例题">例题</h5><p>求矩阵脉冲函数$f(t)=h \ rect (t/2T)$的傅里叶变换<br>$$<br>\mathscr F[h \ rect (t/2T)]<br>=\frac{1}{\sqrt{2\pi}}\int^{\infty}<em>{-\infty}h \ rect (t/2T)e^{-\mathrm{i}\omega t}\mathrm{d}t \<br>=\frac{h}{2\pi}\int^{T}</em>{-T}e^{-\mathrm{i}\omega t}\mathrm{d}t \<br>=-\frac{h}{2\pi \mathrm{i}\omega}e^{-\mathrm{i}\omega t}|^{T}_{-T} \<br>=\frac{h}{\pi}\frac{\sin \omega T}{\omega}<br>$$</p><h4 id="傅里叶变化的基本性质">傅里叶变化的基本性质</h4><p>导数定理<br>$$<br>\mathscr F[f’(x)]=\mathrm{i}\omega F(\omega)<br>$$<br>积分定理<br>$$<br>\mathscr F[\int^{(x)}f(\xi)\mathrm{d}\xi]=\frac{1}{\mathrm{i}\omega} F(\omega)<br>$$<br>相似性定理<br>$$<br>\mathscr F[f(ax)]=\frac{1}{a} F(\frac{\omega}{a})<br>$$<br>延迟定理<br>$$<br>\mathscr F[f(x-x_0)]=e^{-\mathrm{i}\omega x_0} F(\omega)<br>$$<br>位移定理<br>$$<br>\mathscr F[e^{\mathrm{i}\omega_0 x} f(x)]=f(\omega-\omega_0)<br>$$<br>卷积定理<br>$$<br>\mathscr F[f_1(x)*f_2(x)]=2\pi F_1(\omega)F_2(\omega)<br>$$</p><h2 id="拉普拉斯变换">拉普拉斯变换</h2><h3 id="拉普拉斯变换-2">拉普拉斯变换</h3><p>傅里叶积分和傅里叶变换存在的条件是原函数在任意一有限区间满足狄里希利条件，且在$(-\infty,\infty)$上绝对可积，这实际上是一个相当苛刻的条件，导致很多常见函数都不满足</p><p>而拉普拉斯变换是一种条件更宽泛的变换</p><p>拉普拉斯变换常用于初始值问题，即知道某个物理量在初始时刻$t=0$的值$f(0)$，求一段时刻后的情况$f(t)$</p><p>我们置$f(t)=0$，构造一个函数$g(t)$，使得</p><p>$$<br>g(t)=e^{-\sigma t}f(t)<br>$$</p><ul><li>其中$e^{-\sigma t}$为收敛因子，正实数$\sigma$取特别大，以保证$g(t)$在$(-\infty,\infty)$绝对可积</li></ul><p>于是我们对$g(t)$进行傅里叶变换，得到<br>$$<br>G(\omega)=\frac{1}{2\pi}\int^{\infty}<em>{0}f(t)e^{-(\sigma +\mathrm{i}\omega )t}\mathrm{d}t<br>$$<br>令$p=\sigma +\mathrm{i}\omega$，$G(\omega)=\overline{f}(p)/2\pi$，则<br>$$<br>\mathscr L[f(t)]=\overline{f}(p)=\int^{\infty}</em>{0}f(t)e^{-pt}\mathrm{d}t<br>$$<br>我们称这个积分为<strong>拉普拉斯积分</strong>，而函数$\overline{f}(p)$为$f(t)$的<strong>拉普拉斯变换函数</strong>，这个变化过程称为拉普拉斯变换，$e^{pt}$称为<strong>核</strong></p><h4 id="变换条件">变换条件</h4><ul><li>在$[0,\infty)$的任意有限区间上，除了有限个第一类间断点外，函数及其导数是处处连续的</li><li>存在常数$M&gt;0$，$\sigma \ge0$，使得对任意$t\in [0,\infty)$有</li></ul><p>$$<br>|f(t)|&lt;Me^{\sigma t}<br>$$</p><p>其中$\sigma$的下界称为<strong>收敛横标</strong>，记为$\sigma_0$</p><p>在实际应用中，大部分函数都满足这个条件</p><h4 id="性质">性质</h4><ul><li><p>$\overline{f}(p)$是$Re p=\sigma &gt; \sigma_0$的半平面上的解析函数</p></li><li><p>当$|p|\rightarrow \infty$，且$|Arg p|\le \frac{\pi}{2}-\varepsilon(\varepsilon &gt; 0)$，$\overline{f}(p)$存在且满足</p></li></ul><p>$$<br>\lim_{p\rightarrow \infty}\overline{f}(p)=0<br>$$</p><ul><li>线性定理</li><li>导数定理</li><li>积分定理</li><li>相似性定理</li><li>位移定理</li><li>延迟定理</li><li>卷积定理</li></ul><h3 id="拉普拉斯变换的反演">拉普拉斯变换的反演</h3><p>由像函数转化为原函数的步骤称为<strong>反演</strong></p><ul><li>有理分式反演法</li><li>查表法</li><li>黎曼-梅林反演公式</li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微积分</title>
      <link href="/math/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
      <url>/math/%E5%BE%AE%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1>微积分</h1><h2 id="无穷级数">无穷级数</h2><p>从<strong>有限项之和</strong>拓展到<strong>无限项之和</strong></p><p>一根绳子，日取其半，万世不竭。但无论截取多少次，最后总长应该还是这跟绳子，即<br>$$<br>1=\frac{1}{2}+\frac{1}{2^2}+\frac{1}{2^3}+…+\frac{1}{2^n}+…<br>$$<br>另一个例子<br>$$<br>1+(-1)+1+(-1)+1+(-1)…<br>$$<br>等于多少呢？</p><p>到底是<br>$$<br>1+[(-1)+1]+[(-1)+1]…=1+0+0…<br>$$<br>还是<br>$$<br>(1-1)+(1-1)+…(1-1)+…=0+0+0…<br>$$<br>这里出现了矛盾，为此我们建立了无穷级数的概念</p><h3 id="常数项级数">常数项级数</h3><h4 id="常数项无穷级数">常数项无穷级数</h4><p>给定一个数列${u_n}$，由它构成的表达式<br>$$<br>u_1+u_2+…+u_n+…<br>$$<br>被称为<strong>常数项无穷级数</strong>，简称级数，其中$u_n$被称为该级数的通项</p><p>该级数的前n项和称为<strong>部分和</strong>，记为$s_n$</p><p>当n依次取1,2,3…时，部分和构成一个新数列${s_n}$，被称为<strong>部分和数列</strong></p><p>当n无限增大时，若部分和存在极限，即<br>$$<br>\lim_{n \rightarrow \infty}s_n=s<br>$$<br>则称该级数<strong>收敛</strong>，并称极限$s$为该级数的<strong>和</strong></p><p>若不存在极限，则称该级数<strong>发散</strong></p><h4 id="讨论级数收敛-发散">讨论级数收敛/发散</h4><ul><li>部分和公式好求，可以求公式，判断其有无极限</li><li>不好求，可以反证<ul><li>先假设收敛，然后化简公式，最后得出形如$s+x&gt;s$的结论，证否</li></ul></li></ul><p>$$<br>\lim_{n \rightarrow \infty}s_n=\lim_{n \rightarrow \infty}s_{2n}=s<br>$$</p><h4 id="余项">余项</h4><p>去掉级数A前n项，得到一级数<br>$$<br>u_{n+1}+u_{n+2}+…+u_{n+k}+…=\sum^{\infty}_{k=n+1}u_k<br>$$<br>称该级数为级数A的<strong>余项</strong></p><p>若级数A收敛，则余项的前m项之和$s_m’$满足<br>$$<br>s_m’=s-s_n<br>$$<br>一般，我们将n项后余项和记为$r_n$<br>$$<br>s=s_n+r_n<br>$$</p><h4 id="性质">性质</h4><ul><li><p>级数中去掉/加上有限个项，不改变级数的收敛性</p></li><li><p>若一级数收敛，则其通项<strong>乘</strong>以一个常数$k$，仍然收敛，且和为$ks$</p></li><li><p>若两级数收敛，则两通项<strong>相加或相减</strong>，对应的级数仍然收敛，且和为$s+\sigma$</p></li><li><p>若一级数收敛，在其中加任意个括号，仍然收敛</p></li><li><p>级数收敛的<strong>必要条件</strong>是通项在无穷大处有极限，且为0</p></li></ul><h4 id="柯西收敛准则">柯西收敛准则</h4><p>级数收敛的<strong>充要条件</strong></p><h3 id="正项级数">正项级数</h3><p>若级数中各项非负，则称该级数为<strong>正项级数</strong></p><ul><li>正项级数的<strong>部分和</strong>必然是递增的</li></ul><p>正项级数收敛的充要条件：其<strong>部分和数列</strong>有上界</p><h4 id="比较审敛法">比较审敛法</h4><p>对于两个正项级数A，B，其通项分别为$u_n,v_n$</p><ul><li>自某项起，$u_n\ge v_n$，若B发散，则A发散（大于发散则发散）</li><li>自某项起，$u_n\le v_n$，若B收敛，则A收敛（小于收敛则收敛）</li></ul><h5 id="比较审敛法的极限形式">比较审敛法的极限形式</h5><p>对于两个正项级数A，B，其通项分别为$u_n,v_n$，若<br>$$<br>\lim_{n \rightarrow \infty}\frac{u_n}{v_n}=\lambda<br>$$<br>有意义（极限存在或者为无穷大）</p><ul><li>$0&lt;\lambda&lt;\infty$：两级数收敛性相同</li><li>$lambda=0$：若B收敛，则A收敛（小于收敛则收敛）</li><li>$\lambda=\infty$：若B发散，则A发散（大于发散则发散）</li></ul><h4 id="比值审敛法">比值审敛法</h4><p>也称达朗贝尔判别法</p><p>对于一正向级数A，其通项为$u_n$，若<br>$$<br>\lim_{n \rightarrow \infty}\frac{u_{n+1}}{u_n}=\rho<br>$$<br>有意义</p><ul><li>$\rho &lt;1$：A收敛</li><li>$\rho &gt;1$：A发散</li><li>$\rho =1$：A可能收敛也可能发散</li></ul><h4 id="根值审敛法">根值审敛法</h4><p>也称柯西判别法</p><p>对于一正向级数A，其通项为$u_n$，若<br>$$<br>\lim_{n \rightarrow \infty}\sqrt[n]{u_n}=\rho<br>$$<br>有意义</p><ul><li>$\rho &lt;1$：A收敛</li><li>$\rho &gt;1$：A发散</li><li>$\rho =1$：A可能收敛也可能发散</li></ul><h4 id="积分审敛法">积分审敛法</h4><p>对于一正向级数A，其通项为$u_n$，若存在$[1, \infty)$上单调递减的非负连续函数$f(x)$，使得$u_n=f(n)$，则级数A与反常积分$\int^{\infty}_1 f(x)\mathrm{d}x$收敛性相同</p><ul><li>反常积分就是积分域包含无穷上/下限，或者被积函数有瑕点的积分<ul><li>瑕点：函数值区域无穷的点</li><li>奇点：函数值未定的点（比如间断点、无定义点）</li></ul></li></ul><h3 id="任意项级数">任意项级数</h3><h4 id="交错级数">交错级数</h4><p>形如<br>$$<br>u_1-u_2+u_3-u_4…(-1)^{n-1}u_n+…<br>$$<br>或者<br>$$<br>-u_1+u_2-u_3+u_4…(-1)^{n}u_n+…<br>$$<br>的级数，称为<strong>交错级数</strong></p><ul><li>其中$u_n &gt; 0$</li></ul><p><strong>交错级数审敛法</strong></p><p>若$u_n \ge u_{n+1}$ ，且$\lim_{n \rightarrow \infty}u_n=0$</p><p>则级数 $\sum^{\infty}_{n=1}(-1)^{n-1}u_n$ 收敛</p><p>且其和 $s \le u_1$ ，其余项 $|r_n|\le u_{n+1}$</p><h4 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h4><p>对于一级数$A=\sum^{\infty}_{n=1}u_n$，其各项取绝对值</p><p>得到新正项级数$B=\sum^{\infty}_{n=1}|u_n|$</p><p>定理：若B收敛，则A收敛（所以这就是我们为什么要研究正项级数）</p><ul><li>若B收敛，A必收敛，此时称A为<strong>绝对收敛</strong></li><li>若B发散，而A却收敛，此时称A为<strong>条件收敛</strong></li></ul><h5 id="性质-2">性质</h5><ul><li>绝对级数的更序级数仍为绝对级数<ul><li>更序级数：对某级数的项进行重排后得到的新级数</li></ul></li><li>两个绝对级数的柯西乘积仍然绝对收敛，且其和为$s\times \sigma$<ul><li>柯西乘积：参考向量相乘，$(a_1, a_2)(b_1,b_2)=(a_1b_1,a_2b_2)$</li></ul></li></ul><h3 id="函数项级数">函数项级数</h3><p>前面讨论的常数项级数用于表示无穷多个<strong>数</strong>的和，当其收敛时，其和为<strong>一个常数</strong></p><p>而函数项级数用于表示无穷多个<strong>函数</strong>的和</p><p>设定义在集合$D\subseteq \mathbf{R}$的一系列函数（称为函数列）<br>$$<br>u_1(x),u_2(x),u_3(x)…u_n(x)…<br>$$<br>称<br>$$<br>\sum^{\infty}_{n=1}u_n(x)<br>$$<br>为<strong>函数项级数</strong>，$u_n(x)$为通项，前n项和称为部分和</p><h4 id="极限函数">极限函数</h4><ul><li><p>若对于某个点$x_0 \in D$，${ u_n(x_0)}$收敛，则称点$x_0$为该函数列的一个<strong>收敛点</strong></p></li><li><p>所有收敛点构成的集合称为<strong>收敛域</strong></p></li><li><p>若${ u_n(x)}$处处收敛（或逐点收敛），那么就形成了一个定义在D上的函数$f(x)$，D上每一个x都有该函数列一个极限值与之相对应，并称函数$f(x)$为该函数列的<strong>极限函数</strong></p></li></ul><p>$$<br>f(x)=\lim_{n \rightarrow \infty}f_n(x)<br>$$</p><h4 id="极限函数与函数项级数">极限函数与函数项级数</h4><ul><li><p>若点$x_0 \in D$是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的<strong>收敛点</strong></p></li><li><p>若点$x_0 \in D$不是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的<strong>发散点</strong></p></li><li><p>收敛点的集合称为该级数的<strong>收敛域</strong></p></li><li><p>若级数在D上处处收敛，于是形成了一个定义在D上的<strong>和函数</strong>$s(x)$</p></li></ul><p>$$<br>s(x)=\lim_{n \rightarrow \infty}s_n(x)<br>$$</p><h4 id="收敛性">收敛性</h4><p>略</p><h3 id="幂级数">幂级数</h3><p>幂级数是一种特殊的，也是最常用的函数项级数</p><p>我们把形如<br>$$<br>a_0(x-x_0)^0+a_1(x-x_0)^1+a_2(x-x_0)^2+…a_n(x-x_0)^n+…<br>$$<br>的函数项级数称为$x-x_0$的<strong>幂级数</strong></p><p>其中$x_0$是一个常数，$a_0,a_1,…a_n,…$是<strong>幂级数的系数</strong></p><ul><li>对任意幂级数总有，当$x=0$时，幂级数收敛，即0是收敛点</li></ul><h4 id="阿贝尔定理">阿贝尔定理</h4><ul><li>若$x=x_0 \ne 0$且幂级数收敛，则当$|x|&lt;|x_0|$时，幂级数绝对收敛</li><li>若$x=x_0 \ne 0$且幂级数发撒，则当$|x|&gt;|x_0|$时，幂级数发散</li></ul><h4 id="收敛半径">收敛半径</h4><p>幂级数$\sum^{\infty}_{n=1}a_nx^n$的收敛域K是以原点为中心的一个区间，在区间内绝对收敛，在区间外发散，区间界可能收敛也可能发散，于是我们称这个收敛域的半径R为<strong>收敛半径</strong></p><p>对于某个幂级数，若$a_n \ne 0$，且<br>$$<br>\lim_{n \rightarrow \infty}|\frac{a_{n+1}}{a_n}|=\rho<br>$$</p><ul><li>若$0&lt;\rho &lt;\infty$，收敛半径$R=\frac{1}{\rho}$</li><li>若$\rho =0$，收敛半径$R=\infty$</li><li>若$\rho =\infty$，收敛半径$R=0$</li></ul><h4 id="运算">运算</h4><p>对于两个幂级数A、B，他们的收敛半径分别为$R_1$、$R_2$</p><p>$R=\min(R_1, R_2)$，则在$(-R, R)$上</p><ul><li>幂级数乘以一个常数仍然收敛</li><li>A和B的线性组合仍然收敛</li><li>A和B的乘积仍然收敛</li></ul><h4 id="和函数的性质">和函数的性质</h4><p>在收敛区间内，和函数$s(x)$满足</p><ul><li>连续性</li><li>可微性</li></ul><p>$$<br>s’(x)=\sum^{\infty}_{n=1}na_nx^{n-1}<br>$$</p><ul><li>可积性</li></ul><p>$$<br>\int^x_0s(t)\mathrm{d}t=\sum^{\infty}_{n=0}\frac{a_n}{n+1}x^{n+1}<br>$$</p><h3 id="函数展开为幂级数">函数展开为幂级数</h3><p>在前面几节，我们讨论了函数项级数（尤其是幂级数）在收敛区间内可以得到一个和函数</p><p>那么，能不能给定一个（和）函数，将其展开为幂级数呢？</p><p>幂级数可以视为多项式的推广，那么我们能不能用多项式来逼近（和）函数呢？</p><h4 id="泰勒级数">泰勒级数</h4><p>若$f(x)$在区间$(x_0-R, x_0+R)$能展开成幂级数，$f(x)$在$x=x_0$处有任意阶导数，那么幂级数有且仅有一个展开形式，且幂级数的系数为<br>$$<br>a_n=\frac{1}{n!}f^{(n)}(x_0)<br>$$</p><ul><li>n取0，1，2…</li></ul><p>我们称这个幂级数为函数$f(x)$在$x_0$处的<strong>泰勒级数</strong>，记作<br>$$<br>f(x)\sim f(x_0)+\frac{f’(x_0)}{1!}(x-x_0)+\frac{f’'(x_0)}{2!}(x-x_0)^2+…+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+…<br>$$</p><h4 id="展开条件">展开条件</h4><p>若$f(x)$在区间$(x_0-R, x_0+R)$处有任意阶导数，那么$f(x)$在该区间内能展开称泰勒级数的<strong>充要条件</strong>为<br>$$<br>\lim _{n \rightarrow \infty}R_n(x)=0<br>$$</p><ul><li>$R_n(x)$：n以后的余项</li></ul><p>推论</p><p>若存在一个常数$M&gt;0$，使得任意x属于区间$(x_0-R, x_0+R)$，都有当n趋近于无穷时，余项的绝对值小于M，则函数可以在该区间展开成泰勒级数</p><h4 id="麦克劳林展开式">麦克劳林展开式</h4><p>泰勒公式的特例，$x_0=0$<br>$$<br>f(x)=f(0)+\frac{f’(0)}{1!}x+\frac{f’'(0)}{2!}x^2+…++\frac{f^{(n)}(0)}{n!}x^n+…<br>$$</p><h4 id="经典展开">经典展开</h4><p>$$<br>e^x=1+\frac{x}{1!}+\frac{x^2}{2!}+…+\frac{x^n}{n!}+…<br>$$</p><p>$$<br>\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-…+(-1)^{n-1}\frac{x^{2n-1}}{(2n-1)!}+…<br>$$</p><h3 id="傅里叶级数">傅里叶级数</h3><p>使用三角函数来拟合一个已知函数</p><h4 id="三角级数">三角级数</h4><p>一般来说，形如<br>$$<br>\frac{a_0}{2}+\sum^{\infty}_{n=1}(a_n\cos nx+b_n \sin nx)<br>$$<br>的级数被称为三角级数</p><h4 id="正交性">正交性</h4><p>函数系<br>$$<br>{1,\cos x, \sin x, \cos 2x, \sin 2x, …,\cos nx, \sin nx,…}<br>$$<br>被称为<strong>基本三角函数系</strong></p><p><strong>正交性</strong>：该函数系任意两个不同的函数的乘积，在区间$[-\pi,\pi]$上的积分等于0</p><h4 id="三角级数的系数">三角级数的系数</h4><p>$$<br>a_n=\frac{1}{\pi}\int^{\pi}_{-\pi}f(x)\cos nx \ \mathrm{d}x<br>$$</p><p>$$<br>b_n=\frac{1}{\pi}\int^{\pi}_{-\pi}f(x)\sin nx \ \mathrm{d}x<br>$$</p><p>这两个式子被称为欧拉-傅里叶公式，由这个公式确定的系数被称为<strong>傅里叶系数</strong></p><p>对任意在区间$[-\pi,\pi]$上可积函数$f(x)$都可以求出其傅里叶级数，但这个级数不一定收敛，即使收敛也不一定收敛于$f(x)$</p><p>于是我们需要知道什么时候$f(x)$可以被展开成收敛在$f(x)$的傅里叶级数</p><h4 id="收敛定理（狄里希利充分条件）">收敛定理（狄里希利充分条件）</h4><p>对于一个周期为$2\pi$的周期函数，如果它满足<strong>狄里希利条件</strong>：</p><ul><li><p>在一个周期内连续，或者只有有限个第一类间断点</p><ul><li>第一类间断点：左右极限都存在，但该点函数值或该点无定义</li></ul></li><li><p>在一个周期内之多有有限个严格极值点</p></li></ul><p>则$f(x)$的傅里叶级数收敛，且</p><ul><li>当$x$是$f(x)$的连续点时，级数收敛于$f(x)$</li><li>当$x$是$f(x)$的间断点时，级数收敛于$\frac{1}{2}[f(x-0)+f(x+0)]$</li></ul><h4 id="其他概念">其他概念</h4><ul><li>周期延拓</li><li>正弦级数（奇函数）</li><li>余弦级数（偶函数）</li><li>奇延拓</li><li>偶延拓</li></ul><h4 id="复数表示">复数表示</h4><p>欧拉公式<br>$$<br>\sin z=\frac{e^{iz}-e^{-iz}}{2i}<br>$$</p><p>$$<br>\cos z=\frac{e^{iz}+e^{-iz}}{2}<br>$$</p><p>记<br>$$<br>\frac{a_0}{2}=c_0<br>$$</p><p>$$<br>\frac{a_n-ib_n}{2}=c_n<br>$$</p><p>$$<br>\frac{a_n+ib_n}{2}=c_{-n}<br>$$</p><p>则傅里叶级数简化为<br>$$<br>\sum^{\infty}_{n=-\infty}c_ne^{i\frac{n\pi x}{l}}<br>$$</p><p>$$<br>c_n=\frac{1}{2l}\int^l_{-l}f(x)e^{-i\frac{n\pi x}{l}}\mathrm{d}x<br>$$</p><h2 id="多元函数">多元函数</h2><h3 id="方向导数">方向导数</h3><p>设点$P_0(x_0,y_0)\in \mathbf{R}^2$，$l$是平面上的一非零向量，其单位向量为$e_i=\cos \alpha \mathbf {i}+\cos \beta \mathbf {j}$，函数$z=f(x,y)$在点$P_0$的某邻域内有定义，$P_0$为直线L上的一个定点（直线L平行于向量$l$），若极限<br>$$<br>\lim_{t\rightarrow 0}\frac{f(x_0+t\cos \alpha,y_0+t\cos \beta)-f(x_0,y_0)}{t}<br>$$<br>存在，则称此极限为函数$z=f(x,y)$在直线L上点$P_0$处，延方向$l$的<strong>方向导数</strong></p><h4 id="梯度">梯度</h4><p>方向导数刻画了函数在点$P_0$处沿着方向$l$的变化快慢程度，我们希望知道在该点，哪一个方向变化最快，于是引入了梯度</p><p>设函数$z=f(x,y)$在点$P_0(x_0,y_0)$处可偏导，则称向量<br>$$<br>f_x(x_0,y_0)\mathbf{i}+f_y(x_0, y_0)\mathbf{j}<br>$$<br>为函数$z=f(x,y)$在点$P_0(x_0,y_0)$处的<strong>梯度</strong>，记作$\mathbf{grad}f(x_0,y_0)$，或$\nabla f(x_0,y_0)$</p><ul><li>当方向为$(\frac{\partial z}{\partial x}|_P,\frac{\partial z}{\partial y}|_P)$时，变化速度最快</li></ul><h4 id="物理意义">物理意义</h4><ul><li>梯度方向=法线方向</li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>球函数</title>
      <link href="/math/%E7%90%83%E5%87%BD%E6%95%B0/"/>
      <url>/math/%E7%90%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>球函数</h1><p>三大偏微分方程</p><ul><li>拉普拉斯方程（椭圆）</li><li>热方程（抛物线）</li><li>波方程（双曲线）</li></ul><h3 id="常微分方程">常微分方程</h3><p>含有未知函数的导数（含高阶导数）或微分的等式，称为<strong>微分方程</strong></p><p>若未知函数是一元函数，则该函数为<strong>常微分方程</strong></p><p>若导数的阶数为1，那么称为<strong>一阶微分方程</strong></p><h3 id="球坐标系">球坐标系</h3><p>讨论常微分方程时，边界是记为重要的，而当边界是球形时，球坐标系会更好用</p><img src="/images//球坐标系.webp" class="lazyload" data-srcset="/images//球坐标系.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球坐标系" style="zoom: 67%;" /><p>直角坐标系上点$P(x,y,z)$，也可以用三个有次序的数$(r,\theta,\varphi)$表示<br>$$<br>\begin{cases}<br>x=r \sin \theta \cos \varphi \<br>y=r \sin \theta \sin \varphi \<br>z=r\cos \theta<br>\end{cases}<br>$$</p><p>$$<br>\begin{cases}<br>r=\sqrt{x^2+y^2+z^2} \<br>\theta=\arccos \frac{z}{r}\<br>\varphi=\arctan \frac{y}{x}<br>\end{cases}<br>$$</p><h3 id="拉普拉斯方程">拉普拉斯方程</h3><h4 id="拉普拉斯算符">拉普拉斯算符</h4><p>多元函数用梯度表示不同方向函数值变化的速度，拉普拉斯算符$\nabla$就是对多元函数求梯度</p><p>对梯度再次做拉普拉斯算符$\nabla ^2$，就是求<strong>梯度的散度</strong></p><p>在直角坐标系下，二阶拉普拉斯算符为<br>$$<br>\nabla^2=\frac{\partial ^2}{\partial x^2}+\frac{\partial ^2}{\partial y^2}+\frac{\partial ^2}{\partial z^2}<br>$$<br>在球坐标下，二阶拉普拉斯算法为（将xyz带入，化简得到）<br>$$<br>\nabla^2=\frac{1}{r^2}\frac{\partial}{\partial r}(r^2\frac{\partial}{\partial r})<br>+\frac{1}{r^2\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial}{\partial \theta})<br>+\frac{1}{r^2\sin^2 \theta }\frac{\partial^2}{\partial \varphi^2}<br>$$</p><h4 id="拉普拉斯方程-2">拉普拉斯方程</h4><p><strong>拉普拉斯方程</strong>$\nabla^2 u=0$，表示的物理含义是：在各个方向上（比如二维直角坐标系，就是x和y方向）加速度合为0</p><p>这意味着什么？一个不与外界进行能量交换的系统，其拉普拉斯方程为0</p><ul><li>一个不受外力的系统，其整体加速度为0</li><li>一个不与外界传热的系统，其整体能量传播为0</li><li>一个理想的简谐振动</li><li>闭合磁场、电场</li></ul><p>我们称拉普拉斯方程为0的函数叫做<strong>Harmonic</strong></p><h4 id="球坐标系下的拉普拉斯方程">球坐标系下的拉普拉斯方程</h4><p>函数$u(r,\theta,\varphi)$的拉普拉斯方程为<br>$$<br>\nabla^2u=\frac{1}{r^2}\frac{\partial}{\partial r}(r^2\frac{\partial u}{\partial r})<br>+\frac{1}{r^2\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial u}{\partial \theta})<br>+\frac{1}{r^2\sin^2 \theta }\frac{\partial^2 u}{\partial \varphi^2}=0<br>$$<br>我们将距离和方向分离，得到<br>$$<br>u(r,\theta,\varphi)=R®Y(\theta,\varphi)<br>$$</p><ul><li>$R®$表示距离</li><li>$Y(\theta,\varphi)$表示方向，被称为球函数</li></ul><p>带入可得<br>$$<br>\frac{Y}{r^2}\frac{\mathrm{d}}{\mathrm{d} r}(r^2\frac{\mathrm{d} R}{\mathrm{d} r})<br>+\frac{R}{r^2\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial Y}{\partial \theta})<br>+\frac{R}{r^2\sin^2 \theta }\frac{\partial^2 Y}{\partial \varphi^2}=0<br>$$<br>移项、化简可得<br>$$<br>\frac{1}{R}\frac{\mathrm{d}}{\mathrm{d} r}(r^2\frac{\mathrm{d} R}{\mathrm{d} r})<br>=-\frac{1}{\sin \theta Y}\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial Y}{\partial \theta})<br>-\frac{1}{Y}\frac{1}{\sin^2 \theta }\frac{\partial^2 Y}{\partial \varphi^2}<br>$$<br>我们发现，这个方程左边是与$R$有关的函数，右边是与$\theta,\varphi$有关的函数，显然两者不可能相等，除非他们同时等于一个常数</p><p>我们令这个常数为$l(l+1)$，于是得到两个方程<br>$$<br>\frac{\mathrm{d}}{\mathrm{d} r}(r^2\frac{\mathrm{d} R}{\mathrm{d} r})-l(l+1)R=0<br>$$</p><p>$$<br>\frac{1}{\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial Y}{\partial \theta})<br>+\frac{1}{\sin^2 \theta }\frac{\partial^2 Y}{\partial \varphi^2}<br>+l(l+1)Y=0<br>$$</p><p>第二个方程叫做<strong>球函数方程</strong></p><p>如果我们进一步分离变量，令<br>$$<br>Y(\theta,\varphi)=\Theta(\theta)\Phi(\varphi)<br>$$<br>带入球函数方程，化简得到两个常微分方程<br>$$<br>\Phi’'+\lambda \Phi=0<br>$$</p><p>$$<br>\sin \theta \frac{\mathrm{d}}{\mathrm{d} \theta}(\sin \theta \frac{\mathrm{d \Theta}}{\mathrm{d} \theta})+[l(l+1)\sin^2\theta-\lambda]\Theta=0<br>$$</p><h4 id="连带勒让德方程">连带勒让德方程</h4><p>上一步我们得到了两个常微分方程，第一个方程和<strong>自然周期条件</strong>构成本征值问题，在经过很多步的推导化简（感觉这些内容对我来说有些超纲），可以把第二个式子改写为<br>$$<br>(1-x^2)\frac{\mathrm{d}^2\Theta}{\mathrm{d}x^2}-2x\frac{\mathrm{d}\Theta}{\mathrm{d}x}+[l(l+1)-\frac{m^2}{1-x^2}]\Theta=0<br>$$<br>这个式子被称为$l$阶<strong>连带勒让德方程</strong></p><p>这个式子的解，即函数$\Theta$的表达式为<strong>连带勒让德函数</strong></p><h3 id="级数解法">级数解法</h3><p>用球坐标系对拉普拉斯方程进行分离变数，得到了连带勒让德方程等特殊的函数方程，这些方程大多都是线性二阶常微分方程，很难用常规办法解，但可以用<strong>级数解法</strong>解出</p><h4 id="常点与奇点">常点与奇点</h4><p>对于一个复变函数的线性二阶常微分方程<br>$$<br>\frac{\mathrm{d}^2w}{\mathrm{d}z^2}+p(z)\frac{\mathrm{d}w}{\mathrm{d}z}+q(z)w=0<br>$$<br>若系数函数$p(z)$、$q(z)$在点$z_0$的邻域中是解析的，则点$z_0$叫做该方程的<strong>常点</strong>，若点$z_0$是奇点，则点$z_0$叫做该方程的<strong>奇点</strong></p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论</title>
      <link href="/math/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
      <url>/math/%E6%A6%82%E7%8E%87%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1>概率论</h1><h2 id="一：随机事件与概率">一：随机事件与概率</h2><h3 id="事件">事件</h3><h4 id="事件的概念">事件的概念</h4><ul><li>样本空间$\Omega$<ul><li>其单元素子集：基本事件</li><li>其最大子集：必然事件</li><li>最小子集：即空集$\empty$，不可能事件</li></ul></li><li>事件域$F$</li></ul><h4 id="事件的关系">事件的关系</h4><ul><li>包含<ul><li>$A\subset B$：A被包含在B、B包含A、A发生时B一定发生</li></ul></li><li>相等<ul><li>$A=B$：A等于B，两事件是同一个集合、描述的是同一件事</li></ul></li><li>互不相容<ul><li>A和B不能同时发生</li></ul></li></ul><h4 id="事件的运算">事件的运算</h4><h5 id="基本运算">基本运算</h5><ul><li>并<ul><li>$A \cup B$：A和B至少有一个会发生</li></ul></li><li>交<ul><li>$A \cap B$：A和B同时发生</li></ul></li><li>差<ul><li>$A-B$：A发生，但B不发生</li></ul></li><li>对立<ul><li>$\overline{A}$：即$\Omega - A$</li></ul></li></ul><h5 id="运算性质">运算性质</h5><ul><li>交换律</li><li>结合律</li><li>分配律</li><li>对偶律（德摩根公式）<ul><li>$\overline{A \cup B} = \overline{A} \cap \overline{B}$：并的对立等于对立的交</li><li>$\overline{A \cap B} = \overline{A} \cup \overline{B}$：交的对立等于对立的并</li></ul></li></ul><h3 id="概率">概率</h3><h4 id="公理化表示">公理化表示</h4><p>设$\Omega$为一个样本空间，$F$为$\Omega$的某些子集组成的一个事件域，对任意事件$A \in F$，有一个定义在$F$上的实值函数$P(A)$，满足：</p><ul><li>非负<ul><li>$P(A) \ge 0$</li></ul></li><li>正则<ul><li>$P(\Omega) = 1$</li></ul></li><li>可列可加<ul><li>若$A_1,A_2,A_3,…A_n$互不相容，则<strong>和的概率等于概率的和</strong></li></ul></li></ul><p>则称$P(A)$为事件$A$的概率，$(\Omega, F, P)$为概率空间</p><h4 id="排列">排列</h4><p>n中取r，考虑顺序<br>$$<br>P^r_n = \frac{n!}{(n-r)!}<br>$$<br>全排列<br>$$<br>P_n = n!<br>$$</p><ul><li>注意，这里的P是方案数的意思</li></ul><h4 id="组合">组合</h4><p>n中取r，不考虑顺序<br>$$<br>C^r_n=\binom{n}{r}=\binom{n}{n-r}=\frac{n!}{r!(n-r)!}<br>$$<br>并规定<br>$$<br>C^0_n=1<br>$$</p><h4 id="频率">频率</h4><ul><li><p>$n(A)$：频数，n次重复实验中事件A出现的次数</p></li><li><p>$f_n(A)$：频率=频数/n</p></li><li><p>我们认为频率的稳定值就是概率</p></li></ul><h4 id="古典概率">古典概率</h4><p>通过样本数进行估计<br>$$<br>P(A)=\frac{事件A所含样本数}{\Omega 所含样本总数}<br>$$</p><h4 id="几何概率">几何概率</h4><p>通过面积、体积进行估计<br>$$<br>P(A)=\frac{S_A}{S_{\Omega}}<br>$$</p><ul><li>蒙特卡洛方法</li></ul><h4 id="概率的性质">概率的性质</h4><ul><li>$P(\Omega)=1$</li><li>$P(\empty)=0$</li><li>有限可加性：和的概率等于概率之和</li><li>$P(\overline{A}) = 1-P(A)$</li><li>若$A\sub B$<ul><li>$P(B-A) = P(B)-P(A) =P(B) - P(AB)$</li><li>$P(B) \ge P(A)$</li></ul></li><li>$P(A\cup B)=P(A)+P(B)-P(AB)$</li></ul><h3 id="条件概率">条件概率</h3><ul><li>条件概率：在B发生的情况下，A发生的概率</li></ul><p>$$<br>P(A|B) = \frac{P(AB)}{P(B)}<br>$$</p><ul><li>乘法公式</li></ul><p>$$<br>P(A_1…A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1…A_n-1)<br>$$</p><ul><li>全概率公式</li></ul><p>$$<br>P(A) = \sum^{n}_{i=1}P(B_i)P(A|B_i)<br>$$</p><p>$$<br>P(A)=P(B)P(A|B)+P(\overline{B})P(A|\overline{B})<br>$$</p><ul><li>贝叶斯公式（用于计算后验概率）</li></ul><p>$$<br>P(B|A)=\frac{P(B)P(A|B)}{P(B)P(A|B)+P(\overline{B})P(A|\overline{B})}<br>$$</p><h3 id="独立性">独立性</h3><p>若$P(AB)=P(A)P(B)$，则称AB两事件相互独立</p><ul><li>独立重复试验</li></ul><h2 id="二：随机变量及其分布">二：随机变量及其分布</h2><h3 id="随机变量">随机变量</h3><p>定义在样本空间$\Omega$上的实值函数$X=X(\omega)$称为随机变量，$\omega$是样本点</p><ul><li>当$\omega$变化时，$X$会变化，这东西更像一个函数，不要被“变量”给迷惑了</li></ul><h4 id="随机事件">随机事件</h4><p>随机事件是随机变量的集合</p><p>若$B$是某些实数组成的集合，$B\sub R$，则${X \in B}$表示随机事件：<br>$$<br>{\omega:X(\omega) \in B} \sub \Omega<br>$$<br>特别的，${X \in B}$可以写成类似${X \le a }$、${ a &lt; X &lt; b}$</p><h4 id="分布列">分布列</h4><p>$$<br>p(x_i) = P(X=x_i)<br>$$</p><table><thead><tr><th>X</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>P</td><td>1/2</td><td>1/4</td><td>1/8</td><td>1/8</td></tr></tbody></table><h4 id="分布函数">分布函数</h4><p>设$X$是一个连续随机变量，对于任意实数$x$，称<br>$$<br>F(x) = P(X \le x)<br>$$<br>为随机变量$X$的分布函数，并称$X$服从$F(x)$，记为$X \sim F(x) $</p><ul><li><p>$F(x)$定义域$(-\infty， \infty)$，值域$[0, 1]$</p></li><li><p>$F(x)$满足</p><ul><li>单调非减</li><li>有界</li><li>右连续，即$F(x_0+0)=F(x_0)$</li></ul></li></ul><h4 id="概率密度函数">概率密度函数</h4><p>设随机变量$X$的分布函数为$F(x)$，如果存在实数轴上一个非负可积函数$p(x)$，使得对任意实数$x$有<br>$$<br>F(x) = \int^x_{-\infty}p(t)\mathrm{d}t<br>$$<br>则称$p(x)$为$X$的概率密度函数</p><p>在$F(x)$可导的点上，$F’(x)=p(x)$</p><ul><li>非负性</li><li>正则性</li></ul><h3 id="期望">期望</h3><h4 id="离散">离散</h4><p>对于离散随机变量$X$，其分布列为$p(x_i), i=1,2,3…n,…$</p><p>若级数不收敛，即<br>$$<br>\sum^n_{i=1}|x_i|p(x_i) &lt; \infty<br>$$<br>则称<br>$$<br>E(X) = \sum^{\infty}_{i = 1}x_i p(x_i)<br>$$<br>为随机变量$X$、或者该分布的数学期望</p><h4 id="连续">连续</h4><p>设连续随机变量$X$的概率密度函数为$p(x)$</p><p>若<br>$$<br>\int^{\infty}<em>{-\infty}|x|p(x)\mathrm{d}x &lt; \infty<br>$$<br>则称<br>$$<br>E(X) = \int^{\infty}</em>{-\infty}xp(x)\mathrm{d}x<br>$$<br>为$X$的数学期望</p><ul><li>数学期望的物理解释是重心</li></ul><h4 id="性质">性质</h4><p>$$<br>E[g(X)]=\sum_{i}g(x_i)p(x_i)<br>$$</p><p>$$<br>E©=c<br>$$</p><p>$$<br>E(aX)=aE(X)<br>$$</p><p>$$<br>E[g_1(X) + g_2(X)]=E[g_1(X)]+E[g_2(X)]<br>$$</p><h3 id="方差">方差</h3><p>$$<br>Var(X)=E(X-E(X))^2<br>$$</p><p>标准差<br>$$<br>\sigma(X) = \sqrt{Var(X)}<br>$$</p><h4 id="性质-2">性质</h4><p>$$<br>Var(X)=E(X^2)-[E(X)]^2<br>$$</p><p>$$<br>Var© = 0<br>$$</p><p>$$<br>Var(aX+b)=a^2Var(X)<br>$$</p><h4 id="切比雪夫不等式">切比雪夫不等式</h4><p>出现大偏差的概率的上下界，与方差呈正比<br>$$<br>P(|X-E(X)| \ge \epsilon) \le \frac{Var(X)}{\epsilon^2}<br>$$<br>若方差为0，则<br>$$<br>P(X=E(X))=1<br>$$</p><h3 id="常见分布">常见分布</h3><ul><li><p>离散</p><ul><li><p>二项分布</p></li><li><p>两点分布</p></li><li><p>泊松分布</p></li><li><p>超几何分布</p></li></ul></li><li><p>连续</p><ul><li>正态分布</li><li>均匀分布</li><li>指数分布</li><li>伽马分布</li><li>贝塔分布</li></ul></li></ul><h2 id="三：多维随机变量及其分布">三：多维随机变量及其分布</h2><h3 id="多维随机变量">多维随机变量</h3><p>如果$X_1(\omega),X_2(\omega),X_3(\omega)…X_n(\omega)$是定义在同一样本空间$\Omega = {\omega}$上的n个随机变量，则称<br>$$<br>X(\omega)=(X_1(\omega),X_2(\omega),X_3(\omega)…X_n(\omega))<br>$$<br>为N维随机变量</p><ul><li>必须为同一样本空间</li></ul><p>N个小孩中，身高是一个随机变量，体重也是一个随机变量，（身高，体重）是一个二维随机变量</p><h4 id="联合分布函数">联合分布函数</h4><p>$$<br>F(x_1, x_2,…,x_n)=P(X_1\le x_1, X_2 \le x_2, …, X_n \le x_n)<br>$$</p><p>为n维随机变量$(X_1, X_2, …,X_n)$的联合分布函数</p><h4 id="独立性-2">独立性</h4><p>若<br>$$<br>F(x_1, x_2,…,x_n)=\prod^n_{i=1}F_i(x_i)<br>$$<br>则称$X_1, X_2, …,X_n$相互独立（充要条件）</p><ul><li>简单说，独立的随机变量，联合概率密度可以直接相乘</li></ul><h4 id="期望-2">期望</h4><p>$$<br>E(Z)=\sum_i \sum_j g(x_i, y_j)P(X=x_i, Y=y_j)<br>$$</p><p>$$<br>E(Z)=\int^{\infty}<em>{-\infty} \int^{\infty}</em>{-\infty} g(x,y)p(x,y)\mathrm{d}x\mathrm{d}y<br>$$</p><h4 id="重期望公式">重期望公式</h4><p>$$<br>E(X)=E(E(X|Y))<br>$$</p><h4 id="边缘分布">边缘分布</h4><p>边缘分布是指一个联合分布中，对其中一个随机变量的分布进行求和（或积分），从而得到该随机变量的单独分布</p><h2 id="四：大数定律与中心极限定理">四：大数定律与中心极限定理</h2><h3 id="收敛性">收敛性</h3><ul><li>依概率收敛：大数定律</li><li>按分布收敛：中心极限定理</li></ul><h4 id="依概率收敛">依概率收敛</h4><p>有的随机变量X的概率非常难求，如果可以找到一个简单的随机变量Y的分布来拟合X，可以大幅简化计算</p><p>设${X_n}$为以随机变量序列，$X$为一随机变量，对任意$\varepsilon &gt; 0$，有<br>$$<br>P(|X_n - X| \ge \varepsilon)\rightarrow 0 \ \ (n\rightarrow \infty)<br>$$<br>则称序列${X_n}$<strong>依概率收敛于X</strong>，记作$X_n \xrightarrow{P} X$</p><ul><li>简单来说，就是概率集中在某个X处</li></ul><h4 id="弱收敛">弱收敛</h4><p>若<br>$$<br>\lim_{n \rightarrow \infty}F_n(x)=F(x)<br>$$<br>则称${F_n(x)}$弱收敛于$F(x)$，记作$F_n(x) \xrightarrow{W} F(x)$</p><p>也称序列${X_n}$<strong>按分布收敛于X</strong>，记作$X_n \xrightarrow{L} X$</p><ul><li>依概率收敛比按分布收敛，收敛性更强</li></ul><h3 id="特征函数">特征函数</h3><p>设X是一个随机变量，称<br>$$<br>\varphi(t)=E(e^{itX})<br>$$<br>为X的特征函数</p><ul><li>任一随机变量的特征函数总是存在</li></ul><h3 id="大数定理">大数定理</h3><h4 id="伯努利大数定理">伯努利大数定理</h4><p>$$<br>\lim_{n \rightarrow \infty}P(|\frac{S_n}{n} - p| &lt; \varepsilon)=1<br>$$</p><p>意义为：随着n次数的增多，频率会越来越接近概率（随机变量序列的算数平均 依概率收敛到 其均值的算数平均）</p><h3 id="中心极限定理">中心极限定理</h3><p>在某些情况下，<strong>随机变量和</strong> 的分布函数收敛于正态分布</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>线性代数</h1><h2 id="一：线性方程组">一：线性方程组</h2><h3 id="概念">概念</h3><ul><li>线性方程</li><li>线性方程组</li><li>系数</li><li>解：一组能让方程左右相等的数</li><li>解集：方程组的所有解的集合</li><li>等价：若两个线性方程组拥有相同解集，则两者等价</li><li>相容：方程组有一个或无穷多个解</li><li>不相容：方程组无解</li></ul><h3 id="矩阵">矩阵</h3><p>方程组<br>$$<br>\begin{gathered}<br>x_1-2x_2+x_3=0 \\<br>2x_2-8x_3=8 \\<br>5x_1-5x_3=10<br>\end{gathered}<br>$$<br>的<strong>系数矩阵</strong>为<br>$$<br>\left[ \begin{matrix}1&amp;-2&amp;1\\ 0&amp;2&amp;-8\\ 5&amp;0&amp;-5\end{matrix} \right]<br>$$<br><strong>增广矩阵</strong>为<br>$$<br>\left[ \begin{matrix}1&amp;-2&amp;1&amp;0\\ 0&amp;2&amp;-8&amp;8\\ 5&amp;0&amp;-5&amp;10\end{matrix} \right]<br>$$<br>这个增广矩阵，3行4列，是一个3x4的矩阵</p><p>我们对增广矩阵进行多次矩阵运算，于是得到<br>$$<br>\left[ \begin{matrix}1&amp;0&amp;0&amp;1\\ 0&amp;1&amp;0&amp;0\\ 0&amp;0&amp;1&amp;-1\end{matrix} \right]<br>$$<br>于是原方程有且仅有一个解$(1,0,-1)$</p><h4 id="初等行变换">初等行变换</h4><p>也就是行简化</p><ul><li><p>倍加：<code>a=a+nb</code>，把某行加上某一行的倍数</p></li><li><p>对换：<code>swap(a,b)</code>，把某两行对换</p></li><li><p>倍乘：<code>a *= n (n!=0)</code>，把某行所有元素乘以一个非零的数</p></li></ul><h4 id="阶梯矩阵">阶梯矩阵</h4><p>形如<br>$$<br>\left[ \begin{matrix}x&amp;<em>&amp;</em>&amp;<em>\\ 0&amp;x&amp;</em>&amp;<em>\\ 0&amp;0&amp;x&amp;</em>\end{matrix} \right]<br>$$<br>的矩阵，被称为<strong>阶梯形</strong></p><ul><li>$x$为先导元素，非零<ul><li>若先导元素均为1，而且该<strong>列</strong>只有先导元素非零，则矩阵被称为<strong>简化阶梯形</strong></li><li>$x$所在的位置被称为主元位置，拥有主元的列被称为<strong>主元列</strong></li></ul></li><li>$*$取任意值</li></ul><h4 id="行简化">行简化</h4><ul><li>任何非零矩阵都可以行简化为阶梯形矩阵</li><li>简化阶梯形具有唯一性</li></ul><h4 id="线性方程的解">线性方程的解</h4><p>对增广矩阵运用行简化，得到一个简化阶梯形<br>$$<br>\left[ \begin{matrix}1&amp;0&amp;-5&amp;1\\ 0&amp;1&amp;1&amp;4\\ 0&amp;0&amp;0&amp;0\end{matrix} \right]<br>$$<br>对应的线性方程组为<br>$$<br>\begin{gathered}<br>x_1-5x_3=1 \\<br>x_2+x_3=4 \\<br>0=0<br>\end{gathered}<br>$$</p><ul><li>其中$x_1,x_2$为基本变量，$x_3$为自由变量</li></ul><p>于是可以得到线性方程组的<strong>通解</strong><br>$$<br>\begin{cases}<br>x_1=1+5x_3&amp;\\<br>x_2=4-x_3&amp;\\<br>x_3是自由变量<br>\end{cases}<br>$$</p><h3 id="向量方程">向量方程</h3><h4 id="向量">向量</h4><p>n维向量可以写成nx1列矩阵的形式<br>$$<br>\mu=\begin{bmatrix}<br>1\\ 1\\ \vdots \\ 1<br>\end{bmatrix}<br>$$</p><ul><li>所有元素为0的向量称为零向量</li><li>当且仅当两个向量对应元素全相等时，两向量<strong>相等</strong></li></ul><p>为了方便书写，我们会将n维向量横着写（注意！用的是括号，并且相邻元素间用逗号隔开）<br>$$<br>(1,1,…,1)<br>$$</p><h4 id="向量方程-2">向量方程</h4><p>向量方程：<br>$$<br>x_1\mathbf{a_1}+x_2\mathbf{a_2}+…+x_n\mathbf{a_n}=\mathbf{b}<br>$$<br>的解，等同于增广矩阵为<br>$$<br>\begin{bmatrix}\mathbf{a_1}&amp;\mathbf{a_2}&amp;…&amp;\mathbf{a_n}\end{bmatrix}<br>$$<br>的线性方程组的解</p><ul><li><p>$Span{\nu}$</p></li><li><p>$Span{\nu_1,\nu_2,…,\nu_n }$</p></li></ul><h3 id="矩阵运算">矩阵运算</h3><p>$$<br>A\mathbf{x}=<br>\begin{bmatrix}\mathbf{a_1}&amp;\mathbf{a_2}&amp;…&amp;\mathbf{a_n}\end{bmatrix}<br>\begin{bmatrix}x_1\\ x_2\\ \vdots \\ x_n\end{bmatrix}<br>=x_1\mathbf{a_1}+x_2\mathbf{a_2} + …+x_n\mathbf{a_n}<br>$$</p><ul><li>当且仅当左边的列数等于右边的行数，才可以运算（横乘竖）</li></ul><img src="/images/横乘竖.png" class="lazyload" data-srcset="/images/横乘竖.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="横乘竖" style="zoom:50%;" /><h4 id="矩阵方程">矩阵方程</h4><p>$$<br>A\mathbf{x}=\mathbf{b}<br>$$</p><h3 id="齐次线性方程组">齐次线性方程组</h3><p>若线性方程的常数项为0，则称该线性方程为齐次的，可以写成<br>$$<br>A\mathbf{x}=\mathbf{0}<br>$$<br>的形式</p><ul><li>齐次线性方程必有一个平凡解，即$\mathbf{x}=\mathbf{0}$</li><li>齐次线性方程有非平凡解，当且仅当方程组至少有一个自由变量</li></ul><p>要判断$A\mathbf{x}=\mathbf{0}$有无非平凡解</p><ol><li>写出方程组的增广矩阵$[A, \mathbf{0}]$</li><li>将矩阵化简为简化阶梯形</li><li>若存在某一行全为0（该行对应的变量就是<strong>自由变量</strong>），则有非平凡解<ol><li>哪些不全为0的行所对应的变量称为<strong>基本变量</strong></li></ol></li></ol><h3 id="线性无关">线性无关</h3><p>若线性方程仅有平凡解，则该组向量（矩阵各列）线性无关</p><h4 id="矩阵-2">矩阵</h4><p>要判断某个<strong>矩阵</strong>各列是否线性无关：</p><ol><li>写出矩阵的增广矩阵$[A, \mathbf{0}]$</li><li>对矩阵进行行简化</li><li>若矩阵没有自由变量，则说明各列线性无关</li></ol><h4 id="向量的集合">向量的集合</h4><ul><li><p><strong>一个向量</strong>的集合线性无关的条件：当且仅当向量不是零向量</p></li><li><p><strong>两个向量</strong>的集合线性相关的条件：当且仅当某个（非零）向量是另一个（非零）向量的倍数</p></li><li><p><strong>多个向量</strong>的集合线性相关的条件：当且仅当至少有一个向量是其他向量的线性组合</p><ul><li>若一个向量组中向量个数多于每个向量的元素个数，那么这个向量组线性相关（充分条件）</li></ul></li></ul><p>能看出，两个向量属于多个向量</p><h3 id="线性变换">线性变换</h3><h4 id="变换">变换</h4><p>$$<br>A\mathbf{x}=\mathbf{b}<br>$$</p><p>一个n维向量左乘一个m行n列的矩阵，会得到一个m维的向量</p><p>我们称$\mathrm{R}^n \rightarrow \mathrm{R}^m$这个过程为一个<strong>变换</strong>，也可以叫做函数、映射</p><p>变化的规则为$T$，$\mathrm{R}^n$被称为$T$的<strong>定义域</strong>，$\mathrm{R}^m$被称为$T$的<strong>余定义域</strong></p><p>对于$\mathrm{R}^n$中的一个向量$x$，其在$\mathrm{R}^m$中的向量$T(x)$被称为$x$的<strong>像</strong>，所有的像的集合被称为<strong>值域</strong></p><p><img src="/images/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" class="lazyload" data-srcset="/images/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线性变换"></p><h4 id="线性变换-2">线性变换</h4><p>若定义域中的一切向量满足</p><ul><li>$T(\mathbf{u}+\mathbf{v})=T(\mathbf{u})+T(\mathbf{v}) $</li><li>$T(c\mathbf{u})=cT(\mathbf{u})$</li></ul><p>则称该变换为<strong>线性变换</strong></p><p>线性变换的性质：</p><ul><li>$T(\mathbf{0})=\mathbf{0}$</li><li>$T(c\mathbf{u}+d\mathbf{v})=cT(\mathbf{u})+dT(\mathbf{v}) $</li></ul><p>若n等于m，$T(\mathbf{x})=r \ \mathbf{x}$</p><ul><li>若<code>r &gt; 1</code>，则称为拉伸变换</li><li>若<code>0 &lt; r &lt; 1</code>，则称为压缩变化</li></ul><h4 id="变化矩阵">变化矩阵</h4><p>二维空间的变化矩阵为，$(x_1, y_1)$为变化后单位正方形右下角的位置，$(x_2, y_2)$为变化后单位正方形左上角的位置<br>$$<br>\left[ \begin{matrix}x_1&amp;x_2\\ y_1&amp;y_2\end{matrix} \right]<br>$$<br><img src="/images/%E5%8D%95%E4%BD%8D%E6%AD%A3%E6%96%B9%E5%BD%A2.png" class="lazyload" data-srcset="/images/%E5%8D%95%E4%BD%8D%E6%AD%A3%E6%96%B9%E5%BD%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="单位正方形"></p><p><img src="/images/%E5%AF%B9%E7%A7%B0.png" class="lazyload" data-srcset="/images/%E5%AF%B9%E7%A7%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="对称"></p><h2 id="二：矩阵代数">二：矩阵代数</h2><h3 id="矩阵-3">矩阵</h3><p>对于一个mxn的矩阵，也就是m行n列的矩阵，我们可以写作<br>$$<br>A=[\mathbf{a}_1 \ \mathbf{a}_2\ \cdots \mathbf{a}_n]<br>$$</p><!----><p>其中</p><img src="/images/矩阵的列.png" class="lazyload" data-srcset="/images/矩阵的列.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="矩阵的列" style="zoom:50%;" /><p>矩阵A的对角元素为$a_{11}, a_{22}, \cdots$，他们组成了矩阵A的<strong>主对角线</strong></p><p><strong>对角矩阵</strong>：非对角线元素全为0的矩阵</p><p><strong>零矩阵</strong>：元素全为0的矩阵，根据其尺寸，可以写为$\mathbf{0}_{m \times n}$</p><h3 id="矩阵运算-2">矩阵运算</h3><p>矩阵相等：维数相同且对应元素均相同</p><p>矩阵相加：维数相同的矩阵才能相加，结果为对应元素相加</p><p>矩阵标量乘：矩阵所有元素乘一个标量</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DX12龙书</title>
      <link href="/graphics/DX12%E7%AC%94%E8%AE%B0/"/>
      <url>/graphics/DX12%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>DX12</h1><h3 id="环境搭建">环境搭建</h3><p>Windows 10/11系统</p><p>安装<a href="https://devblogs.microsoft.com/pix/download/">PIX</a></p><p>安装Visual Studio 2019</p><h3 id="Windows应用程序">Windows应用程序</h3><p>Windows应用程序使用事件驱动（详情可以去看WPF）</p><p>Windows应用程序的入口点是<code>WinMain</code>函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE, LPSTR, <span class="type">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">LearnDX::D3D12HelloWindow <span class="title">sample</span><span class="params">(<span class="number">1280</span>, <span class="number">720</span>, <span class="string">L&quot;D3D12 Hello Window&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> LearnDX::Win32Application::<span class="built_in">Run</span>(&amp;sample, hInstance, nCmdShow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序会创建一个窗口，并进入消息循环，检索处理操作系统发来的消息，并对其进行相应</p><table><thead><tr><th>message</th><th>发送时机</th></tr></thead><tbody><tr><td>WM_CHAR</td><td>键盘输入一个字符</td></tr><tr><td>WM_COMMAND</td><td>使用菜单栏、控件</td></tr><tr><td>WM_CREATE</td><td>创建一个窗口</td></tr><tr><td>WM_DESTROY</td><td>一个窗口被摧毁</td></tr><tr><td>WM_LBUTTONDOWN</td><td>按下鼠标左键</td></tr><tr><td>WM_LBUTTONUP</td><td>鼠标左键被释放</td></tr><tr><td>WM_MOUSEMOVE</td><td>鼠标指针被移动</td></tr><tr><td>WM_PAINT</td><td>一个窗口需要重新粉刷</td></tr><tr><td>WM_QUIT</td><td>应用程序即将终止，WinMain返回</td></tr><tr><td>WM_SIZE</td><td>调整窗口大小</td></tr></tbody></table><p>当接收到<code>WM_QUIT</code>消息时（比如用户关闭窗口），会退出消息循环，应用程序即将结束，<code>WinMain</code>函数返回</p><h3 id="COM">COM</h3><h4 id="为什么要使用COM">为什么要使用COM</h4><blockquote><p>我们在编写C++时，经常会生成dll文件，这是一种动态库，保存了许多通用的数据和函数，运行时软件可以通过函数指针的方式导出dll的函数，从而实现运行时动态链接</p><p>当我们在同一操作系统、同一编译器环境写构建C++项目，可以复用这个dll文件。然而当你使用其他语言时，如果这个语言读不懂dll的二进制，不知道如何与之沟通，这个语言就不能使用这个dll文件。</p><p>或者另一种情况，当你更新了这个dll文件，而应用还在用老办法调用dll，很有可能也会出错</p></blockquote><p>为了解决上述问题，微软提出了<strong>组件对象模型</strong>（Component Object Model，COM），一套软件组件的二进制接口，可以实现跨编程语言的进程间通信、创建动态对象，在二进制层面打破了代码依赖</p><h4 id="COM的优点">COM的优点</h4><ul><li>软件（apps）使用抽象接口访问服务器（servers，这里指dll文件），可以使用接口指针调用COM类的成员函数</li><li>软件无需知道COM的内部实现，COM对象的创建与释放由COM自行完成</li><li>COM可能同时被多个软件使用，使用引用计数法进行GC</li><li>每个COM类都有独一无二的ID，因此内存中可以同时加载多个拥有相同接口的COM类，软件可以自行选择使用哪一个COM类</li><li>COM规定了一种特殊的layout，可以被任何支持COM的语言所解析（但可惜的是，支持COM的语言并不多，因此你还是只能用C++去写DX）</li><li>COM实际上是由指针和函数表组成（就像C++的虚函数）</li></ul><h4 id="COM的实现">COM的实现</h4><p>COM中所有接口都继承于<code>IUnknown</code>，该接口提供了三个操作</p><ul><li><code>AddRef</code>：增加引用计数的次数，每次拷贝接口指针时都会执行</li><li><code>Release</code>：减少引用计数的次数，当次数为0，释放对象</li><li><code>QueryInterface</code>：返回指向该对象的指针</li></ul><p>不过显式控制COM对象的引用过于困难，C++推荐使用智能指针</p><h3 id="DXGI">DXGI</h3><p>DirectX Graphics Infrastructure (DXGI)，负责管理一些low-level的任务，比如如何将frame呈现在显示器上，gamma矫正，屏幕刷新，交换链等</p><img src="/images/DXGI.png" class="lazyload" data-srcset="/images/DXGI.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DXGI" style="zoom:67%;" /><h3 id="依赖">依赖</h3><p>VS添加DX12依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开VS--项目--属性--配置属性--链接器--输入--附加依赖项</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%B7%BB%E5%8A%A0DX%E4%BE%9D%E8%B5%96.png" class="lazyload" data-srcset="/images/%E6%B7%BB%E5%8A%A0DX%E4%BE%9D%E8%B5%96.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230112010632277"></p><p>cmake添加依赖</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(DXEngine)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp src/*.h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(DXEngine WIN32 <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(DXEngine PUBLIC <span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 比较重要的是d3d12.lib dxgi.lib</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(DXEngine PRIVATE</span><br><span class="line">        d3d12.lib dxgi.lib dxguid.lib uuid.lib</span><br><span class="line">        kernel32.lib user32.lib</span><br><span class="line">        comdlg32.lib advapi32.lib shell32.lib</span><br><span class="line">        ole32.lib oleaut32.lib</span><br><span class="line">        runtimeobject.lib</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id="批注">批注</h3><p>VS提供了一套批注系统，SAL（Source code annotation language）</p><h3 id="字符串">字符串</h3><p>Windows的字符串是一大噩梦</p><p>代码的字符编码主要有两种，<code>ASCII</code>和<code>UNICODE</code>，Windows内部使用了utf-16存储字符串，并支持两种API，用以支持<code>ASCII</code>和<code>UNICODE</code>，他们分布以<code>A</code>和<code>W</code>结尾</p><p>为了支持两种API，于是推出了一种新的字符类型<strong>宽字符</strong>：<code>wchat_t</code>，微软将其重命名为<code>WCHAR</code></p><p>宽字符在使用时要在前面加<code>L</code>，比如<code>L'a'</code></p><p>微软又将字符串进行重命名，提出了窄字符串STR和宽字符串WSTR，并给出了他们的指针<code>LPSTR</code>和<code>LPWSTR</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LPSTR = <span class="type">const</span> <span class="type">char</span>*</span><br><span class="line">LPWSTR = <span class="type">const</span> <span class="type">wchar_t</span>*</span><br></pre></td></tr></table></figure><p>如果你用VS开发，可以设置整个项目使用<code>UNICODE</code>，但我不建议这样做</p><p>强烈推荐当你要使用字符串函数时，明确使用后缀是<code>A</code>还是<code>W</code>，并且要注意你<code>WindowProc</code>的类型（是使用<code>DefWindowProcW</code>还是<code>DefWindowProcA</code>）</p><h3 id="d3dx12-h">d3dx12.h</h3><p>这是一个<code>.h</code>文件，内含许多DX开发常用函数，将该文件复制到项目中</p><p>这个文件中使用了大量Windows SDK，因此你最好用VS2019的Toolchains（Clion的用户使用内置的MinGW可能会报一堆错）</p><p>至于为什么要求是VS2019，是因为这个文件与Windows10 SDK版本强相关，VS2019的SDK直接就是对应版本，2017需要手动下载，2015直接没法用</p><p><a href="https://stackoverflow.com/questions/65294611/d3dx12-h-gives-a-bunch-of-errors">详情</a></p><h3 id="创建第一个窗体">创建第一个窗体</h3><p>这个窗体啥也没有，就输出一个蓝色屏幕，下面是创建这个窗体的过程</p><p><img src="/images/DX%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3.png" class="lazyload" data-srcset="/images/DX%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DX创建窗口"></p><ul><li><p>WindowProc是一个回调函数，用于处理传给窗口的消息</p></li><li><p><code>OnInt()</code>是<code>D3D12HelloWindow</code>的生命周期函数，包含两个部分，加载管线和加载资源</p></li></ul><p><img src="/images/OnInit.png" class="lazyload" data-srcset="/images/OnInit.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="OnInit"></p><ul><li><p>描述符堆（Descriptor Heap），用于CPU向GPU传递资源（比如数组、贴图），告诉GPU去哪里访问这些资源</p><ul><li>描述资源的类型、维度、GPU虚拟地址、硬件信息</li><li>我们将描述符绑定在<strong>slots</strong>上，GPU可以通过访问slots上的描述符找到资源</li></ul></li><li><p>栅栏（Fence），可以将其插入命令队列以实现同步</p></li></ul><p>DX12支持多线程渲染，命令队列和命令列表的关系如下</p><p><img src="/images/DX12%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" class="lazyload" data-srcset="/images/DX12%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DX12多线程"></p><h3 id="硬件架构">硬件架构</h3><ul><li>CPU<ul><li>Cache占绝大部分面积</li><li>ALU、控制单元少，但复杂强大</li></ul></li><li>GPU<ul><li>计算核心占绝大部分面积</li><li>计算核心数量极多，个头小，可编程，支持并行</li></ul></li></ul><p><img src="/images/CPU%E5%92%8CGPU.png" class="lazyload" data-srcset="/images/CPU%E5%92%8CGPU.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CPU和GPU"></p><h3 id="渲染管线">渲染管线</h3><p><img src="/images/rendering-pipeline.png" class="lazyload" data-srcset="/images/rendering-pipeline.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="rendering-pipeline"></p><h4 id="输入汇编器">输入汇编器</h4><p>输入汇编器（Input Assembler）</p><ul><li>输入：顶点索引和顶点缓冲</li><li>行为：组装成图元</li><li>输出：传给顶点着色器</li></ul><p>网格（Mesh）是由图元（通常为三角形）组成的几何体</p><p>顶点缓冲区（vertex buffers）存储了顶点相关的数据</p><p>输入布局（Input layout）描述了顶点缓冲区的布局，为顶点属性指定语意，使得输入汇编器能读懂顶点缓冲区</p><p>索引缓冲（index buffers）内含顶点索引，通过指向顶点缓冲区来组成图元</p><p><img src="/images/Mesh.png" class="lazyload" data-srcset="/images/Mesh.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Mesh"></p><p>原始拓扑（Primitive topologies），描述了图元间的连接、邻接关系</p><p><img src="/images/topology.png" class="lazyload" data-srcset="/images/topology.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="topology"></p><p>特别的，Triangle Strip的三个顶点满足公式<br>$$<br>\Delta_i={i, i+(1+i%2), i+(2-i%2)}<br>$$</p><h4 id="光栅器">光栅器</h4><p>光栅器（Rasterizer），发生在片元着色器之前</p><ul><li>输入：NDC空间的2D图元</li><li>行为：<ul><li>剔除：裁剪掉视口外的图元，剔除背面（可选）</li><li>画线：获得图元所覆盖的像素区域</li><li>插值：根据重心坐标和顶点属性进行插值</li></ul></li><li>输出：传给片元着色器</li></ul><h3 id="资源管理">资源管理</h3><h4 id="内存">内存</h4><p>GPU可以访问四种内存</p><ul><li>专用视频内存（Dedicated video memory）：我们分配GPU资源最常用的地方</li><li>专用系统内存（Dedicated system memory）：GPU内部专用内存，应用程序不能使用</li><li>共享系统内存（Shared system memory）：CPU可见的显存，常用于CPU向GPU传递数据</li><li>CPU系统内存（CPU system memory）：CPU可以任意访问，但GPU要通过PCI-e总线访问，速度极慢</li></ul><h4 id="视图和描述符">视图和描述符</h4><p>视图=描述符≈资源指针</p><table><thead><tr><th>简称</th><th>全称</th><th>意义</th></tr></thead><tbody><tr><td>CBV</td><td>Constant buffer view</td><td>描述常量缓冲区</td></tr><tr><td>UAV</td><td>Unordered access view</td><td>常用于多线程读写</td></tr><tr><td>SRV</td><td>Shader resource view</td><td>描述只读纹理和缓冲区</td></tr><tr><td>Samplers</td><td></td><td>采样器</td></tr><tr><td>RTV</td><td>Render Target View</td><td>描述渲染目标</td></tr><tr><td>DSV</td><td>Depth Stencil View</td><td>描述深度缓冲区</td></tr><tr><td>IBV</td><td>Index Buffer View</td><td>描述顶点索引缓冲区</td></tr><tr><td>VBV</td><td>Vertex Buffer View</td><td>描述顶点缓冲区</td></tr><tr><td>SOV</td><td>Stream Output View</td><td>描述流输出缓冲区</td></tr></tbody></table><h4 id="资源状态">资源状态</h4><p>资源的多线程读写是冲突的，于是要通过资源状态实现互斥</p><p>GPU使用转化资源的状态来指定资源的预期用途，比如要读一张贴图，该贴图必须处于读取状态</p><p>DX12使用<code>ResourceBarrier</code>管理资源状态</p><h4 id="根签名">根签名</h4><p>在HLSL中，我们可以声明一个变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Texture2D g_texture : register(t0);</span><br></pre></td></tr></table></figure><p>该变量的类型是SRV，绑定到<code>t</code>的第0槽</p><ul><li><code>t</code>：SRV</li><li><code>s</code>：Samplers</li><li><code>u</code>：UAV</li><li><code>b</code>：CBV</li></ul><h3 id="管道状态">管道状态</h3><p>管道状态（pipeline state object ，PSO）定义了渲染管线的每个阶段的行为，PSO创建后不可变</p><p><img src="/images/PSO.png" class="lazyload" data-srcset="/images/PSO.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PSO"></p><h3 id="Bundles">Bundles</h3><p>捆绑包（Bundles），用于将少量命令组合在一起，方便使用</p><p>Bundles只能提交给CommandList，不能直接提交给命令队列</p><h3 id="常量缓冲区">常量缓冲区</h3><p>就是CBuffer，是一种访问延迟更低，适合CPU高频更新的缓冲区</p><p>在着色器程序执行期间，常量缓冲区不会发送改变</p><p>常量缓冲区需要256字节<strong>对齐</strong>，一般使用4KB或者64KB（关于为什么要对齐、什么是假引用、缓存行，可以去看《高性能C++》笔记）</p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DX12 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TA面试题</title>
      <link href="/graphics/TA%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/graphics/TA%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>TA面试题</h1><p>这里面不少答案都是我自己凭感觉答的，不保真</p><h4 id="什么是渲染管线">什么是渲染管线</h4><p><strong>渲染管线</strong>是通过安排CPU发出Draw Call的内容以及顺序，指导GPU进行一系列操作，并协同将开发者期待的图像渲染在屏幕上</p><ul><li>剔除</li><li>渲染</li><li>后处理</li></ul><h4 id="什么是Draw-Call">什么是Draw Call</h4><p>Draw Call是CPU为GPU准备渲染数据，并指令GPU进行一次渲染的操作，是重量级的</p><h4 id="什么是Batching">什么是Batching</h4><p>将多个简单、使用同一材质的物体合并渲染的方式叫Batching</p><p><em>batch是批的意思</em></p><h4 id="渲染管线的渲染流程">渲染管线的渲染流程</h4><ul><li><p>延迟着色阶段（光栅化）Deferred Shading (rasterization)</p></li><li><p>直接阴影阶段（光线追踪或光栅化）Direct shadows (ray trace or rasterization)</p></li><li><p>光照阶段（计算着色器+光线追踪）Lighting (compute + ray trace)</p></li><li><p>反射阶段（光线追踪或计算着色器）Reflections(ray trace or compute)</p></li><li><p>全局光照阶段（计算着色器+光线追踪）Global Illumination (compute and ray trace)</p></li><li><p>环境光遮蔽阶段（光线追踪或计算着色器） Ambient occlusion (ray trace or compute)</p></li><li><p>透明与半透明渲染阶段（光线追踪+计算着色器）Transparency &amp; Translucency (ray trace and compute)</p></li><li><p>后处理阶段（计算着色器）Post processing (compute)</p></li></ul><h4 id="渲染流水线的基本流程">渲染流水线的基本流程</h4><p>渲染就是从一个三维场景出发，获得一个二维图像的过程。分为四个过程，应用阶段、几何阶段、光栅化阶段、像素处理阶段，其中几何阶段光栅化阶段主要在GPU中进行。</p><p>几何阶段分为五个步骤：顶点着色器、曲面细分着色器、几何着色器、裁剪、屏幕映射</p><p>光栅化阶段分为四个步骤：三角形设置、三角形遍历、片元着色器、逐片元操作</p><img src="/images/pipeline.png" class="lazyload" data-srcset="/images/pipeline.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1" style="zoom:33%;" /><h5 id="什么是顶点着色器">什么是顶点着色器</h5><ul><li><p>输入值是CPU通过Draw Call发出的顶点数组（没有索引）</p></li><li><p>输出值是齐次裁剪空间坐标（如果不使用细分着色器和几何着色器）</p></li></ul><h5 id="什么是细分着色器">什么是细分着色器</h5><ul><li><p>在显卡中**视口变换器(Viewport Transform)**中实现</p></li><li><p>将复杂的曲面转化为简单的点、线、三角形，可以增加网格细度，并在细分后的顶点上生成插值属性</p></li><li><p>如果使用了曲面细分着色器，顶点着色器就不会处理空间变化（如果没有顶点动画的需求，顶点着色器只负责传递数据），而是交给曲面着色器和几何着色器</p></li><li><p>在不改变网格外形的情况下，对网格进行平滑操作</p></li></ul><h5 id="什么是几何着色器">什么是几何着色器</h5><ul><li>在视口变换器中实现，输出值是齐次裁剪空间</li><li>能改变顶点数量</li><li>能按索引访问顶点</li></ul><h5 id="什么是网格着色器">什么是网格着色器</h5><ul><li>新一代三合一着色器，用于整合顶点、细分、几何着色器</li><li>可以实现无矩式渲染</li></ul><h5 id="屏幕映射">屏幕映射</h5><ul><li>输入齐次裁剪空间</li><li>（通过透视除法）转化到<strong>归一化设备坐标(NDC)</strong>，最后输出屏幕空间坐标</li></ul><h4 id="什么是渲染路径">什么是渲染路径</h4><p><strong>渲染路径</strong>是一系列对光照和着色(尤其是光照)的控制选项的集合</p><p>主流引擎支持前向渲染，延迟渲染，和自定义渲染</p><ul><li>前向渲染<ul><li>批次数=相机数x对象数x（除了主有向平行光外的逐片元光照数+1）</li><li>随着片元光照数量增多，性能大幅下降</li></ul></li><li>延迟渲染<ul><li>类似一种后处理</li><li>批次数=相机数x（网格数+逐片元光照数）</li><li>将几何通路和光照渲染通路分开，几何通道结果输送到G-Buffer中，然后对每个像素只进行一次光照计算</li></ul></li><li>自定义渲染<ul><li>屏幕后处理、天空盒、透明物体</li></ul></li></ul><h4 id="延迟渲染">延迟渲染</h4><h5 id="为什么延迟渲染不支持透明度混合">为什么延迟渲染不支持透明度混合</h5><p>因为半透明网格在G-Buffer中会被其他片元覆盖</p><h5 id="为什么延迟渲染不支持真的对抗锯齿">为什么延迟渲染不支持真的对抗锯齿</h5><p>因为G-Buffer需要的带宽远远大于帧缓冲，在多重抗锯齿下难以满足负载</p><h4 id="前向渲染">前向渲染</h4><p>前向渲染的渲染通路（Pass）有两种，分布是<strong>基本通路（forwardbase）<strong>和</strong>附加通路（forwardadd）</strong></p><p><strong>forwardbase</strong></p><ul><li>对所有的默认的<strong>有向平行光源</strong>及其产生的阴影进行逐片元计算，同时对其它基于顶点的和基于球谐光照的光源，以及物体的自发光、统一环境光和光照贴图进行计算</li><li>只对一个有效灯光执行一次，所以只会执行一次</li></ul><p><strong>forwardadd</strong></p><ul><li>对剩下的<strong>使用逐片元光照的光源</strong>进行光照计算</li><li>必须和forwardbase一同使用，不然会被忽略掉</li><li>对forwardbase外所有有效灯光都执行一次，所以会执行多次</li></ul><h4 id="向量">向量</h4><h5 id="向量点乘叉乘的几何意义">向量点乘叉乘的几何意义</h5><p>点乘是投影，叉乘是法向量（方向符合右手定则，沿大拇指方向）</p><h5 id="向量点乘叉乘的数学意义">向量点乘叉乘的数学意义</h5><p>$\mathbf{a} =\left( x_{1},y_{1},z_{1}\right)  $</p><p>$\mathbf{b} =\left( x_{2},y_{2},z_{2}\right)  $</p><p>$\mathbf{a} \cdot \mathbf{b} =|\mathbf{a} ||\mathbf{b} |\cos \theta =x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}$</p><img src="/images/叉积.png" class="lazyload" data-srcset="/images/叉积.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="叉积" style="zoom: 67%;" /><h5 id="求向量-mathbf-a-关于向量-mathbf-b-的对称向量-mathbf-c">求向量$\mathbf{a}$关于向量$\mathbf{b}$的对称向量$\mathbf{c}$</h5><p>$\mathbf{a} \cdot \mathbf{b}=\mathbf{c} \cdot \mathbf{b}$</p><p>$|\mathbf{a} |=|\mathbf{c} |$</p><h5 id="求点M关于直线l的对称点N">求点M关于直线l的对称点N</h5><p>M和N的中点在直线上</p><p>$\overrightarrow{MN} $与直线垂直</p><h4 id="欧拉角是什么？有何优缺点">欧拉角是什么？有何优缺点</h4><p>欧拉角是一个直观利用三维向量表达旋转的方法</p><p>优点：占用的空间小，不会遇到非法输入</p><p>缺点：没有统一标准、不能跨平台；三个分量可能不正交，可能有无法表示的角度；不能插值运算</p><h4 id="图形渲染用到哪些空间">图形渲染用到哪些空间</h4><ul><li>顶点着色器：模型空间–M–世界空间–V–观察空间–P–齐次裁剪空间----屏幕空间</li></ul><h4 id="什么是模版测试">什么是模版测试</h4><p>将屏幕的部分像素通过一个通道盖住，在渲染时剔除通道上不满足条件的值</p><h4 id="如何渲染半透明物体">如何渲染半透明物体</h4><ul><li>透明度测试</li><li>透明度混合</li></ul><h4 id="如何优化着色器代码">如何优化着色器代码</h4><ul><li>复杂计算放在顶点着色器中</li><li>简化等式，比如说：p = sqrt(2*(X+1))可以改写成1.414*sqrt(X+1)等</li><li>尽量使用内建函数</li><li>重复度低的操作可以交给CPU</li><li>使用顺序结构代替分支</li><li>丢弃片元时直接将alpha设为0</li><li>纹理图尽量使用2的n次方大小</li><li>将许多小纹理拼成一个大纹理</li><li>近点采样能满足要求就不要使用线性采样</li></ul><h4 id="如何判断多边形是凸多边形">如何判断多边形是凸多边形</h4><ul><li>角度法：内角是否小于180°</li><li>凸包法：如果凸包和原始多边形点数一样多，那么就是凸多边形</li><li>顶点凹凸性：本质上还是角度法，就是相邻顶点组成向量叉乘</li></ul><h4 id="相交测试">相交测试</h4><p><em>见图形学笔记</em></p><h4 id="法线贴图">法线贴图</h4><p>纹理就是贴图</p><p>法线纹理用RGB三个通道分布存储法向量在XYZ轴上分量大小</p><p>由于法线贴图大部分文素的方向都是朝向法线方向，于是法线贴图大多是蓝色的</p><h4 id="如何渲染阴影">如何渲染阴影</h4><ul><li>体积阴影法</li><li>深度阴影法</li></ul><h4 id="什么是HDR">什么是HDR</h4><p>高动态范围，一种颜色缓冲技术，使用更高的精度来表示亮度，能更真实的反应光照</p><p>HDR通过色调映射转到LDR</p><h4 id="什么是伽马矫正">什么是伽马矫正</h4><p>早期摄像机通过伽马加码，将实际亮度存储为更亮的值，显示时通过该骂解码获得正确的功率</p><h4 id="什么是色调映射">什么是色调映射</h4><p>就是利用显示器有限的亮度范围来近似实现HDR，就是将亮度映射到[0,1]的范围内，并压缩到8位的渲染目标上</p><h4 id="什么是PBR">什么是PBR</h4><p>基于物理的渲染</p><h4 id="正交投影和透视投影的区别">正交投影和透视投影的区别</h4><ul><li>都是源于对针孔摄像机对数学建模</li><li>视锥形状不一样</li></ul><h4 id="什么是齐次坐标">什么是齐次坐标</h4><p>为了实现仿射变换，将三维顶点引入四维空间，这个空间叫做齐次坐标空间</p><h4 id="旋转平移矩阵">旋转平移矩阵</h4><p><em>见图形学笔记</em></p><h4 id="高光模型">高光模型</h4><p>漫反射模型</p><ul><li>Lambert模型：反射光强度和 表面法线和光源的夹角的 余弦值成正比</li><li>半Lambert模型：光照有一个保底值，于是没有黑面</li><li>Minnaert模型：用于模拟丝绒</li><li>Oren-Nayar模型：风之旅人的沙子</li></ul><p>高光反射模型</p><ul><li>Phong模型：纯几何的经验模型，就是在Lambert漫反射上加了一点高光，强度与 视角方向和反射光方向的夹角的 余弦值成正比</li><li>Blinn-Phong模型：Phong的改进，不计算反射光，而是计算视角方向和光源方向的角平分矢量h，用h替代反射方向计算高光</li><li>Schlick模型：对BP模型的优化，简化一些运算，能获得更类似于油漆的效果</li></ul><p>基于物理的模型</p><ul><li>Cook-Torrance模型</li></ul><h4 id="什么是光栅化">什么是光栅化</h4><p>是渲染流水线的一个重要阶段</p><p>三角形设置和三角形遍历可以合成光栅化，计算三角网格，并进行线性插值</p><h4 id="阴影，软阴影">阴影，软阴影</h4><h4 id="什么是抗锯齿">什么是抗锯齿</h4><p>锯齿是走样的一种，指在渲染三角形、线的时候，像素要么存在，要么不存在，于是出现锯齿现象</p><ul><li>SSAA，超级采样抗锯齿，翻倍渲染向下采样</li><li>MSAA，多重采样抗锯齿，每个像素内有多个采样点，渲染时以点数加权获得（性能好，不支持延迟渲染）</li><li>FXAA/TXAA，放弃精度，让边缘模糊</li></ul><h4 id="延时渲染">延时渲染</h4><p>场景中有大量实时光源时，前向渲染效率会下降，使用两个Pass，一个不计算光照，只计算片元是否可见</p><p>不支持抗锯齿，不能处理透明物体</p><h4 id="故障检测">故障检测</h4><h4 id="后处理">后处理</h4><ul><li>亮度饱和度对比度</li><li>边缘检测</li><li>高斯模糊</li><li>动态模糊</li><li>Bloom效果</li></ul><h4 id="贴图技术">贴图技术</h4><p>贴图就是纹理</p><h4 id="BRDF">BRDF</h4><p>双向反射分布函数</p><h4 id="作品集里实现原理">作品集里实现原理</h4><p>ezy-slice原理：网格中存储了顶点数据、三角形数据、法线数据，使用MeshFilter获得sharemesh（mesh是新网格，sharemesh是原始网格）</p><p>物体的节点和三角形被分为三个部分（上下和切割面），相交处的三角形做分割操作，然后让原始网格不可见</p><h4 id="如何区分位置和方向">如何区分位置和方向</h4><p>齐次坐标，w==0就是位置，w==1就是方向</p><h4 id="SSAO">SSAO</h4><p>SS（Screen Space），都是后处理</p><p>SSGI屏幕空间全局光照</p><p>SSAO屏幕空间环境光遮蔽，对屏幕空间上每一个片元，在其法线范围的半球体中进行采样，采样点在深度纹理采样，从而判断该点是否被遮蔽</p><p>一般来说使用SSAO后还要在进行一次模糊，还需要进行时域平滑来避免闪动</p><h4 id="SSR">SSR</h4><p>SSR屏幕空间反射，在相机中发射出n条光线，然后根据物体的法向量和摄像机的射线方向计算出这条光线的反射方向。再对他进行raymarch（光线步进）计算。</p><h4 id="动态模糊">动态模糊</h4><p>种类</p><ul><li>相机动态模糊</li><li>对象动态模糊</li></ul><p>原理</p><ul><li>保存多帧数据进行混合</li><li>速度映射图，图中存储了每一个像素的速度，沿着这个速度采集像素，进行加权混合，得到模糊效果</li></ul><h4 id="线框">线框</h4><h5 id="方法1-深度偏移（这玩意不是线框，是描边）">方法1:深度偏移（这玩意不是线框，是描边）</h5><p>使用两个Pass渲染，一个正常渲染，一个在深度偏移的情况下渲染一遍线</p><ul><li>两个Pass有性能损失</li><li>深度偏移是为了防止线条被遮挡，这会导致多边形和线框在相同位置的片元的深度值不一样</li></ul><h5 id="方法2-几何着色器（这才是线框）">方法2:几何着色器（这才是线框）</h5><p>几何着色器可以使用索引数组访问顶点的拓扑结构</p><p>线框渲染可以使用几何着色器访问三角形，并计算每个顶点到对边的垂线长度，于是通过插值获得三角形中每个点到三角形三个边的最短距离</p><p>我们知道在光栅化阶段要插值上色，那么我们可以在插值的时候进行判断，当垂线距离符合条件时（离三角形边特别近）就染上线框的颜色</p><h4 id="片元着色器和像素着色器的区别">片元着色器和像素着色器的区别</h4><p><em>在大部分情况下没有区别</em></p><p>在极个别情况下（大概是OpenGL那边）我门认为如果片元着色器中的输入数据是恰好覆盖屏幕的四边形时，这个片元着色器被称为像素着色器</p><h4 id="SDF">SDF</h4><p>距离函数</p><p>shadertoy的本质就是通过编写（2D）距离函数来绘制物体</p><h4 id="为什么shader中少用分支和循环">为什么shader中少用分支和循环</h4><p>因为在gpu中，分支的实现原理是两个分支都执行，然后丢弃不需要的分支，这个增长是指数级的（2^n^）</p><h4 id="什么是Cubemap">什么是Cubemap</h4><p>立方体纹理，是实现环境映射的一种方法</p><h4 id="什么是光照探针">什么是光照探针</h4><p>是一组封装后的Cubemap，在烘培或预计算时，对空间中的一些采样点（光照探针）采集Cubemap，在运行环境渲染运动物体时，CPU会从离物体最近的光照探针中获取Cubemap，按照距离进行插值。</p><p>这个过程实现了CPU和GPU的解耦，CPU只需要维护一组固定的光照探针组，GPU只需要处理与这个物体相关的临近Cubemap</p><p>通过光照探针获取环境景象需要对场景进行六次渲染（毕竟有六个面）</p><h4 id="什么是球偕函数">什么是球偕函数</h4><p>将真实环境中连续的光照方程进行离散化，通过球形坐标系分解简化反射方程，通过球偕变换获得球偕系数，在运行时根据球偕系数重建方程</p><p>采样-分解-变换-重构</p><h4 id="参数和分量">参数和分量</h4><p>参数是黑盒，分量是白盒（你可以理解的是，别人在unity面板上拖动的属性多半是参数，一种东西的组成是分量，比如颜色可能就有由高光、漫反射等分量）</p><h4 id="为什么次表面散射用漫反射做高斯模糊">为什么次表面散射用漫反射做高斯模糊</h4><p>因为lambert的光照强度与入射光线和法线夹角有关，而折射和反射的比例也与这个夹角有关（菲涅尔）</p><p>折射光是次表面散射的入射光，折射的光越强，散射的光也会越强</p><h4 id="什么是光线步进">什么是光线步进</h4><p><strong>光线步进（raymarching）</strong>：从摄像机位置向屏幕每一个像素点发射一条光线，光线按照一定步长前进，并检测当前光线是否位于物体表面，据此调整光线前进幅度，直到抵达物体表面，再按照一般光线追踪的方法计算颜色值。</p><h4 id="什么是MC算法">什么是MC算法</h4><p>**步进立方体算法（Marching Cube）**是一种在密度场中采样来生成多边形的算法，在生成多边形之后再依照多边形渲染的过程进行正常的渲染。 相比射线扫描算法，步进立方体算法可以生成并保存多边形，所以在密度场的修改频率不高的情况下，使用步进立方体算法可以节省很多不必要的性能消耗。</p><p>核心：确定等值面</p><h4 id="什么是屏幕空间阴影纹理">什么是屏幕空间阴影纹理</h4><p>对于多光源的情况，每个光源都可以产生一个深度阴影纹理。在着色器中对这些深度阴影纹理逐个进行处理，可以得到若干个屏幕空间的阴影纹理，将这些屏幕空间下的阴影纹理混合就可得到一个总的屏幕空间阴影纹理，它表示了在屏幕空间中某个片元接受到的来自所有光源产生的阴影强度的总和</p><h4 id="什么是URP">什么是URP</h4><p>unity内的**渲染管线（Render pipelines）**包括</p><ul><li>内置渲染管线（Build-in）</li><li>可编程渲染管线（Scriptable Render Pipeline，SRP）<ul><li>高清渲染管线（High Definition Render Pipeline，HDRP）</li><li>通用渲染管线（Universal Render Pipeline，URP）</li></ul></li></ul><h4 id="什么是滤波模式">什么是滤波模式</h4><p>纹素坐标是整数值，但UV坐标不是，所以要有一种方法由UV坐标获得纹素值</p><h5 id="最近相邻滤波-Nearest-neighbor-filtering，或者Point-sampling">最近相邻滤波(Nearest neighbor filtering，或者Point sampling)</h5><ul><li><p>UV坐标 x 纹理大小，然后四舍五入取最近的纹素</p></li><li><p>有明显的像素块</p></li></ul><h5 id="双线性滤波-Bilinear-filtering，或者liner-filtering">双线性滤波(Bilinear filtering，或者liner filtering)</h5><ul><li>根据一个坐标到其附近最近的四个像素点的距离进行加权平均，得到一个混合的颜色</li></ul><img src="/images/双线性滤波.png" class="lazyload" data-srcset="/images/双线性滤波.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="双线性滤波" style="zoom: 33%;" /><h5 id="三线性滤波-Trilinear-filtering">三线性滤波(Trilinear filtering)</h5><ul><li>在相邻的两个Mipmap层次上分别进行双线性滤波，再对得到的两个值进行线性插值</li><li>当距离非常大或非常小的时候，三线性滤波会退化为双线性滤波</li></ul><h5 id="各项异性滤波-Anisotropic-filtering">各项异性滤波(Anisotropic filtering)</h5><p>当一个目标表面和透视摄像机之间的角度较大时，纹理的填充面积实际上并不是正方形，这引入了模糊和闪烁等瑕疵</p><ul><li>需要在一个非正方形区域内采样和混合</li><li>有的使用长方形，有的使用梯形</li></ul><h4 id="什么是纹理映射">什么是纹理映射</h4><p><em>就是将三维的空间坐标点转化为二维的纹理坐标点</em></p><p><strong>步骤</strong>：</p><ol><li>投影映射</li><li>变换函数</li><li>纹理采样</li><li>纹理转换</li></ol><h4 id="什么是纹理压缩">什么是纹理压缩</h4><p>这是一种有损压缩，对于一张原始纹理，会创建两张小纹理A和B，同时还有一个矩阵M，M的行列和原始纹理的长宽一致，里面的值类似于调色板中的索引，实现纹理A和纹理B的混合</p><h4 id="GPU的寻址方式">GPU的寻址方式</h4><h5 id="集成显卡">集成显卡</h5><p>对集成显卡来说，GPU使用CPU专门划分出来的一份内存空间**UMA（Unified Memory Architecture，一致性储存架构）**作为显存，GPU和CPU使用不同的虚拟地址对UMA中同一个物理地址进行寻址，两者共享总线。</p><p>在渲染时，CPU将顶点数据存储到主存中，然后GPU通过**GART(Graphic Address Remapping Table，显存地址重定位表)**访问UMA</p><h5 id="独立显卡">独立显卡</h5><p>独立显卡中CPU和显卡的沟通是使用异步的**DMA(Direct Memory Access，内存直接访问)**实现的。</p><ol><li>CPU将DMA命令从内存中读取，并写入DMA控制器</li><li>DMA控制器直接操控内存总线，在不依赖CPU的情况下将数据传输给显卡驱动</li><li>显卡驱动给DMA控制器发送信息（握手）</li><li>DMA占用内存总线，向内存请求地址，向显卡发送信号</li><li>显卡接受信号后将数据传输到内存，并清除DMA请求信号</li><li>沟通结束，触发一次CPU中断</li></ol><h4 id="CPU和GPU分支预测方式有何差别">CPU和GPU分支预测方式有何差别</h4><h5 id="CPU">CPU</h5><p>CPU在流水线中进行分支预测</p><ul><li>静态分支预测</li><li>动态分支预测</li><li>协同分支预测</li></ul><h5 id="GPU">GPU</h5><p>将两个结果都运行一次，然后丢弃不需要的分支，这样会严重影响性能（指数级），这个现象被称为<strong>线路分歧</strong></p><h4 id="纹理数据在GPU中是如何排列的">纹理数据在GPU中是如何排列的</h4><p>纹理存储器中的数据以一维/二维/三维数组的形式存储在显存中，可以通过缓存加速访问</p><p>在kernel中访问纹理存储器的操作称为<strong>纹理拾取(texture fetching)</strong></p><p>将显存中的数据与纹理参照系关联的操作，称为将数据与<strong>纹理绑定(texture binding)</strong></p><h4 id="shader中的变量类型（OpenGL）">shader中的变量类型（OpenGL）</h4><h5 id="uniform">uniform</h5><p>在顶点着色器和片元着色器中的声明方式完全一样，可以视为被双方共享的全局变量</p><h5 id="attribute">attribute</h5><p>只能在顶点着色器中使用的变量，一般用于存储顶点的位置、法线、uv、颜色信息</p><h5 id="varying">varying</h5><p>顶点着色器和片元着色器之间做数据传输用的变量，必须保证在两者中声明保持一致</p><h4 id="如何保证顶点着色器传入片元着色器的数据一致性">如何保证顶点着色器传入片元着色器的数据一致性</h4><p>varying变量声明一致？</p><h4 id="矩阵乘法">矩阵乘法</h4><p>两条直线的交点就是C的位置</p><img src="/images/矩阵乘法.png" class="lazyload" data-srcset="/images/矩阵乘法.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="矩阵乘法" style="zoom:50%;" /><p>x左乘A</p><p><img src="/images/x%E5%B7%A6%E4%B9%98A.png" class="lazyload" data-srcset="/images/x%E5%B7%A6%E4%B9%98A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="x左乘A"></p><p>x右乘A</p><img src="/images/x右乘A.png" class="lazyload" data-srcset="/images/x右乘A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="x右乘A" style="zoom:50%;" /><h4 id="直线扫描转化法">直线扫描转化法</h4><h5 id="数值微分法DDA">数值微分法DDA</h5><p>思想：步进和通过舍入选择像素</p><p>$P_{0}(0,0)$到$P_{1}(5,2)$</p><p>k=0.4</p><table><thead><tr><th>$i$</th><th>$x_{i}=x_{i-1}+1$</th><th>$y_{i}=y_{i-1}+k$</th><th>$round(y_{i})$</th><th>坐标</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>(0,0)</td></tr><tr><td>1</td><td>1</td><td>0+0.4=0.4</td><td>0</td><td>(1.0)</td></tr><tr><td>2</td><td>2</td><td>0.4+0.4=0.8</td><td>1</td><td>(2,1)</td></tr><tr><td>3</td><td>3</td><td>0.8+0.4=1.2</td><td>1</td><td>(3,1)</td></tr><tr><td>4</td><td>4</td><td>1.2+0.4=1.6</td><td>2</td><td>(4,2)</td></tr><tr><td>5</td><td>5</td><td>1.6+0.4=2.0</td><td>2</td><td>(5,2)</td></tr></tbody></table><h5 id="中点画线法">中点画线法</h5><p>相比于DDA算法，省去了浮点数运算</p><p>直线方程$F(x,y)=Ax+By+C=0$，若$F(x,y)&gt;0$则位于直线上方，若$&lt;0$则位于直线下方，若$=0$则在点上</p><p>使用步进思想，根据<strong>中点误差项</strong>判断是向右移动还是向右上移动（如果0&lt;k&lt;1)</p><img src="/images/中点画线.png" class="lazyload" data-srcset="/images/中点画线.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="中点画线" style="zoom: 33%;" /><p>直线已经经过点$P$，下一步经过了点$P_{u}$和$P_{d}$，他们的中点是M，我们将M带入直线方程，通过判断大小来决定是不是</p><p>为了进一步降低消耗，使用步进，每一次就将点$P(x_{i}+1,y_{i}+0.5)$带入直线方程$Ax+By+C=0$</p><ul><li><p>d&lt;0就取右边的点，$d_{i+1}=d_{i}+A+B$</p></li><li><p>d&gt;0就取右上的点，$d_{i+1}=d_{i}+A$</p></li></ul><p>只不过我们只关心符号，所以可以用2d代替d</p><ul><li><p>d&lt;0就取右边的点，$d_{i+1}=d_{i}+2A+2B$</p></li><li><p>d&gt;0就取右上的点，$d_{i+1}=d_{i}+2A$</p></li></ul><h5 id="Bresenham画线法">Bresenham画线法</h5><p>本质上和中点画线一样</p><ul><li><p>$d_{i}&lt;0$就取右边的点，$d_{i+1}=d_{i}+2\Delta y$</p></li><li><p>$d_{i}\geqslant 0$就取右上的点，$d_{i+1}=d_{i}+2\Delta y-2\Delta x$</p></li><li><p>$d_{1}=2\Delta y-\Delta x$</p></li></ul><p>$P_{0}(0,0)$到$P_{1}(5,2)$</p><p>k=0.4</p><p>$\Delta y=2$</p><p>$\Delta x=5$</p><table><thead><tr><th>$i$</th><th>$d_{i}$</th><th>$x_{i}$</th><th>$y_{i}$</th><th>坐标</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>(0,0)</td></tr><tr><td>1</td><td>$d_{1}=2\Delta y-\Delta x=-1&lt;0$</td><td>1</td><td>0</td><td>(1.0)</td></tr><tr><td>2</td><td>$d_{2}=d_{1}+2\Delta y=3&gt;0$</td><td>2</td><td>1</td><td>(2,1)</td></tr><tr><td>3</td><td>$d_{3}=d_{2}+2\Delta y-2\Delta x=-3&lt;0$</td><td>3</td><td>1</td><td>(3,1)</td></tr><tr><td>4</td><td>$d_{4}=d_{3}+2\Delta y=1&gt;0$</td><td>4</td><td>2</td><td>(4,2)</td></tr><tr><td>5</td><td>$d_{5}=d_{4}+2\Delta y-2\Delta x=-5&lt;0$</td><td>5</td><td>2</td><td>(5,2)</td></tr></tbody></table><h4 id="构建贝塞尔曲线">构建贝塞尔曲线</h4><h5 id="一阶">一阶</h5><p>两个点$P_{0},P_{1}$</p><p>直接坐标线形插值</p><p>$B_{1}(t)=(1-t)P_{0}+tP_{1}$</p><h5 id="二阶">二阶</h5><p>三个点$P_{0},P_{1},P_{2}$</p><p>先求$P_{0}P_{1}$和$P_{1}P_{2}$的一阶贝塞尔，然后再对两个一阶进行线性插值</p><h5 id="n阶">n阶</h5><p>$$<br>B_{i,n}\left( t\right)  =\frac{n!}{i!\left( n-i\right)  !} t^{i}\left( 1-t\right)^{n-i}<br>$$</p><ul><li>$i$是第几项，从0开始</li><li>$n$是控制点总数</li></ul><h4 id="线段的裁剪">线段的裁剪</h4><h5 id="Cohen-Sutherland">Cohen-Sutherland</h5><p>尽量避免求交运算</p><p>编码，把空间分为九个部分，其中中间部分是屏幕，其outcode编码为</p><img src="/images/裁剪.png" class="lazyload" data-srcset="/images/裁剪.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="裁剪" style="zoom:50%;" /><p>判断时，两个端点的outcode值为$o_{1}和o_{2}$</p><ul><li>若$o_{1}=o_{2}=0（其实是0000）$：说明两个点都在屏幕中间</li><li>若$o_{1}\neq 0,o_{2}=0（12顺序可以颠倒）$：说明一个在屏幕内，一个在屏幕外，而非零端点的编码说明了线段与裁剪窗口哪一个边（或者两个边）相交，需要计算交点</li><li>若$o_{1}&amp;o_{2}\neq 0$：说明两个点在裁剪窗口的同一侧，可以直接丢弃</li><li>若$o_{1}&amp;o_{2}= 0$：需要计算交点</li></ul><h5 id="Liang-Barsky">Liang-Barsky</h5><img src="/images/梁友栋.png" class="lazyload" data-srcset="/images/梁友栋.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="梁友栋" style="zoom: 25%;" /><p>窗口$Wx_{l}=0,Wx_{r}=4,Wy_{b}=0,Wy_{t}=3$</p><p>直线：<br>$$<br>\begin{cases}x=-2+u\left( 7+2\right)  &amp;\ y=6+u(-2-6)&amp;\end{cases}<br>$$</p><p>$$<br>\begin{cases}u_{1}=2/9&amp;\ u_{2}=2/3&amp;\ u_{3}=3/4&amp;\ u_{4}=3/8&amp;\end{cases}<br>$$</p><p>$u_{max}=\max(0,2/9,3/8)=3/8$</p><p>$u_{min}=\min(1,2/3,3/4=2/3)$</p><p>所以保留$u_{2}u_{4}$，其中$u_{2}=(4,2/3)\ u_{4}=(11/8,3)$</p><h3 id="Early-z">Early-z</h3><p>在vertex后，fragment前做一次深度测试，如果失败，则不进行fragment（如果成功，还是要在fragment中做ZTest），这样可以大幅提高性能</p><p>开启AlphaTest需要关闭Early-Z，因为AlphaTest通过会写入深度值，而新写入的深度值无法通过Early-Z，于是本该输出的颜色被剔除了（现在硬件做了优化，可以更智能的自动开关Early-Z）</p><h3 id="什么是球面度">什么是球面度</h3><p><strong>球面度sr</strong>是立体角的国际单位（平面角的单位是<strong>角度/弧度</strong>），可以理解为三维的弧度</p><ul><li><p>弧度</p><ul><li>在一个圆上切一个扇形，弧长等于$r$所对应的角为1弧度</li><li>一个完整的圆的弧度为$2\pi$</li></ul></li><li><p>球面度</p><ul><li>在一个球上切一个“锥形”，锥形的底面积等于$r^2$所对应的角为1球面度</li><li>一个完整的球的球面度为$4\pi$</li></ul></li></ul><img src="/images/球面度.png" class="lazyload" data-srcset="/images/球面度.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球面度" style="zoom:50%;" /><h3 id="为什么BRDF-函数的单位是-1-sr">为什么BRDF 函数的单位是 1/sr</h3><p>BRDF，双向反射分布函数，是材质表面某一点出射**辐射率（Radiance）<strong>和入射</strong>辐照度（Irradiance）**的比值<br>$$<br>BRDF=\frac{dL\left( \omega_{o} \right)  }{dE\left( \omega_{i} \right)  }<br>$$</p><ul><li>辐射率$L$：每单位面积每单位**投影固体角（projected solid angle）**上的能量</li><li>辐照度$E$：每单位面积上的能量</li></ul><h4 id="为什么BRDF不直接用出射辐射率-入射辐射率呢？">为什么BRDF不直接用出射辐射率/入射辐射率呢？</h4><h5 id="原因一：因为入射辐射率很难测量">原因一：因为入射辐射率很难测量</h5><p>测量**出射辐射率$L_{0}$**很简单，只要我在出射方向上放一个下面的仪器，对准该点就可以了</p><img src="/images/测量辐射率.png" class="lazyload" data-srcset="/images/测量辐射率.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="测量辐射率" style="zoom: 33%;" /><p>测量<strong>入射辐射率</strong>很麻烦，需要要求光源很小，没有其他光的干扰，所以实际测量的时候不可行，于是不使用，最后BRDF就是出射辐照度/入射辐射率，这两个</p><p>而测量<strong>辐照度$E_{i}$<strong>只需要一个面积较小的平面，接收半球方向的</strong>光通量$\Phi $</strong>，$E=\Phi /S $</p><img src="/images/测量辐照度.png" class="lazyload" data-srcset="/images/测量辐照度.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="测量辐照度" style="zoom:50%;" /><h5 id="原因二：数学">原因二：数学</h5><p>如果是辐射率/辐射率，当出射立体角$\omega_{o}$趋近为0时，两者比值为0（上面是无穷小），没有意义<br>$$<br>\lim_{\omega_{o} \rightarrow 0} \frac{dL_{o}}{L_{i}} =0<br>$$<br>但辐射率/辐照度不等于零，因为上面下面都有无穷小，所以是不定式/等价无穷小，有意义<br>$$<br>\lim_{\omega_{o} \rightarrow 0} \frac{dL_{o}}{dE_{i}} \neq 0<br>$$</p><h3 id="什么是万向节死锁">什么是万向节死锁</h3><p>Gimbal Lock （万向节死锁，或叫 环向锁节）</p><p>在传统的欧拉坐标系，相机可以沿着xyz三个方向旋转，这三个轴有旋转的先后顺序，可以理解为父母层级关系，父轴旋转时子轴也会跟着旋转</p><ul><li>Y轴<ul><li>X轴<ul><li>Z轴</li></ul></li></ul></li></ul><p>相邻两个轴始终保持垂直，但有的时候，第一个轴会和第三个轴重合，于是你就会失去一个自由度，你无法朝向某一个方向旋转了，如果要旋转，就需要同时旋转两个轴，这个旋转很不流畅，会出现抽搐，被称为<strong>万向节死锁</strong></p><p>可以通过引入四元数解决</p><img src="/images/万向节锁.png" class="lazyload" data-srcset="/images/万向节锁.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="万向节锁" style="zoom:50%;" /><h3 id="有什么常见的遮挡算法">有什么常见的遮挡算法</h3><ul><li>画家算法<ul><li>后画覆盖新画</li><li>这是剔除的核心，下面几个都是对其的加速和优化</li></ul></li><li>沃诺克算法（Warnock）<ul><li>不停地四分屏幕<ul><li>当前子空间没有多边形：完成！</li><li>当前子空间只有一个多边形：画！</li><li>当前子空间有简单的前后关系：画前面的！</li><li>当前子空间只有一个像素那么大了：画离该像素点距离最近的多边形！</li><li>否则，继续递归细分</li></ul></li></ul></li><li>BSP-Tree（二维空间分割树）<ul><li>不停地二分空间，在每一个只有简单前后关系的子空间里使用画家算法</li></ul></li><li>Z-Buffer<ul><li>写入颜色时也写入Z值，绘制时根据Z值判断是否覆盖</li><li>有overdraw，只能处理不透明物体，多使用了一个Z-Buffer</li></ul></li></ul><h3 id="如何判断点在三角形内">如何判断点在三角形内</h3><h4 id="同侧法">同侧法</h4><p>若点P在三角形ABC内部，则</p><ul><li>点P和点A在直线BC同侧</li><li>点P和点B在直线AC同侧</li><li>点P和点C在直线AB同侧</li></ul><p>判断是否同侧都方法是叉积同号</p><h4 id="叉积法">叉积法</h4><p>PA、PB、PC两两叉积，如果三者同号则为内部</p><h4 id="重心公式">重心公式</h4><p>平面内两个不平行的非零向量可以表示任何向量<br>$$<br>\overrightarrow{AP} =u\overrightarrow{AB} +v\overrightarrow{AC}<br>$$<br>两边点积<br>$$<br>\overrightarrow{AP}\cdot \overrightarrow{AC}  =u\overrightarrow{AB}\cdot \overrightarrow{AC} +v\overrightarrow{AC}\cdot \overrightarrow{AC}<br>$$</p><p>$$<br>\overrightarrow{AP}\cdot \overrightarrow{AB}  =u\overrightarrow{AB}\cdot \overrightarrow{AB} +v\overrightarrow{AC}\cdot \overrightarrow{AB}<br>$$</p><p>两个变量两个公式，可以求出u和v</p><h3 id="什么是MIS">什么是MIS</h3><p>多重重要性采样（multiple importance sampling，MIS），在光追中，当光源和物体表面材质都接近$\delta$分布时，无论在光源上采样还是按BSDF采样都会带来很高的方差，使用MIS可以提高效果</p><p>思路就是结合不同种采用方法，分布采用被积函数的不同部分，讲这些部分结合起来，以达到最优效果</p><h4 id="什么是德尔塔分布">什么是德尔塔分布</h4><p>$\delta$函数（狄拉克函数）：除了零点以外的点都等于零，但在其整一个定义域内的积分为1的函数（这种函数本身并不存在）</p><p>$\delta$分布：符合$\delta$函数的分布</p><h3 id="已知UV和深度如何重建世界坐标">已知UV和深度如何重建世界坐标</h3><h4 id="使用逆矩阵">使用逆矩阵</h4><p>用uv和深度重建NDC坐标，乘以VP矩阵的逆矩阵以重建世界坐标</p><h4 id="线性深度">线性深度</h4><h5 id="正交投影">正交投影</h5><p>uvz线性映射回视锥长方体</p><h5 id="透视投影">透视投影</h5><p>通过z确定投影面大小，然后uv线性映射</p><h3 id="草地弯曲是怎么实现的">草地弯曲是怎么实现的</h3><p>顶点偏移？</p><h3 id="离角色很近的树叶如何保持性能">离角色很近的树叶如何保持性能</h3><h3 id="是不是每一次draw-call都需要重新传一次顶点数据">是不是每一次draw call都需要重新传一次顶点数据</h3><h3 id="贴花">贴花</h3><p>前向：绘制几何体</p><p>延迟：Gbuffer中绘制</p><h3 id="SSR会丢失信息，可以怎么处理">SSR会丢失信息，可以怎么处理</h3><p>用cubemap补一下？</p><h3 id="为什么有法线贴图还需要顶点法线信息">为什么有法线贴图还需要顶点法线信息</h3><p>为了构建TBN矩阵</p><p>在片元着色器中采集切线空间法线贴图信息，然后使用TBN矩阵恢复成世界空间法线，那么TBN是怎么来的呢？</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">half3x3 tangentToWorld = half3x3(i.tangentWS.xyz, bitangent.xyz, i.normalWS.xyz);</span><br></pre></td></tr></table></figure><p>是使用顶点着色器传入的世界空间切线、次切线、法线构建的</p><h3 id="Forward">Forward+</h3><p>和传统的前向渲染比添加了一个光源剔除阶段</p><p>着色分三个阶段：</p><ol><li>depth prepass（可选）</li><li>Light culling</li><li>shading</li></ol><p>将光源信息存储在一个线性布局的缓冲区中，方便查找</p><p>light culling阶段和延迟渲染中光照累计很相似，对于每一个像素，先找其所在的tile，求能照射到这个tile的光源列表，然后进行着色</p><p>理论上对每一个像素找灯光是效果最好的，现在这种找tile很显然是会计算一些多余的灯光，但是大幅减少了查找灯光的计算量，在查找和着色间寻找一个平衡</p><h3 id="移动端GPU渲染架构">移动端GPU渲染架构</h3><h4 id="IMR">IMR</h4><p>Immediate Mode Rending，即时模式渲染，按drawcall顺序绘制</p><img src="/images/IMR.png" class="lazyload" data-srcset="/images/IMR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMR" style="zoom:50%;" /><h4 id="TBR">TBR</h4><p>Tile Base Rendering</p><p>将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上，然后FS读信息，渲染每一个tile</p><img src="/images/TBR.png" class="lazyload" data-srcset="/images/TBR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TBR" style="zoom:50%;" /><p>作用：<strong>省带宽</strong>，每次传一个小tile，对带宽的压力会比IMR小很多（IMR一次传一整张屏幕）</p><h4 id="TBDR">TBDR</h4><p>Tile Base Deferred Rendering</p><p>上面我们在FS对每一个tile做渲染时，完全可以记录哪些灯光会影响这个tile，使用这些光做计算</p><p>思路</p><p>TBR省带宽了，但是没减少overdraw，而TBDR处理了剔除问题，降低了overdraw</p><h4 id="TBR的其他应用">TBR的其他应用</h4><ul><li><p>MSAA：MSAA是对一个像素多采几个点，原本采样很费，因为要加载卸载贴图</p><ul><li>但是由于TBR每一个tile都是片上的，相当于省了加载卸载，性能好很多</li><li>只不过虽然采样变便宜了，采样结果一多，就要处理更多的采样数据，所以也不能无限制的使用</li><li>此外这会让多边形覆盖更多的像素</li></ul><p>如图，只有一个采样点时（红点），红圈所在的像素不会被算进去，但MSAA时就会被算进去</p><img src="/images/TBR的MSAA.png" class="lazyload" data-srcset="/images/TBR的MSAA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TBR的MSAA" style="zoom:50%;" /></li></ul><h3 id="视差贴图">视差贴图</h3><p>视差贴图（Parallax Mapping）效果类似法线贴图，其原理是对纹理采样uv做偏移，不修改顶点信息</p><img src="/images/视差贴图.jpeg" class="lazyload" data-srcset="/images/视差贴图.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="视差贴图" style="zoom: 33%;" /><p>原本平坦的表面，如果变成如图的凹凸形状，原本视线会与平面在B处相交，现在则在A处相交，我们采集$A’$点的信息</p><p>从B到$A’$做了什么呢？本质就是采样点从B点出发，沿着<strong>视线在平面的投影</strong>做了一次偏移，偏移的长度可以通过三角形相似求得</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入B的uv，得到A‘的uv</span></span><br><span class="line"><span class="function">float2 <span class="title">ParallaxMapping</span>(<span class="params">float2 texCoords,float3 viewDir</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">float</span> height = texture(depthMap, texCoords).r;    </span><br><span class="line">    float2 p = viewDir.xy / viewDir.z * (height * height_scale);</span><br><span class="line">    <span class="keyword">return</span> texCoords - p;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果按深度步进，通过从上到下找第一个深度小于A的平面，来求$A’$的位置，就是陡峭视差映射(Steep Parallax Mapping)的思想</p><h3 id="virtual-texture">virtual texture</h3><p>根据是否实时生成（合并）virtual texture，该技术分为VT和RVT，该技术主要用于大世界地形上</p><p>在说VT前，要先谈texture splatting。大世界的地表纹理通常是使用多张纹理混合而成的（比如沙子、草、岩石、雪），而混合这些贴图的技术称为<strong>texture splatting</strong></p><p>该技术很简单，比如要混合四张图，那么生成一个新的RGBA贴图，在某一点的混合图为</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">blenderTex = Texture1 * map.r + Texture2 * map.g + Texture3 * map.b + Texture4 * map.a;</span><br><span class="line"><span class="comment">//其中 map.r + map.g + map.b + map.a 恒等于1</span></span><br></pre></td></tr></table></figure><img src="/images/texture splatting.png" class="lazyload" data-srcset="/images/texture splatting.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="texture splatting"  /><p>我们发现这种混合技术要频繁采样，混合四张图，要采9张图（四个材质图，四个法线图，一个splat图），而我们知道采一张大图会比采多个小图性能高很多，那么我们能不能把这九张小图拼成一张大图呢？这就是VT</p><p>但我们没必要一次把这九张完整的图合并，这也存在浪费，那么我们只需要合并需要被采样的图</p><p>我们把原图做预处理，分割成一个个小tile，并维护一个映射表，当我们要采样某个范围内的贴图时，先根据映射表找到所有相关的tile（回传给CPU，让CPU去加载tile），再把tile合并</p><h3 id="帕尼尼投影">帕尼尼投影</h3><p>一种屏幕后效，画面中心凸起，镜头左右两边在垂直方向上保留画面原样</p><p><img src="/images/%E5%B8%95%E5%B0%BC%E5%B0%BC%E6%8A%95%E5%BD%B1.jpeg" class="lazyload" data-srcset="/images/%E5%B8%95%E5%B0%BC%E5%B0%BC%E6%8A%95%E5%BD%B1.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="帕尼尼投影"></p><h3 id="SSBO">SSBO</h3><p>Shader Storage Buffer Object，该对象可以在不同shader间共享数据，功能类似UBO（Uniform Buffer Object）</p><p>两者（SSBO和UBO）区别</p><ul><li>SSBO更大</li><li>SSBO的大小可以在运行时确定</li><li>UBO在显卡的常量区（CMEM），SSBO在全局区（SMEM）</li><li>SSBO更灵活，能支持更多种的数据类型</li></ul><h3 id="计算任意多边形面积">计算任意多边形面积</h3><h4 id="凸多边形">凸多边形</h4><p>一多边形某个点为顶点，将多边形划分为多个三角形，计算每个三角形的面积（可以用向量叉积），再加起来</p><h4 id="凹多边形">凹多边形</h4><p>向量的叉积是有方向的<br>$$<br>S_{OAB}=0.5*(\overrightarrow{OA} \times \overrightarrow{OB})<br>$$</p><p>$$<br>S_{ABCDE}=S_{OBC}+S_{OCD}+S_{ODE}+S_{OEA}+S_{OAB}<br>$$</p><p><img src="/images/%E5%87%B9%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" class="lazyload" data-srcset="/images/%E5%87%B9%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="凹多边形面积"></p><h3 id="OBB包围盒">OBB包围盒</h3><p>常见的包围盒有AABB和OBB，AABB是轴向的，生成简单，但当物体旋转时效果并不好，OBB是有向的，沿着物体的主成分方向生成最小的一个矩形包围盒，可以随物体旋转</p><p><img src="/images/OBB%E4%B8%8EAABB.jpeg" class="lazyload" data-srcset="/images/OBB%E4%B8%8EAABB.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="OBB与AABB"></p><p>OBB2D的生成思路是：通过主成分分析（PCA）获得特征向量，作为OBB的主轴，然后将所有点包含</p><h4 id="主成分分析">主成分分析</h4><p>主成分分析是一种通过正交变换，将一组可能相关的变量集合变换成一组线性不相关的变量集合，即主成分</p><p>简单来说就是根据所有顶点生成协方差矩阵，对其对角化</p><h3 id="BS变形器">BS变形器</h3><p>blendshape</p><p>将一个mesh变化为另一个mesh（顶点数不变）的规则，就是一个BS，其最重要的功能是做表情</p><h3 id="什么是灭点">什么是灭点</h3><p>在透视投影中，不平行于投影平面的平行线会聚集到一点，改点就是灭点</p><h4 id="用途">用途</h4><p>在制作屏幕后效时（比如雨水），在相机的双锥体上渲染（而不是直接对屏幕四边形），可以得到一种雨水向远处收拢的感觉</p><img src="/images/灭点.jpg" class="lazyload" data-srcset="/images/灭点.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="灭点" style="zoom:67%;" /><h3 id="选人界面的打光与镜头">选人界面的打光与镜头</h3><ul><li><p>打光</p><ul><li><p>环境光：用HDRI贴图提供</p></li><li><p>直接光：打在人物正面斜上方，提供主要亮度，开启阴影</p></li><li><p>虚拟光：用于模拟反光板的提供的光源，亮度较弱，方向和相机一个位置（卡渲中常用，可以减弱光照对比，减弱阴影问题）</p></li></ul></li><li><p>镜头</p><ul><li><p>使用长焦镜头，也就是提高FOV，这样可以减少面部崎变，让人显得更瘦（反其道而行之，就是大头猪鼻特效）</p></li><li><p>开启景深</p><ul><li>深度景深：没法处理半透明物体，人物头发也会会出问题（因为深度变化太小）</li><li>Circle Blur：效果更好，美颜相机大多使用这个，原理就是把人抠出来，把人以外的背景模糊</li></ul></li></ul></li></ul><h3 id="眼球渲染的要点">眼球渲染的要点</h3><ul><li><p>眼白</p><ul><li>血丝<ul><li>可以直接画在贴图上</li></ul></li><li>次表面散射<ul><li>将散射函数预积分到LUT图上</li></ul></li></ul></li><li><p>眼睛</p><ul><li>镜面反射<ul><li>颗粒状眼白法线，来表现眼白的粘液</li></ul></li><li>AO<ul><li>在眼球外层做一个用来遮蔽的半透明模型</li></ul></li></ul></li><li><p>虹膜</p><ul><li>缩放<ul><li>uv采样缩放</li></ul></li><li>视差</li><li>焦散（猫的眼睛发亮）<ul><li>双层法线，圆滑的法线计算高光，平整的法线计算漫反射</li></ul></li><li>虹膜对光线的吸收（眼珠旁边有黑圈）<ul><li>根据uv画圆</li></ul></li><li>瞳孔收缩</li></ul></li><li><p>泪腺</p></li></ul><h3 id="移动端Deferred">移动端Deferred</h3><p>移动端延迟与GPU架构强相关</p><ul><li><p>iOS：one pass deferred</p></li><li><p>Adreno：frameBuffer fetch deferred</p><ul><li>提前绑定（开辟）好MRT，使用时RT不动，Pass动</li></ul></li><li><p>Mali：pixel loacl storage deferred</p><ul><li>将GBuffer存在on-clip mem上，于是就减少了IO消耗</li></ul></li></ul><h4 id="移动端SubPass">移动端SubPass</h4><p>Unity移动端使用Metal和Vulkan API时，都可以使用SubPass，但略有不同</p><p>在同一个RenderPass的不同SubPass间切换，是不会带来带宽消耗的</p><ul><li>Metal<ul><li>支持FrameBufferFetch，即可以在一个SubPass中对RT读写</li><li>不支持在Tile上读取深度</li></ul></li><li>Vulakn<ul><li>不支持FrameBufferFetch</li><li>支持在Tile读深度（mali设备读浮点纹理比读tile的深度更高效）</li></ul></li></ul><p>由于Metal不支持读深度，而mali Vulkan读深度效率比读RT差，所以Metal和Vulkan都在GBuffer Pass时额外生成一张深度RT，在LightingPass里用</p><h3 id="角色灯光术语">角色灯光术语</h3><h4 id="光比">光比</h4><p>指物体受光面亮度与阴影面亮度的比值，比值越大，明暗对比越强</p><p>常出现在黑暗空间爆炸光效照亮角色</p><h4 id="二值化光">二值化光</h4><p>照明时，灯光颜色在固定好的暗部颜色和亮部颜色之间插值</p><h3 id="抗锯齿">抗锯齿</h3><p>抗锯齿有两大类，时间层面和空间层面，但本质都是增加采样点数</p><ul><li>空域抗锯齿<ul><li>MSAA（MultiSampling Anti-Aliasing）：一个像素采多个点<ul><li>On-Clip MSAA</li></ul></li><li>FXAA（Fast Approximately -Aliasing）：卷积模糊</li><li>SMAA（Enhanced Subpixel Morphological）：边缘检测–矢量化–像素混合</li></ul></li><li>时域抗锯齿<ul><li>TAA（Temporal Antialiasing），一帧采一下，几帧后就等于采了很多点<br><img src="/images/TAA.png" class="lazyload" data-srcset="/images/TAA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TAA"></li></ul></li></ul><h3 id="svoGI">svoGI</h3><p>Sparse Voxel Octree（稀疏体素八叉树） GI，是VXGI的进阶版本</p><h3 id="无偏渲染">无偏渲染</h3><h3 id="SST">SST</h3><p>Sparse Shadow Tree，一种大范围阴影渲染方案</p><p><a href="https://www.activision.com/cdn/research/SparseShadowTree.pdf">论文地址</a></p><h3 id="ShadowCache">ShadowCache</h3><p>对静态物体和动态物体使用两套CSM，一套只绘制动态物体，每帧刷新，一套只绘制静态物体，低频刷新</p><p>低频刷新的CSM被称为ShadowCache</p><h3 id="TressFX">TressFX</h3><p>一种实时毛发渲染系统</p><h3 id="XGen">XGen</h3><p>一个maya的头发制作工具</p><p><a href="https://knowledge.autodesk.com/zh-hans/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/CHS/Maya-CharEffEnvBuild/files/GUID-C0470142-600B-4615-8110-EC779934DF5F-htm.html">maya文档</a></p><h3 id="Vulkan的基本概念">Vulkan的基本概念</h3><p>Vulkan对象主要分为三个部分，每个部分都有一个主对象</p><h4 id="Instance">Instance</h4><p>第一个Vulkan对象，用于连接应用程序和Vulkan运行时</p><h4 id="PhysicalDevice">PhysicalDevice</h4><p>显卡</p><ul><li>可以枚举图形队列</li><li>可以枚举内存堆和内存类型</li></ul><h4 id="Device">Device</h4><p>逻辑设备</p><ul><li>Queue：用于向GPU传递命令（类比SRP的上下文）</li><li>CommandPool：用于创建CommandBuffer</li><li>CommandBuffer：命令缓冲区，可以通过<code>vkQueueSubmit</code>提交到Queue中</li><li>Sampler：一组采样器状态，用于设置滤波模式、寻址模式等</li><li>Buffer&amp;Image：资源，渲染时不会直接使用</li><li>BufferView&amp;ImageView：对资源的解释（Buffer&amp;Image中，我们所需要的部分），渲染时直接使用（类比SRP的RT）</li><li>SurfaceKHR：控制屏幕窗口，与平台相关</li><li>SwapchainKHR：交换链，内含一组图片，用于实现显示交换<ul><li>立即渲染</li><li>双缓冲</li><li>多重缓冲</li></ul></li><li>Descriptor：描述符，用于访问资源（顶点信息，缓冲区，图像，采样器）<ul><li>DescriptorSet</li><li>DescriptorSetLayout</li><li>DescriptorPool</li></ul></li><li>FrameBuffer：ImageView的集合（RT、MRT）<ul><li>Attachment：附件（类比SRP的RenderTarget）<ul><li>Attachment初始化：Load Action</li><li>Attachment写回内存：Save Action</li></ul></li></ul></li><li>RenderPass：一次渲染流水线的执行，将信息输出到FBO的Attachments中<ul><li>SubPass：渲染的中间Pass，他们的目标不是FBO，而是一些临时的目标</li></ul></li><li>Pipeline：管线<ul><li>ComputePipeline</li><li>GraphicsPipeline<ul><li>PipelineLayout</li><li>ShaderModule：使用SPIR-V进行着色器编译</li><li>PipelineCache</li></ul></li></ul></li><li>Query：查询，用于得到某指令的执行情况</li><li>Fence&amp;Semaphore<ul><li>Fence：栅栏，用于CPU和GPU同步</li><li>Semaphore：信号量：用于GPU内部的同步（对客户端黑盒）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ddx与ddy</title>
      <link href="/graphics/ddx%E4%B8%8Eddy/"/>
      <url>/graphics/ddx%E4%B8%8Eddy/</url>
      
        <content type="html"><![CDATA[<h1>ddx与ddy</h1><p>在OpenGL中叫dFdx和dFdy，在HLSL中叫ddx和ddy</p><p><a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/deriv-rtx--sm4---asm-">HLSL deriv_rtx</a></p><p>ddx和ddy是一个求偏导的过程，依赖于硬件光栅化，只能用于fragment着色器，意思为计算blocks内相邻片元间value的变化（value可以是任意参数，比如uv、color、position、normal），注意不要在分支中使用偏导<br>$$<br>\mathrm{ddx}=\frac{\mathrm{p}(x+1,y)-\mathrm{p}(x,y)}{1}<br>$$<br>三角形光栅化时，fragment着色器一次处理2x2个像素，其中左上角的像素$(x,y)$始终为偶数坐标</p><p><img src="/images/ddx.png" class="lazyload" data-srcset="/images/ddx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ddx"></p><p>如果一个几何体不够大，使用抗锯齿算法后渲染分辨率仍然比2x2要小，那么这个几何体在光栅化前就会被剔除，以此不必担心像素不够的情况</p><h3 id="mipmap（UV）">mipmap（UV）</h3><p>使用mipmap会增加贴图存储，但是能提高性能和效果，在对mipmap贴图进行采样时，我们可以手动指定采样层级</p><p>我们需要一种方法能求mipmap层级（如果层级不对，会导致纹素比异常，产生摩尔纹等）</p><p>ddx和ddy一个应用是求贴图mipmap层级</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> mip_map_level(<span class="keyword">in</span> <span class="type">vec2</span> texture_coordinate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span>  dx_vtc        = <span class="built_in">dFdx</span>(texture_coordinate);</span><br><span class="line">    <span class="type">vec2</span>  dy_vtc        = <span class="built_in">dFdy</span>(texture_coordinate);</span><br><span class="line">    <span class="type">float</span> delta_max_sqr = <span class="built_in">max</span>(<span class="built_in">dot</span>(dx_vtc, dx_vtc), <span class="built_in">dot</span>(dy_vtc, dy_vtc));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">log2</span>(delta_max_sqr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在OpenGL4.x提供了mipmap函数<code>textureQueryLod()</code></p></blockquote><h3 id="面法线（坐标）">面法线（坐标）</h3><p>我们在fragment着色器中对世界坐标做ddx和ddy，就能得到三角面上两个向量（这俩向量还是垂直的），而平面上两个非平行向量就能确定一个平面，他们的叉积就是面法线（注意手系和法线正负）</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec3</span> faceNormal = <span class="built_in">normalize</span>( <span class="built_in">cross</span>(<span class="built_in">dFdx</span>(pos), <span class="built_in">dFdy</span>(pos)) );</span><br></pre></td></tr></table></figure><p><img src="/images/%E9%9D%A2%E6%B3%95%E7%BA%BF.png" class="lazyload" data-srcset="/images/%E9%9D%A2%E6%B3%95%E7%BA%BF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="面法线"></p><p>该技术常用于平面着色（Flat Shading），让物体有一种低面感，法线没有插值，是ground着色、phong着色以前的东西（老古董前的老古董）</p><h3 id="高度图（法线）">高度图（法线）</h3><p>与面法线原理类似，给定一张单通道的灰度图当作高度图，通过ddx、ddy就能得到高度的变化，进而得到法线的变化</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">fixed h = tex2D(_HightMap, i.uv).r;</span><br><span class="line"><span class="type">float</span> offsetU = -ddx(h); </span><br><span class="line"><span class="type">float</span> offsetV = ddy(h);</span><br><span class="line">float3 n = <span class="built_in">normalize</span>(i.normal.xyz + float3(offsetU, offsetV, <span class="number">0</span>) * _Intensity);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：几何光学</title>
      <link href="/optics/%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6/"/>
      <url>/optics/%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1>四：几何光学</h1><p>几何光学，也被称为射线光学（Ray optics），忽略光的波动性，以几何方法来研究光在均匀介质中的传播</p><h2 id="基本定律">基本定律</h2><p>几何光学包含两个部分，一个是光学三定律，定性描述了几何光学中光的传递，一个是费马原理，定量计算了光的传播（通常为光学元件间近轴传播）</p><h3 id="光学三定律">光学三定律</h3><ul><li>光在均匀介质中沿直线传播</li><li>光的反射、折射定律<ul><li>反射角等于入射角</li><li>入射角与折射角的正弦值之比等于折射率之比（Snell定律）</li></ul></li><li>光独立传播，光路可逆</li></ul><p>Shell定律<br>$$<br>n_i\sin \theta_i= n_t \sin \theta_t<br>$$</p><p><img src="/images/Snell.png" class="lazyload" data-srcset="/images/Snell.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snell"></p><p>反射光线是最短路径（亚历山大）</p><img src="/images/亚历山大.png" class="lazyload" data-srcset="/images/亚历山大.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="亚历山大" style="zoom:50%;" /><h3 id="光程">光程</h3><p>由于光在介质中移动速度不同，为了方便描述光在介质中移动某段距离要花费的时间，我们引入了光程长度。于是我们在计算时就可以认为光速永远不变，只是光的传播距离与现实距离不同</p><p>光程长度（Optical path length，OPL）：光在介质中传播长度与介质的折射率的乘积<br>$$<br>[l]=ns<br>$$<br>光程描述的是：光在该介质中移动真实距离所花费的时间，如果在真空中能运动多远的距离</p><h3 id="费马原理">费马原理</h3><blockquote><p>开创了以“路径积分，变分原理“来描述物理规律的思维方式</p></blockquote><p>费马原理（也叫最短时间原则）：</p><ul><li>光在两点间的传播路径是最短路径（最短路径可以由多条，但是其光程相同）</li><li>两点间的光程恒定（光程函数的导数为0）</li></ul><blockquote><p>费马原理可以推导出光学三定律</p><p>在均匀介质中折射率为常数，光在两点间的传播路径为最短距离，又由于两点间直线距离最短，因此光沿着直线传播</p><p>由于反射点、折射点都在交线OO‘上，因此他们在同一平面内（在交线上距离最短）</p><p>由于两点间直线最短，沿着反射轴做反射光线的对称直线，发现当反射角等于入射角时，入射光线和对称光线为一条直线</p><p>用折射率和三角形长度表示折射光线的光程，该光程应该是最小值，因而导数为0，求导化简得出Shell公式</p></blockquote><h4 id="透镜成像">透镜成像</h4><p>根据费马原理，两点间光沿着光程最短的路径传播，这说明凸透镜成像中每一条光线的光程都相等</p><img src="/images/费马原理透镜.png" class="lazyload" data-srcset="/images/费马原理透镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="费马原理透镜" style="zoom:50%;" /><p>实际上，凹透镜散射光光线的反向延长线与入射光组成的总光程也是根根相等的</p><h4 id="等光程">等光程</h4><p>等光程：如果一个光学器械每条光线都是等光程的（比如透镜），我们称之为等光程，他们可以严格成像</p><p>不等光程的器械不能成像，近似光程的器械能成模糊的像</p><h4 id="费马原理的应用">费马原理的应用</h4><p>反曲椭球面生成平行光：从椭球面焦点发生灯光，会生成平行光，由于平型光不会汇聚，因此他们的光程为无穷大</p><p>光在椭球面内反射：在椭球面内，两个焦点间光程为恒定值（毕竟椭圆上的点到两个焦点距离的和为焦距）</p><p>双曲透镜将平行光汇聚到一点</p><p>半球面反射</p><p><img src="/images/%E5%8D%8A%E7%90%83%E9%9D%A2.png" class="lazyload" data-srcset="/images/%E5%8D%8A%E7%90%83%E9%9D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="半球面"></p><h2 id="成像">成像</h2><p>光学系统（Optical system）：一个包含一个或多个光学元器件的系统</p><p>物体空间（Object space）：入射光线所在的区域</p><p>图像空间（…/…/images space）：出射光线所在的区域</p><p>理想光学系统（ideal optical system）：物体能被完美地成像，比如平面镜反射</p><p>共轭点（conjugate points）：物体点和图像点组成共轭点</p><p>对于一个理想光线系统，每对共轭点的光程（后面以OPL指代）均相同</p><p>实像：物体发出的光经过反射、折射后，汇聚成新的像，被称为实像（比如凸透镜）</p><p>虚像：物体发出的光经过反射、折射后，变成了发散光线，将其反向延长得到的像，被称为虚像（比如凹透镜、平面镜）</p><h3 id="单心性">单心性</h3><p>从一点发射光源，经过光学系统后，仍然汇聚为一点，那么这个光学系统满足单心性</p><p>平面镜反射满足单心性，折射不满足</p><p>不满足单心性，物像和图像不共轭，不能完美成像</p><h3 id="全反射">全反射</h3><p>当光从光密射入光疏，且角度大于某个值后，只发生反射，不发生折射</p><blockquote><p>光导纤维</p></blockquote><p>不过光疏介质介质中并没有没有透射波，但这些透射波与界面平行，且振幅在垂直界面方向按指数衰减，于是很快就没了，这个波被称为<strong>隐失波</strong></p><h3 id="人眼为什么能看到虚像">人眼为什么能看到虚像</h3><p>人为什么能看到东西？是因为物体经过眼睛，在视网膜上成了像，在这里，眼睛是成像系统</p><p>我们在讨论实像虚像时，提到的光学系统那些透镜们，于是虚像的全称应该是“某物体在xxx光学系统的虚像”，人眼并不是看到了“某物体在xxx光学系统的虚像”，而是在该处，经由人眼，看到了一个实像</p><h3 id="理想光学系统">理想光学系统</h3><ul><li>共轭性：物像种每个点、线、面都能在图像上找到对应的点、线、面</li><li>等光程</li></ul><h2 id="棱镜成像">棱镜成像</h2><img src="/images/偏向角.JPG" class="lazyload" data-srcset="/images/偏向角.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="偏向角" style="zoom:50%;" /><h3 id=""></h3><h2 id="球面成像">球面成像</h2><p>尽管球面不是一个很好的光学器械，但比较好加工（其实现在加工技术已经很好了，很多人的眼镜都是非球面的），于是球面成像是几何光学很重要的一块</p><p>光轴：若一个光学系统由球面组成，各球心的连线在一条直线上，该光学系统被称为共轴球面系统，这条直线被称为光轴</p><h3 id="球差">球差</h3><p>我们上面提到球面不是一个很好的光学器械，因为透镜成像有球差</p><p>透镜成像，靠近光轴的光会被汇聚在靠后的位置，远离光轴的光会被汇聚在靠前的位置，也就是透射光经过球面成像后不再汇聚为一点，单心性被破坏</p><img src="/images/球差.png" class="lazyload" data-srcset="/images/球差.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球差" style="zoom:50%;" /><h3 id="近轴条件">近轴条件</h3><p>由于球差的存在，我们假设光只在近轴处传播，于是“消除”了球差</p><p>近轴条件（paraxial condition）：入射角与光轴（optical axis）的夹角（用$u$表示）小于等于$5^{\circ}$</p><img src="/images/近轴条件.png" class="lazyload" data-srcset="/images/近轴条件.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="近轴条件" style="zoom:50%;" /><p>此时，三角函数可以近似<br>$$<br>\cos u \approx 1 \<br>\sin u \approx u \<br>\tan u \approx \sin u<br>$$</p><p>消球差平面（Aplanatic Surface）：允许所有光线在两点之间以相等的OPL传播的表面</p><img src="/images/消球差.png" class="lazyload" data-srcset="/images/消球差.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="消球差" style="zoom:50%;" /><h3 id="符号法则">符号法则</h3><blockquote><p>简单来说，若左侧的光射向一个左凸的球面在右侧汇聚，距离都是正的</p></blockquote><p>设入射光从左向右</p><ul><li>若入射点在顶点（球面和光轴的交点）左侧，那么入射点到顶点的距离为正，反之为负</li><li>若汇聚点在顶点右侧，那么汇聚点到顶点的距离为正，反之为负</li><li>若球心在顶点左侧，则半径为负，反之为正</li></ul><h3 id="绘图标准">绘图标准</h3><ul><li>基准点：球面顶点(单球面系统)、焦点</li><li>基准线：光轴、各折射点的法线</li><li>长度量：由指定原点量起<strong>顺光线传播方向为正</strong>，反之为负。</li><li>高度量：垂直向上为正，反之为负。</li><li>角度量规定：以锐角衡量，以主光轴<strong>顺时针转到光线为正</strong>。</li><li>规定：图上只标绝对值。</li></ul><h3 id="球面反射">球面反射</h3><p>Reflection at spherical surfaces</p><img src="/images/球面反射.png" class="lazyload" data-srcset="/images/球面反射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球面反射" style="zoom:50%;" /><p>$$<br>\frac{1}{-s}+\frac{1}{-s’}=-\frac{2}{r}<br>$$</p><ul><li>光轴（QA这条线）</li><li>焦点（image focus，图中$\mathrm{F’}$）：平行于光轴的光线打到球面上，会汇集到一点，这个个点被称为焦点</li><li>物体焦距（Object focal length，用$f$表示）</li><li>图像焦距（…/…/images focal length，用$f’$表示）</li></ul><p>在球面反射，物体焦距和图像焦距是相等的<br>$$<br>f= \lim_{s’ \rightarrow \infty}s<br>\<br>f’= \lim_{s \rightarrow \infty}s’<br>\<br>\frac{1}{s}+\frac{1}{s’}=\frac{1}{f}<br>$$</p><h3 id="球面折射">球面折射</h3><p>Refraction at spherical surfaces</p><p><img src="/images/%E7%90%83%E9%9D%A2%E6%8A%98%E5%B0%84.png" class="lazyload" data-srcset="/images/%E7%90%83%E9%9D%A2%E6%8A%98%E5%B0%84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球面折射"><br>$$<br>\frac{n_1}{-s}+\frac{n_2}{s’}=\frac{n_2-n_1}{r} \equiv \Phi<br>$$</p><ul><li>光焦度（用$\Phi$表示）：用与描述光线系统对光线的曲折能力</li></ul><p><strong>高斯透镜公式</strong>（Gaussian Lens Formula）<br>$$<br>\frac{f}{s}+\frac{f’}{s’}=1<br>$$<br>牛顿透镜公式（Newton form of Lens Formula）<br>$$<br>x_0x_i=ff’<br>$$<br><img src="/images/%E7%89%9B%E9%A1%BF%E6%88%90%E5%83%8F%E5%85%AC%E5%BC%8F.png" class="lazyload" data-srcset="/images/%E7%89%9B%E9%A1%BF%E6%88%90%E5%83%8F%E5%85%AC%E5%BC%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="牛顿成像公式"></p><h3 id="离轴点成像">离轴点成像</h3><p>Imaging for off-axis points</p><p>就是y比较大，导致不能使用三角函数近似</p><p><img src="/images/%E7%A6%BB%E8%BD%B4%E6%88%90%E5%83%8F.png" class="lazyload" data-srcset="/images/%E7%A6%BB%E8%BD%B4%E6%88%90%E5%83%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="离轴成像"></p><h2 id="薄透镜成像">薄透镜成像</h2><p>透镜：由两个同轴折射球组成的镜子，根据球心位置，分为凸透镜（convex lens）和凹透镜（concave lens）</p><p>薄透镜（Thin lens）：中心半径和曲率厚度可以忽略不记的透镜</p><p>光轴（Optic axis）：连接两个曲面中心的轴</p><p>光学中心（Optic center）：两个球面的基准点（vertex）视为重合，重合点就是光学中心</p><p>凸透镜分为双凸、平凸、弯凸三种</p><p>凹透镜分为双凹、平凹、弯凹三种</p><h3 id="透镜公式">透镜公式</h3><p>$$<br>\frac{n_1}{-s_1}+\frac{n_2}{s_2’}=\frac{n_0-n_1}{r_1}+\frac{n_2-n_0}{r_2}\equiv \Phi<br>$$</p><p><img src="/images/%E9%80%8F%E9%95%9C%E5%85%AC%E5%BC%8F.png" class="lazyload" data-srcset="/images/%E9%80%8F%E9%95%9C%E5%85%AC%E5%BC%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="透镜公式"></p><h3 id="焦平面">焦平面</h3><p>焦平面（Focal plane）：垂直于光轴且经过焦点的平面</p><p>前焦平面（front focal plane）：光射入透镜的面</p><p>后焦平面（back focal plane）：光从透镜射出的面</p><p>透镜使得光的落点与入射角有关，且满足<br>$$<br>y=f \cdot \tan\theta \approx f\cdot \theta<br>$$<br><img src="/images/%E8%90%BD%E7%82%B9.png" class="lazyload" data-srcset="/images/%E8%90%BD%E7%82%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="落点"></p><p><em>用透镜成像等于两倍的傅里叶变换</em></p><h3 id="光阑">光阑</h3><p>光阑（stop）：限制（limit）成像光束的器件，比如透镜（lens）、光圈（aperture）、窗口片（the frame of windows）</p><h4 id="光圈">光圈</h4><p>光圈（aperture stop，下图DD’）：用于限制光线宽度的期间</p><p><img src="/images/%E5%85%89%E5%9C%88.png" class="lazyload" data-srcset="/images/%E5%85%89%E5%9C%88.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="光圈"></p><p>Field stop：用于限制成像区域和方位</p><p><img src="/images/field-stop.png" class="lazyload" data-srcset="/images/field-stop.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="field-stop"></p><h4 id="景深">景深</h4><p>景深（Depth of field/focus）：聚焦深度，入射点P在光轴方向移动，移动距离$\Delta x$在景深范围内，图像是清晰的</p><p><img src="/images/%E6%99%AF%E6%B7%B1.png" class="lazyload" data-srcset="/images/%E6%99%AF%E6%B7%B1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="景深"></p><p>能看出图中$P_1$过早聚焦，$P_2$过晚聚焦，他们相对于$P$，都显得比较模糊</p><p>在物体空间的最大$\Delta x$被称为Depth of field</p><p>在图像空间的最大$\Delta x$被称为Depth of focus</p><h4 id="相对孔径">相对孔径</h4><p>相对孔径（Relative aperture）：光圈的直径（用$D$表示）和焦距（focal length，用$f$表示）的比值</p><p>$D/f$越大，说明光学系统收集光的能力越强</p><h4 id="f-number">f-number</h4><p>相对孔径的倒数，意义为焦距是直径的多少倍</p><p>比如一个光学系统，焦距160nm，光圈直径20nm，那么它的f-number等于160/20=8，记作$f/8$</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：反射和折射</title>
      <link href="/optics/%E5%8F%8D%E5%B0%84%E5%92%8C%E6%8A%98%E5%B0%84/"/>
      <url>/optics/%E5%8F%8D%E5%B0%84%E5%92%8C%E6%8A%98%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1>五：反射与折射</h1><h2 id="内容概述">内容概述</h2><ul><li>光在单层各项同性表面的反射与折射</li><li>菲涅尔方程</li><li>全内反射</li><li>相位突变，布鲁斯特角</li></ul><h2 id="菲涅尔方程">菲涅尔方程</h2><h3 id="菲涅尔方程-2">菲涅尔方程</h3><p>各项同性介质（Isotropic medium）：折射率处处相同的材质</p><p>光密介质：折射率高的介质（这是一个相对概念）</p><p>光疏介质：折射率低的介质（这是一个相对概念）</p><p>在几何光学中的那些反射方程，只能得到入射光、反射光、折射光间的方向关系</p><p>而菲涅尔方程（Fresnel Equations）可以求出反射光、折射光的振幅、相位、偏振</p><p>菲涅尔方程的边界条件表明：磁场和电场在边界处连续，也就是入射光的电场磁场=反射光+折射光的电场磁场</p><img src="/images/菲涅尔.png" class="lazyload" data-srcset="/images/菲涅尔.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="菲涅尔" style="zoom:50%;" /><p>我们将入射光的电场分为两个部分，方向满足右手正交系</p><ul><li>平行（parallel）于平面的电场$E_p$</li><li>垂直（senkrecht）与平面<strong>向外</strong>的电场$E_s$</li></ul><p>经过复杂的推导，我们能得到<br>$$<br>r_p=\frac{E_{1p}’}{E_{1p}}=\frac{\tan(\mathrm{i_1}-\mathrm{i_2})}{\tan(\mathrm{i_1}+\mathrm{i_2})}\\<br>r_s=\frac{E_{1s}’}{E_{1s}}=-\frac{\sin(\mathrm{i_1}-\mathrm{i_2})}{\sin(\mathrm{i_1}+\mathrm{i_2})}\\<br>t_p=\frac{E_{2p}}{E_{1p}}=\frac{2\cos \mathrm{i_1}\sin \mathrm{i_2}}{\sin(\mathrm{i_1}+\mathrm{i_2}) \cos (\mathrm{i_1}-\mathrm{i_2})}\\<br>t_s=\frac{E_{2s}}{E_{1s}}=\frac{2\cos \mathrm{i_1}\sin \mathrm{i_2}}{\sin(\mathrm{i_1}+\mathrm{i_2})}<br>$$</p><ul><li>$r$：反射光</li><li>$t$：折射光（透射光，Transmission）</li></ul><p>于是我们能得出几个结论</p><ul><li>反射光、折射光与入射角、折射率有关</li><li>$p$与$s$是独立的</li></ul><h2 id="菲涅尔方程的含义">菲涅尔方程的含义</h2><h3 id="外反射">外反射</h3><p>外反射（External reflection）：从折射率低射向折射率高，比如从空气射向玻璃</p><img src="../../Document/Markdown/ImageLib/外反射.png" class="lazyload" data-srcset="../../Document/Markdown/ImageLib/外反射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="外反射" style="zoom:50%;" /><p>我们发现，随着入射角的增加</p><ul><li><p>折射一直是正数，并且两个方向没有明显差异</p></li><li><p>$r_s$一直是负数，而$r_p$先正后负</p></li><li><p>布鲁斯特角（Brewster’s angle，图中$i_B$），在此处$r_p$发生了一个$180^{\circ}$的相变</p></li><li><p>当入射角为$90^{\circ}$时，也就是掠射角（grazing angles），我们发现此时完全不发生折射，只发生反射</p><ul><li>对于一个湿表面，远看发现很亮，近看却发现变暗了</li><li>远看水面，大部分光来自反射，于是波光粼粼；近看水面，折射部分加强，于是清澈见底</li></ul></li><li><p>让入射角为$0^{\circ}$，也就是垂直入射时，$r_p$完全反向反射回来，折射很微弱</p></li></ul><h3 id="内反射">内反射</h3><p>内反射（Internal reflection）：从折射率高射向折射率低，比如从玻璃射向空气</p><img src="/images/内反射.png" class="lazyload" data-srcset="/images/内反射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内反射" style="zoom: 50%;" /><ul><li>$t_p=t_s$，两者没有相位差</li><li>当$i=i_c$，此时$r_p=r_s=1$，我们称之为全内反射（Total Internal Reflection，TIR），$i_c$被称为临界角（critical angle）</li></ul><h3 id="相位移">相位移</h3><p>相位移（Phase shift）</p><p><img src="/images/%E7%9B%B8%E4%BD%8D%E7%A7%BB.png" class="lazyload" data-srcset="/images/%E7%9B%B8%E4%BD%8D%E7%A7%BB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="相位移"></p><ul><li><p>从低折射率到高折射率，会有一次$\pi$相位移</p></li><li><p>从高折射率到低折射率，没有相位移</p></li></ul><p>薄膜相位移：光线在薄膜内发生多次反射，可能会附加一段相位移</p><p><img src="/images/%E8%96%84%E8%86%9C%E7%9B%B8%E4%BD%8D%E7%A7%BB.png" class="lazyload" data-srcset="/images/%E8%96%84%E8%86%9C%E7%9B%B8%E4%BD%8D%E7%A7%BB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="薄膜相位移"></p><h3 id="简化菲涅尔方程">简化菲涅尔方程</h3><p>反射比（Reflectance，用$R$表示）：反射光占入射光的能量</p><p>折射比（Transmittance，用$T$表示）：透射光（折射光）占入射光的能量</p><p>能流（Energy flow）：单位时间内通过单位横截面积的能量</p><p>能流 = 辐照度 x 横截面积<br>$$<br>R=r^2<br>$$</p><p>$$<br>T=\frac{n_2\cos i_2}{n_1\cos i_1}t^2<br>$$</p><p>根据能量守恒定律（Energy conservation law）：$R+T=1$</p><p>当垂直入射时，带入菲涅尔方程，得到<br>$$<br>\begin{cases}<br>r_p=\frac{n_2-n_1}{n_2+n_1}\\<br>r_s=-r_p\\<br>t_p=\frac{2n_1}{n_1+n_2}\\<br>t_s=t_p<br>\end{cases}<br>$$<br>于是得到<br>$$<br>R_p=R_s=\left( \frac{n_2-n_1}{n_2+n_1}\right)^2<br>$$</p><p>$$<br>T_p=T_s=\frac{4n_1n_2}{(n_1+n_2)^2}<br>$$</p><p>对于空气（$n_1=1$）和玻璃（$n_2=1.5$），$R=0.04，T=0.96$</p><p><em>这也是为什么图形学中取 0.04为F0的基准值</em></p><p><strong>为什么晚上室内玻璃像镜子一样？</strong></p><ol><li>晚上的玻璃，$R\approx 0.08$，室内的光线大部分都会反射回来，而室外的光线只有很少才会透射进来，看到的光绝大多数都来自室内的反射光，因此像镜子一样</li><li>此外，夜晚室内光线本身也比室外光线强</li></ol><p><strong>为什么白天从黑暗的房间看外面看，看的很清楚，而从室外向里看，却看不清</strong>？</p><p><strong>单透玻璃的原理是什么？</strong></p><h3 id="金属">金属</h3><p>金属（电介质）表面存在大量自由电荷，在外部电场的作用下，自由电子在固体表面（相对固定的金属阳离子）间不断弹跳</p><h4 id="德鲁德模型">德鲁德模型</h4><p>德鲁德模型（Drude model）是一种描述金属表面自由电子运动的模型（很复杂，看一下，图一乐）<br>$$<br>P=-nex<br>$$</p><p>$$<br>m\frac{\partial^2 x}{\partial t^2}+m \gamma \frac{\partial x}{\partial t}=eEe^{-\mathrm{i}\omega t}<br>$$</p><ul><li>偏振度（用$P$表示，在电磁波那一章在介绍洛伦兹震荡时有一个极其类似的公式）</li><li>阻尼率（damping rate，用$\gamma$表示）</li><li>电荷密度（density of electron，用$n$表示）</li></ul><p>这个推导很复杂，又涉及复变函数之类的，直接给结论：当平面波垂直射向金属时，$R \approx 1$</p><h4 id="布鲁斯特角">布鲁斯特角</h4><p>布鲁斯特角（Brewster’s angle），在外反射那一节提到过，当$i_1=i_B,r_p=0$</p><img src="/images/布鲁斯特角.png" class="lazyload" data-srcset="/images/布鲁斯特角.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="布鲁斯特角" style="zoom:50%;" /><p>一个应用是测量不透明介质的折射率<br>$$<br>\tan i_B=\frac{n_2}{n_1}<br>$$</p><p>另一个一个应用是制作偏振器，激光经过偏振器后，射出的光线是线偏振的</p><p><img src="/images/%E5%81%8F%E6%8C%AF%E5%99%A8.png" class="lazyload" data-srcset="/images/%E5%81%8F%E6%8C%AF%E5%99%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="偏振器"></p><p>自然光（非偏振光）的反射光、折射光是偏振光，但如果给镜头安装偏振器，并适当旋转偏振片，使偏振片的透振方向与反射光的透振方向垂直，此时$i_1=i_B,r_p=0$，不发生反射，只发生透射，于是会看得更清晰</p><p><img src="/images/%E9%80%8F%E6%8C%AF.png" class="lazyload" data-srcset="/images/%E9%80%8F%E6%8C%AF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="透振"></p><h3 id="偏振">偏振</h3><p>线偏振光的反射、折射光仍为线偏振光，但其光矢量方向会发生改变（上为入射光，下为反射光）</p><img src="/images/线偏振的反射光.png" class="lazyload" data-srcset="/images/线偏振的反射光.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线偏振的反射光" style="zoom:50%;" /><p>圆偏振/椭圆偏振光的反射折射光一般为椭圆偏振光</p><h2 id="全内反射">全内反射</h2><p>从折射率高射向折射率低，当入射角满足$i_1 \ge i_c$时，就会发生全内反射（Total internal reflection）</p><img src="/images/全内反射.png" class="lazyload" data-srcset="/images/全内反射.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="全内反射" style="zoom:50%;" /><p>此时$R\equiv 1$，也就是所有能量都被反射，不发生透射，于是低折射率那一侧看不到任何光，物体变黑了，这个现象就是全内反射</p><p>全内反射的应用：棱镜（Prisms）、光纤</p><h3 id="隐失波">隐失波</h3><p>隐失波（Evanescent wave） ：光从光密介质入射光疏介质时，如果发生全内反射，光疏介质那一侧产生的电磁波</p><p>隐失波的振幅随着穿透深度（Depth of penetration）的增加而呈现指数衰减，随切线方向而改变相位，因此是一种表面波</p><p>$$<br>d=\frac{\lambda_2}{2\pi \Omega}<br>$$</p><ul><li>穿透深度：与分界面的垂直深度，用$d$表示</li><li>$\sqrt{1-\sin ^2 i_2} \equiv \mathrm{i}\Omega$</li></ul><p>隐失波沿着z轴衰减，沿着x轴传播<br>$$<br>E_2=E_{02}e^{-z/d}e^{\mathrm{i}(k_xx-\omega t)}<br>$$<br><img src="/images/隐失波.png" class="lazyload" data-srcset="/images/隐失波.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="隐失波" style="zoom:67%;" /></p><p>隐失波不是横波</p><p>隐失波的一个应用是制作分光镜，如果只有一个棱镜（下图黑色三角形），会发生全内反射，光线全部反射</p><img src="/images/单棱镜.png" class="lazyload" data-srcset="/images/单棱镜.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="单棱镜" style="zoom: 33%;" /><p>如果将两个棱镜靠近，通过控制两者间空气的间隙，在隐失波的作用下，能实现分光</p><p><img src="/images/%E5%88%86%E5%85%89%E9%95%9C.jpg" class="lazyload" data-srcset="/images/%E5%88%86%E5%85%89%E9%95%9C.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="分光镜"></p><p>其他应用：</p><ul><li>光子隧穿</li><li>近场扫描显微镜</li><li>指纹检测</li></ul><img src="/images/指纹检测.png" class="lazyload" data-srcset="/images/指纹检测.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="指纹检测" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：波动光学</title>
      <link href="/optics/%E6%B3%A2%E5%8A%A8%E5%85%89%E5%AD%A6/"/>
      <url>/optics/%E6%B3%A2%E5%8A%A8%E5%85%89%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1>二：波动光学</h1><h2 id="内容概述">内容概述</h2><ul><li>简谐波（simple harmonic waves）</li><li>傅里叶变换（Fourier Transform）</li><li>波的物理量</li></ul><h2 id="数学基础">数学基础</h2><h3 id="常用函数">常用函数</h3><h4 id="三角函数">三角函数</h4><p>欧拉公式<br>$$<br>e^{\mathrm{i}x}=\cos x + \mathrm{i}\sin x<br>$$<br>三角函数的复数表示<br>$$<br>\sin z=\frac{e^{\mathrm{i}z}-e^{-\mathrm{i}z}}{2\mathrm{i}}<br>$$</p><p>$$<br>\cos z=\frac{e^{\mathrm{i}z}+e^{-\mathrm{i}z}}{2}<br>$$</p><h4 id="delta-函数">$\delta$函数</h4><p><em>德尔塔函数，冲击函数</em></p><p>整体积分为1，除了0点以外，其他点函数值都为0<br>$$<br>\delta(x)=0,(x\ne0)<br>$$</p><p>$$<br>\int^{\infty}_{-\infty}\delta(x)dx=1<br>$$</p><h4 id="高斯函数">高斯函数</h4><p><em>概率论里的正态分布</em><br>$$<br>f(x)=ae^{-(x-b)^2/2c^2}<br>$$</p><ul><li>a&gt;0</li></ul><p><img src="/images/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0.jpg" class="lazyload" data-srcset="/images/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="高斯函数"></p><h4 id="洛伦兹函数">洛伦兹函数</h4><p><em>概率论里的柯西分布</em><br>$$<br>f(x)=\frac{A}{B^2+x^2}<br>$$</p><h4 id="矩形脉冲函数">矩形脉冲函数</h4><p>$$<br>f(t)=E[u(t+\frac{\tau}{2})-u(t-\frac{\tau}{2})]<br>$$</p><h2 id="波的数学表示">波的数学表示</h2><p>定态波：空间中各点均为同频率的简谐振荡，各点振幅不随时间改变</p><p>震荡（Vibration）：物理量围绕其平衡位置进行周期性变化</p><p>简谐震荡（Harmonic vibration）：物理量随着时间以三角函数的形式进行震荡<br>$$<br>U(t)=A\cos(\omega t+\varphi_0)<br>$$</p><ul><li>振幅（amplitude，用$A$表示）</li><li>角频率（angular frequency，用$\omega$表示）</li></ul><p>$$<br>\omega=\frac{2\pi}{T}<br>$$</p><ul><li>相位（phase，用$\varphi$表示）</li><li>初相（initial phase，用$\varphi_0$表示）</li></ul><p>波（waves）：震荡在空间中的传播</p><p>简谐波（simple harmonic waves）：进行简谐震荡的波</p><p>单色平面波可以视为简谐波</p><p>波阵面（wave surface）：波在介质中传播，经过相同时间所到达的各点所连成的线/面</p><p>波前（wave front）：最前面的波阵面</p><p>相速度（phase velocity，用$v_p$表示）：波传递的速度<br>$$<br>v_p=\frac{\omega}{k}<br>$$</p><h2 id="傅立叶变换">傅立叶变换</h2><p>将一个满足条件的函数，转化为三角函数（或他们积分）的线性组合<br>$$<br>\hat{f}=&lt;f,E_k&gt;=\int f(x)e^{-2\pi i k\cdot x}\mathrm{d}x<br>$$<br>其傅里叶级数为<br>$$<br>\sum\hat{f}(k)E_k<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光学：电磁波</title>
      <link href="/optics/%E7%94%B5%E7%A3%81%E6%B3%A2/"/>
      <url>/optics/%E7%94%B5%E7%A3%81%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<h1>三：电磁波</h1><h2 id="内容概述">内容概述</h2><ul><li>横波的性质（nature），强度（intensity），能量流动（energyflow）</li><li>偏振态（Polarization states），琼斯矩阵（Jones matrix/vector）</li><li>吸收（Absorption），色散（dispersion），折射率（refractive index）</li><li>微小粒子导致的散射（Scattering）</li></ul><h2 id="波">波</h2><p>构成波的条件：</p><ul><li>波源</li><li>介质</li><li>能量来源</li></ul><p>波的性质：</p><ul><li>时间周期性</li><li>空间周期性</li><li>能量传播</li></ul><p>波的分类</p><ul><li>标量波</li><li>矢量波</li></ul><h2 id="光的基本性质">光的基本性质</h2><ul><li><p>光是电磁波</p></li><li><p>可见光的波长在400nm~760nm</p><ul><li>在做干涉衍射计算时，经常去白光的平均波长550nm</li></ul></li><li><p>人眼对550nm的黄绿光最敏感</p></li><li><p>单色光（Monochromatic light），指仅有一种波长的光，仅存在于理论中</p></li></ul><h3 id="光速">光速</h3><p>光在真空（vacuum）中的速度（简称光速，用c表示）为<br>$$<br>c=\frac{1}{\sqrt{\varepsilon_0 \mu_0}}=2.997 924 58 \times10^8 m/ s<br>$$<br>光在介质（medium）中的速度（也叫做相速度，用v表示）为<br>$$<br>v=\frac{1}{\sqrt{\varepsilon_0 \varepsilon_r\mu_0\mu_r}}=\frac{c}{\sqrt{\varepsilon_r \mu_r}}<br>$$<br>很显然光在介质中的速度比在真空中慢，我们用折射率（Refractive index，用n表示）来描述这一性质<br>$$<br>n=\frac{c}{v}<br>$$<br>光穿过线性介质（linear medium）时，其频率不会发生改变</p><p>光的波长（用$\lambda$表示）<br>$$<br>\lambda=\frac{c}{v}<br>$$</p><h3 id="波粒二象性">波粒二象性</h3><h4 id="波-2">波</h4><p>如果光是波，那么光应该有波的性质：<br>$$<br>\mathbf{k}=\frac{2\pi}{\lambda}\hat{\mathbf{k}}<br>$$</p><p>$$<br>v=\frac{\lambda}{T}=\lambda \nu<br>$$</p><p>$$<br>\omega=2\pi \nu =\frac{2\pi}{T}=\frac{2\pi}{\lambda}v=kv=k_0c<br>$$</p><ul><li>波长（wavelength，用$\lambda$表示）</li><li>波向量（wave vector，用$\mathbf{k}$表示）</li><li>频率（frequency，用$\nu$表示）</li><li>周期（temporal period，用$T$表示）</li><li>角频率（angular frequency，用$\omega$表示）</li><li>速度（velocity，用$v$表示）</li></ul><p>光是电磁波，其电矢量和磁矢量在做简谐振动，一般情况下，我们只讨论电场强度的变化</p><h4 id="粒">粒</h4><p>如果光是粒子，那么光应该有粒子的性质：<br>$$<br>E=h\nu=\hbar \omega<br>$$</p><p>$$<br>\mathbf{p}=\hbar \mathbf{k}=\frac{h}{\lambda}\hat{\mathbf{k}}<br>$$</p><ul><li>能量（Energy，用$E$表示）</li><li>动量（Momentum，用$\mathbf{p}$表示）</li><li>普朗克常量（Plank constant，用$h$表示，$h=6.626\times 10^{-34}\mathrm{J}\cdot\mathrm{s}$</li><li>约化普朗克常量（用$\hbar$表示）</li></ul><h4 id="波粒二象性-2">波粒二象性</h4><p>光具有波粒二象性（Wave-particle duality），光在传播过程中体现出明显的波性，在光与物质交互（light-matter interaction）中粒性更明显</p><h4 id="光子与电子">光子与电子</h4><p>不同之处</p><table><thead><tr><th></th><th>电子</th><th>光子</th></tr></thead><tbody><tr><td>静止质量（Rest mass）</td><td>$m_0$</td><td>0</td></tr><tr><td>运动质量（Motion mass）</td><td>$m$</td><td>$hv/c^2$</td></tr><tr><td>运动速度（Motion velocity）</td><td>$&lt;c$</td><td>$c$</td></tr><tr><td>自旋（Spin）</td><td>1/2</td><td>1</td></tr><tr><td>分布定律</td><td>费力（Fermion）</td><td>玻色（Boson）</td></tr></tbody></table><p>相同之处</p><ul><li>满足波粒二象性</li></ul><h4 id="向量波与标量波">向量波与标量波</h4><p>向量波（Vector wave），波函数是向量的波，比如电磁波（EM wave）</p><p>标量波（Scalar wave），波函数是标量的波，比如声波（Acoustic wave）</p><p>光波（Lightwaves）是一种向量波，但为了方便，我们在讨论干涉衍射时，会认为光是标量波，仅仅在讨论偏振时，才认为光是向量波</p><h3 id="电磁波">电磁波</h3><h4 id="物理量">物理量</h4><ul><li>电场强度（用$\mathrm{E}$表示）：单位电荷在电场中受到的力</li><li>磁场强度（用$\mathrm{H}$表示）：通电导线周围有磁场，其强度与电流大小、距离远近有强度（但实际被后世推翻，无实际意义）</li><li>电场通量密度（用$\mathrm{D}$表示）：单位面积的电场通量</li><li>磁场通量/感应密度（用$\mathrm{B}$表示）：经过一个曲面的磁力线的数量</li></ul><h4 id="电磁学三定律">电磁学三定律</h4><p>库伦定律，真空中两个静止的点电荷间作用力满足<br>$$<br>F=k\frac{q_1q_2}{r^2}<br>$$</p><ul><li>静电力常量（$k=9.0\times 10^9 \mathrm{N} \cdot\mathrm{m^2}/\mathrm{C^2}$）</li></ul><p>安培环路定律（Ampère’s Circuital Law），也叫右手螺旋定则，载流导线能生磁</p><p>法拉第电磁感应定律（Faraday’s Induction Law），磁场变化能产生电场，感应电动势大小与磁通量变化率成正比，电场方向符合楞次定律（由于磁通量的改变而产生的感应电流，其方向为抗拒磁通量改变的方向）</p><h4 id="麦克斯韦方程">麦克斯韦方程</h4><p>真空中麦克斯韦方程：</p><p>法拉第<br>$$<br>\nabla \times \mathbf{E}=-\frac{\partial \mathbf{B}}{\partial t}<br>$$</p><p>安培<br>$$<br>\nabla \times \mathbf{B}=\mu_0 \varepsilon_0 \frac{\partial \mathbf{E}}{\partial t}<br>$$</p><ul><li>真空磁导率（也称为磁常数，用$\mu_0$表示，$\mu_0=4\pi \times 10^{-7}\mathrm{H}/\mathrm{m}$）</li><li>真空电容率（也称为电常数，用$\varepsilon_0$表示，$\varepsilon_0=8.854…\times10^{-12}\mathrm{F}/\mathrm{m}$）</li></ul><p>高斯电场<br>$$<br>\nabla \cdot \mathbf{E}=0<br>$$</p><p>高斯磁场<br>$$<br>\nabla \cdot \mathbf{B}=0<br>$$</p><p>自由空间的波动方程（wave equations，由麦克斯韦方程推出）：<br>$$<br>\nabla^2\mathbf{E}=\mu_0 \varepsilon_0 \frac{\partial^2 \mathbf{E}}{\partial t^2}<br>$$</p><p>$$<br>\nabla^2\mathbf{B}=\mu_0 \varepsilon_0 \frac{\partial^2 \mathbf{B}}{\partial t^2}<br>$$</p><h4 id="平面波">平面波</h4><p>三维的电磁波很难分析，我们可以分解变量，将其转化为两个垂直的平面波</p><p>平面波（Plane waves）：传播时波面在一个平面的电磁波</p><p>平面波的电场方向和磁场方向，与波矢方向垂直，如图，$\mathbf{k}$为波矢方向（推导过程略），从这里也能看出，平面波是横波，方向满足右手定则</p><p><img src="/images/%E5%B9%B3%E9%9D%A2%E6%B3%A2%E6%B3%A2%E7%9F%A2.png" class="lazyload" data-srcset="/images/%E5%B9%B3%E9%9D%A2%E6%B3%A2%E6%B3%A2%E7%9F%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="平面波波矢"></p><p>平面波的磁感应强度B和电场强度E的比值等于波速<br>$$<br>\frac{|E|}{|B|}=\sqrt{\frac{1}{\mu \varepsilon}}=v<br>$$<br>电场强度和磁场强度的关系为（注意，这里不是磁感应强度）<br>$$<br>\sqrt{\varepsilon_0 \varepsilon_r}|\mathrm{E}|=\sqrt{\mu_0\mu_r}|\mathrm{H}|<br>$$<br>自由空间阻抗（单位和电阻相同，用$Z_0$表示）<br>$$<br>Z_0=\sqrt{\frac{\mu_0}{\varepsilon_0}}=376.73\Omega<br>$$<br>波能传递能量，我们引入坡印廷向量（Poynting vector，用$\mathrm{S}$来表示）来描述能量流动，其方向为电磁能传递方向，大小为能流密度（单位面积的能量传输速率）<br>$$<br>\mathrm{S}=\mathrm{E}\times \mathrm{H}<br>$$<br>平面波$\mathrm{E}\times \mathrm{H} // \mathrm{k}$</p><h4 id="傍轴条件">傍轴条件</h4><p>当$\rho \ll z，r \approx z$</p><img src="../../images/傍轴条件.png" class="lazyload" data-srcset="../../images/傍轴条件.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="傍轴条件" style="zoom:50%;" /><h4 id="远场条件">远场条件</h4><h4 id="辐照度">辐照度</h4><p>电磁波的辐照度（Irradiance，用$\mathrm{I}$表示，也称为Intensity），是坡印廷向量在时间上的平均值<br>$$<br>\mathrm{I}=\left&lt; \mathrm{S} \right&gt;=\frac{nc\varepsilon_0}{2}\mathrm{E_0}^2<br>$$</p><ul><li>$c$是真空中光速</li><li>$\mathrm{E_0}$是电磁波电场强度的振幅（电场强度是一个三角周期函数）</li></ul><p>从这里可以看出，辐照度与$\mathrm{E_0}$的平方成正比</p><h2 id="偏振">偏振</h2><p>偏振（Polarization）：光矢量在垂直于传播方向的平面上的震动状态，我们这里提的是电场强度$\mathrm{E}$的震动</p><ul><li><p>根据是否发生偏振</p><ul><li>不偏振光（Unpolarizedlight）</li><li>完全偏振光（Completely polarized light）</li><li>部分偏振光（Partially polarized  light）</li></ul></li><li><p>根据向量$\mathrm{E}$的终点（endpoint）轨迹</p><ul><li>线偏振（Linearly polarized light）</li><li>圆偏振（Circularly polarized light）</li><li>椭圆偏振（Elliptically polarized light）</li></ul></li></ul><p>若光线沿着z轴传播，其方程满足<br>$$<br>(\frac{E_x}{E_{0x}})^2+(\frac{E_y}{E_{0y}})^2-2(\frac{E_x}{E_{0x}})(\frac{E_y}{E_{0y}})\cos \delta = \sin ^2 \delta<br>$$</p><h3 id="线偏振">线偏振</h3><p>当$\delta=2m\pi$时，方程变为<br>$$<br>(\frac{E_x}{E_{0x}})^2+(\frac{E_y}{E_{0y}})^2-2(\frac{E_x}{E_{0x}})(\frac{E_y}{E_{0y}}) = 0 \<br>(\frac{E_x}{E_{0x}}-\frac{E_y}{E_{0y}})^2=0<br>$$<br>于是得到线偏振的方程（一三象限）<br>$$<br>\frac{E_x}{E_{0x}}=\frac{E_y}{E_{0y}} \equiv \cot \alpha<br>$$<br><img src="/images/线偏振.png" class="lazyload" data-srcset="/images/线偏振.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线偏振" style="zoom: 67%;" /></p><p>同理，当$\delta=2(m+1)\pi$时，方程等于（二四象限）<br>$$<br>\frac{E_x}{E_{0x}}=-\frac{E_y}{E_{0y}}<br>$$<br>用虚数将两个方程合并，得到<br>$$<br>\frac{E_x}{E_{y}}=\frac{E_{0x}}{E_{0y}}e^{\mathrm{i}m’\pi}<br>$$</p><ul><li>当$m’$为偶数（0 or even）时，一三象限</li><li>当$m’$为奇数（odd）时，二四象限</li></ul><h3 id="椭圆偏振与圆偏振">椭圆偏振与圆偏振</h3><p>当$\delta=(2m+1)\frac{\pi}{2}$时，方程变为<br>$$<br>(\frac{E_x}{E_{0x}})^2+(\frac{E_y}{E_{0y}})^2=1<br>$$<br>这是一个椭圆方程，我们称之为椭圆偏振</p><p>倘若$E_{0x}=E_{0y}=E_{0}$，方程退化为<br>$$<br>E_x^2+E_y^2=E_0^2<br>$$<br>我们称之为圆偏振</p><img src="/images/椭圆偏振.png" class="lazyload" data-srcset="/images/椭圆偏振.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="椭圆偏振" style="zoom:50%;" /><ul><li><p>当$\delta=\pi / 2$时，y轴驱动x轴移动，此时为顺时针，称为RCP</p></li><li><p>当$\delta=-\pi / 2$时，x轴驱动y轴移动，此时为逆时针，称为LCP</p></li></ul><p><img src="/images/RCP.png" class="lazyload" data-srcset="/images/RCP.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RCP"></p><h3 id="琼斯矢量">琼斯矢量</h3><p>将偏振光的状态以向量的形式写出，方便运算（只适合完全极化光）<br>$$<br>\mathrm{E}=\left[<br>\begin{array}{c}<br>E_x(t)\<br>E_y(t)\<br>\end{array}<br>\right]<br>$$<br>琼斯向量左乘一个2x2矩阵，可以得到一个新的琼斯向量，这个矩阵被称为琼斯矩阵</p><h3 id="偏振度">偏振度</h3><p>偏振度（Degree of polarization，用$P$表示）：用来衡量偏振程度的物理量<br>$$<br>P=\frac{I_p}{I_t}=\frac{I_p}{I_p+I_n}<br>$$</p><ul><li>$I_p$：完全偏振光部分的辐照度</li><li>$I_n$：不偏振光部分（自然光）的辐照度</li></ul><h2 id="吸收">吸收</h2><h3 id="兰伯特定律">兰伯特定律</h3><p>兰伯特定律（Lambert law）：光在气体介质中传播，光强（intensity）随着传播深度增加而递减，满足<br>$$<br>I=I_0 e^{-\alpha x}<br>$$</p><ul><li>吸收系数（用$\alpha$表示）</li><li>传播深度（用$x$表示）</li></ul><h3 id="贝尔定律">贝尔定律</h3><p>贝尔定律（Beer law）：光在溶剂中传播，光强满足<br>$$<br>I=I_0 e^{-ACL}<br>$$</p><ul><li>浓度（用$C$表示）</li><li>常数$A$，与溶质性质有关，与浓度无关</li></ul><p>该公式满足有两个条件</p><ul><li>溶液浓度不能过高，以免出现分子间作用力（这也能解释为什么常数$A$为什么和浓度无关，因为浓度一高，公式就不成立了）</li><li>光强不能过高</li></ul><h2 id="色散">色散</h2><p>色散（Dispersion）：光波的相速度随着频率的改变而改变的现象</p><p><img src="/images/%E8%89%B2%E6%95%A3.png" class="lazyload" data-srcset="/images/%E8%89%B2%E6%95%A3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="色散"></p><p>正常色散（Normal dispersion）：折射率随着波长的增加而减小</p><p>柯西公式：<br>$$<br>n=A+B/\lambda^2+C/\lambda^4<br>$$<br>反常色散（Anomalous dispersion）：折射率随着波长的增加而增加</p><p>反常色散通常发生在吸收带（absorption band）附近，反常色散并不是异常的，叫这个名字只是历史问题</p><h3 id="洛伦兹震荡模型">洛伦兹震荡模型</h3><p>洛伦兹震荡模型（Lorentz oscillator model）：在一个尺寸为$\Delta V$的空间内有一个电子（电荷量为$1.6\times10^{-19}C$），在光的电场作用下，让该电子相对于稳定位置偏离x</p><p>偏振度（单位体积电偶极矩的振幅，用$P$表示）写作<br>$$<br>P=\frac{1}{\Delta V}ex=n_0ex<br>$$</p><ul><li>电荷密度（density of charge，用$n_0$表示）</li><li>$x$是电子的运动方程，如下</li></ul><p>$$<br>x(\omega)=-\frac{eE(\omega)}{m_0}\frac{1}{\omega^2+\mathrm{i}\omega \gamma-\omega_0^2}<br>$$</p><p>将$x$带入，得到<br>$$<br>P=-\frac{n_0e^2}{m_0}\frac{1}{\omega^2+\mathrm{i}\omega \gamma-\omega_0^2}E(\omega)<br>\equiv \varepsilon_0 \chi(\omega)E(\omega)<br>$$<br>根据定义<br>$$<br>\varepsilon=\varepsilon_0[1+\chi(\omega)]<br>$$<br>带入得<br>$$<br>n^2=\varepsilon/\varepsilon_0=1-\frac{n_0e^2}{m_0}\frac{1}{\omega^2+\mathrm{i}\omega \gamma-\omega_0^2}<br>$$<br><img src="/images/洛伦兹模型.png" class="lazyload" data-srcset="/images/洛伦兹模型.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="洛伦兹模型" style="zoom:67%;" /></p><p>如图，洛伦兹模型解释了为什么在靠近吸收带时，会发生反常色散</p><h3 id="组速度">组速度</h3><p>在介质中不同波长的光速度不同，红光波长大，跑的更快</p><p>那么如果一个光，包含了多种波长的光，我们用组速度（Group velocity，用$v_g$表示）来描述其速度<br>$$<br>v_g=\frac{\mathrm{d}\omega}{\mathrm{d}k}<br>$$</p><h2 id="散射">散射</h2><p>一般我们在讨论光在介质中传播，认为是没有损失的，但实际上光在介质中传播是存在吸收的</p><p>吸收：光强度随着穿进介质深度而减弱的现象</p><p>原因：</p><ul><li>光能转化为其他能，比如热量、化学能、电能</li><li>发生散射，光向四面八方传播（丁达尔效应）</li></ul><h3 id="瑞丽散射">瑞丽散射</h3><p>瑞丽散射（Rayleigh scattering）：光在细小粒子间散射<br>$$<br>I_{scat}\propto 1/\lambda^4<br>$$</p><p>$$<br>I_{\theta}\propto I_{\pi/2}(1+\cos^2 \theta)<br>$$</p><h3 id="米氏散射">米氏散射</h3><p>米氏散射（Mie scattering）：光在大型粒子内部散射</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++</title>
      <link href="/program/Effective%20C++/"/>
      <url>/program/Effective%20C++/</url>
      
        <content type="html"><![CDATA[<h1>Effective C++</h1><h2 id="一：C-基础">一：C++基础</h2><h3 id="C-很成熟，很NB">C++很成熟，很NB</h3><p>C++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）</p><p>其核心是四个部分</p><ul><li>C<ul><li>区块block</li><li>语句statements</li><li>预处理器preprocessor</li><li>内置数据类型</li><li>数组arrays</li><li>指针pointers</li></ul></li><li>Object-Orientend C++<ul><li>类classes（构造函数，析构函数）</li><li>封装encapsulation</li><li>继承inheritance</li><li>多态polymorphism</li><li>虚函数virtual（动态绑定）</li></ul></li><li>Template C++</li><li>STL</li></ul><h3 id="替换-define">替换#define</h3><p>使用编译器替代预处理器</p><p>尽量使用const、enum定义常量，使用inlines定义函数宏</p><h4 id="const">const</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br></pre></td></tr></table></figure><p>因为<code>#define</code>不是语言的一部分，在编译器开始工作前，<code>PI</code>就会被处理掉，所以一旦报错，你无法追踪到<code>PI</code>，只能看到<code>3.1415926</code>，这会<strong>浪费你的时间</strong></p><p>应该改为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> Pi <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><p>值得注意的事</p><ul><li>定义常量指针指向char*-based字符串</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> authorName = <span class="string">&quot;Reuben&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GemePlayer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns = <span class="number">5</span>;<span class="comment">//这只是一个声明式</span></span><br><span class="line"><span class="type">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> GamePlayer::NumTurns;<span class="comment">//这是定义式，因为在声明时已经赋值，所以这里就不赋值了</span></span><br></pre></td></tr></table></figure><p>C++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式</p><p>从这里可以看出，<strong>const可以封装</strong>，而#define不行</p><h4 id="enum">enum</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GemePlayer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="const指针">const指针</h3><p>const在星号左边，被指物是常量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = greeting;</span><br></pre></td></tr></table></figure><p>const在星号右边，指针本身是常量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;</span><br></pre></td></tr></table></figure><p>const在星号两边，被指物和指针都是常量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;</span><br></pre></td></tr></table></figure><h3 id="确认对象在使用前已经被初始化">确认对象在使用前已经被初始化</h3><p>C++初始化顺序</p><ul><li>基类比子类先初始化</li><li>成员变量根据其声明次序初始化</li></ul><h2 id="二：构造-析构-赋值">二：构造/析构/赋值</h2><h3 id="空类的默认函数">空类的默认函数</h3><p>一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数</p><p>一个类，如果没有构造函数，也会自动声明一个default构造函数</p><p>这些函数都是public且inline的</p><h3 id="禁用自动生成的函数">禁用自动生成的函数</h3><p>如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）</p><ul><li>你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">HomeForSale</span>(<span class="type">const</span> HomeForSale&amp;);</span><br><span class="line">  HomeForSale&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HomeForSale&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以制作一个不可被copy的类，让子类继承</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">  ~<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">  Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span>: <span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="为多态基类声明virtual析构函数">为多态基类声明virtual析构函数</h3><h4 id="一定要有一个virtual析构函数">一定要有一个virtual析构函数</h4><ul><li>如果这个类要成为一个基类，那么一定要有一个virtual析构函数</li></ul><p>在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicClock</span>: <span class="keyword">public</span> TimeKeeper &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterClock</span>: <span class="keyword">public</span> TimeKeeper &#123;...&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TimeKeeper* ptk = <span class="built_in">getTimeKeeper</span>();<span class="comment">//创建一个动态分配对象</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;<span class="comment">//释放对象，避免资源泄漏</span></span><br></pre></td></tr></table></figure><p>上面这个过程的问题其实出在<code>getTimeKeeper()</code>指向一个派生类（derived class）对象（比如<code>AtomicClock</code>），而这个对象却要经由一个基类（base class）指针删除（比如<code>TimeKeeper*</code>）</p><p>如果这个基类的析构函数不是virtual的，就会出现问题：</p><ul><li>如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象</li></ul><p>解决方法就是给基类一个virtual析构函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TimeKeeper</span>();</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="最好不要有virtual析构函数">最好不要有virtual析构函数</h4><ul><li>如果这个类不可能成为基类，那么最好不要有virtual析构函数</li></ul><p>为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由<strong>vptr（virtual table pointer）<strong>指针携带，这个指针指向一个由函数指针构成的数组，称为</strong>vtbl（virtual table）</strong>，每一个带有virtual函数的类都有一个属于自己的vtbl</p><p><strong>这个vtbl会增大对象的体积</strong>，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍</p><p><strong>这个vtbl会让代码失去兼容性</strong>，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性</p><h4 id="请不要继承没有virtual析构函数的类">请不要继承没有virtual析构函数的类</h4><p>比如string、vector、list、set等等</p><p>而且 C++没有像 Java的<code>final classes</code>或者C#的<code>sealed classes</code>的禁止派生机制</p><h3 id="不要在析构函数里抛出异常">不要在析构函数里抛出异常</h3><p>当一个<code>vector v</code>容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为</p><p>有两个不怎么好的解决方法</p><ul><li>遇到异常，直接<code>std::abort()</code>，即遇到异常，宁愿直接强制停止程序，也不要让异常传播</li><li>遇到异常，把异常记录下来，另程序继续运转，即<strong>吞下异常</strong><ul><li>这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好</li></ul></li></ul><p>比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnevtion</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> DBConnevtion <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span><span class="comment">//封装给客户用的,关闭连接的函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//强制关闭程序或者吞下异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不要在构造和析构过程中调用virtual函数">不要在构造和析构过程中调用virtual函数</h3><p>在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果</p><p>可以简单理解为<strong>在C++中，基类构造期间，vritual函数不是vritual函数</strong></p><p>因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数</p><p>同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的</p><h3 id="令operator-返回一个对-this的引用">令operator=返回一个对*this的引用</h3><p>连续赋值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = y = z = <span class="number">15</span>;</span><br><span class="line"><span class="comment">//其实就等于x = (y = (z = 15))；</span></span><br></pre></td></tr></table></figure><p>为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="xxxxxxxxxx-添加要提交的内容-git-add-文件名-文件夹名-提交所有内容（不包含忽略文件），并设置提交信息为“这是一段话”-git-commit-a-m-这是一段话bash">xxxxxxxxxx #添加要提交的内容$git add 文件名/文件夹名#提交所有内容（不包含忽略文件），并设置提交信息为“这是一段话”$git commit -a -m 这是一段话bash</h3><p>如果对象自己赋给自己，我们称之为自我赋值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">w = w;</span><br><span class="line">a[i] = a[j]; <span class="comment">//当i=j时，自我赋值</span></span><br><span class="line">*px = *py;<span class="comment">//px和py指向同一个物体时，自我赋值</span></span><br></pre></td></tr></table></figure><p>在赋值操作中：</p><ol><li>我们会先另左边的操作数先释放掉当前使用的数据</li><li>令其使用右操作数的副本</li><li>最后返回左操作数</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *pb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//!!!这个不安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果自我赋值，即rhs和pb指向同一个对象，那么<code>delete pb</code>后，这个对象就已经被销毁了，下面使用的<code>*rhs</code>就是一个已经被删除的对象</p><p>解决方法1：延后delete</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法2：使用copy and swap技术</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);<span class="comment">//令*this与temp交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制对象的一切">复制对象的一切</h3><p>如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错</p><p>派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）</p><p>所以copy函数需要</p><ul><li>复制所有local变量</li><li>调用所有基类中的适当的copy函数</li></ul><h2 id="三：资源管理">三：资源管理</h2><h3 id="让对象管理资源">让对象管理资源</h3><p>将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源</p><ul><li>申请资源后立即将其放进对象中，<strong>资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）</strong></li><li>在对象的析构函数中释放资源</li></ul><p>C++的<code>auto_ptr</code>是一个<strong>类指针（pointer-like）对象</strong>，也就是<strong>智能指针</strong>，其析构函数会自动delete掉其所指向的对象</p><p>注意：</p><ul><li>不要让多个<code>auto_ptr</code>指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”</li><li><code>auto_ptr</code>如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权</li></ul><p>**RCSP（引用计数型智能指针）**也是一种智能指针（比如<code>tr1::shared_ptr</code>），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源</p><h3 id="小心copy行为">小心copy行为</h3><p>大多数RAII对象的copy函数：</p><ul><li>禁止复制</li><li>采用引用计数法（RCSP）</li><li>复制底部资源（深拷贝）</li><li>转移底层资源所有权（auto_ptr）</li></ul><h3 id="在资源管理类中提供对原始资源的访问">在资源管理类中提供对原始资源的访问</h3><p>有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）</p><h3 id="new与delete一个数组">new与delete一个数组</h3><p>一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？</p><ul><li>如果new了一个数组，就delete一个数组</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string* ptr1 = <span class="keyword">new</span> string[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> [] ptr1;</span><br></pre></td></tr></table></figure><ul><li>如果new了一个对象，就delete一个对象</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string* ptr2 = <span class="keyword">new</span> string;</span><br><span class="line"><span class="keyword">delete</span> ptr2;</span><br></pre></td></tr></table></figure><p>很多时候很难确定当前这个对象是数组还是一个对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string AddressLines[<span class="number">4</span>];</span><br><span class="line">string* pal = <span class="keyword">new</span> AddressLines;</span><br><span class="line"><span class="keyword">delete</span> [] pal;</span><br></pre></td></tr></table></figure><p>最简单的方法是不用数组，使用STL里的容器，如<code>vector&lt;string&gt;</code></p><h3 id="以独立语句将newed对象置入智能指针">以独立语句将newed对象置入智能指针</h3><p>C++中调用一个函数，会先计算每一个传递进去的实参</p><p>如果按下面的写法，将newed对象置入智能指针中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">分配函数(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), 资源访问);<span class="comment">//不要这样写</span></span><br></pre></td></tr></table></figure><p>需要执行一下函数</p><ul><li>调用“资源访问”函数（A）</li><li>执行<code>new Widget</code>（B）</li><li>调用<code>shared_ptr</code>构造函数（C）</li></ul><p>然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）</p><p>如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏</p><p>所以简单的方法是分离语句</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line">分配函数(pw, 资源访问);</span><br></pre></td></tr></table></figure><h2 id="四：设计与声明">四：设计与声明</h2><h3 id="让接口容易被正确使用">让接口容易被正确使用</h3><p>客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）</p><h4 id="限制参数传递">限制参数传递</h4><p>这是一个日期类</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(<span class="type">int</span> month, <span class="type">int</span> day, <span class="type">int</span> year);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">4</span>, <span class="number">20</span>, <span class="number">2022</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>客户很有可能填错顺序，也有可能填入一个无效的参数</p><p>可以使用<strong>外覆类型（wrapper types）</strong>，当然做出类会更好</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span>&#123;</span><br><span class="line">  <span class="function">explict <span class="title">Day</span><span class="params">(<span class="type">int</span> d)</span> : val(d) &#123;</span>&#125;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span>&#123;</span><br><span class="line">  <span class="function">explict <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span> : val(m) &#123;</span>&#125;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Year</span>&#123;</span><br><span class="line">  <span class="function">explict <span class="title">Year</span><span class="params">(<span class="type">int</span> y)</span> : val(y) &#123;</span>&#125;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(<span class="type">const</span> Mouth&amp; month, <span class="type">const</span> Day&amp; day, <span class="type">const</span> Year&amp; year);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">4</span>), Day(<span class="number">20</span>), Year(<span class="number">2022</span>))</span></span>;</span><br></pre></td></tr></table></figure><h4 id="一致性">一致性</h4><p>自定义的行为要与内置类型的行为一致，比如你不能把<code>operator*</code>重载成<code>operator+</code></p><p>或则像STL中，容器的接口都很一致，比如<code>size</code>、<code>push_back</code>等等</p><h3 id="设计class犹如设计type">设计class犹如设计type</h3><ul><li>对象要如何创建和销毁</li><li>对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）</li><li>对象如果被值传递，意味着什么（深浅拷贝）</li><li>约束成员变量的合法值</li><li>是否可以/需要被继承</li><li>能否类型转换，如何类型转换</li><li>支持何种操作符</li><li>成员变量的访问修饰</li><li>成员函数的访问修饰</li><li>未声明接口（undecided interface）</li><li>是否需要定义模版</li><li>真的需要一个新类吗？</li></ul><h3 id="多用引用传递">多用引用传递</h3><p>C++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些<strong>很大的自定义类型</strong>来说性能非常糟糕</p><p>使用const引用传递会好很多</p><ul><li>不会创建新的对象</li><li>不会改变原有对象</li><li>可以避免<strong>对象切割</strong>问题<ul><li>对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了</li></ul></li></ul><p>只不过引用传递是大多是通过指针实现的，在处理一些<strong>简单的内置类型</strong>时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递</p><h3 id="必须返回对象时，不要返回引用">必须返回对象时，不要返回引用</h3><p>如果必须返回对象，请不要返回引用（比如<code>operator*</code>，<code>operator==</code>），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个<strong>右值</strong>的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用</p><h3 id="将成员变量隐藏">将成员变量隐藏</h3><p>成员变量应该为private，而不是public</p><ul><li>客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）</li><li>分离读写权限（这一点C#做的更好？）</li><li>封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）</li><li>便于对成员变量进行约束（更不容易出现异常值）</li><li>protected并不比public更具有封装性</li></ul><h3 id="使用非成员函数">使用非成员函数</h3><ul><li>C#，java选手可以略过</li><li>C++标准库就是这样写的</li></ul><p>这里有一个类，其中有多个成员函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doB</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doC</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在需要令一个函数做ABC三件事，有两种写法</p><ul><li>成员函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doEverything</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">doA</span>();</span><br><span class="line">    <span class="built_in">doB</span>();</span><br><span class="line">    <span class="built_in">doC</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>非成员函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doEverything</span><span class="params">(WebBrowser&amp; wb)</span></span>&#123;</span><br><span class="line">wb.<span class="built_in">doA</span>();</span><br><span class="line">  wb.<span class="built_in">doB</span>();</span><br><span class="line">  wb.<span class="built_in">doC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令人意外的是，第二种方法（使用非成员函数）更好</p><h4 id="什么是封装">什么是封装</h4><p>一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强</p><p>为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物</p><h4 id="为什么第二种比第一种封装性更强">为什么第二种比第一种封装性更强</h4><p>因为第一种给用户两种调用方法，一个是调用成员函数<code>doEverything()</code>，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性</p><ul><li>注意第一种方法中，<code>doEverything()</code>和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利</li></ul><p>那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的<strong>静态成员（static member）函数</strong>即可</p><p>或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doEverything</span><span class="params">(WebBrowser&amp; wb)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可拓展性更强</p><ul><li>客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）</li></ul></li><li><p>可拆分</p><ul><li>用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）</li></ul></li></ul><h3 id="如果所有参数都需要进行类型转换，使用非成员函数">如果所有参数都需要进行类型转换，使用非成员函数</h3><p>令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时</p><p>比如一个有理数乘法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//这个类没有自定义的explict构造函数</span></span><br><span class="line">  <span class="type">const</span> Rational opertaor* (<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf * oneEighth;<span class="comment">//成功</span></span><br><span class="line">result = result * oneEighth;<span class="comment">//成功</span></span><br><span class="line">result = oneHalf * <span class="number">2</span>;<span class="comment">//成功，等价于 result = oneHalf.operator*(2)</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;<span class="comment">//失败，等价于 result = 2.operator*(oneHalf)</span></span><br></pre></td></tr></table></figure><p><code>result = oneHalf * 2;</code>为什么成功，因为这里发生了一次隐式转换，将<code>2</code>转化为了一个<code>Rational</code>类型</p><p>在编译器中可能等价于</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Rational <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">result = oneHalf * temp;</span><br></pre></td></tr></table></figure><ul><li>如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将<code>2</code>转化为一个<code>Rational</code>类型</li></ul><p><code>result = 2 * oneHalf;</code>为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时<code>2</code>就是一个int类型，没有我们所自定义的<code>operator*</code>函数，自然会失败</p><p>可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此外要极力避免使用<strong>友元（friend）函数</strong></li><li>成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数</li></ul><h3 id="写一个不抛异常的swap函数">写一个不抛异常的swap函数</h3><p>swap函数原本是STL的一部分，后来称为了<strong>异常安全性编程</strong>的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要</p><p>std是一个很特殊的命名空间，客户可以<strong>全特化</strong>（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定</p><p>全特化：针对某个类做模板函数的特例，如对<code>std::swap</code>做一个针对<code>Widget</code>的特化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span>&#123;...&#125;;<span class="comment">//这个类的对象中存储着真正的数据</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>&#123;<span class="comment">//这个函数决对不可抛异常</span></span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);<span class="comment">//这是pimpl写法，交换两个对象只需要置换其pImpl指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImple* pImpl;<span class="comment">//这个类有一个指向资源对象的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;<span class="comment">//这个可以抛异常</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，C++的STL容器就是上面这种写法，提供了<code>public swap</code>成员函数和<code>std::swap</code>的特化版本</p><h2 id="五：实现（Implementations）">五：实现（Implementations）</h2><ul><li>随意定义变量可能会导致性能降低</li><li>过度使用转型（casts）可能会导致性能降低，难以维护，可读性低</li><li>返回对象的内部数据的handles，可能会破坏封装</li><li>未考虑异常可能会导致资源泄露和数据败坏</li><li>过度使用inline可能会导致包体膨胀</li><li>过度耦合（coupling）可能会增加构建时间（build times）</li></ul><h3 id="尽量延后变量定义式的出现时间">尽量延后变量定义式的出现时间</h3><h4 id="避免未曾使用的变量">避免未曾使用的变量</h4><p>如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过</p><p>此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、</p><h4 id="避免无意义的默认构造函数">避免无意义的默认构造函数</h4><p>如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好</p><h4 id="循环">循环</h4><p>此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？</p><p><strong>循环内</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">  <span class="function">Widget <span class="title">w</span><span class="params">(...)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>n个构造函数+n个析构函数</p></li><li><p>如果<code>Widget</code>是一个很敏感的类，这样会让其作用域更小，更容易理解和维护</p></li></ul><p><strong>循环外</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">  w = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个构造函数+一个析构函数+n个赋值操作</li><li>如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）</li></ul><h3 id="少做转型">少做转型</h3><p>C++是强类型语言，设计目标应该是保证类型错误绝不发生，然而<strong>类型转换</strong>破坏了类型系统</p><p>Java、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险</p><p>C++的类型转化</p><ul><li>旧式转换<ul><li><code>(T)expression</code></li><li><code>T(expression)</code></li></ul></li><li>新式转换<ul><li><code>const_cast&lt;T&gt;(expression)</code><ul><li>用于将对象的<strong>常量性转除（cast away the constness）</strong></li><li>比如将<code>const</code>转化为<code>non-const</code></li><li>注意，这个转换的目的，是将一个原本不是const但是莫名加了const的变量，去掉多余的const。如果你对一个真正的const做转换，是未定义行为，真正的const在编译阶段就放在readonly区了</li></ul></li><li><code>dynamic_cast&lt;T&gt;(expression)</code><ul><li>用来<strong>安全向下转型</strong></li><li>无法由旧式语句执行</li><li>耗费巨大</li></ul></li><li><code>reinterpret_cast&lt;T&gt;(expression)</code><ul><li>用于低级转型，实际操作取决于编译器，不可移植</li><li>极其少用</li></ul></li><li><code>static_cast&lt;T&gt;(expression)</code><ul><li>用于<strong>强迫隐式转换（implicit conversions）</strong></li><li>比如<code>non-const</code>转化为<code>const</code>，<code>int</code>转化为<code>double</code>，<code>void*</code>转化为<code>typed</code>，基类指针转化为派生类指针</li></ul></li></ul></li></ul><p>避免C++类型转换出问题的核心是<strong>避免使用基类的接口处理派生类</strong></p><h4 id="一个对象多个地址">一个对象多个地址</h4><p>C++很神奇，如果一个基类指针指向一个派生类对象，如</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Dervied d;</span><br><span class="line">Base* b = &amp;d;</span><br></pre></td></tr></table></figure><p>这可能会导致两个指针值不一样，即这个对象有两个地址，一个<code>Derivied*</code>指针一个<code>Base*</code>指针，这派生类指针上往往会有一个<strong>偏移量（offset）</strong>，通过这个偏移量，可以通过派生类指针找到基类指针</p><p>上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以<strong>请不要假定对象在C++中如何布局</strong>，更不应该基于这个假设对对象进行类型转换</p><p>如果你想让当前对象调用基类的函数，如果对<code>*this</code>做强制转化，转换为基类，<code>*this</code>其实是先前产生的<code>*this</code>对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//static_cast&lt;Window&gt;(*this).onResize();//这样不好</span></span><br><span class="line">    Window::<span class="built_in">onResize</span>();<span class="comment">//请用这种方式调用基类的onResize函数（作用到当前对象上）</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dynamic-cast">dynamic_cast</h4><p>这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象</p><p>什么时候使用这个东西？当<strong>你想在</strong>一个你认为是派生类对象的<strong>对象上执行</strong>派生类的操作<strong>函数</strong>，但你手里却只有一个指向基类的引用/指针时</p><p>解决方法：</p><ul><li>使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器</li><li>在基类中提供virtual函数</li></ul><h3 id="避免返回指向对象内部成分的handles">避免返回指向对象内部成分的handles</h3><p>前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便</p><p>但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span>&#123;</span><br><span class="line">  Point ulhc;<span class="comment">//upper left hand corner</span></span><br><span class="line">  Point lrhc;<span class="comment">//lower right hand corner</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;<span class="comment">//这样返回了引用，非常不好</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::tr1::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>);<span class="comment">//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改</span></span><br></pre></td></tr></table></figure><p><code>upperLeft</code>函数本来只是为了提供给客户获得（get）<code>Rectangle</code>的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了<code>Rectangle</code>本身，而且还是一个内部数据<code>RectData</code></p><p>为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）</p><p>解决方法很简单，只要让handles不可以被修改，就可以了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致<strong>dangling handles（空悬的号码牌）</strong>，比如返回了一个对local变量的引用，依然特别危险</p><p>当然，有的时候不得不返回handles，比如<code>operator[]</code></p><h3 id="异常安全性很重要">异常安全性很重要</h3><p>**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：</p><ul><li>不泄漏任何资源</li><li>不允许数据败坏</li></ul><p>不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂</p><p>三个保证：</p><ul><li>基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏</li><li>强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过<code>copy-and-swap</code>实现）</li><li>不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）</li></ul><p><strong>异常安全码</strong>必须提供上述三种保障之一，如果不能保障，则不具备异常安全性</p><h3 id="了解inline函数">了解inline函数</h3><p>内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化</p><p>缺点也很明显，会让包体变大，会导致<strong>换页行为（paging）</strong>，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数</p><p>内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联</p><h3 id="降低文件间的编译依存">降低文件间的编译依存</h3><p>如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译</p><p>为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用）</p><p>这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类</p><p><em>话说应该不会有人不知道implementation是实现的意思吧</em></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;<span class="comment">//pimpl写法，这是Person类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>;<span class="comment">//Data的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">//Address的前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Persion</span>&#123;<span class="comment">//像这样使用pimpl的类，往往被称为Handle classes</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种设计下，<code>Person</code>就与<code>Data</code>、<code>Address</code>以及<code>Persons</code>的实现分离了，改动这些类也不会导致使用<code>Person</code>的客户重新编译，客户无法看到<code>Person</code>的实现细节，真正实现<strong>接口与实现分离</strong></p><p>这个操作的本质是用<strong>声明的依赖性</strong>替换<strong>定义的依赖性</strong></p><p>此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明</p><p>此外还有另一种制作<code>Handle class</code>的方法，就是令<code>Person</code>成为一个特殊的抽象基类，称为<code>Interface class</code>，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;<span class="comment">//Interface class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;<span class="comment">//具现化</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name...)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name...))</span></span>;</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span>: <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, ...): <span class="built_in">theName</span>(name), ...&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">  <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string theName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::string <span class="title">ReakPerson::name</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, ...)</span></span>&#123;</span><br><span class="line">  retrun std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, ...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六：继承与面向对象">六：继承与面向对象</h2><ul><li><code>is-a</code>：是一个</li><li><code>has-a</code>：有一个</li><li><code>is-implemented-in-terms-of</code>：根据xx实现出</li></ul><h3 id="public继承是is-a关系">public继承是is-a关系</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person&#123;...&#125;;<span class="comment">//Student is a Person</span></span><br></pre></td></tr></table></figure><p>每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化</p><p><strong>public继承下，可以把子类当父类用</strong>，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用</p><p>这就出现了一个问题，子类一定要<code>is a</code>父类，不然会出现问题</p><p>错误的继承：</p><ul><li>企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？</li><li>正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？</li></ul><h3 id="避免遮掩父类成员">避免遮掩父类成员</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<strong>作用域</strong>的<strong>名称遮掩规则</strong>，函数内部的local变量x覆盖了全局变量x</p><h4 id="子类名称会遮掩父类名称，在public继承下是错误的">子类名称会遮掩父类名称，在public继承下是错误的</h4><p>在OOP中，如果子类重载了父类的<code>non-virtual</code>函数，就意味着子类使用同名函数遮掩了父类函数，就意味着<strong>这个父类函数没有被子类继承！</strong>，那么在这种情况下，继承就不是<code>is-a</code>关系了</p><p><strong>在public继承下，子类继承了父类的一切</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">f1</span>();<span class="comment">//正确，调用Derived::f1</span></span><br><span class="line">d.<span class="built_in">f1</span>(x);<span class="comment">//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)</span></span><br><span class="line">d.<span class="built_in">f2</span>();<span class="comment">//正确，调用Derived::f2</span></span><br><span class="line">d.<span class="built_in">f2</span>(x);<span class="comment">//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)</span></span><br></pre></td></tr></table></figure><h4 id="将被遮掩的名称重见天日">将被遮掩的名称重见天日</h4><p>解决起来很简单，只需要让父类的函数在子类作用域内可见，可以<strong>使用using关键字</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::f1;</span><br><span class="line">    <span class="keyword">using</span> Base::f2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">f1</span>();<span class="comment">//正确，调用Derived::f1</span></span><br><span class="line">d.<span class="built_in">f1</span>(x);<span class="comment">//正确，调用Base::f1</span></span><br><span class="line">d.<span class="built_in">f2</span>();<span class="comment">//正确，调用Derived::f2</span></span><br><span class="line">d.<span class="built_in">f2</span>(x);<span class="comment">//正确，调用Base::f2</span></span><br></pre></td></tr></table></figure><p>如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以<strong>使用转交函数</strong>，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base::<span class="built_in">f1</span>();<span class="comment">//inline转交函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">f1</span>();<span class="comment">//正确，调用Derived::f1</span></span><br><span class="line">d.<span class="built_in">f1</span>(x);<span class="comment">//错误，因为Derived::f1遮掩了Base::f1</span></span><br></pre></td></tr></table></figure><h3 id="区分接口继承和实现继承">区分接口继承和实现继承</h3><p>public继承分为两个部分</p><ul><li>函数接口继承</li><li>函数实现继承</li></ul><table><thead><tr><th></th><th>接口继承</th><th>实现继承</th></tr></thead><tbody><tr><td>纯虚函数</td><td>具体指定</td><td>不继承</td></tr><tr><td>非纯虚函数</td><td>具体指定</td><td>继承一份缺省实现</td></tr><tr><td>non-virtual函数</td><td>具体指定</td><td>继承一份强制实现</td></tr></tbody></table><h3 id="考虑使用virtual以外的选择">考虑使用virtual以外的选择</h3><h4 id="基于NVI的Template-Method模式">基于NVI的Template Method模式</h4><p>Non-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>healthValue()</code>被称为virtual函数的<strong>外覆器（wrapper）</strong></p><h4 id="基于函数指针的Strategy模式">基于函数指针的Strategy模式</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: healthFunc(hcf)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种模式下，<code>defaultHealthCalc</code>函数不再是<code>GameCharacter</code>体系内的成员函数，通过修改函数指针，就可以让<code>GameCharacter</code>使用不同种类的计算函数，弹性更强，而且可以在运行时变更</p><p>此外<code>defaultHealthCalc</code>函数不需要/不能访问<code>GameCharacter</code>内的<code>non-public</code>部分，</p><h4 id="基于tr1-function的Strategy模式">基于tr1::function的Strategy模式</h4><p>上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如<code>tr1::function</code>对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::tr1::function&lt;<span class="type">int</span> (<span class="type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: healthFunc(hcf)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="古典的Strategy模式">古典的Strategy模式</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span></span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span>: pHealthFunc(phcf)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> phealthFunc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="绝不重新定义继承而来的non-virtual函数">绝不重新定义继承而来的non-virtual函数</h3><ul><li>静态绑定（staticcally bound）：non-virtual就是这种</li><li>动态绑定（dynamically bound）：virtual就是这种</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">D x;</span><br><span class="line">B* pB = &amp;x;</span><br><span class="line">D* pD = &amp;x;</span><br><span class="line">pB-&gt;<span class="built_in">f</span>();<span class="comment">//调用B::f</span></span><br><span class="line">pD-&gt;<span class="built_in">f</span>();<span class="comment">//调用D::f</span></span><br></pre></td></tr></table></figure><h3 id="绝对不重新定义继承而来的缺省参数值">绝对不重新定义继承而来的缺省参数值</h3><p><strong>virtual函数是动态绑定的，缺省参数值是静态绑定的</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cricle</span>: <span class="keyword">public</span> Shape&#123;...&#125;;</span><br><span class="line">...</span><br><span class="line">Shape* p1;<span class="comment">//p1的静态类型是Shape*，没有动态类型</span></span><br><span class="line">Shape* p2 = <span class="keyword">new</span> Circle;<span class="comment">//p2的静态类型是Shape*，动态类型是Circle*</span></span><br></pre></td></tr></table></figure><ul><li>静态类型<ul><li>指针的类型就是<strong>静态类型</strong></li></ul></li><li>动态类型<ul><li>所指向的对象的类型是<strong>动态类型</strong></li><li>动态类型可以通过赋值等操作改变</li></ul></li></ul><p>virtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载</p><p>但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数</p><h3 id="has-a和根据xx实现出">has-a和根据xx实现出</h3><p>一个类中有多个小类，这种关系被称为<strong>复合（composition）</strong>，其中这些小类被称为<strong>合成成分物（composed object）</strong></p><ul><li>在应用域，复合意味着<code>has-a</code><ul><li>人有名字（也不尽然）</li></ul></li><li>在实现域，复合意味着<code>is-implemented-in-terms-of</code><ul><li>队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）</li></ul></li></ul><h3 id="少用private继承">少用private继承</h3><p><em>经典 C++糟粕，请问 C#有这个吗？</em></p><p>本质上是一种<code>is-implemented-in-terms-of</code>关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术</p><ul><li>private继承，编译器无法自动将子类对象转化为父类对象</li><li>private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）</li></ul><p><strong>尽量使用复合来替代pirvate继承</strong>，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数</p><p>此外private继承的对象有可能比复合的对象要小</p><h3 id="少用多重继承">少用多重继承</h3><p><em>经典 C++糟粕，请问 C#有这个吗？</em></p><ul><li>可能会导致歧义<ul><li>当然你可以在调用函数的时候指出是来自哪一个基类</li></ul></li><li>可能会导致菱形继承<ul><li>菱形继承可能会导致变量重复</li></ul></li></ul><h2 id="七：模版与泛型">七：模版与泛型</h2><p>模板（templates）是泛型编程（generic programming）的基础</p><p>模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译</p><h3 id="评价">评价</h3><p>优点：</p><ol><li>模板编程能够实现非常灵活且类型安全的接口</li><li>极好的性能（更小的文件、更短的运行期，更少的内存需求）</li><li>可以将一些运行时才能侦测到的错误，在编译期找出来</li></ol><p>缺点：</p><ol><li>难以编程和维护</li><li>编译报错信息难以理解</li><li>难以重构</li><li>编译时间大幅变长</li></ol><p>因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释</p><h3 id="隐式接口和编译期多态">隐式接口和编译期多态</h3><ul><li>OOP中经常使用显式接口和运行时多态</li><li>泛型编程更多使用隐式接口和编译期多态</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget)&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span></span><br><span class="line"><span class="function">        temp.<span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组<strong>隐式接口</strong></p><p>所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功</p><p>这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是<strong>编译期多态</strong></p><h3 id="Traits">Traits</h3><p>一种约定俗成的技术方案，为同一类数据提供统一的操作函数</p><p>比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">    TYPE_1;</span><br><span class="line">    TYPE_2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FOO</span>&#123;</span><br><span class="line">    Type type = Type::TYPE_1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line">    Type type = Type::TYPE_2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//统一的模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(<span class="type">const</span> T&amp; data, <span class="type">char</span>* buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T::type == Type::TYPE_1)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T::type == Type::TYPE_2)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">    TYPE_1;</span><br><span class="line">    TYPE_2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FOO</span>&#123;</span><br><span class="line">    Type type = Type::TYPE_1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line">    Type type = Type::TYPE_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_traits</span>&#123;</span><br><span class="line">    Type type = T::type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为内置数据类型特化为独有的 type_traits</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_traits</span>&#123;</span><br><span class="line">    Type type = Type::TYPE_1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统一的模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(<span class="type">const</span> T&amp; data, <span class="type">char</span>* buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type_traits&lt;T&gt;::type == Type::TYPE_1)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type_traits&lt;T&gt;::type == Type::TYPE_2)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因</p><h3 id="模板元编程">模板元编程</h3><p>TMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化</p><p>如果一门语言具备以下功能，则称为图灵完全</p><ol><li>数值运算和符号运算</li><li>判断</li><li>递归</li></ol><h4 id="数值运算-递归">数值运算+递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个TMP计算阶乘，而且阶乘的技术发生在编译期</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11TMP这种函数式编程得到了加强，上文也可以这样写</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value&#123; n * Factorial&lt;n - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="判断">判断</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">if_constexpr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">if_constexpr</span>&lt;<span class="literal">false</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; if_constexpr&lt;<span class="literal">true</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; if_constexpr&lt;<span class="literal">false</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typedef">typedef</h3><p>在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名</p><p>下面是一个函数指针的示例</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x+y=&quot;</span> &lt;&lt; x + y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dec</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x-y=&quot;</span> &lt;&lt; x - y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x*y=&quot;</span> &lt;&lt; x*y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*op[<span class="number">3</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123; add, dec, mul &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        （*op[i])(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用typedef</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Func[<span class="number">3</span>])</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">Func f = &#123; add, dec, mul &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        f[i](<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八：定制new和delete">八：定制new和delete</h2><p>Java和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目</p><h3 id="new-handler">new-handler</h3><p>当<code>operator new</code>无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即<code>new-handler</code></p><p>使用<code>set_new_handler</code>来指定<code>new-handler</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;内存不足\n&quot;</span>;</span><br><span class="line">  std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::<span class="built_in">set_new_handler</span>(outOfMem);<span class="comment">//该函数的参数是一个函数指针</span></span><br><span class="line">  <span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10000000L</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>operator new</code>无法满足内存申请时，会不断调用<code>new-handler</code>函数，直到找到足够的内存，所以<code>new-handler</code>函数应该满足</p><ul><li>让更多的内存可被使用<ul><li>实现方法是程序开始时就分配一大块内存，每次调用<code>new-handler</code>时就释放一点点</li></ul></li><li>安装另一个<code>new-handler</code><ul><li>如果现在这个<code>new-handler</code>无法获取更多内存，需要知道哪一个<code>new-handler</code>具备增大内存的实力，然后使用<code>set_new_handler</code>来替换自己</li></ul></li><li>卸除<code>new-handler</code><ul><li>通过<code>set_new_handler</code>赋值<code>null</code>，将<code>new-handler</code>卸载，使得在内存分配不足时，会抛异常</li></ul></li><li>抛出<code>bad_alloc</code>异常<ul><li>这种异常不会被<code>operator new</code>捕获，会被传播至内存索求处</li></ul></li><li>不反回<ul><li>调用<code>abort</code>或者<code>exit</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerHolder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span>: handler(nh) &#123;</span>&#125;<span class="comment">//获取当前的new_handler</span></span><br><span class="line">  ~<span class="built_in">NewHandlerHolder</span>() &#123; std::<span class="built_in">set_new_handler</span>(handler); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::new_handler handler;<span class="comment">//用于记录当前的new_handler</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>&#123;</span><br><span class="line">  <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;<span class="comment">//安装Widget的new-handler</span></span><br><span class="line">  <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);<span class="comment">//分配对象或者抛异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;</span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(outOfMem);</span><br><span class="line">Widget* pwl = <span class="keyword">new</span> Widget;<span class="comment">//内存不足时会调用outOfMem</span></span><br></pre></td></tr></table></figure><p>mixin风格的写法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> std::new_handler_set <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">throw</span>()&#123;</span><br><span class="line">  std::new_handler oldHandler = currentHandler;</span><br><span class="line">  currentHandler = p;</span><br><span class="line">  <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>&#123;</span><br><span class="line">  <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt;&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为<strong>怪异的循环模版模式（curiously recurring template pattern，CRTP）</strong></p><h3 id="替换new和delete的时机">替换new和delete的时机</h3><p>C++中所有的news返回的指针都必须要<strong>地址对齐</strong>，int要4对齐，double要8对齐</p><p>写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换</p><h3 id="编写new和delete的规则">编写new和delete的规则</h3><p>如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则</p><ul><li><p>new</p><ul><li>应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用<code>new-handler</code></li><li>有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）</li><li>new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理<strong>比正确大小更大的（错误）申请</strong></li></ul></li><li><p>delete</p><ul><li>收到null指针时不做任何事</li><li>处理<strong>比正确大小更大的（错误）申请</strong></li></ul></li></ul><h3 id="编写new时也要写对应的delete">编写new时也要写对应的delete</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget* pw = <span class="keyword">new</span> Widget;</span><br></pre></td></tr></table></figure><p>在这里调用了两个函数，一个时用以分配内存的<code>operator new</code>，一个是<code>Widget</code>的构造函数</p><p>如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的</p><p>运行时系统会调用<code>operator new</code>所对应的<code>operator delete</code>来释放地址，对于拥有正常签名式的new和delete来说不成问题</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;<span class="comment">//普通的new</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//global中的普通的new</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory, std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//class中的new</span></span><br></pre></td></tr></table></figure><p>但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//placement new，比普通new多带一个参数</span></span><br><span class="line"></span><br><span class="line">Widget* pw = <span class="built_in">new</span> (std::cerr) Widget;<span class="comment">//调用operator new，并以cerr作为其实参</span></span><br></pre></td></tr></table></figure><p>当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的<code>operator new</code>时如何运作的，所以运行时系统会去寻找<strong>参数个数与类型</strong>都与<code>operator new</code>相同的某个<code>operator delete</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*, std::ostream&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//palcement delete</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemoty, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果此时调用<code>delete pw</code>，只会调用普通的<code>delete</code>，因为只有在构造时发生异常时，运行时系统才会调用placement delete</p><p>最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete</p><h2 id="九：杂项">九：杂项</h2><h3 id="不要忽视编译器警告">不要忽视编译器警告</h3><p>很多人忽视警告，毕竟一个问题如果真的很严重，应该报错</p><p>比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>报警告</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">warning: D::<span class="built_in">f</span>() <span class="function">hides <span class="keyword">virtual</span> <span class="title">B::f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>原本的目的是为了在D中重新定义virtual函数<code>f()</code>，但由于B中<code>f()</code>是const，在D中不是，此时B中的<code>f()</code>并没有在D中重新被声明，而是被整个遮掩了</p><h3 id="去熟悉标准程序库">去熟悉标准程序库</h3><p>尤其是TR1</p><h4 id="C-98有什么">C++98有什么</h4><ul><li>STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器</li><li>Iostream</li><li>国际化支持</li><li>数值处理，包括复数（complex）和纯数值数组（valarray）</li><li>异常阶层体系</li><li>C89标准程序库</li></ul><h4 id="TR1有什么（全在std-tr1中）">TR1有什么（全在<code>std::tr1</code>中）</h4><ul><li>智能指针<code>tr1::shared_ptr</code>和<code>tr1::weak_ptr</code></li><li><code>tr1::function</code></li><li><code>tr1::bind</code></li></ul><p>和（彼此无关的独立组件）</p><ul><li>哈希表</li><li>正则表达式</li><li>Tuple变量组</li><li><code>tr1::array</code></li><li><code>tr1::mem_fn</code></li><li><code>tr1::reference_wrapper</code></li><li>随机数生成工具</li><li>数学特殊函数</li><li>C99兼容</li></ul><p>和（基于template）</p><ul><li>Type traits</li><li><code>tr1::result_of</code></li></ul><h3 id="熟悉Boost">熟悉Boost</h3>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CXX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu入门</title>
      <link href="/program/Ubuntu%E5%85%A5%E9%97%A8/"/>
      <url>/program/Ubuntu%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>Ubuntu入门</h1><p>你可以使用neofetch查看系统信息，我这里是一台WSL2</p><p><img src="/images/neofetch.png" class="lazyload" data-srcset="/images/neofetch.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="neofetch"></p><p>无头环境（Headless Environment）是指没有GUI的计算环境</p><h2 id="常用快捷键">常用快捷键</h2><table><thead><tr><th>快捷键</th><th>意义</th></tr></thead><tbody><tr><td>ctrl+C</td><td>关掉当前运行的程序</td></tr><tr><td>ctrl+R</td><td>搜索过去运行过的命令</td></tr></tbody></table><h2 id="常用命令">常用命令</h2><table><thead><tr><th>命令</th><th>意义</th><th></th></tr></thead><tbody><tr><td>ls -a</td><td>查看当前目录内容</td><td>`ls -l</td></tr><tr><td>cd 路径名</td><td>路径跳转</td><td></td></tr><tr><td>clear</td><td>清空窗口</td><td></td></tr><tr><td>find 文件名</td><td>找出当前文件夹内符合条件的文件</td><td>支持正则</td></tr><tr><td>whoami</td><td>查看当前用户身份</td><td></td></tr><tr><td>pwd</td><td>查看当前工作目录</td><td></td></tr><tr><td>cat test.txt</td><td>查看文件内容</td><td></td></tr><tr><td>cat &gt; new.txt</td><td>新建文件</td><td></td></tr><tr><td>cat file1 file2 &gt; file</td><td>合并文件</td><td></td></tr><tr><td>mkdir 文件夹名</td><td>创建文件夹</td><td>-p可以创建多级文件夹</td></tr><tr><td>cp src dst</td><td>复制文件</td><td></td></tr><tr><td>kill 进程名</td><td>杀死进程</td><td></td></tr><tr><td>unzip</td><td>解压zip文件</td><td>需要先安装unzip</td></tr><tr><td>rm test.txt</td><td>删除文件</td><td>-r递归删文件夹 -f强删</td></tr><tr><td>nvidia-smi</td><td>查看当前N卡驱动</td><td></td></tr><tr><td>echo &lt;变量名称&gt;</td><td>打印一个变量</td><td>echo $xxx 打印环境变量</td></tr><tr><td>eval $(命令内容)</td><td>执行一个命令</td><td>可以传入很多参数</td></tr><tr><td>bash &lt;程序名称&gt;</td><td>用bash执行一个程序</td><td>可以再前面加一些临时的变量，如venv_dir=- bash ./webui.sh</td></tr><tr><td>chmod u+x &lt;文件名&gt;</td><td>给文件持有者添加执行权限</td><td>也有数字模式，比如chmod 777 &lt;文件名&gt;</td></tr><tr><td>curl  &lt;链接&gt;</td><td>访问一个链接</td><td>使用-X POST可以用POST请求类型，使用-v可以显示详细信息</td></tr><tr><td>export no_proxy=“$no_proxy, x.x.x.x”</td><td>对某个链接关闭代理</td><td>修改后存储在~/.bashrc中</td></tr><tr><td>source ~/.bashrc</td><td>让shell读取并执行脚本</td><td>这里作用是立刻应用之前对~/.bashrc的修改</td></tr><tr><td>df -h /</td><td>查看磁盘剩余空间</td><td></td></tr><tr><td>head -n 1 &lt;文件名&gt;</td><td>打印文件第一行的内容</td><td>查看一些巨大的jsonl的格式很有用</td></tr><tr><td>ps -ux</td><td>查看后台进程</td><td></td></tr><tr><td>kill &lt;PID&gt;</td><td>删掉某个进程</td><td></td></tr><tr><td>tail -f 1.txt</td><td>实时监控某个文件的变化</td><td></td></tr><tr><td>du -h</td><td>查看当前目录磁盘占用</td><td>du -h --max-depth=1 只看深度为1</td></tr></tbody></table><h3 id="后台命令">后台命令</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">python test.py &gt; output.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"><span class="comment"># 监控log</span></span><br><span class="line">tail -f output.txt</span><br><span class="line"><span class="comment"># 查看后台</span></span><br><span class="line">ps -ux</span><br><span class="line"><span class="comment"># 删掉对应进程</span></span><br><span class="line">kill &lt;PID&gt;</span><br></pre></td></tr></table></figure><h2 id="文件访问">文件访问</h2><p>Windows访问Linux文件，路径为<code>\\wsl$\Ubuntu-20.04\home\username</code></p><p>Linux访问Windows文件，路径为<code>/mnt/c/Users/username</code></p><p>在本地和远端服务器通过SSH传递文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp &lt;<span class="built_in">local</span> path&gt; xxx.com:/xxx</span><br></pre></td></tr></table></figure><h2 id="常用软件">常用软件</h2><h3 id="apt-get">apt-get</h3><p>Linux内置的包管理器，可以非常优雅地安装管理各种包、软件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装git</span></span><br><span class="line">sudo apt-get install git</span><br><span class="line"><span class="comment"># 安装tbb</span></span><br><span class="line">sudo apt-get install libtbb-dev</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有已安装软件（这个信息量巨大，而且有重复信息，不简易使用）</span></span><br><span class="line"><span class="variable">$sudo</span> apt-cache search all</span><br><span class="line"><span class="comment"># 查看所有已安装软件（去重）</span></span><br><span class="line"><span class="variable">$sudo</span> apt-cache search all | <span class="built_in">wc</span></span><br><span class="line"><span class="comment">#查看所有名字中带gcc的软件</span></span><br><span class="line"><span class="variable">$sudo</span> apt-cache search all | grep gcc</span><br></pre></td></tr></table></figure><p>如果遇到报错：“E: Unable to locate package”，可以执行一次更新</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="VS-Code">VS Code</h3><ol><li>在Windows系统中安装VS Code，并选择添加PATH</li><li>在WSL中如果要打开当前目录，直接输入</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$code</span> .</span><br></pre></td></tr></table></figure><p>推荐安装VS Code的WSL插件</p><p>使用快捷键<code>CTRL+SHIFT+P</code>，打开命令面板，键入<code>WSL</code>，进行一些设置</p><h3 id="C">C++</h3><table><thead><tr><th>包名</th><th>描述</th></tr></thead><tbody><tr><td>g++</td><td>C++编译器</td></tr><tr><td>libtbb-dev</td><td>tbb并行库</td></tr><tr><td>cmake</td><td>项目构建</td></tr><tr><td>git</td><td>版本管理</td></tr><tr><td>gfortran</td><td>fortran编译器</td></tr><tr><td>liblapack-dev、liblapacke-dev</td><td>BLAS和LAPACK线代库</td></tr><tr><td>gdb</td><td>调试器</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="Git">Git</h3><h4 id="配置">配置</h4><p>使用Git前需要先配置git config，可以输命令，也可以无脑用vscode改<code>.gitconfig</code>文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail@domain.com&quot;</span></span><br></pre></td></tr></table></figure><h4 id="生成SSH公钥">生成SSH公钥</h4><p>SSH公钥对Linux很重要，比如SSH连接、Git都会用到</p><p>生成方法很简单，生成后你可以将<code>.ssh/id_rsa.pub</code>的内容拷贝到需要密钥的网站</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &lt;邮箱&gt;</span><br></pre></td></tr></table></figure><h4 id="拉取项目">拉取项目</h4><p>项目拉取有两种常见方法</p><ul><li><p>ssh：需要配置SSH Key，只能拉自己的项目，但不提交时不需要账号密码</p></li><li><p>https：非常方便，只需要git clone，而且可以拉别人的项目，但提交时需要输入账号密码</p><ul><li>其实你也可以在输入一次密码后输入</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>我们这里说的密码是token，可以去<a href="https://github.com/settings/tokens">Github</a>生成token</p><h4 id="提交">提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加要提交的内容</span></span><br><span class="line">git add &lt;文件名/文件夹名&gt;</span><br><span class="line"><span class="comment"># 提交所有内容（不包含忽略文件），并设置提交信息为“这是一段话”</span></span><br><span class="line">git commit -a -m &lt;信息&gt;</span><br></pre></td></tr></table></figure><h4 id="分支">分支</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 展示所有分支</span></span><br><span class="line">git branch -a</span><br><span class="line"><span class="comment"># 切分支</span></span><br><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="Tmux">Tmux</h3><p>经常使用Windows系统的同学，直接使用Linux会感觉我好像一次只能干一件事（尤其是你运行了一个Web后端），因为Windows所有窗口都是一个个单独的进程，UI和逻辑也是多线程，于是我们可以轻松在多个<strong>前台</strong>任务中切换</p><p>其实Linux也是一个多线程多进程的操作系统，我们也可以同时执行多个前台任务，使用的就是Tmux</p><p>你可以认为Tmux就是一个个窗口，你可以打开、挂起、恢复窗口，你可以开一个窗口用于开Web后端，然后开另一个窗口做其他事情</p><h4 id="命令">命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 展示当前所有的窗口</span></span><br><span class="line">tmux <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 杀掉某个窗口</span></span><br><span class="line">tmux kill-window -t &lt;窗口编号&gt;</span><br><span class="line"><span class="comment"># 新建某个窗口</span></span><br><span class="line">tmux newn -s &lt;session名称&gt;</span><br><span class="line"><span class="comment"># 挂起，窗口内的程序会继续运行，直接关窗口也是这样</span></span><br><span class="line">tmux detach</span><br><span class="line"><span class="comment"># 打开最近一个窗口</span></span><br><span class="line">tmux a</span><br><span class="line"><span class="comment"># 关闭当前窗口</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h4 id="快捷键">快捷键</h4><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>ctrl+B</td><td>进入命令模式</td></tr><tr><td>shift+’</td><td>创建一个split窗口</td></tr><tr><td>命令模式+ C</td><td>创建一个新的窗口</td></tr><tr><td>命令模式下 + D</td><td>挂起当前窗口</td></tr><tr><td>命令模式下 + [</td><td>开启上下滚动模式（可以看之前的命令行输出，按ctrl+C退出）</td></tr><tr><td>命令模式下 + /</td><td>搜索内容，按n匹配下一个</td></tr><tr><td>命令模式下 + x + y</td><td>强制退出tmux窗口</td></tr><tr><td>命令模式下 + p</td><td>回到上一个tmux窗口</td></tr></tbody></table><h3 id="Pip">Pip</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载包</span></span><br><span class="line">pip install &lt;包名&gt;</span><br><span class="line"><span class="comment"># 查看是否有某个包</span></span><br><span class="line">pip show &lt;包名&gt;</span><br><span class="line"><span class="comment"># 查看某个包的版本</span></span><br><span class="line">pip list | grep &lt;包名&gt;</span><br></pre></td></tr></table></figure><h3 id="Anaconda3">Anaconda3</h3><p>非常好用的Python环境管理工具，你可以创建多个虚拟Python环境，不用再考虑版本问题了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个环境，python版本指定为3.10</span></span><br><span class="line">conda create -n &lt;环境名&gt; python=3.10 pip</span><br><span class="line"><span class="comment"># 切换环境，成功切换后bash左侧会有一个(环境名)</span></span><br><span class="line">conda activate &lt;环境名&gt;</span><br><span class="line"><span class="comment"># 删除环境</span></span><br><span class="line">conda remove -name &lt;环境名&gt; --all</span><br><span class="line"><span class="comment"># 查看所有环境</span></span><br><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure><h3 id="SSH">SSH</h3><p>我们经常使用SSH连接其他远程主机，但SSH经常会断掉，其实我们只需要在config里加一个参数，即可让SSH连接定时发送一段空数据包，以实现维持连接的效果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host xxx.com</span><br><span class="line">  ServerAliveInterval 40</span><br></pre></td></tr></table></figure><h3 id="压缩软件">压缩软件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压 xxx.tar.xz</span></span><br><span class="line">tar -xf xxx.tar.xz</span><br><span class="line">tar -xf xxx.tar -C output_folder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压 xxx.zip</span></span><br><span class="line">unzip xxx.zip </span><br></pre></td></tr></table></figure><h3 id="CUDA">CUDA</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看cuda版本</span></span><br><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
