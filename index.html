<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ReubenSun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Reuben的笔记博客">
<meta property="og:type" content="website">
<meta property="og:title" content="ReubenSun">
<meta property="og:url" content="http://reuben-sun.github.io/index.html">
<meta property="og:site_name" content="ReubenSun">
<meta property="og:description" content="Reuben的笔记博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Reuben Sun">
<meta property="article:tag" content="reubensun computer graphics engine Technical Artist">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="ReubenSun" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ReubenSun</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://reuben-sun.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-optics/光学复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/26/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time datetime="2023-02-26T10:01:25.000Z" itemprop="datePublished">2023-02-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/optics/">optics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/26/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/">光学复习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>光学复习</h1>
<ul>
<li>[ ] 相速度</li>
<li>[ ] 偏振态</li>
<li>[x] 费马原理</li>
<li>[ ] 横向放大率</li>
<li>[ ] 薄透镜成像</li>
<li>[ ] 透镜组成像（做图法）</li>
<li>[ ] 反射过程中的相移</li>
<li>[ ] 布鲁斯特角</li>
<li>[ ] 反射光与折射光的偏振态</li>
<li>[x] 全反射</li>
<li>[x] 相干条件</li>
<li>[x] 杨氏双缝干涉</li>
<li>[ ] 时间、空间相干性</li>
<li>[ ] 等倾干涉</li>
<li>[ ] 等厚干涉</li>
<li>[ ] 迈克尔逊干涉仪</li>
<li>[ ] 多光束干涉</li>
<li>[ ] 增反膜与增透膜</li>
<li>[ ] 惠更斯-菲涅尔原理</li>
<li>[ ] 衍射的分类</li>
<li>[ ] 衍射与傅立叶变换</li>
<li>[ ] 单缝衍射</li>
<li>[ ] 圆孔衍射</li>
<li>[ ] Airy斑</li>
<li>[ ] 瑞丽判据</li>
<li>[ ] 多缝衍射</li>
<li>[ ] 光栅方程</li>
<li>[ ] Abbe成像原理</li>
<li>[ ] 最小分辨距离、角度</li>
<li>[ ] 光栅</li>
<li>[ ] 双折射</li>
<li>[ ] 惠更斯作图法</li>
<li>[ ] 波片</li>
<li>[ ] 光偏振态的改变与检测</li>
<li>[ ] 黑体辐射与光量子</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/26/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/" data-id="clepy40oq001qglnk9qd62qhv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%89%E5%AD%A6/" rel="tag">光学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-optics/衍射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/25/optics/%E8%A1%8D%E5%B0%84/" class="article-date">
  <time datetime="2023-02-25T10:10:25.000Z" itemprop="datePublished">2023-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/optics/">optics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/25/optics/%E8%A1%8D%E5%B0%84/">衍射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>七：衍射</h1>
<h2 id="内容概述">内容概述</h2>
<ul>
<li>衍射（Diffraction），光在传播途中偏移直线传播，强度重新分布的过程</li>
<li>惠更斯-菲涅尔原理</li>
<li>定量分析衍射</li>
<li>统一衍射和直线传播</li>
</ul>
<h2 id="衍射">衍射</h2>
<p>衍射是光在传播途中偏移直线传播，强度重新分布的过程</p>
<blockquote>
<p>物体遮挡光线，就会产生阴影</p>
<p>在几何光学中，光线只会被完全遮挡/完全不遮挡，因此阴影应该是清晰的</p>
<p>但现实中的阴影是软阴影，其实就是发生了衍射</p>
</blockquote>
<img src="../../images/光的衍射.png" alt="光的衍射" style="zoom:50%;" />
<p>一组平行的波阵面通过小孔，会变成圆形</p>
<img src="../../images/衍射.png" alt="衍射" style="zoom:50%;" />
<p>波长越长，越容易观测到衍射</p>
<ul>
<li>小孔尺寸在波长的1000倍左右时衍射现象不明显</li>
<li>小孔尺寸在波长的10倍左右时衍射十分明显</li>
<li>小孔尺寸和波场相近时会发生散射</li>
</ul>
<h3 id="衍射的分类">衍射的分类</h3>
<ul>
<li>菲尼尔衍射：光源和接收屏距离有限</li>
<li>夫朗禾费衍射：光源和接收屏距离无限（也就是入射光是平行光）</li>
</ul>
<p>夫朗禾费衍射需要用透镜将平行光汇聚</p>
<h3 id="干涉与衍射的关系">干涉与衍射的关系</h3>
<p>相同：</p>
<ul>
<li>干涉和衍射都是相干叠加</li>
</ul>
<p>不同：</p>
<ul>
<li>干涉是离散点光源叠加求和，衍射是连续次波源叠加积分</li>
<li>干涉满足几何光学规律，衍射不满足几何光学规律</li>
</ul>
<h2 id="惠更斯-菲涅尔原理">惠更斯-菲涅尔原理</h2>
<h3 id="惠更斯">惠更斯</h3>
<p>惠更斯：波阵面上每一个点，本质上是一个球面次级小波的发射源，下一个波阵面实际上是这些球面的包络线（envelope）</p>
<img src="../../images/惠更斯原理.png" alt="惠更斯原理" style="zoom: 33%;" />
<p>理论的作用</p>
<ul>
<li>根据这个理论，给定一个波阵面，我们可以画出下一个波阵面</li>
<li>解释了光在各向同性介质中的传播原理</li>
<li>解释了反射和折射公式</li>
</ul>
<p>局限性</p>
<ul>
<li>无法区分光沿直线传播和发生衍射的条件</li>
<li>无法定量分析衍射强度</li>
<li>根据该理论，应该会有反转波</li>
</ul>
<h3 id="菲涅尔">菲涅尔</h3>
<p>菲涅尔修正了惠更斯的理论</p>
<ul>
<li>波阵面上每一个（无阻塞）点都是球面波的发射源，频率与主波相同</li>
<li>不在波阵面上的点，都是由小波相干叠加得到的</li>
</ul>
<p><strong>衍射是无数干涉的叠加</strong></p>
<h4 id="倾斜因子">倾斜因子</h4>
<p>惠更斯的理论会应该会存在向后的波，菲涅尔引入了倾斜因子（Tilt factor）<br>
$$<br>
F(\theta_0, \theta)=\frac{1}{2}(\cos\theta_0+\cos \theta)<br>
$$<br>
<img src="../../images/倾斜因子.png" alt="倾斜因子" style="zoom:50%;" /></p>
<p>倾斜因子的引入使得向后的波强度为0，自然就不会出现反转波</p>
<p>不过倾斜因子的引入是纯经验，这也是菲涅尔理论的局限性</p>
<h3 id="基尔霍夫积分定律">基尔霍夫积分定律</h3>
<p>基尔霍夫在倾斜因子的基础上添加了一个常数K，提供了一个$-\pi/2$的相位差<br>
$$<br>
K=\frac{e^{-i\pi/2}}{\lambda}<br>
$$<br>
于是衍射积分公式转化为：</p>
<img src="../../images/基尔霍夫求解波动方程.png" alt="基尔霍夫求解波动方程" style="zoom:50%;" />
<h2 id="巴俾涅原理">巴俾涅原理</h2>
<h2 id="傅立叶变换">傅立叶变换</h2>
<h2 id="正弦光栅衍射">正弦光栅衍射</h2>
<h2 id="单缝夫琅禾费衍射">单缝夫琅禾费衍射</h2>
<h2 id="小孔夫琅禾费衍射">小孔夫琅禾费衍射</h2>
<h2 id="多缝衍射">多缝衍射</h2>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/25/optics/%E8%A1%8D%E5%B0%84/" data-id="clepy40ow0026glnk04qd7akj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%89%E5%AD%A6/" rel="tag">光学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-optics/干涉" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/25/optics/%E5%B9%B2%E6%B6%89/" class="article-date">
  <time datetime="2023-02-25T10:01:25.000Z" itemprop="datePublished">2023-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/optics/">optics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/25/optics/%E5%B9%B2%E6%B6%89/">干涉</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>六：干涉</h1>
<h2 id="内容概述">内容概述</h2>
<ul>
<li>干涉（Interference），光的叠加不满足线性叠加，证明了光的波性</li>
<li>干涉条件</li>
<li>干涉方法与装置</li>
<li>干涉仪</li>
</ul>
<h2 id="干涉">干涉</h2>
<p>干涉让光学从线性光学变成非线性光学</p>
<h3 id="线性光学">线性光学</h3>
<p>在几何光学中，我们认为光是独立传播的</p>
<p>光是一种横波，光在介质中传播会引起介质粒子振动，若独立传播成立，那么两束光的交叉区域，粒子的振动是两个振动的叠加，这就是<strong>叠加原理</strong></p>
<p>光的叠加实际上是介质的性质（因为描述的是介质粒子振动的叠加）</p>
<ul>
<li>线性介质：在该介质中，波满足叠加原理</li>
<li>非线性介质：在该介质中，波不满足叠加原理</li>
</ul>
<p>违反叠加原理的介质是非线性介质，现象是非线性现象，学科是非线性光学</p>
<p>此外，叠加原理只有在低强度光下才成立，因此激光发明后，非线性光学才蓬勃发展</p>
<h3 id="复振幅叠加法">复振幅叠加法</h3>
<p>求解相干光强有三种方法，实际分析时通常使用复振幅法</p>
<ul>
<li>三角函数法：波可以由三角函数表示，对三角函数做恒等变化，即可求相干光强</li>
<li>矢量图解法</li>
<li>复振幅法</li>
</ul>
<p>首先将三角函数表示为复振幅<br>
$$<br>
\tilde{\mathbf{E}_i}=\mathbf{A}_i e^{i\varphi <em>i}<br>
$$<br>
复振幅的叠加<br>
$$<br>
\tilde{\mathbf{E}}=\sum</em>{i=1}^n\tilde{\mathbf{E}_i}<br>
$$<br>
合光强<br>
$$<br>
I = \tilde{\mathbf{E}}\cdot \tilde{\mathbf{E}}^*<br>
$$</p>
<h3 id="相干叠加">相干叠加</h3>
<p>现在有两个相同频率（frequency）相同偏振（polarization）的光波，下面是他们电场强度随时间的变化（用复数表示三角函数）<br>
$$<br>
\mathbf{E_1}=\mathbf{A_1} e^{i(kr_1-\omega t+\varphi _{01})}<br>
$$</p>
<p>$$<br>
\mathbf{E_2}=\mathbf{A_2} e^{i(kr_2-\omega t+\varphi _{02})}<br>
$$</p>
<p>他们相交于点P，根据叠加原理，P点点电场强度为<br>
$$<br>
\mathbf{E}=\mathbf{E_1}+\mathbf{E_2}=[\mathbf{A_1}e^{i(kr_1+\varphi_{01})} + \mathbf{A_2}e^{i(kr_2+\varphi_{02})}]e^{-i\omega t}<br>
$$<br>
显然，振幅为<br>
$$<br>
\tilde{\mathbf{E}}=\mathbf{A_1}e^{i(kr_1+\varphi_{01})} + \mathbf{A_2}e^{i(kr_2+\varphi_{02})}<br>
$$<br>
由于光过于高频，我们没法实时进行光电场强度的检测，于是我们使用光强（intensity，$I$）来进行推导</p>
<p>$$<br>
I \propto \tilde{\mathbf{E}}\cdot \tilde{\mathbf{E}}^*=\mathbf{A_1}^2+\mathbf{A_2}^2+2\mathbf{A_1A_2}\cos(kr_1-kr_2+\varphi_{01}-\varphi_{02})<br>
$$</p>
<p>$$<br>
I = I_1+ I_2 + 2\sqrt{I_1I_2}\cos \delta<br>
$$</p>
<p>$$<br>
\delta=kr_1-kr_2+\varphi_{01}-\varphi_{02}<br>
$$</p>
<p>我们发现，两个光波进行叠加，光强不只是简单叠加，还有一个尾巴，这个尾巴就是<strong>干涉</strong></p>
<p>干涉：因波的叠加引起强度重新分布的现象</p>
<p>并且我们发现：</p>
<ul>
<li>
<p>干涉强度与时间无关，与空间位置有关，且保持不变</p>
</li>
<li>
<p>当$\delta=2m\pi$，干涉强度最大，我们称之为构造干涉（constructive interference）</p>
</li>
</ul>
<p>$$<br>
I=(\mathbf{A_1}+\mathbf{A_2})^2<br>
$$</p>
<ul>
<li>当$\delta=(2m+1)\pi$，干涉强度最小，我们称之为相消干涉（destructive interference）</li>
</ul>
<p>$$<br>
I=(\mathbf{A_1}-\mathbf{A_2})^2<br>
$$</p>
<h3 id="非相干叠加">非相干叠加</h3>
<p>一般而言，两个光频率和偏振不一样，经过推导<br>
$$<br>
I_{12}=2\mathbf{A_1}\cdot \mathbf{A_2} \cos [(\omega_2 - \omega_1)t + \theta_1 - \theta_2]<br>
$$<br>
我们到处干涉强度为0的条件</p>
<ul>
<li>两个光频率不同，$\cos[…]$的均值为0</li>
<li>两个光光矢量垂直，$\mathbf{A_1}\cdot \mathbf{A_2}=0$</li>
<li>两个光夹角（相位差）迅速且无序变化，$\cos[…]$的均值为0</li>
</ul>
<h3 id="干涉条件">干涉条件</h3>
<p>因此我们总结出发生干涉的条件</p>
<ul>
<li>频率相同</li>
<li>相同的平行分量</li>
<li>固定的相位差</li>
</ul>
<p>如果不满足干涉条件，那么平均下来<br>
$$<br>
I=I_1+I_2<br>
$$</p>
<h2 id="获得干涉光">获得干涉光</h2>
<p>普通光源：普通光源的发光单位为原子、分子，不同原子间的发光是独立的，他们的频率、偏振、相位都是不同的，因此他们的光是不会发生干涉的</p>
<p>使用杨氏干涉实验、菲涅尔双棱镜、劳埃德镜可以将普通光源变成干涉光</p>
<p><img src="../../images/%E6%99%AE%E9%80%9A%E5%85%89%E6%BA%90%E7%9B%B8%E5%B9%B2%E5%85%89.png" alt="普通光源相干光"></p>
<h3 id="杨氏双缝干涉实验">杨氏双缝干涉实验</h3>
<p>杨氏实验是通过两个点波光源进行干涉实验的典型</p>
<p>如果光是一种波，那么光在传播过程中应该会有波前（传播最靠前的波阵面），提取一个波前，并将其分为两部分，就能得到两个相干光</p>
<p>现在有一个非常窄的单色光源，经过两个带缝平面，会生成两个相干光，进而发生衍射现象，在平面留下明暗条纹</p>
<p><img src="../../images/%E6%9D%A8%E6%B0%8F%E5%8F%8C%E7%BC%9D%E5%B9%B2%E6%B6%89.png" alt="杨氏双缝干涉"></p>
<p>$$<br>
I=4I_1\cos^2\frac{\pi \Delta}{\lambda}<br>
$$</p>
<ul>
<li>若$\Delta=m\lambda, I=I_{max}=4I_1$，呈现亮条纹</li>
<li>若$\Delta=(2m-1)\lambda/2, I=I_{min}=0$，呈现暗条纹</li>
</ul>
<img src="../../images/杨氏干涉.png" alt="杨氏干涉" style="zoom: 50%;" />
<p>当间距不大时，角度比较小，缝间距是相同的，间距为<br>
$$<br>
\Delta x=\frac{D}{d}\lambda<br>
$$<br>
如果传入的是白光，条纹将为彩色</p>
<img src="../../images/杨氏干涉彩色条纹.png" alt="杨氏干涉彩色条纹" style="zoom:50%;" />
<h3 id="其他干涉仪器">其他干涉仪器</h3>
<p>本质都是杨氏双缝干涉，条纹间距都满足<br>
$$<br>
\Delta x=\frac{D}{d}\lambda<br>
$$</p>
<h4 id="菲涅尔双平面镜">菲涅尔双平面镜</h4>
<img src="../../images/菲尼尔双平面镜.png" alt="菲尼尔双平面镜" style="zoom:50%;" />
<h4 id="劳埃德镜">劳埃德镜</h4>
<img src="../../images/劳埃德镜.png" alt="劳埃德镜" style="zoom:67%;" />
<h4 id="菲涅尔双棱镜">菲涅尔双棱镜</h4>
<img src="../../images/菲涅尔双棱镜.png" alt="菲涅尔双棱镜" style="zoom:50%;" />
<h3 id="干涉条纹的移动">干涉条纹的移动</h3>
<p>我们不仅观测到明暗条纹，还观测到条纹的移动和变化</p>
<ul>
<li>
<p>移动光源，对于屏幕上一点，求多少个条纹经过该点</p>
<ul>
<li>对于屏幕上点P，经过点P的条纹数取决于两条相干光线的光程差（OPL）</li>
<li>当光程差增减一个$\lambda$时，就会经过一条条纹</li>
</ul>
</li>
<li>
<p>移动光源，对于特定的一个条纹，求其移动了多长距离</p>
<ul>
<li>杨氏双缝中</li>
</ul>
</li>
</ul>
<p>$$<br>
\delta x = -\frac{D}{R}\delta s<br>
$$</p>
<img src="../../images/条纹移动.png" alt="条纹移动" style="zoom:50%;" />
<h2 id="时空相干性">时空相干性</h2>
<p>现实中的普通光源的发光单元为原子、分子，靠自发辐射发光（激光光源靠受激辐射），这是一个随机过程，产生的光是随机、无规律、不相干的。看起来我们无法用普通光源做干涉实验，但实际上杨氏双缝是可以使用普通光源的，因为杨氏双缝中两个光都是由同一束光分割而成的</p>
<p>尽管普通光源的相位随机，但是杨氏双缝两束光的相位差与原光源相位无关，仅与空间位置有关</p>
<p>不过，光源的尺寸和光谱尺寸仍然会对杨氏干涉产生影响</p>
<p>在杨氏干涉中，我们使用了很窄的单色光源，然而现实中光源总是有尺寸，其颜色也不是单色而是光谱中一小段</p>
<p>空间相干性：光源尺寸对干涉强度的影响</p>
<p>时间相干性：光谱尺寸对干涉强度的影响（也就是说光不是真的纯色）</p>
<h3 id="空间相干性">空间相干性</h3>
<p>干涉条纹的衬比度（constrast）定义为<br>
$$<br>
\gamma = \frac{I_\max-I_\min}{I_\max + I_\min}<br>
$$<br>
任何光源都有一定的宽度，我们将其视为多个不相干的点光源排布，屏幕上的总强度为各个光源的干涉条纹的线性叠加</p>
<p>我们发现沿着x轴方向的长度会让条纹模糊</p>
<p>沿着y轴方向的长度会让亮纹和亮纹重叠，于是条纹更清晰</p>
<p>我们在做杨氏双缝时常常使用平行于y轴方向的光</p>
<img src="../../images/光源宽度.png" alt="光源宽度" style="zoom:50%;" />
<h3 id="时间相干性">时间相干性</h3>
<h2 id="薄膜干涉">薄膜干涉</h2>
<p>薄膜干涉（Thin film interference）：光在薄膜表面发生反射和折射，反射光和折射光发生干涉</p>
<blockquote>
<p>比如彩色太阳眼镜和阳光下的七彩肥皂泡</p>
</blockquote>
<p>光线在射向薄膜后会发生反射和透射，透射光可能会再次反射透射，返回薄膜表面，进而和入射光相遇，发生干涉</p>
<img src="../../images/薄膜干涉.png" alt="薄膜干涉" style="zoom:50%;" />
<h3 id="等倾斜角干涉">等倾斜角干涉</h3>
<h3 id="等厚度干涉">等厚度干涉</h3>
<h2 id="干涉仪">干涉仪</h2>
<h3 id="迈克耳孙干涉仪">迈克耳孙干涉仪</h3>
<h3 id="法布里-珀罗干涉仪">法布里-珀罗干涉仪</h3>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/25/optics/%E5%B9%B2%E6%B6%89/" data-id="clepy40ot001yglnkau1mcuro" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%89%E5%AD%A6/" rel="tag">光学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-program/AskQuestion" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/18/program/AskQuestion/" class="article-date">
  <time datetime="2023-02-18T10:01:25.000Z" itemprop="datePublished">2023-02-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/18/program/AskQuestion/">提问的智慧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>提问的智慧</h1>
<p>提问的方式，可能会很大程度影响你是否能得到有用的回答</p>
<h3 id="树立好的形象">树立好的形象</h3>
<p>当你想问问题，一定要树立你的形象：我已经做了努力，我不是一个不劳而获且浪费别人时间的提问者</p>
<p>你可以做的努力有</p>
<ul>
<li>网上搜素</li>
<li>查看文档、手册、issuse</li>
<li>看看源码</li>
<li>自己先做试验</li>
</ul>
<h3 id="问题不要带有错误的预设">问题不要带有错误的预设</h3>
<p>草率的发问只会得到草率的回答，如果你的预设错了，下面的尝试和思考都是无用功</p>
<blockquote>
<p>很多民科认为自己推翻了相对论、微积分，很有可能是使用了一个错误的预设</p>
</blockquote>
<blockquote>
<p>not even wrong</p>
<p>Q：你是哪个省的</p>
<p>Right：四川省</p>
<p>Wrong：西藏省</p>
<p>Not even wrong：妈妈生的</p>
</blockquote>
<h3 id="不要明知故问">不要明知故问</h3>
<p>特别要批评哪些为了“耍存在感”而明知自问，列举了一大串知识试图诱导他人的思路，然后在最后向别人进行提问</p>
<h3 id="不要认为自己够格得到回答">不要认为自己够格得到回答</h3>
<p>如果你没有为这个问题付费，那你不要期待自己一定能得到好的回答，你需要通过靠提出有内涵的、有趣的、有思维激励作用的问题<strong>挣得</strong>回答</p>
<h3 id="选择正确的提问地点">选择正确的提问地点</h3>
<p>不要在主题不和的论坛贴出你的问题</p>
<blockquote>
<p>比如在NS吧问原神好不好玩，在A9问XGPU是否值得购买</p>
</blockquote>
<p>不要在进阶的论坛中问低级问题，反之亦然</p>
<blockquote>
<p>比如你认为火箭燃料应该用水洗煤，在太空应该用铅笔替代</p>
</blockquote>
<p>不要在不同的论坛反复问同一件事</p>
<blockquote>
<p>这让人感觉你在大喊大叫</p>
</blockquote>
<p>不要向陌生人发私人邮件</p>
<blockquote>
<p>你没有付费，别人就没有必要回答，更不要说私聊对方让他“加班”</p>
</blockquote>
<p>可以试一试在Stack Overflow问程序相关的问题</p>
<h3 id="向一个群体提问，而非个人">向一个群体提问，而非个人</h3>
<p>个人没有义务回答你的问题</p>
<p>向群体问一个好问题能对整个群体有益，你的提问可以被后来者看到</p>
<p>向群体问问题能减轻某个个人的压力</p>
<h3 id="描述问题">描述问题</h3>
<h4 id="使用有意义的标题">使用有意义的标题</h4>
<p>使用<code>目标-差异</code>做标题</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://X.org">X.org</a> 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形</p>
</blockquote>
<h4 id="言之有物">言之有物</h4>
<p>低声下气不如清晰地说明情况</p>
<p>不要使用</p>
<blockquote>
<p>大佬，求救</p>
<p>在线等，很急</p>
<p>我是一个菜鸡，呜呜呜</p>
<p>有人能帮帮我吗</p>
</blockquote>
<p>如果你真的很菜，你可以去一些更入门的论坛去搜寻答案（菜的远远不止你一个人，因此你遇到的问题很可能其他人也会遇到）</p>
<h4 id="不要擅自声称找到bug">不要擅自声称找到bug</h4>
<p>如果你没有非常明确的根据，不要擅自声称找到了bug（很可能是因为你不会用导致的）</p>
<p>如果你对该软件还没有足够的了解，就声称自己遇到的困难是bug，这可能会惹恼软件作者</p>
<p>即使真的有bug，你最好要写的像是你做错了什么，给开发者一个台阶下，他可能反过来给你说抱歉</p>
<h4 id="不要进行猜测">不要进行猜测</h4>
<p>如果你的猜测有效，那还用向别人求助吗？</p>
<p>你认为问题是怎么来的并不重要，重要地是描述问题本身，你的错误推测甚至可能会影响回答者的思路</p>
<p><strong>蠢问题</strong></p>
<blockquote>
<p>我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p>
</blockquote>
<p><strong>聪明问题</strong></p>
<blockquote>
<p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下…</p>
</blockquote>
<h4 id="按时间顺序描述问题症状">按时间顺序描述问题症状</h4>
<h4 id="描述目标而非过程">描述目标而非过程</h4>
<p><strong>蠢问题</strong></p>
<blockquote>
<p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？</p>
</blockquote>
<p><strong>聪明问题</strong></p>
<blockquote>
<p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。</p>
</blockquote>
<h3 id="问题解决后">问题解决后</h3>
<p>问题解决后你应该感谢帮助你的人</p>
<p>将标题修改为<strong>已解决</strong>，并在最后补充说明，你是如何解决问题的</p>
<h3 id="参考">参考</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">How to Ask Question</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/18/program/AskQuestion/" data-id="clepy40ow002aglnk7dhx3k2m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PM/" rel="tag">PM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-graphics/DOSDF" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/13/graphics/DOSDF/" class="article-date">
  <time datetime="2023-02-13T10:01:25.000Z" itemprop="datePublished">2023-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/13/graphics/DOSDF/">Dynamic Occlusion with SDF</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Dynamic Occlusion with SDF</h1>
<p>2015年SIGGRAPH，epic提出一种基于SDF的occlusion算法</p>
<h2 id="问题">问题</h2>
<p>需要找到一种比较好的动态物体occlusion算法，应满足</p>
<ul>
<li>软（soft）、准确（accurate）、不连续（incoherent）</li>
<li>能用于阴影、天空、反射球</li>
</ul>
<p>现存的动态oc技术都有局限性</p>
<ul>
<li>shadowmap：连续</li>
<li>SSAO：丢失边界和被撤档区域的信息</li>
<li>Voxel cone tracing：耗费大，处于性能考虑没法使用过高精度</li>
<li>预计算的体积AO：自阴影分辨率低，难以避免被多个物体过度遮挡</li>
</ul>
<h2 id="SDF">SDF</h2>
<p><a target="_blank" rel="noopener" href="https://iquilezles.org/articles/distfunctions/">SDF</a></p>
<p>SDF（Signed Distance Field）有很多用处，比如体积建模，比如加速射线检测</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> <span class="token function">sdf</span><span class="token punctuation">(</span>float3 pos<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>pos 在模型表面<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pos 在模型外<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> pos距离模型表面最近的距离<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span>pos距离模型表面最近的距离<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>SDF体积建模</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 以原点为球心的球</span>
<span class="token keyword">float</span> <span class="token function">sdfSphere</span><span class="token punctuation">(</span>float3 pos<span class="token punctuation">,</span> <span class="token keyword">float</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token function">length</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">-</span> r<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 以原点为中心的长方形</span>
<span class="token keyword">float</span> <span class="token function">sdfBox</span><span class="token punctuation">(</span>float3 pos<span class="token punctuation">,</span> float3 box<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  float3 q <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">-</span> box<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>y<span class="token punctuation">,</span> q<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>SDF射线检测</p>
<img src="../../images/SDFTrace.png" alt="SDFTrace" style="zoom:50%;" />

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/13/graphics/DOSDF/" data-id="clepy40o20008glnk1a4h9rlh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SIGGRAPH/" rel="tag">SIGGRAPH</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-graphics/SSSR" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/10/graphics/SSSR/" class="article-date">
  <time datetime="2023-02-10T01:16:25.000Z" itemprop="datePublished">2023-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/10/graphics/SSSR/">SSSR</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Stochastic Screen Space Reflections</h1>
<p>2015年SIGRAPH，EA提出了SSSR，用于《镜之边缘》中镜面反射</p>
<p>需求有</p>
<ul>
<li>支持清晰（sharp）和模糊（blurry）反射</li>
<li>邻接性，越近反射越清晰（contact hardening）</li>
<li>高光拉伸</li>
<li>逐像素的粗糙度和法线</li>
</ul>
<h2 id="相关工作">相关工作</h2>
<h3 id="mirror-only-SSR">mirror-only SSR</h3>
<p>我们先回顾传统的SSR</p>
<ol>
<li>从屏幕像素开始RayMarching（需要View空间的世界坐标和法线）</li>
<li>根据深度可以很轻松找到第一个落点，根据法线很容易求出反射光线的角度</li>
<li>使用简单的线性步进，求反射光线的命中点
<ol>
<li>反射光线向前步进一段距离，到达C点</li>
<li>通过三角形边角性质，可以求出C点距离镜头的距离，这其实就是View空间的深度</li>
<li>若C点距离镜头的距离小于等于深度，则说明命中</li>
</ol>
</li>
<li>将命中位置进行透视投影，使用上一帧的渲染结果作为反射颜色</li>
</ol>
<img src="/images/SSR.png" alt="SSR" style="zoom:50%;" />
<h3 id="glossy-SSR">glossy SSR</h3>
<h4 id="模糊滤波">模糊滤波</h4>
<p>杀戮尖塔提供了一种glossy SSR，就是对反射像素做一次卷积模糊，但这种模糊是一视同仁的模糊，没有实现越近越清晰</p>
<h4 id="重要性采样">重要性采样</h4>
<p>相对于普通的SSR，这里根据法线求反射光线方向时，加入一些随机偏差，反射光线形成了一个锥形，进而实现了模糊的SSR</p>
<p>当物体离反射面比较近时，根据正弦定理，滤波的像素数量更少，于是清晰度更高</p>
<p>但是在光线数量比较少的情况下，会有大量噪点，效果很差</p>
<img src="/images/SSR噪点.png" alt="SSR噪点" style="zoom:50%;" />
<h2 id="作者的算法">作者的算法</h2>
<img src="/images/SSSR.png" alt="SSSR" style="zoom: 67%;" />
<ol>
<li>将屏幕划分为Tile，进行一次低分辨率的光线步进，评估Tile的重要性，需要多少射线</li>
<li>根据材质粗糙度判断使用何种的RayMarching
<ul>
<li>昂贵的射线：借助Hi-Z的精确tracing，能得到准确的命中点
<ul>
<li>用于smooth表面</li>
</ul>
</li>
<li>便宜的射线：简单的线性步进
<ul>
<li>用于粗糙表面（反正会做严重的滤波，不需要高精度）</li>
</ul>
</li>
</ul>
</li>
<li>使用BRDF重要性采样决定射线方向</li>
<li>使用邻居的采样信息进行模糊</li>
<li>TAA</li>
</ol>
<h2 id="Tile评估">Tile评估</h2>
<ol>
<li>对于每一个Tile以1/8分辨率发射射线</li>
<li>判断射线（的反射光线）是否击中
<ol>
<li>若所有光线都没命中，则跳过这个Tile的步进</li>
<li>根据命中的比例和命中信息的差异，判断这个Tile中的像素需要多少个光线</li>
</ol>
</li>
</ol>
<h2 id="Hi-Z-tracing">Hi-Z tracing</h2>
<blockquote>
<p>详情可以去看《GPU Pro 5》</p>
</blockquote>
<p>Hi-Z使用四叉树组织屏幕深度，将层次关系存储在MipMap层级中，用于加速反射光线的求交</p>
<p>Hi-Z的构建时，对屏幕尺寸的深度进行滤波，每次保存2x2像素中最浅的像素，也就是说最高级别的Hi-Z存储着整张图中最浅的深度</p>
<p>用C点表示光线在步进过程中的头坐标，我们射线求交的原理就是判断C点距离相机的距离和该点深度图的深度关系，相交处必然是一侧比C点深，一侧比C点浅</p>
<p>此外还有几条经验：</p>
<ul>
<li>从相机出发的射线，落点位置是View空间该方向最浅的位置</li>
<li>从相机出发的射线，与落点位置的法线夹角应该大于$45^{\circ}$
<ul>
<li>若夹角小于$45^{\circ}$，那么反射信息来自相机身后的内容，屏幕空间没有这些信息（可以用Cubemap补充信息）</li>
<li>若夹角大于$45^{\circ}$，那么我们基本可以认为，反射光线在步进过程中，深度在不断变深</li>
</ul>
</li>
<li>我们实际寻找的是，光线在步进过程中，比C点要深的最浅位置（更深，但只能深一点点）</li>
<li>由于起初我们位于最浅的位置，而步进的光线越来越深，因此第一个min-Z小于C点深度的位置，就是交点位置，我们只需要一直向右，不用回头
<ul>
<li>这样得到的Mip等级比较高，我们通过降低Mip等级，每次取比C深中最浅的那一个，直到Mip为0</li>
</ul>
</li>
</ul>
<img src="/images/HiZTrace.png" alt="HiZTrace"  />
<p>算法复杂度为$O(\log n)$</p>
<h2 id="重要性采样-2">重要性采样</h2>
<blockquote>
<p>重要性采样是蒙特卡洛积分中用于减少方差的算法，详情可以去看PBRT</p>
<p>简单来说就是我们有一个积分，我们不得不实时求这个积分，于是我们将这个积分很多项分离出去，最后变成了 复杂离散项 x 一段简单函数的积分</p>
</blockquote>
<h3 id="蒙特卡洛积分">蒙特卡洛积分</h3>
<img src="/images/三角形积分.png" alt="三角形" style="zoom: 33%;" />
<p>这是一个三角形，如果我们想求三角形的面积，可以对三角形的高度函数做积分</p>
<ul>
<li>第一种切分方法：均匀切分，三角形被分为等宽的长方形，每个长方形长$\Delta x$，高$\sqrt{1-x^2}$</li>
</ul>
<p>$$<br>
S=\sum _{i=0}^N \Delta x \times h_i<br>
$$</p>
<ul>
<li>第二种切分方法：重要性切分，左侧长方形更窄，右侧更宽</li>
</ul>
<p>$$<br>
S=\sum _{i=0}^N x_i \times h_i<br>
$$</p>
<p>三角形切被分为一个个长方形，长方形的面积代表贡献。很显然，左侧的长方形高度越高，相同宽度面积越大，贡献越多。也就是说，相同的x轴变化，左侧部分对积分的影响越明显，越高频</p>
<p>能看出（在同等误差下）重要性采样所需要的采样次数比均匀采样要小</p>
<p>重要性采样的思想就是，在高频处我们进行更多次的采样，低频处进行更少的采样，最后根据权重合并，就能在采样次数比较少的情况下，得到最精确的积分值</p>
<ul>
<li>高度函数$h_i$就是采样值</li>
<li>宽度函数$x_i$就是重要性权重</li>
<li>面积$S$就是在当前概率分布下的采样期望</li>
</ul>
<h3 id="概率密度函数">概率密度函数</h3>
<p>详情可以去看<a href="/2023/01/31/math/%E6%A6%82%E7%8E%87%E8%AE%BA/">概率论</a></p>
<p>在上一步，我们将连续函数的积分，转化为离散的采样值 x 重要性权重，然后我们发现，这个重要性权重怎么求？</p>
<p>还是上面的三角形，我们发现横坐标可以取[0, r]中任意值（r为三角形边长）</p>
<p>因此具体到某个点（随机变量），被取到的概率为$\frac{\mathrm{d}x}{r}$（这里其实不怎么精确，概率论中点取到的概率为0，这里实际上是一段很小的区域被取到的概率）</p>
<p>对于一个区域[a, b]，我们进行积分，得到随机变量取到该区域的概率P<br>
$$<br>
P(a &lt; X \le b)=F(b)-F(a)=\int_a^b \frac{1}{r}\mathrm{d}x=\frac{b-a}{r}<br>
$$</p>
<ul>
<li>
<p>分布函数：$F(x)$</p>
</li>
<li>
<p>概率密度函数：$1/r$，我们用$p(x)$表示</p>
</li>
<li>
<p>概率：$P(a &lt; X \le b)$</p>
</li>
</ul>
<p>哦，现在我们知道了这个重要性权重有多大了<br>
$$<br>
x_i=\Delta x/P=1/p(x)<br>
$$<br>
进而我们可以写出这个三角形面积的期望<br>
$$<br>
S=\sum _{i=0}^N x_i \times h_i=\lim <em>{N \rightarrow \infty}\frac{1}{N}\sum</em>{k=1}^{N}\frac{f(x_k)}{p(x)}<br>
$$</p>
<p>不过，值得注意的是，我们上面使用的PDF是均匀的，其实并能很好地加速收敛，实际会使用一个和原函数形状类似的PDF来加速收敛（PDF的选择不会影响最终结果，但是会影响收敛速度）</p>
<img src="/images/重要性采样.png" alt="重要性采样" style="zoom:67%;" />
<h3 id="BRDF生成射线方向">BRDF生成射线方向</h3>
<p>BRDF，双向反射分布函数，用于描述光线进出材质后能量的变化</p>
<p>我们在实现BRDF时，通常会实现以下接口</p>
<ul>
<li>eval：给定入射光方向和视线方向，求BRDF值</li>
<li>sample：生成射线方向</li>
<li>pdf：返回sample生成的射线的PDF</li>
</ul>
<p>我们以最简单的phong着色为例</p>
<p>在<a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html">RTOW</a>中，我们朝着随机半球方向生成向量，该向量就是新射线的方向，同时求出该方向的PDF</p>
<blockquote>
<p>我个人理解，射线方向是随机生成的，每个方向出现的可能性相同，但是他们的PDF不同，你可以理解为重要性采样求三角形面积时，每个大长方形是由内部多个（数量相同）等高的小长方形拼成的，但是小长方形的宽度不一致，1/PDF就是小长方形的宽度。越重要的地方，长方形宽度越小，越密集，于是实现了重要性采样</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token function">scatter</span><span class="token punctuation">(</span>
        <span class="token keyword">const</span> ray<span class="token operator">&amp;</span> r_in<span class="token punctuation">,</span> <span class="token keyword">const</span> hit_record<span class="token operator">&amp;</span> rec<span class="token punctuation">,</span> color<span class="token operator">&amp;</span> alb<span class="token punctuation">,</span> ray<span class="token operator">&amp;</span> scattered<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> pdf<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">auto</span> scatter_direction <span class="token operator">=</span> rec<span class="token punctuation">.</span>normal <span class="token operator">+</span> <span class="token function">random_unit_vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// Catch degenerate scatter direction</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>scatter_direction<span class="token punctuation">.</span><span class="token function">near_zero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                scatter_direction <span class="token operator">=</span> rec<span class="token punctuation">.</span>normal<span class="token punctuation">;</span>
            scattered <span class="token operator">=</span> <span class="token function">ray</span><span class="token punctuation">(</span>rec<span class="token punctuation">.</span>p<span class="token punctuation">,</span> <span class="token function">unit_vector</span><span class="token punctuation">(</span>scatter_direction<span class="token punctuation">)</span><span class="token punctuation">,</span> r_in<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            alb <span class="token operator">=</span> albedo<span class="token operator">-></span><span class="token function">value</span><span class="token punctuation">(</span>rec<span class="token punctuation">.</span>u<span class="token punctuation">,</span> rec<span class="token punctuation">.</span>v<span class="token punctuation">,</span> rec<span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pdf <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span>rec<span class="token punctuation">.</span>normal<span class="token punctuation">,</span> scattered<span class="token punctuation">.</span><span class="token function">direction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> pi<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span></code></pre>
<p>上面生成新射线方向时，使用法线+球面向量，最后的形状就类似下图红色</p>
<img src="/images/法线+球.png" alt="法线+球" style="zoom:80%;" />
<p>还清除了朝下（射向材质内部的）的射线</p>
<h3 id="随机数">随机数</h3>
<p>作者使用了<a target="_blank" rel="noopener" href="https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/The_Halton_Sampler">Halton Sequences</a>生成随机数，并引入了截断，角度有最大值，这样能减弱BRDF的长尾巴（Tail）对结果的影响（这些尾巴会带来很多噪点）</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">float2 u <span class="token operator">=</span> <span class="token function">halton</span><span class="token punctuation">(</span>sampleIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
u<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">lerp</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> bias<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">importanceSample</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<img src="/images/截断.png" alt="截断" style="zoom:67%;" />
<h3 id="过滤重要性采样">过滤重要性采样</h3>
<p>一种基于预计算的光追，我们假设射线是圆锥形，我们可以根据MipMap层级得到滤波结果</p>
<img src="/images/coneRayTrace.png" alt="coneRayTrace" style="zoom:67%;" />
<h2 id="复用邻居光线">复用邻居光线</h2>
<h3 id="复用">复用</h3>
<p>上面提到glossy ssr会导致严重的噪点问题，即使使用重要性采样，每个像素仍需要大量光线才能得到低噪点的结果</p>
<p>我们注意到，相邻像素，他们的位置相近，可见性应该也是接近的，那么邻居像素朝某方向发射的光线，其实也可以被当前像素复用</p>
<p>当然直接做模糊（比如用高斯滤波）会导致很多光斑，经过很多数学推导和近似后，给出了以下公式</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">result <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
weightSum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> pixel <span class="token operator">:</span> neighborhood<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    weight <span class="token operator">=</span> <span class="token function">localBRDF</span><span class="token punctuation">(</span>pixel<span class="token punctuation">.</span>hit<span class="token punctuation">)</span> <span class="token operator">/</span> pixel<span class="token punctuation">.</span>hitPDF<span class="token punctuation">;</span>
    result <span class="token operator">+=</span> <span class="token function">color</span><span class="token punctuation">(</span>pixel<span class="token punctuation">.</span>hit<span class="token punctuation">)</span> <span class="token operator">*</span> weight<span class="token punctuation">;</span>
    weightSum <span class="token operator">+=</span> weight<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
result <span class="token operator">/=</span> weightSum<span class="token punctuation">;</span></code></pre>
<h3 id="稀疏">稀疏</h3>
<p>受邻居光线的启发，我们完全没必要每个像素都做射线，只需要在低分辨率下某些点做多次射线，其邻居使用这个射线结果就可以</p>
<h3 id="TAA">TAA</h3>
<p>我们不仅在空间上做射线的复用，也可以在时间上及逆行复用</p>
<h2 id="参考">参考</h2>
<p><a target="_blank" rel="noopener" href="https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html">SSR</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/10/graphics/SSSR/" data-id="clepy40o6000eglnkbsi5039g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SIGGRAPH/" rel="tag">SIGGRAPH</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-graphics/UnityEnemies" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/10/graphics/UnityEnemies/" class="article-date">
  <time datetime="2023-02-10T01:16:25.000Z" itemprop="datePublished">2023-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/10/graphics/UnityEnemies/">Probe-based Lighting in Unity Enemies</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Probe-based Lighting in Unity Enemies</h1>
<p>2022年SIGGRAPH，Unity发布了一个数字人项目，在头发、眼球、GI方面效果非常好，我们来分析一下他的Probe-based GI</p>
<p><a target="_blank" rel="noopener" href="http://advances.realtimerendering.com/s2022/SIGGRAPH2022-Advances-Enemies-Ciardi%20et%20al.pdf">论文地址</a></p>
<blockquote>
<p>感觉原理上就是在Volume GI的基础上，存了遮罩信息用于偏移采样点，使用紧凑哈希提高了空间利用率，感觉手游大世界完全可以上这个</p>
</blockquote>
<img src="/images/Enemies.png" alt="Enemies" style="zoom:50%;" />
<h3 id="不用Lightmap">不用Lightmap</h3>
<ul>
<li>难以处理复杂的集合体，难以处理LOD</li>
<li>烘焙速度慢，严重制约开发效率</li>
<li>无法处理动态物体，无法提供统一的光照</li>
<li>无法处理人物</li>
<li>Worse directional quality</li>
</ul>
<h3 id="Adaptive-Probe-Volumes">Adaptive Probe Volumes</h3>
<p>将空间划分为相同大小的cell，将cell作为分块烘焙、分块加载的最小单位</p>
<p>cell被细分为brick，在几何体密集的地方，brick越细分</p>
<img src="/images/adaptive.png" alt="adaptive" style="zoom:50%;" />
<img src="/images/cell.png" alt="cell" style="zoom:50%;" />
<img src="/images/稀疏网格.png" alt="稀疏网格" style="zoom:67%;" />
<h4 id="细分">细分</h4>
<blockquote>
<p>可以参考Lumen中Build Voxel Faces，本质就是推箱子</p>
</blockquote>
<p>细分的原理是使用Raycast判断一个区域有没有物体（命中点），我们使用SDF加速射线检测</p>
<img src="/images/SDF推箱子.png" alt="SDF推箱子" style="zoom:50%;" />
<ol>
<li>我们将一个cell划分为4x4的brick，这样就有16条起始边界，这些边界构成了一个正方形</li>
<li>每一条边界向内发射一条长度为一的射线（使用SDF加速），若没有命中，则向内移动一格</li>
<li>直到所有边界都命中后，我们得到右图所示的brick</li>
</ol>
<h4 id="数据结构">数据结构</h4>
<p>感觉很类似与VolumeGI，由索引buffer和3DTexture组成，通过紧凑哈希来降低存储</p>
<ul>
<li>An indirection buffer存储了cell信息，cell索引→SH指针</li>
<li>Spherical Harmonics Pool中存储SH信息，SH指针→SH系数</li>
</ul>
<img src="/images/IndirectionBuffer.png" alt="IndirectionBuffer" style="zoom:50%;" />
<h4 id="采样">采样</h4>
<p>采样流程：World Position → Cell Indirection → Per-Cell Brick Indirection→ Brick UVW →Trilinear Sample SH Data</p>
<ol>
<li>基于着色点posWS生成cellPos</li>
<li>加载cell信息</li>
<li>找到该着色点位于cell中哪一个brick（brick的最低层级可能是由相机距着色点距离决定的）</li>
</ol>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> localBrickIndex <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>residualPosWS <span class="token operator">/</span> <span class="token punctuation">(</span>_MinBrickSize <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> minFoundBrickLevel<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//若minFoundBrickLevel=1，那么cell被细分为3x3个brick</span>
localBrickIndex <span class="token operator">-=</span> validArea<span class="token punctuation">.</span>min<span class="token punctuation">;</span></code></pre>
<ol start="4">
<li>
<p>加载brick信息</p>
</li>
<li>
<p>通过brick信息+offset采样3DTexture</p>
</li>
</ol>
<h3 id="接缝">接缝</h3>
<p>我们根据场景几何体密度构建空间八叉树，对于稀疏空间使用精度更低的高Subdiv Level存储Probe信息，在Level交界处有时会有明显的接缝问题</p>
<p>解决方法：采样时加入抖动</p>
<h3 id="黑斑">黑斑</h3>
<p>当我们做Probe摆放时，由于按网格和brick摆放，经常会出现Probe放在墙内的情况，这会导致墙面、地板发黑</p>
<p>Unity的做法是一种辐照度驱动的摆放，通过判断Probe位置处四周backface比例，来判断这个Probe的有效性</p>
<img src="/images/Probe评分.png" alt="Probe评分" style="zoom:50%;" />
<p>对于有效性低/无效的Probe，Unity给出的解决方案就是，<strong>让墙内的Probe变亮</strong></p>
<h4 id="Post-Bake">Post-Bake</h4>
<ol>
<li>烘焙后遍历Probe，找到在墙内的无效Probe</li>
<li>搜索其邻居Probe，使用其中<strong>有效</strong>Probe进行加权插值，权重是距离的平方反比</li>
<li>于是墙内的Probe就成功变亮了</li>
</ol>
<img src="/images/Dilation2.png" alt="Dilation2" style="zoom:67%;" />
<h4 id="Pre-Bake">Pre-Bake</h4>
<blockquote>
<p>参考《The lighting technology of Detroit Become Human》</p>
</blockquote>
<p>使用Post-Bake后，确实黑斑少了，但是我们发现墙体出现了漏光，为此我们加入了Virtual Offset（bake阶段的offset），在烘焙时，将Probe移至墙外，最后再将墙外烘焙的信息写入墙内Probe中，于是既没有破坏网格结构，也实现了墙内Probe变亮</p>
<img src="/images/probeoffset.png" alt="probeoffset" style="zoom:50%;" />
<h3 id="漏光">漏光</h3>
<blockquote>
<p>我感觉防漏光的本质就是让墙体“变厚”，无论是摆放层面上的遮光板，烘焙时期的Virtual Offset，还是是采样层面的偏移</p>
</blockquote>
<p>传统的Probe采样，薄墙体由于使用了墙壁另一面的Probe信息发生漏光。为了避免漏光，采样时通常对采样位置进行偏移（Biases）</p>
<ul>
<li>Normal Bias，采样点沿着法线方向偏移
<ul>
<li>这样做实际上让物体沿着法线方向变大了</li>
<li>偏移的过多/过少，都会影响效果</li>
<li>难以调优</li>
</ul>
</li>
<li>View Bias，采样点朝着相机方向偏移
<ul>
<li>依赖于相机</li>
<li>难以调优</li>
</ul>
</li>
</ul>
<h4 id="Validity-Based-Weighting">Validity Based Weighting</h4>
<p>而Unity使用了Validity Based Weighting技术来减弱漏光，本质还是对采样点进行偏移</p>
<p>原理上是通过标记遮罩得出偏移方向，使得偏移方向基于辐照度，而非模型法线、视线，</p>
<ul>
<li>每一个Probe存储者8bit的遮罩，用于记录其八个方向（2x2x2）的邻居是否有效</li>
<li>若某个邻居无效，则推动采样点远离那个邻居（计算偏移的方向和大小）</li>
</ul>
<p>但我们现在其实只得到了偏移的方向，不知道偏移的距离</p>
<h4 id="遮光板">遮光板</h4>
<p>美术可以手动摆放一个遮光板，使得某些位置上的Probe失效</p>
<img src="/images/遮光板.png" alt="遮光板" style="zoom:50%;" />
<p>这确实让房顶下面不再漏光，但是这让房顶上面的物体过黑了</p>
<p>Unity的做法是对遮光板内Probe的邻居进行判断</p>
<ul>
<li>若邻居Probe都不在室内（Occluding objects），那么不会使用遮光板，使用原本的数据</li>
<li>若邻居有在室内的，室内物体用到该Probe时才会变黑</li>
</ul>
<h3 id="场景管理">场景管理</h3>
<p>将球偕信息编码在3DTexture中比较好做Streaming</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/10/graphics/UnityEnemies/" data-id="clepy40ob000oglnkf3v85g73" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SIGGRAPH/" rel="tag">SIGGRAPH</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-program/GoogleC++" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/09/program/GoogleC++/" class="article-date">
  <time datetime="2023-02-09T19:01:25.000Z" itemprop="datePublished">2023-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/09/program/GoogleC++/">Google C++代码规范</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Google C++ 代码规范</h1>
<p><a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></p>
<p>Google提出的一套代码规范，能提高代码的可读性，减少出错。建议配合<a href="/2023/01/31/program/Effective%20C++/">Effective C++</a>阅读</p>
<h2 id="头文件">头文件</h2>
<h3 id="所有头文件都应该自给自足（self-contained）">所有头文件都应该自给自足（self-contained）</h3>
<blockquote>
<p>self-contained : compile on their own</p>
</blockquote>
<p>确保你的header files包含了你需要的所有东西，而不是假设你#include进来的某个（些）headers帮你包含了你需要的东西。</p>
<p>A.h包含了B.h和C.h，而B.h也包含了C.h，那么在A.h中使用C.h时，会难以判断到底该用哪一个</p>
<h3 id="define-保护">#define 保护</h3>
<p>每个头文件都要使用<code>#pragma once</code>保护</p>
<h3 id="前置声明">前置声明</h3>
<p>我个人理解的前置声明，是指在一个<code>.h</code>文件中开头声明另一个<code>.h</code>文件中的类，以此来实现类似<code>#include</code>某个文件的某一部分</p>
<p>与之对应的是直接使用<code>#include</code>引入文件，但这样实际会增加编译工作量，降低编译速度，于是我们非必要不<code>#include</code></p>
<blockquote>
<p>Google建议要避免使用前置声明，因为使用前置声明会影响类的修改，也容易产生错误</p>
<p>但使用前置声明可以提高编译速度，因此需要按情况选择</p>
</blockquote>
<p>优点</p>
<ul>
<li>节省编译时间，避免很多不必要的（因为头文件改动而导致的）重新编译</li>
</ul>
<p>缺点</p>
<ul>
<li>隐藏了依赖关系</li>
<li>头文件改动时会破坏后续，影响开发者改动API（比如当你要添加一个形参时）
<ul>
<li>但这个是不是可以通过宏的方法避免？<code>#define Func Func</code></li>
</ul>
</li>
</ul>
<h4 id="两个类互相引用">两个类互相引用</h4>
<p>前置声明（Forward Declarations）基本仅用于两个类互相引用</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// A.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"B.h"</span></span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">&#123;</span>
    B b<span class="token punctuation">;</span>	<span class="token comment">//A中使用了B，因此</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span></code></pre>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// B.h</span>
<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">&#123;</span>
	A<span class="token operator">*</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span></code></pre>
<h4 id="失去依赖关系">失去依赖关系</h4>
<p>前置声明最大的问题是失去依赖关系</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// B.h</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>	<span class="token comment">//这里的D继承自B</span></code></pre>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"b.h"</span></span>
<span class="token comment">//如果使用前置声明替换掉#include，就会出现错误</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>B<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>D<span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// Calls f(B*)</span></code></pre>
<h3 id="内联函数">内联函数</h3>
<p>除非是极其高频调用，确定是性能瓶颈的地方，不然不用内联函数</p>
<p>不要内敛超过十行的函数</p>
<p>析构函数远比表面要长，因为他隐式调用着成员和基类的析构函数</p>
<h3 id="include路径">#include路径</h3>
<p>按照源码目录树结构排列，避免使用UNIX的快捷目录，比如<code>.</code>（当前目录）和<code>..</code>（上级目录）</p>
<h3 id="include顺序">#include顺序</h3>
<ol>
<li>C头文件</li>
<li>C++头文件</li>
<li>第三方库头文件</li>
<li>本项目头文件</li>
</ol>
<h2 id="作用域">作用域</h2>
<p>命名空间将全局作用域细分为独立具体的作用域，可以有效防止全局命名冲突</p>
<pre class="language-C++" data-language="C++"><code class="language-C++">#include &quot;a.h&quot;

namespace MyNamespace
&#123;
    class MyClass
    &#123;
        ...
    &#125;;
&#125;    &#x2F;&#x2F;namespace MyNamespace</code></pre>
<h3 id="请在命名空间最后注释出命名空间的名字">请在命名空间最后注释出命名空间的名字</h3>
<h3 id="不要污染命名空间">不要污染命名空间</h3>
<ul>
<li>不要在std命名空间中声明任何东西</li>
<li>不要使用<code>using namespace xxx</code></li>
<li>不要在头文件中使用命名空间别名，如<code>namespace bbb = ::Foo::Bar::Baz</code></li>
</ul>
<h3 id="静态变量">静态变量</h3>
<p>不要在.h文件中声明静态变量，至少不能用全裸的静态变量</p>
<p>不要定义静态存储周期<strong>非</strong>POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中静态变量的构造和析构顺序不确定，会导致bug（除非你使用constexpr）</p>
<p>原生数据类型（POD，Olain Old Data），如int、char、float，int*、int[]、结构体</p>
<p>在同一编译单元，静态初始化会优先于动态初始化，并按照声明顺序初始化，以逆序销毁</p>
<p>但是不同编译单元，初始化、销毁顺序是未定义行为</p>
<h2 id="类">类</h2>
<h3 id="构造函数不要调用虚函数">构造函数不要调用虚函数</h3>
<p>在类被完全初始化前，这个类其实是基类+其他部分，此时调用虚函数不一定会指向子类的重载，可能会报错、出错</p>
<p>优点</p>
<ul>
<li>不需要考虑类是否被完全初始化</li>
<li>初始化的对象可以为const类型</li>
</ul>
<p>如果你想进行有意义的non-trivial初始化，可以使用明确的Init()方法，或者工厂模式</p>
<h3 id="析构函数要设为虚函数">析构函数要设为虚函数</h3>
<h3 id="不要隐式类型转换">不要隐式类型转换</h3>
<p>不要使用隐式类型转换</p>
<ul>
<li>隐式转换会降低代码可读性，由于是存在函数重载时，让人难以判断到底在用哪一个函数</li>
<li>隐式转化可能会导致类型不匹配的错误</li>
</ul>
<p>使用explict关键词（常用于<strong>单参数</strong>构造函数和类型转化操作符），可以使当前类型只能被显示类型转换，如果使用隐式转化，会报错</p>
<pre class="language-C++" data-language="C++"><code class="language-C++">class Foo
&#123;
    explicit Foo(int x, int y);    &#x2F;&#x2F;这个类型不能被隐式转化，调用Func(&#123;42, 3.14&#125;)会报错
    ...
&#125;
void Func(Foo f);</code></pre>
<h3 id="拷贝和移动">拷贝和移动</h3>
<p>如果你的类型需要拷贝和支持，就请实现它，否则禁用它（<code>=delete</code>）</p>
<p>std::unique_ptr<int> 可移动，但是不能复制</p>
<ul>
<li>可拷贝类型，可以使用相同类型的另一对象进行初始化，当前对象会得到相同的值，同时不改变源对象。
<ul>
<li>用户通过定义拷贝构造函数、拷贝赋值操作符实现</li>
</ul>
</li>
<li>可移动对象，可以使用相同类型的临时对象进行初始化，当前对象会得到相同的值
<ul>
<li>用户通过定义移动构造函数、移动赋值操作符实现</li>
</ul>
</li>
</ul>
<p>不要为任何有可能有子类的类型提供拷贝和移动，可能会导致对象割裂</p>
<h3 id="除了数据成员，其他一律用class">除了数据成员，其他一律用class</h3>
<p>C++的class和struct很像，但是class有构造和析构函数，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/09/program/GoogleC++/" data-id="clepy40p1002pglnk8yd30cl1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-graphics/TiledDeferred" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/08/graphics/TiledDeferred/" class="article-date">
  <time datetime="2023-02-08T14:33:25.000Z" itemprop="datePublished">2023-02-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/08/graphics/TiledDeferred/">Metal：TBDR</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Tile Base Deferred Rendering</h1>
<p>基于Apple M1和Metal图形库，<a target="_blank" rel="noopener" href="https://github.com/Reuben-Sun/TinyMetalEngine">项目地址</a></p>
<h3 id="移动端GPU渲染架构">移动端GPU渲染架构</h3>
<p><img src="/images/%E7%A7%BB%E5%8A%A8%E7%AB%AFGPU.png" alt="移动端GPU"></p>
<ul>
<li>IMR（Immediate Mode Rending），即时模式渲染，按drawcall顺序绘制</li>
<li>TBR（Tile Base Rendering）
<ul>
<li>将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上</li>
<li>FS读信息，渲染每一个tile</li>
<li>当FS将所有的tile渲染完毕后，将完成的frame信息写入System Memory中</li>
</ul>
</li>
</ul>
<p>TBR相较于IMR能省带宽，而移动端的性能瓶颈在于带宽</p>
<p>值的注意的是，TBR产生带宽优势的核心是片上存储，而非Tile</p>
<blockquote>
<p>我个人感觉为什么要使用Tile，可能是因为移动端GPU规模太小，难以放下整张RT。毕竟理论上使用一张大RT的采样成本更低，比如将一组TextureArray转化为VSM，能很明显提高滤波速度</p>
<p>我在实际测试中发现当你隐式使用TBR时也会自动切分Tile，手动指定Tile尺寸反而增大了带宽和GPU时间（我也不清楚为什么，希望有人能给我解释一些）</p>
</blockquote>
<h4 id="片上储存">片上储存</h4>
<p>片上存储（on-chip memory），是集成在GPU上的存储空间</p>
<p>GPU中有多种存储数据的结构，访问速度从快到慢排依次是</p>
<ol>
<li>Register Memory（RMEM）
<ul>
<li>访问极快，不需要消耗时钟周期（除非发生了冲突或者先写后读）</li>
<li>只对负责对其进行读写的线程可见</li>
</ul>
</li>
<li>Shared Memory（SMEM）
<ul>
<li>对处于同一个block所有的线程都是可见的，所以常用与数据交换</li>
</ul>
</li>
<li>Constant Memory（CMEM）
<ul>
<li>用于存储常量数据</li>
</ul>
</li>
<li>Texture Memory（TMEM）
<ul>
<li>用于存储常量数据</li>
</ul>
</li>
<li>Local Memory（LMEM）和Global Memory（GMEM）
<ul>
<li>LMEM只是对GMEM的一个抽象，两者存取速度上一样的</li>
<li>只对负责对其进行读写的线程可见</li>
<li>一般用来存储automatic变量
<ul>
<li>automatic变量是一种大尺寸的数据结构/数组</li>
</ul>
</li>
<li>有缓存机制（类比cache）</li>
</ul>
</li>
</ol>
<p>其中<strong>RMEM与SMEM是集成在GPU芯片上的</strong>，其他的则是存储在显存中的（你可以类比寄存器，cache和内存）</p>
<h3 id="Single-RednerPass">Single RednerPass</h3>
<blockquote>
<p>类比Vulkan的SubPass</p>
</blockquote>
<p>传统的延迟渲染，是一个多Pass渲染。GBufferPass生成MRT，传递给LightingPass着色输出，这个过程中会有大量的贴图IO带宽</p>
<img src="/images/传统延迟.png" alt="传统延迟" style="zoom:50%;" />
<p>TBDR（Tile Base Deferred Rendering）利用了Metal图形库Single RenderPass的特性</p>
<ul>
<li>在一个Single Pass中有多个小Pass，小Pass共享一组片上存储</li>
<li>一个Pass运行后，会在片上生成一些临时贴图，其他Pass可以直接访问这些贴图</li>
</ul>
<img src="/images/MetalTBDR.png" alt="MetalTBDR" style="zoom:50%;" />
<blockquote>
<p>TBDR是Apple芯片的功能，对于安卓GPU</p>
<p>Adreno：frameBuffer fetch deferred，提前绑定（开辟）好MRT，使用时RT不动，Pass动</p>
<p>Mali：pixel loacl storage deferred，将GBuffer存在on-clip mem上，于是就减少了IO消耗</p>
</blockquote>
<h3 id="实现TBDR">实现TBDR</h3>
<ol>
<li>将GBuffer中Texture存储类型设为memoryless</li>
</ol>
<pre class="language-diff" data-language="diff"><code class="language-diff">albedoTexture = Self.makeTexture(
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">           size: size,
</span><span class="token prefix unchanged"> </span><span class="token line">           pixelFormat: .bgra8Unorm,
</span><span class="token prefix unchanged"> </span><span class="token line">           label: "Albedo Texture",
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">            storageMode: .private)
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            storageMode: .memoryless)  </span></span></code></pre>
<ol start="2">
<li>将贴图存储操作设为dontcare</li>
</ol>
<pre class="language-diff" data-language="diff"><code class="language-diff">func draw(commandBuffer: MTLCommandBuffer, scene: GameScene, uniforms: Uniforms, params: Params) &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">       ...
</span><span class="token prefix unchanged"> </span><span class="token line">       //将贴图存储操作设为dontCare
</span><span class="token prefix unchanged"> </span><span class="token line">       for (index, texture) in textures.enumerated() &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">           let attachment =
</span><span class="token prefix unchanged"> </span><span class="token line">           descriptor.colorAttachments[RenderTargetAlbedo.index + index]
</span><span class="token prefix unchanged"> </span><span class="token line">           attachment?.texture = texture
</span><span class="token prefix unchanged"> </span><span class="token line">           attachment?.loadAction = .clear
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">            attachment?.storeAction = .store
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            attachment?.storeAction = .dontCare
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">           attachment?.clearColor =
</span><span class="token prefix unchanged"> </span><span class="token line">           MTLClearColor(red: 0.73, green: 0.92, blue: 1, alpha: 1)
</span><span class="token prefix unchanged"> </span><span class="token line">       &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">       ...</span></span></code></pre>
<ol start="3">
<li>停止向LightPass的片元着色器传递贴图信息</li>
</ol>
<pre class="language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">func drawSunLight(
</span><span class="token prefix unchanged"> </span><span class="token line">       renderEncoder: MTLRenderCommandEncoder,
</span><span class="token prefix unchanged"> </span><span class="token line">       scene: GameScene,
</span><span class="token prefix unchanged"> </span><span class="token line">       params: Params
</span><span class="token prefix unchanged"> </span><span class="token line">   ) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       renderEncoder.pushDebugGroup("Sun Light")
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        renderEncoder.setFragmentTexture(
</span><span class="token prefix deleted">-</span><span class="token line">            albedoTexture,
</span><span class="token prefix deleted">-</span><span class="token line">            index: BaseColor.index)
</span><span class="token prefix deleted">-</span><span class="token line">        renderEncoder.setFragmentTexture(
</span><span class="token prefix deleted">-</span><span class="token line">            normalTexture,
</span><span class="token prefix deleted">-</span><span class="token line">            index: NormalTexture.index)
</span><span class="token prefix deleted">-</span><span class="token line">        renderEncoder.setFragmentTexture(
</span><span class="token prefix deleted">-</span><span class="token line">            positionTexture,
</span><span class="token prefix deleted">-</span><span class="token line">            index: NormalTexture.index + 1)
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">       ...</span></span></code></pre>
<ol start="4">
<li>修改LightPass的片元着色器，使其直接接收GBufferOut</li>
</ol>
<pre class="language-diff" data-language="diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">fragment float4 fragment_deferredSun(VertexOut in [[stage_in]],
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">fragment float4 fragment_tiled_deferredSun(VertexOut in [[stage_in]],
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">       constant Params &amp;params [[buffer(ParamsBuffer)]],
</span><span class="token prefix unchanged"> </span><span class="token line">       constant Light *lights [[buffer(LightBuffer)]],
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        texture2d&lt;float> albedoTexture [[texture(BaseColor)]],
</span><span class="token prefix deleted">-</span><span class="token line">        texture2d&lt;float> normalTexture [[texture(NormalTexture)]],
</span><span class="token prefix deleted">-</span><span class="token line">        texture2d&lt;float> positionTexture [[texture(NormalTexture + 1)]])
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">				GBufferOut gBuffer)
</span></span>&#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   uint2 coord = uint2(in.position.xy);
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    float4 albedo = albedoTexture.read(coord);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">		 float4 albedo = gBuffer.albedo;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    float3 normal = normalTexture.read(coord).xyz;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">		 float3 normal = gBuffer.normal.xyz;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    float3 position = positionTexture.read(coord).xyz;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">		 float3 position = gBuffer.position.xyz;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   Material material &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       .baseColor = albedo.xyz,
</span><span class="token prefix unchanged"> </span><span class="token line">       .specularColor = float3(0),
</span><span class="token prefix unchanged"> </span><span class="token line">       .shininess = 500
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">   float3 color = phongLighting(normal,
</span><span class="token prefix unchanged"> </span><span class="token line">                                position,
</span><span class="token prefix unchanged"> </span><span class="token line">                                params,
</span><span class="token prefix unchanged"> </span><span class="token line">                                lights,
</span><span class="token prefix unchanged"> </span><span class="token line">                                material);
</span><span class="token prefix unchanged"> </span><span class="token line">   color *= albedo.a;
</span><span class="token prefix unchanged"> </span><span class="token line">   return float4(color, 1);
</span></span>&#125;</code></pre>
<ol start="5">
<li>
<p>合并渲染命令提交，将drawGBufferRenderPass和drawLightingRenderPass放在同一个commandBuffer中</p>
</li>
<li>
<p>配置Stencil测试</p>
</li>
</ol>
<pre class="language-diff" data-language="diff"><code class="language-diff"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">static func buildDepthStencilState() -> MTLDepthStencilState? &#123;
</span><span class="token prefix inserted">+</span><span class="token line">        let descriptor = MTLDepthStencilDescriptor()
</span><span class="token prefix inserted">+</span><span class="token line">        descriptor.depthCompareFunction = .less
</span><span class="token prefix inserted">+</span><span class="token line">        descriptor.isDepthWriteEnabled = true
</span><span class="token prefix inserted">+</span><span class="token line">        let frontFaceStencil = MTLStencilDescriptor()
</span><span class="token prefix inserted">+</span><span class="token line">        frontFaceStencil.stencilCompareFunction = .always
</span><span class="token prefix inserted">+</span><span class="token line">        frontFaceStencil.stencilFailureOperation = .keep
</span><span class="token prefix inserted">+</span><span class="token line">        frontFaceStencil.depthFailureOperation = .keep
</span><span class="token prefix inserted">+</span><span class="token line">        frontFaceStencil.depthStencilPassOperation = .incrementClamp
</span><span class="token prefix inserted">+</span><span class="token line">        descriptor.frontFaceStencil = frontFaceStencil
</span><span class="token prefix inserted">+</span><span class="token line">        return Renderer.device.makeDepthStencilState(descriptor: descriptor)
</span><span class="token prefix inserted">+</span><span class="token line">      &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   
</span><span class="token prefix unchanged"> </span><span class="token line">   static func buildLightingDepthStencilState() -> MTLDepthStencilState? &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       let descriptor = MTLDepthStencilDescriptor()
</span><span class="token prefix unchanged"> </span><span class="token line">       descriptor.isDepthWriteEnabled = false
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        let frontFaceStencil = MTLStencilDescriptor()
</span><span class="token prefix inserted">+</span><span class="token line">        frontFaceStencil.stencilCompareFunction = .notEqual
</span><span class="token prefix inserted">+</span><span class="token line">        frontFaceStencil.stencilFailureOperation = .keep
</span><span class="token prefix inserted">+</span><span class="token line">        frontFaceStencil.depthFailureOperation = .keep
</span><span class="token prefix inserted">+</span><span class="token line">        frontFaceStencil.depthStencilPassOperation = .keep
</span><span class="token prefix inserted">+</span><span class="token line">        descriptor.frontFaceStencil = frontFaceStencil
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">       return Renderer.device.makeDepthStencilState(descriptor: descriptor)
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;</span></span></code></pre>
<pre class="language-diff" data-language="diff"><code class="language-diff">depthTexture = Self.makeTexture(
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">           size: size,
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">            pixelFormat: .depth32Float,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            pixelFormat: .depth32Float_stencil8,
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">           label: "Depth Texture",
</span><span class="token prefix unchanged"> </span><span class="token line">           storageMode: .memoryless)</span></span></code></pre>
<pre class="language-diff" data-language="diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">descriptor.depthAttachment.storeAction = .dontCare
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">descriptor.depthAttachment.texture = depthTexture
</span><span class="token prefix inserted">+</span><span class="token line">descriptor.stencilAttachment.texture = depthTexture</span></span></code></pre>
<pre class="language-diff" data-language="diff"><code class="language-diff">static func createGBufferPSO(colorPixelFormat: MTLPixelFormat, tiled: Bool = false) -> MTLRenderPipelineState &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">       ...        
</span><span class="token prefix unchanged"> </span><span class="token line">       if tiled &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">           pipelineDescriptor.colorAttachments[0].pixelFormat = colorPixelFormat
</span><span class="token prefix unchanged"> </span><span class="token line">       &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">       pipelineDescriptor.setGBufferPixelFormats()
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        pipelineDescriptor.depthAttachmentPixelFormat = .depth32Float
</span><span class="token prefix deleted">-</span><span class="token line">        if !tiled &#123;
</span><span class="token prefix deleted">-</span><span class="token line">            pipelineDescriptor.depthAttachmentPixelFormat = .depth32Float_stencil8
</span><span class="token prefix deleted">-</span><span class="token line">            pipelineDescriptor.stencilAttachmentPixelFormat = .depth32Float_stencil8
</span><span class="token prefix deleted">-</span><span class="token line">				 &#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        pipelineDescriptor.depthAttachmentPixelFormat = .depth32Float_stencil8
</span><span class="token prefix inserted">+</span><span class="token line">        pipelineDescriptor.stencilAttachmentPixelFormat = .depth32Float_stencil8
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">       pipelineDescriptor.vertexDescriptor = MTLVertexDescriptor.defaultLayout
</span><span class="token prefix unchanged"> </span><span class="token line">       return createPSO(descriptor: pipelineDescriptor)
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;</span></span></code></pre>
<h3 id="参考">参考</h3>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10632/">WWDC 2020</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/kodecocodes/met-materials">Metal by Tutorials</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/08/graphics/TiledDeferred/" data-id="clepy40oa000kglnkg79qczd9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Deferred-Render/" rel="tag">Deferred Render</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Metal/" rel="tag">Metal</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-graphics/邻域搜索" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/06/graphics/%E9%82%BB%E5%9F%9F%E6%90%9C%E7%B4%A2/" class="article-date">
  <time datetime="2023-02-06T19:33:25.000Z" itemprop="datePublished">2023-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/06/graphics/%E9%82%BB%E5%9F%9F%E6%90%9C%E7%B4%A2/">SPH：邻域搜索</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>邻域搜索</h1>
<h3 id="参考">参考</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/alen-cell/PhysicsEngine">alen-cell</a></p>
<p><a target="_blank" rel="noopener" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.187.5321&amp;rep=rep1&amp;type=pdf">A parallel SPH implementation on multi-core CPUs</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/InteractiveComputerGraphics/CompactNSearch">紧凑哈希</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/06/graphics/%E9%82%BB%E5%9F%9F%E6%90%9C%E7%B4%A2/" data-id="clepy40oe000vglnkfzcl1k8q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Physics/" rel="tag">Physics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SPH/" rel="tag">SPH</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/dcc/">dcc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/engine/">engine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/graphics/">graphics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/math/">math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/optics/">optics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/program/">program</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DX12/" rel="tag">DX12</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deferred-Render/" rel="tag">Deferred Render</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metal/" rel="tag">Metal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PM/" rel="tag">PM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Physics/" rel="tag">Physics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SIGGRAPH/" rel="tag">SIGGRAPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPH/" rel="tag">SPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TA/" rel="tag">TA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unreal/" rel="tag">Unreal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shader/" rel="tag">shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%89%E5%AD%A6/" rel="tag">光学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" rel="tag">并行计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" rel="tag">微积分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C#</a> <a href="/tags/C/" style="font-size: 17.5px;">C++</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/DX12/" style="font-size: 10px;">DX12</a> <a href="/tags/Deferred-Render/" style="font-size: 10px;">Deferred Render</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/GI/" style="font-size: 15px;">GI</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Metal/" style="font-size: 10px;">Metal</a> <a href="/tags/PM/" style="font-size: 10px;">PM</a> <a href="/tags/Physics/" style="font-size: 12.5px;">Physics</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/SIGGRAPH/" style="font-size: 15px;">SIGGRAPH</a> <a href="/tags/SPH/" style="font-size: 12.5px;">SPH</a> <a href="/tags/TA/" style="font-size: 15px;">TA</a> <a href="/tags/Unity/" style="font-size: 12.5px;">Unity</a> <a href="/tags/Unreal/" style="font-size: 10px;">Unreal</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/shader/" style="font-size: 10px;">shader</a> <a href="/tags/%E5%85%89%E5%AD%A6/" style="font-size: 20px;">光学</a> <a href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" style="font-size: 10px;">并行计算</a> <a href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" style="font-size: 10px;">微积分</a> <a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 17.5px;">高等数学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/02/26/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/">光学复习</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E8%A1%8D%E5%B0%84/">衍射</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E5%B9%B2%E6%B6%89/">干涉</a>
          </li>
        
          <li>
            <a href="/2023/02/18/program/AskQuestion/">提问的智慧</a>
          </li>
        
          <li>
            <a href="/2023/02/13/graphics/DOSDF/">Dynamic Occlusion with SDF</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Reuben Sun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>