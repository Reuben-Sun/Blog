<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ReubenSun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Reuben的笔记博客">
<meta property="og:type" content="website">
<meta property="og:title" content="ReubenSun">
<meta property="og:url" content="http://reuben-sun.github.io/page/3/index.html">
<meta property="og:site_name" content="ReubenSun">
<meta property="og:description" content="Reuben的笔记博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Reuben Sun">
<meta property="article:tag" content="reubensun computer graphics engine Technical Artist">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="ReubenSun" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ReubenSun</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://reuben-sun.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-engine/大象无形UE笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/engine/%E5%A4%A7%E8%B1%A1%E6%97%A0%E5%BD%A2UE%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/engine/">engine</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/engine/%E5%A4%A7%E8%B1%A1%E6%97%A0%E5%BD%A2UE%E7%AC%94%E8%AE%B0/">大象无形UE笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>UE学习笔记</h1>
<h2 id="基类">基类</h2>
<h3 id="UObject">UObject</h3>
<p>一切对象的基类。UE为UObject类提供了</p>
<ul>
<li>垃圾回收GC
<ul>
<li>被<code>UProperty</code>标记的变量会自动进行生命周期管理</li>
<li>非UObject可以使用C++标准推荐的智能指针</li>
</ul>
</li>
<li>引用计数</li>
<li>反射</li>
<li>序列化
<ul>
<li>资源的存储与加载</li>
</ul>
</li>
<li>自动检测默认变量的更改</li>
<li>自动变量初始化</li>
<li>与Editor的交互</li>
<li>运行时类型识别
<ul>
<li>UE禁用了C++的<code>dynamic_cast</code>，你可以使用<code>Cast&lt;&gt;</code>替代</li>
</ul>
</li>
<li>网络复制</li>
</ul>
<h4 id="反射">反射</h4>
<p>反射分为静态反射和动态反射，C++没有该机制（尽管C++可以在编译时进行类型推导，但远不如Java那种<strong>Class对象</strong>的机制好用），于是UE自己做了一套</p>
<ul>
<li>
<p>功能</p>
<ul>
<li>
<p>运行时知道类、函数的所有相关信息（属性表，函数表），进而实现可视化编程（蓝图，面板）</p>
</li>
<li>
<p>通过函数名/类名+连续数据块访问对应函数/类</p>
</li>
</ul>
</li>
</ul>
<p>反射说白了就是将类、函数的信息（用哈希表）存储，运行时根据函数名、类名（key）查找信息，UE的反射是通过UBT和UHT实现的</p>
<ul>
<li>通过宏标记C++代码</li>
<li>UHT生成<code>.generated.h</code>和<code>.generated.cpp</code>文件</li>
<li>引擎初始化时注册反射信息</li>
</ul>
<h3 id="Actor">Actor</h3>
<p>一切实体的基类。能够被挂载组件（U）</p>
<h4 id="Component">Component</h4>
<p>基类：<code>UActorComponent</code></p>
<p>Component是一种属性+行为的集合</p>
<p><img src="/images/UEComponent.png" alt="UEComponent"></p>
<h4 id="通讯">通讯</h4>
<p>Actor之间要进行通讯，Unity可以通过获得GO引用、获得GO的组件的方式进行通讯</p>
<p>UE Actor的通讯方式有</p>
<ul>
<li>获取引用</li>
<li>Cast</li>
<li>接口</li>
<li>事件</li>
</ul>
<h3 id="Pawn">Pawn</h3>
<p>英语意思为棋子，指可以被操控的兵卒（可以被玩家操控，也可以被AI操控）</p>
<h4 id="Charactor">Charactor</h4>
<p>继承自Pawn，是一个更复杂的可操控角色，该角色的特点是有一种特殊的组件，Charactor Movement</p>
<h3 id="Controller">Controller</h3>
<p>控制器，负责控制Pawn、Charactor的行为</p>
<h2 id="命名原则">命名原则</h2>
<p>通过类的前缀来区分类的类型</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>纯C++类，通常为功能类</td>
</tr>
<tr>
<td>U</td>
<td>继承自UObject，但不继承自Actor</td>
</tr>
<tr>
<td>A</td>
<td>继承自Actor</td>
</tr>
<tr>
<td>S</td>
<td>Slate控件</td>
</tr>
<tr>
<td>H</td>
<td>HitResult相关类</td>
</tr>
<tr>
<td>T</td>
<td>模版类</td>
</tr>
<tr>
<td>E</td>
<td>枚举类</td>
</tr>
</tbody>
</table>
<h2 id="对象">对象</h2>
<h3 id="创建对象">创建对象</h3>
<ul>
<li>F类，使用new</li>
<li>U类，使用NewObject</li>
<li>A类，使用SpawnActor</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">new FClass();
NewObject&lt;UxxxClass&gt;();
GetWorld()-&gt;SpawnActor&lt;AxxxClass&gt;();</code></pre>
<h3 id="UObject-2">UObject</h3>
<p>生命周期</p>
<h4 id="创建">创建</h4>
<ul>
<li>内存分配，返回一个分配好尺寸但没有初始化的指针（你steam下游戏也是先清出一片区域，再正式下载）</li>
<li>对象构建
<ul>
<li>创建<code>FObjectInitializer</code></li>
<li>将<code>FObjectInitializer</code>作为参数传递给函数指针<code>ClassConstructor</code>，得到对象</li>
</ul>
</li>
</ul>
<h4 id="反序列化">反序列化</h4>
<ul>
<li>获取类信息<code>GetClass</code></li>
<li>判断类信息是否载入，若没有载入则进行预载</li>
<li>载入名字、Outer、类信息（类信息保存在ObjClass对象中，感觉和Java的类对象机制很接近）</li>
<li>载入脚本成员变量信息</li>
</ul>
<p>反序列化的规则：</p>
<ul>
<li>只反序列化<code>UPROPERTY</code>标记，且不等于默认值的数据</li>
<li>先创建出对象，再反序列化（还原数据）</li>
<li>对象具有所属关系</li>
<li>若一个对象所有信息和原始对象相同，尽管他们在内存的位置不同（指针值不同），该对象就是原始对象</li>
</ul>
<h4 id="释放消亡">释放消亡</h4>
<p>UObject无法手动释放，但是可以被请求，将其标记后等待引擎将其释放</p>
<p>GC分为两步，析构、回收</p>
<h2 id="蓝图">蓝图</h2>
<ul>
<li>UPROPERTY：注册成员变量到蓝图</li>
<li>UFUNCTION：注册函数到蓝图</li>
</ul>
<h2 id="引擎基础功能">引擎基础功能</h2>
<h3 id="正则表达式">正则表达式</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;Regex.h&quot;
...
FString TextStr(&quot;This is a string&quot;);
FRegexPattern TestPattern(TEXT(&quot;C.+H&quot;));
FRegexMatcher TestMatcher(TestPattern, TextStr);
if(TestMatcher.FindNext())&#123;
  UE_LOG(MyLog, Warning, TEXT(&quot;找到匹配内容 %d -%d&quot;), 
        TestMatcher.GetMatchBeginning(),
        TestMatcher.GetMatchEnding());
&#125;</code></pre>
<h3 id="路径">路径</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;获取xxx目录路径
FString FPaths::xxxDir();		
&#x2F;&#x2F;判断文件是否存在
bool FPaths::FileExists(const FString&amp; InPath);	
&#x2F;&#x2F;相对路径转化为绝对路径
FString ConvertRelativePathToFull(const FString&amp; BasePath, FString&amp;&amp; InPath)；	</code></pre>
<h3 id="XML">XML</h3>
<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Ami<span class="token punctuation">"</span></span> <span class="token attr-name">age</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>John<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>
  	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>line</span><span class="token punctuation">></span></span>Hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>line</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>line</span><span class="token punctuation">></span></span>world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>line</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span></code></pre>
<p>使用<code>FXmlFile</code>或者<code>FastXML</code>操作xml文件</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">FString xmlFilePath &#x3D; TEXT(&quot;xxx&#x2F;Test.xml&quot;);
FXmlFile* xml &#x3D; new FXmlFile();
xml-&gt;LoadFile(xmlFilePath);
FXmlNode* RootNode &#x3D; xml-&gt;GetRootNode();
FString from_content &#x3D; RootNode-&gt;FindChildNode(&quot;from&quot;)-&gt;GetContent();
FString note_name  &#x3D; RootNode-&gt;GetAttribute(&quot;name&quot;);
TArray&lt;FXmlNode*&gt; list_node &#x3D; RootNode-&gt;FindChildNode(&quot;list&quot;)-&gt;GetChildrenNodes();</code></pre>
<h3 id="JSON">JSON</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">FString JsonStr &#x3D; &quot;[&#123;\&quot;author\&quot;: \&quot;Tim\&quot;&#125;, &#123;\&quot;age\&quot;: \&quot;100\&quot;&#125;]&quot;;
TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParsed;
TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader &#x3D; TJsonReaderFactory&lt;TCHAR&gt;::Create(JsonStr);
bool BFlag &#x3D; FJsonSerializer::Deserialize(JsonReader, JsonParsed);
&#123;
  FString FStringAutor &#x3D; JsonParsed[0]-&gt;AsObject()-&gt;GetStringField(&quot;autor&quot;);
&#125;</code></pre>
<h3 id="文件">文件</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">FPlatformFileManager::Get()-&gt;GetPlatformFile();</code></pre>
<h3 id="GConfig">GConfig</h3>
<pre class="language-c+" data-language="c+"><code class="language-c+">&#x2F;&#x2F;写配置
GConfig-&gt;SetString(TEXT(&quot;Section&quot;), TEXT(&quot;Key&quot;), TEXT(&quot;Value&quot;), FPaths::xxxDir()&#x2F;&quot;Config.ini&quot;);
&#x2F;&#x2F;读配置
FString Result;
GConfig-&gt;GetString(TEXT(&quot;Section&quot;), TEXT(&quot;Key&quot;), Result, FPaths::xxxDir()&#x2F;&quot;Config.ini&quot;);</code></pre>
<h3 id="UE-LOG">UE_LOG</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">UE_LOG(log分类，log类型，log内容)；</code></pre>
<h3 id="字符串">字符串</h3>
<table>
<thead>
<tr>
<th></th>
<th>能否修改</th>
<th>大小写敏感</th>
<th>语意</th>
</tr>
</thead>
<tbody>
<tr>
<td>FName</td>
<td>无法修改</td>
<td>不敏感</td>
<td>名字，在整个字符串表只出现一次</td>
</tr>
<tr>
<td>FText</td>
<td>无法修改</td>
<td>敏感</td>
<td>被显示的字符串</td>
</tr>
<tr>
<td>FString</td>
<td>能够修改</td>
<td>敏感</td>
<td>普通字符串</td>
</tr>
</tbody>
</table>
<h3 id="图片">图片</h3>
<p><code>/imagesrWrapper</code></p>
<h2 id="模块">模块</h2>
<h3 id="模块-2">模块</h3>
<p>模块就像Unity的Package，用于整理文件结构，便于编译</p>
<p>一个模块包含</p>
<ul>
<li><code>Public</code>文件夹
<ul>
<li><code>.h</code>文件</li>
</ul>
</li>
<li><code>Private</code>文件夹
<ul>
<li><code>.cpp</code>文件</li>
</ul>
</li>
<li><code>模块名.build.cs</code>文件（继承自<code>ModuleRules</code>类）</li>
</ul>
<h3 id="UBT">UBT</h3>
<p><code>Unreal Build Tool.cs</code>中有Main函数，主要做三个功能</p>
<ol>
<li>收集信息：环境变量、目录信息等</li>
<li>确定生成的目标类型</li>
<li>生成构建</li>
</ol>
<h3 id="UHT">UHT</h3>
<p><code>Unreal Header Tool</code>，一个基于引擎代码，但不需要引擎完全启动，编译后得到一个<code>.exe</code>文件的程序</p>
<h2 id="引擎核心">引擎核心</h2>
<p><a target="_blank" rel="noopener" href="https://dev.epicgames.com/community/learning/paths/0w/beginplay">UE Begin Play</a></p>
<h3 id="内存分配">内存分配</h3>
<p>提供了多套内存分配器，其中包含TBB（TBB的内存分配一大特点就是可以通过代理的方式全局替换new、malloc等操作符），TBB见《高性能C+++》笔记，那边有详细介绍</p>
<p>TBB内存分配主要包括</p>
<ul>
<li>LTS，线程内存池，每个线程会独立拥有一个局部的内存池，互不影响，但最后需要归约</li>
<li>缓存对齐，通过在变量间填充大量无效信息，使得不同变量处于不同缓存行中，于是避免了假共享问题</li>
</ul>
<h3 id="引擎初始化">引擎初始化</h3>
<ul>
<li>PreInit
<ul>
<li>接收cmd命令，判断启动模式</li>
<li>初始化游戏主线程（将当前线程当作主线程）</li>
<li>初始化随机数</li>
<li>初始化TaskGraph系统，设置线程数量，启动线程池</li>
<li>调用<code>LoadCoreModules</code>，启动<code>CoreUObject</code>模块</li>
<li>启动引擎、渲染、动画蓝图、Slate、贴图压缩、地形模块</li>
</ul>
</li>
<li>Init
<ul>
<li>各个模块初始化，并执行所有<code>PostEngineInit</code>函数</li>
<li>进入主循环</li>
</ul>
</li>
</ul>
<h3 id="主循环">主循环</h3>
<p>UE是一个多线程引擎，将游戏逻辑、渲染、声音、IO等系统分离</p>
<p>主线程是游戏逻辑线程，内含一个while循环，循环内有一个<code>Trick</code>，可以类比Unity的Update</p>
<p>渲染线程数游戏逻辑线程的从属，接收来自主线程的命令，进行渲染绘制。渲染线程比逻辑线程慢一帧</p>
<h3 id="并发并行">并发并行</h3>
<ul>
<li>
<p>线程</p>
</li>
<li>
<p>并行</p>
</li>
<li>
<p>并发</p>
</li>
<li>
<p>Task Graph</p>
<ul>
<li>UE最强大的多线程框架，将任务抽象为Task</li>
<li>UE内部使用了TBB，感觉这部分内容和TBB基本一致</li>
<li>详情见<code>FBaseGraphTask</code>、<code>FTaskThreadBase</code></li>
</ul>
</li>
<li>
<p><code>FRunnableThread+FRunnable</code></p>
<ul>
<li>详情见<code>QueuedThreadPoolWrapper.h</code>，并不是很好用</li>
</ul>
</li>
</ul>
<h2 id="渲染">渲染</h2>
<h3 id="渲染线程">渲染线程</h3>
<p>UE的游戏线程和渲染线程分离（事实上现在基本所有引擎都这样），渲染线程是游戏线程的“附庸”</p>
<p>在引擎Init时，会调用<code>StartRenderingThread</code>函数，启动渲染线程</p>
<p>该函数主要做：</p>
<ol>
<li>创建渲染线程</li>
<li>从TaskGraph中取任务</li>
<li>注册渲染线程</li>
<li>注册Trick</li>
</ol>
<h3 id="运行">运行</h3>
<p>渲染线程的主要执行内容在<code>RenderingThreadMain</code>中，游戏线程可以通过<code>EQUEUE_Render_COMMAND</code>等宏命令向渲染线程的TaskMap中添加渲染任务，渲染线程提取这些命令后将其添加到<code>RHICommandList</code>中，最后传递到GPU中</p>
<p><img src="/images/%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E4%B8%8ERHI.png" alt="渲染线程与RHI"></p>
<h3 id="RHI">RHI</h3>
<p>RHI（Render Hardware Interface），对图形库的一种封装，以供上层使用</p>
<table>
<thead>
<tr>
<th></th>
<th>UE5中含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>FRenderResource</td>
<td>渲染线程中的资源，如贴图、顶点buffer、顶点id</td>
</tr>
<tr>
<td>FRHIResource</td>
<td>GPU侧的资源，如Texture2D、3D、Cube</td>
</tr>
<tr>
<td>DynamicRHI</td>
<td>所有图形API适配器的基类</td>
</tr>
<tr>
<td>RHI</td>
<td></td>
</tr>
<tr>
<td>RHIContext</td>
<td>RHI命令上下文</td>
</tr>
<tr>
<td>RHICommandList</td>
<td>RHI指令队列</td>
</tr>
<tr>
<td>FRHICommandListExecutor</td>
<td>将RHI指令翻译为图形API</td>
</tr>
</tbody>
</table>
<h3 id="多线程">多线程</h3>
<h4 id="DX11">DX11</h4>
<p>DX11尝试从硬件层面解决多线程渲染，提供了两种设备上下文：即时上下文（Immediate Context）和延迟上下文（Deferred Context）</p>
<p>延迟上下文多线程并行，最后将生成的CommandList归约到即时上下文中，由即时上下文Execute</p>
<p>对于某些支持硬件级加速的驱动，延迟上下文可以将CommandList也直接提交给图形驱动</p>
<p><img src="/images/DX11%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="DX11多线程"></p>
<p>DX11的多线程，感觉就是一种简单的异步，仅仅是加速了指令录制，减少了等待</p>
<h4 id="DX12">DX12</h4>
<p>取消了DX11的渲染上下文，不再使用DrawCall，而是直接使用CommandList来调用图形驱动</p>
<ol>
<li>DX12渲染线程并行进行指令录制，生成一些命令列表（CommandList）</li>
<li>然后将这些命令列表提交给命令队列（CommandQueue）中</li>
<li>命令队列根据指令类型，将指令放入不同的GPU引擎中</li>
</ol>
<p>命令队列有三种：复制队列（Copy Queue）、计算队列（Compute Queue）、3D队列</p>
<p>GPU引擎有三种：复制引擎、计算引擎、3D引擎</p>
<p>命令队列和GPU引擎都可以并行执行</p>
<img src="/images/DX12多线程.png" alt="DX12多线程" style="zoom: 50%;" />
<h3 id="渲染管线">渲染管线</h3>
<p><img src="/images/UE5RenderingPipeline.jpg" alt="UE5RenderingPipeline"></p>
<h2 id="物理">物理</h2>
<p>UE5使用Chaos替代PhysX作为新的物理引擎</p>
<table>
<thead>
<tr>
<th>Chaos</th>
<th>PhysX</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于位置（PBD）</td>
<td>基于速度</td>
</tr>
<tr>
<td>支持大世界坐标（LWC）</td>
<td>不支持</td>
</tr>
<tr>
<td>支持网络同步</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<h3 id="异步">异步</h3>
<p>UE5可以启用异步物理模拟，物理线程会作为单独的线程运行（类似渲染线程）</p>
<p>由于是独立线程，物理模拟可以以固定的间隔运行，既可以提高精确度，也方便C/S网络同步</p>
<p>但开启异步后物理线程无法即时获取游戏线程的输入，有可能影响游戏逻辑</p>
<h3 id="功能">功能</h3>
<ul>
<li>布料</li>
<li>破坏</li>
<li>载具</li>
<li>场</li>
</ul>
<h3 id="PBD">PBD</h3>
<p><a target="_blank" rel="noopener" href="https://matthias-research.github.io/pages/publications/PBDBodies.pdf">论文</a></p>
<h3 id="大世界">大世界</h3>
<p>World partition</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/engine/%E5%A4%A7%E8%B1%A1%E6%97%A0%E5%BD%A2UE%E7%AC%94%E8%AE%B0/" data-id="clepy40o10007glnkc9m9dhs7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unreal/" rel="tag">Unreal</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-graphics/DX12笔记1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/graphics/DX12%E7%AC%94%E8%AE%B01/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/graphics/DX12%E7%AC%94%E8%AE%B01/">DX12龙书（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>DX12</h1>
<h3 id="环境搭建">环境搭建</h3>
<p>Windows 10/11系统</p>
<p>安装<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/pix/download/">PIX</a></p>
<p>安装Visual Studio 2019</p>
<h3 id="Windows应用程序">Windows应用程序</h3>
<p>Windows应用程序使用事件驱动（详情可以去看WPF）</p>
<p>Windows应用程序的入口点是<code>WinMain</code>函数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow)
&#123;
    LearnDX::D3D12HelloWindow sample(1280, 720, L&quot;D3D12 Hello Window&quot;);
    return LearnDX::Win32Application::Run(&amp;sample, hInstance, nCmdShow);
&#125;</code></pre>
<p>主程序会创建一个窗口，并进入消息循环，检索处理操作系统发来的消息，并对其进行相应</p>
<table>
<thead>
<tr>
<th>message</th>
<th>发送时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>WM_CHAR</td>
<td>键盘输入一个字符</td>
</tr>
<tr>
<td>WM_COMMAND</td>
<td>使用菜单栏、控件</td>
</tr>
<tr>
<td>WM_CREATE</td>
<td>创建一个窗口</td>
</tr>
<tr>
<td>WM_DESTROY</td>
<td>一个窗口被摧毁</td>
</tr>
<tr>
<td>WM_LBUTTONDOWN</td>
<td>按下鼠标左键</td>
</tr>
<tr>
<td>WM_LBUTTONUP</td>
<td>鼠标左键被释放</td>
</tr>
<tr>
<td>WM_MOUSEMOVE</td>
<td>鼠标指针被移动</td>
</tr>
<tr>
<td>WM_PAINT</td>
<td>一个窗口需要重新粉刷</td>
</tr>
<tr>
<td>WM_QUIT</td>
<td>应用程序即将终止，WinMain返回</td>
</tr>
<tr>
<td>WM_SIZE</td>
<td>调整窗口大小</td>
</tr>
</tbody>
</table>
<p>当接收到<code>WM_QUIT</code>消息时（比如用户关闭窗口），会退出消息循环，应用程序即将结束，<code>WinMain</code>函数返回</p>
<h3 id="COM">COM</h3>
<h4 id="为什么要使用COM">为什么要使用COM</h4>
<blockquote>
<p>我们在编写C++时，经常会生成dll文件，这是一种动态库，保存了许多通用的数据和函数，运行时软件可以通过函数指针的方式导出dll的函数，从而实现运行时动态链接</p>
<p>当我们在同一操作系统、同一编译器环境写构建C++项目，可以复用这个dll文件。然而当你使用其他语言时，如果这个语言读不懂dll的二进制，不知道如何与之沟通，这个语言就不能使用这个dll文件。</p>
<p>或者另一种情况，当你更新了这个dll文件，而应用还在用老办法调用dll，很有可能也会出错</p>
</blockquote>
<p>为了解决上述问题，微软提出了<strong>组件对象模型</strong>（Component Object Model，COM），一套软件组件的二进制接口，可以实现跨编程语言的进程间通信、创建动态对象，在二进制层面打破了代码依赖</p>
<h4 id="COM的优点">COM的优点</h4>
<ul>
<li>软件（apps）使用抽象接口访问服务器（servers，这里指dll文件），可以使用接口指针调用COM类的成员函数</li>
<li>软件无需知道COM的内部实现，COM对象的创建与释放由COM自行完成</li>
<li>COM可能同时被多个软件使用，使用引用计数法进行GC</li>
<li>每个COM类都有独一无二的ID，因此内存中可以同时加载多个拥有相同接口的COM类，软件可以自行选择使用哪一个COM类</li>
<li>COM规定了一种特殊的layout，可以被任何支持COM的语言所解析（但可惜的是，支持COM的语言并不多，因此你还是只能用C++去写DX）</li>
<li>COM实际上是由指针和函数表组成（就像C++的虚函数）</li>
</ul>
<h4 id="COM的实现">COM的实现</h4>
<p>COM中所有接口都继承于<code>IUnknown</code>，该接口提供了三个操作</p>
<ul>
<li><code>AddRef</code>：增加引用计数的次数，每次拷贝接口指针时都会执行</li>
<li><code>Release</code>：减少引用计数的次数，当次数为0，释放对象</li>
<li><code>QueryInterface</code>：返回指向该对象的指针</li>
</ul>
<p>不过显式控制COM对象的引用过于困难，C++推荐使用智能指针</p>
<h3 id="DXGI">DXGI</h3>
<p>DirectX Graphics Infrastructure (DXGI)，负责管理一些low-level的任务，比如如何将frame呈现在显示器上，gamma矫正，屏幕刷新，交换链等</p>
<img src="/images/DXGI.png" alt="DXGI" style="zoom:67%;" />
<h3 id="依赖">依赖</h3>
<p>VS添加DX12依赖</p>
<pre class="language-none"><code class="language-none">打开VS--项目--属性--配置属性--链接器--输入--附加依赖项</code></pre>
<p><img src="/images/%E6%B7%BB%E5%8A%A0DX%E4%BE%9D%E8%B5%96.png" alt="image-20230112010632277"></p>
<p>cmake添加依赖</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.20</span><span class="token punctuation">)</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>DXEngine<span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span>

<span class="token keyword">file</span><span class="token punctuation">(</span>GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp src/*.h<span class="token punctuation">)</span>

<span class="token keyword">add_executable</span><span class="token punctuation">(</span>DXEngine <span class="token variable">WIN32</span> <span class="token punctuation">$&#123;</span>srcs<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>DXEngine <span class="token namespace">PUBLIC</span> include<span class="token punctuation">)</span>
<span class="token comment"># 比较重要的是d3d12.lib dxgi.lib</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>DXEngine <span class="token namespace">PRIVATE</span>
        d3d12.lib dxgi.lib dxguid.lib uuid.lib
        kernel32.lib user32.lib
        comdlg32.lib advapi32.lib shell32.lib
        ole32.lib oleaut32.lib
        runtimeobject.lib
        <span class="token punctuation">)</span></code></pre>
<h3 id="批注">批注</h3>
<p>VS提供了一套批注系统，SAL（Source code annotation language）</p>
<h3 id="字符串">字符串</h3>
<p>Windows的字符串是一大噩梦</p>
<p>代码的字符编码主要有两种，<code>ASCII</code>和<code>UNICODE</code>，Windows内部使用了utf-16存储字符串，并支持两种API，用以支持<code>ASCII</code>和<code>UNICODE</code>，他们分布以<code>A</code>和<code>W</code>结尾</p>
<p>为了支持两种API，于是推出了一种新的字符类型<strong>宽字符</strong>：<code>wchat_t</code>，微软将其重命名为<code>WCHAR</code></p>
<p>宽字符在使用时要在前面加<code>L</code>，比如<code>L'a'</code></p>
<p>微软又将字符串进行重命名，提出了窄字符串STR和宽字符串WSTR，并给出了他们的指针<code>LPSTR</code>和<code>LPWSTR</code></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">LPSTR &#x3D; const char*
LPWSTR &#x3D; const wchar_t*</code></pre>
<p>如果你用VS开发，可以设置整个项目使用<code>UNICODE</code>，但我不建议这样做</p>
<p>强烈推荐当你要使用字符串函数时，明确使用后缀是<code>A</code>还是<code>W</code>，并且要注意你<code>WindowProc</code>的类型（是使用<code>DefWindowProcW</code>还是<code>DefWindowProcA</code>）</p>
<h3 id="d3dx12-h">d3dx12.h</h3>
<p>这是一个<code>.h</code>文件，内含许多DX开发常用函数，将该文件复制到项目中</p>
<p>这个文件中使用了大量Windows SDK，因此你最好用VS2019的Toolchains（Clion的用户使用内置的MinGW可能会报一堆错）</p>
<p>至于为什么要求是VS2019，是因为这个文件与Windows10 SDK版本强相关，VS2019的SDK直接就是对应版本，2017需要手动下载，2015直接没法用</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/65294611/d3dx12-h-gives-a-bunch-of-errors">详情</a></p>
<h3 id="创建第一个窗体">创建第一个窗体</h3>
<p>这个窗体啥也没有，就输出一个蓝色屏幕，下面是创建这个窗体的过程</p>
<p><img src="/images/DX%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3.png" alt="DX创建窗口"></p>
<ul>
<li>
<p>WindowProc是一个回调函数，用于处理传给窗口的消息</p>
</li>
<li>
<p><code>OnInt()</code>是<code>D3D12HelloWindow</code>的生命周期函数，包含两个部分，加载管线和加载资源</p>
</li>
</ul>
<p><img src="/images/OnInit.png" alt="OnInit"></p>
<ul>
<li>
<p>描述符堆（Descriptor Heap），用于CPU向GPU传递资源（比如数组、贴图），告诉GPU去哪里访问这些资源</p>
<ul>
<li>描述资源的类型、维度、GPU虚拟地址、硬件信息</li>
<li>我们将描述符绑定在<strong>slots</strong>上，GPU可以通过访问slots上的描述符找到资源</li>
</ul>
</li>
<li>
<p>栅栏（Fence），可以将其插入命令队列以实现同步</p>
</li>
</ul>
<p>DX12支持多线程渲染，命令队列和命令列表的关系如下</p>
<p><img src="/images/DX12%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="DX12多线程"></p>
<h3 id="硬件架构">硬件架构</h3>
<ul>
<li>CPU
<ul>
<li>Cache占绝大部分面积</li>
<li>ALU、控制单元少，但复杂强大</li>
</ul>
</li>
<li>GPU
<ul>
<li>计算核心占绝大部分面积</li>
<li>计算核心数量极多，个头小，可编程，支持并行</li>
</ul>
</li>
</ul>
<p><img src="/images/CPU%E5%92%8CGPU.png" alt="CPU和GPU"></p>
<h3 id="渲染管线">渲染管线</h3>
<p><img src="/images/rendering-pipeline.png" alt="rendering-pipeline"></p>
<h4 id="输入汇编器">输入汇编器</h4>
<p>输入汇编器（Input Assembler）</p>
<ul>
<li>输入：顶点索引和顶点缓冲</li>
<li>行为：组装成图元</li>
<li>输出：传给顶点着色器</li>
</ul>
<p>网格（Mesh）是由图元（通常为三角形）组成的几何体</p>
<p>顶点缓冲区（vertex buffers）存储了顶点相关的数据</p>
<p>输入布局（Input layout）描述了顶点缓冲区的布局，为顶点属性指定语意，使得输入汇编器能读懂顶点缓冲区</p>
<p>索引缓冲（index buffers）内含顶点索引，通过指向顶点缓冲区来组成图元</p>
<p><img src="/images/Mesh.png" alt="Mesh"></p>
<p>原始拓扑（Primitive topologies），描述了图元间的连接、邻接关系</p>
<p><img src="/images/topology.png" alt="topology"></p>
<p>特别的，Triangle Strip的三个顶点满足公式<br>
$$<br>
\Delta_i={i, i+(1+i%2), i+(2-i%2)}<br>
$$</p>
<h4 id="光栅器">光栅器</h4>
<p>光栅器（Rasterizer），发生在片元着色器之前</p>
<ul>
<li>输入：NDC空间的2D图元</li>
<li>行为：
<ul>
<li>剔除：裁剪掉视口外的图元，剔除背面（可选）</li>
<li>画线：获得图元所覆盖的像素区域</li>
<li>插值：根据重心坐标和顶点属性进行插值</li>
</ul>
</li>
<li>输出：传给片元着色器</li>
</ul>
<h3 id="资源管理">资源管理</h3>
<h4 id="内存">内存</h4>
<p>GPU可以访问四种内存</p>
<ul>
<li>专用视频内存（Dedicated video memory）：我们分配GPU资源最常用的地方</li>
<li>专用系统内存（Dedicated system memory）：GPU内部专用内存，应用程序不能使用</li>
<li>共享系统内存（Shared system memory）：CPU可见的显存，常用于CPU向GPU传递数据</li>
<li>CPU系统内存（CPU system memory）：CPU可以任意访问，但GPU要通过PCI-e总线访问，速度极慢</li>
</ul>
<h4 id="视图和描述符">视图和描述符</h4>
<p>视图=描述符≈资源指针</p>
<table>
<thead>
<tr>
<th>简称</th>
<th>全称</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CBV</td>
<td>Constant buffer view</td>
<td>描述常量缓冲区</td>
</tr>
<tr>
<td>UAV</td>
<td>Unordered access view</td>
<td>常用于多线程读写</td>
</tr>
<tr>
<td>SRV</td>
<td>Shader resource view</td>
<td>描述只读纹理和缓冲区</td>
</tr>
<tr>
<td>Samplers</td>
<td></td>
<td>采样器</td>
</tr>
<tr>
<td>RTV</td>
<td>Render Target View</td>
<td>描述渲染目标</td>
</tr>
<tr>
<td>DSV</td>
<td>Depth Stencil View</td>
<td>描述深度缓冲区</td>
</tr>
<tr>
<td>IBV</td>
<td>Index Buffer View</td>
<td>描述顶点索引缓冲区</td>
</tr>
<tr>
<td>VBV</td>
<td>Vertex Buffer View</td>
<td>描述顶点缓冲区</td>
</tr>
<tr>
<td>SOV</td>
<td>Stream Output View</td>
<td>描述流输出缓冲区</td>
</tr>
</tbody>
</table>
<h4 id="资源状态">资源状态</h4>
<p>资源的多线程读写是冲突的，于是要通过资源状态实现互斥</p>
<p>GPU使用转化资源的状态来指定资源的预期用途，比如要读一张贴图，该贴图必须处于读取状态</p>
<p>DX12使用<code>ResourceBarrier</code>管理资源状态</p>
<h4 id="根签名">根签名</h4>
<p>在HLSL中，我们可以声明一个变量</p>
<pre class="language-hlsl" data-language="hlsl"><code class="language-hlsl"><span class="token class-name">Texture2D</span> g_texture <span class="token operator">:</span> <span class="token keyword">register</span><span class="token punctuation">(</span>t0<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>该变量的类型是SRV，绑定到<code>t</code>的第0槽</p>
<ul>
<li><code>t</code>：SRV</li>
<li><code>s</code>：Samplers</li>
<li><code>u</code>：UAV</li>
<li><code>b</code>：CBV</li>
</ul>
<h3 id="管道状态">管道状态</h3>
<p>管道状态（pipeline state object ，PSO）定义了渲染管线的每个阶段的行为，PSO创建后不可变</p>
<p><img src="/images/PSO.png" alt="PSO"></p>
<h3 id="Bundles">Bundles</h3>
<p>捆绑包（Bundles），用于将少量命令组合在一起，方便使用</p>
<p>Bundles只能提交给CommandList，不能直接提交给命令队列</p>
<h3 id="常量缓冲区">常量缓冲区</h3>
<p>就是CBuffer，是一种访问延迟更低，适合CPU高频更新的缓冲区</p>
<p>在着色器程序执行期间，常量缓冲区不会发送改变</p>
<p>常量缓冲区需要256字节<strong>对齐</strong>，一般使用4KB或者64KB（关于为什么要对齐、什么是假引用、缓存行，可以去看《高性能C++》笔记）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/graphics/DX12%E7%AC%94%E8%AE%B01/" data-id="clepy40o30009glnkfkl02tbc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DX12/" rel="tag">DX12</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-graphics/TA面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/graphics/TA%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/graphics/TA%E9%9D%A2%E8%AF%95%E9%A2%98/">TA面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>TA面试题</h1>
<p>这里面不少答案都是我自己凭感觉答的，不保真</p>
<h4 id="什么是渲染管线">什么是渲染管线</h4>
<p><strong>渲染管线</strong>是通过安排CPU发出Draw Call的内容以及顺序，指导GPU进行一系列操作，并协同将开发者期待的图像渲染在屏幕上</p>
<ul>
<li>剔除</li>
<li>渲染</li>
<li>后处理</li>
</ul>
<h4 id="什么是Draw-Call">什么是Draw Call</h4>
<p>Draw Call是CPU为GPU准备渲染数据，并指令GPU进行一次渲染的操作，是重量级的</p>
<h4 id="什么是Batching">什么是Batching</h4>
<p>将多个简单、使用同一材质的物体合并渲染的方式叫Batching</p>
<p><em>batch是批的意思</em></p>
<h4 id="渲染管线的渲染流程">渲染管线的渲染流程</h4>
<ul>
<li>
<p>延迟着色阶段（光栅化）Deferred Shading (rasterization)</p>
</li>
<li>
<p>直接阴影阶段（光线追踪或光栅化）Direct shadows (ray trace or rasterization)</p>
</li>
<li>
<p>光照阶段（计算着色器+光线追踪）Lighting (compute + ray trace)</p>
</li>
<li>
<p>反射阶段（光线追踪或计算着色器）Reflections(ray trace or compute)</p>
</li>
<li>
<p>全局光照阶段（计算着色器+光线追踪）Global Illumination (compute and ray trace)</p>
</li>
<li>
<p>环境光遮蔽阶段（光线追踪或计算着色器） Ambient occlusion (ray trace or compute)</p>
</li>
<li>
<p>透明与半透明渲染阶段（光线追踪+计算着色器）Transparency &amp; Translucency (ray trace and compute)</p>
</li>
<li>
<p>后处理阶段（计算着色器）Post processing (compute)</p>
</li>
</ul>
<h4 id="渲染流水线的基本流程">渲染流水线的基本流程</h4>
<p>渲染就是从一个三维场景出发，获得一个二维图像的过程。分为四个过程，应用阶段、几何阶段、光栅化阶段、像素处理阶段，其中几何阶段光栅化阶段主要在GPU中进行。</p>
<p>几何阶段分为五个步骤：顶点着色器、曲面细分着色器、几何着色器、裁剪、屏幕映射</p>
<p>光栅化阶段分为四个步骤：三角形设置、三角形遍历、片元着色器、逐片元操作</p>
<img src="/images/pipeline.png" alt="1" style="zoom:33%;" />
<h5 id="什么是顶点着色器">什么是顶点着色器</h5>
<ul>
<li>
<p>输入值是CPU通过Draw Call发出的顶点数组（没有索引）</p>
</li>
<li>
<p>输出值是齐次裁剪空间坐标（如果不使用细分着色器和几何着色器）</p>
</li>
</ul>
<h5 id="什么是细分着色器">什么是细分着色器</h5>
<ul>
<li>
<p>在显卡中**视口变换器(Viewport Transform)**中实现</p>
</li>
<li>
<p>将复杂的曲面转化为简单的点、线、三角形，可以增加网格细度，并在细分后的顶点上生成插值属性</p>
</li>
<li>
<p>如果使用了曲面细分着色器，顶点着色器就不会处理空间变化（如果没有顶点动画的需求，顶点着色器只负责传递数据），而是交给曲面着色器和几何着色器</p>
</li>
<li>
<p>在不改变网格外形的情况下，对网格进行平滑操作</p>
</li>
</ul>
<h5 id="什么是几何着色器">什么是几何着色器</h5>
<ul>
<li>在视口变换器中实现，输出值是齐次裁剪空间</li>
<li>能改变顶点数量</li>
<li>能按索引访问顶点</li>
</ul>
<h5 id="什么是网格着色器">什么是网格着色器</h5>
<ul>
<li>新一代三合一着色器，用于整合顶点、细分、几何着色器</li>
<li>可以实现无矩式渲染</li>
</ul>
<h5 id="屏幕映射">屏幕映射</h5>
<ul>
<li>输入齐次裁剪空间</li>
<li>（通过透视除法）转化到<strong>归一化设备坐标(NDC)</strong>，最后输出屏幕空间坐标</li>
</ul>
<h4 id="什么是渲染路径">什么是渲染路径</h4>
<p><strong>渲染路径</strong>是一系列对光照和着色(尤其是光照)的控制选项的集合</p>
<p>主流引擎支持前向渲染，延迟渲染，和自定义渲染</p>
<ul>
<li>前向渲染
<ul>
<li>批次数=相机数x对象数x（除了主有向平行光外的逐片元光照数+1）</li>
<li>随着片元光照数量增多，性能大幅下降</li>
</ul>
</li>
<li>延迟渲染
<ul>
<li>类似一种后处理</li>
<li>批次数=相机数x（网格数+逐片元光照数）</li>
<li>将几何通路和光照渲染通路分开，几何通道结果输送到G-Buffer中，然后对每个像素只进行一次光照计算</li>
</ul>
</li>
<li>自定义渲染
<ul>
<li>屏幕后处理、天空盒、透明物体</li>
</ul>
</li>
</ul>
<h4 id="延迟渲染">延迟渲染</h4>
<h5 id="为什么延迟渲染不支持透明度混合">为什么延迟渲染不支持透明度混合</h5>
<p>因为半透明网格在G-Buffer中会被其他片元覆盖</p>
<h5 id="为什么延迟渲染不支持真的对抗锯齿">为什么延迟渲染不支持真的对抗锯齿</h5>
<p>因为G-Buffer需要的带宽远远大于帧缓冲，在多重抗锯齿下难以满足负载</p>
<h4 id="前向渲染">前向渲染</h4>
<p>前向渲染的渲染通路（Pass）有两种，分布是<strong>基本通路（forwardbase）<strong>和</strong>附加通路（forwardadd）</strong></p>
<p><strong>forwardbase</strong></p>
<ul>
<li>对所有的默认的<strong>有向平行光源</strong>及其产生的阴影进行逐片元计算，同时对其它基于顶点的和基于球谐光照的光源，以及物体的自发光、统一环境光和光照贴图进行计算</li>
<li>只对一个有效灯光执行一次，所以只会执行一次</li>
</ul>
<p><strong>forwardadd</strong></p>
<ul>
<li>对剩下的<strong>使用逐片元光照的光源</strong>进行光照计算</li>
<li>必须和forwardbase一同使用，不然会被忽略掉</li>
<li>对forwardbase外所有有效灯光都执行一次，所以会执行多次</li>
</ul>
<h4 id="向量">向量</h4>
<h5 id="向量点乘叉乘的几何意义">向量点乘叉乘的几何意义</h5>
<p>点乘是投影，叉乘是法向量（方向符合右手定则，沿大拇指方向）</p>
<h5 id="向量点乘叉乘的数学意义">向量点乘叉乘的数学意义</h5>
<p>$\mathbf{a} =\left( x_{1},y_{1},z_{1}\right)  $</p>
<p>$\mathbf{b} =\left( x_{2},y_{2},z_{2}\right)  $</p>
<p>$\mathbf{a} \cdot \mathbf{b} =|\mathbf{a} ||\mathbf{b} |\cos \theta =x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}$</p>
<img src="/images/叉积.png" alt="叉积" style="zoom: 67%;" />
<h5 id="求向量-mathbf-a-关于向量-mathbf-b-的对称向量-mathbf-c">求向量$\mathbf{a}$关于向量$\mathbf{b}$的对称向量$\mathbf{c}$</h5>
<p>$\mathbf{a} \cdot \mathbf{b}=\mathbf{c} \cdot \mathbf{b}$</p>
<p>$|\mathbf{a} |=|\mathbf{c} |$</p>
<h5 id="求点M关于直线l的对称点N">求点M关于直线l的对称点N</h5>
<p>M和N的中点在直线上</p>
<p>$\overrightarrow{MN} $与直线垂直</p>
<h4 id="欧拉角是什么？有何优缺点">欧拉角是什么？有何优缺点</h4>
<p>欧拉角是一个直观利用三维向量表达旋转的方法</p>
<p>优点：占用的空间小，不会遇到非法输入</p>
<p>缺点：没有统一标准、不能跨平台；三个分量可能不正交，可能有无法表示的角度；不能插值运算</p>
<h4 id="图形渲染用到哪些空间">图形渲染用到哪些空间</h4>
<ul>
<li>顶点着色器：模型空间–M–世界空间–V–观察空间–P–齐次裁剪空间----屏幕空间</li>
</ul>
<h4 id="什么是模版测试">什么是模版测试</h4>
<p>将屏幕的部分像素通过一个通道盖住，在渲染时剔除通道上不满足条件的值</p>
<h4 id="如何渲染半透明物体">如何渲染半透明物体</h4>
<ul>
<li>透明度测试</li>
<li>透明度混合</li>
</ul>
<h4 id="如何优化着色器代码">如何优化着色器代码</h4>
<ul>
<li>复杂计算放在顶点着色器中</li>
<li>简化等式，比如说：p = sqrt(2*(X+1))可以改写成1.414*sqrt(X+1)等</li>
<li>尽量使用内建函数</li>
<li>重复度低的操作可以交给CPU</li>
<li>使用顺序结构代替分支</li>
<li>丢弃片元时直接将alpha设为0</li>
<li>纹理图尽量使用2的n次方大小</li>
<li>将许多小纹理拼成一个大纹理</li>
<li>近点采样能满足要求就不要使用线性采样</li>
</ul>
<h4 id="如何判断多边形是凸多边形">如何判断多边形是凸多边形</h4>
<ul>
<li>角度法：内角是否小于180°</li>
<li>凸包法：如果凸包和原始多边形点数一样多，那么就是凸多边形</li>
<li>顶点凹凸性：本质上还是角度法，就是相邻顶点组成向量叉乘</li>
</ul>
<h4 id="相交测试">相交测试</h4>
<p><em>见图形学笔记</em></p>
<h4 id="法线贴图">法线贴图</h4>
<p>纹理就是贴图</p>
<p>法线纹理用RGB三个通道分布存储法向量在XYZ轴上分量大小</p>
<p>由于法线贴图大部分文素的方向都是朝向法线方向，于是法线贴图大多是蓝色的</p>
<h4 id="如何渲染阴影">如何渲染阴影</h4>
<ul>
<li>体积阴影法</li>
<li>深度阴影法</li>
</ul>
<h4 id="什么是HDR">什么是HDR</h4>
<p>高动态范围，一种颜色缓冲技术，使用更高的精度来表示亮度，能更真实的反应光照</p>
<p>HDR通过色调映射转到LDR</p>
<h4 id="什么是伽马矫正">什么是伽马矫正</h4>
<p>早期摄像机通过伽马加码，将实际亮度存储为更亮的值，显示时通过该骂解码获得正确的功率</p>
<h4 id="什么是色调映射">什么是色调映射</h4>
<p>就是利用显示器有限的亮度范围来近似实现HDR，就是将亮度映射到[0,1]的范围内，并压缩到8位的渲染目标上</p>
<h4 id="什么是PBR">什么是PBR</h4>
<p>基于物理的渲染</p>
<h4 id="正交投影和透视投影的区别">正交投影和透视投影的区别</h4>
<ul>
<li>都是源于对针孔摄像机对数学建模</li>
<li>视锥形状不一样</li>
</ul>
<h4 id="什么是齐次坐标">什么是齐次坐标</h4>
<p>为了实现仿射变换，将三维顶点引入四维空间，这个空间叫做齐次坐标空间</p>
<h4 id="旋转平移矩阵">旋转平移矩阵</h4>
<p><em>见图形学笔记</em></p>
<h4 id="高光模型">高光模型</h4>
<p>漫反射模型</p>
<ul>
<li>Lambert模型：反射光强度和 表面法线和光源的夹角的 余弦值成正比</li>
<li>半Lambert模型：光照有一个保底值，于是没有黑面</li>
<li>Minnaert模型：用于模拟丝绒</li>
<li>Oren-Nayar模型：风之旅人的沙子</li>
</ul>
<p>高光反射模型</p>
<ul>
<li>Phong模型：纯几何的经验模型，就是在Lambert漫反射上加了一点高光，强度与 视角方向和反射光方向的夹角的 余弦值成正比</li>
<li>Blinn-Phong模型：Phong的改进，不计算反射光，而是计算视角方向和光源方向的角平分矢量h，用h替代反射方向计算高光</li>
<li>Schlick模型：对BP模型的优化，简化一些运算，能获得更类似于油漆的效果</li>
</ul>
<p>基于物理的模型</p>
<ul>
<li>Cook-Torrance模型</li>
</ul>
<h4 id="什么是光栅化">什么是光栅化</h4>
<p>是渲染流水线的一个重要阶段</p>
<p>三角形设置和三角形遍历可以合成光栅化，计算三角网格，并进行线性插值</p>
<h4 id="阴影，软阴影">阴影，软阴影</h4>
<h4 id="什么是抗锯齿">什么是抗锯齿</h4>
<p>锯齿是走样的一种，指在渲染三角形、线的时候，像素要么存在，要么不存在，于是出现锯齿现象</p>
<ul>
<li>SSAA，超级采样抗锯齿，翻倍渲染向下采样</li>
<li>MSAA，多重采样抗锯齿，每个像素内有多个采样点，渲染时以点数加权获得（性能好，不支持延迟渲染）</li>
<li>FXAA/TXAA，放弃精度，让边缘模糊</li>
</ul>
<h4 id="延时渲染">延时渲染</h4>
<p>场景中有大量实时光源时，前向渲染效率会下降，使用两个Pass，一个不计算光照，只计算片元是否可见</p>
<p>不支持抗锯齿，不能处理透明物体</p>
<h4 id="故障检测">故障检测</h4>
<h4 id="后处理">后处理</h4>
<ul>
<li>亮度饱和度对比度</li>
<li>边缘检测</li>
<li>高斯模糊</li>
<li>动态模糊</li>
<li>Bloom效果</li>
</ul>
<h4 id="贴图技术">贴图技术</h4>
<p>贴图就是纹理</p>
<h4 id="BRDF">BRDF</h4>
<p>双向反射分布函数</p>
<h4 id="作品集里实现原理">作品集里实现原理</h4>
<p>ezy-slice原理：网格中存储了顶点数据、三角形数据、法线数据，使用MeshFilter获得sharemesh（mesh是新网格，sharemesh是原始网格）</p>
<p>物体的节点和三角形被分为三个部分（上下和切割面），相交处的三角形做分割操作，然后让原始网格不可见</p>
<h4 id="如何区分位置和方向">如何区分位置和方向</h4>
<p>齐次坐标，w==0就是位置，w==1就是方向</p>
<h4 id="SSAO">SSAO</h4>
<p>SS（Screen Space），都是后处理</p>
<p>SSGI屏幕空间全局光照</p>
<p>SSAO屏幕空间环境光遮蔽，对屏幕空间上每一个片元，在其法线范围的半球体中进行采样，采样点在深度纹理采样，从而判断该点是否被遮蔽</p>
<p>一般来说使用SSAO后还要在进行一次模糊，还需要进行时域平滑来避免闪动</p>
<h4 id="SSR">SSR</h4>
<p>SSR屏幕空间反射，在相机中发射出n条光线，然后根据物体的法向量和摄像机的射线方向计算出这条光线的反射方向。再对他进行raymarch（光线步进）计算。</p>
<h4 id="动态模糊">动态模糊</h4>
<p>种类</p>
<ul>
<li>相机动态模糊</li>
<li>对象动态模糊</li>
</ul>
<p>原理</p>
<ul>
<li>保存多帧数据进行混合</li>
<li>速度映射图，图中存储了每一个像素的速度，沿着这个速度采集像素，进行加权混合，得到模糊效果</li>
</ul>
<h4 id="线框">线框</h4>
<h5 id="方法1-深度偏移（这玩意不是线框，是描边）">方法1:深度偏移（这玩意不是线框，是描边）</h5>
<p>使用两个Pass渲染，一个正常渲染，一个在深度偏移的情况下渲染一遍线</p>
<ul>
<li>两个Pass有性能损失</li>
<li>深度偏移是为了防止线条被遮挡，这会导致多边形和线框在相同位置的片元的深度值不一样</li>
</ul>
<h5 id="方法2-几何着色器（这才是线框）">方法2:几何着色器（这才是线框）</h5>
<p>几何着色器可以使用索引数组访问顶点的拓扑结构</p>
<p>线框渲染可以使用几何着色器访问三角形，并计算每个顶点到对边的垂线长度，于是通过插值获得三角形中每个点到三角形三个边的最短距离</p>
<p>我们知道在光栅化阶段要插值上色，那么我们可以在插值的时候进行判断，当垂线距离符合条件时（离三角形边特别近）就染上线框的颜色</p>
<h4 id="片元着色器和像素着色器的区别">片元着色器和像素着色器的区别</h4>
<p><em>在大部分情况下没有区别</em></p>
<p>在极个别情况下（大概是OpenGL那边）我门认为如果片元着色器中的输入数据是恰好覆盖屏幕的四边形时，这个片元着色器被称为像素着色器</p>
<h4 id="SDF">SDF</h4>
<p>距离函数</p>
<p>shadertoy的本质就是通过编写（2D）距离函数来绘制物体</p>
<h4 id="为什么shader中少用分支和循环">为什么shader中少用分支和循环</h4>
<p>因为在gpu中，分支的实现原理是两个分支都执行，然后丢弃不需要的分支，这个增长是指数级的（2^n^）</p>
<h4 id="什么是Cubemap">什么是Cubemap</h4>
<p>立方体纹理，是实现环境映射的一种方法</p>
<h4 id="什么是光照探针">什么是光照探针</h4>
<p>是一组封装后的Cubemap，在烘培或预计算时，对空间中的一些采样点（光照探针）采集Cubemap，在运行环境渲染运动物体时，CPU会从离物体最近的光照探针中获取Cubemap，按照距离进行插值。</p>
<p>这个过程实现了CPU和GPU的解耦，CPU只需要维护一组固定的光照探针组，GPU只需要处理与这个物体相关的临近Cubemap</p>
<p>通过光照探针获取环境景象需要对场景进行六次渲染（毕竟有六个面）</p>
<h4 id="什么是球偕函数">什么是球偕函数</h4>
<p>将真实环境中连续的光照方程进行离散化，通过球形坐标系分解简化反射方程，通过球偕变换获得球偕系数，在运行时根据球偕系数重建方程</p>
<p>采样-分解-变换-重构</p>
<h4 id="参数和分量">参数和分量</h4>
<p>参数是黑盒，分量是白盒（你可以理解的是，别人在unity面板上拖动的属性多半是参数，一种东西的组成是分量，比如颜色可能就有由高光、漫反射等分量）</p>
<h4 id="为什么次表面散射用漫反射做高斯模糊">为什么次表面散射用漫反射做高斯模糊</h4>
<p>因为lambert的光照强度与入射光线和法线夹角有关，而折射和反射的比例也与这个夹角有关（菲涅尔）</p>
<p>折射光是次表面散射的入射光，折射的光越强，散射的光也会越强</p>
<h4 id="什么是光线步进">什么是光线步进</h4>
<p><strong>光线步进（raymarching）</strong>：从摄像机位置向屏幕每一个像素点发射一条光线，光线按照一定步长前进，并检测当前光线是否位于物体表面，据此调整光线前进幅度，直到抵达物体表面，再按照一般光线追踪的方法计算颜色值。</p>
<h4 id="什么是MC算法">什么是MC算法</h4>
<p>**步进立方体算法（Marching Cube）**是一种在密度场中采样来生成多边形的算法，在生成多边形之后再依照多边形渲染的过程进行正常的渲染。 相比射线扫描算法，步进立方体算法可以生成并保存多边形，所以在密度场的修改频率不高的情况下，使用步进立方体算法可以节省很多不必要的性能消耗。</p>
<p>核心：确定等值面</p>
<h4 id="什么是屏幕空间阴影纹理">什么是屏幕空间阴影纹理</h4>
<p>对于多光源的情况，每个光源都可以产生一个深度阴影纹理。在着色器中对这些深度阴影纹理逐个进行处理，可以得到若干个屏幕空间的阴影纹理，将这些屏幕空间下的阴影纹理混合就可得到一个总的屏幕空间阴影纹理，它表示了在屏幕空间中某个片元接受到的来自所有光源产生的阴影强度的总和</p>
<h4 id="什么是URP">什么是URP</h4>
<p>unity内的**渲染管线（Render pipelines）**包括</p>
<ul>
<li>内置渲染管线（Build-in）</li>
<li>可编程渲染管线（Scriptable Render Pipeline，SRP）
<ul>
<li>高清渲染管线（High Definition Render Pipeline，HDRP）</li>
<li>通用渲染管线（Universal Render Pipeline，URP）</li>
</ul>
</li>
</ul>
<h4 id="什么是滤波模式">什么是滤波模式</h4>
<p>纹素坐标是整数值，但UV坐标不是，所以要有一种方法由UV坐标获得纹素值</p>
<h5 id="最近相邻滤波-Nearest-neighbor-filtering，或者Point-sampling">最近相邻滤波(Nearest neighbor filtering，或者Point sampling)</h5>
<ul>
<li>
<p>UV坐标 x 纹理大小，然后四舍五入取最近的纹素</p>
</li>
<li>
<p>有明显的像素块</p>
</li>
</ul>
<h5 id="双线性滤波-Bilinear-filtering，或者liner-filtering">双线性滤波(Bilinear filtering，或者liner filtering)</h5>
<ul>
<li>根据一个坐标到其附近最近的四个像素点的距离进行加权平均，得到一个混合的颜色</li>
</ul>
<img src="/images/双线性滤波.png" alt="双线性滤波" style="zoom: 33%;" />
<h5 id="三线性滤波-Trilinear-filtering">三线性滤波(Trilinear filtering)</h5>
<ul>
<li>在相邻的两个Mipmap层次上分别进行双线性滤波，再对得到的两个值进行线性插值</li>
<li>当距离非常大或非常小的时候，三线性滤波会退化为双线性滤波</li>
</ul>
<h5 id="各项异性滤波-Anisotropic-filtering">各项异性滤波(Anisotropic filtering)</h5>
<p>当一个目标表面和透视摄像机之间的角度较大时，纹理的填充面积实际上并不是正方形，这引入了模糊和闪烁等瑕疵</p>
<ul>
<li>需要在一个非正方形区域内采样和混合</li>
<li>有的使用长方形，有的使用梯形</li>
</ul>
<h4 id="什么是纹理映射">什么是纹理映射</h4>
<p><em>就是将三维的空间坐标点转化为二维的纹理坐标点</em></p>
<p><strong>步骤</strong>：</p>
<ol>
<li>投影映射</li>
<li>变换函数</li>
<li>纹理采样</li>
<li>纹理转换</li>
</ol>
<h4 id="什么是纹理压缩">什么是纹理压缩</h4>
<p>这是一种有损压缩，对于一张原始纹理，会创建两张小纹理A和B，同时还有一个矩阵M，M的行列和原始纹理的长宽一致，里面的值类似于调色板中的索引，实现纹理A和纹理B的混合</p>
<h4 id="GPU的寻址方式">GPU的寻址方式</h4>
<h5 id="集成显卡">集成显卡</h5>
<p>对集成显卡来说，GPU使用CPU专门划分出来的一份内存空间**UMA（Unified Memory Architecture，一致性储存架构）**作为显存，GPU和CPU使用不同的虚拟地址对UMA中同一个物理地址进行寻址，两者共享总线。</p>
<p>在渲染时，CPU将顶点数据存储到主存中，然后GPU通过**GART(Graphic Address Remapping Table，显存地址重定位表)**访问UMA</p>
<h5 id="独立显卡">独立显卡</h5>
<p>独立显卡中CPU和显卡的沟通是使用异步的**DMA(Direct Memory Access，内存直接访问)**实现的。</p>
<ol>
<li>CPU将DMA命令从内存中读取，并写入DMA控制器</li>
<li>DMA控制器直接操控内存总线，在不依赖CPU的情况下将数据传输给显卡驱动</li>
<li>显卡驱动给DMA控制器发送信息（握手）</li>
<li>DMA占用内存总线，向内存请求地址，向显卡发送信号</li>
<li>显卡接受信号后将数据传输到内存，并清除DMA请求信号</li>
<li>沟通结束，触发一次CPU中断</li>
</ol>
<h4 id="CPU和GPU分支预测方式有何差别">CPU和GPU分支预测方式有何差别</h4>
<h5 id="CPU">CPU</h5>
<p>CPU在流水线中进行分支预测</p>
<ul>
<li>静态分支预测</li>
<li>动态分支预测</li>
<li>协同分支预测</li>
</ul>
<h5 id="GPU">GPU</h5>
<p>将两个结果都运行一次，然后丢弃不需要的分支，这样会严重影响性能（指数级），这个现象被称为<strong>线路分歧</strong></p>
<h4 id="纹理数据在GPU中是如何排列的">纹理数据在GPU中是如何排列的</h4>
<p>纹理存储器中的数据以一维/二维/三维数组的形式存储在显存中，可以通过缓存加速访问</p>
<p>在kernel中访问纹理存储器的操作称为<strong>纹理拾取(texture fetching)</strong></p>
<p>将显存中的数据与纹理参照系关联的操作，称为将数据与<strong>纹理绑定(texture binding)</strong></p>
<h4 id="shader中的变量类型（OpenGL）">shader中的变量类型（OpenGL）</h4>
<h5 id="uniform">uniform</h5>
<p>在顶点着色器和片元着色器中的声明方式完全一样，可以视为被双方共享的全局变量</p>
<h5 id="attribute">attribute</h5>
<p>只能在顶点着色器中使用的变量，一般用于存储顶点的位置、法线、uv、颜色信息</p>
<h5 id="varying">varying</h5>
<p>顶点着色器和片元着色器之间做数据传输用的变量，必须保证在两者中声明保持一致</p>
<h4 id="如何保证顶点着色器传入片元着色器的数据一致性">如何保证顶点着色器传入片元着色器的数据一致性</h4>
<p>varying变量声明一致？</p>
<h4 id="矩阵乘法">矩阵乘法</h4>
<p>两条直线的交点就是C的位置</p>
<img src="/images/矩阵乘法.png" alt="矩阵乘法" style="zoom:50%;" />
<p>x左乘A</p>
<p><img src="/images/x%E5%B7%A6%E4%B9%98A.png" alt="x左乘A"></p>
<p>x右乘A</p>
<img src="/images/x右乘A.png" alt="x右乘A" style="zoom:50%;" />
<h4 id="直线扫描转化法">直线扫描转化法</h4>
<h5 id="数值微分法DDA">数值微分法DDA</h5>
<p>思想：步进和通过舍入选择像素</p>
<p>$P_{0}(0,0)$到$P_{1}(5,2)$</p>
<p>k=0.4</p>
<table>
<thead>
<tr>
<th>$i$</th>
<th>$x_{i}=x_{i-1}+1$</th>
<th>$y_{i}=y_{i-1}+k$</th>
<th>$round(y_{i})$</th>
<th>坐标</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>(0,0)</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0+0.4=0.4</td>
<td>0</td>
<td>(1.0)</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0.4+0.4=0.8</td>
<td>1</td>
<td>(2,1)</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>0.8+0.4=1.2</td>
<td>1</td>
<td>(3,1)</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>1.2+0.4=1.6</td>
<td>2</td>
<td>(4,2)</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>1.6+0.4=2.0</td>
<td>2</td>
<td>(5,2)</td>
</tr>
</tbody>
</table>
<h5 id="中点画线法">中点画线法</h5>
<p>相比于DDA算法，省去了浮点数运算</p>
<p>直线方程$F(x,y)=Ax+By+C=0$，若$F(x,y)&gt;0$则位于直线上方，若$&lt;0$则位于直线下方，若$=0$则在点上</p>
<p>使用步进思想，根据<strong>中点误差项</strong>判断是向右移动还是向右上移动（如果0&lt;k&lt;1)</p>
<img src="/images/中点画线.png" alt="中点画线" style="zoom: 33%;" />
<p>直线已经经过点$P$，下一步经过了点$P_{u}$和$P_{d}$，他们的中点是M，我们将M带入直线方程，通过判断大小来决定是不是</p>
<p>为了进一步降低消耗，使用步进，每一次就将点$P(x_{i}+1,y_{i}+0.5)$带入直线方程$Ax+By+C=0$</p>
<ul>
<li>
<p>d&lt;0就取右边的点，$d_{i+1}=d_{i}+A+B$</p>
</li>
<li>
<p>d&gt;0就取右上的点，$d_{i+1}=d_{i}+A$</p>
</li>
</ul>
<p>只不过我们只关心符号，所以可以用2d代替d</p>
<ul>
<li>
<p>d&lt;0就取右边的点，$d_{i+1}=d_{i}+2A+2B$</p>
</li>
<li>
<p>d&gt;0就取右上的点，$d_{i+1}=d_{i}+2A$</p>
</li>
</ul>
<h5 id="Bresenham画线法">Bresenham画线法</h5>
<p>本质上和中点画线一样</p>
<ul>
<li>
<p>$d_{i}&lt;0$就取右边的点，$d_{i+1}=d_{i}+2\Delta y$</p>
</li>
<li>
<p>$d_{i}\geqslant 0$就取右上的点，$d_{i+1}=d_{i}+2\Delta y-2\Delta x$</p>
</li>
<li>
<p>$d_{1}=2\Delta y-\Delta x$</p>
</li>
</ul>
<p>$P_{0}(0,0)$到$P_{1}(5,2)$</p>
<p>k=0.4</p>
<p>$\Delta y=2$</p>
<p>$\Delta x=5$</p>
<table>
<thead>
<tr>
<th>$i$</th>
<th>$d_{i}$</th>
<th>$x_{i}$</th>
<th>$y_{i}$</th>
<th>坐标</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>(0,0)</td>
</tr>
<tr>
<td>1</td>
<td>$d_{1}=2\Delta y-\Delta x=-1&lt;0$</td>
<td>1</td>
<td>0</td>
<td>(1.0)</td>
</tr>
<tr>
<td>2</td>
<td>$d_{2}=d_{1}+2\Delta y=3&gt;0$</td>
<td>2</td>
<td>1</td>
<td>(2,1)</td>
</tr>
<tr>
<td>3</td>
<td>$d_{3}=d_{2}+2\Delta y-2\Delta x=-3&lt;0$</td>
<td>3</td>
<td>1</td>
<td>(3,1)</td>
</tr>
<tr>
<td>4</td>
<td>$d_{4}=d_{3}+2\Delta y=1&gt;0$</td>
<td>4</td>
<td>2</td>
<td>(4,2)</td>
</tr>
<tr>
<td>5</td>
<td>$d_{5}=d_{4}+2\Delta y-2\Delta x=-5&lt;0$</td>
<td>5</td>
<td>2</td>
<td>(5,2)</td>
</tr>
</tbody>
</table>
<h4 id="构建贝塞尔曲线">构建贝塞尔曲线</h4>
<h5 id="一阶">一阶</h5>
<p>两个点$P_{0},P_{1}$</p>
<p>直接坐标线形插值</p>
<p>$B_{1}(t)=(1-t)P_{0}+tP_{1}$</p>
<h5 id="二阶">二阶</h5>
<p>三个点$P_{0},P_{1},P_{2}$</p>
<p>先求$P_{0}P_{1}$和$P_{1}P_{2}$的一阶贝塞尔，然后再对两个一阶进行线性插值</p>
<h5 id="n阶">n阶</h5>
<p>$$<br>
B_{i,n}\left( t\right)  =\frac{n!}{i!\left( n-i\right)  !} t^{i}\left( 1-t\right)^{n-i}<br>
$$</p>
<ul>
<li>$i$是第几项，从0开始</li>
<li>$n$是控制点总数</li>
</ul>
<h4 id="线段的裁剪">线段的裁剪</h4>
<h5 id="Cohen-Sutherland">Cohen-Sutherland</h5>
<p>尽量避免求交运算</p>
<p>编码，把空间分为九个部分，其中中间部分是屏幕，其outcode编码为</p>
<img src="/images/裁剪.png" alt="裁剪" style="zoom:50%;" />
<p>判断时，两个端点的outcode值为$o_{1}和o_{2}$</p>
<ul>
<li>若$o_{1}=o_{2}=0（其实是0000）$：说明两个点都在屏幕中间</li>
<li>若$o_{1}\neq 0,o_{2}=0（12顺序可以颠倒）$：说明一个在屏幕内，一个在屏幕外，而非零端点的编码说明了线段与裁剪窗口哪一个边（或者两个边）相交，需要计算交点</li>
<li>若$o_{1}&amp;o_{2}\neq 0$：说明两个点在裁剪窗口的同一侧，可以直接丢弃</li>
<li>若$o_{1}&amp;o_{2}= 0$：需要计算交点</li>
</ul>
<h5 id="Liang-Barsky">Liang-Barsky</h5>
<img src="/images/梁友栋.png" alt="梁友栋" style="zoom: 25%;" />
<p>窗口$Wx_{l}=0,Wx_{r}=4,Wy_{b}=0,Wy_{t}=3$</p>
<p>直线：<br>
$$<br>
\begin{cases}x=-2+u\left( 7+2\right)  &amp;\ y=6+u(-2-6)&amp;\end{cases}<br>
$$</p>
<p>$$<br>
\begin{cases}u_{1}=2/9&amp;\ u_{2}=2/3&amp;\ u_{3}=3/4&amp;\ u_{4}=3/8&amp;\end{cases}<br>
$$</p>
<p>$u_{max}=\max(0,2/9,3/8)=3/8$</p>
<p>$u_{min}=\min(1,2/3,3/4=2/3)$</p>
<p>所以保留$u_{2}u_{4}$，其中$u_{2}=(4,2/3)\ u_{4}=(11/8,3)$</p>
<h3 id="Early-z">Early-z</h3>
<p>在vertex后，fragment前做一次深度测试，如果失败，则不进行fragment（如果成功，还是要在fragment中做ZTest），这样可以大幅提高性能</p>
<p>开启AlphaTest需要关闭Early-Z，因为AlphaTest通过会写入深度值，而新写入的深度值无法通过Early-Z，于是本该输出的颜色被剔除了（现在硬件做了优化，可以更智能的自动开关Early-Z）</p>
<h3 id="什么是球面度">什么是球面度</h3>
<p><strong>球面度sr</strong>是立体角的国际单位（平面角的单位是<strong>角度/弧度</strong>），可以理解为三维的弧度</p>
<ul>
<li>
<p>弧度</p>
<ul>
<li>在一个圆上切一个扇形，弧长等于$r$所对应的角为1弧度</li>
<li>一个完整的圆的弧度为$2\pi$</li>
</ul>
</li>
<li>
<p>球面度</p>
<ul>
<li>在一个球上切一个“锥形”，锥形的底面积等于$r^2$所对应的角为1球面度</li>
<li>一个完整的球的球面度为$4\pi$</li>
</ul>
</li>
</ul>
<img src="/images/球面度.png" alt="球面度" style="zoom:50%;" />
<h3 id="为什么BRDF-函数的单位是-1-sr">为什么BRDF 函数的单位是 1/sr</h3>
<p>BRDF，双向反射分布函数，是材质表面某一点出射**辐射率（Radiance）<strong>和入射</strong>辐照度（Irradiance）**的比值<br>
$$<br>
BRDF=\frac{dL\left( \omega_{o} \right)  }{dE\left( \omega_{i} \right)  }<br>
$$</p>
<ul>
<li>辐射率$L$：每单位面积每单位**投影固体角（projected solid angle）**上的能量</li>
<li>辐照度$E$：每单位面积上的能量</li>
</ul>
<h4 id="为什么BRDF不直接用出射辐射率-入射辐射率呢？">为什么BRDF不直接用出射辐射率/入射辐射率呢？</h4>
<h5 id="原因一：因为入射辐射率很难测量">原因一：因为入射辐射率很难测量</h5>
<p>测量**出射辐射率$L_{0}$**很简单，只要我在出射方向上放一个下面的仪器，对准该点就可以了</p>
<img src="/images/测量辐射率.png" alt="测量辐射率" style="zoom: 33%;" />
<p>测量<strong>入射辐射率</strong>很麻烦，需要要求光源很小，没有其他光的干扰，所以实际测量的时候不可行，于是不使用，最后BRDF就是出射辐照度/入射辐射率，这两个</p>
<p>而测量<strong>辐照度$E_{i}$<strong>只需要一个面积较小的平面，接收半球方向的</strong>光通量$\Phi $</strong>，$E=\Phi /S $</p>
<img src="/images/测量辐照度.png" alt="测量辐照度" style="zoom:50%;" />
<h5 id="原因二：数学">原因二：数学</h5>
<p>如果是辐射率/辐射率，当出射立体角$\omega_{o}$趋近为0时，两者比值为0（上面是无穷小），没有意义<br>
$$<br>
\lim_{\omega_{o} \rightarrow 0} \frac{dL_{o}}{L_{i}} =0<br>
$$<br>
但辐射率/辐照度不等于零，因为上面下面都有无穷小，所以是不定式/等价无穷小，有意义<br>
$$<br>
\lim_{\omega_{o} \rightarrow 0} \frac{dL_{o}}{dE_{i}} \neq 0<br>
$$</p>
<h3 id="什么是万向节死锁">什么是万向节死锁</h3>
<p>Gimbal Lock （万向节死锁，或叫 环向锁节）</p>
<p>在传统的欧拉坐标系，相机可以沿着xyz三个方向旋转，这三个轴有旋转的先后顺序，可以理解为父母层级关系，父轴旋转时子轴也会跟着旋转</p>
<ul>
<li>Y轴
<ul>
<li>X轴
<ul>
<li>Z轴</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>相邻两个轴始终保持垂直，但有的时候，第一个轴会和第三个轴重合，于是你就会失去一个自由度，你无法朝向某一个方向旋转了，如果要旋转，就需要同时旋转两个轴，这个旋转很不流畅，会出现抽搐，被称为<strong>万向节死锁</strong></p>
<p>可以通过引入四元数解决</p>
<img src="/images/万向节锁.png" alt="万向节锁" style="zoom:50%;" />
<h3 id="有什么常见的遮挡算法">有什么常见的遮挡算法</h3>
<ul>
<li>画家算法
<ul>
<li>后画覆盖新画</li>
<li>这是剔除的核心，下面几个都是对其的加速和优化</li>
</ul>
</li>
<li>沃诺克算法（Warnock）
<ul>
<li>不停地四分屏幕
<ul>
<li>当前子空间没有多边形：完成！</li>
<li>当前子空间只有一个多边形：画！</li>
<li>当前子空间有简单的前后关系：画前面的！</li>
<li>当前子空间只有一个像素那么大了：画离该像素点距离最近的多边形！</li>
<li>否则，继续递归细分</li>
</ul>
</li>
</ul>
</li>
<li>BSP-Tree（二维空间分割树）
<ul>
<li>不停地二分空间，在每一个只有简单前后关系的子空间里使用画家算法</li>
</ul>
</li>
<li>Z-Buffer
<ul>
<li>写入颜色时也写入Z值，绘制时根据Z值判断是否覆盖</li>
<li>有overdraw，只能处理不透明物体，多使用了一个Z-Buffer</li>
</ul>
</li>
</ul>
<h3 id="如何判断点在三角形内">如何判断点在三角形内</h3>
<h4 id="同侧法">同侧法</h4>
<p>若点P在三角形ABC内部，则</p>
<ul>
<li>点P和点A在直线BC同侧</li>
<li>点P和点B在直线AC同侧</li>
<li>点P和点C在直线AB同侧</li>
</ul>
<p>判断是否同侧都方法是叉积同号</p>
<h4 id="叉积法">叉积法</h4>
<p>PA、PB、PC两两叉积，如果三者同号则为内部</p>
<h4 id="重心公式">重心公式</h4>
<p>平面内两个不平行的非零向量可以表示任何向量<br>
$$<br>
\overrightarrow{AP} =u\overrightarrow{AB} +v\overrightarrow{AC}<br>
$$<br>
两边点积<br>
$$<br>
\overrightarrow{AP}\cdot \overrightarrow{AC}  =u\overrightarrow{AB}\cdot \overrightarrow{AC} +v\overrightarrow{AC}\cdot \overrightarrow{AC}<br>
$$</p>
<p>$$<br>
\overrightarrow{AP}\cdot \overrightarrow{AB}  =u\overrightarrow{AB}\cdot \overrightarrow{AB} +v\overrightarrow{AC}\cdot \overrightarrow{AB}<br>
$$</p>
<p>两个变量两个公式，可以求出u和v</p>
<h3 id="什么是MIS">什么是MIS</h3>
<p>多重重要性采样（multiple importance sampling，MIS），在光追中，当光源和物体表面材质都接近$\delta$分布时，无论在光源上采样还是按BSDF采样都会带来很高的方差，使用MIS可以提高效果</p>
<p>思路就是结合不同种采用方法，分布采用被积函数的不同部分，讲这些部分结合起来，以达到最优效果</p>
<h4 id="什么是德尔塔分布">什么是德尔塔分布</h4>
<p>$\delta$函数（狄拉克函数）：除了零点以外的点都等于零，但在其整一个定义域内的积分为1的函数（这种函数本身并不存在）</p>
<p>$\delta$分布：符合$\delta$函数的分布</p>
<h3 id="已知UV和深度如何重建世界坐标">已知UV和深度如何重建世界坐标</h3>
<h4 id="使用逆矩阵">使用逆矩阵</h4>
<p>用uv和深度重建NDC坐标，乘以VP矩阵的逆矩阵以重建世界坐标</p>
<h4 id="线性深度">线性深度</h4>
<h5 id="正交投影">正交投影</h5>
<p>uvz线性映射回视锥长方体</p>
<h5 id="透视投影">透视投影</h5>
<p>通过z确定投影面大小，然后uv线性映射</p>
<h3 id="草地弯曲是怎么实现的">草地弯曲是怎么实现的</h3>
<p>顶点偏移？</p>
<h3 id="离角色很近的树叶如何保持性能">离角色很近的树叶如何保持性能</h3>
<h3 id="是不是每一次draw-call都需要重新传一次顶点数据">是不是每一次draw call都需要重新传一次顶点数据</h3>
<h3 id="贴花">贴花</h3>
<p>前向：绘制几何体</p>
<p>延迟：Gbuffer中绘制</p>
<h3 id="SSR会丢失信息，可以怎么处理">SSR会丢失信息，可以怎么处理</h3>
<p>用cubemap补一下？</p>
<h3 id="为什么有法线贴图还需要顶点法线信息">为什么有法线贴图还需要顶点法线信息</h3>
<p>为了构建TBN矩阵</p>
<p>在片元着色器中采集切线空间法线贴图信息，然后使用TBN矩阵恢复成世界空间法线，那么TBN是怎么来的呢？</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">half3x3 tangentToWorld &#x3D; half3x3(i.tangentWS.xyz, bitangent.xyz, i.normalWS.xyz);</code></pre>
<p>是使用顶点着色器传入的世界空间切线、次切线、法线构建的</p>
<h3 id="Forward">Forward+</h3>
<p>和传统的前向渲染比添加了一个光源剔除阶段</p>
<p>着色分三个阶段：</p>
<ol>
<li>depth prepass（可选）</li>
<li>Light culling</li>
<li>shading</li>
</ol>
<p>将光源信息存储在一个线性布局的缓冲区中，方便查找</p>
<p>light culling阶段和延迟渲染中光照累计很相似，对于每一个像素，先找其所在的tile，求能照射到这个tile的光源列表，然后进行着色</p>
<p>理论上对每一个像素找灯光是效果最好的，现在这种找tile很显然是会计算一些多余的灯光，但是大幅减少了查找灯光的计算量，在查找和着色间寻找一个平衡</p>
<h3 id="移动端GPU渲染架构">移动端GPU渲染架构</h3>
<h4 id="IMR">IMR</h4>
<p>Immediate Mode Rending，即时模式渲染，按drawcall顺序绘制</p>
<img src="/images/IMR.png" alt="IMR" style="zoom:50%;" />
<h4 id="TBR">TBR</h4>
<p>Tile Base Rendering</p>
<p>将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上，然后FS读信息，渲染每一个tile</p>
<img src="/images/TBR.png" alt="TBR" style="zoom:50%;" />
<p>作用：<strong>省带宽</strong>，每次传一个小tile，对带宽的压力会比IMR小很多（IMR一次传一整张屏幕）</p>
<h4 id="TBDR">TBDR</h4>
<p>Tile Base Deferred Rendering</p>
<p>上面我们在FS对每一个tile做渲染时，完全可以记录哪些灯光会影响这个tile，使用这些光做计算</p>
<p>思路</p>
<p>TBR省带宽了，但是没减少overdraw，而TBDR处理了剔除问题，降低了overdraw</p>
<h4 id="TBR的其他应用">TBR的其他应用</h4>
<ul>
<li>
<p>MSAA：MSAA是对一个像素多采几个点，原本采样很费，因为要加载卸载贴图</p>
<ul>
<li>但是由于TBR每一个tile都是片上的，相当于省了加载卸载，性能好很多</li>
<li>只不过虽然采样变便宜了，采样结果一多，就要处理更多的采样数据，所以也不能无限制的使用</li>
<li>此外这会让多边形覆盖更多的像素</li>
</ul>
<p>如图，只有一个采样点时（红点），红圈所在的像素不会被算进去，但MSAA时就会被算进去</p>
<img src="/images/TBR的MSAA.png" alt="TBR的MSAA" style="zoom:50%;" />
</li>
</ul>
<h3 id="视差贴图">视差贴图</h3>
<p>视差贴图（Parallax Mapping）效果类似法线贴图，其原理是对纹理采样uv做偏移，不修改顶点信息</p>
<img src="/images/视差贴图.jpeg" alt="视差贴图" style="zoom: 33%;" />
<p>原本平坦的表面，如果变成如图的凹凸形状，原本视线会与平面在B处相交，现在则在A处相交，我们采集$A’$点的信息</p>
<p>从B到$A’$做了什么呢？本质就是采样点从B点出发，沿着<strong>视线在平面的投影</strong>做了一次偏移，偏移的长度可以通过三角形相似求得</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F;输入B的uv，得到A‘的uv
float2 ParallaxMapping(float2 texCoords,float3 viewDir)
&#123; 
    float height &#x3D; texture(depthMap, texCoords).r;    
    float2 p &#x3D; viewDir.xy &#x2F; viewDir.z * (height * height_scale);
    return texCoords - p;    
&#125;</code></pre>
<p>如果按深度步进，通过从上到下找第一个深度小于A的平面，来求$A’$的位置，就是陡峭视差映射(Steep Parallax Mapping)的思想</p>
<h3 id="virtual-texture">virtual texture</h3>
<p>根据是否实时生成（合并）virtual texture，该技术分为VT和RVT，该技术主要用于大世界地形上</p>
<p>在说VT前，要先谈texture splatting。大世界的地表纹理通常是使用多张纹理混合而成的（比如沙子、草、岩石、雪），而混合这些贴图的技术称为<strong>texture splatting</strong></p>
<p>该技术很简单，比如要混合四张图，那么生成一个新的RGBA贴图，在某一点的混合图为</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">blenderTex &#x3D; Texture1 * map.r + Texture2 * map.g + Texture3 * map.b + Texture4 * map.a;
&#x2F;&#x2F;其中 map.r + map.g + map.b + map.a 恒等于1</code></pre>
<img src="/images/texture splatting.png" alt="texture splatting"  />
<p>我们发现这种混合技术要频繁采样，混合四张图，要采9张图（四个材质图，四个法线图，一个splat图），而我们知道采一张大图会比采多个小图性能高很多，那么我们能不能把这九张小图拼成一张大图呢？这就是VT</p>
<p>但我们没必要一次把这九张完整的图合并，这也存在浪费，那么我们只需要合并需要被采样的图</p>
<p>我们把原图做预处理，分割成一个个小tile，并维护一个映射表，当我们要采样某个范围内的贴图时，先根据映射表找到所有相关的tile（回传给CPU，让CPU去加载tile），再把tile合并</p>
<h3 id="帕尼尼投影">帕尼尼投影</h3>
<p>一种屏幕后效，画面中心凸起，镜头左右两边在垂直方向上保留画面原样</p>
<p><img src="/images/%E5%B8%95%E5%B0%BC%E5%B0%BC%E6%8A%95%E5%BD%B1.jpeg" alt="帕尼尼投影"></p>
<h3 id="SSBO">SSBO</h3>
<p>Shader Storage Buffer Object，该对象可以在不同shader间共享数据，功能类似UBO（Uniform Buffer Object）</p>
<p>两者（SSBO和UBO）区别</p>
<ul>
<li>SSBO更大</li>
<li>SSBO的大小可以在运行时确定</li>
<li>UBO在显卡的常量区（CMEM），SSBO在全局区（SMEM）</li>
<li>SSBO更灵活，能支持更多种的数据类型</li>
</ul>
<h3 id="计算任意多边形面积">计算任意多边形面积</h3>
<h4 id="凸多边形">凸多边形</h4>
<p>一多边形某个点为顶点，将多边形划分为多个三角形，计算每个三角形的面积（可以用向量叉积），再加起来</p>
<h4 id="凹多边形">凹多边形</h4>
<p>向量的叉积是有方向的<br>
$$<br>
S_{OAB}=0.5*(\overrightarrow{OA} \times \overrightarrow{OB})<br>
$$</p>
<p>$$<br>
S_{ABCDE}=S_{OBC}+S_{OCD}+S_{ODE}+S_{OEA}+S_{OAB}<br>
$$</p>
<p><img src="/images/%E5%87%B9%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" alt="凹多边形面积"></p>
<h3 id="OBB包围盒">OBB包围盒</h3>
<p>常见的包围盒有AABB和OBB，AABB是轴向的，生成简单，但当物体旋转时效果并不好，OBB是有向的，沿着物体的主成分方向生成最小的一个矩形包围盒，可以随物体旋转</p>
<p><img src="/images/OBB%E4%B8%8EAABB.jpeg" alt="OBB与AABB"></p>
<p>OBB2D的生成思路是：通过主成分分析（PCA）获得特征向量，作为OBB的主轴，然后将所有点包含</p>
<h4 id="主成分分析">主成分分析</h4>
<p>主成分分析是一种通过正交变换，将一组可能相关的变量集合变换成一组线性不相关的变量集合，即主成分</p>
<p>简单来说就是根据所有顶点生成协方差矩阵，对其对角化</p>
<h3 id="BS变形器">BS变形器</h3>
<p>blendshape</p>
<p>将一个mesh变化为另一个mesh（顶点数不变）的规则，就是一个BS，其最重要的功能是做表情</p>
<h3 id="什么是灭点">什么是灭点</h3>
<p>在透视投影中，不平行于投影平面的平行线会聚集到一点，改点就是灭点</p>
<h4 id="用途">用途</h4>
<p>在制作屏幕后效时（比如雨水），在相机的双锥体上渲染（而不是直接对屏幕四边形），可以得到一种雨水向远处收拢的感觉</p>
<img src="/images/灭点.jpg" alt="灭点" style="zoom:67%;" />
<h3 id="选人界面的打光与镜头">选人界面的打光与镜头</h3>
<ul>
<li>
<p>打光</p>
<ul>
<li>
<p>环境光：用HDRI贴图提供</p>
</li>
<li>
<p>直接光：打在人物正面斜上方，提供主要亮度，开启阴影</p>
</li>
<li>
<p>虚拟光：用于模拟反光板的提供的光源，亮度较弱，方向和相机一个位置（卡渲中常用，可以减弱光照对比，减弱阴影问题）</p>
</li>
</ul>
</li>
<li>
<p>镜头</p>
<ul>
<li>
<p>使用长焦镜头，也就是提高FOV，这样可以减少面部崎变，让人显得更瘦（反其道而行之，就是大头猪鼻特效）</p>
</li>
<li>
<p>开启景深</p>
<ul>
<li>深度景深：没法处理半透明物体，人物头发也会会出问题（因为深度变化太小）</li>
<li>Circle Blur：效果更好，美颜相机大多使用这个，原理就是把人抠出来，把人以外的背景模糊</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="眼球渲染的要点">眼球渲染的要点</h3>
<ul>
<li>
<p>眼白</p>
<ul>
<li>血丝
<ul>
<li>可以直接画在贴图上</li>
</ul>
</li>
<li>次表面散射
<ul>
<li>将散射函数预积分到LUT图上</li>
</ul>
</li>
</ul>
</li>
<li>
<p>眼睛</p>
<ul>
<li>镜面反射
<ul>
<li>颗粒状眼白法线，来表现眼白的粘液</li>
</ul>
</li>
<li>AO
<ul>
<li>在眼球外层做一个用来遮蔽的半透明模型</li>
</ul>
</li>
</ul>
</li>
<li>
<p>虹膜</p>
<ul>
<li>缩放
<ul>
<li>uv采样缩放</li>
</ul>
</li>
<li>视差</li>
<li>焦散（猫的眼睛发亮）
<ul>
<li>双层法线，圆滑的法线计算高光，平整的法线计算漫反射</li>
</ul>
</li>
<li>虹膜对光线的吸收（眼珠旁边有黑圈）
<ul>
<li>根据uv画圆</li>
</ul>
</li>
<li>瞳孔收缩</li>
</ul>
</li>
<li>
<p>泪腺</p>
</li>
</ul>
<h3 id="移动端Deferred">移动端Deferred</h3>
<p>移动端延迟与GPU架构强相关</p>
<ul>
<li>
<p>iOS：one pass deferred</p>
</li>
<li>
<p>Adreno：frameBuffer fetch deferred</p>
<ul>
<li>提前绑定（开辟）好MRT，使用时RT不动，Pass动</li>
</ul>
</li>
<li>
<p>Mali：pixel loacl storage deferred</p>
<ul>
<li>将GBuffer存在on-clip mem上，于是就减少了IO消耗</li>
</ul>
</li>
</ul>
<h4 id="移动端SubPass">移动端SubPass</h4>
<p>Unity移动端使用Metal和Vulkan API时，都可以使用SubPass，但略有不同</p>
<p>在同一个RenderPass的不同SubPass间切换，是不会带来带宽消耗的</p>
<ul>
<li>Metal
<ul>
<li>支持FrameBufferFetch，即可以在一个SubPass中对RT读写</li>
<li>不支持在Tile上读取深度</li>
</ul>
</li>
<li>Vulakn
<ul>
<li>不支持FrameBufferFetch</li>
<li>支持在Tile读深度（mali设备读浮点纹理比读tile的深度更高效）</li>
</ul>
</li>
</ul>
<p>由于Metal不支持读深度，而mali Vulkan读深度效率比读RT差，所以Metal和Vulkan都在GBuffer Pass时额外生成一张深度RT，在LightingPass里用</p>
<h3 id="角色灯光术语">角色灯光术语</h3>
<h4 id="光比">光比</h4>
<p>指物体受光面亮度与阴影面亮度的比值，比值越大，明暗对比越强</p>
<p>常出现在黑暗空间爆炸光效照亮角色</p>
<h4 id="二值化光">二值化光</h4>
<p>照明时，灯光颜色在固定好的暗部颜色和亮部颜色之间插值</p>
<h3 id="抗锯齿">抗锯齿</h3>
<p>抗锯齿有两大类，时间层面和空间层面，但本质都是增加采样点数</p>
<ul>
<li>空域抗锯齿
<ul>
<li>MSAA（MultiSampling Anti-Aliasing）：一个像素采多个点
<ul>
<li>On-Clip MSAA</li>
</ul>
</li>
<li>FXAA（Fast Approximately -Aliasing）：卷积模糊</li>
<li>SMAA（Enhanced Subpixel Morphological）：边缘检测–矢量化–像素混合</li>
</ul>
</li>
<li>时域抗锯齿
<ul>
<li>TAA（Temporal Antialiasing），一帧采一下，几帧后就等于采了很多点<br>
<img src="/images/TAA.png" alt="TAA"></li>
</ul>
</li>
</ul>
<h3 id="svoGI">svoGI</h3>
<p>Sparse Voxel Octree（稀疏体素八叉树） GI，是VXGI的进阶版本</p>
<h3 id="无偏渲染">无偏渲染</h3>
<h3 id="SST">SST</h3>
<p>Sparse Shadow Tree，一种大范围阴影渲染方案</p>
<p><a target="_blank" rel="noopener" href="https://www.activision.com/cdn/research/SparseShadowTree.pdf">论文地址</a></p>
<h3 id="ShadowCache">ShadowCache</h3>
<p>对静态物体和动态物体使用两套CSM，一套只绘制动态物体，每帧刷新，一套只绘制静态物体，低频刷新</p>
<p>低频刷新的CSM被称为ShadowCache</p>
<h3 id="TressFX">TressFX</h3>
<p>一种实时毛发渲染系统</p>
<h3 id="XGen">XGen</h3>
<p>一个maya的头发制作工具</p>
<p><a target="_blank" rel="noopener" href="https://knowledge.autodesk.com/zh-hans/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/CHS/Maya-CharEffEnvBuild/files/GUID-C0470142-600B-4615-8110-EC779934DF5F-htm.html">maya文档</a></p>
<h3 id="Vulkan的基本概念">Vulkan的基本概念</h3>
<p>Vulkan对象主要分为三个部分，每个部分都有一个主对象</p>
<h4 id="Instance">Instance</h4>
<p>第一个Vulkan对象，用于连接应用程序和Vulkan运行时</p>
<h4 id="PhysicalDevice">PhysicalDevice</h4>
<p>显卡</p>
<ul>
<li>可以枚举图形队列</li>
<li>可以枚举内存堆和内存类型</li>
</ul>
<h4 id="Device">Device</h4>
<p>逻辑设备</p>
<ul>
<li>Queue：用于向GPU传递命令（类比SRP的上下文）</li>
<li>CommandPool：用于创建CommandBuffer</li>
<li>CommandBuffer：命令缓冲区，可以通过<code>vkQueueSubmit</code>提交到Queue中</li>
<li>Sampler：一组采样器状态，用于设置滤波模式、寻址模式等</li>
<li>Buffer&amp;Image：资源，渲染时不会直接使用</li>
<li>BufferView&amp;ImageView：对资源的解释（Buffer&amp;Image中，我们所需要的部分），渲染时直接使用（类比SRP的RT）</li>
<li>SurfaceKHR：控制屏幕窗口，与平台相关</li>
<li>SwapchainKHR：交换链，内含一组图片，用于实现显示交换
<ul>
<li>立即渲染</li>
<li>双缓冲</li>
<li>多重缓冲</li>
</ul>
</li>
<li>Descriptor：描述符，用于访问资源（顶点信息，缓冲区，图像，采样器）
<ul>
<li>DescriptorSet</li>
<li>DescriptorSetLayout</li>
<li>DescriptorPool</li>
</ul>
</li>
<li>FrameBuffer：ImageView的集合（RT、MRT）
<ul>
<li>Attachment：附件（类比SRP的RenderTarget）
<ul>
<li>Attachment初始化：Load Action</li>
<li>Attachment写回内存：Save Action</li>
</ul>
</li>
</ul>
</li>
<li>RenderPass：一次渲染流水线的执行，将信息输出到FBO的Attachments中
<ul>
<li>SubPass：渲染的中间Pass，他们的目标不是FBO，而是一些临时的目标</li>
</ul>
</li>
<li>Pipeline：管线
<ul>
<li>ComputePipeline</li>
<li>GraphicsPipeline
<ul>
<li>PipelineLayout</li>
<li>ShaderModule：使用SPIR-V进行着色器编译</li>
<li>PipelineCache</li>
</ul>
</li>
</ul>
</li>
<li>Query：查询，用于得到某指令的执行情况</li>
<li>Fence&amp;Semaphore
<ul>
<li>Fence：栅栏，用于CPU和GPU同步</li>
<li>Semaphore：信号量：用于GPU内部的同步（对客户端黑盒）</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/graphics/TA%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clepy40o8000iglnk9e681e22" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TA/" rel="tag">TA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-graphics/ddx与ddy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/graphics/ddx%E4%B8%8Eddy/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/graphics/ddx%E4%B8%8Eddy/">ddx与ddy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>ddx与ddy</h1>
<p>在OpenGL中叫dFdx和dFdy，在HLSL中叫ddx和ddy</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/deriv-rtx--sm4---asm-">HLSL deriv_rtx</a></p>
<p>ddx和ddy是一个求偏导的过程，依赖于硬件光栅化，只能用于fragment着色器，意思为计算blocks内相邻片元间value的变化（value可以是任意参数，比如uv、color、position、normal），注意不要在分支中使用偏导<br>
$$<br>
\mathrm{ddx}=\frac{\mathrm{p}(x+1,y)-\mathrm{p}(x,y)}{1}<br>
$$<br>
三角形光栅化时，fragment着色器一次处理2x2个像素，其中左上角的像素$(x,y)$始终为偶数坐标</p>
<p><img src="/images/ddx.png" alt="ddx"></p>
<p>如果一个几何体不够大，使用抗锯齿算法后渲染分辨率仍然比2x2要小，那么这个几何体在光栅化前就会被剔除，以此不必担心像素不够的情况</p>
<h3 id="mipmap（UV）">mipmap（UV）</h3>
<p>使用mipmap会增加贴图存储，但是能提高性能和效果，在对mipmap贴图进行采样时，我们可以手动指定采样层级</p>
<p>我们需要一种方法能求mipmap层级（如果层级不对，会导致纹素比异常，产生摩尔纹等）</p>
<p>ddx和ddy一个应用是求贴图mipmap层级</p>
<pre class="language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">float</span> <span class="token function">mip_map_level</span><span class="token punctuation">(</span><span class="token keyword">in</span> <span class="token keyword">vec2</span> texture_coordinate<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">vec2</span>  dx_vtc        <span class="token operator">=</span> <span class="token function">dFdx</span><span class="token punctuation">(</span>texture_coordinate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">vec2</span>  dy_vtc        <span class="token operator">=</span> <span class="token function">dFdy</span><span class="token punctuation">(</span>texture_coordinate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> delta_max_sqr <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>dx_vtc<span class="token punctuation">,</span> dx_vtc<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">dot</span><span class="token punctuation">(</span>dy_vtc<span class="token punctuation">,</span> dy_vtc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0.5</span> <span class="token operator">*</span> <span class="token function">log2</span><span class="token punctuation">(</span>delta_max_sqr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<blockquote>
<p>在OpenGL4.x提供了mipmap函数<code>textureQueryLod()</code></p>
</blockquote>
<h3 id="面法线（坐标）">面法线（坐标）</h3>
<p>我们在fragment着色器中对世界坐标做ddx和ddy，就能得到三角面上两个向量（这俩向量还是垂直的），而平面上两个非平行向量就能确定一个平面，他们的叉积就是面法线（注意手系和法线正负）</p>
<pre class="language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">vec3</span> faceNormal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span> <span class="token function">cross</span><span class="token punctuation">(</span><span class="token function">dFdx</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">dFdy</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><img src="/images/%E9%9D%A2%E6%B3%95%E7%BA%BF.png" alt="面法线"></p>
<p>该技术常用于平面着色（Flat Shading），让物体有一种低面感，法线没有插值，是ground着色、phong着色以前的东西（老古董前的老古董）</p>
<h3 id="高度图（法线）">高度图（法线）</h3>
<p>与面法线原理类似，给定一张单通道的灰度图当作高度图，通过ddx、ddy就能得到高度的变化，进而得到法线的变化</p>
<pre class="language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">fixed</span> h <span class="token operator">=</span> <span class="token function">tex2D</span><span class="token punctuation">(</span>_HightMap<span class="token punctuation">,</span> i<span class="token punctuation">.</span>uv<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span>
<span class="token keyword">float</span> offsetU <span class="token operator">=</span> <span class="token operator">-</span><span class="token function">ddx</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">float</span> offsetV <span class="token operator">=</span> <span class="token function">ddy</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
float3 n <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>normal<span class="token punctuation">.</span>xyz <span class="token operator">+</span> <span class="token function">float3</span><span class="token punctuation">(</span>offsetU<span class="token punctuation">,</span> offsetV<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">*</span> _Intensity<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/graphics/ddx%E4%B8%8Eddy/" data-id="clepy40oc000qglnke470dt98" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shader/" rel="tag">shader</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-math/Nabla算子" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/math/Nabla%E7%AE%97%E5%AD%90/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/math/">math</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/math/Nabla%E7%AE%97%E5%AD%90/">Nabla算子</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Nabla算子</h1>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1a541127cX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a72e0e57d1aa2c57c64020832e1cde7e">参考</a></p>
<p>$\nabla$：Nabla算子，将数量场变成向量场</p>
<ul>
<li>
<p>当其作用于函数，如$\nabla F(x)$，意思为求该函数梯度</p>
</li>
<li>
<p>当其点乘函数，如$\nabla \cdot F(x)$，意思为求该函数的散度</p>
</li>
<li>
<p>当其叉乘（三维）函数，如$\nabla \times F(x)$，意思为求该函数的旋度</p>
</li>
</ul>
<h3 id="函数可视化">函数可视化</h3>
<p>对于函数$f(x,y)=x^2+y^2$，我们有两种可视化方法，第一种叫做图像：<br>
$$<br>
{(\vec{x}, f(\vec{x}))|\vec{x} \in D}<br>
$$<br>
<img src="/images//%E5%9B%BE%E5%83%8F.png" alt="图像"></p>
<p>第二种叫做等值面:<br>
$$<br>
{\vec{x}|f(\vec{x})=c}<br>
$$<br>
<img src="/images//%E7%AD%89%E5%80%BC%E9%9D%A2.png" alt="等值面"></p>
<p>等值面只需要二维空间就能表示三维数据</p>
<h3 id="梯度">梯度</h3>
<p>Nabla算子其实是一个向量：<br>
$$<br>
\nabla =\left[</p>
<p>\frac{\partial }{\partial x_1}, \frac{\partial }{\partial x_2 },\cdots,\frac{\partial }{\partial x_n }</p>
<p>\right]^{T}<br>
$$<br>
Nabla算子作用于函数（标量场），可以将标量场转化为向量场，我们称该向量场为<strong>梯度</strong><br>
$$<br>
\nabla f=<br>
\left[<br>
\begin{array}{c}<br>
\frac{\partial f}{\partial x_1}\\<br>
\frac{\partial f}{\partial x_2}\\<br>
\vdots\\<br>
\frac{\partial f}{\partial x_n}\\<br>
\end{array}<br>
\right]<br>
$$<br>
<img src="/images//%E6%A2%AF%E5%BA%A6.png" alt="梯度"></p>
<p>梯度垂直于等值面，意义为变化最快的方向（图中黄色箭头）</p>
<h3 id="散度">散度</h3>
<p>我们知道向量和向量间可以进行点乘，其结果为一个标量，那么Nabla算子和向量相乘，我们称所得到的标量为<strong>散度</strong><br>
$$<br>
\vec{f}=\left[<br>
\begin{array}{c}<br>
f_1\\<br>
f_2\\<br>
\vdots\\<br>
f_n\\<br>
\end{array}<br>
\right]<br>
$$</p>
<p>$$<br>
\nabla \cdot \vec{f}=\frac{\partial f_1}{\partial x_1}+\frac{\partial f_2}{\partial x_2}+\cdots +\frac{\partial f_n}{\partial x_n}<br>
$$</p>
<p><img src="/images//%E6%95%A3%E5%BA%A6.png" alt="散度"></p>
<p>上图的白色箭头表示一个向量，我们发现这些箭头都是在朝外扩散，而散度就是用来衡量箭头向外扩散的程度</p>
<p>散度的物理意义是通量的局部描述。我们在图上画一个圈，我们发现会有向量进入这个圈，也有向量离开这个圈，那么进出之合，我们就称之为通量（比如磁通量），我们将通量除以圈的面积，就得到了通量的体密度。若这个圆取无穷小，那么体密度的极限值就是该点的散度</p>
<p>是不是突然很好理解麦克斯韦方程中$\nabla \cdot \mathbf{E}=0$的原因了？</p>
<p><img src="/images//%E7%94%B5%E8%8D%B7%E5%9C%BA%E6%BA%90.png" alt="电荷场源"></p>
<p>其实这个公式就是高斯公式</p>
<p><img src="/images//Gauss%E5%85%AC%E5%BC%8F.png" alt="Gauss公式"></p>
<h3 id="旋度">旋度</h3>
<p>向量不仅可以点乘，其实也可以叉乘，两个三维向量叉乘，能得到一个3x3的行列式。最后得到一个矩阵，我们称为<strong>旋度</strong></p>
<p><img src="/images//%E6%97%8B%E5%BA%A6.png" alt="旋度"></p>
<p>旋度的物理意义就是环量的面密度。现在有一个在旋转的场，我们在场上画一个圈，场在这个圈内会做功，这个功就是环量，我们求出单位面积上环量，这个极限值描述了漩涡的强度。旋度就是旋转最快的方向</p>
<p><img src="/images//%E6%97%8B%E5%BA%A62.png" alt="旋度2"></p>
<p><img src="/images//%E6%96%AF%E6%89%98%E5%85%8B%E6%96%AF%E5%85%AC%E5%BC%8F.png" alt="斯托克斯公式"></p>
<h3 id="梯度的散度">梯度的散度</h3>
<p>nabla算子和自己做内积，于是会得到一个数量场，意义为求梯度的散度</p>
<p>这个操作为$\nabla\cdot \nabla$，也可以写作$\nabla^2、\nabla^T \nabla$，但为了避免歧义，我们引入了一个新的符号，拉普拉斯算子<br>
$$<br>
\Delta=\nabla \cdot\nabla<br>
$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/math/Nabla%E7%AE%97%E5%AD%90/" data-id="clepy40oh0012glnk6u8lc58s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%89%E5%AD%A6/" rel="tag">光学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" rel="tag">微积分</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-math/复变函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/math/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/math/">math</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/math/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/">复变函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>复变函数</h1>
<h2 id="复变函数">复变函数</h2>
<h3 id="复数">复数</h3>
<p>复数可以表示为实数和纯虚数的和</p>
<p>代数式：<br>
$$<br>
z=x+\mathrm{i}y<br>
$$</p>
<ul>
<li>x：实部，记为Re z</li>
<li>y：虚部，记为Im z</li>
</ul>
<p>复平面：</p>
<p><img src="/images/%E5%A4%8D%E5%B9%B3%E9%9D%A2.png" alt="复平面"></p>
<p>极坐标下<br>
$$<br>
\begin{cases}<br>
\rho=\sqrt{x^2+y^2} \<br>
\varphi=\arctan (y/x)<br>
\end{cases}<br>
$$</p>
<p>$$<br>
\begin{cases}<br>
x=\rho \cos \varphi  \<br>
y=\rho \sin \varphi<br>
\end{cases}<br>
$$</p>
<p>于是复数可以表示为三角式<br>
$$<br>
z=\rho (\cos \varphi+ \mathrm{i}\sin \varphi )=\rho e^{\mathrm{i}\varphi}<br>
$$</p>
<ul>
<li>
<p>$\rho$：模，记为$|z|$</p>
</li>
<li>
<p>$\varphi$：辐角，记为Arg z</p>
</li>
<li>
<p>复数的辐角有无穷多个，彼此间差$2k\pi$，于是我们约定在$[0,2\pi)$的辐角为主辐角</p>
</li>
<li>
<p>复数<strong>零</strong>的辐角没有意义</p>
</li>
</ul>
<h4 id="复数的运算">复数的运算</h4>
<p>加减（满足交换律、结合律）<br>
$$<br>
z_1\pm z_2=(x_1 \pm x_2)+\mathrm{i}(y_1\pm y_2)<br>
$$<br>
乘（满足交换律、结合律、分配律）<br>
$$<br>
z_1z_2=(x_1x_2-y_1y_2)+\mathrm{i}(x_1y_2-x_2y_1)<br>
$$</p>
<p>$$<br>
z_1z_2=\rho_1 \rho_2 e^{\mathrm{i}(\varphi_1+\varphi_2)}<br>
$$</p>
<p>除（是乘的逆运算）<br>
$$<br>
\frac{z_1}{z_2}=\frac{x_1x_2+y_1y_2}{x_2^2+y_2^2}+\mathrm{i}\frac{x_2y_1+x_1y_2}{x_2^2+y_2^2}<br>
$$</p>
<p>$$<br>
\frac{z_1}{z_2}=\frac{\rho_1}{\rho_2} e^{\mathrm{i}(\varphi_1-\varphi_2)}<br>
$$</p>
<p>n次幂<br>
$$<br>
z^n=\rho^n e^{\mathrm{i}n\varphi}<br>
$$<br>
n次根式<br>
$$<br>
\sqrt[n]{z}=\sqrt[n]{\rho}\ e^{\mathrm{i}\frac{\varphi}{n}}<br>
$$</p>
<h3 id="复变函数-2">复变函数</h3>
<p>$$<br>
\omega=f(z)<br>
$$</p>
<ul>
<li>z为$\omega$的宗量，$z\in E$</li>
</ul>
<h4 id="区域">区域</h4>
<p>在解析函数论中，函数的定义域不是一般的点集，而是满足一定条件的点击，称为区域，用B表示</p>
<ul>
<li>邻域：以复数$z_0$为圆心，画一个半径为任意小正实数的圆，圆内所有点被称为$z_0$的邻域</li>
<li>内点：若某点及其邻域都属于点集E，那么该点是点集E的内点</li>
<li>外点：若某点及其邻域都不属于点集E，那么该点是点集E的外点</li>
<li>边界点：若某点及其邻域既有属于点集E的点，也有不属于的点，那么该点是点集E的边界点</li>
<li>边界线：全体边界点构成边界线</li>
</ul>
<p>区域是满足以下两条件的点集</p>
<ul>
<li>全由内点组成</li>
<li>具有连通性，点集内任意两点都联通，且路径上的点都在该点集</li>
</ul>
<p>闭区域：区域+边境线组成的点集</p>
<h4 id="连续">连续</h4>
<p>$$<br>
当z\rightarrow z_0时，f(z)\rightarrow f(z_0)<br>
$$</p>
<h3 id="导数">导数</h3>
<p>实变数$\Delta x$只能沿着实轴趋近0，但复变数$\Delta z$可以沿着复平面上任意一曲线逼近0</p>
<p>若极限<br>
$$<br>
\lim _{\Delta z \rightarrow 0}\frac{f(z+\Delta z)-f(z)}{\Delta z}<br>
$$<br>
存在，且与$\Delta z \rightarrow 0$的方式无关，则称函数$\omega=f(z)$在$z$点可导（也称单演），这个极限被称为函数在该点的导数（也叫微商）</p>
<ul>
<li>若$\Delta z$沿着平行于实轴方向逼近0，$\Delta y \equiv 0,\Delta z=\Delta x \rightarrow 0$</li>
</ul>
<p>$$<br>
\lim _{\Delta z \rightarrow 0}\frac{\Delta\omega}{\Delta z}=\frac{\partial v}{\partial x}+\mathrm{i}\frac{\partial u}{\partial x}<br>
$$</p>
<ul>
<li>若$\Delta z$沿着平行于虚轴方向逼近0，$\Delta x \equiv 0,\Delta z=\mathrm{i}\Delta y \rightarrow 0$</li>
</ul>
<p>$$<br>
\lim _{\Delta z \rightarrow 0}\frac{\Delta\omega}{\Delta z}=\frac{\partial v}{\partial y}-\mathrm{i}\frac{\partial u}{\partial y}<br>
$$</p>
<p>要想让在该点可导，这两个极限必须同时存在且相等，于是<br>
$$<br>
\begin{cases}<br>
\frac{\partial u}{\partial x}=\frac{\partial v}{\partial y} \<br>
\frac{\partial v}{\partial x}=-\frac{\partial u}{\partial y}<br>
\end{cases}<br>
$$<br>
这个方程被称为<strong>柯西-黎曼方程</strong>，或者<strong>柯西-黎曼条件（C-R条件）</strong>，这个方程是复变函数可导的<strong>必要条件</strong></p>
<p>充要条件为：函数的偏导存在且连续，且满足C-R条件</p>
<h3 id="解析函数">解析函数</h3>
<p>若函数$f(z)$在点$z_0$及其邻域上处处可导，则称$f(z)$在$z_0$点<strong>解析</strong></p>
<p>若$f(z)$在区域B上处处解析，那么称$f(z)$是区域B上的解析函数</p>
<p>解析函数是一类具有特殊性质的复变函数</p>
<h4 id="正交性">正交性</h4>
<p>若函数$f(z)=u+\mathrm{i}v$在区域B上解析，则<br>
$$<br>
u(x,y)=C_1,v(x,y)=C_2<br>
$$<br>
是B上的两组正交曲线族，即梯度$\nabla u$（其直角坐标分量为$\frac{\partial u}{\partial x}$和$\frac{\partial u}{\partial y}$）与梯度$\nabla v$（其直角坐标分量为$\frac{\partial v}{\partial x}$和$\frac{\partial v}{\partial y}$）正交</p>
<h4 id="调和函数">调和函数</h4>
<p>若函数$f(z)=u+\mathrm{i}v$在区域B上解析，则$u,v$均为B上的<strong>调和函数</strong></p>
<ul>
<li>若函数$H(x,y)$存在二阶连续偏导数，且满足拉普拉斯方程$\nabla^2H=0$，则该函数为调和函数</li>
</ul>
<h4 id="应用">应用</h4>
<p>给定一个二元的调和函数，将其看作某个解析函数的实部，利用C-R条件求出对应的虚部，于是就构建了一个解析函数</p>
<ul>
<li>曲线积分法</li>
<li>凑全微分显式法</li>
<li>不定积分法</li>
</ul>
<h3 id="多值函数">多值函数</h3>
<p>根式函数、对数函数就是一种多值函数</p>
<p>黎曼面</p>
<h2 id="傅里叶变换">傅里叶变换</h2>
<h3 id="傅里叶级数">傅里叶级数</h3>
<p>我们已经学过，周期函数可以唯一展开为以三角函数为基本函数族的级数</p>
<p>这些三角函数满足任意两个函数的乘积在一个周期内的积分为0，即正交性</p>
<p>利用三角函数的正交性，我们求出展开系数，这个系数被称为傅里叶系数</p>
<p>这个三角函数族是<strong>完备</strong>的</p>
<ul>
<li>完备的充要条件：任意一平方可积函数的傅里叶级数均值收敛于它本身</li>
</ul>
<h4 id="傅里叶级数收敛定理">傅里叶级数收敛定理</h4>
<p>若一周期函数$f(x)$满足<strong>狄里希利条件</strong>，则函数的傅里叶级数收敛（也就是函数可以用傅里叶级数表示），且收敛值为</p>
<ul>
<li>当$x$是$f(x)$的连续点时，级数收敛于$f(x)$</li>
<li>当$x$是$f(x)$的间断点时，级数收敛于$\frac{1}{2}[f(x-0)+f(x+0)]$</li>
</ul>
<h4 id="傅里叶级数的复数表示">傅里叶级数的复数表示</h4>
<p>$$<br>
\sum^{\infty}_{n=-\infty}c_ne^{\mathrm{i}\frac{n\pi x}{l}}<br>
$$</p>
<p>$$<br>
c_n=\frac{1}{2l}\int^l_{-l}f(x)e^{-\mathrm{i}\frac{n\pi x}{l}}\mathrm{d}x<br>
$$</p>
<h3 id="傅里叶积分">傅里叶积分</h3>
<p>一般来说非周期函数不能展开为傅里叶级数，但是如果我们将这个函数视为周期趋近于无穷的函数<br>
$$<br>
f(x)=\int_0^{\infty}A(\omega)\cos \omega \mathrm{d}\omega+\int_0^{\infty}B(\omega)\sin \omega \mathrm{d}\omega<br>
$$<br>
其中<br>
$$<br>
A(\omega)=\frac{1}{\pi}\int^{\infty}_{-\infty}f(\xi)\cos \omega\xi\mathrm{d}\xi<br>
$$</p>
<p>$$<br>
B(\omega)=\frac{1}{\pi}\int^{\infty}_{-\infty}f(\xi)\sin \omega\xi\mathrm{d}\xi<br>
$$</p>
<p>上面的公式是<strong>傅里叶积分</strong>，这两个参数函数称为<strong>傅里叶变换式</strong></p>
<h4 id="傅里叶积分定理">傅里叶积分定理</h4>
<p>若函数$f(x)$在区间$(-\infty,\infty)$满足</p>
<ul>
<li>$f(x)$在任意一有限区间内满足<strong>狄里希利条件</strong></li>
<li>在$(-\infty,\infty)$绝对可积（即$\int^{\infty}_{-\infty}|f(x)|\mathrm{d}x$收敛）</li>
</ul>
<p>则$f(x)$可以用傅里叶积分表示，且积分值为$\frac{1}{2}[f(x-0)+f(x+0)]$</p>
<h4 id="傅里叶积分的复数表示">傅里叶积分的复数表示</h4>
<p>$$<br>
f(x)=\int^{\infty}<em>{-\infty}F(\omega)e^{\mathrm{i}\omega x}\mathrm{d}\omega<br>
=\frac{1}{\sqrt{2\pi}}\int^{\infty}</em>{-\infty}F(\omega)e^{\mathrm{i}\omega x}\mathrm{d}\omega<br>
$$</p>
<p>$$<br>
F(\omega)=<br>
\begin{cases}<br>
\frac{1}{2}[A(\omega)-\mathrm{i}B(\omega)] &amp; (\omega\ge 0) \<br>
\frac{1}{2}[A(|\omega|)+\mathrm{i}B(|\omega|)] &amp; (\omega&lt; 0)<br>
\end{cases}<br>
$$</p>
<p>$$<br>
F(\omega)=\frac{1}{\sqrt{2\pi}}\int^{\infty}_{-\infty}f(x)[e^{\mathrm{i}\omega x}]^{*}\mathrm{d}\omega<br>
$$</p>
<ul>
<li>这里的$[]^*$是复数的共轭的意思，实际上就是直接给虚部加一个符号</li>
</ul>
<p>我们称$f(x)$为<strong>原函数</strong>，$F(\omega)$为<strong>像函数</strong></p>
<h5 id="例题">例题</h5>
<p>求矩阵脉冲函数$f(t)=h \ rect (t/2T)$的傅里叶变换<br>
$$<br>
\mathscr F[h \ rect (t/2T)]<br>
=\frac{1}{\sqrt{2\pi}}\int^{\infty}<em>{-\infty}h \ rect (t/2T)e^{-\mathrm{i}\omega t}\mathrm{d}t \<br>
=\frac{h}{2\pi}\int^{T}</em>{-T}e^{-\mathrm{i}\omega t}\mathrm{d}t \<br>
=-\frac{h}{2\pi \mathrm{i}\omega}e^{-\mathrm{i}\omega t}|^{T}_{-T} \<br>
=\frac{h}{\pi}\frac{\sin \omega T}{\omega}<br>
$$</p>
<h4 id="傅里叶变化的基本性质">傅里叶变化的基本性质</h4>
<p>导数定理<br>
$$<br>
\mathscr F[f’(x)]=\mathrm{i}\omega F(\omega)<br>
$$<br>
积分定理<br>
$$<br>
\mathscr F[\int^{(x)}f(\xi)\mathrm{d}\xi]=\frac{1}{\mathrm{i}\omega} F(\omega)<br>
$$<br>
相似性定理<br>
$$<br>
\mathscr F[f(ax)]=\frac{1}{a} F(\frac{\omega}{a})<br>
$$<br>
延迟定理<br>
$$<br>
\mathscr F[f(x-x_0)]=e^{-\mathrm{i}\omega x_0} F(\omega)<br>
$$<br>
位移定理<br>
$$<br>
\mathscr F[e^{\mathrm{i}\omega_0 x} f(x)]=f(\omega-\omega_0)<br>
$$<br>
卷积定理<br>
$$<br>
\mathscr F[f_1(x)*f_2(x)]=2\pi F_1(\omega)F_2(\omega)<br>
$$</p>
<h2 id="拉普拉斯变换">拉普拉斯变换</h2>
<h3 id="拉普拉斯变换-2">拉普拉斯变换</h3>
<p>傅里叶积分和傅里叶变换存在的条件是原函数在任意一有限区间满足狄里希利条件，且在$(-\infty,\infty)$上绝对可积，这实际上是一个相当苛刻的条件，导致很多常见函数都不满足</p>
<p>而拉普拉斯变换是一种条件更宽泛的变换</p>
<p>拉普拉斯变换常用于初始值问题，即知道某个物理量在初始时刻$t=0$的值$f(0)$，求一段时刻后的情况$f(t)$</p>
<p>我们置$f(t)=0$，构造一个函数$g(t)$，使得</p>
<p>$$<br>
g(t)=e^{-\sigma t}f(t)<br>
$$</p>
<ul>
<li>其中$e^{-\sigma t}$为收敛因子，正实数$\sigma$取特别大，以保证$g(t)$在$(-\infty,\infty)$绝对可积</li>
</ul>
<p>于是我们对$g(t)$进行傅里叶变换，得到<br>
$$<br>
G(\omega)=\frac{1}{2\pi}\int^{\infty}<em>{0}f(t)e^{-(\sigma +\mathrm{i}\omega )t}\mathrm{d}t<br>
$$<br>
令$p=\sigma +\mathrm{i}\omega$，$G(\omega)=\overline{f}§/2\pi$，则<br>
$$<br>
\mathscr L[f(t)]=\overline{f}§=\int^{\infty}</em>{0}f(t)e^{-pt}\mathrm{d}t<br>
$$<br>
我们称这个积分为<strong>拉普拉斯积分</strong>，而函数$\overline{f}§$为$f(t)$的<strong>拉普拉斯变换函数</strong>，这个变化过程称为拉普拉斯变换，$e^{pt}$称为<strong>核</strong></p>
<h4 id="变换条件">变换条件</h4>
<ul>
<li>在$[0,\infty)$的任意有限区间上，除了有限个第一类间断点外，函数及其导数是处处连续的</li>
<li>存在常数$M&gt;0$，$\sigma \ge0$，使得对任意$t\in [0,\infty)$有</li>
</ul>
<p>$$<br>
|f(t)|&lt;Me^{\sigma t}<br>
$$</p>
<p>其中$\sigma$的下界称为<strong>收敛横标</strong>，记为$\sigma_0$</p>
<p>在实际应用中，大部分函数都满足这个条件</p>
<h4 id="性质">性质</h4>
<ul>
<li>
<p>$\overline{f}§$是$Re p=\sigma &gt; \sigma_0$的半平面上的解析函数</p>
</li>
<li>
<p>当$|p|\rightarrow \infty$，且$|Arg p|\le \frac{\pi}{2}-\varepsilon(\varepsilon &gt; 0)$，$\overline{f}§$存在且满足</p>
</li>
</ul>
<p>$$<br>
\lim_{p\rightarrow \infty}\overline{f}§=0<br>
$$</p>
<ul>
<li>线性定理</li>
<li>导数定理</li>
<li>积分定理</li>
<li>相似性定理</li>
<li>位移定理</li>
<li>延迟定理</li>
<li>卷积定理</li>
</ul>
<h3 id="拉普拉斯变换的反演">拉普拉斯变换的反演</h3>
<p>由像函数转化为原函数的步骤称为<strong>反演</strong></p>
<ul>
<li>有理分式反演法</li>
<li>查表法</li>
<li>黎曼-梅林反演公式</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/math/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/" data-id="clepy40oj0019glnk8vym6ron" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-math/微积分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/math/%E5%BE%AE%E7%A7%AF%E5%88%86/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/math/">math</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/math/%E5%BE%AE%E7%A7%AF%E5%88%86/">微积分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>微积分</h1>
<h2 id="无穷级数">无穷级数</h2>
<p>从<strong>有限项之和</strong>拓展到<strong>无限项之和</strong></p>
<p>一根绳子，日取其半，万世不竭。但无论截取多少次，最后总长应该还是这跟绳子，即<br>
$$<br>
1=\frac{1}{2}+\frac{1}{2^2}+\frac{1}{2^3}+…+\frac{1}{2^n}+…<br>
$$<br>
另一个例子<br>
$$<br>
1+(-1)+1+(-1)+1+(-1)…<br>
$$<br>
等于多少呢？</p>
<p>到底是<br>
$$<br>
1+[(-1)+1]+[(-1)+1]…=1+0+0…<br>
$$<br>
还是<br>
$$<br>
(1-1)+(1-1)+…(1-1)+…=0+0+0…<br>
$$<br>
这里出现了矛盾，为此我们建立了无穷级数的概念</p>
<h3 id="常数项级数">常数项级数</h3>
<h4 id="常数项无穷级数">常数项无穷级数</h4>
<p>给定一个数列${u_n}$，由它构成的表达式<br>
$$<br>
u_1+u_2+…+u_n+…<br>
$$<br>
被称为<strong>常数项无穷级数</strong>，简称级数，其中$u_n$被称为该级数的通项</p>
<p>该级数的前n项和称为<strong>部分和</strong>，记为$s_n$</p>
<p>当n依次取1,2,3…时，部分和构成一个新数列${s_n}$，被称为<strong>部分和数列</strong></p>
<p>当n无限增大时，若部分和存在极限，即<br>
$$<br>
\lim_{n \rightarrow \infty}s_n=s<br>
$$<br>
则称该级数<strong>收敛</strong>，并称极限$s$为该级数的<strong>和</strong></p>
<p>若不存在极限，则称该级数<strong>发散</strong></p>
<h4 id="讨论级数收敛-发散">讨论级数收敛/发散</h4>
<ul>
<li>部分和公式好求，可以求公式，判断其有无极限</li>
<li>不好求，可以反证
<ul>
<li>先假设收敛，然后化简公式，最后得出形如$s+x&gt;s$的结论，证否</li>
</ul>
</li>
</ul>
<p>$$<br>
\lim_{n \rightarrow \infty}s_n=\lim_{n \rightarrow \infty}s_{2n}=s<br>
$$</p>
<h4 id="余项">余项</h4>
<p>去掉级数A前n项，得到一级数<br>
$$<br>
u_{n+1}+u_{n+2}+…+u_{n+k}+…=\sum^{\infty}_{k=n+1}u_k<br>
$$<br>
称该级数为级数A的<strong>余项</strong></p>
<p>若级数A收敛，则余项的前m项之和$s_m’$满足<br>
$$<br>
s_m’=s-s_n<br>
$$<br>
一般，我们将n项后余项和记为$r_n$<br>
$$<br>
s=s_n+r_n<br>
$$</p>
<h4 id="性质">性质</h4>
<ul>
<li>
<p>级数中去掉/加上有限个项，不改变级数的收敛性</p>
</li>
<li>
<p>若一级数收敛，则其通项<strong>乘</strong>以一个常数$k$，仍然收敛，且和为$ks$</p>
</li>
<li>
<p>若两级数收敛，则两通项<strong>相加或相减</strong>，对应的级数仍然收敛，且和为$s+\sigma$</p>
</li>
<li>
<p>若一级数收敛，在其中加任意个括号，仍然收敛</p>
</li>
<li>
<p>级数收敛的<strong>必要条件</strong>是通项在无穷大处有极限，且为0</p>
</li>
</ul>
<h4 id="柯西收敛准则">柯西收敛准则</h4>
<p>级数收敛的<strong>充要条件</strong></p>
<h3 id="正项级数">正项级数</h3>
<p>若级数中各项非负，则称该级数为<strong>正项级数</strong></p>
<ul>
<li>正项级数的<strong>部分和</strong>必然是递增的</li>
</ul>
<p>正项级数收敛的充要条件：其<strong>部分和数列</strong>有上界</p>
<h4 id="比较审敛法">比较审敛法</h4>
<p>对于两个正项级数A，B，其通项分别为$u_n,v_n$</p>
<ul>
<li>自某项起，$u_n\ge v_n$，若B发散，则A发散（大于发散则发散）</li>
<li>自某项起，$u_n\le v_n$，若B收敛，则A收敛（小于收敛则收敛）</li>
</ul>
<h5 id="比较审敛法的极限形式">比较审敛法的极限形式</h5>
<p>对于两个正项级数A，B，其通项分别为$u_n,v_n$，若<br>
$$<br>
\lim_{n \rightarrow \infty}\frac{u_n}{v_n}=\lambda<br>
$$<br>
有意义（极限存在或者为无穷大）</p>
<ul>
<li>$0&lt;\lambda&lt;\infty$：两级数收敛性相同</li>
<li>$lambda=0$：若B收敛，则A收敛（小于收敛则收敛）</li>
<li>$\lambda=\infty$：若B发散，则A发散（大于发散则发散）</li>
</ul>
<h4 id="比值审敛法">比值审敛法</h4>
<p>也称达朗贝尔判别法</p>
<p>对于一正向级数A，其通项为$u_n$，若<br>
$$<br>
\lim_{n \rightarrow \infty}\frac{u_{n+1}}{u_n}=\rho<br>
$$<br>
有意义</p>
<ul>
<li>$\rho &lt;1$：A收敛</li>
<li>$\rho &gt;1$：A发散</li>
<li>$\rho =1$：A可能收敛也可能发散</li>
</ul>
<h4 id="根值审敛法">根值审敛法</h4>
<p>也称柯西判别法</p>
<p>对于一正向级数A，其通项为$u_n$，若<br>
$$<br>
\lim_{n \rightarrow \infty}\sqrt[n]{u_n}=\rho<br>
$$<br>
有意义</p>
<ul>
<li>$\rho &lt;1$：A收敛</li>
<li>$\rho &gt;1$：A发散</li>
<li>$\rho =1$：A可能收敛也可能发散</li>
</ul>
<h4 id="积分审敛法">积分审敛法</h4>
<p>对于一正向级数A，其通项为$u_n$，若存在$[1, \infty)$上单调递减的非负连续函数$f(x)$，使得$u_n=f(n)$，则级数A与反常积分$\int^{\infty}_1 f(x)\mathrm{d}x$收敛性相同</p>
<ul>
<li>反常积分就是积分域包含无穷上/下限，或者被积函数有瑕点的积分
<ul>
<li>瑕点：函数值区域无穷的点</li>
<li>奇点：函数值未定的点（比如间断点、无定义点）</li>
</ul>
</li>
</ul>
<h3 id="任意项级数">任意项级数</h3>
<h4 id="交错级数">交错级数</h4>
<p>形如<br>
$$<br>
u_1-u_2+u_3-u_4…(-1)^{n-1}u_n+…<br>
$$<br>
或者<br>
$$<br>
-u_1+u_2-u_3+u_4…(-1)^{n}u_n+…<br>
$$<br>
的级数，称为<strong>交错级数</strong></p>
<ul>
<li>其中$u_n &gt; 0$</li>
</ul>
<p><strong>交错级数审敛法</strong></p>
<p>若$u_n \ge u_{n+1}$ ，且$\lim_{n \rightarrow \infty}u_n=0$</p>
<p>则级数 $\sum^{\infty}_{n=1}(-1)^{n-1}u_n$ 收敛</p>
<p>且其和 $s \le u_1$ ，其余项 $|r_n|\le u_{n+1}$</p>
<h4 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h4>
<p>对于一级数$A=\sum^{\infty}_{n=1}u_n$，其各项取绝对值</p>
<p>得到新正项级数$B=\sum^{\infty}_{n=1}|u_n|$</p>
<p>定理：若B收敛，则A收敛（所以这就是我们为什么要研究正项级数）</p>
<ul>
<li>若B收敛，A必收敛，此时称A为<strong>绝对收敛</strong></li>
<li>若B发散，而A却收敛，此时称A为<strong>条件收敛</strong></li>
</ul>
<h5 id="性质-2">性质</h5>
<ul>
<li>绝对级数的更序级数仍为绝对级数
<ul>
<li>更序级数：对某级数的项进行重排后得到的新级数</li>
</ul>
</li>
<li>两个绝对级数的柯西乘积仍然绝对收敛，且其和为$s\times \sigma$
<ul>
<li>柯西乘积：参考向量相乘，$(a_1, a_2)(b_1,b_2)=(a_1b_1,a_2b_2)$</li>
</ul>
</li>
</ul>
<h3 id="函数项级数">函数项级数</h3>
<p>前面讨论的常数项级数用于表示无穷多个<strong>数</strong>的和，当其收敛时，其和为<strong>一个常数</strong></p>
<p>而函数项级数用于表示无穷多个<strong>函数</strong>的和</p>
<p>设定义在集合$D\subseteq \mathbf{R}$的一系列函数（称为函数列）<br>
$$<br>
u_1(x),u_2(x),u_3(x)…u_n(x)…<br>
$$<br>
称<br>
$$<br>
\sum^{\infty}_{n=1}u_n(x)<br>
$$<br>
为<strong>函数项级数</strong>，$u_n(x)$为通项，前n项和称为部分和</p>
<h4 id="极限函数">极限函数</h4>
<ul>
<li>
<p>若对于某个点$x_0 \in D$，${ u_n(x_0)}$收敛，则称点$x_0$为该函数列的一个<strong>收敛点</strong></p>
</li>
<li>
<p>所有收敛点构成的集合称为<strong>收敛域</strong></p>
</li>
<li>
<p>若${ u_n(x)}$处处收敛（或逐点收敛），那么就形成了一个定义在D上的函数$f(x)$，D上每一个x都有该函数列一个极限值与之相对应，并称函数$f(x)$为该函数列的<strong>极限函数</strong></p>
</li>
</ul>
<p>$$<br>
f(x)=\lim_{n \rightarrow \infty}f_n(x)<br>
$$</p>
<h4 id="极限函数与函数项级数">极限函数与函数项级数</h4>
<ul>
<li>
<p>若点$x_0 \in D$是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的<strong>收敛点</strong></p>
</li>
<li>
<p>若点$x_0 \in D$不是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的<strong>发散点</strong></p>
</li>
<li>
<p>收敛点的集合称为该级数的<strong>收敛域</strong></p>
</li>
<li>
<p>若级数在D上处处收敛，于是形成了一个定义在D上的<strong>和函数</strong>$s(x)$</p>
</li>
</ul>
<p>$$<br>
s(x)=\lim_{n \rightarrow \infty}s_n(x)<br>
$$</p>
<h4 id="收敛性">收敛性</h4>
<p>略</p>
<h3 id="幂级数">幂级数</h3>
<p>幂级数是一种特殊的，也是最常用的函数项级数</p>
<p>我们把形如<br>
$$<br>
a_0(x-x_0)^0+a_1(x-x_0)^1+a_2(x-x_0)^2+…a_n(x-x_0)^n+…<br>
$$<br>
的函数项级数称为$x-x_0$的<strong>幂级数</strong></p>
<p>其中$x_0$是一个常数，$a_0,a_1,…a_n,…$是<strong>幂级数的系数</strong></p>
<ul>
<li>对任意幂级数总有，当$x=0$时，幂级数收敛，即0是收敛点</li>
</ul>
<h4 id="阿贝尔定理">阿贝尔定理</h4>
<ul>
<li>若$x=x_0 \ne 0$且幂级数收敛，则当$|x|&lt;|x_0|$时，幂级数绝对收敛</li>
<li>若$x=x_0 \ne 0$且幂级数发撒，则当$|x|&gt;|x_0|$时，幂级数发散</li>
</ul>
<h4 id="收敛半径">收敛半径</h4>
<p>幂级数$\sum^{\infty}_{n=1}a_nx^n$的收敛域K是以原点为中心的一个区间，在区间内绝对收敛，在区间外发散，区间界可能收敛也可能发散，于是我们称这个收敛域的半径R为<strong>收敛半径</strong></p>
<p>对于某个幂级数，若$a_n \ne 0$，且<br>
$$<br>
\lim_{n \rightarrow \infty}|\frac{a_{n+1}}{a_n}|=\rho<br>
$$</p>
<ul>
<li>若$0&lt;\rho &lt;\infty$，收敛半径$R=\frac{1}{\rho}$</li>
<li>若$\rho =0$，收敛半径$R=\infty$</li>
<li>若$\rho =\infty$，收敛半径$R=0$</li>
</ul>
<h4 id="运算">运算</h4>
<p>对于两个幂级数A、B，他们的收敛半径分别为$R_1$、$R_2$</p>
<p>$R=\min(R_1, R_2)$，则在$(-R, R)$上</p>
<ul>
<li>幂级数乘以一个常数仍然收敛</li>
<li>A和B的线性组合仍然收敛</li>
<li>A和B的乘积仍然收敛</li>
</ul>
<h4 id="和函数的性质">和函数的性质</h4>
<p>在收敛区间内，和函数$s(x)$满足</p>
<ul>
<li>连续性</li>
<li>可微性</li>
</ul>
<p>$$<br>
s’(x)=\sum^{\infty}_{n=1}na_nx^{n-1}<br>
$$</p>
<ul>
<li>可积性</li>
</ul>
<p>$$<br>
\int^x_0s(t)\mathrm{d}t=\sum^{\infty}_{n=0}\frac{a_n}{n+1}x^{n+1}<br>
$$</p>
<h3 id="函数展开为幂级数">函数展开为幂级数</h3>
<p>在前面几节，我们讨论了函数项级数（尤其是幂级数）在收敛区间内可以得到一个和函数</p>
<p>那么，能不能给定一个（和）函数，将其展开为幂级数呢？</p>
<p>幂级数可以视为多项式的推广，那么我们能不能用多项式来逼近（和）函数呢？</p>
<h4 id="泰勒级数">泰勒级数</h4>
<p>若$f(x)$在区间$(x_0-R, x_0+R)$能展开成幂级数，$f(x)$在$x=x_0$处有任意阶导数，那么幂级数有且仅有一个展开形式，且幂级数的系数为<br>
$$<br>
a_n=\frac{1}{n!}f^{(n)}(x_0)<br>
$$</p>
<ul>
<li>n取0，1，2…</li>
</ul>
<p>我们称这个幂级数为函数$f(x)$在$x_0$处的<strong>泰勒级数</strong>，记作<br>
$$<br>
f(x)\sim f(x_0)+\frac{f’(x_0)}{1!}(x-x_0)+\frac{f’'(x_0)}{2!}(x-x_0)^2+…+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+…<br>
$$</p>
<h4 id="展开条件">展开条件</h4>
<p>若$f(x)$在区间$(x_0-R, x_0+R)$处有任意阶导数，那么$f(x)$在该区间内能展开称泰勒级数的<strong>充要条件</strong>为<br>
$$<br>
\lim _{n \rightarrow \infty}R_n(x)=0<br>
$$</p>
<ul>
<li>$R_n(x)$：n以后的余项</li>
</ul>
<p>推论</p>
<p>若存在一个常数$M&gt;0$，使得任意x属于区间$(x_0-R, x_0+R)$，都有当n趋近于无穷时，余项的绝对值小于M，则函数可以在该区间展开成泰勒级数</p>
<h4 id="麦克劳林展开式">麦克劳林展开式</h4>
<p>泰勒公式的特例，$x_0=0$<br>
$$<br>
f(x)=f(0)+\frac{f’(0)}{1!}x+\frac{f’'(0)}{2!}x^2+…++\frac{f^{(n)}(0)}{n!}x^n+…<br>
$$</p>
<h4 id="经典展开">经典展开</h4>
<p>$$<br>
e^x=1+\frac{x}{1!}+\frac{x^2}{2!}+…+\frac{x^n}{n!}+…<br>
$$</p>
<p>$$<br>
\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-…+(-1)^{n-1}\frac{x^{2n-1}}{(2n-1)!}+…<br>
$$</p>
<h3 id="傅里叶级数">傅里叶级数</h3>
<p>使用三角函数来拟合一个已知函数</p>
<h4 id="三角级数">三角级数</h4>
<p>一般来说，形如<br>
$$<br>
\frac{a_0}{2}+\sum^{\infty}_{n=1}(a_n\cos nx+b_n \sin nx)<br>
$$<br>
的级数被称为三角级数</p>
<h4 id="正交性">正交性</h4>
<p>函数系<br>
$$<br>
{1,\cos x, \sin x, \cos 2x, \sin 2x, …,\cos nx, \sin nx,…}<br>
$$<br>
被称为<strong>基本三角函数系</strong></p>
<p><strong>正交性</strong>：该函数系任意两个不同的函数的乘积，在区间$[-\pi,\pi]$上的积分等于0</p>
<h4 id="三角级数的系数">三角级数的系数</h4>
<p>$$<br>
a_n=\frac{1}{\pi}\int^{\pi}_{-\pi}f(x)\cos nx \ \mathrm{d}x<br>
$$</p>
<p>$$<br>
b_n=\frac{1}{\pi}\int^{\pi}_{-\pi}f(x)\sin nx \ \mathrm{d}x<br>
$$</p>
<p>这两个式子被称为欧拉-傅里叶公式，由这个公式确定的系数被称为<strong>傅里叶系数</strong></p>
<p>对任意在区间$[-\pi,\pi]$上可积函数$f(x)$都可以求出其傅里叶级数，但这个级数不一定收敛，即使收敛也不一定收敛于$f(x)$</p>
<p>于是我们需要知道什么时候$f(x)$可以被展开成收敛在$f(x)$的傅里叶级数</p>
<h4 id="收敛定理（狄里希利充分条件）">收敛定理（狄里希利充分条件）</h4>
<p>对于一个周期为$2\pi$的周期函数，如果它满足<strong>狄里希利条件</strong>：</p>
<ul>
<li>
<p>在一个周期内连续，或者只有有限个第一类间断点</p>
<ul>
<li>第一类间断点：左右极限都存在，但该点函数值或该点无定义</li>
</ul>
</li>
<li>
<p>在一个周期内之多有有限个严格极值点</p>
</li>
</ul>
<p>则$f(x)$的傅里叶级数收敛，且</p>
<ul>
<li>当$x$是$f(x)$的连续点时，级数收敛于$f(x)$</li>
<li>当$x$是$f(x)$的间断点时，级数收敛于$\frac{1}{2}[f(x-0)+f(x+0)]$</li>
</ul>
<h4 id="其他概念">其他概念</h4>
<ul>
<li>周期延拓</li>
<li>正弦级数（奇函数）</li>
<li>余弦级数（偶函数）</li>
<li>奇延拓</li>
<li>偶延拓</li>
</ul>
<h4 id="复数表示">复数表示</h4>
<p>欧拉公式<br>
$$<br>
\sin z=\frac{e^{iz}-e^{-iz}}{2i}<br>
$$</p>
<p>$$<br>
\cos z=\frac{e^{iz}+e^{-iz}}{2}<br>
$$</p>
<p>记<br>
$$<br>
\frac{a_0}{2}=c_0<br>
$$</p>
<p>$$<br>
\frac{a_n-ib_n}{2}=c_n<br>
$$</p>
<p>$$<br>
\frac{a_n+ib_n}{2}=c_{-n}<br>
$$</p>
<p>则傅里叶级数简化为<br>
$$<br>
\sum^{\infty}_{n=-\infty}c_ne^{i\frac{n\pi x}{l}}<br>
$$</p>
<p>$$<br>
c_n=\frac{1}{2l}\int^l_{-l}f(x)e^{-i\frac{n\pi x}{l}}\mathrm{d}x<br>
$$</p>
<h2 id="多元函数">多元函数</h2>
<h3 id="方向导数">方向导数</h3>
<p>设点$P_0(x_0,y_0)\in \mathbf{R}^2$，$l$是平面上的一非零向量，其单位向量为$e_i=\cos \alpha \mathbf {i}+\cos \beta \mathbf {j}$，函数$z=f(x,y)$在点$P_0$的某邻域内有定义，$P_0$为直线L上的一个定点（直线L平行于向量$l$），若极限<br>
$$<br>
\lim_{t\rightarrow 0}\frac{f(x_0+t\cos \alpha,y_0+t\cos \beta)-f(x_0,y_0)}{t}<br>
$$<br>
存在，则称此极限为函数$z=f(x,y)$在直线L上点$P_0$处，延方向$l$的<strong>方向导数</strong></p>
<h4 id="梯度">梯度</h4>
<p>方向导数刻画了函数在点$P_0$处沿着方向$l$的变化快慢程度，我们希望知道在该点，哪一个方向变化最快，于是引入了梯度</p>
<p>设函数$z=f(x,y)$在点$P_0(x_0,y_0)$处可偏导，则称向量<br>
$$<br>
f_x(x_0,y_0)\mathbf{i}+f_y(x_0, y_0)\mathbf{j}<br>
$$<br>
为函数$z=f(x,y)$在点$P_0(x_0,y_0)$处的<strong>梯度</strong>，记作$\mathbf{grad}f(x_0,y_0)$，或$\nabla f(x_0,y_0)$</p>
<ul>
<li>当方向为$(\frac{\partial z}{\partial x}|_P,\frac{\partial z}{\partial y}|_P)$时，变化速度最快</li>
</ul>
<h4 id="物理意义">物理意义</h4>
<ul>
<li>梯度方向=法线方向</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/math/%E5%BE%AE%E7%A7%AF%E5%88%86/" data-id="clepy40ok001dglnk25902kw5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-math/概率论" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/math/%E6%A6%82%E7%8E%87%E8%AE%BA/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/math/">math</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/math/%E6%A6%82%E7%8E%87%E8%AE%BA/">概率论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>概率论</h1>
<h2 id="一：随机事件与概率">一：随机事件与概率</h2>
<h3 id="事件">事件</h3>
<h4 id="事件的概念">事件的概念</h4>
<ul>
<li>样本空间$\Omega$
<ul>
<li>其单元素子集：基本事件</li>
<li>其最大子集：必然事件</li>
<li>最小子集：即空集$\empty$，不可能事件</li>
</ul>
</li>
<li>事件域$F$</li>
</ul>
<h4 id="事件的关系">事件的关系</h4>
<ul>
<li>包含
<ul>
<li>$A\subset B$：A被包含在B、B包含A、A发生时B一定发生</li>
</ul>
</li>
<li>相等
<ul>
<li>$A=B$：A等于B，两事件是同一个集合、描述的是同一件事</li>
</ul>
</li>
<li>互不相容
<ul>
<li>A和B不能同时发生</li>
</ul>
</li>
</ul>
<h4 id="事件的运算">事件的运算</h4>
<h5 id="基本运算">基本运算</h5>
<ul>
<li>并
<ul>
<li>$A \cup B$：A和B至少有一个会发生</li>
</ul>
</li>
<li>交
<ul>
<li>$A \cap B$：A和B同时发生</li>
</ul>
</li>
<li>差
<ul>
<li>$A-B$：A发生，但B不发生</li>
</ul>
</li>
<li>对立
<ul>
<li>$\overline{A}$：即$\Omega - A$</li>
</ul>
</li>
</ul>
<h5 id="运算性质">运算性质</h5>
<ul>
<li>交换律</li>
<li>结合律</li>
<li>分配律</li>
<li>对偶律（德摩根公式）
<ul>
<li>$\overline{A \cup B} = \overline{A} \cap \overline{B}$：并的对立等于对立的交</li>
<li>$\overline{A \cap B} = \overline{A} \cup \overline{B}$：交的对立等于对立的并</li>
</ul>
</li>
</ul>
<h3 id="概率">概率</h3>
<h4 id="公理化表示">公理化表示</h4>
<p>设$\Omega$为一个样本空间，$F$为$\Omega$的某些子集组成的一个事件域，对任意事件$A \in F$，有一个定义在$F$上的实值函数$P(A)$，满足：</p>
<ul>
<li>非负
<ul>
<li>$P(A) \ge 0$</li>
</ul>
</li>
<li>正则
<ul>
<li>$P(\Omega) = 1$</li>
</ul>
</li>
<li>可列可加
<ul>
<li>若$A_1,A_2,A_3,…A_n$互不相容，则<strong>和的概率等于概率的和</strong></li>
</ul>
</li>
</ul>
<p>则称$P(A)$为事件$A$的概率，$(\Omega, F, P)$为概率空间</p>
<h4 id="排列">排列</h4>
<p>n中取r，考虑顺序<br>
$$<br>
P^r_n = \frac{n!}{(n-r)!}<br>
$$<br>
全排列<br>
$$<br>
P_n = n!<br>
$$</p>
<ul>
<li>注意，这里的P是方案数的意思</li>
</ul>
<h4 id="组合">组合</h4>
<p>n中取r，不考虑顺序<br>
$$<br>
C^r_n=\binom{n}{r}=\binom{n}{n-r}=\frac{n!}{r!(n-r)!}<br>
$$<br>
并规定<br>
$$<br>
C^0_n=1<br>
$$</p>
<h4 id="频率">频率</h4>
<ul>
<li>
<p>$n(A)$：频数，n次重复实验中事件A出现的次数</p>
</li>
<li>
<p>$f_n(A)$：频率=频数/n</p>
</li>
<li>
<p>我们认为频率的稳定值就是概率</p>
</li>
</ul>
<h4 id="古典概率">古典概率</h4>
<p>通过样本数进行估计<br>
$$<br>
P(A)=\frac{事件A所含样本数}{\Omega 所含样本总数}<br>
$$</p>
<h4 id="几何概率">几何概率</h4>
<p>通过面积、体积进行估计<br>
$$<br>
P(A)=\frac{S_A}{S_{\Omega}}<br>
$$</p>
<ul>
<li>蒙特卡洛方法</li>
</ul>
<h4 id="概率的性质">概率的性质</h4>
<ul>
<li>$P(\Omega)=1$</li>
<li>$P(\empty)=0$</li>
<li>有限可加性：和的概率等于概率之和</li>
<li>$P(\overline{A}) = 1-P(A)$</li>
<li>若$A\sub B$
<ul>
<li>$P(B-A) = P(B)-P(A) =P(B) - P(AB)$</li>
<li>$P(B) \ge P(A)$</li>
</ul>
</li>
<li>$P(A\cup B)=P(A)+P(B)-P(AB)$</li>
</ul>
<h3 id="条件概率">条件概率</h3>
<ul>
<li>条件概率：在B发生的情况下，A发生的概率</li>
</ul>
<p>$$<br>
P(A|B) = \frac{P(AB)}{P(B)}<br>
$$</p>
<ul>
<li>乘法公式</li>
</ul>
<p>$$<br>
P(A_1…A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1…A_n-1)<br>
$$</p>
<ul>
<li>全概率公式</li>
</ul>
<p>$$<br>
P(A) = \sum^{n}_{i=1}P(B_i)P(A|B_i)<br>
$$</p>
<p>$$<br>
P(A)=P(B)P(A|B)+P(\overline{B})P(A|\overline{B})<br>
$$</p>
<ul>
<li>贝叶斯公式（用于计算后验概率）</li>
</ul>
<p>$$<br>
P(B|A)=\frac{P(B)P(A|B)}{P(B)P(A|B)+P(\overline{B})P(A|\overline{B})}<br>
$$</p>
<h3 id="独立性">独立性</h3>
<p>若$P(AB)=P(A)P(B)$，则称AB两事件相互独立</p>
<ul>
<li>独立重复试验</li>
</ul>
<h2 id="二：随机变量及其分布">二：随机变量及其分布</h2>
<h3 id="随机变量">随机变量</h3>
<p>定义在样本空间$\Omega$上的实值函数$X=X(\omega)$称为随机变量，$\omega$是样本点</p>
<ul>
<li>当$\omega$变化时，$X$会变化，这东西更像一个函数，不要被“变量”给迷惑了</li>
</ul>
<h4 id="随机事件">随机事件</h4>
<p>随机事件是随机变量的集合</p>
<p>若$B$是某些实数组成的集合，$B\sub R$，则${X \in B}$表示随机事件：<br>
$$<br>
{\omega:X(\omega) \in B} \sub \Omega<br>
$$<br>
特别的，${X \in B}$可以写成类似${X \le a }$、${ a &lt; X &lt; b}$</p>
<h4 id="分布列">分布列</h4>
<p>$$<br>
p(x_i) = P(X=x_i)<br>
$$</p>
<table>
<thead>
<tr>
<th>X</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>1/2</td>
<td>1/4</td>
<td>1/8</td>
<td>1/8</td>
</tr>
</tbody>
</table>
<h4 id="分布函数">分布函数</h4>
<p>设$X$是一个连续随机变量，对于任意实数$x$，称<br>
$$<br>
F(x) = P(X \le x)<br>
$$<br>
为随机变量$X$的分布函数，并称$X$服从$F(x)$，记为$X \sim F(x) $</p>
<ul>
<li>
<p>$F(x)$定义域$(-\infty， \infty)$，值域$[0, 1]$</p>
</li>
<li>
<p>$F(x)$满足</p>
<ul>
<li>单调非减</li>
<li>有界</li>
<li>右连续，即$F(x_0+0)=F(x_0)$</li>
</ul>
</li>
</ul>
<h4 id="概率密度函数">概率密度函数</h4>
<p>设随机变量$X$的分布函数为$F(x)$，如果存在实数轴上一个非负可积函数$p(x)$，使得对任意实数$x$有<br>
$$<br>
F(x) = \int^x_{-\infty}p(t)\mathrm{d}t<br>
$$<br>
则称$p(x)$为$X$的概率密度函数</p>
<p>在$F(x)$可导的点上，$F’(x)=p(x)$</p>
<ul>
<li>非负性</li>
<li>正则性</li>
</ul>
<h3 id="期望">期望</h3>
<h4 id="离散">离散</h4>
<p>对于离散随机变量$X$，其分布列为$p(x_i), i=1,2,3…n,…$</p>
<p>若级数不收敛，即<br>
$$<br>
\sum^n_{i=1}|x_i|p(x_i) &lt; \infty<br>
$$<br>
则称<br>
$$<br>
E(X) = \sum^{\infty}_{i = 1}x_i p(x_i)<br>
$$<br>
为随机变量$X$、或者该分布的数学期望</p>
<h4 id="连续">连续</h4>
<p>设连续随机变量$X$的概率密度函数为$p(x)$</p>
<p>若<br>
$$<br>
\int^{\infty}<em>{-\infty}|x|p(x)\mathrm{d}x &lt; \infty<br>
$$<br>
则称<br>
$$<br>
E(X) = \int^{\infty}</em>{-\infty}xp(x)\mathrm{d}x<br>
$$<br>
为$X$的数学期望</p>
<ul>
<li>数学期望的物理解释是重心</li>
</ul>
<h4 id="性质">性质</h4>
<p>$$<br>
E[g(X)]=\sum_{i}g(x_i)p(x_i)<br>
$$</p>
<p>$$<br>
E©=c<br>
$$</p>
<p>$$<br>
E(aX)=aE(X)<br>
$$</p>
<p>$$<br>
E[g_1(X) + g_2(X)]=E[g_1(X)]+E[g_2(X)]<br>
$$</p>
<h3 id="方差">方差</h3>
<p>$$<br>
Var(X)=E(X-E(X))^2<br>
$$</p>
<p>标准差<br>
$$<br>
\sigma(X) = \sqrt{Var(X)}<br>
$$</p>
<h4 id="性质-2">性质</h4>
<p>$$<br>
Var(X)=E(X^2)-[E(X)]^2<br>
$$</p>
<p>$$<br>
Var© = 0<br>
$$</p>
<p>$$<br>
Var(aX+b)=a^2Var(X)<br>
$$</p>
<h4 id="切比雪夫不等式">切比雪夫不等式</h4>
<p>出现大偏差的概率的上下界，与方差呈正比<br>
$$<br>
P(|X-E(X)| \ge \epsilon) \le \frac{Var(X)}{\epsilon^2}<br>
$$<br>
若方差为0，则<br>
$$<br>
P(X=E(X))=1<br>
$$</p>
<h3 id="常见分布">常见分布</h3>
<ul>
<li>
<p>离散</p>
<ul>
<li>
<p>二项分布</p>
</li>
<li>
<p>两点分布</p>
</li>
<li>
<p>泊松分布</p>
</li>
<li>
<p>超几何分布</p>
</li>
</ul>
</li>
<li>
<p>连续</p>
<ul>
<li>正态分布</li>
<li>均匀分布</li>
<li>指数分布</li>
<li>伽马分布</li>
<li>贝塔分布</li>
</ul>
</li>
</ul>
<h2 id="三：多维随机变量及其分布">三：多维随机变量及其分布</h2>
<h3 id="多维随机变量">多维随机变量</h3>
<p>如果$X_1(\omega),X_2(\omega),X_3(\omega)…X_n(\omega)$是定义在同一样本空间$\Omega = {\omega}$上的n个随机变量，则称<br>
$$<br>
X(\omega)=(X_1(\omega),X_2(\omega),X_3(\omega)…X_n(\omega))<br>
$$<br>
为N维随机变量</p>
<ul>
<li>必须为同一样本空间</li>
</ul>
<p>N个小孩中，身高是一个随机变量，体重也是一个随机变量，（身高，体重）是一个二维随机变量</p>
<h4 id="联合分布函数">联合分布函数</h4>
<p>$$<br>
F(x_1, x_2,…,x_n)=P(X_1\le x_1, X_2 \le x_2, …, X_n \le x_n)<br>
$$</p>
<p>为n维随机变量$(X_1, X_2, …,X_n)$的联合分布函数</p>
<h4 id="独立性-2">独立性</h4>
<p>若<br>
$$<br>
F(x_1, x_2,…,x_n)=\prod^n_{i=1}F_i(x_i)<br>
$$<br>
则称$X_1, X_2, …,X_n$相互独立（充要条件）</p>
<ul>
<li>简单说，独立的随机变量，联合概率密度可以直接相乘</li>
</ul>
<h4 id="期望-2">期望</h4>
<p>$$<br>
E(Z)=\sum_i \sum_j g(x_i, y_j)P(X=x_i, Y=y_j)<br>
$$</p>
<p>$$<br>
E(Z)=\int^{\infty}<em>{-\infty} \int^{\infty}</em>{-\infty} g(x,y)p(x,y)\mathrm{d}x\mathrm{d}y<br>
$$</p>
<h4 id="重期望公式">重期望公式</h4>
<p>$$<br>
E(X)=E(E(X|Y))<br>
$$</p>
<h2 id="四：大数定律与中心极限定理">四：大数定律与中心极限定理</h2>
<h3 id="收敛性">收敛性</h3>
<ul>
<li>依概率收敛：大数定律</li>
<li>按分布收敛：中心极限定理</li>
</ul>
<h4 id="依概率收敛">依概率收敛</h4>
<p>有的随机变量X的概率非常难求，如果可以找到一个简单的随机变量Y的分布来拟合X，可以大幅简化计算</p>
<p>设${X_n}$为以随机变量序列，$X$为一随机变量，对任意$\varepsilon &gt; 0$，有<br>
$$<br>
P(|X_n - X| \ge \varepsilon)\rightarrow 0 \ \ (n\rightarrow \infty)<br>
$$<br>
则称序列${X_n}$<strong>依概率收敛于X</strong>，记作$X_n \xrightarrow{P} X$</p>
<ul>
<li>简单来说，就是概率集中在某个X处</li>
</ul>
<h4 id="弱收敛">弱收敛</h4>
<p>若<br>
$$<br>
\lim_{n \rightarrow \infty}F_n(x)=F(x)<br>
$$<br>
则称${F_n(x)}$弱收敛于$F(x)$，记作$F_n(x) \xrightarrow{W} F(x)$</p>
<p>也称序列${X_n}$<strong>按分布收敛于X</strong>，记作$X_n \xrightarrow{L} X$</p>
<ul>
<li>依概率收敛比按分布收敛，收敛性更强</li>
</ul>
<h3 id="特征函数">特征函数</h3>
<p>设X是一个随机变量，称<br>
$$<br>
\varphi(t)=E(e^{itX})<br>
$$<br>
为X的特征函数</p>
<ul>
<li>任一随机变量的特征函数总是存在</li>
</ul>
<h3 id="大数定理">大数定理</h3>
<h4 id="伯努利大数定理">伯努利大数定理</h4>
<p>$$<br>
\lim_{n \rightarrow \infty}P(|\frac{S_n}{n} - p| &lt; \varepsilon)=1<br>
$$</p>
<p>意义为：随着n次数的增多，频率会越来越接近概率（随机变量序列的算数平均 依概率收敛到 其均值的算数平均）</p>
<h3 id="中心极限定理">中心极限定理</h3>
<p>在某些情况下，<strong>随机变量和</strong> 的分布函数收敛于正态分布</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/math/%E6%A6%82%E7%8E%87%E8%AE%BA/" data-id="clepy40ol001gglnkbmtecdh2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-math/球函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/math/%E7%90%83%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/math/">math</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/math/%E7%90%83%E5%87%BD%E6%95%B0/">球函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>球函数</h1>
<p>三大偏微分方程</p>
<ul>
<li>拉普拉斯方程（椭圆）</li>
<li>热方程（抛物线）</li>
<li>波方程（双曲线）</li>
</ul>
<h3 id="常微分方程">常微分方程</h3>
<p>含有未知函数的导数（含高阶导数）或微分的等式，称为<strong>微分方程</strong></p>
<p>若未知函数是一元函数，则该函数为<strong>常微分方程</strong></p>
<p>若导数的阶数为1，那么称为<strong>一阶微分方程</strong></p>
<h3 id="球坐标系">球坐标系</h3>
<p>讨论常微分方程时，边界是记为重要的，而当边界是球形时，球坐标系会更好用</p>
<img src="/images//球坐标系.webp" alt="球坐标系" style="zoom: 67%;" />
<p>直角坐标系上点$P(x,y,z)$，也可以用三个有次序的数$(r,\theta,\varphi)$表示<br>
$$<br>
\begin{cases}<br>
x=r \sin \theta \cos \varphi \<br>
y=r \sin \theta \sin \varphi \<br>
z=r\cos \theta<br>
\end{cases}<br>
$$</p>
<p>$$<br>
\begin{cases}<br>
r=\sqrt{x^2+y^2+z^2} \<br>
\theta=\arccos \frac{z}{r}	\<br>
\varphi=\arctan \frac{y}{x}<br>
\end{cases}<br>
$$</p>
<h3 id="拉普拉斯方程">拉普拉斯方程</h3>
<h4 id="拉普拉斯算符">拉普拉斯算符</h4>
<p>多元函数用梯度表示不同方向函数值变化的速度，拉普拉斯算符$\nabla$就是对多元函数求梯度</p>
<p>对梯度再次做拉普拉斯算符$\nabla ^2$，就是求<strong>梯度的散度</strong></p>
<p>在直角坐标系下，二阶拉普拉斯算符为<br>
$$<br>
\nabla^2=\frac{\partial ^2}{\partial x^2}+\frac{\partial ^2}{\partial y^2}+\frac{\partial ^2}{\partial z^2}<br>
$$<br>
在球坐标下，二阶拉普拉斯算法为（将xyz带入，化简得到）<br>
$$<br>
\nabla^2=\frac{1}{r^2}\frac{\partial}{\partial r}(r^2\frac{\partial}{\partial r})<br>
+\frac{1}{r^2\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial}{\partial \theta})<br>
+\frac{1}{r^2\sin^2 \theta }\frac{\partial^2}{\partial \varphi^2}<br>
$$</p>
<h4 id="拉普拉斯方程-2">拉普拉斯方程</h4>
<p><strong>拉普拉斯方程</strong>$\nabla^2 u=0$，表示的物理含义是：在各个方向上（比如二维直角坐标系，就是x和y方向）加速度合为0</p>
<p>这意味着什么？一个不与外界进行能量交换的系统，其拉普拉斯方程为0</p>
<ul>
<li>一个不受外力的系统，其整体加速度为0</li>
<li>一个不与外界传热的系统，其整体能量传播为0</li>
<li>一个理想的简谐振动</li>
<li>闭合磁场、电场</li>
</ul>
<p>我们称拉普拉斯方程为0的函数叫做<strong>Harmonic</strong></p>
<h4 id="球坐标系下的拉普拉斯方程">球坐标系下的拉普拉斯方程</h4>
<p>函数$u(r,\theta,\varphi)$的拉普拉斯方程为<br>
$$<br>
\nabla^2u=\frac{1}{r^2}\frac{\partial}{\partial r}(r^2\frac{\partial u}{\partial r})<br>
+\frac{1}{r^2\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial u}{\partial \theta})<br>
+\frac{1}{r^2\sin^2 \theta }\frac{\partial^2 u}{\partial \varphi^2}=0<br>
$$<br>
我们将距离和方向分离，得到<br>
$$<br>
u(r,\theta,\varphi)=R®Y(\theta,\varphi)<br>
$$</p>
<ul>
<li>$R®$表示距离</li>
<li>$Y(\theta,\varphi)$表示方向，被称为球函数</li>
</ul>
<p>带入可得<br>
$$<br>
\frac{Y}{r^2}\frac{\mathrm{d}}{\mathrm{d} r}(r^2\frac{\mathrm{d} R}{\mathrm{d} r})<br>
+\frac{R}{r^2\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial Y}{\partial \theta})<br>
+\frac{R}{r^2\sin^2 \theta }\frac{\partial^2 Y}{\partial \varphi^2}=0<br>
$$<br>
移项、化简可得<br>
$$<br>
\frac{1}{R}\frac{\mathrm{d}}{\mathrm{d} r}(r^2\frac{\mathrm{d} R}{\mathrm{d} r})<br>
=-\frac{1}{\sin \theta Y}\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial Y}{\partial \theta})<br>
-\frac{1}{Y}\frac{1}{\sin^2 \theta }\frac{\partial^2 Y}{\partial \varphi^2}<br>
$$<br>
我们发现，这个方程左边是与$R$有关的函数，右边是与$\theta,\varphi$有关的函数，显然两者不可能相等，除非他们同时等于一个常数</p>
<p>我们令这个常数为$l(l+1)$，于是得到两个方程<br>
$$<br>
\frac{\mathrm{d}}{\mathrm{d} r}(r^2\frac{\mathrm{d} R}{\mathrm{d} r})-l(l+1)R=0<br>
$$</p>
<p>$$<br>
\frac{1}{\sin \theta }\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial Y}{\partial \theta})<br>
+\frac{1}{\sin^2 \theta }\frac{\partial^2 Y}{\partial \varphi^2}<br>
+l(l+1)Y=0<br>
$$</p>
<p>第二个方程叫做<strong>球函数方程</strong></p>
<p>如果我们进一步分离变量，令<br>
$$<br>
Y(\theta,\varphi)=\Theta(\theta)\Phi(\varphi)<br>
$$<br>
带入球函数方程，化简得到两个常微分方程<br>
$$<br>
\Phi’'+\lambda \Phi=0<br>
$$</p>
<p>$$<br>
\sin \theta \frac{\mathrm{d}}{\mathrm{d} \theta}(\sin \theta \frac{\mathrm{d \Theta}}{\mathrm{d} \theta})+[l(l+1)\sin^2\theta-\lambda]\Theta=0<br>
$$</p>
<h4 id="连带勒让德方程">连带勒让德方程</h4>
<p>上一步我们得到了两个常微分方程，第一个方程和<strong>自然周期条件</strong>构成本征值问题，在经过很多步的推导化简（感觉这些内容对我来说有些超纲），可以把第二个式子改写为<br>
$$<br>
(1-x^2)\frac{\mathrm{d}^2\Theta}{\mathrm{d}x^2}-2x\frac{\mathrm{d}\Theta}{\mathrm{d}x}+[l(l+1)-\frac{m^2}{1-x^2}]\Theta=0<br>
$$<br>
这个式子被称为$l$阶<strong>连带勒让德方程</strong></p>
<p>这个式子的解，即函数$\Theta$的表达式为<strong>连带勒让德函数</strong></p>
<h3 id="级数解法">级数解法</h3>
<p>用球坐标系对拉普拉斯方程进行分离变数，得到了连带勒让德方程等特殊的函数方程，这些方程大多都是线性二阶常微分方程，很难用常规办法解，但可以用<strong>级数解法</strong>解出</p>
<h4 id="常点与奇点">常点与奇点</h4>
<p>对于一个复变函数的线性二阶常微分方程<br>
$$<br>
\frac{\mathrm{d}^2w}{\mathrm{d}z^2}+p(z)\frac{\mathrm{d}w}{\mathrm{d}z}+q(z)w=0<br>
$$<br>
若系数函数$p(z)$、$q(z)$在点$z_0$的邻域中是解析的，则点$z_0$叫做该方程的<strong>常点</strong>，若点$z_0$是奇点，则点$z_0$叫做该方程的<strong>奇点</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/math/%E7%90%83%E5%87%BD%E6%95%B0/" data-id="clepy40om001jglnk4di5awk3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-math/线性代数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/math/">math</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">线性代数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>线性代数</h1>
<h2 id="一：线性方程组">一：线性方程组</h2>
<h3 id="概念">概念</h3>
<ul>
<li>线性方程</li>
<li>线性方程组</li>
<li>系数</li>
<li>解：一组能让方程左右相等的数</li>
<li>解集：方程组的所有解的集合</li>
<li>等价：若两个线性方程组拥有相同解集，则两者等价</li>
<li>相容：方程组有一个或无穷多个解</li>
<li>不相容：方程组无解</li>
</ul>
<h3 id="矩阵">矩阵</h3>
<p>方程组<br>
$$<br>
\begin{gathered}<br>
x_1-2x_2+x_3=0 \\<br>
2x_2-8x_3=8 \\<br>
5x_1-5x_3=10<br>
\end{gathered}<br>
$$<br>
的<strong>系数矩阵</strong>为<br>
$$<br>
\left[ \begin{matrix}1&amp;-2&amp;1\\ 0&amp;2&amp;-8\\ 5&amp;0&amp;-5\end{matrix} \right]<br>
$$<br>
<strong>增广矩阵</strong>为<br>
$$<br>
\left[ \begin{matrix}1&amp;-2&amp;1&amp;0\\ 0&amp;2&amp;-8&amp;8\\ 5&amp;0&amp;-5&amp;10\end{matrix} \right]<br>
$$<br>
这个增广矩阵，3行4列，是一个3x4的矩阵</p>
<p>我们对增广矩阵进行多次矩阵运算，于是得到<br>
$$<br>
\left[ \begin{matrix}1&amp;0&amp;0&amp;1\\ 0&amp;1&amp;0&amp;0\\ 0&amp;0&amp;1&amp;-1\end{matrix} \right]<br>
$$<br>
于是原方程有且仅有一个解$(1,0,-1)$</p>
<h4 id="初等行变换">初等行变换</h4>
<p>也就是行简化</p>
<ul>
<li>
<p>倍加：<code>a=a+nb</code>，把某行加上某一行的倍数</p>
</li>
<li>
<p>对换：<code>swap(a,b)</code>，把某两行对换</p>
</li>
<li>
<p>倍乘：<code>a *= n (n!=0)</code>，把某行所有元素乘以一个非零的数</p>
</li>
</ul>
<h4 id="阶梯矩阵">阶梯矩阵</h4>
<p>形如<br>
$$<br>
\left[ \begin{matrix}x&amp;<em>&amp;</em>&amp;<em>\\ 0&amp;x&amp;</em>&amp;<em>\\ 0&amp;0&amp;x&amp;</em>\end{matrix} \right]<br>
$$<br>
的矩阵，被称为<strong>阶梯形</strong></p>
<ul>
<li>$x$为先导元素，非零
<ul>
<li>若先导元素均为1，而且该<strong>列</strong>只有先导元素非零，则矩阵被称为<strong>简化阶梯形</strong></li>
<li>$x$所在的位置被称为主元位置，拥有主元的列被称为<strong>主元列</strong></li>
</ul>
</li>
<li>$*$取任意值</li>
</ul>
<h4 id="行简化">行简化</h4>
<ul>
<li>任何非零矩阵都可以行简化为阶梯形矩阵</li>
<li>简化阶梯形具有唯一性</li>
</ul>
<h4 id="线性方程的解">线性方程的解</h4>
<p>对增广矩阵运用行简化，得到一个简化阶梯形<br>
$$<br>
\left[ \begin{matrix}1&amp;0&amp;-5&amp;1\\ 0&amp;1&amp;1&amp;4\\ 0&amp;0&amp;0&amp;0\end{matrix} \right]<br>
$$<br>
对应的线性方程组为<br>
$$<br>
\begin{gathered}<br>
x_1-5x_3=1 \\<br>
x_2+x_3=4 \\<br>
0=0<br>
\end{gathered}<br>
$$</p>
<ul>
<li>其中$x_1,x_2$为基本变量，$x_3$为自由变量</li>
</ul>
<p>于是可以得到线性方程组的<strong>通解</strong><br>
$$<br>
\begin{cases}<br>
x_1=1+5x_3&amp;\\<br>
x_2=4-x_3&amp;\\<br>
x_3是自由变量<br>
\end{cases}<br>
$$</p>
<h3 id="向量方程">向量方程</h3>
<h4 id="向量">向量</h4>
<p>n维向量可以写成nx1列矩阵的形式<br>
$$<br>
\mu=\begin{bmatrix}<br>
1\\ 1\\ \vdots \\ 1<br>
\end{bmatrix}<br>
$$</p>
<ul>
<li>所有元素为0的向量称为零向量</li>
<li>当且仅当两个向量对应元素全相等时，两向量<strong>相等</strong></li>
</ul>
<p>为了方便书写，我们会将n维向量横着写（注意！用的是括号，并且相邻元素间用逗号隔开）<br>
$$<br>
(1,1,…,1)<br>
$$</p>
<h4 id="向量方程-2">向量方程</h4>
<p>向量方程：<br>
$$<br>
x_1\mathbf{a_1}+x_2\mathbf{a_2}+…+x_n\mathbf{a_n}=\mathbf{b}<br>
$$<br>
的解，等同于增广矩阵为<br>
$$<br>
\begin{bmatrix}\mathbf{a_1}&amp;\mathbf{a_2}&amp;…&amp;\mathbf{a_n}\end{bmatrix}<br>
$$<br>
的线性方程组的解</p>
<ul>
<li>
<p>$Span{\nu}$</p>
</li>
<li>
<p>$Span{\nu_1,\nu_2,…,\nu_n }$</p>
</li>
</ul>
<h3 id="矩阵运算">矩阵运算</h3>
<p>$$<br>
A\mathbf{x}=<br>
\begin{bmatrix}\mathbf{a_1}&amp;\mathbf{a_2}&amp;…&amp;\mathbf{a_n}\end{bmatrix}<br>
\begin{bmatrix}x_1\\ x_2\\ \vdots \\ x_n\end{bmatrix}<br>
=x_1\mathbf{a_1}+x_2\mathbf{a_2} + …+x_n\mathbf{a_n}<br>
$$</p>
<ul>
<li>当且仅当左边的列数等于右边的行数，才可以运算（横乘竖）</li>
</ul>
<img src="/images/横乘竖.png" alt="横乘竖" style="zoom:50%;" />
<h4 id="矩阵方程">矩阵方程</h4>
<p>$$<br>
A\mathbf{x}=\mathbf{b}<br>
$$</p>
<h3 id="齐次线性方程组">齐次线性方程组</h3>
<p>若线性方程的常数项为0，则称该线性方程为齐次的，可以写成<br>
$$<br>
A\mathbf{x}=\mathbf{0}<br>
$$<br>
的形式</p>
<ul>
<li>齐次线性方程必有一个平凡解，即$\mathbf{x}=\mathbf{0}$</li>
<li>齐次线性方程有非平凡解，当且仅当方程组至少有一个自由变量</li>
</ul>
<p>要判断$A\mathbf{x}=\mathbf{0}$有无非平凡解</p>
<ol>
<li>写出方程组的增广矩阵$[A, \mathbf{0}]$</li>
<li>将矩阵化简为简化阶梯形</li>
<li>若存在某一行全为0（该行对应的变量就是<strong>自由变量</strong>），则有非平凡解
<ol>
<li>哪些不全为0的行所对应的变量称为<strong>基本变量</strong></li>
</ol>
</li>
</ol>
<h3 id="线性无关">线性无关</h3>
<p>若线性方程仅有平凡解，则该组向量（矩阵各列）线性无关</p>
<h4 id="矩阵-2">矩阵</h4>
<p>要判断某个<strong>矩阵</strong>各列是否线性无关：</p>
<ol>
<li>写出矩阵的增广矩阵$[A, \mathbf{0}]$</li>
<li>对矩阵进行行简化</li>
<li>若矩阵没有自由变量，则说明各列线性无关</li>
</ol>
<h4 id="向量的集合">向量的集合</h4>
<ul>
<li>
<p><strong>一个向量</strong>的集合线性无关的条件：当且仅当向量不是零向量</p>
</li>
<li>
<p><strong>两个向量</strong>的集合线性相关的条件：当且仅当某个（非零）向量是另一个（非零）向量的倍数</p>
</li>
<li>
<p><strong>多个向量</strong>的集合线性相关的条件：当且仅当至少有一个向量是其他向量的线性组合</p>
<ul>
<li>若一个向量组中向量个数多于每个向量的元素个数，那么这个向量组线性相关（充分条件）</li>
</ul>
</li>
</ul>
<p>能看出，两个向量属于多个向量</p>
<h3 id="线性变换">线性变换</h3>
<h4 id="变换">变换</h4>
<p>$$<br>
A\mathbf{x}=\mathbf{b}<br>
$$</p>
<p>一个n维向量左乘一个m行n列的矩阵，会得到一个m维的向量</p>
<p>我们称$\mathrm{R}^n \rightarrow \mathrm{R}^m$这个过程为一个<strong>变换</strong>，也可以叫做函数、映射</p>
<p>变化的规则为$T$，$\mathrm{R}^n$被称为$T$的<strong>定义域</strong>，$\mathrm{R}^m$被称为$T$的<strong>余定义域</strong></p>
<p>对于$\mathrm{R}^n$中的一个向量$x$，其在$\mathrm{R}^m$中的向量$T(x)$被称为$x$的<strong>像</strong>，所有的像的集合被称为<strong>值域</strong></p>
<p><img src="/images/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" alt="线性变换"></p>
<h4 id="线性变换-2">线性变换</h4>
<p>若定义域中的一切向量满足</p>
<ul>
<li>$T(\mathbf{u}+\mathbf{v})=T(\mathbf{u})+T(\mathbf{v}) $</li>
<li>$T(c\mathbf{u})=cT(\mathbf{u})$</li>
</ul>
<p>则称该变换为<strong>线性变换</strong></p>
<p>线性变换的性质：</p>
<ul>
<li>$T(\mathbf{0})=\mathbf{0}$</li>
<li>$T(c\mathbf{u}+d\mathbf{v})=cT(\mathbf{u})+dT(\mathbf{v}) $</li>
</ul>
<p>若n等于m，$T(\mathbf{x})=r \ \mathbf{x}$</p>
<ul>
<li>若<code>r &gt; 1</code>，则称为拉伸变换</li>
<li>若<code>0 &lt; r &lt; 1</code>，则称为压缩变化</li>
</ul>
<h4 id="变化矩阵">变化矩阵</h4>
<p>二维空间的变化矩阵为，$(x_1, y_1)$为变化后单位正方形右下角的位置，$(x_2, y_2)$为变化后单位正方形左上角的位置<br>
$$<br>
\left[ \begin{matrix}x_1&amp;x_2\\ y_1&amp;y_2\end{matrix} \right]<br>
$$<br>
<img src="/images/%E5%8D%95%E4%BD%8D%E6%AD%A3%E6%96%B9%E5%BD%A2.png" alt="单位正方形"></p>
<p><img src="/images/%E5%AF%B9%E7%A7%B0.png" alt="对称"></p>
<h2 id="二：矩阵代数">二：矩阵代数</h2>
<h3 id="矩阵-3">矩阵</h3>
<p>对于一个mxn的矩阵，也就是m行n列的矩阵，我们可以写作<br>
$$<br>
A=[\mathbf{a}_1 \ \mathbf{a}_2\ \cdots \mathbf{a}_n]<br>
$$</p>
<!---->
<p>其中</p>
<img src="/images/矩阵的列.png" alt="矩阵的列" style="zoom:50%;" />
<p>矩阵A的对角元素为$a_{11}, a_{22}, \cdots$，他们组成了矩阵A的<strong>主对角线</strong></p>
<p><strong>对角矩阵</strong>：非对角线元素全为0的矩阵</p>
<p><strong>零矩阵</strong>：元素全为0的矩阵，根据其尺寸，可以写为$\mathbf{0}_{m \times n}$</p>
<h3 id="矩阵运算-2">矩阵运算</h3>
<p>矩阵相等：维数相同且对应元素均相同</p>
<p>矩阵相加：维数相同的矩阵才能相加，结果为对应元素相加</p>
<p>矩阵标量乘：矩阵所有元素乘一个标量</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" data-id="clepy40on001mglnk5jy6hjk2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/dcc/">dcc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/engine/">engine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/graphics/">graphics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/math/">math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/optics/">optics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/program/">program</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DX12/" rel="tag">DX12</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deferred-Render/" rel="tag">Deferred Render</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metal/" rel="tag">Metal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PM/" rel="tag">PM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Physics/" rel="tag">Physics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SIGGRAPH/" rel="tag">SIGGRAPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPH/" rel="tag">SPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TA/" rel="tag">TA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unreal/" rel="tag">Unreal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shader/" rel="tag">shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%89%E5%AD%A6/" rel="tag">光学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" rel="tag">并行计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" rel="tag">微积分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C#</a> <a href="/tags/C/" style="font-size: 17.5px;">C++</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/DX12/" style="font-size: 10px;">DX12</a> <a href="/tags/Deferred-Render/" style="font-size: 10px;">Deferred Render</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/GI/" style="font-size: 15px;">GI</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Metal/" style="font-size: 10px;">Metal</a> <a href="/tags/PM/" style="font-size: 10px;">PM</a> <a href="/tags/Physics/" style="font-size: 12.5px;">Physics</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/SIGGRAPH/" style="font-size: 15px;">SIGGRAPH</a> <a href="/tags/SPH/" style="font-size: 12.5px;">SPH</a> <a href="/tags/TA/" style="font-size: 15px;">TA</a> <a href="/tags/Unity/" style="font-size: 12.5px;">Unity</a> <a href="/tags/Unreal/" style="font-size: 10px;">Unreal</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/shader/" style="font-size: 10px;">shader</a> <a href="/tags/%E5%85%89%E5%AD%A6/" style="font-size: 20px;">光学</a> <a href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" style="font-size: 10px;">并行计算</a> <a href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" style="font-size: 10px;">微积分</a> <a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 17.5px;">高等数学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/02/26/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/">光学复习</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E8%A1%8D%E5%B0%84/">衍射</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E5%B9%B2%E6%B6%89/">干涉</a>
          </li>
        
          <li>
            <a href="/2023/02/18/program/AskQuestion/">提问的智慧</a>
          </li>
        
          <li>
            <a href="/2023/02/13/graphics/DOSDF/">Dynamic Occlusion with SDF</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Reuben Sun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>