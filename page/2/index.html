<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ReubenSun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Reuben的笔记博客">
<meta property="og:type" content="website">
<meta property="og:title" content="ReubenSun">
<meta property="og:url" content="http://reuben-sun.github.io/page/2/index.html">
<meta property="og:site_name" content="ReubenSun">
<meta property="og:description" content="Reuben的笔记博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Reuben Sun">
<meta property="article:tag" content="reubensun computer graphics engine Technical Artist">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="ReubenSun" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ReubenSun</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://reuben-sun.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-graphics/SPH" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/02/graphics/SPH/" class="article-date">
  <time datetime="2023-02-02T22:16:25.000Z" itemprop="datePublished">2023-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/02/graphics/SPH/">SPH：入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>SPH入门</h1>
<p>SPH（Smoothed Particle Hydrodynamics）光滑粒子流体力学</p>
<blockquote>
<p>A mesh-free method for the discretization of functions and partial differential operators</p>
</blockquote>
<p>SPH是一种基于拉格朗日视角的算法，是一种空间离散化的算法，常用于连续介质的数值模拟</p>
<ul>
<li>
<p>材质导数的坐标</p>
<ul>
<li>
<p>拉格朗日坐标：视角随着介质移动而移动（粒子模拟）</p>
</li>
<li>
<p>欧拉坐标：视角是固定的，检测穿过视角的介质流速（网格模拟）</p>
</li>
</ul>
</li>
</ul>
<p><img src="/images/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5.png" alt="拉格朗日"></p>
<p>SPH进行简单流体模拟，简单来说就是</p>
<ol>
<li>介质离散化，使用多个质点来表示流体（离散化）</li>
<li>对于每一个粒子，找到它附近的粒子（临域搜索）</li>
<li>计算密度（质量密度估计）</li>
<li>计算压强（控制方程，如理想气体状态方程+动量守恒），压强差、粘滞力等</li>
<li>更新运动状态</li>
<li>水体渲染（Marching Cube）</li>
</ol>
<h2 id="离散化">离散化</h2>
<h3 id="狄拉克函数">狄拉克函数</h3>
<p>狄拉克$\delta$函数，这是一个广义函数，其在整个定义域中积分值都集中在原点<br>
$$<br>
\delta (\mathbf{r})= \begin{cases}<br>
\infty &amp; |\mathbf{r}|=0 \\<br>
0 &amp; otherwise<br>
\end{cases}<br>
$$<br>
该函数仅在积分中有意义，可以通过高斯钟形函数（正态分布）逼近</p>
<p><img src="/images/%E9%AB%98%E6%96%AF%E9%92%9F%E5%BD%A2.png" alt="高斯钟形"></p>
<p>在物理学中我们常用质点表示物体，但是因此使得密度函数失去了意义（因为质点没有空间），此时密度函数就塌缩成了狄拉克函数</p>
<p>空间中任何标量场函数，都可以用狄拉克函数表示：<br>
$$<br>
A(\mathbf{x})=(A*\delta)(\mathbf{x})=\int A(\mathbf{x}‘)\delta (\mathbf{x}-\mathbf{x}’)dv’<br>
$$</p>
<ul>
<li>$dv’$是$\mathbf{x}'$对应的体积积分变量</li>
<li>$A(\mathbf{x}): \mathbb{R}^d \rightarrow \mathbb{R}$，d是维度，意思就是这是一个空间函数</li>
</ul>
<blockquote>
<p>$\mathbb{R}$是实数集</p>
<p>$\mathbb{R}^+$是正实数集（不含0）</p>
<p>$\mathbb{R}^d$是d维实数集</p>
</blockquote>
<h3 id="光滑核函数">光滑核函数</h3>
<p>我们有了狄拉克函数，想要把连续函数来离散表示</p>
<p>核函数（kernel functions，smoothing kernels）是一种随着距离而衰减的函数，与高斯函数要在整个作用域积分不同，核函数是有最大影响半径的，最大影响半径用$h$表示</p>
<img src="/images/核函数.png" alt="核函数" style="zoom:50%;" />
<p>核函数满足</p>
<ol>
<li>归一化</li>
<li>狄拉克条件</li>
<li>非负性</li>
<li>对称性</li>
<li>有界性</li>
</ol>
<p><img src="/images/%E6%A0%B8%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8.png" alt="核函数性质"></p>
<p>一个经典的核函数是三次样条器（cubic spline kernel）</p>
<p><img src="/images/%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%99%A8.png" alt="三次样条器"></p>
<ul>
<li>其中$q=\frac{1}{h}||\mathbf{r}||$</li>
</ul>
<h3 id="离散化-2">离散化</h3>
<blockquote>
<p>有个数学大佬告诉我，这里就是“在某个i点处求所有其他j点按核函数加权的平均值，只不过离散化的时候划成了区块赋予了密度和体积”</p>
<p>换句话说，这其实就是一次卷积（数学家真是不讲人话）</p>
</blockquote>
<p>参考上面那张核函数的图，离散化就是对于$i$点，我们求该点附近场密度函数值和核函数（一堆$j$点）的加权平均值</p>
<img src="/images/离散化.png" alt="离散化" style="zoom:50%;" />
<p>在数学上，$\langle A(x)\rangle $表示平均值</p>
<h3 id="质量密度估计">质量密度估计</h3>
<p>粒子不需要携带质量密度函数，对于空间中任意位置的点，都可以通过离散化求出该点密度</p>
<p>对于$\mathbf{x}_i$位置处的点，其密度为：</p>
<p>$$<br>
\rho_{i} =\sum_{j} m_{j}W_{ij}<br>
$$<br>
不过在流体边界，这样求密度会导致数据偏小，需要做边界处理</p>
<p>下图绿色点临域完整，得到正确的密度，而红色点只能得到一个较小的密度</p>
<img src="/images/流体边界.png" alt="流体边界" style="zoom:50%;" />
<h3 id="微分算子的离散化">微分算子的离散化</h3>
<p>上面我们已经实现场函数的离散化，实现了质量密度估计。但除此之外，还有一些空间微分算子（导数）值得离散化<br>
$$<br>
\nabla A_{i}\approx \sum_{j} A_{j}\frac{m_{j}}{\rho_{j} } \nabla W_{ij}<br>
$$</p>
<blockquote>
<p>关于拉普拉斯算符，可以去看<a href="/2023/01/31/math/Nabla%E7%AE%97%E5%AD%90/">Nabla算子</a>，简单来说这东西是将标量场转化为向量场，一阶算符就是梯度，二阶是散度，用于得到数据变化最快的方向。文中也实现了拉普拉斯算符的离散化</p>
</blockquote>
<p>文章介绍了两种最常用的梯度的近似方法，并给了适用范围</p>
<ul>
<li>差分公式（Difference Formula）：用于近似速度的散度</li>
<li>对称公式（Symmetric Formula）：用于近似力、脉冲的梯度</li>
</ul>
<h4 id="差分公式">差分公式</h4>
<p>在高中学微积分时，我们用两个相邻的点组成的线来逼近切线，以此引入了极限、导数的概念。在实际应用中，这两个点不可能无穷近，于是存在误差</p>
<p>使用差分表示导数（导数就是），我们只能把$h$取到一个很小的值，而不是无穷小，因此这个导数是有误差的<br>
$$<br>
f’(x)=\lim_{h \rightarrow0}\frac{f(x+h/2)-f(x-h/2)}{h}<br>
$$<br>
我们需要衡量这个误差的大小，于是我们将$f(x\pm h/2)$泰勒展开后带入上式，得到<br>
$$<br>
f’(x)=\lim_{h \rightarrow0}\frac{f’(x)h+O(h^3)}{h}=f’(x)+O(h^2)<br>
$$<br>
误差大小为$O(h^2)$</p>
<blockquote>
<p>经计算，二阶导数的误差也是$O(h^2)$</p>
</blockquote>
<h4 id="对称公式">对称公式</h4>
<h2 id="临域搜索">临域搜索</h2>
<p>这里介绍最简单的，不做空间优化的临域搜索，进阶内容可以看<a href="2023/02/06/graphics/%E9%82%BB%E5%9F%9F%E6%90%9C%E7%B4%A2/">临域搜索</a></p>
<p>由于核函数存在作用范围，我们在积分时，只需要遍历核半径内其他粒子的信息。这样相较于nxn的全遍历，能大幅减少计算，为此我们需要构建临域表</p>
<h3 id="网格化">网格化</h3>
<p>临域搜索是一种基于网格（grid）构建粒子拓扑关系的算法，找到该粒子所在位置和其相邻位置有哪些粒子</p>
<p>我们将整个（粒子作用的）场景均匀切分为一个个三维网格，每个网格为立方体，边长等于核半径$\hslash $，</p>
<p>每个网格拥有一个坐标$(i,j,k)$，用于表示网格在场景中的位置</p>
<p>对于任意一个粒子，其核函数的作用范围是一个球，临域搜索就是计算球内有哪些粒子</p>
<img src="/images/grid.png" alt="grid" style="zoom: 33%;" />
<ol>
<li>空间网格化</li>
<li>遍历粒子，记录每个网格中有多少个粒子，有哪些粒子</li>
<li>遍历粒子，建立临域表
<ol>
<li>求该粒子的核函数球位于哪些网格中</li>
<li>遍历那些网格，取出网格中所有粒子，计算距离</li>
<li>将距离小于核半径的粒子id存储在临域表中</li>
</ol>
</li>
</ol>
<h3 id="数据结构">数据结构</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>_neighbourList</td>
<td>id.x * maximumParticlesPerCell * 8 + _neighbourTracker[id.x]++</td>
<td>临居的id</td>
</tr>
<tr>
<td>_neighbourTracker</td>
<td>id.x</td>
<td>当前粒子有多少个临居</td>
</tr>
<tr>
<td>_hashGrid</td>
<td>hashCellIdx * maximumParticlesPerCell + previousCount</td>
<td>id.x</td>
</tr>
<tr>
<td>_hashGridTracker</td>
<td>hashCellIdx</td>
<td>该网格中的粒子数</td>
</tr>
</tbody>
</table>
<ul>
<li>id.x：当前粒子id</li>
<li>hashCellIdx：网格坐标的Hash值</li>
<li>maximumParticlesPerCell：每个网格的的粒子最大数量（提前留好空）</li>
<li>previousCount：空里有几个粒子</li>
</ul>
<h3 id="球作用于哪些网格">球作用于哪些网格</h3>
<p>我们发现核函数球最少位于8个网格中（一个2x2x2的立方体），最多位于27个网格中（一个3x3x3的立方体），我们只需要找出核函数球位于哪些网格中，就能减少很多便利</p>
<p>在这里，我们只使用8个网格作为临域（舍弃那些不重要的网格），很显然，球心向哪个方向靠，我们就使用哪8个网格</p>
<ol>
<li>找到球心所在网格坐标，构建临域坐标表，临域坐标初始均设为球心位置</li>
<li>判断中心网格的中心坐标与球心的坐标位置关系</li>
<li>存储临域Hash Key</li>
</ol>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">GetNearbyKeys</span><span class="token punctuation">(</span>int3 originIndex<span class="token punctuation">,</span> float3 position<span class="token punctuation">,</span> out <span class="token keyword">int</span> nearbyKeys<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    int3 nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        nearbyBucketIndices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> originIndex<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>originIndex<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">)</span> <span class="token operator">*</span> CellSize <span class="token operator">&lt;=</span> position<span class="token punctuation">.</span>x<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>        
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>originIndex<span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">)</span> <span class="token operator">*</span> CellSize <span class="token operator">&lt;=</span> position<span class="token punctuation">.</span>y<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>originIndex<span class="token punctuation">.</span>z <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">)</span> <span class="token operator">*</span> CellSize <span class="token operator">&lt;=</span> position<span class="token punctuation">.</span>z<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        nearbyBucketIndices<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        int3 nbcellIndex <span class="token operator">=</span> nearbyBucketIndices<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nbcellIndex<span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nbcellIndex<span class="token punctuation">.</span>x <span class="token operator">>=</span> Dimensions <span class="token operator">||</span> nbcellIndex<span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nbcellIndex<span class="token punctuation">.</span>y <span class="token operator">>=</span> Dimensions <span class="token operator">||</span> nbcellIndex<span class="token punctuation">.</span>z <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nbcellIndex<span class="token punctuation">.</span>z <span class="token operator">>=</span> Dimensions<span class="token punctuation">)</span> 
        <span class="token punctuation">&#123;</span>
            nearbyKeys<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>		<span class="token comment">//出界了</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> 
        <span class="token punctuation">&#123;</span>
            nearbyKeys<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Hash</span><span class="token punctuation">(</span>nearbyBucketIndices<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//将三维坐标转化为一维hash key</span>
<span class="token keyword">int</span> <span class="token function">Hash</span><span class="token punctuation">(</span>int3 cell<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> cell<span class="token punctuation">.</span>x <span class="token operator">+</span> Dimensions <span class="token operator">*</span> <span class="token punctuation">(</span>cell<span class="token punctuation">.</span>y <span class="token operator">+</span> Dimensions <span class="token operator">*</span> cell<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="构建临域表">构建临域表</h3>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token function">numthreads</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">void</span> <span class="token function">BuildNeighbourList</span><span class="token punctuation">(</span>uint3 id <span class="token operator">:</span> SV_DispatchThreadID<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    _neighbourTracker<span class="token punctuation">[</span>id<span class="token punctuation">.</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> int3 cell <span class="token operator">=</span> <span class="token function">GetCell</span><span class="token punctuation">(</span>_particles<span class="token punctuation">[</span>id<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> cells<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">GetNearbyKeys</span><span class="token punctuation">(</span>cell<span class="token punctuation">,</span> _particles<span class="token punctuation">[</span>id<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>position<span class="token punctuation">,</span> cells<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>uint j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cells<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// Grid does not contain cell.</span>
        <span class="token keyword">const</span> uint numberOfParticlesInCell <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>_hashGridTracker<span class="token punctuation">[</span>cells<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> maximumParticlesPerCell<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>uint index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> numberOfParticlesInCell<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">const</span> uint potentialNeighbour <span class="token operator">=</span> _hashGrid<span class="token punctuation">[</span>cells<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> maximumParticlesPerCell <span class="token operator">+</span> index<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>potentialNeighbour <span class="token operator">==</span> id<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token keyword">const</span> float3 v <span class="token operator">=</span> _particles<span class="token punctuation">[</span>potentialNeighbour<span class="token punctuation">]</span><span class="token punctuation">.</span>position <span class="token operator">-</span> _particles<span class="token punctuation">[</span>id<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>position<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> radius2<span class="token punctuation">)</span> <span class="token comment">// Use squared length (= dot) instead of length for performance.</span>
            <span class="token punctuation">&#123;</span>
                _neighbourList<span class="token punctuation">[</span>id<span class="token punctuation">.</span>x <span class="token operator">*</span> maximumParticlesPerCell <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">+</span> _neighbourTracker<span class="token punctuation">[</span>id<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> potentialNeighbour<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h2 id="控制方程">控制方程</h2>
<p>尽管物体在微观层面（比如原子）是离散的，但在宏观层面上，流体、固体表现为连续介质</p>
<blockquote>
<p>continuum, a region of continuously distributed mass</p>
</blockquote>
<p>根据定义，一个连续介质可以被切分为多个小的连续介质（类比实数的稠密性，任意两个实数间总存在第三个实数），而不影响其性质</p>
<p>材料粒子（material particle）：a portion of matter contained in an infinitesimal volume</p>
<h3 id="连续性方程">连续性方程</h3>
<p>连续性方程描述了物体的密度与时间的关系<br>
$$<br>
\frac{D\rho}{Dt}=-\rho(\nabla \cdot \mathbf{v})<br>
$$</p>
<h3 id="随体导数">随体导数</h3>
<p>随体导数（material derivative）：$\frac{D(\cdot)}{Dt}$</p>
<p>随体导数描述了材质点的场量随着时间的变化率</p>
<p>在制作不可压缩的介质中，必须始终保持<br>
$$<br>
\frac{D\rho}{Dt}=0<br>
$$<br>
随体导数与坐标系有关，常见的坐标系有：拉格朗日坐标系和欧拉坐标系</p>
<h3 id="线性动量守恒定律">线性动量守恒定律</h3>
<p>高中物理就学过的碰撞时动量守恒，力作用在物体上，会改变物体的动量</p>
<p>将运动公式（equation of motion）用积分的形式写出来就是<br>
$$<br>
\rho \frac{D^2\mathbf{x}}{Dt^2}=\nabla \cdot \mathbf{T}+\mathbf{f}_{ext}<br>
$$</p>
<ul>
<li>$\mathbf{T}$：应力张量（stress tensor）</li>
<li>$\mathbf{f}_{ext}$：体积力（body forces），穿越空间作用在所有流体元上的非接触力，例如重力、惯性力、电磁力</li>
</ul>
<h4 id="理解应力张量">理解应力张量</h4>
<p>对于材质内部一个微小平面，这个平面会受材质中其他点的作用力，这个力可能不与平面垂直。其中垂直于平面的力叫正向应力，平行于平面的力叫剪应力</p>
<p>矢量是一种一维张量，由大小和一个方向组成。然而对于应力，我们没法使用矢量进行表示，于是改用二维张量来表示，一个方向是应力的指向，一个方向是应力所在的平面方向</p>
<p>对于材质内一个点，它可能处于无数个平面中，我们需要用一种平面无关的方式来表示其受力状态。在三维空间中，我们选择了三组正交基底$(\mathbf{e}_1,\mathbf{e}_2,\mathbf{e}_3)$构建坐标系，应用中给定一个方向$\mathbf{e}$，就能求出该方向的应力矢量</p>
<img src="/images/应力张量.png" alt="应力张量" style="zoom:50%;" />
<p>其中$\mathbf{T}$为应力矢量，$\sigma $为柯西应力张量（一个3x3的矩阵）</p>
<p>$\sigma_{xy}$的意思是，处于yz平面，指向y方向</p>
<img src="/images/柯西应力张量.png" alt="柯西应力张量" style="zoom:50%;" />
<img src="/images/三维应力.png" alt="三维应力" style="zoom:50%;" />
<blockquote>
<p>柯西应力张量只适用于材料微小变形的情况</p>
</blockquote>
<h4 id="Navier-Stokes方程">Navier-Stokes方程</h4>
<p>一个经典的不可压缩流体的张力表示方法<br>
$$<br>
\mathbf{T}=-p+\mu (\nabla \mathbf{v}+\nabla  \mathbf{v}^T)<br>
$$</p>
<ul>
<li>$p$：压强</li>
<li>$\mu$：粘度（viscosity ）</li>
</ul>
<p>我们将该液体的应力张量公式带入牛顿运动公式，得到速度的公式<br>
$$<br>
\rho \frac{D\mathbf{v}}{Dt}=-\nabla p + \mu \nabla^2 \mathbf{v}+\mathbf{f}_{ext}<br>
$$<br>
压强可以由密度表示，根据理想气体压强公式，我们得知压强与密度呈线性关系，于是我们取一个静止状态下的密度$\rho_0$，通过与当前状态密度做差值，就能得出压强</p>
<blockquote>
<p>理想气体压强公式，初中就学了，$pV=nRT$</p>
</blockquote>
<p>$$<br>
p=B((\frac{\rho}{\rho_0})^{\gamma}-1)<br>
$$</p>
<ul>
<li>$B$：体积模量（bulk modulus）</li>
</ul>
<h4 id="弹力">弹力</h4>
<p>拥有弹力的固体，应力张量来自于固体的形变，之后会展开讲</p>
<h2 id="积分求解">积分求解</h2>
<h3 id="混合初始边界值问题">混合初始边界值问题</h3>
<p>我们上面给出了控制方程，但是想要求解运动问题，必须给定初始位置和速度（场）</p>
<p>一般而言，混合初始边界值问题（Mixed Initial-Boundary Value Problem）没有解析解，只有数值解</p>
<blockquote>
<p>得嘞，这一节就这一句话，这一句话一个字都看不懂</p>
</blockquote>
<h4 id="混合边界">混合边界</h4>
<blockquote>
<p>简单来说，就是要想求解运动问题，必须既要给初始位置，也要给初始速度（场）</p>
</blockquote>
<p>边界条件也叫定解条件，是微分方程里的概念，给定初始值才能求控制方程、偏微分方程的解（比如带入解中的未知数）</p>
<p>放在物理学中叫临界条件，就是物体处于某两种状态间的交界处，比如冰水混合物</p>
<p>边界条件对于解决物理问题（比如求极值）十分重要</p>
<p>有三类边界条件</p>
<ul>
<li>第一类边界条件（迪利克雷边界条件，Dirichlet boundary condition）
<ul>
<li>直接告诉你边界值，比如热传递中告诉你边界处温度</li>
</ul>
</li>
<li>第二类边界（若依曼边界条件，Neumann boundary condition）
<ul>
<li>告诉你边界处的梯度，比如热传递中告诉你热流密度（温度的梯度）</li>
</ul>
</li>
<li>混合边界条件
<ul>
<li>第一二类边界的混合，比如热对流微分公式，公式中既有温度，也有梯度，只有同时给出两者，才能求解</li>
</ul>
</li>
</ul>
<p>$$<br>
q=h(T_0-T_a)<br>
$$</p>
<h4 id="解析解与数值解">解析解与数值解</h4>
<ul>
<li>解析解（analytic solution），形如一个函数，给定变量就能得出任意位置的解</li>
<li>数值解（numerical solution），这是一个数，是采用有限元、数值逼近、插值等方法得到的解</li>
</ul>
<blockquote>
<p>据说在数学家和物理学家眼里，解析解才是真正的解，更高贵，美丽</p>
<p>让我突然想到三体力魏成想要求出三体问题的解析解，结果最后发现这个问题只有数值解</p>
</blockquote>
<h3 id="算子分裂">算子分裂</h3>
<p>就是使用分治的算法，将一个复杂的偏微分方程（PDE），分解为几个连续的子问题</p>
<img src="/images/算子分解.png" alt="算子分解"  />
<p>在实践中证明，像这样每步操作依赖于上一步，一步一步操作，能提高系统的稳定性</p>
<h3 id="时间积分">时间积分</h3>
<p>在实时渲染中，和精度相比，性能、稳定性和鲁棒性更重要</p>
<p>在GAMES201开篇讲弹簧质点模型时，关于质点的运动方程，给出了两种积分器：显式积分器和隐式积分器</p>
<h4 id="显式积分器">显式积分器</h4>
<p>从过去的状态得到现在的状态，表示简单容易实现</p>
<p>$$<br>
\mathbf{v}_{t+1}=\mathbf{v}_t+\Delta t \frac{\mathbf{f}_t}{m}<br>
$$</p>
<!---->
<p>$$<br>
\mathbf{x}_{t+1}=\mathbf{x}<em>t+\Delta t \mathbf{v}</em>{t+1}<br>
$$</p>
<p>但是显式积分器有一个问题，就是容易爆炸，于是$\Delta t$不能太大，应满足<br>
$$<br>
\Delta t \le c\sqrt{\frac{m}{k}} \ \ (c \sim 1)<br>
$$</p>
<h5 id="CFL条件">CFL条件</h5>
<p>这是CFL条件（Courant–Friedrichs–Lewy condition），是某些偏微分方程的收敛条件，它决定了显式积分器中粒子在单位时间内走过的距离，必须小于粒子大小（或者说质点间的间距）<br>
$$<br>
\Delta t \le \lambda \frac{\tilde{h}}{|\mathbf{v}^{\max}|}<br>
$$</p>
<ul>
<li>$\tilde{h}$：粒子大小（质点间的间距）</li>
<li>$\lambda$：一个常量</li>
<li>$\mathbf{v}^{\max}$：粒子运动的最快速度</li>
</ul>
<h4 id="隐式积分器">隐式积分器</h4>
<p>现在的状态依赖于现在的状态（求$t+1$时刻的信息，结果需要$t+1$时刻的信息），难以实现，但鲁棒性强</p>
<!---->
<p>$$<br>
\mathbf{v}_{t+1}=\mathbf{v}<em>t+\Delta t \mathbf{M}^{-1}\mathbf{f}(\mathbf{x}</em>{t+1})<br>
$$</p>
<!---->
<p>$$<br>
\mathbf{x}_{t+1}=\mathbf{x}<em>t+\Delta t \mathbf{v}</em>{t+1}<br>
$$</p>
<ul>
<li>$\mathbf{M}$：质量矩阵</li>
</ul>
<h2 id="Marching-Cube">Marching Cube</h2>
<h2 id="符号表">符号表</h2>
<p><img src="/images/%E7%AC%A6%E5%8F%B7.png" alt="符号"></p>
<h2 id="参考">参考</h2>
<p><a target="_blank" rel="noopener" href="https://interactivecomputergraphics.github.io/physics-simulation/">Physics Simulation in Visual Computing</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZK411H7Hc">GAMES201</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/426566636">MrKill的知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/alen-cell/PhysicsEngine">alen-cell</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/02/graphics/SPH/" data-id="clepy40o4000dglnk8lv2ap4b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Physics/" rel="tag">Physics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SPH/" rel="tag">SPH</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-我是谁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/02/%E6%88%91%E6%98%AF%E8%B0%81/" class="article-date">
  <time datetime="2023-02-02T09:50:25.000Z" itemprop="datePublished">2023-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/02/%E6%88%91%E6%98%AF%E8%B0%81/">我是谁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>一个渴望得到认同的怪兽</h1>
<h3 id="过去">过去</h3>
<p>感觉我做啥都三分钟热度，换了好多次道路</p>
<p>我从小就喜欢游戏，在小学的时候就在班级“发售”了一款桌游，赚了5块钱，最后被班主任没收了😂</p>
<p>初高中时特别喜欢科幻和物理，当时想着去做<strong>可控核聚变</strong>，认为这才是有意义有价值的工作，那时候我的梦想就是做一名学者</p>
<p>在高三时期学校给我们开大会，在讲华为被制裁、卡脖子，然后我就被忽悠着去报考计算机</p>
<p>刚上大学时想做嵌入式和芯片，但在一次大作业中用嵌入式+触摸屏做了一款游戏，那是一个打地鼠和五子棋结合的游戏，没有游戏引擎，没有图形API，画面绘制是靠着在屏幕上绘制点阵，属实是有些拙劣</p>
<p>这次经历让我又想做游戏了，于是我开始做<strong>游戏策划</strong></p>
<p>最初的策划生涯还蛮顺利的，每天都在玩游戏做反拆，加了学校的游戏开发社团，做独立游戏，参加Gamejam。然后在腾讯策划公开课拿了金奖，又在字节朝夕光年Gamejam拿到了策划offer。但很快字节上海人事调整（裁员），我被毁了offer</p>
<p>只不过我当时才大二上学期，感觉挺无所谓的。不过在字节Gamejam中看到一个队伍做的平台跳跃，当跳跃时屏幕会有振动和RGB通道分离，我十分好奇这是什么原理，经社团学长介绍，这是shader</p>
<p>然后我开始搞图形了，自学shader三四个月，到了大二下学期我又拿到了字节朝夕光年的offer，只不过这次是TA，然后就在这边实习了十个月。只不过当我大三下学期快要秋招的时候，又遇到了人事调整，整个项目被砍了，mentor离职，于是没继续待</p>
<p>不过这次实习改变了我的技术栈，我现在在做引擎，只不过资质尚浅，能力不足</p>
<h3 id="现在">现在</h3>
<p>引擎实在是太复杂了，我的编程能力也不是很强，图形知识大多都停留在应用层面（比如如何用Unity做手游图形效果），算法基础也不是很牢固，看到身边的大佬，感觉好卑微</p>
<p>但是我又是一个渴望得认同的怪兽，不积跬步无以至千里，于是就有了这个博客，用于记录那些<strong>想让别人看，但又不敢发知乎贻笑大方的内容</strong></p>
<p>希望我能在引擎道路上坚持下去</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/02/%E6%88%91%E6%98%AF%E8%B0%81/" data-id="clepy40ns0001glnkfe9w2hnb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-program/C++11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/01/program/C++11/" class="article-date">
  <time datetime="2023-02-01T14:01:25.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/01/program/C++11/">C++11特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>C++11特性</h1>
<p>都什么年代了，还在整C++11？八股害人啊</p>
<h2 id="一：C-11的“新”特性">一：C++11的“新”特性</h2>
<h3 id="nullptr">nullptr</h3>
<p>一个新关键字，用于表示指针指向no value，可以被自动转化为各种指针类型，但是不会被转化为整数</p>
<p><em>比NULL好，因为NULL的本质就是整数0</em></p>
<h3 id="auto">auto</h3>
<p>通过auto声明变量、对象，可以自动推到其类型，在处理表达式时有奇效</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto l &#x3D; [](int x) -&gt; &#123;...&#125;;</code></pre>
<h3 id="一致性初始化">一致性初始化</h3>
<p>一致性初始化（Uniform Initiallization），简单来说就是可以用大括号来做初始化</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int v[] &#123;1, 2, 3&#125;;
vector&lt;int&gt; v2 &#123;1, 2, 3&#125;;
complex&lt;double&gt; c&#123;4.0, 3.0&#125;;</code></pre>
<p>但是这个操作不支持<strong>窄化（narrowing）</strong>，即</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 5.3;	&#x2F;&#x2F;x &#x3D;&#x3D; 5
int y &#123;5.3&#125;;	&#x2F;&#x2F;Error</code></pre>
<h3 id="新的for循环">新的for循环</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">for(auto&amp; item: lists)&#123;...&#125;

for(int i : &#123;1, 2, 3, 4&#125;)&#123;...&#125;</code></pre>
<h3 id="转移语意">转移语意</h3>
<p>转移语意（move semantic），用于避免非必要的拷贝和临时对象</p>
<p>比如一个函数定义为</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void fun(const T&amp; v)&#123;...&#125;</code></pre>
<p>当我们调用时</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">T t;
fun(t);		&#x2F;&#x2F;1
fun(t+1);	&#x2F;&#x2F;2</code></pre>
<p>我们发现，第一种调用时，直接传了引用，没有拷贝和临时变量，而第二种，实际上是</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">T temp &#x3D; t+1;		&#x2F;&#x2F;T temp(t+1)或者 T temp.T(t+1)
fun(temp);</code></pre>
<p>总之是调用了拷贝构造函数和生成了临时变量，这不是我们想要的，于是引入了左右值和转移语意的概念，然后就诞生了一种新的调用方式：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">fun(std::move(t+1));</code></pre>
<p><code>std::move</code>的作用是将其参数<code>t+1</code>变成一个<strong>右值（rvalue reference）</strong>，是一个<code>T&amp;&amp;</code>的类型</p>
<p>一旦一个类型被“标记”为右值，就意味着这是一个临时对象，你可以随意使用它的内容和资源</p>
<p>然后我们可以优化一下这个函数的定义</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class T&#123;
public:
  T (const T&amp; lvalue);	&#x2F;&#x2F;通过左值拷贝构造（根传统C++一样）
  T (T&amp;&amp; rvalue);		&#x2F;&#x2F;通过右值move构造
&#125;
void fun(T&amp;&amp; v)&#123;...&#125;</code></pre>
<p>右值被move以后，就变成有效但不确定的状态</p>
<h3 id="字符串字面量">字符串字面量</h3>
<h4 id="Raw-String-Literal">Raw String Literal</h4>
<p>以R开头的字符串，可以换行，不需要转义，用于正则表示式有奇效</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">R&quot;(\\n)&quot;;	&#x2F;&#x2F;等于 &quot;\\\\n&quot;</code></pre>
<h4 id="Encoded-String-Literal">Encoded String Literal</h4>
<p>用于国际化</p>
<h3 id="noexcept">noexcept</h3>
<p>让函数无法抛出异常，遇到未定义事件会直接<code>abort</code></p>
<p>noexcept后面可以跟一个bool条件，为true时就不抛异常</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void fun() noexcept;
void fun2(T&amp; x, T&amp; y) noexcept(noexcept(x.swap(y)))&#123;
    x.swap(y);
    &#x2F;&#x2F;这个函数意味着，只要xy交换不抛异常，那么下面这些函数体做任何事都不会抛异常
&#125;</code></pre>
<h3 id="constexpr">constexpr</h3>
<p>用于让表达式核定与编译期，能助力TMP编程</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">constexpr int square(int x)&#123;
    return x*x;
&#125;
float a[square(9)];</code></pre>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;以前的写法
template&lt;unsigned n&gt;
struct Factorial
&#123;
    enum &#123; value &#x3D; n * Factorial&lt;n-1&gt;::value &#125;;
&#125;;
&#x2F;&#x2F;C++11写法
template&lt;unsigned n&gt;
struct Factorial
&#123;
    constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;;
&#125;;</code></pre>
<h3 id="新的模板">新的模板</h3>
<h4 id="不定个数的参数">不定个数的参数</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">void f(int i)&#123;
    cout &lt;&lt; i &lt;&lt; endl;
&#125;
template &lt;typename T , typename... Types&gt;
void f(const T&amp; first, const Types&amp;... args)&#123;
    cout &lt;&lt; first &lt;&lt; endl;
    f(args...);
&#125;
int main() &#123;
    f(1, 2, 3);
    return 0;
&#125;</code></pre>
<h4 id="模板别名">模板别名</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
using Vec &#x3D; std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;
Vec&lt;int&gt; coll;	&#x2F;&#x2F;等价于std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll;</code></pre>
<h3 id="Lambda">Lambda</h3>
<p>允许函数的定义式被用作一个参数、local对象</p>
<h4 id="定义与调用">定义与调用</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">[]&#123;
    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;
&#125;;	&#x2F;&#x2F;这是一个lambda表达式

[]&#123;
    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;
&#125;();	&#x2F;&#x2F;定义并直接调用表达式

auto l &#x3D; []&#123;
    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;
&#125;;
l();	&#x2F;&#x2F;调用表达式</code></pre>
<h4 id="含参">含参</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto l2 &#x3D; [](const std::string&amp; s)&#123;
    cout &lt;&lt; s &lt;&lt; endl;
&#125;;
l(&quot;hello&quot;);</code></pre>
<h4 id="返回值">返回值</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">[]() -&gt; int &#123;
    return 42;	
&#125;</code></pre>
<h4 id="外部作用域">外部作用域</h4>
<p>分值传递和引用传递两种，值传递不能进行修改</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 0;
int y &#x3D; 42;
auto l &#x3D; [x, &amp;y] &#123;
    cout &lt;&lt; x &lt;&lt; &quot;+&quot; &lt;&lt; y &lt;&lt; endl;
    ++y;
&#125;
l();	&#x2F;&#x2F;调用，注意xy不是参数，不需要写在括号里</code></pre>
<h4 id="mutable">mutable</h4>
<p>这个关键词是const的反义词，意思是可变的，于是让值传递也可变</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 0;
auto l &#x3D; [x]() mutable &#123;
    cout &lt;&lt; x &lt;&lt; endl;
    x++;
&#125;
l();</code></pre>
<h3 id="decltype">decltype</h3>
<p>自动推导表达式的类型，大号typeof</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int &amp;i &#x3D; 1;
int a &#x3D; 2;
decltype(i) b &#x3D; 2; &#x2F;&#x2F; b是const int&amp;</code></pre>
<h4 id="推断返回类型">推断返回类型</h4>
<p>可以将返回类型的声明放在参数列之后</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename T1, typename T2&gt;
auto add(T1 x, T2 y) -&gt; decltype(x+y)&#123;
    return x + y;
&#125;</code></pre>
<h3 id="带领域的枚举">带领域的枚举</h3>
<h2 id="二：一般概念">二：一般概念</h2>
<h3 id="可被调用的对象">可被调用的对象</h3>
<p>Callable Object，一种对象，可以通过某些方式调用其某些函数，它可以是</p>
<ul>
<li>函数</li>
<li>指向成员函数的指针</li>
<li>函数对象</li>
<li>lambda表达式</li>
</ul>
<h2 id="三：通用工具">三：通用工具</h2>
<h3 id="pair">pair</h3>
<p>本质是一个struct</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int add(pair&lt;int, int&gt; p)&#123;
    return p.first + p.second;
&#125;

int main() &#123;
    pair&lt;int, int&gt; p(42, 10);
    cout &lt;&lt; add(p);
    return 0;
&#125;</code></pre>
<h3 id="tuple">tuple</h3>
<p>大号pair，可以有多个值</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int f(tuple&lt;int, int, int&gt; t)&#123;
    return get&lt;0&gt;(t) + get&lt;1&gt;(t) + get&lt;2&gt;(t);
&#125;
int main() &#123;
    tuple&lt;int, int, int&gt; t(3, 5, 7);
    cout &lt;&lt; f(t);
    return 0;
&#125;</code></pre>
<h3 id="智能指针">智能指针</h3>
<p>智能指针智能在，它能知道自己是不是指向某物的最后一个指针</p>
<ul>
<li>shared_ptr：共享式拥有
<ul>
<li>多个指针可以指向一个资源，通过引用计数法GC</li>
<li>为了解决引用计数法的缺点（比如循环引用），提供weak_ptr等辅助类</li>
</ul>
</li>
<li>unique_ptr：独占式拥有
<ul>
<li>同一时间只能有一个unique_ptr指向某个资源，可以进行拥有权的移交</li>
</ul>
</li>
</ul>
<h3 id="极值">极值</h3>
<p>Numeric Limit</p>
<p>用于得到当前平台下，一些数值类型的长度（大小）</p>
<h3 id="Trait">Trait</h3>
<p>是一种技术方案，用来为同一类数据提供统一的操作函数，核心就是使用另外的模版类<code>type_traits</code>存储不同数据类型的<code>type</code>，这样就可以兼容各种数据类型</p>
<h3 id="外覆器">外覆器</h3>
<h4 id="Reference-Wrapper">Reference Wrapper</h4>
<p>允许函数模板可以操作引用，不需要写特化版本</p>
<p>具体有两个函数</p>
<ul>
<li>ref：隐式转化为<code>T&amp;</code></li>
<li>cref：隐式转化为<code>const T &amp;</code></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
void fun(T v);

int x;
fun(std::ref(x));	&#x2F;&#x2F;此时T为int&amp;

int x;
fun(std::cref(x));	&#x2F;&#x2F;此时T为const int&amp;</code></pre>
<h4 id="Function-Type-Wrapper">Function Type Wrapper</h4>
<p>允许将可调用对象当作最高级对象（first-class object）</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">vector&lt;function&lt;void(int, int)&gt;&gt; tasks;	&#x2F;&#x2F;一个存储多个可调用对象的vector
tasks.push_back(func);	&#x2F;&#x2F;void func(int x, int y);
tasks.push_back([] (int x, int y) &#123;...&#125;);	&#x2F;&#x2F;添加一个lambda表达式

for(function&lt;void(int, int)&gt; f : tasks)&#123;
    f(36, 36);	&#x2F;&#x2F;遍历所有的可调用对象，并调用
&#125;</code></pre>
<h3 id="辅助函数">辅助函数</h3>
<ul>
<li>min</li>
<li>max</li>
<li>swap</li>
<li>operator
<ul>
<li><code>==</code></li>
<li><code>!=</code></li>
<li><code>&gt;</code></li>
<li><code>&lt;</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;=</code></li>
</ul>
</li>
</ul>
<h3 id="编译期分数运算">编译期分数运算</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">ratio&lt;5, 5&gt; one;
cout &lt;&lt; one.num &lt;&lt; &quot;&#x2F;&quot; &lt;&lt; one.den &lt;&lt; endl;	&#x2F;&#x2F; 1&#x2F;1

ratio&lt;5, 3&gt; two;
cout &lt;&lt; two.num &lt;&lt; &quot;&#x2F;&quot; &lt;&lt; two.den &lt;&lt; endl;	&#x2F;&#x2F; 5&#x2F;3</code></pre>
<h2 id="四：STL">四：STL</h2>
<p>STL是C++标准库的核心，是一个泛型（generic）程序库，由三部分组成</p>
<ul>
<li>容器（Container）</li>
<li>迭代器（Iterator）</li>
<li>算法（Algorithm）</li>
</ul>
<h3 id="容器">容器</h3>
<h4 id="有序容器">有序容器</h4>
<p>顺序与插入顺序有关，与元素值无关，常常通过array、linked list实现</p>
<ul>
<li>array</li>
<li>vector</li>
<li>deque</li>
<li>list</li>
<li>forward_list</li>
</ul>
<h4 id="关联式容器">关联式容器</h4>
<p>在内部进行排序的集合，位置取决于value，常常通过二叉树实现</p>
<ul>
<li>set</li>
<li>multiset（mult的意思是元素可以重复）</li>
<li>map</li>
<li>multimap（mult的意思是key可以重复）</li>
</ul>
<h4 id="无序容器">无序容器</h4>
<p>元素位置无关紧要，重要的是元素是否在容器内，常常通过哈希表实现</p>
<ul>
<li>unordered_set</li>
<li>unordered_multiset</li>
<li>unordered_map</li>
<li>unordered_multmap</li>
</ul>
<h4 id="其他容器">其他容器</h4>
<ul>
<li>string</li>
<li>寻常的数组（一种type，而非class）</li>
</ul>
<h3 id="迭代器">迭代器</h3>
<p>迭代器是一个可以遍历STL容器全部、部分元素的对象</p>
<h4 id="操作">操作</h4>
<ul>
<li><code>*</code>：取元素</li>
<li><code>++</code>：迭代器前进至下一个元素
<ul>
<li>注意，<code>++i</code>比<code>i++</code>效率高一点点，因为后者要创建临时对象</li>
</ul>
</li>
<li><code>==</code>、<code>!=</code>：判断两个迭代器是否指向同一个位置</li>
<li><code>=</code>：赋值</li>
</ul>
<h3 id="种类">种类</h3>
<table>
<thead>
<tr>
<th></th>
<th>R/W</th>
<th>读写次数</th>
<th>跳转</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出迭代器</td>
<td>只读/只写</td>
<td>能且仅能读写一次</td>
<td>i++</td>
<td>istream_iterators、ostream_iterators</td>
</tr>
<tr>
<td>前向/双向迭代器</td>
<td>读写</td>
<td>能读写多次</td>
<td>i++</td>
<td>STL的set、map</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写</td>
<td>能读写多次</td>
<td>i += n</td>
<td>vector、deque、string、array</td>
</tr>
</tbody>
</table>
<p>从上到下，迭代器能力越来越强（他们间有继承关系，前向 is a 输入）</p>
<h3 id="算法">算法</h3>
<p>大多为非成员函数，思想是泛型编程（而不是OOP）</p>
<h3 id="函数对象">函数对象</h3>
<p>一个行为像函数的对象，思想是泛型编程</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class X&#123;
public:
    int operator() (int a, int b) const;
&#125;;
...
X fo;
fo(arg1, arg2);	&#x2F;&#x2F;等同于fo.operator()(arg1, arg2);</code></pre>
<ul>
<li>函数对象是一个带状态的函数</li>
<li>函数对象有自己的类型</li>
<li>函数对象速度通常比普通函数快（编译期间有更好的优化）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/01/program/C++11/" data-id="clepy40oy002dglnk1ghee8td" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-graphics/profile工具" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/01/graphics/profile%E5%B7%A5%E5%85%B7/" class="article-date">
  <time datetime="2023-02-01T10:01:25.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/01/graphics/profile%E5%B7%A5%E5%85%B7/">profile工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Profile工具</h1>
<p>工具手册</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>优点</th>
<th>评价</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unity profiler</td>
<td>用起来最简单，可以网络远程测试</td>
<td>功能不是很全</td>
</tr>
<tr>
<td>Xcode</td>
<td>功能全，而且使用简单</td>
<td>只能iOS，而且iOS打包很折磨</td>
</tr>
<tr>
<td>RenderDoc</td>
<td></td>
<td>安卓利器</td>
</tr>
<tr>
<td>snapdragon</td>
<td></td>
<td>只能用于高通骁龙soc，使用时注意有无adb</td>
</tr>
<tr>
<td>Nsight</td>
<td></td>
<td>贼难用（可能是Unity图形API的锅）</td>
</tr>
<tr>
<td>PIX</td>
<td></td>
<td>调试DX12也就这个好使</td>
</tr>
</tbody>
</table>
<h3 id="Xcode">Xcode</h3>
<h4 id="配置Xcode项目">配置Xcode项目</h4>
<p>Xcode想要截帧需要依赖Xcode源项目</p>
<ul>
<li>
<p>签名配置（略，这玩意贼恶心，尤其是别人的项目）</p>
</li>
<li>
<p>配置截帧</p>
<ul>
<li>Edit Scheme</li>
</ul>
</li>
</ul>
<p><img src="/images/EditScheme.png" alt="Edit Scheme"></p>
<ul>
<li>CaptureMetal</li>
</ul>
<p><img src="/images/CaptureMetal.png" alt="CaptureMetal"></p>
<ul>
<li>API Validation</li>
</ul>
<p><img src="/images/APIValidation.png" alt="API Validation"></p>
<h4 id="截帧">截帧</h4>
<p><img src="/images/Metal%E6%88%AA%E5%B8%A7.png" alt="Metal截帧"></p>
<h4 id="截帧信息分析">截帧信息分析</h4>
<ul>
<li>GPU时间（首页就有）</li>
<li>带宽</li>
</ul>
<p><img src="/images/Xcode%E5%B8%A6%E5%AE%BD.png" alt="Xcode带宽"></p>
<h4 id="截帧分享">截帧分享</h4>
<p>找到这个文件，分享给其他人</p>
<p><img src="/images/Xcode%E6%88%AA%E5%B8%A7%E5%88%86%E4%BA%AB.png" alt="Xcode截帧分享"></p>
<h3 id="Nsight">Nsight</h3>
<h4 id="连接Unity-Editor">连接Unity Editor</h4>
<ul>
<li>
<p>以管理员身份打开</p>
</li>
<li>
<p>配置</p>
<ul>
<li>
<p>Application Executable：Unity.exe所在的绝对路径</p>
</li>
<li>
<p>Command Line Arguements：-projectPath ”项目根路径“</p>
<ul>
<li>项目根路径：文件夹内有Asset、Package的那个文件夹</li>
</ul>
</li>
</ul>
</li>
<li>
<p>启动</p>
<ul>
<li>点击Launch Frame Debugger</li>
<li>注意，请将Unity和Unity Hub都关掉</li>
</ul>
</li>
</ul>
<p><img src="/images/NSight_Unity.png" alt="NSight_Unity"></p>
<h4 id="注意">注意</h4>
<p>Unity HDRP使用了<code>D3D11On12</code>，在使用NSight时会报Warm，暂时先别管</p>
<h3 id="Snapdragon">Snapdragon</h3>
<h4 id="连接安卓APP">连接安卓APP</h4>
<ul>
<li>Connect to a device
<ul>
<li>如果找不到设备，检查有无adb命令，或者直接用adb连接</li>
</ul>
</li>
<li>Realtime看带宽
<ul>
<li>从左下角Process中挑</li>
</ul>
</li>
<li>Trace Capture看GPU时间</li>
</ul>
<h3 id="RenderDoc">RenderDoc</h3>
<h4 id="连接安卓APP-2">连接安卓APP</h4>
<ul>
<li>手机连接电脑，电脑打开RenderDoc</li>
<li>Connect</li>
<li>打开Launch Application窗口
<ul>
<li>Program——Executable Path——选择要截帧的APP</li>
</ul>
</li>
</ul>
<p><img src="/images/RenderDoc%E5%AE%89%E5%8D%93.jpg" alt="RenderDoc安卓"></p>
<h4 id="连接Unity-Editor-2">连接Unity Editor</h4>
<ul>
<li>右键Scene，Load RenderDoc</li>
<li>按小相机截帧</li>
</ul>
<h3 id="PIX">PIX</h3>
<h4 id="权限配置">权限配置</h4>
<ul>
<li>开启Window开发者模式</li>
</ul>
<img src="/images/开发者模式.png" alt="开发者模式" style="zoom: 80%;" />
<ul>
<li>开启英伟达开发者模式（以管理员身法打开英伟达控制面板）
<ul>
<li>注意，更换模式时，请注意关闭、保存Unity（和显卡相关的软件会崩掉）</li>
</ul>
</li>
</ul>
<p><img src="/images/%E8%8B%B1%E4%BC%9F%E8%BE%BE%E8%AE%BE%E7%BD%AE.png" alt="英伟达设置"></p>
<h4 id="连接Unity-Editor-3">连接Unity Editor</h4>
<ul>
<li>
<p>以管理员身份打开PIX</p>
</li>
<li>
<p>Attach Unity Editor（配置方式同NSight）</p>
</li>
</ul>
<p><img src="/images/PIX.jpg" alt="PIX"></p>
<ul>
<li>按GPU Capture截帧</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/01/graphics/profile%E5%B7%A5%E5%85%B7/" data-id="clepy40oe000uglnk2x2nbhbs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TA/" rel="tag">TA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-graphics/骨骼动画" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/01/graphics/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/" class="article-date">
  <time datetime="2023-02-01T10:01:25.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/graphics/">graphics</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/01/graphics/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/">骨骼动画</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>骨骼动画</h1>
<ul>
<li>序列帧动画：记录动作的每一帧
<ul>
<li>非矢量动画：每一帧是固定不可复用的，新的一帧本质上是完全重画一次物体，没有发生形态上的改变</li>
</ul>
</li>
<li>关键帧动画：记录动作的始末和轨迹曲线，运行时根据曲线进行插值（很显然，这是一种矢量动画）
<ul>
<li>每个关键帧被称为姿势</li>
</ul>
</li>
</ul>
<h2 id="顶点动画">顶点动画</h2>
<p>骨骼动画的本质是顶点动画</p>
<ul>
<li>刚体动画：在渲染中网格不发生改变，刚体的变化矩阵发生改变</li>
<li>顶点动画：在渲染中网格顶点发生了直接的变化（位移旋转缩放）
<ul>
<li>骨骼动画：一种对顶点动画的压缩算法</li>
<li>流体动画</li>
<li>粒子动画</li>
<li>变形动画：常用于制作表情，捏脸</li>
</ul>
</li>
</ul>
<p>根据顶点动画的实现方式，分为CPU和GPU</p>
<table>
<thead>
<tr>
<th></th>
<th>CPU动画</th>
<th>GPU动画</th>
</tr>
</thead>
<tbody>
<tr>
<td>顶点位置改变时机</td>
<td>CPU应用阶段</td>
<td>GPU几何阶段</td>
</tr>
<tr>
<td>数据流</td>
<td>CPU传递给GPU的顶点数组发生改变</td>
<td>顶点着色器输出发生改变</td>
</tr>
</tbody>
</table>
<h3 id="骨骼动画">骨骼动画</h3>
<p>骨骼动画的模型整体不是刚体，同时为了避免旋转、移动时发生断裂，也不能将物体拆分为多个小刚体，因此只能选择顶点动画。</p>
<p>然而顶点动画带来的顶点移动，如果全部交由vertex着色器处理，过于昂贵，实时渲染不可接受</p>
<p>而且骨骼动画的顶点受更高层次的骨骼节点控制</p>
<ul>
<li>同一根骨骼的顶点要保持相对位置不变</li>
<li>骨骼间顶点要进行平滑</li>
<li>顶点的大体形状受骨骼形状制约，顶点变化时要保持和骨骼的联系</li>
</ul>
<h4 id="实现">实现</h4>
<p>矩阵调色板蒙皮技术（Matrix Palette Skinning）：</p>
<ul>
<li>骨骼为近似刚体，其变化矩阵按顺序存储在数组中（我们称这个数组为骨骼）</li>
<li>顶点缓冲中会存储其骨骼ID和权重信息（一个顶点通常会受1～4个骨骼影响，可以用两个Vector存储）</li>
<li>进行变化时，顶点可以根据骨骼ID和权重查询变化矩阵，并通过插值的方式实现顶点动画（我们称查询矩阵为蒙皮）</li>
<li>CPU通过姿势间插值，以获得每一帧骨骼的位置及矩阵，GPU根据顶点信息查询矩阵进而实现运动</li>
</ul>
<h2 id="坐标系">坐标系</h2>
<p><img src="/images/%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="img"></p>
<h3 id="骨骼树">骨骼树</h3>
<p>三维骨骼本质上是一系列Bone组成的树状结构</p>
<p>在骨骼动画中，我们更关心骨骼的相对位置，于是我们选择本地坐标系（A物体的本地坐标就是以A物体中心为原点，相对于中心的偏移），并让坐标系层次嵌套</p>
<blockquote>
<p>比如大臂移动时也会带动小臂移动，我们就把小臂的本地坐标系定义在大臂的本地坐标系之下，我们称大臂是小臂的父物体，小臂是大臂的子物体。而小臂在大臂的本地坐标系的坐标被称为局部坐标系（可以参考Unity的GO组织）</p>
</blockquote>
<p>顺着嵌套关系向根部搜索，就可以获得物体的世界坐标系</p>
<p>下图为树节点的数据结构</p>
<p><img src="/images/%E7%A9%BA%E9%97%B4%E6%A0%91%E8%8A%82%E7%82%B9.png" alt="img"></p>
<ul>
<li>本地坐标系就是object space transform</li>
</ul>
<p>在播放动画时，会从空间树的根节点（一般为盆骨节点或者root节点）开始向下递归变化，以保证父物体的local transform总是先于子物体刷新</p>
<pre class="language-C#" data-language="C#"><code class="language-C#"> &#x2F;&#x2F;对关键帧进行插值 
public OnAnimated(CoordinateTreeNode Key0, CoordinateTreeNode Key1, float t)
&#123; 
    Position &#x3D; Vector3.Lerp(Key0.Position, Key1.Position, t); 
    Rotation &#x3D; Quaternion.Lerp(Key0.Rotation, Key2.Rotation, t); 
    Scale &#x3D; Vector3.Lerp(Key0.Scale, Key1.Scale, t); 
    
    localTransform &#x3D; new TransformMatrix(Position, Rotation, Scale); 
    combinedTransform &#x3D; parent.localTransform * this.localTransform; 
&#125; </code></pre>
<h3 id="骨骼">骨骼</h3>
<ul>
<li>盆骨：选盆骨作为根节点（或者是空根节点的第一也是唯一的子节点），是因为盆骨在运动时相对匀速，且位置居中，可以避免骨骼树过深</li>
<li>脊椎骨：模拟躯干运动，一般有2～3块</li>
<li>捻度骨骼：Twist Bone，生物学中像小臂这类骨骼不是一块骨骼，而是两条并排的骨骼，以此实现肘关节不动而手掌可以旋转</li>
</ul>
<p><img src="/images/%E4%BA%BA%E4%BD%93%E9%AA%A8%E9%AA%BC.png" alt="img"></p>
<h3 id="坐标变化">坐标变化</h3>
<ul>
<li>位移矩阵</li>
<li>缩放矩阵</li>
<li>旋转矩阵</li>
<li>齐次坐标</li>
<li>仿射变换：缩放–旋转–平移</li>
<li>列矩阵左乘</li>
<li>手性变换：只需要对所有的矩阵任选一维进行取反即可（哪个维度不重要，只要统一即可）</li>
</ul>
<h2 id="旋转">旋转</h2>
<p>骨骼动画是矢量动画，是关键帧动画，因此会用到大量的插值，这决定了旋转的表达<strong>必须便于插值</strong></p>
<p>三维空间中的点可以由三个正交向量插值表示，根据嵌套关系，一个物体发生旋转，其实就是其基向量相对于父节点基向量发生改变</p>
<h3 id="双向量法">双向量法</h3>
<p>既然旋转可以由基向量的朝向表示，那么我们就直接基向量表示旋转吧！</p>
<p>正好三个基向量正交，而且对长度不敏感，那么我们还可以将三个向量压缩为两个向量</p>
<p>更进一步，这些向量都在球面上，那么用球坐标系替代直角坐标系</p>
<p>问题：</p>
<ul>
<li>需要时刻保证两个向量垂直</li>
<li>不好插值</li>
</ul>
<h3 id="欧拉角">欧拉角</h3>
<p>在航空业应用广泛，本质是一种过程量，描述了从初始位置沿着xyz轴旋转指定角度的过程，使用时需要明确旋转顺序（即顺规）</p>
<table>
<thead>
<tr>
<th></th>
<th>直角坐标系</th>
<th>欧拉角</th>
</tr>
</thead>
<tbody>
<tr>
<td>前进方向</td>
<td>Z</td>
<td>Roll 桶滚角</td>
</tr>
<tr>
<td>上方向</td>
<td>Y</td>
<td>Yaw 偏航角</td>
</tr>
<tr>
<td>右方向</td>
<td>X</td>
<td>Pitch 俯仰角</td>
</tr>
</tbody>
</table>
<p>问题：</p>
<ul>
<li>没有统一标准，而欧拉角强依赖于顺规</li>
<li>某些情况下会有两个轴平行，以至于失去一个自由度，导致万向节死锁</li>
<li>不能线性插值</li>
</ul>
<h3 id="轴角与四元数">轴角与四元数</h3>
<p>轴角（x, y, z, w）指沿着轴（x, y, z）旋转w度，也可以压缩为三维向量（wx’, wy’, wz’），轴角可以通过对轴向量和旋转角度分别插值对方法进行插值</p>
<p>四元数是一种超复数，可以用来表示旋转</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1SW411y7W1">四元数的可视化_哔哩哔哩_bilibili</a></p>
<h2 id="蒙皮解算">蒙皮解算</h2>
<p>Mesh中的顶点缓存中会存储骨架、骨骼索引，骨骼权重，将用于蒙皮解算</p>
<p><img src="/images/Mesh.png" alt="Mesh"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/01/graphics/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/" data-id="clepy40og000yglnk73j26au0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TA/" rel="tag">TA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-math/Pro-TBB" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/01/math/Pro-TBB/" class="article-date">
  <time datetime="2023-02-01T10:01:25.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/01/math/Pro-TBB/">Pro-TBB</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Pro TBB</h1>
<p>在摩尔定律逐渐失效的今日，CPU主频和单核性能提升越来越不明显，为了得到跟高的性能，我们走向了并行计算的道路</p>
<h2 id="概念">概念</h2>
<h3 id="并发和并行">并发和并行</h3>
<ul>
<li>
<p>并发（Concurrent）：happening during the same time span，处理器在两件事间快速切换，宏观上看，就像是同时发生的（下图AB）</p>
</li>
<li>
<p>并行（Parallel）：happening at the same time，多个处理器一起做事（下图CD）</p>
</li>
</ul>
<p><img src="Image/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C.png" alt="并发和并行"></p>
<h2 id="TBB基础">TBB基础</h2>
<p>TBB（Threading Building Blocks）是一个非常流行的C++并行编程（parallel programming）方案</p>
<ul>
<li>
<p>使用Task而非Thread</p>
<ul>
<li>Thread与硬件相关，直接编写难以跨平台，而且线程间通信过于频繁，过于繁琐</li>
<li>TBB使用Task编程，运行时会将程序映射到硬件上（该方法对嵌套并行的支持很不错）</li>
<li>TBB任务调度使用<strong>工作窃取</strong>，当一个任务队列执行完毕后，核心会去其他任务队列中窃取任务，于是可以提高核心的利用率</li>
</ul>
</li>
<li>
<p>TBB实现了可组合性（Composability）</p>
<ul>
<li>简单来说就是支持for循环</li>
</ul>
</li>
<li>
<p>方便移植（portable）</p>
</li>
</ul>
<h3 id="Mac上安装使用TBB">Mac上安装使用TBB</h3>
<ol>
<li>安装tbb</li>
</ol>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$brew</span> <span class="token function">install</span> tbb</code></pre>
<ol start="2">
<li>链接tbb</li>
</ol>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#寻找tbb包</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>TBB REQUIRED<span class="token punctuation">)</span>
...
<span class="token comment">#链接</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>TimeStudy <span class="token inserted class-name">TBB::tbb</span><span class="token punctuation">)</span></code></pre>
<ol start="3">
<li>引用头文件</li>
</ol>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;tbb&#x2F;tbb.h&gt;</code></pre>
<h3 id="在Ubuntu上安装TBB">在Ubuntu上安装TBB</h3>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libtbb-dev</code></pre>
<h3 id="调用函数">调用函数</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Func0, [...,] typename FuncN&gt;
void parallel_invoke(const Func0&amp; f0, [...,] const FuncN&amp; fN);</code></pre>
<p>一个简单的TBB示例，并行输出两行字符串</p>
<p>通过<code>tbb::parallel_invoke</code>实现任务、函数粒度的并行</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;tbb&#x2F;tbb.h&gt;

int main() &#123;
    tbb::parallel_invoke(
            []()&#123;std::cout &lt;&lt; &quot;TBB!&quot; &lt;&lt; std::endl;&#125;,
            []()&#123;std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;&#125;
            );
    return 0;
&#125;</code></pre>
<p>我们这里使用lambda表达式创建了匿名（anonymous）函数，可以大幅简化TBB编写</p>
<h4 id="快排示例">快排示例</h4>
<p>传统快排算法（升序）</p>
<ol>
<li>在数列中取一个数作为基准数</li>
<li>比基准小的放在基准左边，大的放在右边</li>
<li>对左右两边分别快排，直到只剩一个数（左右重合）</li>
</ol>
<p>能看出，这个算法采用了分治的思想，很适合并行</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;tbb&#x2F;tbb.h&gt;

using QV &#x3D; std::vector&lt;int&gt;;
&#x2F;&#x2F;传统快排
void quickSort(QV::iterator left, QV::iterator right)&#123;
    if(left &gt;&#x3D; right)&#123; return; &#125;
    int pivot_value &#x3D; *left;
    QV::iterator i &#x3D; left, j &#x3D; right - 1;
    while(i !&#x3D; j)&#123;
        while(i !&#x3D; j &amp;&amp; pivot_value &lt; *j) --j;    &#x2F;&#x2F;从右向左找，直到找到一个比基准小的
        while(i !&#x3D; j &amp;&amp; pivot_value &gt;&#x3D; *i) ++i;   &#x2F;&#x2F;从左往右找，直到找到一个比基准大的
        std::iter_swap(i, j);
    &#125;
    std::iter_swap(left, i);
    quickSort(left, i);
    quickSort(j+1, right);
&#125;
&#x2F;&#x2F;并行快排
void parallelQuicksort(QV::iterator left, QV::iterator right)&#123;
    if(left &gt;&#x3D; right)&#123; return; &#125;
    int pivot_value &#x3D;  *left;
    QV::iterator i &#x3D; left, j &#x3D; right - 1;
    while (i !&#x3D; j) &#123;
        while (i !&#x3D; j &amp;&amp; pivot_value &lt; *j) --j;
        while (i !&#x3D; j &amp;&amp; pivot_value &gt;&#x3D; *i) ++i;
        std::iter_swap(i, j);
    &#125;
    std::iter_swap(left, i);

    &#x2F;&#x2F; recursive call
    tbb::parallel_invoke(
      			&#x2F;&#x2F;lambda表达式[&#x3D;]表示传入当前函数所有的成员
            [&#x3D;]() &#123; parallelQuicksort(left, i); &#125;,
            [&#x3D;]() &#123; parallelQuicksort(i + 1, right); &#125;
    );

&#125;
&#x2F;&#x2F;使用cutoff
void parallelCutoffQuicksort(QV::iterator left, QV::iterator right)&#123;
    const int cutoff &#x3D; 100;

    if (right - left &lt; cutoff) &#123;
        quickSort(right, left);
    &#125;
    else &#123;
        int pivot_value &#x3D;  *left;
        QV::iterator i &#x3D; left, j &#x3D; right - 1;
        while (i !&#x3D; j) &#123;
            while (i !&#x3D; j &amp;&amp; pivot_value &lt; *j) --j;
            while (i !&#x3D; j &amp;&amp; pivot_value &gt;&#x3D; *i) ++i;
            std::iter_swap(i, j);
        &#125;
        std::iter_swap(left, i);

        &#x2F;&#x2F; recursive call
        tbb::parallel_invoke(
                [&#x3D;]() &#123; parallelQuicksort(left, i); &#125;,
                [&#x3D;]() &#123; parallelQuicksort(i + 1, right); &#125;
        );
    &#125;
&#125;

int main() &#123;
    std::vector&lt;int&gt; nums;
    for(int i &#x3D; 0; i &lt; 5000; ++i)&#123;
        nums.push_back(rand() % 5000);
    &#125;
  	&#x2F;&#x2F;warmup
    tbb::parallel_for(0, 10, [](int) &#123;
        tbb::tick_count t0 &#x3D; tbb::tick_count::now();
        while ((tbb::tick_count::now() - t0).seconds() &lt; 0.01);
    &#125;);

    std::vector&lt;int&gt; nums2 &#x3D; nums;
    tbb::tick_count t0 &#x3D; tbb::tick_count::now();
    quickSort(nums.begin(), nums.end());
    std::cout &lt;&lt; &quot;Normal Time&#x3D;&quot; &lt;&lt; (tbb::tick_count::now() - t0).seconds() &lt;&lt; std::endl;

    tbb::tick_count t1 &#x3D; tbb::tick_count::now();
    parallelQuicksort(nums2.begin(), nums2.end());
    std::cout &lt;&lt; &quot;Parallel Time&#x3D;&quot; &lt;&lt; (tbb::tick_count::now() - t1).seconds() &lt;&lt; std::endl;
    return 0;
&#125;</code></pre>
<p>最后结果，当数组比较大的时候，并行快排速度会更快一点</p>
<pre class="language-none"><code class="language-none">Normal Time&#x3D;0.0023285
Parallel Time&#x3D;0.00110846</code></pre>
<p>此外tbb进行任务分配也会有开销，因此我们往往将大任务分成若干个小任务后，让小任务串型执行，上文中的cutoff就是起到这个作用，这样往往能得到更高的性能</p>
<h3 id="时刻查询">时刻查询</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;t0时刻
tbb::tick_count t0 &#x3D; tbb::tick_count::now();	
...
&#x2F;&#x2F;当前时刻-t0时刻&#x3D;经过了多长时间段（并转化为秒）
std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; (tbb::tick_count::now() - t0).seconds() &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;</code></pre>
<p>并行开发中动态内存管理十分复杂、危险（内存泄漏），这里推荐使用C++11的智能指针（自带GC）</p>
<h3 id="Flow-Graph">Flow Graph</h3>
<p>将函数执行制作成Graph，实现消息驱动的并行（有些类似FrameGraph）</p>
<p><img src="Image/FlowGraph.jpeg" alt="FlowGraph"></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void fig1_10(const std::vector&lt;ImagePtr&gt;&amp; image_vector)&#123;
    const double tint_array[] &#x3D; &#123;0.75, 0, 0&#125;;

    tbb::flow::graph g;
    int i &#x3D; 0;
    &#x2F;&#x2F;注意，source_node已经失效
    tbb::flow::input_node&lt;ImagePtr&gt; src(g,
        [&amp;i, &amp;image_vector](tbb::flow_control &amp;fc) -&gt; ImagePtr &#123;
            if(i &lt; image_vector.size())&#123;
                return image_vector[i++];
            &#125;
            else&#123;
                fc.stop();
                return &#123;&#125;;
            &#125;
    &#125;);
    tbb::flow::function_node&lt;ImagePtr, ImagePtr&gt; gamma(g,
        tbb::flow::unlimited, [] (ImagePtr img) -&gt; ImagePtr&#123;
                return applyGamma(img, 1.4);
        &#125;
    );
    tbb::flow::function_node&lt;ImagePtr, ImagePtr&gt; tint(g,
        tbb::flow::unlimited, [tint_array] (ImagePtr img) -&gt; ImagePtr&#123;
                return applyTint(img, tint_array);
        &#125;
    );
    tbb::flow::function_node&lt;ImagePtr&gt; write(g,
         tbb::flow::unlimited, [] (ImagePtr img)&#123;
                writeImage(img);
        &#125;
    );

    tbb::flow::make_edge(src, gamma);
    tbb::flow::make_edge(gamma, tint);
    tbb::flow::make_edge(tint, write);
    src.activate();
    g.wait_for_all();
&#125;</code></pre>
<p>最后该程序会以<strong>流水线</strong>的形式执行，当第一张图片完成gamma矫正，去执行tint着色时，第二张图片开始执行gamma矫正（每张图片间互不影响）</p>
<p>相比于TimeStudy的串型执行，流水线执行效率会更快</p>
<h3 id="循环">循环</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Index, typename Func&gt;
Func parallel_for(Index frist, Index last, [Index step,] const Func&amp; f);</code></pre>
<p>上面的代码，我们将图片处理切分为几个小块，但小块内部仍然是单线程</p>
<p>我们注意到，在图片处理时，有一个很大的循环在遍历图片上的像素点，那么能不能并行做这件事？</p>
<p>我们并行处理每一行</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">tbb::parallel_for(0, height,
                  [&amp;in_rows, &amp;out_rows, width, gamma](int i)&#123;
                    for(int j &#x3D; 0; j &lt; width; ++j)&#123;
                      const ImageLib::Image::Pixel&amp; p &#x3D; in_rows[i][j];
                      double v &#x3D; 0.3 * p.bgra[2] + 0.59 * p.bgra[1] + 0.11 * p.bgra[0];
                      double res &#x3D; pow(v, gamma);
                      if(res &gt; ImageLib::MAX_BGR_VALUE)&#123;
                        res &#x3D; ImageLib::MAX_BGR_VALUE;
                      &#125;
                      out_rows[i][j] &#x3D; ImageLib::Image::Pixel(res, res, res);
                    &#125;
                  &#125;
                 );</code></pre>
<pre class="language-c++" data-language="c++"><code class="language-c++">tbb::parallel_for(0, height,
                  [&amp;in_rows, &amp;out_rows, width, tints](int i)&#123;
                    for(int j &#x3D; 0; j &lt; width; ++j)&#123;
                      const ImageLib::Image::Pixel&amp; p &#x3D; in_rows[i][j];
                      std::uint8_t b &#x3D; (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[0]) * tints[0];
                      std::uint8_t g &#x3D; (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[1]) * tints[1];
                      std::uint8_t r &#x3D; (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[2]) * tints[2];
                      out_rows[i][j] &#x3D; ImageLib::Image::Pixel(
                        (b &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : b,
                        (g &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : g,
                        (r &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : r
                      );
                    &#125;
                  &#125;
                 );</code></pre>
<p>M1 Mac Xcode Clang至今不支持C++17的std::execution，对OpenMP的支持也相当差</p>
<h3 id="归约">归约</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Range, typename Value, typename Func, typename Reduction&gt;
Value parallel_reduce(const Range&amp; range, const Value&amp; identity, const Func&amp; func, const Reduction&amp; reduction);</code></pre>
<p>树形规约</p>
<img src="Image/树形归并.png" alt="树形归并" style="zoom:50%;" />
<p><img src="Image/reduce.png" alt="reduce"></p>
<h4 id="求最大值">求最大值</h4>
<p>下面是一个vector求最大值的示例，实现机制就是将整个数组分成一个个小块（chunks），分别对小块求最值，然后将小块归约（reduce），最后求得最值（形成了一个树型结构）</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int pmax(const std::vector&lt;int&gt; &amp;arr)&#123;
    int max_value &#x3D; tbb::parallel_reduce(
      			&#x2F;&#x2F;range，扫描范围
            tbb::blocked_range&lt;int&gt;(0, arr.size()),	
      			&#x2F;&#x2F;identity，小块数据的初始值，这里赋值为int类型的最小值-2147483648
            std::numeric_limits&lt;int&gt;::min(),	
      			&#x2F;&#x2F;func，每个小块的处理方式
            [&amp;](const tbb::blocked_range&lt;int&gt; &amp;r, int init) -&gt; int&#123;	
                for(int i &#x3D; r.begin(); i !&#x3D; r.end(); ++i)&#123;
                    init &#x3D; std::max(init, arr[i]);
                &#125;
                return init;
            &#125;,
      			&#x2F;&#x2F;reduction，小块间合并的处理方式
            [](int x, int y) -&gt; int&#123;
                return std::max(x, y);
            &#125;
    );
    return max_value;
&#125;</code></pre>
<p>下面这是一个求PI的示例</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">double calcPI(int degree)&#123;
    double dx &#x3D; 1.0 &#x2F; degree;
    double sum &#x3D; tbb::parallel_reduce(
      			&#x2F;&#x2F;range，扫描范围
            tbb::blocked_range&lt;int&gt;(0, degree),
      			&#x2F;&#x2F;identity，小块数据的初始值，这里赋值为0
            0.0,
      			&#x2F;&#x2F;func，每个小块的处理方式
            [&#x3D;](const tbb::blocked_range&lt;int&gt; &amp;r, double init) -&gt; double&#123;
                for(int i &#x3D; r.begin(); i !&#x3D; r.end(); ++i)&#123;
                    double x &#x3D; (i + 0.5)*dx;
                    double h &#x3D; std::sqrt(1 - x*x);  &#x2F;&#x2F;勾股定理
                    init +&#x3D; h * dx;
                &#125;
                return init;
            &#125;,
      			&#x2F;&#x2F;reduction，小块间合并的处理方式
            [](double x, double y) -&gt; double&#123;
                return x+y;
            &#125;
        );
    return 4 * sum;
&#125;</code></pre>
<h3 id="扫描">扫描</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Range, typename Value, typename Scan, typename Combine&gt;
Value parallel_scan(const Range&amp; range, const Value&amp; identity, const Scan&amp; scan, const Combine&amp; combine);</code></pre>
<h4 id="前缀和">前缀和</h4>
<p><em>前缀和在图形领域也有很大的用处</em></p>
<p>对于一个数组，我们将其分为三个小块ABC</p>
<pre class="language-none"><code class="language-none">A.init&#x3D;0, B.init&#x3D;0
scan(A), scan(B)

B.init &#x3D; A.ans
C.init &#x3D; A.ans + B.ans
scan(B), scan(C)</code></pre>
<p>最后我们只用了串行2/3的扫描时间，但是多做了1/3的扫描工作，时间减少了，但是工作量变大了</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int parallelPrefix(const std::vector&lt;int&gt; &amp;v, std::vector&lt;int&gt; &amp;psum)&#123;
    int N &#x3D; v.size();
    psum[0] &#x3D; v[0];
    int final_sum &#x3D; tbb::parallel_scan(
      			&#x2F;&#x2F;range
            tbb::blocked_range&lt;int&gt;(1, N),
      			&#x2F;&#x2F;identity
            (int)0,
      			&#x2F;&#x2F;scan body
            [&amp;v, &amp;psum](const tbb::blocked_range&lt;int&gt; &amp;r, int sum, bool is_final_scan) -&gt; int&#123;
                for(int i &#x3D; r.begin(); i &lt; r.end(); ++i)&#123;
                    sum +&#x3D; v[i];
                    if(is_final_scan)&#123;
                        psum[i] &#x3D; sum;
                    &#125;
                &#125;
                return sum;
            &#125;,
      			&#x2F;&#x2F;combine body
            [](int x, int y)&#123;
                return x+y;
            &#125;
        );
    return final_sum;
&#125;</code></pre>
<h4 id="可见性">可见性</h4>
<p>如图，等间距摆放一个个薄板（厚度忽略不计），从最右上角向左看，能看到哪些薄板？</p>
<img src="Image/sight.png" alt="sight" style="zoom:50%;" />
<p>解题的本质就是比较夹角大小，只要夹角一直递增，就能看到</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void visibility(const std::vector&lt;double&gt; &amp;heights, std::vector&lt;bool&gt; &amp; visible, double dx)&#123;
    const int N &#x3D; heights.size();
    double max_angle &#x3D; std::atan2(dx, heights[0] - heights[1]);

    double final_max_angle &#x3D; tbb::parallel_scan(
      			&#x2F;&#x2F;range
            tbb::blocked_range&lt;int&gt;(1, N),
      			&#x2F;&#x2F;identity
            0.0,
      			&#x2F;&#x2F;scan body
            [&amp;heights, &amp;visible, dx](const tbb::blocked_range&lt;int&gt; &amp;r, double max_angle, bool is_final_scan) -&gt; double &#123;
                for(int i &#x3D; r.begin(); i !&#x3D; r.end(); ++i)&#123;
                    double my_angle &#x3D; atan2(i * dx, heights[0] - heights[i]);
                    if(my_angle &gt;&#x3D; max_angle)&#123;
                        max_angle &#x3D; my_angle;
                    &#125;
                    else if(is_final_scan)&#123;
                        visible[i] &#x3D; false;
                    &#125;
                &#125;
                return max_angle;
            &#125;,
      			&#x2F;&#x2F;combine body
            [](double a, double b)&#123;
                return std::max(a, b);
            &#125;
        );
&#125;</code></pre>
<h3 id="parallel-for-each">parallel_for_each</h3>
<p>parallel_for在使用时必须指定range，但如果要处理的item数量不确定（比如在执行过程中修改itemList），那么就不能使用，这个时候我们可以使用parallel_for_each</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typaname InputIterator, typename Body&gt;
void parallel_for_each( InputIterator first, InputIterator last, Body body );</code></pre>
<p>下面是一个遍历树的示例，若一个节点的<code>v.first</code>为prime，将其<code>v.second</code>修改为true。我们不知道树有多大，于是采用递归遍历</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void f(PrimesTreeElement::Ptr root)&#123;
  PrimesTreeElement::Ptr tree_arry[] &#x3D; &#123;root&#125;;
  &#x2F;&#x2F;tbb::parallel_do已经废弃
  tbb::parallel_for_each(
        tree_array,
        [](PrimesTreeElement::Ptr e, 
        &#x2F;&#x2F;tbb::parallel_do_feeder已被废弃
        tbb::feeder&lt;PrimesTreeElement::Ptr&gt;&amp; feeder)&#123;
        if(e)&#123;
          if(isPrime(e-&gt;v.first)) e-&gt;v.second &#x3D; true;
          if(e-&gt;left) feeder.add(e-&gt;left);
          if(e-&gt;right) feeder.add(e-&gt;right);
        &#125;
      &#125;                 
  );
&#125;</code></pre>
<h4 id="前向替换">前向替换</h4>
<p>前向替换（Forward Substitution）是线性代数中一种求解线性方程组的方法</p>
<p>一般解线性方程组有两种方法：</p>
<ul>
<li>直接法
<ul>
<li>高斯消元法</li>
<li>LU分解法</li>
</ul>
</li>
<li>迭代法</li>
</ul>
<p>高斯消元法：初中就学了，就是两个方程变化后相加减（也可以换元），消除变量，直到得到解。这个方法可以拓展到矩阵中，就是把线性方程转化为行阶梯矩阵（中间那个矩阵），然后简化为简化行阶梯矩阵（右边那个矩阵）</p>
<p>$$<br>
\left[<br>
\begin{matrix}<br>
2 &amp; 1 &amp; -1 &amp;|&amp; 8	\\<br>
-3 &amp; -1 &amp; 2 &amp; | &amp; -11 \\<br>
-2 &amp; 1 &amp; 2 &amp; | &amp; -3<br>
\end{matrix}<br>
\right]<br>
=&gt;<br>
\left[<br>
\begin{matrix}<br>
2 &amp; 1 &amp; -1 &amp;|&amp; 8	\\<br>
0 &amp; 1/2 &amp; 1/2 &amp; | &amp; 1 \\<br>
0 &amp; 0 &amp; -1 &amp; | &amp; 1<br>
\end{matrix}<br>
\right]<br>
=&gt;<br>
\left[<br>
\begin{matrix}<br>
1 &amp; 0 &amp; 0 &amp;|&amp; 2	\\<br>
0 &amp; 1 &amp; 0 &amp; | &amp; 3 \\<br>
0 &amp; 0 &amp; 1 &amp; | &amp; -1<br>
\end{matrix}<br>
\right]<br>
$$</p>
<p>前向替换法就是得到行阶梯矩阵后</p>
<img src="/images/前向替换.png" alt="前向替换" style="zoom:50%;" />
<p>能写出以下式子</p>
<p>$$<br>
\begin{cases}	<br>
x_1 = b_1/a_{11} \\<br>
x_2 = (b_2-a_{21}x_1)/a_{22}	\\<br>
\ \vdots	\\<br>
x_n = (b_n -a_{n1}x_1-a_{n2}x_2 - \cdots -a_{nn-1}x_{n-1})/a_{nm}<br>
\end{cases}<br>
$$</p>
<p>于是我们只需要从第一个式子开始，逐步向下替换，就能求出方程的解</p>
<p><em>如果是下三角矩阵，那就是后向替换</em></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a是一个下三角矩阵，x、b是向量
void serialFS(std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; a, std::vector&lt;double&gt;&amp; b) &#123;
    const int N &#x3D; x.size();
    for (int i &#x3D; 0; i &lt; N; ++i) &#123;
        for (int j &#x3D; 0; j &lt; i; ++j) &#123;
            b[i] -&#x3D; a[j + i*N] * x[j];
        &#125;
        x[i] &#x3D; b[i] &#x2F; a[i + i*N];
    &#125;
&#125;</code></pre>
<p>加入分块和并行后：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void parallelFS(std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a,
                std::vector&lt;double&gt; &amp;b) &#123;
  const int N &#x3D; x.size();
  const int block_size &#x3D; 512;
  const int num_blocks &#x3D; N &#x2F; block_size;
  &#x2F;&#x2F;tbb::atomic已经废弃
  std::vector&lt;std::atomic&lt;char&gt;&gt; ref_count(num_blocks * num_blocks);
  for (int r &#x3D; 0; r &lt; num_blocks; ++r) &#123;
    for (int c &#x3D; 0; c &lt;&#x3D; r; ++c) &#123;
      if (r &#x3D;&#x3D; 0 &amp;&amp; c &#x3D;&#x3D; 0)
        ref_count[r * num_blocks + c] &#x3D; 0;
      else if (c &#x3D;&#x3D; 0 || r &#x3D;&#x3D; c)
        ref_count[r * num_blocks + c] &#x3D; 1;
      else
        ref_count[r * num_blocks + c] &#x3D; 2;
    &#125;
  &#125;

  using BlockIndex &#x3D; std::pair&lt;size_t, size_t&gt;;
  BlockIndex top_left(0, 0);
  &#x2F;&#x2F;tbb::parallel_do已经废弃
  tbb::parallel_for_each(&amp;top_left, &amp;top_left + 1,
                         [&amp;](const BlockIndex &amp;bi, tbb::feeder&lt;BlockIndex&gt; &amp;feeder) &#123;
                           size_t r &#x3D; bi.first;
                           size_t c &#x3D; bi.second;
                           int i_start &#x3D; r * block_size, i_end &#x3D; i_start + block_size;
                           int j_start &#x3D; c * block_size, j_max &#x3D; j_start + block_size - 1;
                           for (int i &#x3D; i_start; i &lt; i_end; ++i) &#123;
                             int j_end &#x3D; (i &lt;&#x3D; j_max) ? i : j_max + 1;
                             for (int j &#x3D; j_start; j &lt; j_end; ++j) &#123;
                               b[i] -&#x3D; a[j + i * N] * x[j];
                             &#125;
                             if (j_end &#x3D;&#x3D; i) &#123;
                               x[i] &#x3D; b[i] &#x2F; a[i + i * N];
                             &#125;
                           &#125;
                           &#x2F;&#x2F; add successor to right if ready
                           if (c + 1 &lt;&#x3D; r &amp;&amp; --ref_count[r * num_blocks + c + 1] &#x3D;&#x3D; 0) &#123;
                             feeder.add(BlockIndex(r, c + 1));
                           &#125;
                           &#x2F;&#x2F; add succesor below if ready
                           if (r + 1 &lt; (size_t) num_blocks &amp;&amp; --ref_count[(r + 1) * num_blocks + c] &#x3D;&#x3D; 0) &#123;
                             feeder.add(BlockIndex(r + 1, c));
                           &#125;
                         &#125;
                        );
&#125;</code></pre>
<h3 id="流水线">流水线</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">void parallel_pipeline( size_t max_number_of_live_tokens, const filter&lt;void,void&gt;&amp; filter_chain );

template&lt;typename T, typename U, typename Func&gt;
filter_t&lt;T, U&gt; make_filter(filter::mode mode, const Func&amp; f);</code></pre>
<p>管线（pipeline）是过滤器（filters）的线性序列，物体（items）在通过过滤器时，会被处理</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;并行 将字符串中大写变小写
void fig_2_27(int num_tokens, std::ofstream &amp;caseBeforeFile, std::ofstream &amp;caseAfterFile) &#123;
  tbb::parallel_pipeline(
    &#x2F;&#x2F;tokens
    num_tokens,
    &#x2F;&#x2F;第一个filter，负责创建字符串
    tbb::make_filter&lt;void, CaseStringPtr&gt;(
        &#x2F;&#x2F;tbb::filter::serial_in_order已经废弃
        tbb::filter_mode::serial_in_order,
        &#x2F;&#x2F;filter body
        [&amp;](tbb::flow_control &amp;fc) -&gt; CaseStringPtr &#123;
            CaseStringPtr s_ptr &#x3D; getCaseString(caseBeforeFile);
            if (!s_ptr)
              fc.stop();
            return s_ptr;
        &#125;) 
    
    &amp; &#x2F;&#x2F; 链接
    
    &#x2F;&#x2F;第二个filter，负责修改字符串
    tbb::make_filter&lt;CaseStringPtr, CaseStringPtr&gt;(
        &#x2F;&#x2F;filter node
        tbb::filter_mode::parallel,
        &#x2F;&#x2F;filter body
        [](CaseStringPtr s_ptr) -&gt; CaseStringPtr &#123;
        		std::transform(s_ptr-&gt;begin(), s_ptr-&gt;end(), s_ptr-&gt;begin(),
                       [](char c) -&gt; char &#123;
                         if (std::islower(c))
                           return std::toupper(c);
                         else if (std::isupper(c))
                           return std::tolower(c);
                         else
                           return c;
                       &#125;);
        		return s_ptr;
      &#125;) 
    
      &amp; &#x2F;&#x2F;链接
    
      &#x2F;&#x2F;第三个filter，负责写字符串
    	tbb::make_filter&lt;CaseStringPtr, void&gt;(
          &#x2F;&#x2F;filter node
          tbb::filter_mode::serial_in_order,
          &#x2F;&#x2F;filter body
          [&amp;](CaseStringPtr s_ptr) -&gt; void &#123;
            	writeCaseString(caseAfterFile, s_ptr);
          &#125;)
      );
&#125;</code></pre>
<h2 id="Flow-Graphs">Flow Graphs</h2>
<p>并行编程另一个问题是混乱，传统并行编程为了避免程序混乱（messy），我们需要事无巨细地管理每一件事。但在上一节简单提到的Flow Graphs，提供了一个简单的管理方法</p>
<p>Flow Graphs允许我们用图（DAG）来描述程序，相比于<code>parallel_do</code>和<code>parallel_pipeline</code>，FlowGraphs自由度更高，推荐使用。</p>
<ul>
<li>每个节点是一个并行函数，箭头代表数据的流向/消息传递，我们将这个图称为数据流向图（data flow graphs）</li>
<li>图也可以描述操作的前后顺序，进而可以构建一些传统方法难以表示的独立结构体，这种图被称为依赖图（dependency graphs）</li>
</ul>
<h3 id="预热">预热</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">static void warmupTBB() &#123;
    &#x2F;&#x2F;tbb::task_scheduler_init::default_num_threads()已经弃用
    tbb::parallel_for(0, tbb::this_task_arena::max_concurrency(), [](int) &#123;
        tbb::tick_count t0 &#x3D; tbb::tick_count::now();
        while ((tbb::tick_count::now() - t0).seconds() &lt; 0.01);
    &#125;);
&#125;</code></pre>
<p>无论是web服务器、CPU/GPU并行计算，深度学习，都有warmup的概念</p>
<p>对于一个项目，如果采用冷启动的方式，从零瞬间增加计算量，可能会把系统压垮，于是我们可以使用warmup，逐步提高项目负荷。</p>
<h3 id="数据流图">数据流图</h3>
<ol>
<li>构建图对象</li>
<li>创建节点，填充节点信息</li>
<li>链接节点</li>
<li>发送消息</li>
<li>等待图完成</li>
</ol>
<pre class="language-c++" data-language="c++"><code class="language-c++">void graphSample()&#123;
    &#x2F;&#x2F;创建图对象
    tbb::flow::graph g;
    &#x2F;&#x2F;创建节点
    tbb::flow::function_node&lt;int, std::string&gt; my_first_node(
            g, tbb::flow::unlimited,
            [](const int &amp;in) -&gt; std::string&#123;
                std::cout &lt;&lt; &quot;first node received: &quot; &lt;&lt; in &lt;&lt; std::endl;
                return std::to_string(in);
            &#125;
        );
    tbb::flow::function_node&lt;std::string&gt; my_second_node(
            g, tbb::flow::unlimited,
            [](const std::string &amp;in)&#123;
                std::cout &lt;&lt; &quot;second node received: &quot; &lt;&lt; in &lt;&lt; std::endl;
            &#125;
        );
    &#x2F;&#x2F;链接
    tbb::flow::make_edge(my_first_node, my_second_node);
    &#x2F;&#x2F;发送消息
    my_first_node.try_put(10);
    &#x2F;&#x2F;等待图完成
    g.wait_for_all();
&#125;</code></pre>
<h4 id="节点">节点</h4>
<p>Flow Graphs有三种节点</p>
<ul>
<li>functional</li>
<li>control flow</li>
<li>buffering</li>
</ul>
<h5 id="function-node">function_node</h5>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Body&gt;
function_node(graph&amp; g, size_t concurrency, Body body);</code></pre>
<p>函数节点，当消息传递到该节点，会被函数处理，并将输出值传递给后继者</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;输入一个int类型，输出一个std::string类型
tbb::flow::function_node&lt;int, std::string&gt; my_first_node(
  					&#x2F;&#x2F;图对象
            g, 	
  					&#x2F;&#x2F;节点的并发限制，0是无限制(unlimited)，1是串行(serial)
  					tbb::flow::unlimited,	
  					&#x2F;&#x2F;body
            [](const int &amp;in) -&gt; std::string&#123;
                std::cout &lt;&lt; &quot;first node received: &quot; &lt;&lt; in &lt;&lt; std::endl;
                return std::to_string(in);
            &#125;
        );</code></pre>
<p>函数节点可以从他所连接（edges）其他节点获取消息，也可以使用<code>try_put</code>手动向其传递消息</p>
<h5 id="join-node">join_node</h5>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename Body, typename... Bodies&gt;
join_node(graph&amp;, Body, Bodies...)-&gt;join_node&lt;std::tuple&lt;std::decay_t&lt;input_t&lt;Body&gt;&gt;, std::decay_t&lt;input_t&lt;Bodies&gt;&gt;...&gt;, key_matching&lt;output_t&lt;Body&gt;&gt;&gt;;</code></pre>
<p>流控制节点，当消息传递到该节点，会创建一个消息元组（tuple），然后将元组广播给所有后继者</p>
<p><img src="Image/join.jpg" alt="join"></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;my_node，输入int，输出std::string
tbb::flow::function_node&lt;int, std::string&gt; my_node&#123;...&#125;;
&#x2F;&#x2F;my_other_node，输入int，输出double
tbb::flow::function_node&lt;int, double&gt; my_other_node&#123;...&#125;;
&#x2F;&#x2F;join节点，这里的作用是将两个节点的输出整合，传递给my_final_node
tbb::flow::join_node&lt;std::tuple&lt;std::string, double&gt;,
            tbb::flow::queueing&gt; my_join_node&#123;g&#125;;
&#x2F;&#x2F;my_final_node，输入一个元组
tbb::flow::function_node&lt;std::tuple&lt;std::string, double&gt;, int&gt; my_final_node&#123;g,
                   tbb::flow::unlimited,
                   [](const std::tuple&lt;std::string, double&gt;&amp; in) -&gt; int &#123;
                     std::cout &lt;&lt; &quot;final: &quot; &lt;&lt; std::get&lt;0&gt;(in)
                       &lt;&lt; &quot; and &quot; &lt;&lt; std::get&lt;1&gt;(in) &lt;&lt; std::endl;
                     return 0;
                   &#125;
                  &#125;;</code></pre>
<p>有的时候，我们需要保证<code>join_node</code>的输入的对应的。比如我想将两张照片拼成一张，我开两个节点并行读项目，再用<code>join_node</code>整合后传入merge函数节点，然而在这个过程中，我必须保证传入的两个像素点在同一位置，为此，我们可以添加一个frameNumber做标记（tags）</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;使用函数对象作为tags，可以用input_port&lt;i&gt;读出来
tbb::flow::join_node&lt;std::tuple&lt;Image, Image&gt;, tbb::flow::tag_matching &gt;
    join_images_node(g, [] (Image left) &#123; return left.frameNumber; &#125;,
                        [] (Image right) &#123; return right.frameNumber; &#125; );
...
tbb::flow::make_edge(increase_left_node, tbb::flow::input_port&lt;0&gt;(join_images_node));
tbb::flow::make_edge(increase_right_node, tbb::flow::input_port&lt;1&gt;(join_images_node));
tbb::flow::make_edge(join_images_node, merge_images_node);</code></pre>
<h4 id="链接">链接</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Message&gt;
    inline void make_edge( sender&lt;Message&gt; &amp;p, receiver&lt;Message&gt; &amp;s );
template&lt; typename MultiOutputNode, typename MultiInputNode &gt;
    inline void make_edge( MultiOutputNode&amp; output, MultiInputNode&amp; input );</code></pre>
<p>我们可以使用<code>make_edge</code>链接两个节点</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;这里的input_port是一种sender，跟节点差不多，都能互相链接
make_edge(my_node, tbb::flow::input_port&lt;0&gt;(my_join_node));
make_edge(my_other_node, tbb::flow::input_port&lt;1&gt;(my_join_node));
make_edge(my_join_node, my_final_node);</code></pre>
<h4 id="激活">激活</h4>
<p>为了激活图，我们需要向图中传递消息，除了前文的<code>try_put</code>，我们也可以使用<code>input_port</code></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;my_node是一个input_node
my_node.activate();	&#x2F;&#x2F;将其设为活动状态，启用消息生成</code></pre>
<h4 id="等待">等待</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">g.wait_for_all();</code></pre>
<h3 id="性能限制">性能限制</h3>
<p>Flow Graphs是一个基于Task的并行框架，当消息到达一个节点时，根据节点的并发限制，创建Task。生成的Task会进一步映射为线程（跟上一节讲的循环、算法的机制一样）</p>
<p>真正限制Flow Graphs性能的有</p>
<ul>
<li>串行节点（serial node）</li>
<li>工作线程数</li>
<li>任务复杂度</li>
</ul>
<h3 id="依赖图">依赖图</h3>
<p><em>很像RenderGraph</em></p>
<table>
<thead>
<tr>
<th></th>
<th>数据流向图</th>
<th>依赖图</th>
</tr>
</thead>
<tbody>
<tr>
<td>Edges含义</td>
<td>表示数据流向</td>
<td>表示节点的先后顺序</td>
</tr>
<tr>
<td>信息传递方式</td>
<td>消息</td>
<td>shared memory</td>
</tr>
<tr>
<td>节点类型</td>
<td>function_node</td>
<td>continue_node</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>节点的先后顺序，描述的是依赖关系，只有前面节点执行结束后，后面节点才能安全、正确地执行</p>
</li>
<li>
<p>依赖图不使用函数节点，而是继续节点<code>continue_node</code>，节点间的消息传递使用，当传入<code>continue_node</code>的消息（<code>continue_msg</code>）数量等于该节点需要的消息数量，节点内的函数会开始执行</p>
</li>
<li>
<p><code>continue_node</code>只关心传入的消息数量，不关心消息源。这导致依赖图必须是非循环的（acyclic），因为一个物体循环发出两次消息，（在这里）等同于两个物体各发出一次消息</p>
</li>
</ul>
<p>构建依赖图</p>
<ol>
<li>创建图对象</li>
<li>创建节点</li>
<li>链接</li>
<li>发送信息</li>
<li>等待图完成</li>
</ol>
<h4 id="前向替换-2">前向替换</h4>
<p>之前我们使用<code>parallel_for_each</code>实现了一份前向替换，我们现在用依赖图再实现一次</p>
<p><img src="Image/%E5%89%8D%E5%90%91%E6%9B%BF%E6%8D%A2.jpg" alt="前向替换"></p>
<p>经观察，我们发现辅对角线的块/迭代器是相互独立的，他们之间没有依赖关系（上图(b)，块BC间没有依赖，他们只需要在A之后执行就可以正确运算）</p>
<p>经观察，同时并行计算的最大块数为辅对角线的长度，也就是图中标注的 a set of independent blocks</p>
<p>经观察，上图(b)中每一个块需要接受两个msg，正好与block_sizes大小相等</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">using Node &#x3D; tbb::flow::continue_node&lt;tbb::flow::continue_msg&gt;;
using NodePtr &#x3D; std::shared_ptr&lt;Node&gt;;
NodePtr createNode(tbb::flow::graph &amp;g, int r, int c, int block_size,
                   std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b);
void addEdges(std::vector&lt;NodePtr&gt; &amp;nodes, int r, int c, int block_size, int num_blocks);
void dependencyGraphFS(std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b)&#123;
    const int N &#x3D; x.size();
    const int block_size &#x3D; 1024;
    const int num_blocks &#x3D; N &#x2F; block_size;
		&#x2F;&#x2F;创建num_blocks * num_blocks个节点，只不过我们只会用到下半部分
    std::vector&lt;NodePtr&gt; nodes(num_blocks * num_blocks);
    &#x2F;&#x2F;创建图对象
    tbb::flow::graph g;
  	&#x2F;&#x2F;我们从最下面一行开始向上构建
    for(int r &#x3D; num_blocks-1; r &gt;&#x3D; 0; --r)&#123;
        for(int c &#x3D; r; c &gt;&#x3D; 0; --c)&#123;
            &#x2F;&#x2F;创建图节点
            nodes[r * num_blocks + c] &#x3D; createNode(g, r, c, block_size, x, a, b);
            &#x2F;&#x2F;链接
            addEdges(nodes, r, c, block_size, num_blocks);
        &#125;
    &#125;
    &#x2F;&#x2F;传入消息
    nodes[0]-&gt;try_put(tbb::flow::continue_msg());
    &#x2F;&#x2F;等待完成
    g.wait_for_all();
&#125;

NodePtr createNode(tbb::flow::graph &amp;g, int r, int c, int block_size,
                   std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b)&#123;
    const int N &#x3D; x.size();
    return std::make_shared&lt;Node&gt;(
            g,
            [r, c, block_size, N, &amp;x, &amp;a, &amp;b](const tbb::flow::continue_msg &amp; msg)&#123;
                int i_start &#x3D; r * block_size, i_end &#x3D; i_start + block_size;
                int j_start &#x3D; c * block_size, j_max &#x3D; j_start + block_size -1;
                &#x2F;&#x2F;对于每个块，串行进行正向替换计算
                for(int i &#x3D; i_start; i &lt; i_end; ++i)&#123;
                    int j_end &#x3D; (i &lt;&#x3D; j_max) ? i : j_max+1;
                    for(int j &#x3D; j_start; j &lt; j_end; ++j)&#123;
                        b[i] -&#x3D; a[j + i*N] * x[j];
                    &#125;
                    if(j_end &#x3D;&#x3D; i)&#123;
                        x[i] &#x3D; b[i] &#x2F; a[i + i*N];
                    &#125;
                &#125;
                return msg;
            &#125;
        );
&#125;

void addEdges(std::vector&lt;NodePtr&gt; &amp;nodes, int r, int c, int block_size, int num_blocks)&#123;
    NodePtr np &#x3D; nodes[r * num_blocks + c];
  	&#x2F;&#x2F;每个块链接自己的下面和右边，最下面和最右边不链接
    if(c + 1 &lt; num_blocks &amp;&amp; r !&#x3D; c)&#123;
        tbb::flow::make_edge(*np, *nodes[r * num_blocks + c + 1]);
    &#125;
    if(r + 1 &lt; num_blocks)&#123;
        tbb::flow::make_edge(*np, *nodes[(r+1) * num_blocks + c]);
    &#125;
&#125;</code></pre>
<h2 id="PSTL">PSTL</h2>
<p>parallel_sort</p>
<h2 id="同步">同步</h2>
<p>在并行编程中，我们要极力避免同步（Synchronization）和互斥（exclusion），这会严重影响性能</p>
<p>但是很多情况下，我们不得不同步，书中称其为“必要之恶”（necessary evil）</p>
<h3 id="写冲突">写冲突</h3>
<p>比如我们想要统计一张图中各种颜色出现的次数，如果是串行处理，我们就遍历每一个像素，用一个数组存储统计值</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 0; i &lt; N; ++i)&#123;
  hist[image[i]]++;
&#125;</code></pre>
<p>但当我们想要并行处理遍历像素时，就会出现问题。如果两个线程同时读到了同一种颜色，于是都想执行<code>hist[p]++</code>，而如果该操作不支持原子（atomic）操作，就会出现写冲突</p>
<h4 id="RMW">RMW</h4>
<p>现代操作系统将很多操作设置为原子操作，该操作被视为一个完成的操作，不可分割，因此是线程安全的。比如对齐读（Aligned Read），对齐写（Aligned Write）</p>
<p><em>原子的本意就是不可分割的意思，当年化学家和物理学家认为原子是最小的粒子（尽管并非如此）</em></p>
<p>Read-Modify-Write（RMW）设计原则，可以让复杂操作原子化，当多个线程想要对某个内存进行修改时，保证线程安全并只执行一次</p>
<p>windows原子操作的实现原理（_InterlockedIncrement）</p>
<ol>
<li>读内存</li>
<li>计算得到新值</li>
<li>若内存位置仍然是原始值，则将新值写入该内存位置
<ul>
<li>若不是原始值，则在下一个循环周期中重新操作</li>
</ul>
</li>
</ol>
<h4 id="锁">锁</h4>
<p>解决并行写冲突最简单的方法就是加锁，我们给对象加一个互斥锁（mutex），写之前上锁，写完解锁，其他线程无法操作锁住的对象。而上锁解锁操作中间的代码被称为临界区（critical section），是被锁保护的部分。</p>
<p>锁会影响性能</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;tbb::task_scheduler_init init&#123;nth&#125;已经弃用，用于设置最大线程数
tbb::global_control global_limit(tbb::global_control::max_allowed_parallelism, nth);

using my_mutex_t&#x3D;tbb::spin_mutex;
my_mutex_t my_mutex;
std::vector&lt;int&gt; hist_p(num_bins);
parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;,
             [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
             &#123;
                 &#x2F;&#x2F;这种写法比my_lock.acquire(my_mutex)、my_lock.release()好
                 my_mutex_t::scoped_lock my_lock&#123;my_mutex&#125;;
                 for (size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)
                   	hist_p[image[i]]++;
             &#125;);</code></pre>
<h4 id="原子操作">原子操作</h4>
<p>锁过于消耗性能，原子操作效果会好一些，只不过这样还是比线性慢，而且不是真共享（Sharing）</p>
<p>什么是原子？原子的原意就是不可分割的基本粒子，我们在实现<code>a++</code>时，本质是分了三步</p>
<ol>
<li>取a</li>
<li>加法运算</li>
<li>写a</li>
</ol>
<p>由于并行计算，其他线程可能在你完整完成这三步期间进行操作，于是就会出现冲突。而原子操作就是将这三步视为一步，不可分割，在完整完成这三部之前，其他线程无权访问，等到操作结束</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">std::vector&lt;std::atomic&lt;int&gt;&gt; hist_p2(num_bins);
parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, 
             [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
             &#123;
                 for(size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)
                 &#123;
                     hist_p2[image[i]]++;
                 &#125;
             &#125;
            );</code></pre>
<h3 id="Thread-Local-Storage">Thread Local Storage</h3>
<p>一个较好的解决方案是私有化（Privatization）和归并（Reduction）</p>
<p>我感觉这个的设计理念就是：如果不得不同步，那就尽可能让更多更复杂的计算并行执行，最后对统一、规范、简单的数据进行同步</p>
<p>前面并行统计Image像素信息时，会出现多个线程写冲突。但如果让每个线程都有一个Image副本，线程对自己的副本进行操作（私有化），最后将这些副本进行归并。</p>
<p>私有化确实不会出现写冲突了，尽管归并仍然存在同步问题，但这个归并更简单，毕竟归并几个数，远远比处理几个线程冲突要简单，性能开销小</p>
<p>TBB提供了多种私有化+归并的的方案，其中归并模板（parallel_reduce）在TBB基础时就讲了</p>
<ul>
<li>Thread Local Storage（TLS）：让每一个线程拥有一份副本，只不过存储开销过大，不宜过多使用
<ul>
<li>enumerable_thread_specific（ETS）</li>
<li>combinable</li>
</ul>
</li>
</ul>
<h4 id="ETS">ETS</h4>
<p><code>tbb::enumerable_thread_specific&lt;T&gt;</code>对象是一个大容器，容器内包含者每一个线程所对应的副本，我们可以使用迭代器进行访问</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">using vector_t &#x3D; std::vector&lt;int&gt;;
using priv_h_t &#x3D; tbb::enumerable_thread_specific&lt;vector_t&gt;;
priv_h_t priv_h&#123;num_bins&#125;;
&#x2F;&#x2F;私有化
parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;,
             [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
             &#123;
                 &#x2F;&#x2F;若该线程第一次使用local，那么会创建一个新的vector&lt;int&gt;，初始值为0
                 priv_h_t::reference my_hist &#x3D; priv_h.local();
                 for (size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)&#123;
                     &#x2F;&#x2F;my_hist是引用，实际上是在修改priv_h[xxx]，以此将数据传递到线程外
                     my_hist[image[i]]++;
                 &#125;     
             &#125;);
&#x2F;&#x2F;归并
vector_t hist_p3(num_bins);
for(auto i&#x3D;priv_h.begin(); i!&#x3D;priv_h.end(); ++i)&#123;
    for (int j&#x3D;0; j&lt;num_bins; ++j) &#123;
    	hist_p3[j]+&#x3D;(*i)[j];
    &#125;
&#125;</code></pre>
<p>使用STL算法替代循环，进行归并</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;我们可以使用transform替代循环遍历
for (auto&amp; i: priv_h) &#123; &#x2F;&#x2F; i traverses all private vectors
    std::transform(hist_p3.begin(),    &#x2F;&#x2F; source 1 begin
                   hist_p3.end(),      &#x2F;&#x2F; source 1 end
                   i.begin(),          &#x2F;&#x2F; source 2 begin
                   hist_p3.begin(),    &#x2F;&#x2F; destination begin
                   std::plus&lt;int&gt;() ); &#x2F;&#x2F; binary operation
	&#125;</code></pre>
<p>由于归并过于常用，TBB也对归并做了封装</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;使用combine_each
priv_h.combine_each([&amp;](vector_t i)&#123;
        std::transform(hist_p3.begin(),   	&#x2F;&#x2F; source 1 begin
                   hist_p3.end(),      		&#x2F;&#x2F; source 1 end
                   i.begin(),         		&#x2F;&#x2F; source 2 begin
                   hist_p3.begin(),    		&#x2F;&#x2F; destination begin
                   std::plus&lt;int&gt;() );		&#x2F;&#x2F; binary operation
    &#125;);
&#x2F;&#x2F;或者使用combine
vector_t hist_p &#x3D; priv_h.combine([](vector_t a, vector_t b) -&gt; vector_t &#123;
      std::transform(a.begin(),         &#x2F;&#x2F; source 1 begin
                     a.end(),           &#x2F;&#x2F; source 1 end
                     b.begin(),         &#x2F;&#x2F; source 2 begin
                     a.begin(),         &#x2F;&#x2F; destination begin
                     std::plus&lt;int&gt;() );&#x2F;&#x2F; binary operation
       return a;
    &#125;);</code></pre>
<h4 id="combinable">combinable</h4>
<p><code>combinable&lt;T&gt;</code>对象也是一个容器，每一个线程对应一个instance</p>
<p>但是与ETS不同，<code>combinable&lt;T&gt;</code>并不能使用迭代器访问，这样设计的目的是不向外暴露对象，这样归并结束后大容器和其中的数据都释放了，以此节省局部空间</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;combinable
tbb::combinable&lt;vector_t&gt; priv_h2&#123;[num_bins]()&#123;return vector_t(num_bins);&#125;&#125;;
&#x2F;&#x2F;私有化
parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;,
             [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
             &#123;
                 vector_t&amp; my_hist &#x3D; priv_h2.local();
                 for (size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)
                     my_hist[image[i]]++;
             &#125;);
&#x2F;&#x2F;归并
vector_t hist_p4(num_bins);
priv_h2.combine_each([&amp;](vector_t i)
                     &#123; &#x2F;&#x2F; for each priv histogram a
                         std::transform(hist_p4.begin(),     &#x2F;&#x2F; source 1 begin
                                        hist_p4.end(),      &#x2F;&#x2F; source 1 end
                                        i.begin(),          &#x2F;&#x2F; source 2 begin
                                        hist_p4.begin(),    &#x2F;&#x2F; destination begin
                                        std::plus&lt;int&gt;() ); &#x2F;&#x2F; binary operation
                     &#125;);</code></pre>
<p>最终性能比较，能看出TLS能大幅提高性能</p>
<pre class="language-none"><code class="language-none">Serial:       0.399203
Parallel:     2.01466
Atomic:       0.500326
ETC:          0.0348115
combinable:   0.0339478</code></pre>
<h3 id="parallel-reduce">parallel_reduce</h3>
<p>最简单的归并，还是给用tbb封装好的模板，该算法的本质是树形规约</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;parallel_reduce
using image_iterator &#x3D; std::vector&lt;uint8_t&gt;::iterator;
t0 &#x3D; tbb::tick_count::now();
vector_t hist_p5 &#x3D; parallel_reduce (
    &#x2F;*range*&#x2F;    
    tbb::blocked_range&lt;image_iterator&gt;&#123;image.begin(), image.end()&#125;,
    &#x2F;*identity*&#x2F; 
    vector_t(num_bins),
    &#x2F;&#x2F; 1st Lambda: Parallel computation on private histograms
    [](const tbb::blocked_range&lt;image_iterator&gt;&amp; r, vector_t v) &#123;
        std::for_each(r.begin(), r.end(),
                      [&amp;v](uint8_t i) &#123;v[i]++;&#125;);
        return v;
    &#125;,
    &#x2F;&#x2F; 2nd Lambda: Parallel reduction of the private histograms
    [num_bins](vector_t a, const vector_t &amp; b) -&gt; vector_t &#123;
        for(int i&#x3D;0; i&lt;num_bins; ++i) a[i] +&#x3D; b[i];
        return a;
&#125;);</code></pre>
<h2 id="并发容器">并发容器</h2>
<p>在上一节我们遇到了同步问题，处理同步会大幅降低性能，为此我们使用了TLS等方法实现了高效的显式同步，而这一节，我们将介绍TBB的核心，并发（Concurrent）</p>
<p>TBB提供了一些高效、线程安全的并发容器，他们大多是使用细粒度的锁或者无锁设计</p>
<ul>
<li>细粒度锁：指锁定真正需要锁定的地方（其实还是挺低效的），比如一个数组我们只锁我们需要的某一个元素，其他线程如果不访问我这个元素，就能正常并行</li>
<li>无锁：有的线程负责操作，有的线程负责纠错</li>
</ul>
<p>TBB的并发容器并发性能很好，但串行性能不如STL</p>
<ul>
<li>顺序表（Sequences）
<ul>
<li><code>concurrent_vector</code></li>
</ul>
</li>
<li>队列（Queues）
<ul>
<li><code>concurrent_queue</code></li>
<li><code>concurrent_bounded_queue</code></li>
<li><code>concurrent_priority_queue</code></li>
</ul>
</li>
<li>无序关联容器（Unordered associative containers）
<ul>
<li><code>concurrent_hash_map</code></li>
<li><code>map/multimap</code></li>
<li><code>set/multiset</code></li>
</ul>
</li>
<li>有序关联容器（Ordered associative containers）
<ul>
<li><code>map/multimap</code></li>
<li><code>set/multiset</code></li>
</ul>
</li>
</ul>
<h3 id="concurrent-hash-map">concurrent_hash_map</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename Key, typename T,
                 typename HashCompare &#x3D; tbb_hash_compare&lt;Key&gt;,
                 typename Allocator &#x3D; tbb_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
class concurrent_hash_map &#123;..&#125;</code></pre>
<p>这是一个字符串-Int的哈希表</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;HashCompare必须有hash函数和equal函数
struct MyHashCompare&#123;
    static size_t hash(const std::string&amp; s)&#123;
        size_t h &#x3D; 0;
        for(auto &amp;c : s)&#123;
            h &#x3D; (h*17)^c;
        &#125;
        return h;
    &#125;
    static bool equal(const std::string&amp; x, const std::string&amp; y)&#123;
        return x &#x3D;&#x3D; y;
    &#125;
&#125;;
&#x2F;&#x2F;hash map
typedef tbb::concurrent_hash_map&lt;std::string, int, MyHashCompare&gt; StringTable;
&#x2F;&#x2F;一个函数对象，用于记录table内元素数量
class Tally&#123;
private:
    StringTable&amp; table;
public:
    Tally(StringTable&amp; table_): table(table_) &#123;&#125;
    void operator() (const tbb::blocked_range&lt;std::string*&gt; range) const &#123;
        for(std::string* p &#x3D; range.begin(); p !&#x3D; range.end(); ++p)&#123;
          	&#x2F;&#x2F;accessor类似于锁、智能智能，在accessor完成前，其他线程不能lookup这个key
            StringTable::accessor a;
            table.insert(a, *p);
            a-&gt;second +&#x3D; 1;
        &#125;
    &#125;
&#125;;</code></pre>
<pre class="language-c++" data-language="c++"><code class="language-c++">int main() &#123;
    StringTable table;
    tbb::parallel_for( tbb::blocked_range&lt;std::string*&gt;( Data, Data+N, 1000 ), Tally(table) );

    for( StringTable::iterator i&#x3D;table.begin();
         i!&#x3D;table.end();
         ++i )
        printf(&quot;%s %d\n&quot;,i-&gt;first.c_str(),i-&gt;second);
    return 0;
&#125;</code></pre>
<h2 id="内存分配">内存分配</h2>
<p>内存分配最重要的是正确，TBB提供了一套可拓展的内存分配</p>
<p>现代C++推荐使用智能指针进行内存管理，不推荐使用malloc和new。TBB完全适配所有版本的C++标准，也推荐使用智能指针进行内存分配</p>
<p>TBB动态内存分配的核心是线程内存池（memory pooling by threads），该内存池可以避免内存分配带来的性能下降，也不苛求“避免cache间不必要的数据移动”</p>
<p>TBB还提供了可拓展的缓存对齐，比<code>std::aligned_alloc</code>使用更简单方便。只不过滥用缓存对齐可能会带了巨大的内存浪费</p>
<p>在并行编程中，内存分配的主要问题是：分配器的争用，缓存效果</p>
<ul>
<li>分配器争用：C++内存分存储在两个位置，堆和栈。传统的非线程分配器只能在单个全局堆中分配和释放内存，这个过程配合锁以实现互斥，很低效</li>
<li>缓存效应：某些操作可能会把缓存中的数据移动到缓存的另一处，这是很无效的行为，要避免</li>
</ul>
<h3 id="缓存填充（对齐）">缓存填充（对齐）</h3>
<p>用于解决假共享（我们在同步那一节解决了真共享带来的问题）</p>
<p>基于局部性原则，当CPU查询某个数据时：</p>
<ol>
<li>若cache中没有找到，就会去内存中寻找</li>
<li>找到后会将该数据写入cache（时间局部性，刚刚被引用过的一个内存位置容易再次被引用）</li>
<li>并将其相邻元素也写入cache（空间局部性，一个内存位置被引用，其相邻位置很可能马上被引用）</li>
</ol>
<p><img src="Image/%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7.png" alt="空间局部性"></p>
<p>如上图，CPU访问a时，先去cache去找，如果cache中没有，就会去内存中寻找，找到后将a和相邻的b写入cache的<strong>同一行</strong>。但问题出现了，如果当前cache的其他行里，已经有b了呢？</p>
<p>另一个线程也拥有一缓存行，里面存储了b，结果b却被移动到a那一行了，于是这个线程要访问b，又要去内存中找，增加了cache miss。此外多线程中，a那个线程多半是不会用到b的，于是平白做了cache位置的移动。</p>
<p>这个现象被称为假共享（false sharing），a和b并不是共享对象，但是由于他们靠的太近了，以至于在一个缓存行中，其中一个对象的更新，会强制另一个对象更新。</p>
<p>在多线程中，假共享可以通过缓存填充（cache padding）解决。缓存填充，就是在缓存中两个变量中间填充一些没有意义的数据，于是导致这两个变量不会处于同一个缓存行中，于是避免了假共享。</p>
<p>我们还是以统计图片像素为例，我们发现这种方法比直接用原子操作要快一些</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct bin&#123;
    std::atomic&lt;int&gt; count; &#x2F;&#x2F;4 bytes
    uint8_t padding[64 - sizeof(count)];    &#x2F;&#x2F;60 bytes
&#125;;
&#x2F;&#x2F;cache padding
std::vector&lt;bin, tbb::cache_aligned_allocator&lt;bin&gt;&gt; hist_p6(num_bins);
t0 &#x3D; tbb::tick_count::now();
parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;,
             [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
             &#123;
               for(size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)
               &#123;
                 hist_p6[image[i]].count++;
               &#125;
             &#125;
            );</code></pre>
<p>我们可以用C++特性来创建结构体：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct bin&#123;
    &#x2F;&#x2F;C++17后，可以用std::hardware_destructive_interference_size替代64
    alignas(64) std::atomic&lt;int&gt; count;
&#125;;</code></pre>
<h3 id="代理">代理</h3>
<p>TBB的TBBmalloc库使用代理方法，可以实现在不同操作系统，不改变代码，只需要配置一些动态库、代理库、环境变量，就可以实现全局替换new、malloc等分配函数，这对跨平台真的很重要</p>
<h2 id="Task调度">Task调度</h2>
<p>Chapter10</p>
<h2 id="资料">资料</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/Apress/pro-TBB">Pro TBB</a></p>
<p><a target="_blank" rel="noopener" href="https://spec.oneapi.io/versions/latest/elements/oneTBB/source/nested-index.html">API Document</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Reuben-Sun/TBB--Programing-Sample">代码仓库</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/" data-id="clepy40oi0016glnkd97k1xnb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" rel="tag">并行计算</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-program/CMake入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/01/program/CMake%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2023-02-01T10:01:25.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/01/program/CMake%E5%85%A5%E9%97%A8/">CMake入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>CMake</h1>
<h2 id="快速入门">快速入门</h2>
<p>一个大项目（Project）内嵌多个子项目（SubProject）</p>
<p>一个子项目内有src、include、CMakeLists.txt，其中有一个子项目中有main.cpp</p>
<img src="/images/C++项目结构.png" alt="C++项目结构" style="zoom:50%;" />
<p>最外面的CMakeLists.txt，负责连接所有子项目：</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.20</span><span class="token punctuation">)</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>Project<span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">14</span><span class="token punctuation">)</span>
<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>subProject1<span class="token punctuation">)</span>
<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>subProject2<span class="token punctuation">)</span></code></pre>
<p>subProject1（main.cpp所在的子项目）下面的CMakeLists.txt：</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp include/*.h<span class="token punctuation">)</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>subProject1 <span class="token punctuation">$&#123;</span>srcs<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>subProject1 <span class="token namespace">PUBLIC</span> include<span class="token punctuation">)</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>subProject1 <span class="token namespace">PUBLIC</span> subProject2<span class="token punctuation">)</span></code></pre>
<p>subProject2下面的CMakeLists.txt：</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp include/*.h<span class="token punctuation">)</span>
<span class="token keyword">add_library</span><span class="token punctuation">(</span>subProject2 <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>srcs<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>subProject2 <span class="token namespace">PUBLIC</span> include<span class="token punctuation">)</span></code></pre>
<h2 id="一：CMake基础语法">一：CMake基础语法</h2>
<h3 id="CMakeLists-txt">CMakeLists.txt</h3>
<p>我们将CMake指令放在<code>CMakeLists.txt</code>文件中</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置CMake所需最低版本</span>
<span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.20</span><span class="token punctuation">)</span>
<span class="token comment">#设置项目名称为CMakeStudy，支持的语言为C++（CXX表示C++）</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>CMakeStudy LANGUAGES CXX<span class="token punctuation">)</span>
<span class="token comment">#设置创建的新目标名称：一个名叫CMakeStudy的可执行文件</span>
<span class="token comment">#这个可执行文件是通过编译和链接源文件main.cpp生成的</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>CMakeStudy main.cpp<span class="token punctuation">)</span></code></pre>
<ul>
<li>CMake语言不区分大小写，但参数区分大小写</li>
<li>CMake的缺省默认语言为C++</li>
</ul>
<h3 id="构建">构建</h3>
<p>写好<code>CMakeLists.txt</code>文件后，在命令行中输入：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cmake</span> -H. <span class="token parameter variable">-Bbuild</span></code></pre>
<p>这个命令会搜索当前目录下的根<code>CMakeLists.txt</code>文件，创建一个<code>build</code>目录，在其中生成所有的代码</p>
<p>然后再build目录中输入命令，以完成编译</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cmake</span> <span class="token parameter variable">--build</span> <span class="token builtin class-name">.</span></code></pre>
<p>一般我们不会在源码内部构建，因为这会污染源码的目录树</p>
<h3 id="链接">链接</h3>
<p>如果项目中有多个文件，如</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5.png" alt="链接"></p>
<p>可以改目标生成</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello main.cpp Message.cpp Message.h<span class="token punctuation">)</span></code></pre>
<p>但是这种改法太麻烦了，每添加一个文件就要在后面添一端，最后这东西会特别长</p>
<p>我们可以把这个类编译成一个（静态）库，然后再将库链接到可执行文件中（你还记得c++编译器的编译步骤吗？）</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.20</span><span class="token punctuation">)</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>CMakeStudy LANGUAGES CXX<span class="token punctuation">)</span>
<span class="token comment">#将两个文件编译成库</span>
<span class="token keyword">add_library</span><span class="token punctuation">(</span>message <span class="token namespace">STATIC</span> Message.h Message.cpp<span class="token punctuation">)</span>
<span class="token comment">#目标不变</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello main.cpp<span class="token punctuation">)</span>
<span class="token comment">#链接</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>hello message<span class="token punctuation">)</span></code></pre>
<p>此外，我们能在buid目录中找到一个名为/形如<code>libmessage.a</code>的文件，这就是编译得到的静态库</p>
<h4 id="add-library">add_library</h4>
<p>生成一个名叫<code>message</code>的库</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_library</span><span class="token punctuation">(</span>message <span class="token namespace">STATIC</span> Message.h Message.cpp<span class="token punctuation">)</span></code></pre>
<ul>
<li>
<p>第一个参数是目标名，后续可以使用该名来引用库</p>
</li>
<li>
<p>第二个参数是库的种类</p>
<ul>
<li>STATIC：静态库</li>
<li>SHARED：动态库</li>
<li>OBJECT：对象库（将代码编译到可执行文件内部的静态库）</li>
<li>MODULE：一种不会链接到项目中任何目标的动态共享对象（DSO），可以运行时动态加载</li>
</ul>
</li>
</ul>
<p>此外CMake还有一些不会出现在构建系统里的库</p>
<ul>
<li>IMPORTED：项目外部的库，用于对现有依赖项进行构建，认为是不可变的</li>
<li>INTERFACE：也是项目之外的库，但是可变</li>
<li>ALIAS：对已有的库做别名</li>
</ul>
<h4 id="条件语句">条件语句</h4>
<p>在讲链接时，我们给出了两种编译方法，我们希望能在两种方式间切换</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.20</span><span class="token punctuation">)</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>CMakeStudy LANGUAGES CXX<span class="token punctuation">)</span>
<span class="token comment">#引入一个新变量USE_LIBRARY，设置为OFF</span>
<span class="token keyword">set</span><span class="token punctuation">(</span>USE_LIBRARY <span class="token boolean">OFF</span><span class="token punctuation">)</span>
<span class="token comment">#打印信息</span>
<span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"Compile sources into a library? <span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">USE_LIBRARY</span><span class="token punctuation">&#125;</span></span>"</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">BUILD_SHARED_LIBS</span> <span class="token boolean">OFF</span><span class="token punctuation">)</span>
<span class="token comment">#引入一个list变量: _sources，包含两个文件</span>
<span class="token keyword">list</span><span class="token punctuation">(</span>APPEND _sources Message.h Message.cpp<span class="token punctuation">)</span>
<span class="token comment">#判断，若USE_LIBRARY为真，则编译成库</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>USE_LIBRARY<span class="token punctuation">)</span>
    <span class="token keyword">add_library</span><span class="token punctuation">(</span>message <span class="token punctuation">$&#123;</span>_sources<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
    <span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello main.cpp<span class="token punctuation">)</span>
    <span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>hello message<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello main.cpp <span class="token punctuation">$&#123;</span>_sources<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h4 id="逻辑变量">逻辑变量</h4>
<ul>
<li>true：<code>1</code>、<code>ON</code>、<code>YES</code>、<code>true</code>、<code>Y</code>、非零数</li>
<li>false：<code>0</code>、<code>OFF</code>、<code>NO</code>、<code>false</code>、<code>N</code>、<code>IGNORE</code>、<code>NOTFOUND</code>、空字符串、以<code>-NOTFOUND</code>为后缀</li>
</ul>
<h4 id="全局变量">全局变量</h4>
<p>CMake有一些全局变量，修改他们可以起到配置作用，这里设置的</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">BUILD_SHARED_LIBS</span> <span class="token boolean">OFF</span><span class="token punctuation">)</span></code></pre>
<p>当设置为OFF时，可以使<code>add_library</code>不用传递第二个参数</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMAKE_RUNTIME_OUTPUT_DIRECTORY</td>
<td>.exe、.dll文件的输出路径</td>
</tr>
<tr>
<td>CMAKE_ARCHIVE_OUTPUT_DIRECTORY</td>
<td>.a文件的输出路径</td>
</tr>
<tr>
<td>CMAKE_LIBRARY_OUTPUT_DIRECTORY</td>
<td>.so文件的输出路径</td>
</tr>
<tr>
<td>CMAKE_CURRENT_SOURCE_DIR</td>
<td>当前CMakeLists.txt所在路径</td>
</tr>
<tr>
<td>PROJECT_NAME</td>
<td>项目名字</td>
</tr>
<tr>
<td>CMAKE_MODULE_PATH</td>
<td>cmake模块所在路径</td>
</tr>
</tbody>
</table>
<h3 id="用户选项">用户选项</h3>
<p>在上面我们引入了一个条件语句，但是是硬编码的。我们希望用户可以控制<code>USE_LIBRARY</code>，于是可以使用<code>option</code></p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#set(USE_LIBRARY OFF)</span>
<span class="token keyword">option</span><span class="token punctuation">(</span>USE_LIBRARY <span class="token string">"Compile sources into a library"</span> <span class="token boolean">OFF</span><span class="token punctuation">)</span></code></pre>
<p>将上面下面的<code>set</code>替换为<code>option</code>，运行</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cmake</span> <span class="token parameter variable">-D</span> <span class="token assign-left variable">USE_LIBRARY</span><span class="token operator">=</span>ON</code></pre>
<p>如果是Clion可以配置</p>
<p><img src="/images/Clion-Option.png" alt="Clion-Option"></p>
<h3 id="构建类型">构建类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>有无优化</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debug</td>
<td>没有优化，带调试符号</td>
</tr>
<tr>
<td>Release</td>
<td>有优化，没有调试符号</td>
</tr>
<tr>
<td>RelWithDebInfo</td>
<td>有少量优化，带调试符号</td>
</tr>
<tr>
<td>MinSizeRel</td>
<td>不增加代码大小来优化</td>
</tr>
</tbody>
</table>
<h3 id="编译选项">编译选项</h3>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.20</span><span class="token punctuation">)</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>CMakeStudy LANGUAGES CXX<span class="token punctuation">)</span>

<span class="token keyword">list</span><span class="token punctuation">(</span>APPEND flags <span class="token string">"-fPIC"</span> <span class="token string">"-Wall"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">NOT</span> <span class="token variable">WIN32</span><span class="token punctuation">)</span>
    <span class="token keyword">list</span><span class="token punctuation">(</span>APPEND flags <span class="token string">"-Wextra"</span> <span class="token string">"-Wpedantic"</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#添加一个库</span>
<span class="token keyword">add_library</span><span class="token punctuation">(</span>message
    <span class="token namespace">STATIC</span>
        Message.h
        Message.cpp
<span class="token punctuation">)</span>
<span class="token comment">#为库设置编译选项</span>
<span class="token keyword">target_compile_options</span><span class="token punctuation">(</span>message
    <span class="token namespace">PRIVATE</span>
        <span class="token punctuation">$&#123;</span>flags<span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span>
<span class="token comment">#添加可执行目标</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello main.cpp<span class="token punctuation">)</span>
<span class="token comment">#为可执行目标设置编译选项</span>
<span class="token keyword">target_compile_options</span><span class="token punctuation">(</span>hello
    <span class="token namespace">PRIVATE</span>
        <span class="token string">"-fPIC"</span>
<span class="token punctuation">)</span>
<span class="token comment">#链接</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>hello message<span class="token punctuation">)</span></code></pre>
<table>
<thead>
<tr>
<th>可见性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PRIVATE</td>
<td>编译选项仅对目标生效，不会传递（hello链接了message，但不会接受message的编译选项）</td>
</tr>
<tr>
<td>INTERFACE</td>
<td>编译选项对目标生效，并传递给相关目标</td>
</tr>
<tr>
<td>PUBLIC</td>
<td>编译选项对目标和使用它的目标生效</td>
</tr>
</tbody>
</table>
<p><code>-Wall</code>、<code>-Wextra</code>等是警告标志</p>
<h3 id="循环">循环</h3>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">foreach</span><span class="token punctuation">(</span>_source <span class="token punctuation">$&#123;</span>sources_with_lower_optimization<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token keyword">get_source_file_property</span><span class="token punctuation">(</span>_flags <span class="token punctuation">$&#123;</span>_source<span class="token punctuation">&#125;</span> <span class="token property">COMPILE_FLAGS</span><span class="token punctuation">)</span>
  <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"Source <span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">_source</span><span class="token punctuation">&#125;</span></span> has the following extra COMPILE_FLAGS: <span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">_flags</span><span class="token punctuation">&#125;</span></span>"</span><span class="token punctuation">)</span>
<span class="token keyword">endforeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h2 id="二：环境检查">二：环境检查</h2>
<h3 id="检查平台">检查平台</h3>
<p>我们要处理如下的C++源码（hello-world.cpp）</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">std::string say_hello() &#123;
#ifdef IS_WINDOWS
  return std::string(&quot;Hello from Windows!&quot;);
#elif IS_LINUX
  return std::string(&quot;Hello from Linux!&quot;);
#elif IS_MACOS
  return std::string(&quot;Hello from macOS!&quot;);
#else
  return std::string(&quot;Hello from an unknown system!&quot;);
#endif
&#125;</code></pre>
<p>CMake可以加入</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#查询操作系统</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">CMAKE_SYSTEM_NAME</span> <span class="token operator">STREQUAL</span> <span class="token string">"Linux"</span><span class="token punctuation">)</span>
	<span class="token comment">#设置宏</span>
  <span class="token keyword">target_compile_definitions</span><span class="token punctuation">(</span>hello-world <span class="token namespace">PUBLIC</span> <span class="token string">"IS_LINUX"</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">CMAKE_SYSTEM_NAME</span> <span class="token operator">STREQUAL</span> <span class="token string">"Darwin"</span><span class="token punctuation">)</span>
  <span class="token keyword">target_compile_definitions</span><span class="token punctuation">(</span>hello-world <span class="token namespace">PUBLIC</span> <span class="token string">"IS_MACOS"</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">CMAKE_SYSTEM_NAME</span> <span class="token operator">STREQUAL</span> <span class="token string">"Windows"</span><span class="token punctuation">)</span>
  <span class="token keyword">target_compile_definitions</span><span class="token punctuation">(</span>hello-world <span class="token namespace">PUBLIC</span> <span class="token string">"IS_WINDOWS"</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h3 id="检查编译器">检查编译器</h3>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_COMPILER_ID</span> <span class="token operator">MATCHES</span> Intel<span class="token punctuation">)</span>
	...
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_COMPILER_ID</span> <span class="token operator">MATCHES</span> GNU<span class="token punctuation">)</span>
	...
...</code></pre>
<h3 id="检查处理器架构">检查处理器架构</h3>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">CMAKE_SIZEOF_VOID_P</span> <span class="token operator">EQUAL</span> <span class="token number">8</span><span class="token punctuation">)</span>
	<span class="token comment">#64bits</span>
<span class="token keyword">else</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">#32bits</span>
<span class="token function">endlf</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h2 id="三：链接外部库">三：链接外部库</h2>
<h3 id="语法">语法</h3>
<h4 id="find-package">find_package</h4>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#查找名为OpenCV的包，如果没找到就报错</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV REQUIRED<span class="token punctuation">)</span></code></pre>
<p>该函数的本质就是去（先去标准路径）寻找一个<code>包名-config.cmake</code>文件</p>
<p>在mac，找OpenCV找的可能就是</p>
<pre class="language-none"><code class="language-none">&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;OpenCV&#x2F;OpenCVConfig.cmake</code></pre>
<p>如果你安装的位置不是标准路径，你可以</p>
<ul>
<li>在build时手动指定<code>-xxx_DIR=&quot;aaa/lib/cmake/xxx&quot;</code>
<ul>
<li>只有第一次指定，只要不删掉build目录，就不需要重新指定</li>
</ul>
</li>
<li>可以在CMakeLists.txt<strong>最开头</strong>写<code>set(xx_DIR &quot;aaa/lib/cmake/xxx&quot;)</code>、</li>
<li>可以给<code>xxx_DIR</code>设置环境变量</li>
</ul>
<h3 id="链接静态库">链接静态库</h3>
<ol>
<li>在项目根目录新建lib文件夹</li>
<li>将要链接的静态库（<code>test_library.a</code>）复制到lib文件夹中</li>
<li>找包</li>
</ol>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">find_library</span><span class="token punctuation">(</span>TEXT_LIBRARY test_library lib<span class="token punctuation">)</span></code></pre>
<ol start="4">
<li>链接</li>
</ol>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>testapp LINK_PUBLIC &amp;&#123;TEST_LIBRARY<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>
<h3 id="链接动态库">链接动态库</h3>
<h3 id="常用库">常用库</h3>
<h4 id="Eigen">Eigen</h4>
<p>Eigen是一个纯头文件实现的线性代数库，在mac上可以使用brew安装</p>
<ol>
<li>安装（记住eigen的版本）</li>
</ol>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$brew</span> <span class="token function">install</span> eigen</code></pre>
<ol start="2">
<li>将Eigen链接到系统文件夹（brew一般会自动链接）</li>
</ol>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$brew</span> <span class="token function">link</span> <span class="token parameter variable">--overwrite</span> eigen</code></pre>
<ol start="3">
<li>链接</li>
</ol>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#寻找Eigen包，并附带包版本</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>Eigen3 <span class="token number">3.4</span> REQUIRED CONFIG<span class="token punctuation">)</span>
<span class="token comment">#若找到，则打印信息</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>TARGET <span class="token inserted class-name">Eigen3::Eigen</span><span class="token punctuation">)</span>
    <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"Eigen3 <span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">EIGEN3_VERSION_STRING</span><span class="token punctuation">&#125;</span></span> found in <span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">EIGEN3_INCLUDE_DIR</span><span class="token punctuation">&#125;</span></span>"</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#目标</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>path-info main.cpp<span class="token punctuation">)</span>
<span class="token comment">#链接</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>path-info
        <span class="token namespace">PUBLIC</span>
        <span class="token inserted class-name">Eigen3::Eigen</span>
        <span class="token punctuation">)</span></code></pre>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;Eigen&#x2F;Dense&gt;

int main(int argc, char **argv)&#123;
    int dim &#x3D; std::atoi(argv[1]);
    Eigen::MatrixXd A &#x3D; Eigen::MatrixXd::Random(dim, dim);
    std::cout &lt;&lt; A;
    return 0;
&#125;</code></pre>
<h3 id="brew的用法">brew的用法</h3>
<p>这里提一嘴Homebrew，这是一个mac上非常好用的包管理器，可以非常“优雅”地安装软件</p>
<p>brew会把软件安装在<code>/usr/local/Cellar</code>目录</p>
<ul>
<li>安装目录软链接到<code>/usr/local/opt</code></li>
<li>bin目录执行文件链接到<code>/usr/local/bin</code>中（opt也有可能在根目录）</li>
</ul>
<p>常用命令</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ brew <span class="token parameter variable">-v</span>     <span class="token comment"># 安装完成后可以查看版本</span>
$ brew <span class="token parameter variable">--help</span> <span class="token comment"># 简洁命令帮助</span>
$ <span class="token function">man</span> brew    <span class="token comment"># 完整命令帮助</span>

$ brew search <span class="token function">git</span>    <span class="token comment"># 搜索软件包</span>
$ brew info <span class="token function">git</span>      <span class="token comment"># 查看软件包信息</span>
$ brew home <span class="token function">git</span>      <span class="token comment"># 访问软件包官方站(用浏览器打开)</span>

$ brew <span class="token function">install</span> <span class="token function">git</span>   <span class="token comment"># 安装软件包(这里是示例安装Git版本控制)</span>
$ brew uninstall <span class="token function">git</span> <span class="token comment"># 卸载软件包</span>
$ brew list          <span class="token comment"># 显示已经安装的所有软件包</span>
$ brew list <span class="token parameter variable">--versions</span> <span class="token comment"># 查看你安装过的包列表（包括版本号）</span>

$ brew update        <span class="token comment"># 同步远程最新更新情况，对本机已经安装并有更新的软件用*标明</span>
$ brew outdated      <span class="token comment"># 查看已安装的哪些软件包需要更新</span>
$ brew upgrade <span class="token function">git</span>   <span class="token comment"># 更新单个软件包</span>
$ brew deps php      <span class="token comment"># 显示包依赖</span>

$ brew cleanup       <span class="token comment"># 清理所有已安装软件包的历史老版本</span>
$ brew cleanup <span class="token function">git</span>   <span class="token comment"># 清理单个已安装软件包的历史版本</span>
$ brew cleanup <span class="token parameter variable">-n</span>    <span class="token comment"># 查看哪些软件包要被清除</span></code></pre>
<h2 id="四：项目">四：项目</h2>
<h3 id="模块">模块</h3>
<p>我们可以将一个大的CMake源码分成一个个模块，将这些模块放在<code>cmake</code>文件夹里，后缀为<code>.cmake</code></p>
<p>如下的项目结构</p>
<pre class="language-none"><code class="language-none">.
├── cmake
│     └── colors.cmake
└── CMakeLists.txt</code></pre>
<p><code>cmake/colors.cmake</code>文件内包含了一个色彩输出的定义</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">macro</span><span class="token punctuation">(</span>define_colors<span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">WIN32</span><span class="token punctuation">)</span>
    <span class="token comment"># has no effect on WIN32</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>ColourReset <span class="token string">""</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>ColourBold <span class="token string">""</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>Red <span class="token string">""</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>Green <span class="token string">""</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>Yellow <span class="token string">""</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>Blue <span class="token string">""</span><span class="token punctuation">)</span>
   	...
  <span class="token keyword">else</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">string</span><span class="token punctuation">(</span>ASCII <span class="token number">27</span> Esc<span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>ColourReset <span class="token string">"<span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">Esc</span><span class="token punctuation">&#125;</span></span>[m"</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>ColourBold <span class="token string">"<span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">Esc</span><span class="token punctuation">&#125;</span></span>[1m"</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>Red <span class="token string">"<span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">Esc</span><span class="token punctuation">&#125;</span></span>[31m"</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>Green <span class="token string">"<span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">Esc</span><span class="token punctuation">&#125;</span></span>[32m"</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>Yellow <span class="token string">"<span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">Esc</span><span class="token punctuation">&#125;</span></span>[33m"</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>Blue <span class="token string">"<span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">Esc</span><span class="token punctuation">&#125;</span></span>[34m"</span><span class="token punctuation">)</span>
    ...
  <span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">endmacro</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>在<code>CMakeLists.txt</code>引用</p>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#将/cmake目录添加到路径列表</span>
<span class="token keyword">list</span><span class="token punctuation">(</span>APPEND <span class="token variable">CMAKE_MODULE_PATH</span> <span class="token string">"<span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">&#125;</span></span>/cmake"</span><span class="token punctuation">)</span>
<span class="token comment">#引入colors.cmake</span>
<span class="token keyword">include</span><span class="token punctuation">(</span>colors<span class="token punctuation">)</span>
<span class="token comment">#使用定义</span>
<span class="token function">define_colors</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h3 id="函数">函数</h3>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">function</span><span class="token punctuation">(</span>函数名 参数<span class="token number">1</span> 参数<span class="token number">2</span><span class="token punctuation">)</span>
	...
<span class="token keyword">endfunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h2 id="参考资料">参考资料</h2>
<p><a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/quick-cmake-tutorial.html?keymap=secondary_macos#seealso">Clion CMake</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/CMake-Cookbook/content-preface-preface-chinese.md">CMake菜谱</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1V84y117YU">小鹏老师</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/01/program/CMake%E5%85%A5%E9%97%A8/" data-id="clepy40oy002hglnk10d3fl7f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CMake/" rel="tag">CMake</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-program/Csharpe" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/01/program/Csharpe/" class="article-date">
  <time datetime="2023-02-01T10:01:25.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/01/program/Csharpe/">WPF中的C#</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>WPF中的C#</h1>
<h2 id="一、C-语法">一、C#语法</h2>
<h3 id="委托">委托</h3>
<p>C#的委托类似于C++的函数指针，C#中，将参数<code>a,b</code>委托给了对象adder的Add方法，委托本质上是一种支持<code>()</code>运算符的<strong>对象</strong>。既然是对象，就可以有自己的成员和状态</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">delegate int Fun(int a, int b);

class Adder&#123;
  private int c &#x3D; 0;
  
  public Adder(int c)&#123; this.c &#x3D; c; &#125;
  
  public int Add(int a, int b)&#123; return a+b; &#125;
&#125;
&#x2F;&#x2F;Main()&#123;...
Adder adder &#x3D; new Adder(1);
Fun f &#x3D; adder.Add;
f(2,3);	&#x2F;&#x2F;return 6</code></pre>
<p>C#委托支持匿名委托和lambda表达式</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">delegate int Fun(int a, int b);
&#x2F;&#x2F;Main()&#123;...
Fun f &#x3D; delegate(int a, int b)&#123;
  cout &lt;&lt; a+b &lt;&lt; endl;
&#125;;
Fun f2 &#x3D; (int a, int b)&#x3D;&gt;&#123;
  cout &lt;&lt; a+b &lt;&lt; endl;
&#125;;</code></pre>
<h4 id="C-的函数指针">C++的函数指针</h4>
<p>C/C++的函数指针是一个指向函数入口的指针，不具有对象的性质，只能指向非成员函数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">typedef int(*Func)(int a, int b);

int Add(int a, int b)&#123;
    return a+b;
&#125;

int main(int argc, char **argv)&#123;
    Func func &#x3D; Add;
    std::cout &lt;&lt; func(1,2);	&#x2F;&#x2F;cout 3
    return 0;
&#125;</code></pre>
<p>当然，如果加上类型限制符，还是可以指向成员函数的</p>
<pre class="language-C++" data-language="C++"><code class="language-C++">class Multiple&#123;
public:
    int Mul(int a, int b)&#123;
        return a * b;
    &#125;
&#125;;

typedef int(Multiple::*Fm)(int a, int b);

int main(int argc, char **argv)&#123;
    Multiple multiple;
    Fm f &#x3D; &amp;Multiple::Mul;
    std::cout &lt;&lt; (multiple.*f)(3,4);
    return 0;
&#125;</code></pre>
<p>如果想让C++对委托具有对象的性质，我们可以重载<code>()</code>操作符</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class Adder&#123;
public:
    Adder(int c)&#123; this-&gt;c &#x3D; c; &#125;
    int operator()(int a, int b)&#123;
        return a+b+c;
    &#125;
private:
    int c;
&#125;;

int main(int argc, char **argv)&#123;
    Adder adder(1);
    std::cout &lt;&lt; adder(2, 3);
    return 0;
&#125;</code></pre>
<h4 id="Action泛型委托">Action泛型委托</h4>
<p>C#一种无返回值的泛型委托</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">public delegate void Action&lt;in T&gt;(T obj);</code></pre>
<p>无参数<code>Action xxx = 函数</code></p>
<pre class="language-c#" data-language="c#"><code class="language-c#">public class Name
&#123;
  public string InstanceName&#123; private set; get; &#125;
  public Name(string name)
  &#123;
    InstanceName &#x3D; name;
  &#125;
  public void DisplayName()
  &#123;
    Console.WriteLine($&quot;I&#39;m &#123;InstanceName&#125;&quot;);
  &#125;
&#125;
public static void Main(string[] args)
&#123;
  Name testName &#x3D; new Name(&quot;Tim&quot;);
  Action showName &#x3D; testName.DisplayName;
  showName();
&#125;       </code></pre>
<p>有参数<code>Action&lt;参数类型&gt; xxx = 函数</code></p>
<pre class="language-c#" data-language="c#"><code class="language-c#">public class Name
&#123;
  public string InstanceName&#123; private set; get; &#125;
  public Name(string name)
  &#123;
    InstanceName &#x3D; name;
  &#125;
  public void DisplayName(string str)
  &#123;
    Console.WriteLine($&quot;I&#39;m &#123;InstanceName&#125;, &#123;str&#125;&quot;);
  &#125;
&#125;
public static void Main(string[] args)
&#123;
  Name testName &#x3D; new Name(&quot;Tim&quot;);
  Action&lt;string&gt; showName &#x3D; testName.DisplayName;
  showName(&quot;HHH&quot;);
&#125;    </code></pre>
<h4 id="Func泛型委托">Func泛型委托</h4>
<p>C#一种有返回值的泛型委托</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">public delegate TResult Func&lt;out TResult&gt;();</code></pre>
<pre class="language-c#" data-language="c#"><code class="language-c#">public class Adder
&#123;
  private int c;
  public Adder(int c) &#123; this.c &#x3D; c; &#125;
  public int Add(int a, int b)
  &#123;
    return a + b + c;
  &#125;
&#125;

public static void Main(string[] args)
&#123;
  Adder adder &#x3D; new Adder(1);
  &#x2F;&#x2F;第一个参数是返回值类型，后面的参数是输入参数类型
  Func&lt;int, int, int&gt; method &#x3D; adder.Add;
  &#x2F;&#x2F;使用时不需要写返回值参数
  Console.WriteLine(method(2, 3));
&#125;</code></pre>
<h3 id="事件">事件</h3>
<p><em>这里的事件指CLR事件模型，详细内容见下文</em></p>
<p>委托：把工作委托给了某个函数，可以直接调用</p>
<p>事件：订阅者侦听发行者，发行者可以通过回调函数间接让订阅者干事（而且订阅者具体干什么，要看订阅者心情，发行者无权过问）</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F;事件参数
public class MyEventArgs: EventArgs
&#123;
  public string Args
  &#123;
    private set;
    get;
  &#125;
  public MyEventArgs(string args)
  &#123;
    Args &#x3D; args;
  &#125;
&#125;
&#x2F;&#x2F;事件发行者
public class EventSource
&#123;
  MyEventArgs eventArgs;

  public string Name;

  public EventSource(string args)
  &#123;
    eventArgs &#x3D; new MyEventArgs(args);
  &#125;

  public delegate void handlerEvent(Object sender, MyEventArgs args);

  public event handlerEvent m_handler_event;

  public void Handler()
  &#123;
    m_handler_event?.Invoke(this, eventArgs);
    &#x2F;&#x2F;也可以写成 m_handler_event(this, eventArgs);
  &#125;
&#125;</code></pre>
<pre class="language-C#" data-language="C#"><code class="language-C#">&#x2F;&#x2F;事件订阅者
class MainClass
&#123;
  public static void Main(string[] args)
  &#123;
    EventSource source &#x3D; new EventSource(&quot;Event had been raised!&quot;);
    source.Name &#x3D; &quot;Tim&quot;;
    source.m_handler_event +&#x3D; new EventSource.handlerEvent(writeHello);
    &#x2F;&#x2F;也可以写成 source.m_handler_event +&#x3D; writeHello;
    source.Handler();		&#x2F;&#x2F;输出：Hello Tim, Event had been raised!
  &#125;

  static void writeHello(Object sender, MyEventArgs args)
  &#123;
    EventSource source &#x3D; sender as EventSource;
    Console.WriteLine($&quot;Hello &#123;source.Name&#125;, &#123;args.Args&#125;&quot;);
  &#125;
&#125;</code></pre>
<p>最初我很好奇，我们注册了一个处理函数，<code>source.m_handler_event += writeHello</code>，但是好像没看到怎么传参进去。</p>
<p>其实是因为C#的委托本质是一个支持<code>()</code>运算符的对象，所有处理函数形式上跟委托一致，参数是委托对象的成员变量</p>
<p>一个事件可以注册多个处理函数，于是事件也称为多重委托</p>
<h2 id="二、Binding">二、Binding</h2>
<h3 id="逻辑层与UI层">逻辑层与UI层</h3>
<p>程序 = 数据 + 算法</p>
<p>三层结构：存储、逻辑、展示（UI）</p>
<p>逻辑层可以访问UI层的数据，但展示层不能访问逻辑层，UI层能显示信息，靠的是绑定逻辑层数据</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">this.textBoxName.SetBinding(TextBox.TextProperty, new Binding(&quot;Name&quot;) &#123; Source &#x3D; stu &#x3D; new Student() &#125;);</code></pre>
<p>UI层不仅可以绑定逻辑层数据，也可以绑定UI层数据</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">&#x2F;&#x2F;为 Text属性设置 Binding为 slider1的...
&lt;TextBox x:Name&#x3D;&quot;textBox2&quot; Text&#x3D;&quot;&#123;Binding Value, ElementName&#x3D;slider1&#125;&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;</code></pre>
<p>在XAML中加入</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">xmlns:local&#x3D;&quot;clr-namespace:BindingStudy&quot;</code></pre>
<p>即可在XAML中使用BindingStudy命名空间里C#定义的类</p>
<h3 id="绑定的实现">绑定的实现</h3>
<p>绑定实现的机制：源对象的属性（Property）发生改变时，会Invoke一个事件，Binding负责侦听这个事件</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">class Student : INotifyPropertyChanged
&#123;
    public event PropertyChangedEventHandler PropertyChanged;
    private string name;
    public string Name
    &#123;
        get &#123; return name; &#125;
        set
        &#123;
            name &#x3D; value;
            if(this.PropertyChanged !&#x3D; null)
            &#123;
                this.PropertyChanged.Invoke(this, new PropertyChangedEventArgs(&quot;Name&quot;));
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="Path">Path</h3>
<p>源对象往往会有多个属性，我们可以使用Path，设置绑定那些属性，而且Path支持多级路径（简单说就是一直点下去）和索引器（Indexer）</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">&lt;TextBox x:Name&#x3D;&quot;textBoxName&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
&lt;TextBox x:Name&#x3D;&quot;textBox1&quot; Text&#x3D;&quot;&#123;Binding Path&#x3D;Text.Length, ElementName&#x3D;textBoxName, Mode&#x3D;OneWay&#125;&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;          
&lt;TextBox x:Name&#x3D;&quot;textBox2&quot; Text&#x3D;&quot;&#123;Binding Path&#x3D;Text.[3], ElementName&#x3D;textBoxName, Mode&#x3D;OneWay&#125;&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;</code></pre>
<p><img src="/images/Path.png" alt="Path"></p>
<p>此外Path也支持多级斜线（也是可以一直斜线下去，其中&quot;/&quot;就是自身）</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">this.textBoxName.SetBinding(TextBox.TextProperty, new Binding(&quot;&#x2F;Length&quot;) &#123; Source &#x3D; stringList &#125;);</code></pre>
<p>当源数据本身就是数据（比如int、string类型），我们可以不写Path，或者将Path省略为&quot;.&quot;</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">this.textBlock1.SetBinding(TextBlock.TextProperty, new Binding(&quot;.&quot;) &#123; Source &#x3D; str &#125;);</code></pre>
<h3 id="集合">集合</h3>
<pre class="language-XML" data-language="XML"><code class="language-XML">&lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt;
    &lt;TextBlock Text&#x3D;&quot;Student ID:&quot; FontWeight&#x3D;&quot;Bold&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
    &lt;TextBox x:Name&#x3D;&quot;textBoxId&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
    &lt;TextBlock Text&#x3D;&quot;Student List:&quot; FontWeight&#x3D;&quot;Bold&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
    &lt;ListBox x:Name&#x3D;&quot;listBoxStudents&quot; Height&#x3D;&quot;110&quot; Margin&#x3D;&quot;5&quot;&gt;
        &lt;ListBox.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;StackPanel Orientation&#x3D;&quot;Horizontal&quot;&gt;
                    &lt;TextBlock Text&#x3D;&quot;&#123;Binding Path&#x3D;Id&#125;&quot; Width&#x3D;&quot;30&quot;&#x2F;&gt;
                    &lt;TextBlock Text&#x3D;&quot;&#123;Binding Path&#x3D;Name&#125;&quot; Width&#x3D;&quot;60&quot;&#x2F;&gt;
                    &lt;TextBlock Text&#x3D;&quot;&#123;Binding Path&#x3D;Age&#125;&quot; Width&#x3D;&quot;30&quot;&#x2F;&gt;
                &lt;&#x2F;StackPanel&gt;
            &lt;&#x2F;DataTemplate&gt;
        &lt;&#x2F;ListBox.ItemTemplate&gt;
    &lt;&#x2F;ListBox&gt;

&lt;&#x2F;StackPanel&gt;
public MainWindow()
&#123;
    InitializeComponent();
    List&lt;Student&gt; stuList &#x3D; new List&lt;Student&gt;()
    &#123;
        new Student()&#123;Id&#x3D;0, Name&#x3D;&quot;赵&quot;, Age&#x3D;21&#125;,
        new Student()&#123;Id&#x3D;1, Name&#x3D;&quot;钱&quot;, Age&#x3D;22&#125;,
        new Student()&#123;Id&#x3D;2, Name&#x3D;&quot;孙&quot;, Age&#x3D;11&#125;,
        new Student()&#123;Id&#x3D;3, Name&#x3D;&quot;李&quot;, Age&#x3D;50&#125;,
        new Student()&#123;Id&#x3D;4, Name&#x3D;&quot;周&quot;, Age&#x3D;44&#125;,
    &#125;;
    this.listBoxStudents.ItemsSource &#x3D; stuList;
    &#x2F;&#x2F;this.listBoxStudents.DisplayMemberPath &#x3D; &quot;Name&quot;;

    Binding binding &#x3D; new Binding(&quot;SelectedItem.Id&quot;) &#123; Source &#x3D; this.listBoxStudents &#125;;
    this.textBoxId.SetBinding(TextBox.TextProperty, binding);
&#125;</code></pre>
<p><img src="/images/%E9%9B%86%E5%90%88.png" alt="集合"></p>
<h3 id="XML">XML</h3>
<p>SOAP（Simple Object Access Protocel，简单对象访问协议）：一种基于XML的数据交换协议</p>
<pre class="language-XML" data-language="XML"><code class="language-XML">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot; ?&gt;
&lt;StudentList&gt;
        &lt;Student Id&#x3D;&quot;0&quot;&gt;
                &lt;Name&gt;赵&lt;&#x2F;Name&gt;
        &lt;&#x2F;Student&gt;
        &lt;Student Id&#x3D;&quot;1&quot;&gt;
                &lt;Name&gt;钱&lt;&#x2F;Name&gt;
        &lt;&#x2F;Student&gt;
        &lt;Student Id&#x3D;&quot;2&quot;&gt;
                &lt;Name&gt;孙&lt;&#x2F;Name&gt;
        &lt;&#x2F;Student&gt;
        &lt;Student Id&#x3D;&quot;3&quot;&gt;
                &lt;Name&gt;李&lt;&#x2F;Name&gt;
        &lt;&#x2F;Student&gt;
        &lt;Student Id&#x3D;&quot;4&quot;&gt;
                &lt;Name&gt;周&lt;&#x2F;Name&gt;
        &lt;&#x2F;Student&gt;
&lt;&#x2F;StudentList&gt;
&lt;ListView x:Name&#x3D;&quot;listViewStudents&quot; Height&#x3D;&quot;130&quot; Margin&#x3D;&quot;5&quot;&gt;
    &lt;ListView.View&gt;
        &lt;GridView&gt;
            &lt;GridViewColumn Header&#x3D;&quot;Id&quot; Width&#x3D;&quot;80&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding XPath&#x3D;@Id&#125;&quot;&#x2F;&gt;
            &lt;GridViewColumn Header&#x3D;&quot;Name&quot; Width&#x3D;&quot;120&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding XPath&#x3D;Name&#125;&quot;&#x2F;&gt;
        &lt;&#x2F;GridView&gt;
    &lt;&#x2F;ListView.View&gt;
&lt;&#x2F;ListView&gt;
&lt;Button Content&#x3D;&quot;Load Click&quot; Click&#x3D;&quot;Button_Click&quot; Height&#x3D;&quot;25&quot; Margin&#x3D;&quot;5,0&quot;&#x2F;&gt;
 private void Button_Click(object sender, RoutedEventArgs e)
&#123;
    XmlDataProvider xdp &#x3D; new XmlDataProvider();
    xdp.Source &#x3D; new Uri(@&quot;D:\code\BindingStudy\BindingStudy\RawData.xml&quot;);
    xdp.XPath &#x3D; @&quot;&#x2F;StudentList&#x2F;Student&quot;;

    this.listViewStudents.DataContext &#x3D; xdp;
    this.listViewStudents.SetBinding(ListView.ItemsSourceProperty, new Binding());
&#125;</code></pre>
<p><img src="/images/xml.png" alt="xml"></p>
<h3 id="LINQ">LINQ</h3>
<p>LINQ（Language-Integrated Query，语言集成查询）：一种对象查询机制，查询的结果为IEnumerable<T>类型</p>
<pre class="language-XML" data-language="XML"><code class="language-XML">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot; ?&gt;
&lt;StudentList&gt;
        &lt;Class&gt;
                &lt;Student Id&#x3D;&quot;0&quot; Name&#x3D;&quot;Tim&quot; Age&#x3D;&quot;29&quot;&#x2F;&gt;
                &lt;Student Id&#x3D;&quot;1&quot; Name&#x3D;&quot;Tom&quot; Age&#x3D;&quot;20&quot;&#x2F;&gt;
                &lt;Student Id&#x3D;&quot;2&quot; Name&#x3D;&quot;Mess&quot; Age&#x3D;&quot;9&quot;&#x2F;&gt;
        &lt;&#x2F;Class&gt;
        &lt;Class&gt;
                &lt;Student Id&#x3D;&quot;3&quot; Name&#x3D;&quot;Tony&quot; Age&#x3D;&quot;2&quot;&#x2F;&gt;
                &lt;Student Id&#x3D;&quot;4&quot; Name&#x3D;&quot;Viv&quot; Age&#x3D;&quot;23&quot;&#x2F;&gt;
                &lt;Student Id&#x3D;&quot;5&quot; Name&#x3D;&quot;Oio&quot; Age&#x3D;&quot;88&quot;&#x2F;&gt;
        &lt;&#x2F;Class&gt;
&lt;&#x2F;StudentList&gt;
&lt;ListView x:Name&#x3D;&quot;listViewStudents&quot; Height&#x3D;&quot;130&quot; Margin&#x3D;&quot;5&quot;&gt;
    &lt;ListView.View&gt;
        &lt;GridView&gt;
            &lt;GridViewColumn Header&#x3D;&quot;Id&quot; Width&#x3D;&quot;80&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding Id&#125;&quot;&#x2F;&gt;
            &lt;GridViewColumn Header&#x3D;&quot;Name&quot; Width&#x3D;&quot;120&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding Name&#125;&quot;&#x2F;&gt;
            &lt;GridViewColumn Header&#x3D;&quot;Age&quot; Width&#x3D;&quot;80&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding Age&#125;&quot;&#x2F;&gt;
        &lt;&#x2F;GridView&gt;
    &lt;&#x2F;ListView.View&gt;
&lt;&#x2F;ListView&gt;
private void Button_Click(object sender, RoutedEventArgs e)
&#123;
    XDocument doc &#x3D; XDocument.Load(@&quot;D:\code\BindingStudy\BindingStudy\RawData.xml&quot;);
    this.listViewStudents.ItemsSource &#x3D;
        from element in doc.Descendants(&quot;Student&quot;)
        where element.Attribute(&quot;Name&quot;).Value.StartsWith(&quot;T&quot;)
        select new Student()
        &#123;
            Id &#x3D; int.Parse(element.Attribute(&quot;Id&quot;).Value),
            Name &#x3D; element.Attribute(&quot;Name&quot;).Value,
            Age &#x3D; int.Parse(element.Attribute(&quot;Age&quot;).Value)
        &#125;;
    
&#125;
class Student
&#123;
    public int Id &#123; get; set; &#125;
    public string Name &#123; get; set; &#125;
    public int Age &#123; get; set; &#125;
&#125;</code></pre>
<p><img src="/images/LINQ.png" alt="LINQ"></p>
<h3 id="校验">校验</h3>
<p>“你永远不能相信来自前端的数据”</p>
<p>我们认为Source的数据一定是正确的，但Target的数据是有可能出现问题的</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">public partial class MainWindow : Window
&#123;
    public MainWindow()
    &#123;
        InitializeComponent();

        Binding binding &#x3D; new Binding(&quot;Value&quot;) &#123; Source &#x3D; this.slider1 &#125;;
        binding.UpdateSourceTrigger &#x3D; UpdateSourceTrigger.PropertyChanged;    &#x2F;&#x2F;当源数据改变时进行校验
        RangeValidationRule rvr &#x3D; new RangeValidationRule();
        rvr.ValidatesOnTargetUpdated &#x3D; true;    &#x2F;&#x2F;当Target数据改变时进行校验
        binding.ValidationRules.Add(rvr);
        binding.NotifyOnValidationError &#x3D; true;
        this.textBox1.SetBinding(TextBox.TextProperty, binding);
        this.textBox1.AddHandler(Validation.ErrorEvent, new RoutedEventHandler(this.ValidationError));
    &#125;

    &#x2F;&#x2F;若校验失败，将失败信息添加到 ToolTip上
    void ValidationError(object sender, RoutedEventArgs e)
    &#123;
        if(Validation.GetErrors(this.textBox1).Count &gt; 0)
        &#123;
            this.textBox1.ToolTip &#x3D; Validation.GetErrors(this.textBox1)[0].ErrorContent.ToString();
        &#125;
        else
        &#123;
            this.textBox1.ToolTip &#x3D; null;
        &#125;
    &#125;
&#125;
&lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt;
    &lt;TextBox x:Name&#x3D;&quot;textBox1&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
    &lt;Slider x:Name&#x3D;&quot;slider1&quot; Minimum&#x3D;&quot;-10&quot; Maximum&#x3D;&quot;110&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
&lt;&#x2F;StackPanel&gt;
class RangeValidationRule : ValidationRule
&#123;
    &#x2F;&#x2F;对数据范围进行校验，仅当在[0,100]时校验通过，校验失败时返回信息
    public override ValidationResult Validate(object value, CultureInfo cultureInfo)
    &#123;
        double d &#x3D; 0;
        if(double.TryParse(value.ToString(), out d))
        &#123;
            if(d &gt;&#x3D; 0 &amp;&amp; d &lt;&#x3D; 100)
            &#123;
                return new ValidationResult(true, null);
            &#125;
        &#125;
        return new ValidationResult(false, &quot;Validation Failed!!!&quot;);
    &#125;
&#125;</code></pre>
<p><img src="/images/%E6%A0%A1%E9%AA%8C.png" alt="校验"></p>
<h3 id="数据转换">数据转换</h3>
<p>Slider的Value是double类型，TextBox的Text是string类型，但是Binding后数据往来自如，是因为数据转化机制</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">class ClassAToClassBConverter : IValueConverter
&#123;
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    &#123;
        ...
    &#125;

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    &#123;
        ...
    &#125;
&#125;
&lt;Window x:Class&#x3D;&quot;BindingStudy.MainWindow&quot;
        ...
    &lt;Window.Resources&gt;
        &lt;local:ClassAToClassBConverter x:Key&#x3D;&quot;atb&quot;&#x2F;&gt;
    &lt;&#x2F;Window.Resources&gt;
    &lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt;
        ...
        &lt;&#x2F;images Width&#x3D;&quot;20&quot; Height&#x3D;&quot;20&quot; Source&#x3D;&quot;&#123;Binding Path&#x3D;A, Converter&#x3D;&#123;StaticResource atb&#125;&#125;&quot;&#x2F;&gt;
    &lt;&#x2F;StackPanel&gt;
&lt;&#x2F;Window&gt;</code></pre>
<h2 id="三、属性">三、属性</h2>
<h3 id="英语中的属性">英语中的属性</h3>
<p>Property是物体自带的属性</p>
<p>Attribute是物体的描述属性</p>
<p>张三是中国人，身上有一百块钱。中国人是张三的Attribute, 100块钱是张三的property</p>
<h3 id="C-中的属性">C#中的属性</h3>
<p>将字段设为private，使用一对非private的方法来包装它，以实现<strong>高内聚</strong></p>
<p>C#中提供语法糖，将Get和Set合并为了属性（Property），这种属性也被称为CLR（Common Language Runtime）属性</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">class Student
&#123;
    private string name;
    public string Name &#123; get; set; &#125;
&#125;</code></pre>
<p>此外反编译后发现，属性的本质是两个函数，并不会增加字段数量（不额外占内存）</p>
<h3 id="依赖属性">依赖属性</h3>
<p>（WPF属性加强版）</p>
<p>依赖属性（Dependency Property）可以自己没有值，通过Binding从数据源获得值</p>
<p>拥有依赖属性的对象被称为依赖对象</p>
<p>传统开发中，对象所占用的内存在进行实例化时就确定（分配）了，而依赖属性可以允许对象不分配部分空间</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">class Student : DependencyObject
&#123;
    &#x2F;&#x2F;依赖对象的 CLR封装
    public string Name
    &#123;
        get &#123; return (string)GetValue(NameProperty); &#125;
        set &#123; SetValue(NameProperty, value); &#125;
    &#125;
    &#x2F;&#x2F;依赖对象
    public static readonly DependencyProperty NameProperty &#x3D; DependencyProperty.Register(&quot;Name&quot;, typeof(string), typeof(Student));  
    &#x2F;&#x2F;Binding封装
    public BindingExpressionBase SetBinding(DependencyProperty dp, BindingBase binding)
    &#123;
        return BindingOperations.SetBinding(this, dp, binding);
    &#125;
&#125;</code></pre>
<ul>
<li>“Name”：指明使用哪一个 CLR属性作为这个依赖属性的包装器 (Wrapper)</li>
<li>typeof(string)：指明此依赖属性用来储存什么类型的值</li>
<li>typeof(Student))：指明此依赖属性要注册关联到谁身上</li>
</ul>
<pre class="language-XML" data-language="XML"><code class="language-XML">&lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt;
    &lt;TextBox x:Name&#x3D;&quot;textBox1&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
    &lt;TextBox x:Name&#x3D;&quot;textBox2&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
&lt;&#x2F;StackPanel&gt;
public partial class MainWindow : Window
&#123;
    Student stu;
    public MainWindow()
    &#123;
        InitializeComponent();

        stu &#x3D; new Student();
        stu.SetBinding(Student.NameProperty, new Binding(&quot;Text&quot;) &#123; Source &#x3D; textBox1 &#125;);
        textBox2.SetBinding(TextBox.TextProperty, new Binding(&quot;Name&quot;) &#123; Source &#x3D; stu &#125;);
    &#125;
&#125;</code></pre>
<p>我们还发现，依赖对象并没有实现INotifyPropertyChanged接口，但是当期值发生改变时，与之相关的Binding对象依然可以得到通知，于是依赖对象是天生的合格源数据</p>
<p>在VS中，输入propdp并按两次tab，就能得到一个依赖属性模板</p>
<h4 id="依赖属性的注册">依赖属性的注册</h4>
<p>前文我们获得依赖对象的实例时，是通过<code>DependencyProperty.Register</code>注册得到：</p>
<ol>
<li>创建DependencyProperty实例，并使用其CLR属性名的哈希异或宿主类型的哈希，得到key（通过其他算法，保证唯一）</li>
<li>将key和实例存储到一张全局的HashTable上</li>
</ol>
<pre class="language-C#" data-language="C#"><code class="language-C#">GlobalIndex &#x3D; CLR属性名的HaseCode XOR 宿主类型HashCode</code></pre>
<p>于是运行时只要知道CLR属性名和宿主，就能找到依赖对象实例</p>
<h4 id="依赖属性的读写">依赖属性的读写</h4>
<p>依赖属性对象的作用是检索真正的属性值，而非存储属性值</p>
<p>每个DependencyObject实例都自带一个数组，当某个依赖属性的值要被读取时，算法会在这个数组中检索。而用于检索的键值，实际上就是依赖属性的GlobalIndex</p>
<p>也就是说，这个被static readonly修饰的属性，它的作用是一个“标记”，当你需要找某个东西时，就来这里拼一个id，用id查数组</p>
<h3 id="附加属性">附加属性</h3>
<p>附加属性（Attached Properties）：一个属性本不属于某个对象，但由于某种需求后来附加上。换句话说，将对象放入一个特定环境后，才会具有出来的属性</p>
<p>举个例子，比如Human这个类，它可以有很多很多种属性，现在我们想在里面加入一个新的需求，如果我们直接改动这个类，过于繁琐。而如果提前留好空，那么有时候又会空间浪费</p>
<p>附加属性的作用就是让宿主和属性解耦，让宿主的设计更为灵活</p>
<h2 id="四、事件">四、事件</h2>
<h3 id="消息">消息</h3>
<p>事件的前身是消息（Message），Windows系统就是一个消息驱动的操作系统，后来微软为了降低开发难度，将消息系统封装为了事件模型</p>
<h3 id="CLR事件模型">CLR事件模型</h3>
<p>CLR事件模型由三部分组成</p>
<ul>
<li>事件的拥有者：即消息的发送者</li>
<li>事件的响应者：即消息的接收者，它可以使用事件处理器（Event Handler）对事件做相应</li>
<li>事件的订阅关系：事件的拥有者可以随时激发事件，但只有关注（订阅）了这个事件的响应者会对此产生反应</li>
</ul>
<p>事件本质上就是一个使用event关键字修饰的委托（Delegate）类型成员变量，事件处理器是一个函数</p>
<p>A订阅了B，实际上就是让B.Event和A.EventHandler关联起来</p>
<p>事件激发就是B.Event被调用</p>
<h4 id="举例">举例</h4>
<p>Windows Form按按钮</p>
<table>
<thead>
<tr>
<th>事件的拥有者</th>
<th>button</th>
</tr>
</thead>
<tbody>
<tr>
<td>事件</td>
<td>button.Click</td>
</tr>
<tr>
<td>事件的响应者</td>
<td>窗体</td>
</tr>
<tr>
<td>事件处理器</td>
<td>this.button_Click()</td>
</tr>
<tr>
<td>订阅关系</td>
<td>this.button.Click += new System.EventHandler(this.button_Click)</td>
</tr>
</tbody>
</table>
<h3 id="路由事件">路由事件</h3>
<p>（WPF事件加强版）</p>
<p>路由事件没有显示订阅关系</p>
<ul>
<li>事件拥有者只负责激发事件，至于谁会倾听，他并不知道</li>
<li>事件响应者装有事件倾听器，若有事件传递于此，可以决定事件是否可以继续传递
<ul>
<li>如果事件不归他管，那就踢给下一个人，继续传播</li>
<li>若事件归他管，那就进行处理，并判断是否还需要传给下一个人</li>
</ul>
</li>
</ul>
<pre class="language-C#" data-language="C#"><code class="language-C#">public abstract class ButtonBase : ContentControl, ICommandSource
&#123;
    &#x2F;&#x2F;声明并注册路由事件
    public static readonly RoutedEvent ClickEvent &#x3D; EventManager.RegisterRoutedEvent(&quot;Click&quot;, 
        RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(ButtonBase));

    &#x2F;&#x2F;为路由事件添加 CLR事件包装器
    public event RoutedEventHandler Click
    &#123;
        add &#123; this.AddHandler(ClickEvent, value); &#125;
        remove &#123; this.RemoveHandler(ClickEvent, value); &#125;
    &#125;
    
    &#x2F;&#x2F;激活路由事件的方法
    protected virtual void OnClick()
    &#123;
        RoutedEventArgs newEvent &#x3D; new RoutedEventArgs(ButtonBase.ClickEvent, this);
        this.RaiseEvent(newEvent);
    &#125;
&#125;</code></pre>
<p>WPF路由事件有三种策略</p>
<ul>
<li>Bubble：冒泡式，激发者向其上级一层一层路由，直到到根，路径是确定且唯一</li>
<li>Tunnel：隧道式，激发者向其下级一层一层路由，路径有很多，但朝向响应者移动，就像形成一个隧道</li>
<li>Direct：直达式，类似CLR事件，直接向响应者发送事件</li>
</ul>
<h2 id="五、命令">五、命令</h2>
<p>事件不具有约束力，事件接收者使用自己的行为响应事件</p>
<p>命令具有约束力，当命令到达某个组件时，会主动调用组件的某个方法</p>
<h3 id="命令系统">命令系统</h3>
<ul>
<li>命令（Command）：实现ICommand接口</li>
<li>命令源（Command Source）：实现ICommandSource接口</li>
<li>命令目标（Command Target）：实现IInputElement接口</li>
<li>命令关联（Command Binding）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/01/program/Csharpe/" data-id="clepy40oz002jglnk4l6le43l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dcc/maya插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/dcc/maya%E6%8F%92%E4%BB%B6/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/dcc/">dcc</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/dcc/maya%E6%8F%92%E4%BB%B6/">Maya插件开发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Maya</h1>
<p>maya，老东西，行业标准，真难用（不是）</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76957745">腾讯巨神级TA</a>、<a target="_blank" rel="noopener" href="http://www.zt-page.com/?p=109">碧血红天的blog</a>、<a target="_blank" rel="noopener" href="https://www.cnblogs.com/3lina/p/11672415.html">Pycharm环境搭建</a></p>
<h3 id="创建一个python工具">创建一个python工具</h3>
<p>Python插件和Unity Editor那种工具不太一样，这个其实本质就是一个嵌入式的脚本，通过命令调用maya指令，就算有UI也是现绘制的，也不需要什么项目结构，就一个py文件</p>
<h4 id="创建一个python文件">创建一个python文件</h4>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> maya<span class="token punctuation">.</span>cmds <span class="token keyword">as</span> cmds


<span class="token keyword">def</span> <span class="token function">createWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> cmds<span class="token punctuation">.</span>window<span class="token punctuation">(</span><span class="token string">'mywindow'</span><span class="token punctuation">,</span> exists<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        cmds<span class="token punctuation">.</span>deleteUI<span class="token punctuation">(</span><span class="token string">'mywindow'</span><span class="token punctuation">)</span>
    windowvar <span class="token operator">=</span> cmds<span class="token punctuation">.</span>window<span class="token punctuation">(</span><span class="token string">'mywindow'</span><span class="token punctuation">)</span>
    cmds<span class="token punctuation">.</span>columnLayout<span class="token punctuation">(</span><span class="token punctuation">)</span>
    checkButton <span class="token operator">=</span> cmds<span class="token punctuation">.</span>button<span class="token punctuation">(</span>l<span class="token operator">=</span><span class="token string">'Test'</span><span class="token punctuation">,</span> command<span class="token operator">=</span><span class="token string">'testFunc()'</span><span class="token punctuation">)</span>
    cmds<span class="token punctuation">.</span>showWindow<span class="token punctuation">(</span><span class="token string">'mywindow'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">testFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span> <span class="token string">"Hello"</span>

createWindow<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h4 id="添加到工具栏">添加到工具栏</h4>
<p>当你的代码完成后，可以将其固定到工具架上</p>
<p><img src="/images/maya%E4%BF%9D%E5%AD%98%E5%B7%A5%E5%85%B7%E6%A0%8F.png" alt="maya保存工具栏"></p>
<h4 id="怎么写">怎么写</h4>
<p>这应该是很多人写maya插件最大的疑惑，我的建议是先学美术，开着脚本编辑器，按照美术流程走一遍，你会发现你每一次操作，脚本编辑器都会输出一个指令，这个应该能让你深受启发</p>
<p><img src="/images/maya%E8%84%9A%E6%9C%AC.png" alt="maya脚本"></p>
<p>如果你的脚本编辑器没有显示，那么在脚本编辑器中设置<strong>显示二者</strong></p>
<p><img src="/images/%E6%98%BE%E7%A4%BA%E4%BA%8C%E8%80%85.png" alt="显示二者"></p>
<h3 id="常用API">常用API</h3>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> maya<span class="token punctuation">.</span>cmds <span class="token keyword">as</span> cmds	<span class="token comment">#这是一个将MEL指令用python封装的库，适合面向过程编程</span>
<span class="token keyword">import</span> maya<span class="token punctuation">.</span>OpenMaya <span class="token keyword">as</span> om	<span class="token comment">#拥有cmd没有的功能，运行效率更高</span></code></pre>
<ul>
<li>
<p>删除：<code>cmds.delete(p)</code></p>
</li>
<li>
<p>选中：<code>p = cmds.ls('Name')</code></p>
</li>
<li>
<p>创建</p>
<ul>
<li>Cube：<code>pCube = cmds.polyCube(w=10, h=10, d=10, name='myCube')</code></li>
</ul>
</li>
<li>
<p>移动（到指定位置）</p>
<ul>
<li>平移：<code>cmds.move(0, 10, 0, pCube)</code></li>
<li>缩放：<code>cmds.scale(2, 2, 2, pCube)</code></li>
<li>旋转：<code>cmds.rotate(45, 45, 0, pCube)</code></li>
</ul>
</li>
<li>
<p>选择（得到的是对象数组）</p>
<ul>
<li>当前选择：<code>list = cmds.ls(selection=True)</code></li>
</ul>
</li>
<li>
<p>读参数</p>
<ul>
<li>位置：<code>cmds.getAttr('%s.translate ' % (p))</code></li>
<li>位置（某一维）：<code>y = cmds.getAttr('%s.translateY ' % (p))</code></li>
</ul>
</li>
<li>
<p>写参数</p>
<ul>
<li>位置（某一维）：<code>cmds.setAttr('%s.translateX' % (p), 10)</code></li>
</ul>
</li>
</ul>
<p>想知道maya物体的参数，可以通过表达式编辑器查看（窗口-动画编辑器-表达式编辑器）</p>
<p><img src="/images/maya%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="maya表达式编辑器"></p>
<ul>
<li>得到顶点数据</li>
</ul>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">printVertexPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    selectObjectList <span class="token operator">=</span> cmds<span class="token punctuation">.</span>ls<span class="token punctuation">(</span>selection<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    VertexArray <span class="token operator">=</span> cmds<span class="token punctuation">.</span>ls<span class="token punctuation">(</span><span class="token string">'&#123;&#125;.vtx[:]'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>selectObjectList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fl <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> v <span class="token keyword">in</span> VertexArray<span class="token punctuation">:</span>
        <span class="token keyword">print</span> cmds<span class="token punctuation">.</span>xform<span class="token punctuation">(</span>v<span class="token punctuation">,</span> query <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span> translation <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span> worldSpace <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span></code></pre>
<h3 id="工具实例">工具实例</h3>
<h4 id="平滑法线">平滑法线</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/Reuben-Sun/Note-of-Graphics/blob/main/Code/MayaPython/SmoothNormal.py">平滑法线</a></p>
<h4 id="模型展2UV">模型展2UV</h4>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#创建一个名称为sph的多边形</span>
<span class="token keyword">def</span> <span class="token function">createFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   cmds<span class="token punctuation">.</span>polySphere<span class="token punctuation">(</span>n<span class="token operator">=</span><span class="token string">'sph'</span><span class="token punctuation">)</span>

<span class="token comment">#删除除了map1以外所有的uvmap</span>
<span class="token keyword">def</span> <span class="token function">deleteUVs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    au <span class="token operator">=</span> cmds<span class="token punctuation">.</span>polyUVSet<span class="token punctuation">(</span>query<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> allUVSets<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>au<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        cmds<span class="token punctuation">.</span>polyUVSet<span class="token punctuation">(</span>delete<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> uvSet<span class="token operator">=</span>au<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">#自动展选中物体的2UV，并命名为map2</span>
<span class="token keyword">def</span> <span class="token function">pickUV2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">list</span> <span class="token operator">=</span> cmds<span class="token punctuation">.</span>ls<span class="token punctuation">(</span>dag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> selection<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    au <span class="token operator">=</span> cmds<span class="token punctuation">.</span>polyUVSet<span class="token punctuation">(</span>query<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> allUVSets<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>au<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        cmds<span class="token punctuation">.</span>polyAutoProjection<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'.f[*]'</span><span class="token punctuation">,</span> cm <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> uvs<span class="token operator">=</span> <span class="token string">'map2'</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span> <span class="token string">"map2 has been exited"</span></code></pre>
<h4 id="动画clip">动画clip</h4>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#输出选中的动画片段的开始帧和结束帧</span>
<span class="token keyword">def</span> <span class="token function">printClip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token builtin">list</span> <span class="token operator">=</span> cmds<span class="token punctuation">.</span>ls<span class="token punctuation">(</span>selection<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">:</span>
        start <span class="token operator">=</span> cmds<span class="token punctuation">.</span>getAttr<span class="token punctuation">(</span><span class="token string">'%s.clipStart '</span> <span class="token operator">%</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        end <span class="token operator">=</span> cmds<span class="token punctuation">.</span>getAttr<span class="token punctuation">(</span><span class="token string">'%s.clipStart '</span> <span class="token operator">%</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> cmds<span class="token punctuation">.</span>getAttr<span class="token punctuation">(</span><span class="token string">'%s.clipDuration '</span> <span class="token operator">%</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span> start
        <span class="token keyword">print</span> end</code></pre>
<h4 id="打开文件">打开文件</h4>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">openFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   path <span class="token operator">=</span> <span class="token string">'C:/Users/Admin/Desktop/多边形.fbx'</span>
   cmds<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> i<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></code></pre>
<h4 id="开关UV编辑器">开关UV编辑器</h4>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">openUVPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token keyword">if</span> cmds<span class="token punctuation">.</span>window<span class="token punctuation">(</span><span class="token string">'polyTexturePlacementPanel1Window'</span><span class="token punctuation">,</span> ex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        cmds<span class="token punctuation">.</span>deleteUI<span class="token punctuation">(</span><span class="token string">'polyTexturePlacementPanel1Window'</span><span class="token punctuation">)</span>
        mel<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'toggleUVToolkit;'</span><span class="token punctuation">)</span>
   <span class="token keyword">else</span><span class="token punctuation">:</span>
        mel<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'texturePanelShow;'</span><span class="token punctuation">)</span></code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/dcc/maya%E6%8F%92%E4%BB%B6/" data-id="clepy40nw0003glnk2i8y5k6d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-engine/GC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/engine/GC/" class="article-date">
  <time datetime="2023-01-31T10:01:25.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/engine/">engine</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/engine/GC/">垃圾回收</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>垃圾回收</h1>
<h3 id="前言">前言</h3>
<p>《垃圾回收的算法与实现》读书笔记，其中的代码大多为伪代码</p>
<h3 id="一：概念">一：概念</h3>
<p>GC，Garbage Collection，垃圾回收</p>
<p>功能</p>
<ul>
<li>找到内存中的垃圾</li>
<li>回收垃圾</li>
</ul>
<h4 id="为什么需要GC">为什么需要GC</h4>
<p>如果没有GC，程序员需要手动进行内存管理，开发麻烦，容易引发内存泄漏、野指针，而且因此导致的BUG很难被定位，修复麻烦</p>
<p>如果有GC，就可以避免这些问题</p>
<h4 id="GC的种类">GC的种类</h4>
<ul>
<li>保守式GC：不能识别指针和非指针时，一律视为非指针</li>
<li>准确式GC</li>
</ul>
<h4 id="GC的算法">GC的算法</h4>
<ul>
<li>标记清除法：标记活动对象，其他的都回收</li>
<li>引用计数法：回收引用值为0的对象</li>
<li>GC复制法：复制活动对象，其他的都回收</li>
</ul>
<h4 id="GC的选取">GC的选取</h4>
<ul>
<li>最大暂停时间短：游戏</li>
<li>整体处理时间短：音频编码</li>
</ul>
<h4 id="对象">对象</h4>
<p>这里的对象并不是OOP里的Object，而是<strong>被应用程序使用的数据的集合</strong>，对象由<strong>头</strong>和<strong>域</strong>构成</p>
<ul>
<li>
<p>头（header）：包含对象的大小和种类</p>
</li>
<li>
<p>域（field）：参考OOP里的成员</p>
</li>
</ul>
<p>对象分为活动对象和非活动对象，GC会保留活动对象，销毁非活动对象</p>
<h4 id="mutator">mutator</h4>
<p>可以简单理解为应用程序，在程序运行过程中，会分配/调用/改变对象（只能操作活动对象），伴随着mutator运行，会产生垃圾</p>
<h4 id="GC算法的评估标准">GC算法的评估标准</h4>
<ul>
<li>吞吐量（throughput）：单位时间的处理能力</li>
<li>最大暂停时间（在进行GC时，mutator会被暂停）</li>
<li>堆使用效率</li>
<li>访问局部性</li>
</ul>
<h3 id="二：标记清除法">二：标记清除法</h3>
<p><em>学这一节之前想想操作系统里文件系统</em></p>
<p>该算法分为两步</p>
<ol>
<li>标记阶段：将所有活动对象做上标记</li>
<li>清除阶段：将所有没被标记的对象回收</li>
</ol>
<h4 id="标记阶段">标记阶段</h4>
<ol>
<li>通过根，找到直接引用的对象，标记</li>
<li>递归标记所有能访问到的对象（常用深搜，因为内存使用量更少）</li>
</ol>
<pre class="language-c++" data-language="c++"><code class="language-c++">void mark(obj)&#123;
	if(!obj.mark) 
        obj.mark &#x3D; true;
	for(child: obj.children) 
        mark(*child);
&#125;</code></pre>
<h4 id="清除阶段">清除阶段</h4>
<p>遍历堆，回收所有没有被标记的对象，并将其放入空闲链表，以备分配</p>
<h4 id="分配策略">分配策略</h4>
<p>在创建新对象<code>obj</code>时，遍历空闲链表，寻找合适的块，这里使用First-fit算法（因为快）</p>
<ul>
<li>First-fit：找到第一个能放下<code>obj</code>的块</li>
<li>Best-fit：找到最小的能放下<code>obj</code>的块</li>
<li>Worst-fit：找到最大的能放下<code>obj</code>的块</li>
</ul>
<h4 id="合并策略">合并策略</h4>
<p>分配和回收会导致大量小的分块，于是需要合并，在这里直接遍历堆，将连续的空闲块合并</p>
<h4 id="评价">评价</h4>
<p>优点</p>
<ul>
<li>实现简单</li>
<li>与保守式GC兼容（因为对象不会被移动）</li>
</ul>
<p>缺点</p>
<ul>
<li>碎片化，导致空间浪费，访问性能降低</li>
<li>不支持<strong>写时复制</strong>（比如UNIX中的<code>fork()</code>）</li>
</ul>
<h4 id="优化方案">优化方案</h4>
<h5 id="分级空闲链表">分级空闲链表</h5>
<p>使用多个空闲链表，分别只连接不同大小的分块，分配时先找所对应的区间，可以提高性能</p>
<h5 id="BiBOP（Big-Bag-Of-Pages）">BiBOP（Big Bag Of Pages）</h5>
<p>将大小相近的对象整理成固定大小的块进行管理</p>
<ul>
<li>碎片化的原因之一是杂乱散布的大小各异的对象，如果将堆固定分割，就可以减缓碎片化</li>
</ul>
<h5 id="位图标记">位图标记</h5>
<p>不直接堆对象进行标记，而是记录对象的标志位，存储在一个表格中</p>
<ul>
<li>与写时复制技术兼容（因为不会修改对象本身，可以复用）</li>
<li>清除标志位更高效（只需要把表中要清除的对象的标志位改成一个特殊值）</li>
</ul>
<h5 id="延迟标记清除法">延迟标记清除法</h5>
<ul>
<li>分配时，先调用清除，如果能清出足够的空间来分配，则直接分配，否则进行普通的标记操作</li>
<li>清除时，同样是First-fit遍历堆，但遍历的起点是上次开始的地点的右侧</li>
<li>延迟的内核是不主动清除，而是等到要分配时再清除</li>
</ul>
<h3 id="三：引用计数法">三：引用计数法</h3>
<p><em>学这一节前，想想智能指针</em></p>
<p>引用计数法中，对象会记录自己被引用次数，主要分为两个阶段</p>
<ol>
<li>创建新对象：分配内存，将对象引用次数设为1</li>
<li>更新指针：先增后减计数器值，若引用次数为0则回收</li>
</ol>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;更新指针ptr，让其指向obj
void update_ptr(ptr, obj)&#123;	
	inc_ref_cnt(obj);	&#x2F;&#x2F;obj要被ptr引用了，所以obj计数值++
    dec_ref_cnt(*ptr);	&#x2F;&#x2F;ptr之前引用的东西不再被引用
    *ptr &#x3D; obj;
&#125;
void dec_ref_cnt(obj)&#123;
    obj.ref_cnt--;	&#x2F;&#x2F;obj不再被引用，所以计数值--
    if(obj.ref_cnt &#x3D;&#x3D; 0)&#123;	&#x2F;&#x2F;如果obj没人用了，obj就要被清除
        for(child: obj.children)&#123;	&#x2F;&#x2F;obj被清除了，那obj引用的对象，被引用次数要--
            dec_ref_cnt(*child);
        &#125;
        reclaim(obj);	&#x2F;&#x2F;执行回收
    &#125;
&#125;</code></pre>
<h4 id="评价-2">评价</h4>
<p>优点：</p>
<ul>
<li>对象变成垃圾时立刻被回收（延迟标记清除算法要等到分块用尽后才开始回收垃圾）</li>
<li>最大暂停时间短（只有在更新指针的时候才会打断mutator）</li>
<li>减少延根指针遍历所有子节点的次数（尤其在分布式系统中，效果显著）</li>
</ul>
<p>缺点</p>
<ul>
<li>频繁进行计数值的操作</li>
<li>计数器本身空间比较大（32位系统的计数器就要32位大小）</li>
<li><strong>循环引用无法回收</strong>
<ul>
<li>如果两个物体互相引用，并不和其他对象有联系，于是他们成为了一座“孤岛”，成为了事实意义上的垃圾，但是却无法被回收（因为只要被引用，就不算垃圾）</li>
</ul>
</li>
</ul>
<h4 id="优化方案-2">优化方案</h4>
<h5 id="延迟引用计数法">延迟引用计数法</h5>
<p>解决频繁操作</p>
<ul>
<li>使用ZCT表（Zero Count Table），记录所有执行<code>dec_ref_cnt</code>后计数值变成0的对象（也就是说计数值变成0，不会立刻被视为垃圾回收），当ZCT表满了以后，开始回收表中的对象</li>
<li>优点：延迟了根引用的计数（只有要回收时才会一起操作），降低了计数值的操作频率</li>
<li>缺点
<ul>
<li>不再能即刻回收垃圾（你可以理解为以前有垃圾就仍，现在要先堆一波垃圾再扔）</li>
<li>最大暂停时间延长（<code>scan_zct()</code>要访问整个ZCT，这个过程muator是被中断的）</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">void dec_ref_cnt(obj)&#123;
    obj.ref_cnt--;
    if(obj.ref_cnt &#x3D;&#x3D; 0)&#123;	&#x2F;&#x2F;计数值变为0，可能会变成垃圾
        if(is_full($zct))&#123;
            scan_zct();		&#x2F;&#x2F;如果zct表满了，就扫描zct，并回收
        &#125;
        push($zct, obj);	&#x2F;&#x2F;将obj放入zct表
    &#125;
&#125;
void scane_zct()&#123;
    fot(r: $root)&#123;
        (*r).ref_cnt++;	&#x2F;&#x2F;根直接引用的对象的计数器++，直接引用计数时，根会极频繁改动
    &#125;
    for(obj: $zct)&#123;
        if(obj.ref_cnt &#x3D;&#x3D; 0)&#123;
            remove($zct, obj);
            delete(obj);
        &#125;
    &#125;
    fot(r: $root)&#123;
        (*r).ref_cnt--;	
    &#125;
&#125;</code></pre>
<h5 id="Sticky引用计数法">Sticky引用计数法</h5>
<p>解决空间浪费</p>
<p>32位电脑意味着可以有$2^{32}$个对象，这些对象可能都会引用<code>obj</code>，所以<code>obj</code>的计数位应当可以记录被引用$2^{32}$次，所以计数位要有32位</p>
<p>如果计数位太少，一些比较大的对象就无法正常表示（直接做饱和运算，汽车速度超过速度计的最大值会停在最大值处），一旦出现这种情况，我们可以</p>
<ul>
<li>什么都不做
<ul>
<li>这会导致如果一个物体被引用的次数特别多，超出了目前表示的范围，即使他变成了垃圾也无法回收</li>
<li>但是，事实上绝大多数对象计数值一直在0和1间变化（生成后立刻回收），所以很少出现溢出</li>
<li>而且一个对象被频繁引用，说明他十分重要，十分重要的东西被回收的概率并不大</li>
<li>很多时候不需要保证内存永不泄露，只需要保证一段时间内不泄露就行，很多软件，用户不会一直开着的</li>
</ul>
</li>
<li>结合使用标记清除算法
<ul>
<li>什么都不做，可能会导致内存耗尽，如果耗尽，那就用标记清除法清一次（相当于垃圾太多了，管不来了，就干脆来一次大扫除）</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;标记
void mark()&#123;	
    for(r: $roots)&#123;
        push(*r, $stack);	&#x2F;&#x2F;将所有根直接引用对象入栈
    &#125;
    while(!$stack.empty())&#123;
        obj &#x3D; pop($stack);
        obj.ref_cnt++;
        if(obj.ref_cnt &#x3D;&#x3D; 1)&#123;	&#x2F;&#x2F;这说明obj只进栈一次
            for(child: obj.children)&#123;
                push(*child, $stack);
            &#125;
        &#125;
    &#125;
&#125;
&#x2F;&#x2F;清除
void sweep()&#123;
    index &#x3D; $heap_top;
    while(index &lt; $heap_end)&#123;	&#x2F;&#x2F;遍历整个堆
        if(index.ref_cnt &#x3D;&#x3D; 0)&#123;
            reclaim(index);		&#x2F;&#x2F;回收计数值为0的对象
        &#125;
        index +&#x3D; index.size;
    &#125;
&#125;</code></pre>
<h5 id="一位引用计数法">一位引用计数法</h5>
<p>是Sticky的极端，计数位只有一位（两个tag，一个MULTIPLE，一个UNIQUE），而且将计数位放在指针上，而非放在对象上</p>
<p><img src="/images/%E4%B8%80%E4%BD%8D%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.png" alt="一位引用计数"></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void copy_ptr(dest_ptr, src_ptr)&#123;
    delete_ptr(dest_ptr);
    *dest_ptr &#x3D; *src_ptr;
    set_tag(dest_ptr, MULTIPLE);
    if(src_ptr.tag &#x3D;&#x3D; UNIQUE)&#123;
        set_tag(src_ptr, MULTIPLE);
    &#125;
&#125;
void delete_ptr(ptr)&#123;
    if(ptr.tag &#x3D;&#x3D; UNIQUE)	
        reclaim(*ptr);	&#x2F;&#x2F;如果对象以前只被引用一次，那么这次就要被回收
&#125;</code></pre>
<p>优点</p>
<ul>
<li>cache命中率高</li>
</ul>
<p>缺点</p>
<ul>
<li>同Sticky，而且更严重</li>
</ul>
<h5 id="部分标记清除法">部分标记清除法</h5>
<p>解决循环引用</p>
<p>只对可能会有循环引用的对象使用标记清除法，其他对象使用引用计数法</p>
<p>每个对象会有两个状态位（于是就有四个状态），分别为</p>
<ul>
<li>BLACK：绝对不是垃圾的对象（初始值）</li>
<li>WHILE：绝对是垃圾的对象</li>
<li>GRAY：搜索完毕的对象</li>
<li>HATCH：可能是循环垃圾的对象</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">void dec_ref_cnt(obj)&#123;
    obj.ref_cnt--;
    if(obj.ref_cnt &#x3D;&#x3D; 0)&#123;
        delete(obj);
    &#125;
    else if(obj.color !&#x3D; HATCH)&#123;
        obj.color &#x3D; HATCH;
        queue.push(obj);
    &#125;
&#125;</code></pre>
<p>对放入队列的对象进行标记清除算法</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">Object new_obj(size)&#123;
    obj &#x3D; pickup_chunk(size);	&#x2F;&#x2F;分配内存
    if(obj !&#x3D; null)&#123;	&#x2F;&#x2F;如果分配成功
        obj.color &#x3D; BLACK;
        obj.ref_cnt &#x3D; 1;
        return obj;
    &#125;
    else if(!queue.empty())&#123;	&#x2F;&#x2F;说明现在空间不足，要回收垃圾，先看是否存在HATCH物体
        scan_hatch_queue();		
        return new_obj(size);	&#x2F;&#x2F;回收queue内后重新尝试分配
    &#125;
    else&#123;
        allocation_fall();
    &#125;
&#125;
void scan_hatch_queue()&#123;	&#x2F;&#x2F;循环扫描队列，直至队列为空
    obj &#x3D; queue.pop();
    if(obj.color &#x3D;&#x3D; HATCH)&#123;
        paint_gray(obj);	&#x2F;&#x2F;把obj和其孩子变为GRAY，孩子们引用值--
        scan_gray(obj);		&#x2F;&#x2F;引用值&gt;0涂黑，等于0涂白
        collect_while(obj);
    &#125;
    else if(!queue.empty())&#123;
        scane_hatch_queue();
    &#125;
&#125;
void paint_gray(obj)&#123;
    if(obj.color &#x3D;&#x3D; (BLACK | HATCH))&#123;	
        obj.color &#x3D; GRAY;	
        for(child: obj.children)&#123;
            (*child).ref_cnt--;
            paint_gray(*child);
        &#125;
    &#125;
&#125;
void scan_gray(obj)&#123;
    if(obj.color &#x3D;&#x3D; GRAY)&#123;
        if(obj.ref_cnt &gt; 0)&#123;
            paint_black(obj);
        &#125;
        else&#123;
            obj.color &#x3D; WHITE;
            for(child: children(obj))&#123;
                scan_gray(*child);
            &#125;
        &#125;
    &#125;
&#125;
void paint_black(obj)&#123;
     obj.color &#x3D; BLACK;
	 for(child : children(obj))&#123;
		(*child).ref_cnt++
		if((*child).color !&#x3D; BLACK)&#123;
			paint_black(*child)            
        &#125;          
     &#125;		
&#125;
void collect_while()&#123;
    if(obj.color &#x3D;&#x3D; WHILE)&#123;
        obj.color &#x3D; BLACK;
        for(child: obj.children)&#123;
            collect_while(*child);
        &#125;
        reclaim(obj);
    &#125;
&#125;</code></pre>
<p>优点</p>
<ul>
<li>可以回收循环引用</li>
</ul>
<p>缺点</p>
<ul>
<li>一个对象要被查找三次，导致最大暂停时间+++</li>
</ul>
<h3 id="四：GC复制法">四：GC复制法</h3>
<p><em>想一下渲染中的双缓冲</em></p>
<p>先把整个空间分为等大的两部分，From和To，我们用From空间分配活动对象</p>
<p>GC时，把所有活动对象（递归）复制到其他空间（To空间），然后把原空间（From空间）所有对象回收，然后把空间互换</p>
<h4 id="评价-3">评价</h4>
<p>优点</p>
<ul>
<li>吞吐量大</li>
<li>分配速度快（Frist-fit）</li>
<li>不会发生碎片化（每次回收时，都会把所有对象重新排在From空间的开头，这个操作被称为<strong>压缩</strong>）</li>
<li>兼容缓存</li>
</ul>
<p>缺点</p>
<ul>
<li>堆效率低（因为二等分后，只能利用其中一半）</li>
<li>不兼容保守式GC</li>
<li>复制对象时要递归复制，会消耗栈，可能导致栈溢出</li>
</ul>
<h4 id="优化方案-3">优化方案</h4>
<h5 id="Cheney-GC复制法">Cheney GC复制法</h5>
<p>从递归复制改为迭代复制（基于队列的广度优先搜索）</p>
<p>下图搜索顺序：A BC DEFG HIJKLMNO</p>
<p>![Cheney GC](/images/Cheney GC.png)</p>
<p>优点</p>
<ul>
<li>从递归变成迭代，降低栈压力</li>
</ul>
<p>缺点</p>
<ul>
<li>不利于缓存（在上图，我们假设每个页最多存放三个块，我们发现有引用关系的对象很可能不在同一个块中）</li>
</ul>
<h5 id="近似深度优先搜索方法">近似深度优先搜索方法</h5>
<p>在页间做深度优先搜索，在页内做广度优先搜索</p>
<p>下图搜索顺序：ABC DHI EJK FLM GNO</p>
<p><img src="/images/%E8%BF%91%E4%BC%BC%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88.png" alt="近似深度优先"></p>
<h5 id="多空间复制法">多空间复制法</h5>
<p>把空间分成十份，一个From，一个To，八个标记清除法</p>
<h3 id="五：标记压缩法">五：标记压缩法</h3>
<p>结合了标记清除法的标记+GC复制法的压缩</p>
<h4 id="Lisp2算法">Lisp2算法</h4>
<p><em>类比原地删除数组中某个元素</em></p>
<p>标记方法和标记清除法一样，标记后遍历堆，将所有活动对象压缩到左侧</p>
<p><img src="/images/Lisp2%E6%A0%87%E8%AE%B0.png" alt="Lisp2标记"></p>
<p><img src="/images/Lisp2%E5%8E%8B%E7%BC%A9.png" alt="Lisp2压缩"></p>
<p><img src="/images/Lisp2%E7%BB%93%E6%9D%9F.png" alt="Lisp2结束"></p>
<p>优点</p>
<ul>
<li>比GC复制法堆效率高，比标记压缩法碎片少</li>
</ul>
<p>缺点</p>
<ul>
<li>三次遍历堆，效率过低</li>
</ul>
<h4 id="Two-Finger算法">Two-Finger算法</h4>
<p>这个算法优缺点很明显，所以先说优缺点，再谈实现</p>
<p>优点</p>
<ul>
<li>只需要两次遍历堆</li>
<li>不需要额外的forward指针（Lisp2的对号）</li>
</ul>
<p>缺点</p>
<ul>
<li>对象大小必须一致（可以与BiBOP结合使用）</li>
<li>压缩时破坏排序（一般有引用关系的对象会放在一起），于是不适合缓存</li>
</ul>
<p>在Lisp2算法中，可以说几乎每一个活动对象都需要移动，一般来说越靠近左边，移动的概率、距离越小，而越后面则越大（可以类比幽灵堵车）</p>
<p>我们能不能固定前面的对象，只移动后面的对象，从而实现压缩呢？（如果后面的对象和前面的对象大小一致，完全可以）</p>
<p><img src="/images/Two-Finger.png" alt="Two-Finger"></p>
<h4 id="表格算法">表格算法</h4>
<p>算法分为三部：移动对象群，构建间隙表格，更新指针</p>
<ul>
<li>移动对象群（Lisp2一次移动一个对象，这个一次移动所有相邻对象）</li>
</ul>
<p><img src="/images/%E8%A1%A8%E6%A0%BC%E7%AE%97%E6%B3%95%E7%A7%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1%E7%BE%A4.png" alt="表格算法移动对象群"></p>
<ul>
<li>构建间隙表格（设一个小格子尺寸为50）
<ul>
<li>a到b：live在B开头，scan在D开头，于是将B的初始位置和B向左移动的距离$(100,100)$写到D处</li>
<li>b到c：
<ul>
<li>先把间隙表格向后移动，移到FG之后，于是H处写入$(100,100)$</li>
<li>FG的初始位置和向左移动的距离为$(550,300)$，写入H之后（后是左边的G）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/%E6%9E%84%E5%BB%BA%E9%97%B4%E9%9A%99%E8%A1%A8%E6%A0%BC.png" alt="构建间隙表格"></p>
<ul>
<li>更新指针</li>
</ul>
<h4 id="ImmixGC算法">ImmixGC算法</h4>
<h3 id="六：保守式GC">六：保守式GC</h3>
<p>把疑似指针的一律视为指针</p>
<h4 id="不明确的根">不明确的根</h4>
<p>常见的根有</p>
<ul>
<li>寄存器</li>
<li>调用栈</li>
<li>全局变量空间</li>
</ul>
<p>在c++等语言里，<code>int</code>这种内置变量（非指针）和<code>void*</code>指针都存放在栈里，GC无法区分两者的区别，保守式GC就干脆不区分两者</p>
<p>存储着不确定对象的根，称为不明确的根，而基于这些根的GC算法，被称为保守式GC（ambiguous GC）</p>
<h4 id="检查内容">检查内容</h4>
<ul>
<li>是否<strong>位对齐</strong>（32位CPU，指针是4的倍数，64位CPU，指针是8的倍数）
<ul>
<li>不对齐的一定是非指针</li>
</ul>
</li>
<li>是否指向堆内
<ul>
<li>对象放在堆中，所以指针一定指向堆</li>
</ul>
</li>
<li>是否指向对象开头</li>
</ul>
<p>我们发现，有的时候我们会遇到一些格式与指针一致的非指针，我们称之为<strong>貌似指针的非指针（false pointer）</strong></p>
<p>在标记清除算法中，遇到这种貌似指针的非指针，会胡乱找到一个对象，我们不知道这个对象是活动对象还是非活动对象，所以<strong>一律视为活动对象</strong>，进行标记</p>
<p>注意：保守GC是只有当判断不出来到底是不是指针时才将其视为指针，而不是把所有对象都视为指针（迫不得已，凑合凑合用）</p>
<h4 id="评价-4">评价</h4>
<p>优点</p>
<ul>
<li>开发容易，程序员不需要意识到GC的存在</li>
</ul>
<p>缺点</p>
<ul>
<li>识别指针和非指针需要付出代价（检查内容）</li>
<li>将false pointer指向的错误对象视为活动对象，这些东西不会被用到，却进栈了</li>
<li>支持保守GC的算法不多</li>
</ul>
<h4 id="准确式GC">准确式GC</h4>
<p>正确的根（exact roots）可以精确地识别指针和非指针</p>
<p>基于正确的根的GC被称为<strong>准确式GC</strong></p>
<h5 id="构建正确的根的方法：打标签">构建正确的根的方法：打标签</h5>
<ul>
<li>32位CPU指针的值是4的倍数，那么其<strong>低2位</strong>一定是0</li>
<li>我们可以将所有非指针左移1位，然后将其<strong>低1位</strong>置为1</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;打标签
int addTag(int a)&#123;
    a &#x3D; a &lt;&lt; 1;	&#x2F;&#x2F;小心溢出，如果会溢出，就用一个更大的数据结构
	a &#x3D; a|1;
    return a;
&#125;
&#x2F;&#x2F;去标签（在使用时需要恢复成正常数值），而且使用完后还有再次打标签
int getValue(int a)&#123;
    a  &#x3D; a &gt;&gt; 1;
    return a;
&#125;</code></pre>
<p>除了打标签，还可以专门构建一个只存放指针的根，比如一些使用虚拟机（VM）的语言</p>
<h5 id="评价-5">评价</h5>
<p>优点</p>
<ul>
<li>不需要判断是否为指针，没有判断带来的性能代价</li>
<li>堆中只会存在指针，可以适用于一些移动对象的GC算法</li>
</ul>
<p>缺点</p>
<ul>
<li>构建准确的根需要性能成本</li>
<li>语言使用时更麻烦</li>
</ul>
<h4 id="间接引用">间接引用</h4>
<p>为什么保守式GC不能移动对象？因为一个false pointer可能是一个非指针，移动会导致问题</p>
<h5 id="句柄">句柄</h5>
<p>如图，即使我们移动了堆中的对象，也却不会改变根内的内容</p>
<img src="/images/句柄.jpeg" alt="句柄" style="zoom:50%;" />
<p>优点：</p>
<ul>
<li>可以使用复制算法</li>
</ul>
<p>缺点：</p>
<ul>
<li>访问一个对象需要访问两次内存</li>
</ul>
<h4 id="MostlyCopyingGC">MostlyCopyingGC</h4>
<p>保守式GC复制算法</p>
<h4 id="黑名单">黑名单</h4>
<p>有的false pointer即使是非指针，错把他当指针用也可以找到一个对象（尽管这个过程是未定义的），如果这个非指针可以做到这个事，拿我们就把这个非指针指向的地址存放到<strong>黑名单</strong>中</p>
<p>黑名单中存放的是地址，如果在这些地址中分配空间，可能会导致未定义事件</p>
<p>所以在这些地址上分配对象时要十分小心，比如只能分配小对象、只能分配没有子对象的小对象，因为这些对象比较小，即使变成垃圾，被错误识别了，危害也比较小</p>
<h3 id="七：分代垃圾回收">七：分代垃圾回收</h3>
<p>引入了年龄这一概念，优先回收那些容易成为垃圾的对象</p>
<h4 id="年龄">年龄</h4>
<p>我们在引用计数法中提到过，绝大多数的对象生成后立刻会被回收，而被引用次数多多对象很难变成垃圾</p>
<p>于是我们引入年龄这一概念，初始为0，每经历一次GC算法，如果没有被回收，则年龄+1</p>
<p>我们发现年龄越大，说明对象越重要，越不容易被回收，于是年龄越大，参与回收的频率就越低</p>
<h4 id="评价-6">评价</h4>
<p>优点</p>
<ul>
<li>提高吞吐量</li>
</ul>
<p>缺点</p>
<ul>
<li>很多对象出生立刻回收只是一个经验，不适合所有程序，一旦某程序对象比较“长寿”，会起反作用</li>
</ul>
<h3 id="八：增量式垃圾回收">八：增量式垃圾回收</h3>
<p><em>想一想单核CPU并行的本质，就是将线程切分，来回切换</em></p>
<p>通过逐步推进垃圾回收来控制最大暂停时间，不一次执行完GC，而是执行一会mutator，执行一会GC</p>
<img src="/images/增量式GC.jpeg" alt="增量式GC" style="zoom:50%;" />
<ul>
<li>三色标记法</li>
</ul>
<h4 id="评价-7">评价</h4>
<p>优点</p>
<ul>
<li>降低最大暂停时间</li>
</ul>
<p>缺点</p>
<ul>
<li>降低了吞吐量</li>
</ul>
<h3 id="九：RC-Immix算法">九：RC Immix算法</h3>
<p><em>这是一个2013年的算法，听懂掌声</em></p>
<p>将合并型引用计数法和Immix组合到一起，改善了引用计数法的吞吐量</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/01/31/engine/GC/" data-id="clepy40ny0004glnk6wsm4rcq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/" rel="tag">GC</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/dcc/">dcc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/engine/">engine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/graphics/">graphics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/math/">math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/optics/">optics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/program/">program</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DX12/" rel="tag">DX12</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deferred-Render/" rel="tag">Deferred Render</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metal/" rel="tag">Metal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PM/" rel="tag">PM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Physics/" rel="tag">Physics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SIGGRAPH/" rel="tag">SIGGRAPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPH/" rel="tag">SPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TA/" rel="tag">TA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unreal/" rel="tag">Unreal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shader/" rel="tag">shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%89%E5%AD%A6/" rel="tag">光学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" rel="tag">并行计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" rel="tag">微积分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C#</a> <a href="/tags/C/" style="font-size: 17.5px;">C++</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/DX12/" style="font-size: 10px;">DX12</a> <a href="/tags/Deferred-Render/" style="font-size: 10px;">Deferred Render</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/GI/" style="font-size: 15px;">GI</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Metal/" style="font-size: 10px;">Metal</a> <a href="/tags/PM/" style="font-size: 10px;">PM</a> <a href="/tags/Physics/" style="font-size: 12.5px;">Physics</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/SIGGRAPH/" style="font-size: 15px;">SIGGRAPH</a> <a href="/tags/SPH/" style="font-size: 12.5px;">SPH</a> <a href="/tags/TA/" style="font-size: 15px;">TA</a> <a href="/tags/Unity/" style="font-size: 12.5px;">Unity</a> <a href="/tags/Unreal/" style="font-size: 10px;">Unreal</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/shader/" style="font-size: 10px;">shader</a> <a href="/tags/%E5%85%89%E5%AD%A6/" style="font-size: 20px;">光学</a> <a href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" style="font-size: 10px;">并行计算</a> <a href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" style="font-size: 10px;">微积分</a> <a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 17.5px;">高等数学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/02/26/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/">光学复习</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E8%A1%8D%E5%B0%84/">衍射</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E5%B9%B2%E6%B6%89/">干涉</a>
          </li>
        
          <li>
            <a href="/2023/02/18/program/AskQuestion/">提问的智慧</a>
          </li>
        
          <li>
            <a href="/2023/02/13/graphics/DOSDF/">Dynamic Occlusion with SDF</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Reuben Sun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>