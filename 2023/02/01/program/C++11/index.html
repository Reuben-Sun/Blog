<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>C++11特性 | ReubenSun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="C++11特性 都什么年代了，还在整C++11？八股害人啊 一：C++11的“新”特性 nullptr 一个新关键字，用于表示指针指向no value，可以被自动转化为各种指针类型，但是不会被转化为整数 比NULL好，因为NULL的本质就是整数0 auto 通过auto声明变量、对象，可以自动推到其类型，在处理表达式时有奇效 auto l &#x3D; [](int x) -&gt; &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11特性">
<meta property="og:url" content="http://reuben-sun.github.io/2023/02/01/program/C++11/index.html">
<meta property="og:site_name" content="ReubenSun">
<meta property="og:description" content="C++11特性 都什么年代了，还在整C++11？八股害人啊 一：C++11的“新”特性 nullptr 一个新关键字，用于表示指针指向no value，可以被自动转化为各种指针类型，但是不会被转化为整数 比NULL好，因为NULL的本质就是整数0 auto 通过auto声明变量、对象，可以自动推到其类型，在处理表达式时有奇效 auto l &#x3D; [](int x) -&gt; &amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-01T14:01:25.000Z">
<meta property="article:modified_time" content="2023-03-01T17:22:20.541Z">
<meta property="article:author" content="Reuben Sun">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="ReubenSun" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ReubenSun</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://reuben-sun.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-program/C++11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/01/program/C++11/" class="article-date">
  <time datetime="2023-02-01T14:01:25.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++11特性
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>C++11特性</h1>
<p>都什么年代了，还在整C++11？八股害人啊</p>
<h2 id="一：C-11的“新”特性">一：C++11的“新”特性</h2>
<h3 id="nullptr">nullptr</h3>
<p>一个新关键字，用于表示指针指向no value，可以被自动转化为各种指针类型，但是不会被转化为整数</p>
<p><em>比NULL好，因为NULL的本质就是整数0</em></p>
<h3 id="auto">auto</h3>
<p>通过auto声明变量、对象，可以自动推到其类型，在处理表达式时有奇效</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto l &#x3D; [](int x) -&gt; &#123;...&#125;;</code></pre>
<h3 id="一致性初始化">一致性初始化</h3>
<p>一致性初始化（Uniform Initiallization），简单来说就是可以用大括号来做初始化</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int v[] &#123;1, 2, 3&#125;;
vector&lt;int&gt; v2 &#123;1, 2, 3&#125;;
complex&lt;double&gt; c&#123;4.0, 3.0&#125;;</code></pre>
<p>但是这个操作不支持<strong>窄化（narrowing）</strong>，即</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 5.3;	&#x2F;&#x2F;x &#x3D;&#x3D; 5
int y &#123;5.3&#125;;	&#x2F;&#x2F;Error</code></pre>
<h3 id="新的for循环">新的for循环</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">for(auto&amp; item: lists)&#123;...&#125;

for(int i : &#123;1, 2, 3, 4&#125;)&#123;...&#125;</code></pre>
<h3 id="转移语意">转移语意</h3>
<p>转移语意（move semantic），用于避免非必要的拷贝和临时对象</p>
<p>比如一个函数定义为</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void fun(const T&amp; v)&#123;...&#125;</code></pre>
<p>当我们调用时</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">T t;
fun(t);		&#x2F;&#x2F;1
fun(t+1);	&#x2F;&#x2F;2</code></pre>
<p>我们发现，第一种调用时，直接传了引用，没有拷贝和临时变量，而第二种，实际上是</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">T temp &#x3D; t+1;		&#x2F;&#x2F;T temp(t+1)或者 T temp.T(t+1)
fun(temp);</code></pre>
<p>总之是调用了拷贝构造函数和生成了临时变量，这不是我们想要的，于是引入了左右值和转移语意的概念，然后就诞生了一种新的调用方式：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">fun(std::move(t+1));</code></pre>
<p><code>std::move</code>的作用是将其参数<code>t+1</code>变成一个<strong>右值（rvalue reference）</strong>，是一个<code>T&amp;&amp;</code>的类型</p>
<p>一旦一个类型被“标记”为右值，就意味着这是一个临时对象，你可以随意使用它的内容和资源</p>
<p>然后我们可以优化一下这个函数的定义</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class T&#123;
public:
  T (const T&amp; lvalue);	&#x2F;&#x2F;通过左值拷贝构造（根传统C++一样）
  T (T&amp;&amp; rvalue);		&#x2F;&#x2F;通过右值move构造
&#125;
void fun(T&amp;&amp; v)&#123;...&#125;</code></pre>
<p>右值被move以后，就变成有效但不确定的状态</p>
<h3 id="字符串字面量">字符串字面量</h3>
<h4 id="Raw-String-Literal">Raw String Literal</h4>
<p>以R开头的字符串，可以换行，不需要转义，用于正则表示式有奇效</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">R&quot;(\\n)&quot;;	&#x2F;&#x2F;等于 &quot;\\\\n&quot;</code></pre>
<h4 id="Encoded-String-Literal">Encoded String Literal</h4>
<p>用于国际化</p>
<h3 id="noexcept">noexcept</h3>
<p>让函数无法抛出异常，遇到未定义事件会直接<code>abort</code></p>
<p>noexcept后面可以跟一个bool条件，为true时就不抛异常</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void fun() noexcept;
void fun2(T&amp; x, T&amp; y) noexcept(noexcept(x.swap(y)))&#123;
    x.swap(y);
    &#x2F;&#x2F;这个函数意味着，只要xy交换不抛异常，那么下面这些函数体做任何事都不会抛异常
&#125;</code></pre>
<h3 id="constexpr">constexpr</h3>
<p>用于让表达式核定与编译期，能助力TMP编程</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">constexpr int square(int x)&#123;
    return x*x;
&#125;
float a[square(9)];</code></pre>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;以前的写法
template&lt;unsigned n&gt;
struct Factorial
&#123;
    enum &#123; value &#x3D; n * Factorial&lt;n-1&gt;::value &#125;;
&#125;;
&#x2F;&#x2F;C++11写法
template&lt;unsigned n&gt;
struct Factorial
&#123;
    constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;;
&#125;;</code></pre>
<h3 id="新的模板">新的模板</h3>
<h4 id="不定个数的参数">不定个数的参数</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">void f(int i)&#123;
    cout &lt;&lt; i &lt;&lt; endl;
&#125;
template &lt;typename T , typename... Types&gt;
void f(const T&amp; first, const Types&amp;... args)&#123;
    cout &lt;&lt; first &lt;&lt; endl;
    f(args...);
&#125;
int main() &#123;
    f(1, 2, 3);
    return 0;
&#125;</code></pre>
<h4 id="模板别名">模板别名</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
using Vec &#x3D; std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;
Vec&lt;int&gt; coll;	&#x2F;&#x2F;等价于std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll;</code></pre>
<h3 id="Lambda">Lambda</h3>
<p>允许函数的定义式被用作一个参数、local对象</p>
<h4 id="定义与调用">定义与调用</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">[]&#123;
    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;
&#125;;	&#x2F;&#x2F;这是一个lambda表达式

[]&#123;
    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;
&#125;();	&#x2F;&#x2F;定义并直接调用表达式

auto l &#x3D; []&#123;
    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;
&#125;;
l();	&#x2F;&#x2F;调用表达式</code></pre>
<h4 id="含参">含参</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto l2 &#x3D; [](const std::string&amp; s)&#123;
    cout &lt;&lt; s &lt;&lt; endl;
&#125;;
l(&quot;hello&quot;);</code></pre>
<h4 id="返回值">返回值</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">[]() -&gt; int &#123;
    return 42;	
&#125;</code></pre>
<h4 id="外部作用域">外部作用域</h4>
<p>分值传递和引用传递两种，值传递不能进行修改</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 0;
int y &#x3D; 42;
auto l &#x3D; [x, &amp;y] &#123;
    cout &lt;&lt; x &lt;&lt; &quot;+&quot; &lt;&lt; y &lt;&lt; endl;
    ++y;
&#125;
l();	&#x2F;&#x2F;调用，注意xy不是参数，不需要写在括号里</code></pre>
<h4 id="mutable">mutable</h4>
<p>这个关键词是const的反义词，意思是可变的，于是让值传递也可变</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 0;
auto l &#x3D; [x]() mutable &#123;
    cout &lt;&lt; x &lt;&lt; endl;
    x++;
&#125;
l();</code></pre>
<h3 id="decltype">decltype</h3>
<p>自动推导表达式的类型，大号typeof</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int &amp;i &#x3D; 1;
int a &#x3D; 2;
decltype(i) b &#x3D; 2; &#x2F;&#x2F; b是const int&amp;</code></pre>
<h4 id="推断返回类型">推断返回类型</h4>
<p>可以将返回类型的声明放在参数列之后</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename T1, typename T2&gt;
auto add(T1 x, T2 y) -&gt; decltype(x+y)&#123;
    return x + y;
&#125;</code></pre>
<h3 id="带领域的枚举">带领域的枚举</h3>
<h2 id="二：一般概念">二：一般概念</h2>
<h3 id="可被调用的对象">可被调用的对象</h3>
<p>Callable Object，一种对象，可以通过某些方式调用其某些函数，它可以是</p>
<ul>
<li>函数</li>
<li>指向成员函数的指针</li>
<li>函数对象</li>
<li>lambda表达式</li>
</ul>
<h2 id="三：通用工具">三：通用工具</h2>
<h3 id="pair">pair</h3>
<p>本质是一个struct</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int add(pair&lt;int, int&gt; p)&#123;
    return p.first + p.second;
&#125;

int main() &#123;
    pair&lt;int, int&gt; p(42, 10);
    cout &lt;&lt; add(p);
    return 0;
&#125;</code></pre>
<h3 id="tuple">tuple</h3>
<p>大号pair，可以有多个值</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int f(tuple&lt;int, int, int&gt; t)&#123;
    return get&lt;0&gt;(t) + get&lt;1&gt;(t) + get&lt;2&gt;(t);
&#125;
int main() &#123;
    tuple&lt;int, int, int&gt; t(3, 5, 7);
    cout &lt;&lt; f(t);
    return 0;
&#125;</code></pre>
<h3 id="智能指针">智能指针</h3>
<p>智能指针智能在，它能知道自己是不是指向某物的最后一个指针</p>
<ul>
<li>shared_ptr：共享式拥有
<ul>
<li>多个指针可以指向一个资源，通过引用计数法GC</li>
<li>为了解决引用计数法的缺点（比如循环引用），提供weak_ptr等辅助类</li>
</ul>
</li>
<li>unique_ptr：独占式拥有
<ul>
<li>同一时间只能有一个unique_ptr指向某个资源，可以进行拥有权的移交</li>
</ul>
</li>
</ul>
<h3 id="极值">极值</h3>
<p>Numeric Limit</p>
<p>用于得到当前平台下，一些数值类型的长度（大小）</p>
<h3 id="Trait">Trait</h3>
<p>是一种技术方案，用来为同一类数据提供统一的操作函数，核心就是使用另外的模版类<code>type_traits</code>存储不同数据类型的<code>type</code>，这样就可以兼容各种数据类型</p>
<h3 id="外覆器">外覆器</h3>
<h4 id="Reference-Wrapper">Reference Wrapper</h4>
<p>允许函数模板可以操作引用，不需要写特化版本</p>
<p>具体有两个函数</p>
<ul>
<li>ref：隐式转化为<code>T&amp;</code></li>
<li>cref：隐式转化为<code>const T &amp;</code></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
void fun(T v);

int x;
fun(std::ref(x));	&#x2F;&#x2F;此时T为int&amp;

int x;
fun(std::cref(x));	&#x2F;&#x2F;此时T为const int&amp;</code></pre>
<h4 id="Function-Type-Wrapper">Function Type Wrapper</h4>
<p>允许将可调用对象当作最高级对象（first-class object）</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">vector&lt;function&lt;void(int, int)&gt;&gt; tasks;	&#x2F;&#x2F;一个存储多个可调用对象的vector
tasks.push_back(func);	&#x2F;&#x2F;void func(int x, int y);
tasks.push_back([] (int x, int y) &#123;...&#125;);	&#x2F;&#x2F;添加一个lambda表达式

for(function&lt;void(int, int)&gt; f : tasks)&#123;
    f(36, 36);	&#x2F;&#x2F;遍历所有的可调用对象，并调用
&#125;</code></pre>
<h3 id="辅助函数">辅助函数</h3>
<ul>
<li>min</li>
<li>max</li>
<li>swap</li>
<li>operator
<ul>
<li><code>==</code></li>
<li><code>!=</code></li>
<li><code>&gt;</code></li>
<li><code>&lt;</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;=</code></li>
</ul>
</li>
</ul>
<h3 id="编译期分数运算">编译期分数运算</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">ratio&lt;5, 5&gt; one;
cout &lt;&lt; one.num &lt;&lt; &quot;&#x2F;&quot; &lt;&lt; one.den &lt;&lt; endl;	&#x2F;&#x2F; 1&#x2F;1

ratio&lt;5, 3&gt; two;
cout &lt;&lt; two.num &lt;&lt; &quot;&#x2F;&quot; &lt;&lt; two.den &lt;&lt; endl;	&#x2F;&#x2F; 5&#x2F;3</code></pre>
<h2 id="四：STL">四：STL</h2>
<p>STL是C++标准库的核心，是一个泛型（generic）程序库，由三部分组成</p>
<ul>
<li>容器（Container）</li>
<li>迭代器（Iterator）</li>
<li>算法（Algorithm）</li>
</ul>
<h3 id="容器">容器</h3>
<h4 id="有序容器">有序容器</h4>
<p>顺序与插入顺序有关，与元素值无关，常常通过array、linked list实现</p>
<ul>
<li>array</li>
<li>vector</li>
<li>deque</li>
<li>list</li>
<li>forward_list</li>
</ul>
<h4 id="关联式容器">关联式容器</h4>
<p>在内部进行排序的集合，位置取决于value，常常通过二叉树实现</p>
<ul>
<li>set</li>
<li>multiset（mult的意思是元素可以重复）</li>
<li>map</li>
<li>multimap（mult的意思是key可以重复）</li>
</ul>
<h4 id="无序容器">无序容器</h4>
<p>元素位置无关紧要，重要的是元素是否在容器内，常常通过哈希表实现</p>
<ul>
<li>unordered_set</li>
<li>unordered_multiset</li>
<li>unordered_map</li>
<li>unordered_multmap</li>
</ul>
<h4 id="其他容器">其他容器</h4>
<ul>
<li>string</li>
<li>寻常的数组（一种type，而非class）</li>
</ul>
<h3 id="迭代器">迭代器</h3>
<p>迭代器是一个可以遍历STL容器全部、部分元素的对象</p>
<h4 id="操作">操作</h4>
<ul>
<li><code>*</code>：取元素</li>
<li><code>++</code>：迭代器前进至下一个元素
<ul>
<li>注意，<code>++i</code>比<code>i++</code>效率高一点点，因为后者要创建临时对象</li>
</ul>
</li>
<li><code>==</code>、<code>!=</code>：判断两个迭代器是否指向同一个位置</li>
<li><code>=</code>：赋值</li>
</ul>
<h3 id="种类">种类</h3>
<table>
<thead>
<tr>
<th></th>
<th>R/W</th>
<th>读写次数</th>
<th>跳转</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出迭代器</td>
<td>只读/只写</td>
<td>能且仅能读写一次</td>
<td>i++</td>
<td>istream_iterators、ostream_iterators</td>
</tr>
<tr>
<td>前向/双向迭代器</td>
<td>读写</td>
<td>能读写多次</td>
<td>i++</td>
<td>STL的set、map</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写</td>
<td>能读写多次</td>
<td>i += n</td>
<td>vector、deque、string、array</td>
</tr>
</tbody>
</table>
<p>从上到下，迭代器能力越来越强（他们间有继承关系，前向 is a 输入）</p>
<h3 id="算法">算法</h3>
<p>大多为非成员函数，思想是泛型编程（而不是OOP）</p>
<h3 id="函数对象">函数对象</h3>
<p>一个行为像函数的对象，思想是泛型编程</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class X&#123;
public:
    int operator() (int a, int b) const;
&#125;;
...
X fo;
fo(arg1, arg2);	&#x2F;&#x2F;等同于fo.operator()(arg1, arg2);</code></pre>
<ul>
<li>函数对象是一个带状态的函数</li>
<li>函数对象有自己的类型</li>
<li>函数对象速度通常比普通函数快（编译期间有更好的优化）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/01/program/C++11/" data-id="clepy40oy002dglnk1ghee8td" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/02/02/%E6%88%91%E6%98%AF%E8%B0%81/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          我是谁
        
      </div>
    </a>
  
  
    <a href="/2023/02/01/graphics/profile%E5%B7%A5%E5%85%B7/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">profile工具</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/dcc/">dcc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/engine/">engine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/graphics/">graphics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/math/">math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/optics/">optics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/program/">program</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DX12/" rel="tag">DX12</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deferred-Render/" rel="tag">Deferred Render</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metal/" rel="tag">Metal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PM/" rel="tag">PM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Physics/" rel="tag">Physics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SIGGRAPH/" rel="tag">SIGGRAPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPH/" rel="tag">SPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TA/" rel="tag">TA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unreal/" rel="tag">Unreal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shader/" rel="tag">shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%89%E5%AD%A6/" rel="tag">光学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" rel="tag">并行计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" rel="tag">微积分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C#</a> <a href="/tags/C/" style="font-size: 17.5px;">C++</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/DX12/" style="font-size: 10px;">DX12</a> <a href="/tags/Deferred-Render/" style="font-size: 10px;">Deferred Render</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/GI/" style="font-size: 15px;">GI</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Metal/" style="font-size: 10px;">Metal</a> <a href="/tags/PM/" style="font-size: 10px;">PM</a> <a href="/tags/Physics/" style="font-size: 12.5px;">Physics</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/SIGGRAPH/" style="font-size: 15px;">SIGGRAPH</a> <a href="/tags/SPH/" style="font-size: 12.5px;">SPH</a> <a href="/tags/TA/" style="font-size: 15px;">TA</a> <a href="/tags/Unity/" style="font-size: 12.5px;">Unity</a> <a href="/tags/Unreal/" style="font-size: 10px;">Unreal</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/shader/" style="font-size: 10px;">shader</a> <a href="/tags/%E5%85%89%E5%AD%A6/" style="font-size: 20px;">光学</a> <a href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" style="font-size: 10px;">并行计算</a> <a href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" style="font-size: 10px;">微积分</a> <a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 17.5px;">高等数学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/02/26/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/">光学复习</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E8%A1%8D%E5%B0%84/">衍射</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E5%B9%B2%E6%B6%89/">干涉</a>
          </li>
        
          <li>
            <a href="/2023/02/18/program/AskQuestion/">提问的智慧</a>
          </li>
        
          <li>
            <a href="/2023/02/13/graphics/DOSDF/">Dynamic Occlusion with SDF</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Reuben Sun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>