<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>WPF中的C# | ReubenSun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="WPF中的C# 一、C#语法 委托 C#的委托类似于C++的函数指针，C#中，将参数a,b委托给了对象adder的Add方法，委托本质上是一种支持()运算符的对象。既然是对象，就可以有自己的成员和状态 delegate int Fun(int a, int b);  class Adder&amp;#123;   private int c &#x3D; 0;      public Adder(int">
<meta property="og:type" content="article">
<meta property="og:title" content="WPF中的C#">
<meta property="og:url" content="http://reuben-sun.github.io/2023/02/01/program/Csharpe/index.html">
<meta property="og:site_name" content="ReubenSun">
<meta property="og:description" content="WPF中的C# 一、C#语法 委托 C#的委托类似于C++的函数指针，C#中，将参数a,b委托给了对象adder的Add方法，委托本质上是一种支持()运算符的对象。既然是对象，就可以有自己的成员和状态 delegate int Fun(int a, int b);  class Adder&amp;#123;   private int c &#x3D; 0;      public Adder(int">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://reuben-sun.github.io/images/Path.png">
<meta property="og:image" content="http://reuben-sun.github.io/images/%E9%9B%86%E5%90%88.png">
<meta property="og:image" content="http://reuben-sun.github.io/images/xml.png">
<meta property="og:image" content="http://reuben-sun.github.io/images/LINQ.png">
<meta property="og:image" content="http://reuben-sun.github.io/images/%E6%A0%A1%E9%AA%8C.png">
<meta property="article:published_time" content="2023-02-01T10:01:25.000Z">
<meta property="article:modified_time" content="2023-03-01T17:22:20.541Z">
<meta property="article:author" content="Reuben Sun">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Windows">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://reuben-sun.github.io/images/Path.png">
  
    <link rel="alternate" href="/atom.xml" title="ReubenSun" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ReubenSun</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://reuben-sun.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-program/Csharpe" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/01/program/Csharpe/" class="article-date">
  <time datetime="2023-02-01T10:01:25.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      WPF中的C#
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>WPF中的C#</h1>
<h2 id="一、C-语法">一、C#语法</h2>
<h3 id="委托">委托</h3>
<p>C#的委托类似于C++的函数指针，C#中，将参数<code>a,b</code>委托给了对象adder的Add方法，委托本质上是一种支持<code>()</code>运算符的<strong>对象</strong>。既然是对象，就可以有自己的成员和状态</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">delegate int Fun(int a, int b);

class Adder&#123;
  private int c &#x3D; 0;
  
  public Adder(int c)&#123; this.c &#x3D; c; &#125;
  
  public int Add(int a, int b)&#123; return a+b; &#125;
&#125;
&#x2F;&#x2F;Main()&#123;...
Adder adder &#x3D; new Adder(1);
Fun f &#x3D; adder.Add;
f(2,3);	&#x2F;&#x2F;return 6</code></pre>
<p>C#委托支持匿名委托和lambda表达式</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">delegate int Fun(int a, int b);
&#x2F;&#x2F;Main()&#123;...
Fun f &#x3D; delegate(int a, int b)&#123;
  cout &lt;&lt; a+b &lt;&lt; endl;
&#125;;
Fun f2 &#x3D; (int a, int b)&#x3D;&gt;&#123;
  cout &lt;&lt; a+b &lt;&lt; endl;
&#125;;</code></pre>
<h4 id="C-的函数指针">C++的函数指针</h4>
<p>C/C++的函数指针是一个指向函数入口的指针，不具有对象的性质，只能指向非成员函数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">typedef int(*Func)(int a, int b);

int Add(int a, int b)&#123;
    return a+b;
&#125;

int main(int argc, char **argv)&#123;
    Func func &#x3D; Add;
    std::cout &lt;&lt; func(1,2);	&#x2F;&#x2F;cout 3
    return 0;
&#125;</code></pre>
<p>当然，如果加上类型限制符，还是可以指向成员函数的</p>
<pre class="language-C++" data-language="C++"><code class="language-C++">class Multiple&#123;
public:
    int Mul(int a, int b)&#123;
        return a * b;
    &#125;
&#125;;

typedef int(Multiple::*Fm)(int a, int b);

int main(int argc, char **argv)&#123;
    Multiple multiple;
    Fm f &#x3D; &amp;Multiple::Mul;
    std::cout &lt;&lt; (multiple.*f)(3,4);
    return 0;
&#125;</code></pre>
<p>如果想让C++对委托具有对象的性质，我们可以重载<code>()</code>操作符</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class Adder&#123;
public:
    Adder(int c)&#123; this-&gt;c &#x3D; c; &#125;
    int operator()(int a, int b)&#123;
        return a+b+c;
    &#125;
private:
    int c;
&#125;;

int main(int argc, char **argv)&#123;
    Adder adder(1);
    std::cout &lt;&lt; adder(2, 3);
    return 0;
&#125;</code></pre>
<h4 id="Action泛型委托">Action泛型委托</h4>
<p>C#一种无返回值的泛型委托</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">public delegate void Action&lt;in T&gt;(T obj);</code></pre>
<p>无参数<code>Action xxx = 函数</code></p>
<pre class="language-c#" data-language="c#"><code class="language-c#">public class Name
&#123;
  public string InstanceName&#123; private set; get; &#125;
  public Name(string name)
  &#123;
    InstanceName &#x3D; name;
  &#125;
  public void DisplayName()
  &#123;
    Console.WriteLine($&quot;I&#39;m &#123;InstanceName&#125;&quot;);
  &#125;
&#125;
public static void Main(string[] args)
&#123;
  Name testName &#x3D; new Name(&quot;Tim&quot;);
  Action showName &#x3D; testName.DisplayName;
  showName();
&#125;       </code></pre>
<p>有参数<code>Action&lt;参数类型&gt; xxx = 函数</code></p>
<pre class="language-c#" data-language="c#"><code class="language-c#">public class Name
&#123;
  public string InstanceName&#123; private set; get; &#125;
  public Name(string name)
  &#123;
    InstanceName &#x3D; name;
  &#125;
  public void DisplayName(string str)
  &#123;
    Console.WriteLine($&quot;I&#39;m &#123;InstanceName&#125;, &#123;str&#125;&quot;);
  &#125;
&#125;
public static void Main(string[] args)
&#123;
  Name testName &#x3D; new Name(&quot;Tim&quot;);
  Action&lt;string&gt; showName &#x3D; testName.DisplayName;
  showName(&quot;HHH&quot;);
&#125;    </code></pre>
<h4 id="Func泛型委托">Func泛型委托</h4>
<p>C#一种有返回值的泛型委托</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">public delegate TResult Func&lt;out TResult&gt;();</code></pre>
<pre class="language-c#" data-language="c#"><code class="language-c#">public class Adder
&#123;
  private int c;
  public Adder(int c) &#123; this.c &#x3D; c; &#125;
  public int Add(int a, int b)
  &#123;
    return a + b + c;
  &#125;
&#125;

public static void Main(string[] args)
&#123;
  Adder adder &#x3D; new Adder(1);
  &#x2F;&#x2F;第一个参数是返回值类型，后面的参数是输入参数类型
  Func&lt;int, int, int&gt; method &#x3D; adder.Add;
  &#x2F;&#x2F;使用时不需要写返回值参数
  Console.WriteLine(method(2, 3));
&#125;</code></pre>
<h3 id="事件">事件</h3>
<p><em>这里的事件指CLR事件模型，详细内容见下文</em></p>
<p>委托：把工作委托给了某个函数，可以直接调用</p>
<p>事件：订阅者侦听发行者，发行者可以通过回调函数间接让订阅者干事（而且订阅者具体干什么，要看订阅者心情，发行者无权过问）</p>
<pre class="language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F;事件参数
public class MyEventArgs: EventArgs
&#123;
  public string Args
  &#123;
    private set;
    get;
  &#125;
  public MyEventArgs(string args)
  &#123;
    Args &#x3D; args;
  &#125;
&#125;
&#x2F;&#x2F;事件发行者
public class EventSource
&#123;
  MyEventArgs eventArgs;

  public string Name;

  public EventSource(string args)
  &#123;
    eventArgs &#x3D; new MyEventArgs(args);
  &#125;

  public delegate void handlerEvent(Object sender, MyEventArgs args);

  public event handlerEvent m_handler_event;

  public void Handler()
  &#123;
    m_handler_event?.Invoke(this, eventArgs);
    &#x2F;&#x2F;也可以写成 m_handler_event(this, eventArgs);
  &#125;
&#125;</code></pre>
<pre class="language-C#" data-language="C#"><code class="language-C#">&#x2F;&#x2F;事件订阅者
class MainClass
&#123;
  public static void Main(string[] args)
  &#123;
    EventSource source &#x3D; new EventSource(&quot;Event had been raised!&quot;);
    source.Name &#x3D; &quot;Tim&quot;;
    source.m_handler_event +&#x3D; new EventSource.handlerEvent(writeHello);
    &#x2F;&#x2F;也可以写成 source.m_handler_event +&#x3D; writeHello;
    source.Handler();		&#x2F;&#x2F;输出：Hello Tim, Event had been raised!
  &#125;

  static void writeHello(Object sender, MyEventArgs args)
  &#123;
    EventSource source &#x3D; sender as EventSource;
    Console.WriteLine($&quot;Hello &#123;source.Name&#125;, &#123;args.Args&#125;&quot;);
  &#125;
&#125;</code></pre>
<p>最初我很好奇，我们注册了一个处理函数，<code>source.m_handler_event += writeHello</code>，但是好像没看到怎么传参进去。</p>
<p>其实是因为C#的委托本质是一个支持<code>()</code>运算符的对象，所有处理函数形式上跟委托一致，参数是委托对象的成员变量</p>
<p>一个事件可以注册多个处理函数，于是事件也称为多重委托</p>
<h2 id="二、Binding">二、Binding</h2>
<h3 id="逻辑层与UI层">逻辑层与UI层</h3>
<p>程序 = 数据 + 算法</p>
<p>三层结构：存储、逻辑、展示（UI）</p>
<p>逻辑层可以访问UI层的数据，但展示层不能访问逻辑层，UI层能显示信息，靠的是绑定逻辑层数据</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">this.textBoxName.SetBinding(TextBox.TextProperty, new Binding(&quot;Name&quot;) &#123; Source &#x3D; stu &#x3D; new Student() &#125;);</code></pre>
<p>UI层不仅可以绑定逻辑层数据，也可以绑定UI层数据</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">&#x2F;&#x2F;为 Text属性设置 Binding为 slider1的...
&lt;TextBox x:Name&#x3D;&quot;textBox2&quot; Text&#x3D;&quot;&#123;Binding Value, ElementName&#x3D;slider1&#125;&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;</code></pre>
<p>在XAML中加入</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">xmlns:local&#x3D;&quot;clr-namespace:BindingStudy&quot;</code></pre>
<p>即可在XAML中使用BindingStudy命名空间里C#定义的类</p>
<h3 id="绑定的实现">绑定的实现</h3>
<p>绑定实现的机制：源对象的属性（Property）发生改变时，会Invoke一个事件，Binding负责侦听这个事件</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">class Student : INotifyPropertyChanged
&#123;
    public event PropertyChangedEventHandler PropertyChanged;
    private string name;
    public string Name
    &#123;
        get &#123; return name; &#125;
        set
        &#123;
            name &#x3D; value;
            if(this.PropertyChanged !&#x3D; null)
            &#123;
                this.PropertyChanged.Invoke(this, new PropertyChangedEventArgs(&quot;Name&quot;));
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="Path">Path</h3>
<p>源对象往往会有多个属性，我们可以使用Path，设置绑定那些属性，而且Path支持多级路径（简单说就是一直点下去）和索引器（Indexer）</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">&lt;TextBox x:Name&#x3D;&quot;textBoxName&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
&lt;TextBox x:Name&#x3D;&quot;textBox1&quot; Text&#x3D;&quot;&#123;Binding Path&#x3D;Text.Length, ElementName&#x3D;textBoxName, Mode&#x3D;OneWay&#125;&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;          
&lt;TextBox x:Name&#x3D;&quot;textBox2&quot; Text&#x3D;&quot;&#123;Binding Path&#x3D;Text.[3], ElementName&#x3D;textBoxName, Mode&#x3D;OneWay&#125;&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;</code></pre>
<p><img src="/images/Path.png" alt="Path"></p>
<p>此外Path也支持多级斜线（也是可以一直斜线下去，其中&quot;/&quot;就是自身）</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">this.textBoxName.SetBinding(TextBox.TextProperty, new Binding(&quot;&#x2F;Length&quot;) &#123; Source &#x3D; stringList &#125;);</code></pre>
<p>当源数据本身就是数据（比如int、string类型），我们可以不写Path，或者将Path省略为&quot;.&quot;</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">this.textBlock1.SetBinding(TextBlock.TextProperty, new Binding(&quot;.&quot;) &#123; Source &#x3D; str &#125;);</code></pre>
<h3 id="集合">集合</h3>
<pre class="language-XML" data-language="XML"><code class="language-XML">&lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt;
    &lt;TextBlock Text&#x3D;&quot;Student ID:&quot; FontWeight&#x3D;&quot;Bold&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
    &lt;TextBox x:Name&#x3D;&quot;textBoxId&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
    &lt;TextBlock Text&#x3D;&quot;Student List:&quot; FontWeight&#x3D;&quot;Bold&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
    &lt;ListBox x:Name&#x3D;&quot;listBoxStudents&quot; Height&#x3D;&quot;110&quot; Margin&#x3D;&quot;5&quot;&gt;
        &lt;ListBox.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;StackPanel Orientation&#x3D;&quot;Horizontal&quot;&gt;
                    &lt;TextBlock Text&#x3D;&quot;&#123;Binding Path&#x3D;Id&#125;&quot; Width&#x3D;&quot;30&quot;&#x2F;&gt;
                    &lt;TextBlock Text&#x3D;&quot;&#123;Binding Path&#x3D;Name&#125;&quot; Width&#x3D;&quot;60&quot;&#x2F;&gt;
                    &lt;TextBlock Text&#x3D;&quot;&#123;Binding Path&#x3D;Age&#125;&quot; Width&#x3D;&quot;30&quot;&#x2F;&gt;
                &lt;&#x2F;StackPanel&gt;
            &lt;&#x2F;DataTemplate&gt;
        &lt;&#x2F;ListBox.ItemTemplate&gt;
    &lt;&#x2F;ListBox&gt;

&lt;&#x2F;StackPanel&gt;
public MainWindow()
&#123;
    InitializeComponent();
    List&lt;Student&gt; stuList &#x3D; new List&lt;Student&gt;()
    &#123;
        new Student()&#123;Id&#x3D;0, Name&#x3D;&quot;赵&quot;, Age&#x3D;21&#125;,
        new Student()&#123;Id&#x3D;1, Name&#x3D;&quot;钱&quot;, Age&#x3D;22&#125;,
        new Student()&#123;Id&#x3D;2, Name&#x3D;&quot;孙&quot;, Age&#x3D;11&#125;,
        new Student()&#123;Id&#x3D;3, Name&#x3D;&quot;李&quot;, Age&#x3D;50&#125;,
        new Student()&#123;Id&#x3D;4, Name&#x3D;&quot;周&quot;, Age&#x3D;44&#125;,
    &#125;;
    this.listBoxStudents.ItemsSource &#x3D; stuList;
    &#x2F;&#x2F;this.listBoxStudents.DisplayMemberPath &#x3D; &quot;Name&quot;;

    Binding binding &#x3D; new Binding(&quot;SelectedItem.Id&quot;) &#123; Source &#x3D; this.listBoxStudents &#125;;
    this.textBoxId.SetBinding(TextBox.TextProperty, binding);
&#125;</code></pre>
<p><img src="/images/%E9%9B%86%E5%90%88.png" alt="集合"></p>
<h3 id="XML">XML</h3>
<p>SOAP（Simple Object Access Protocel，简单对象访问协议）：一种基于XML的数据交换协议</p>
<pre class="language-XML" data-language="XML"><code class="language-XML">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot; ?&gt;
&lt;StudentList&gt;
        &lt;Student Id&#x3D;&quot;0&quot;&gt;
                &lt;Name&gt;赵&lt;&#x2F;Name&gt;
        &lt;&#x2F;Student&gt;
        &lt;Student Id&#x3D;&quot;1&quot;&gt;
                &lt;Name&gt;钱&lt;&#x2F;Name&gt;
        &lt;&#x2F;Student&gt;
        &lt;Student Id&#x3D;&quot;2&quot;&gt;
                &lt;Name&gt;孙&lt;&#x2F;Name&gt;
        &lt;&#x2F;Student&gt;
        &lt;Student Id&#x3D;&quot;3&quot;&gt;
                &lt;Name&gt;李&lt;&#x2F;Name&gt;
        &lt;&#x2F;Student&gt;
        &lt;Student Id&#x3D;&quot;4&quot;&gt;
                &lt;Name&gt;周&lt;&#x2F;Name&gt;
        &lt;&#x2F;Student&gt;
&lt;&#x2F;StudentList&gt;
&lt;ListView x:Name&#x3D;&quot;listViewStudents&quot; Height&#x3D;&quot;130&quot; Margin&#x3D;&quot;5&quot;&gt;
    &lt;ListView.View&gt;
        &lt;GridView&gt;
            &lt;GridViewColumn Header&#x3D;&quot;Id&quot; Width&#x3D;&quot;80&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding XPath&#x3D;@Id&#125;&quot;&#x2F;&gt;
            &lt;GridViewColumn Header&#x3D;&quot;Name&quot; Width&#x3D;&quot;120&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding XPath&#x3D;Name&#125;&quot;&#x2F;&gt;
        &lt;&#x2F;GridView&gt;
    &lt;&#x2F;ListView.View&gt;
&lt;&#x2F;ListView&gt;
&lt;Button Content&#x3D;&quot;Load Click&quot; Click&#x3D;&quot;Button_Click&quot; Height&#x3D;&quot;25&quot; Margin&#x3D;&quot;5,0&quot;&#x2F;&gt;
 private void Button_Click(object sender, RoutedEventArgs e)
&#123;
    XmlDataProvider xdp &#x3D; new XmlDataProvider();
    xdp.Source &#x3D; new Uri(@&quot;D:\code\BindingStudy\BindingStudy\RawData.xml&quot;);
    xdp.XPath &#x3D; @&quot;&#x2F;StudentList&#x2F;Student&quot;;

    this.listViewStudents.DataContext &#x3D; xdp;
    this.listViewStudents.SetBinding(ListView.ItemsSourceProperty, new Binding());
&#125;</code></pre>
<p><img src="/images/xml.png" alt="xml"></p>
<h3 id="LINQ">LINQ</h3>
<p>LINQ（Language-Integrated Query，语言集成查询）：一种对象查询机制，查询的结果为IEnumerable<T>类型</p>
<pre class="language-XML" data-language="XML"><code class="language-XML">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot; ?&gt;
&lt;StudentList&gt;
        &lt;Class&gt;
                &lt;Student Id&#x3D;&quot;0&quot; Name&#x3D;&quot;Tim&quot; Age&#x3D;&quot;29&quot;&#x2F;&gt;
                &lt;Student Id&#x3D;&quot;1&quot; Name&#x3D;&quot;Tom&quot; Age&#x3D;&quot;20&quot;&#x2F;&gt;
                &lt;Student Id&#x3D;&quot;2&quot; Name&#x3D;&quot;Mess&quot; Age&#x3D;&quot;9&quot;&#x2F;&gt;
        &lt;&#x2F;Class&gt;
        &lt;Class&gt;
                &lt;Student Id&#x3D;&quot;3&quot; Name&#x3D;&quot;Tony&quot; Age&#x3D;&quot;2&quot;&#x2F;&gt;
                &lt;Student Id&#x3D;&quot;4&quot; Name&#x3D;&quot;Viv&quot; Age&#x3D;&quot;23&quot;&#x2F;&gt;
                &lt;Student Id&#x3D;&quot;5&quot; Name&#x3D;&quot;Oio&quot; Age&#x3D;&quot;88&quot;&#x2F;&gt;
        &lt;&#x2F;Class&gt;
&lt;&#x2F;StudentList&gt;
&lt;ListView x:Name&#x3D;&quot;listViewStudents&quot; Height&#x3D;&quot;130&quot; Margin&#x3D;&quot;5&quot;&gt;
    &lt;ListView.View&gt;
        &lt;GridView&gt;
            &lt;GridViewColumn Header&#x3D;&quot;Id&quot; Width&#x3D;&quot;80&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding Id&#125;&quot;&#x2F;&gt;
            &lt;GridViewColumn Header&#x3D;&quot;Name&quot; Width&#x3D;&quot;120&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding Name&#125;&quot;&#x2F;&gt;
            &lt;GridViewColumn Header&#x3D;&quot;Age&quot; Width&#x3D;&quot;80&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding Age&#125;&quot;&#x2F;&gt;
        &lt;&#x2F;GridView&gt;
    &lt;&#x2F;ListView.View&gt;
&lt;&#x2F;ListView&gt;
private void Button_Click(object sender, RoutedEventArgs e)
&#123;
    XDocument doc &#x3D; XDocument.Load(@&quot;D:\code\BindingStudy\BindingStudy\RawData.xml&quot;);
    this.listViewStudents.ItemsSource &#x3D;
        from element in doc.Descendants(&quot;Student&quot;)
        where element.Attribute(&quot;Name&quot;).Value.StartsWith(&quot;T&quot;)
        select new Student()
        &#123;
            Id &#x3D; int.Parse(element.Attribute(&quot;Id&quot;).Value),
            Name &#x3D; element.Attribute(&quot;Name&quot;).Value,
            Age &#x3D; int.Parse(element.Attribute(&quot;Age&quot;).Value)
        &#125;;
    
&#125;
class Student
&#123;
    public int Id &#123; get; set; &#125;
    public string Name &#123; get; set; &#125;
    public int Age &#123; get; set; &#125;
&#125;</code></pre>
<p><img src="/images/LINQ.png" alt="LINQ"></p>
<h3 id="校验">校验</h3>
<p>“你永远不能相信来自前端的数据”</p>
<p>我们认为Source的数据一定是正确的，但Target的数据是有可能出现问题的</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">public partial class MainWindow : Window
&#123;
    public MainWindow()
    &#123;
        InitializeComponent();

        Binding binding &#x3D; new Binding(&quot;Value&quot;) &#123; Source &#x3D; this.slider1 &#125;;
        binding.UpdateSourceTrigger &#x3D; UpdateSourceTrigger.PropertyChanged;    &#x2F;&#x2F;当源数据改变时进行校验
        RangeValidationRule rvr &#x3D; new RangeValidationRule();
        rvr.ValidatesOnTargetUpdated &#x3D; true;    &#x2F;&#x2F;当Target数据改变时进行校验
        binding.ValidationRules.Add(rvr);
        binding.NotifyOnValidationError &#x3D; true;
        this.textBox1.SetBinding(TextBox.TextProperty, binding);
        this.textBox1.AddHandler(Validation.ErrorEvent, new RoutedEventHandler(this.ValidationError));
    &#125;

    &#x2F;&#x2F;若校验失败，将失败信息添加到 ToolTip上
    void ValidationError(object sender, RoutedEventArgs e)
    &#123;
        if(Validation.GetErrors(this.textBox1).Count &gt; 0)
        &#123;
            this.textBox1.ToolTip &#x3D; Validation.GetErrors(this.textBox1)[0].ErrorContent.ToString();
        &#125;
        else
        &#123;
            this.textBox1.ToolTip &#x3D; null;
        &#125;
    &#125;
&#125;
&lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt;
    &lt;TextBox x:Name&#x3D;&quot;textBox1&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
    &lt;Slider x:Name&#x3D;&quot;slider1&quot; Minimum&#x3D;&quot;-10&quot; Maximum&#x3D;&quot;110&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
&lt;&#x2F;StackPanel&gt;
class RangeValidationRule : ValidationRule
&#123;
    &#x2F;&#x2F;对数据范围进行校验，仅当在[0,100]时校验通过，校验失败时返回信息
    public override ValidationResult Validate(object value, CultureInfo cultureInfo)
    &#123;
        double d &#x3D; 0;
        if(double.TryParse(value.ToString(), out d))
        &#123;
            if(d &gt;&#x3D; 0 &amp;&amp; d &lt;&#x3D; 100)
            &#123;
                return new ValidationResult(true, null);
            &#125;
        &#125;
        return new ValidationResult(false, &quot;Validation Failed!!!&quot;);
    &#125;
&#125;</code></pre>
<p><img src="/images/%E6%A0%A1%E9%AA%8C.png" alt="校验"></p>
<h3 id="数据转换">数据转换</h3>
<p>Slider的Value是double类型，TextBox的Text是string类型，但是Binding后数据往来自如，是因为数据转化机制</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">class ClassAToClassBConverter : IValueConverter
&#123;
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    &#123;
        ...
    &#125;

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    &#123;
        ...
    &#125;
&#125;
&lt;Window x:Class&#x3D;&quot;BindingStudy.MainWindow&quot;
        ...
    &lt;Window.Resources&gt;
        &lt;local:ClassAToClassBConverter x:Key&#x3D;&quot;atb&quot;&#x2F;&gt;
    &lt;&#x2F;Window.Resources&gt;
    &lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt;
        ...
        &lt;&#x2F;images Width&#x3D;&quot;20&quot; Height&#x3D;&quot;20&quot; Source&#x3D;&quot;&#123;Binding Path&#x3D;A, Converter&#x3D;&#123;StaticResource atb&#125;&#125;&quot;&#x2F;&gt;
    &lt;&#x2F;StackPanel&gt;
&lt;&#x2F;Window&gt;</code></pre>
<h2 id="三、属性">三、属性</h2>
<h3 id="英语中的属性">英语中的属性</h3>
<p>Property是物体自带的属性</p>
<p>Attribute是物体的描述属性</p>
<p>张三是中国人，身上有一百块钱。中国人是张三的Attribute, 100块钱是张三的property</p>
<h3 id="C-中的属性">C#中的属性</h3>
<p>将字段设为private，使用一对非private的方法来包装它，以实现<strong>高内聚</strong></p>
<p>C#中提供语法糖，将Get和Set合并为了属性（Property），这种属性也被称为CLR（Common Language Runtime）属性</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">class Student
&#123;
    private string name;
    public string Name &#123; get; set; &#125;
&#125;</code></pre>
<p>此外反编译后发现，属性的本质是两个函数，并不会增加字段数量（不额外占内存）</p>
<h3 id="依赖属性">依赖属性</h3>
<p>（WPF属性加强版）</p>
<p>依赖属性（Dependency Property）可以自己没有值，通过Binding从数据源获得值</p>
<p>拥有依赖属性的对象被称为依赖对象</p>
<p>传统开发中，对象所占用的内存在进行实例化时就确定（分配）了，而依赖属性可以允许对象不分配部分空间</p>
<pre class="language-C#" data-language="C#"><code class="language-C#">class Student : DependencyObject
&#123;
    &#x2F;&#x2F;依赖对象的 CLR封装
    public string Name
    &#123;
        get &#123; return (string)GetValue(NameProperty); &#125;
        set &#123; SetValue(NameProperty, value); &#125;
    &#125;
    &#x2F;&#x2F;依赖对象
    public static readonly DependencyProperty NameProperty &#x3D; DependencyProperty.Register(&quot;Name&quot;, typeof(string), typeof(Student));  
    &#x2F;&#x2F;Binding封装
    public BindingExpressionBase SetBinding(DependencyProperty dp, BindingBase binding)
    &#123;
        return BindingOperations.SetBinding(this, dp, binding);
    &#125;
&#125;</code></pre>
<ul>
<li>“Name”：指明使用哪一个 CLR属性作为这个依赖属性的包装器 (Wrapper)</li>
<li>typeof(string)：指明此依赖属性用来储存什么类型的值</li>
<li>typeof(Student))：指明此依赖属性要注册关联到谁身上</li>
</ul>
<pre class="language-XML" data-language="XML"><code class="language-XML">&lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt;
    &lt;TextBox x:Name&#x3D;&quot;textBox1&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
    &lt;TextBox x:Name&#x3D;&quot;textBox2&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;
&lt;&#x2F;StackPanel&gt;
public partial class MainWindow : Window
&#123;
    Student stu;
    public MainWindow()
    &#123;
        InitializeComponent();

        stu &#x3D; new Student();
        stu.SetBinding(Student.NameProperty, new Binding(&quot;Text&quot;) &#123; Source &#x3D; textBox1 &#125;);
        textBox2.SetBinding(TextBox.TextProperty, new Binding(&quot;Name&quot;) &#123; Source &#x3D; stu &#125;);
    &#125;
&#125;</code></pre>
<p>我们还发现，依赖对象并没有实现INotifyPropertyChanged接口，但是当期值发生改变时，与之相关的Binding对象依然可以得到通知，于是依赖对象是天生的合格源数据</p>
<p>在VS中，输入propdp并按两次tab，就能得到一个依赖属性模板</p>
<h4 id="依赖属性的注册">依赖属性的注册</h4>
<p>前文我们获得依赖对象的实例时，是通过<code>DependencyProperty.Register</code>注册得到：</p>
<ol>
<li>创建DependencyProperty实例，并使用其CLR属性名的哈希异或宿主类型的哈希，得到key（通过其他算法，保证唯一）</li>
<li>将key和实例存储到一张全局的HashTable上</li>
</ol>
<pre class="language-C#" data-language="C#"><code class="language-C#">GlobalIndex &#x3D; CLR属性名的HaseCode XOR 宿主类型HashCode</code></pre>
<p>于是运行时只要知道CLR属性名和宿主，就能找到依赖对象实例</p>
<h4 id="依赖属性的读写">依赖属性的读写</h4>
<p>依赖属性对象的作用是检索真正的属性值，而非存储属性值</p>
<p>每个DependencyObject实例都自带一个数组，当某个依赖属性的值要被读取时，算法会在这个数组中检索。而用于检索的键值，实际上就是依赖属性的GlobalIndex</p>
<p>也就是说，这个被static readonly修饰的属性，它的作用是一个“标记”，当你需要找某个东西时，就来这里拼一个id，用id查数组</p>
<h3 id="附加属性">附加属性</h3>
<p>附加属性（Attached Properties）：一个属性本不属于某个对象，但由于某种需求后来附加上。换句话说，将对象放入一个特定环境后，才会具有出来的属性</p>
<p>举个例子，比如Human这个类，它可以有很多很多种属性，现在我们想在里面加入一个新的需求，如果我们直接改动这个类，过于繁琐。而如果提前留好空，那么有时候又会空间浪费</p>
<p>附加属性的作用就是让宿主和属性解耦，让宿主的设计更为灵活</p>
<h2 id="四、事件">四、事件</h2>
<h3 id="消息">消息</h3>
<p>事件的前身是消息（Message），Windows系统就是一个消息驱动的操作系统，后来微软为了降低开发难度，将消息系统封装为了事件模型</p>
<h3 id="CLR事件模型">CLR事件模型</h3>
<p>CLR事件模型由三部分组成</p>
<ul>
<li>事件的拥有者：即消息的发送者</li>
<li>事件的响应者：即消息的接收者，它可以使用事件处理器（Event Handler）对事件做相应</li>
<li>事件的订阅关系：事件的拥有者可以随时激发事件，但只有关注（订阅）了这个事件的响应者会对此产生反应</li>
</ul>
<p>事件本质上就是一个使用event关键字修饰的委托（Delegate）类型成员变量，事件处理器是一个函数</p>
<p>A订阅了B，实际上就是让B.Event和A.EventHandler关联起来</p>
<p>事件激发就是B.Event被调用</p>
<h4 id="举例">举例</h4>
<p>Windows Form按按钮</p>
<table>
<thead>
<tr>
<th>事件的拥有者</th>
<th>button</th>
</tr>
</thead>
<tbody>
<tr>
<td>事件</td>
<td>button.Click</td>
</tr>
<tr>
<td>事件的响应者</td>
<td>窗体</td>
</tr>
<tr>
<td>事件处理器</td>
<td>this.button_Click()</td>
</tr>
<tr>
<td>订阅关系</td>
<td>this.button.Click += new System.EventHandler(this.button_Click)</td>
</tr>
</tbody>
</table>
<h3 id="路由事件">路由事件</h3>
<p>（WPF事件加强版）</p>
<p>路由事件没有显示订阅关系</p>
<ul>
<li>事件拥有者只负责激发事件，至于谁会倾听，他并不知道</li>
<li>事件响应者装有事件倾听器，若有事件传递于此，可以决定事件是否可以继续传递
<ul>
<li>如果事件不归他管，那就踢给下一个人，继续传播</li>
<li>若事件归他管，那就进行处理，并判断是否还需要传给下一个人</li>
</ul>
</li>
</ul>
<pre class="language-C#" data-language="C#"><code class="language-C#">public abstract class ButtonBase : ContentControl, ICommandSource
&#123;
    &#x2F;&#x2F;声明并注册路由事件
    public static readonly RoutedEvent ClickEvent &#x3D; EventManager.RegisterRoutedEvent(&quot;Click&quot;, 
        RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(ButtonBase));

    &#x2F;&#x2F;为路由事件添加 CLR事件包装器
    public event RoutedEventHandler Click
    &#123;
        add &#123; this.AddHandler(ClickEvent, value); &#125;
        remove &#123; this.RemoveHandler(ClickEvent, value); &#125;
    &#125;
    
    &#x2F;&#x2F;激活路由事件的方法
    protected virtual void OnClick()
    &#123;
        RoutedEventArgs newEvent &#x3D; new RoutedEventArgs(ButtonBase.ClickEvent, this);
        this.RaiseEvent(newEvent);
    &#125;
&#125;</code></pre>
<p>WPF路由事件有三种策略</p>
<ul>
<li>Bubble：冒泡式，激发者向其上级一层一层路由，直到到根，路径是确定且唯一</li>
<li>Tunnel：隧道式，激发者向其下级一层一层路由，路径有很多，但朝向响应者移动，就像形成一个隧道</li>
<li>Direct：直达式，类似CLR事件，直接向响应者发送事件</li>
</ul>
<h2 id="五、命令">五、命令</h2>
<p>事件不具有约束力，事件接收者使用自己的行为响应事件</p>
<p>命令具有约束力，当命令到达某个组件时，会主动调用组件的某个方法</p>
<h3 id="命令系统">命令系统</h3>
<ul>
<li>命令（Command）：实现ICommand接口</li>
<li>命令源（Command Source）：实现ICommandSource接口</li>
<li>命令目标（Command Target）：实现IInputElement接口</li>
<li>命令关联（Command Binding）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/01/program/Csharpe/" data-id="clepy40oz002jglnk4l6le43l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/02/01/program/CMake%E5%85%A5%E9%97%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          CMake入门
        
      </div>
    </a>
  
  
    <a href="/2023/01/31/dcc/maya%E6%8F%92%E4%BB%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Maya插件开发</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/dcc/">dcc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/engine/">engine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/graphics/">graphics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/math/">math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/optics/">optics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/program/">program</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DX12/" rel="tag">DX12</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deferred-Render/" rel="tag">Deferred Render</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metal/" rel="tag">Metal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PM/" rel="tag">PM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Physics/" rel="tag">Physics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SIGGRAPH/" rel="tag">SIGGRAPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPH/" rel="tag">SPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TA/" rel="tag">TA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unreal/" rel="tag">Unreal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shader/" rel="tag">shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%89%E5%AD%A6/" rel="tag">光学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" rel="tag">并行计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" rel="tag">微积分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C#</a> <a href="/tags/C/" style="font-size: 17.5px;">C++</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/DX12/" style="font-size: 10px;">DX12</a> <a href="/tags/Deferred-Render/" style="font-size: 10px;">Deferred Render</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/GI/" style="font-size: 15px;">GI</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Metal/" style="font-size: 10px;">Metal</a> <a href="/tags/PM/" style="font-size: 10px;">PM</a> <a href="/tags/Physics/" style="font-size: 12.5px;">Physics</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/SIGGRAPH/" style="font-size: 15px;">SIGGRAPH</a> <a href="/tags/SPH/" style="font-size: 12.5px;">SPH</a> <a href="/tags/TA/" style="font-size: 15px;">TA</a> <a href="/tags/Unity/" style="font-size: 12.5px;">Unity</a> <a href="/tags/Unreal/" style="font-size: 10px;">Unreal</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/shader/" style="font-size: 10px;">shader</a> <a href="/tags/%E5%85%89%E5%AD%A6/" style="font-size: 20px;">光学</a> <a href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" style="font-size: 10px;">并行计算</a> <a href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" style="font-size: 10px;">微积分</a> <a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 17.5px;">高等数学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/02/26/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/">光学复习</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E8%A1%8D%E5%B0%84/">衍射</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E5%B9%B2%E6%B6%89/">干涉</a>
          </li>
        
          <li>
            <a href="/2023/02/18/program/AskQuestion/">提问的智慧</a>
          </li>
        
          <li>
            <a href="/2023/02/13/graphics/DOSDF/">Dynamic Occlusion with SDF</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Reuben Sun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>