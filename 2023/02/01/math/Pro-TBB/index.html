<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Pro-TBB | ReubenSun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Pro TBB 在摩尔定律逐渐失效的今日，CPU主频和单核性能提升越来越不明显，为了得到跟高的性能，我们走向了并行计算的道路 概念 并发和并行   并发（Concurrent）：happening during the same time span，处理器在两件事间快速切换，宏观上看，就像是同时发生的（下图AB）   并行（Parallel）：happening at the same time，">
<meta property="og:type" content="article">
<meta property="og:title" content="Pro-TBB">
<meta property="og:url" content="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/index.html">
<meta property="og:site_name" content="ReubenSun">
<meta property="og:description" content="Pro TBB 在摩尔定律逐渐失效的今日，CPU主频和单核性能提升越来越不明显，为了得到跟高的性能，我们走向了并行计算的道路 概念 并发和并行   并发（Concurrent）：happening during the same time span，处理器在两件事间快速切换，宏观上看，就像是同时发生的（下图AB）   并行（Parallel）：happening at the same time，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/Image/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C.png">
<meta property="og:image" content="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/Image/FlowGraph.jpeg">
<meta property="og:image" content="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/Image/树形归并.png">
<meta property="og:image" content="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/Image/reduce.png">
<meta property="og:image" content="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/Image/sight.png">
<meta property="og:image" content="http://reuben-sun.github.io/images/前向替换.png">
<meta property="og:image" content="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/Image/join.jpg">
<meta property="og:image" content="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/Image/%E5%89%8D%E5%90%91%E6%9B%BF%E6%8D%A2.jpg">
<meta property="og:image" content="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/Image/%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7.png">
<meta property="article:published_time" content="2023-02-01T10:01:25.000Z">
<meta property="article:modified_time" content="2023-03-01T17:22:20.537Z">
<meta property="article:author" content="Reuben Sun">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="并行计算">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/Image/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C.png">
  
    <link rel="alternate" href="/atom.xml" title="ReubenSun" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ReubenSun</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://reuben-sun.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-math/Pro-TBB" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/01/math/Pro-TBB/" class="article-date">
  <time datetime="2023-02-01T10:01:25.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Pro-TBB
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Pro TBB</h1>
<p>在摩尔定律逐渐失效的今日，CPU主频和单核性能提升越来越不明显，为了得到跟高的性能，我们走向了并行计算的道路</p>
<h2 id="概念">概念</h2>
<h3 id="并发和并行">并发和并行</h3>
<ul>
<li>
<p>并发（Concurrent）：happening during the same time span，处理器在两件事间快速切换，宏观上看，就像是同时发生的（下图AB）</p>
</li>
<li>
<p>并行（Parallel）：happening at the same time，多个处理器一起做事（下图CD）</p>
</li>
</ul>
<p><img src="Image/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C.png" alt="并发和并行"></p>
<h2 id="TBB基础">TBB基础</h2>
<p>TBB（Threading Building Blocks）是一个非常流行的C++并行编程（parallel programming）方案</p>
<ul>
<li>
<p>使用Task而非Thread</p>
<ul>
<li>Thread与硬件相关，直接编写难以跨平台，而且线程间通信过于频繁，过于繁琐</li>
<li>TBB使用Task编程，运行时会将程序映射到硬件上（该方法对嵌套并行的支持很不错）</li>
<li>TBB任务调度使用<strong>工作窃取</strong>，当一个任务队列执行完毕后，核心会去其他任务队列中窃取任务，于是可以提高核心的利用率</li>
</ul>
</li>
<li>
<p>TBB实现了可组合性（Composability）</p>
<ul>
<li>简单来说就是支持for循环</li>
</ul>
</li>
<li>
<p>方便移植（portable）</p>
</li>
</ul>
<h3 id="Mac上安装使用TBB">Mac上安装使用TBB</h3>
<ol>
<li>安装tbb</li>
</ol>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$brew</span> <span class="token function">install</span> tbb</code></pre>
<ol start="2">
<li>链接tbb</li>
</ol>
<pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#寻找tbb包</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>TBB REQUIRED<span class="token punctuation">)</span>
...
<span class="token comment">#链接</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>TimeStudy <span class="token inserted class-name">TBB::tbb</span><span class="token punctuation">)</span></code></pre>
<ol start="3">
<li>引用头文件</li>
</ol>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;tbb&#x2F;tbb.h&gt;</code></pre>
<h3 id="在Ubuntu上安装TBB">在Ubuntu上安装TBB</h3>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libtbb-dev</code></pre>
<h3 id="调用函数">调用函数</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Func0, [...,] typename FuncN&gt;
void parallel_invoke(const Func0&amp; f0, [...,] const FuncN&amp; fN);</code></pre>
<p>一个简单的TBB示例，并行输出两行字符串</p>
<p>通过<code>tbb::parallel_invoke</code>实现任务、函数粒度的并行</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;tbb&#x2F;tbb.h&gt;

int main() &#123;
    tbb::parallel_invoke(
            []()&#123;std::cout &lt;&lt; &quot;TBB!&quot; &lt;&lt; std::endl;&#125;,
            []()&#123;std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;&#125;
            );
    return 0;
&#125;</code></pre>
<p>我们这里使用lambda表达式创建了匿名（anonymous）函数，可以大幅简化TBB编写</p>
<h4 id="快排示例">快排示例</h4>
<p>传统快排算法（升序）</p>
<ol>
<li>在数列中取一个数作为基准数</li>
<li>比基准小的放在基准左边，大的放在右边</li>
<li>对左右两边分别快排，直到只剩一个数（左右重合）</li>
</ol>
<p>能看出，这个算法采用了分治的思想，很适合并行</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;tbb&#x2F;tbb.h&gt;

using QV &#x3D; std::vector&lt;int&gt;;
&#x2F;&#x2F;传统快排
void quickSort(QV::iterator left, QV::iterator right)&#123;
    if(left &gt;&#x3D; right)&#123; return; &#125;
    int pivot_value &#x3D; *left;
    QV::iterator i &#x3D; left, j &#x3D; right - 1;
    while(i !&#x3D; j)&#123;
        while(i !&#x3D; j &amp;&amp; pivot_value &lt; *j) --j;    &#x2F;&#x2F;从右向左找，直到找到一个比基准小的
        while(i !&#x3D; j &amp;&amp; pivot_value &gt;&#x3D; *i) ++i;   &#x2F;&#x2F;从左往右找，直到找到一个比基准大的
        std::iter_swap(i, j);
    &#125;
    std::iter_swap(left, i);
    quickSort(left, i);
    quickSort(j+1, right);
&#125;
&#x2F;&#x2F;并行快排
void parallelQuicksort(QV::iterator left, QV::iterator right)&#123;
    if(left &gt;&#x3D; right)&#123; return; &#125;
    int pivot_value &#x3D;  *left;
    QV::iterator i &#x3D; left, j &#x3D; right - 1;
    while (i !&#x3D; j) &#123;
        while (i !&#x3D; j &amp;&amp; pivot_value &lt; *j) --j;
        while (i !&#x3D; j &amp;&amp; pivot_value &gt;&#x3D; *i) ++i;
        std::iter_swap(i, j);
    &#125;
    std::iter_swap(left, i);

    &#x2F;&#x2F; recursive call
    tbb::parallel_invoke(
      			&#x2F;&#x2F;lambda表达式[&#x3D;]表示传入当前函数所有的成员
            [&#x3D;]() &#123; parallelQuicksort(left, i); &#125;,
            [&#x3D;]() &#123; parallelQuicksort(i + 1, right); &#125;
    );

&#125;
&#x2F;&#x2F;使用cutoff
void parallelCutoffQuicksort(QV::iterator left, QV::iterator right)&#123;
    const int cutoff &#x3D; 100;

    if (right - left &lt; cutoff) &#123;
        quickSort(right, left);
    &#125;
    else &#123;
        int pivot_value &#x3D;  *left;
        QV::iterator i &#x3D; left, j &#x3D; right - 1;
        while (i !&#x3D; j) &#123;
            while (i !&#x3D; j &amp;&amp; pivot_value &lt; *j) --j;
            while (i !&#x3D; j &amp;&amp; pivot_value &gt;&#x3D; *i) ++i;
            std::iter_swap(i, j);
        &#125;
        std::iter_swap(left, i);

        &#x2F;&#x2F; recursive call
        tbb::parallel_invoke(
                [&#x3D;]() &#123; parallelQuicksort(left, i); &#125;,
                [&#x3D;]() &#123; parallelQuicksort(i + 1, right); &#125;
        );
    &#125;
&#125;

int main() &#123;
    std::vector&lt;int&gt; nums;
    for(int i &#x3D; 0; i &lt; 5000; ++i)&#123;
        nums.push_back(rand() % 5000);
    &#125;
  	&#x2F;&#x2F;warmup
    tbb::parallel_for(0, 10, [](int) &#123;
        tbb::tick_count t0 &#x3D; tbb::tick_count::now();
        while ((tbb::tick_count::now() - t0).seconds() &lt; 0.01);
    &#125;);

    std::vector&lt;int&gt; nums2 &#x3D; nums;
    tbb::tick_count t0 &#x3D; tbb::tick_count::now();
    quickSort(nums.begin(), nums.end());
    std::cout &lt;&lt; &quot;Normal Time&#x3D;&quot; &lt;&lt; (tbb::tick_count::now() - t0).seconds() &lt;&lt; std::endl;

    tbb::tick_count t1 &#x3D; tbb::tick_count::now();
    parallelQuicksort(nums2.begin(), nums2.end());
    std::cout &lt;&lt; &quot;Parallel Time&#x3D;&quot; &lt;&lt; (tbb::tick_count::now() - t1).seconds() &lt;&lt; std::endl;
    return 0;
&#125;</code></pre>
<p>最后结果，当数组比较大的时候，并行快排速度会更快一点</p>
<pre class="language-none"><code class="language-none">Normal Time&#x3D;0.0023285
Parallel Time&#x3D;0.00110846</code></pre>
<p>此外tbb进行任务分配也会有开销，因此我们往往将大任务分成若干个小任务后，让小任务串型执行，上文中的cutoff就是起到这个作用，这样往往能得到更高的性能</p>
<h3 id="时刻查询">时刻查询</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;t0时刻
tbb::tick_count t0 &#x3D; tbb::tick_count::now();	
...
&#x2F;&#x2F;当前时刻-t0时刻&#x3D;经过了多长时间段（并转化为秒）
std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; (tbb::tick_count::now() - t0).seconds() &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;</code></pre>
<p>并行开发中动态内存管理十分复杂、危险（内存泄漏），这里推荐使用C++11的智能指针（自带GC）</p>
<h3 id="Flow-Graph">Flow Graph</h3>
<p>将函数执行制作成Graph，实现消息驱动的并行（有些类似FrameGraph）</p>
<p><img src="Image/FlowGraph.jpeg" alt="FlowGraph"></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void fig1_10(const std::vector&lt;ImagePtr&gt;&amp; image_vector)&#123;
    const double tint_array[] &#x3D; &#123;0.75, 0, 0&#125;;

    tbb::flow::graph g;
    int i &#x3D; 0;
    &#x2F;&#x2F;注意，source_node已经失效
    tbb::flow::input_node&lt;ImagePtr&gt; src(g,
        [&amp;i, &amp;image_vector](tbb::flow_control &amp;fc) -&gt; ImagePtr &#123;
            if(i &lt; image_vector.size())&#123;
                return image_vector[i++];
            &#125;
            else&#123;
                fc.stop();
                return &#123;&#125;;
            &#125;
    &#125;);
    tbb::flow::function_node&lt;ImagePtr, ImagePtr&gt; gamma(g,
        tbb::flow::unlimited, [] (ImagePtr img) -&gt; ImagePtr&#123;
                return applyGamma(img, 1.4);
        &#125;
    );
    tbb::flow::function_node&lt;ImagePtr, ImagePtr&gt; tint(g,
        tbb::flow::unlimited, [tint_array] (ImagePtr img) -&gt; ImagePtr&#123;
                return applyTint(img, tint_array);
        &#125;
    );
    tbb::flow::function_node&lt;ImagePtr&gt; write(g,
         tbb::flow::unlimited, [] (ImagePtr img)&#123;
                writeImage(img);
        &#125;
    );

    tbb::flow::make_edge(src, gamma);
    tbb::flow::make_edge(gamma, tint);
    tbb::flow::make_edge(tint, write);
    src.activate();
    g.wait_for_all();
&#125;</code></pre>
<p>最后该程序会以<strong>流水线</strong>的形式执行，当第一张图片完成gamma矫正，去执行tint着色时，第二张图片开始执行gamma矫正（每张图片间互不影响）</p>
<p>相比于TimeStudy的串型执行，流水线执行效率会更快</p>
<h3 id="循环">循环</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Index, typename Func&gt;
Func parallel_for(Index frist, Index last, [Index step,] const Func&amp; f);</code></pre>
<p>上面的代码，我们将图片处理切分为几个小块，但小块内部仍然是单线程</p>
<p>我们注意到，在图片处理时，有一个很大的循环在遍历图片上的像素点，那么能不能并行做这件事？</p>
<p>我们并行处理每一行</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">tbb::parallel_for(0, height,
                  [&amp;in_rows, &amp;out_rows, width, gamma](int i)&#123;
                    for(int j &#x3D; 0; j &lt; width; ++j)&#123;
                      const ImageLib::Image::Pixel&amp; p &#x3D; in_rows[i][j];
                      double v &#x3D; 0.3 * p.bgra[2] + 0.59 * p.bgra[1] + 0.11 * p.bgra[0];
                      double res &#x3D; pow(v, gamma);
                      if(res &gt; ImageLib::MAX_BGR_VALUE)&#123;
                        res &#x3D; ImageLib::MAX_BGR_VALUE;
                      &#125;
                      out_rows[i][j] &#x3D; ImageLib::Image::Pixel(res, res, res);
                    &#125;
                  &#125;
                 );</code></pre>
<pre class="language-c++" data-language="c++"><code class="language-c++">tbb::parallel_for(0, height,
                  [&amp;in_rows, &amp;out_rows, width, tints](int i)&#123;
                    for(int j &#x3D; 0; j &lt; width; ++j)&#123;
                      const ImageLib::Image::Pixel&amp; p &#x3D; in_rows[i][j];
                      std::uint8_t b &#x3D; (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[0]) * tints[0];
                      std::uint8_t g &#x3D; (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[1]) * tints[1];
                      std::uint8_t r &#x3D; (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[2]) * tints[2];
                      out_rows[i][j] &#x3D; ImageLib::Image::Pixel(
                        (b &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : b,
                        (g &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : g,
                        (r &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : r
                      );
                    &#125;
                  &#125;
                 );</code></pre>
<p>M1 Mac Xcode Clang至今不支持C++17的std::execution，对OpenMP的支持也相当差</p>
<h3 id="归约">归约</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Range, typename Value, typename Func, typename Reduction&gt;
Value parallel_reduce(const Range&amp; range, const Value&amp; identity, const Func&amp; func, const Reduction&amp; reduction);</code></pre>
<p>树形规约</p>
<img src="Image/树形归并.png" alt="树形归并" style="zoom:50%;" />
<p><img src="Image/reduce.png" alt="reduce"></p>
<h4 id="求最大值">求最大值</h4>
<p>下面是一个vector求最大值的示例，实现机制就是将整个数组分成一个个小块（chunks），分别对小块求最值，然后将小块归约（reduce），最后求得最值（形成了一个树型结构）</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int pmax(const std::vector&lt;int&gt; &amp;arr)&#123;
    int max_value &#x3D; tbb::parallel_reduce(
      			&#x2F;&#x2F;range，扫描范围
            tbb::blocked_range&lt;int&gt;(0, arr.size()),	
      			&#x2F;&#x2F;identity，小块数据的初始值，这里赋值为int类型的最小值-2147483648
            std::numeric_limits&lt;int&gt;::min(),	
      			&#x2F;&#x2F;func，每个小块的处理方式
            [&amp;](const tbb::blocked_range&lt;int&gt; &amp;r, int init) -&gt; int&#123;	
                for(int i &#x3D; r.begin(); i !&#x3D; r.end(); ++i)&#123;
                    init &#x3D; std::max(init, arr[i]);
                &#125;
                return init;
            &#125;,
      			&#x2F;&#x2F;reduction，小块间合并的处理方式
            [](int x, int y) -&gt; int&#123;
                return std::max(x, y);
            &#125;
    );
    return max_value;
&#125;</code></pre>
<p>下面这是一个求PI的示例</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">double calcPI(int degree)&#123;
    double dx &#x3D; 1.0 &#x2F; degree;
    double sum &#x3D; tbb::parallel_reduce(
      			&#x2F;&#x2F;range，扫描范围
            tbb::blocked_range&lt;int&gt;(0, degree),
      			&#x2F;&#x2F;identity，小块数据的初始值，这里赋值为0
            0.0,
      			&#x2F;&#x2F;func，每个小块的处理方式
            [&#x3D;](const tbb::blocked_range&lt;int&gt; &amp;r, double init) -&gt; double&#123;
                for(int i &#x3D; r.begin(); i !&#x3D; r.end(); ++i)&#123;
                    double x &#x3D; (i + 0.5)*dx;
                    double h &#x3D; std::sqrt(1 - x*x);  &#x2F;&#x2F;勾股定理
                    init +&#x3D; h * dx;
                &#125;
                return init;
            &#125;,
      			&#x2F;&#x2F;reduction，小块间合并的处理方式
            [](double x, double y) -&gt; double&#123;
                return x+y;
            &#125;
        );
    return 4 * sum;
&#125;</code></pre>
<h3 id="扫描">扫描</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Range, typename Value, typename Scan, typename Combine&gt;
Value parallel_scan(const Range&amp; range, const Value&amp; identity, const Scan&amp; scan, const Combine&amp; combine);</code></pre>
<h4 id="前缀和">前缀和</h4>
<p><em>前缀和在图形领域也有很大的用处</em></p>
<p>对于一个数组，我们将其分为三个小块ABC</p>
<pre class="language-none"><code class="language-none">A.init&#x3D;0, B.init&#x3D;0
scan(A), scan(B)

B.init &#x3D; A.ans
C.init &#x3D; A.ans + B.ans
scan(B), scan(C)</code></pre>
<p>最后我们只用了串行2/3的扫描时间，但是多做了1/3的扫描工作，时间减少了，但是工作量变大了</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int parallelPrefix(const std::vector&lt;int&gt; &amp;v, std::vector&lt;int&gt; &amp;psum)&#123;
    int N &#x3D; v.size();
    psum[0] &#x3D; v[0];
    int final_sum &#x3D; tbb::parallel_scan(
      			&#x2F;&#x2F;range
            tbb::blocked_range&lt;int&gt;(1, N),
      			&#x2F;&#x2F;identity
            (int)0,
      			&#x2F;&#x2F;scan body
            [&amp;v, &amp;psum](const tbb::blocked_range&lt;int&gt; &amp;r, int sum, bool is_final_scan) -&gt; int&#123;
                for(int i &#x3D; r.begin(); i &lt; r.end(); ++i)&#123;
                    sum +&#x3D; v[i];
                    if(is_final_scan)&#123;
                        psum[i] &#x3D; sum;
                    &#125;
                &#125;
                return sum;
            &#125;,
      			&#x2F;&#x2F;combine body
            [](int x, int y)&#123;
                return x+y;
            &#125;
        );
    return final_sum;
&#125;</code></pre>
<h4 id="可见性">可见性</h4>
<p>如图，等间距摆放一个个薄板（厚度忽略不计），从最右上角向左看，能看到哪些薄板？</p>
<img src="Image/sight.png" alt="sight" style="zoom:50%;" />
<p>解题的本质就是比较夹角大小，只要夹角一直递增，就能看到</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void visibility(const std::vector&lt;double&gt; &amp;heights, std::vector&lt;bool&gt; &amp; visible, double dx)&#123;
    const int N &#x3D; heights.size();
    double max_angle &#x3D; std::atan2(dx, heights[0] - heights[1]);

    double final_max_angle &#x3D; tbb::parallel_scan(
      			&#x2F;&#x2F;range
            tbb::blocked_range&lt;int&gt;(1, N),
      			&#x2F;&#x2F;identity
            0.0,
      			&#x2F;&#x2F;scan body
            [&amp;heights, &amp;visible, dx](const tbb::blocked_range&lt;int&gt; &amp;r, double max_angle, bool is_final_scan) -&gt; double &#123;
                for(int i &#x3D; r.begin(); i !&#x3D; r.end(); ++i)&#123;
                    double my_angle &#x3D; atan2(i * dx, heights[0] - heights[i]);
                    if(my_angle &gt;&#x3D; max_angle)&#123;
                        max_angle &#x3D; my_angle;
                    &#125;
                    else if(is_final_scan)&#123;
                        visible[i] &#x3D; false;
                    &#125;
                &#125;
                return max_angle;
            &#125;,
      			&#x2F;&#x2F;combine body
            [](double a, double b)&#123;
                return std::max(a, b);
            &#125;
        );
&#125;</code></pre>
<h3 id="parallel-for-each">parallel_for_each</h3>
<p>parallel_for在使用时必须指定range，但如果要处理的item数量不确定（比如在执行过程中修改itemList），那么就不能使用，这个时候我们可以使用parallel_for_each</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typaname InputIterator, typename Body&gt;
void parallel_for_each( InputIterator first, InputIterator last, Body body );</code></pre>
<p>下面是一个遍历树的示例，若一个节点的<code>v.first</code>为prime，将其<code>v.second</code>修改为true。我们不知道树有多大，于是采用递归遍历</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void f(PrimesTreeElement::Ptr root)&#123;
  PrimesTreeElement::Ptr tree_arry[] &#x3D; &#123;root&#125;;
  &#x2F;&#x2F;tbb::parallel_do已经废弃
  tbb::parallel_for_each(
        tree_array,
        [](PrimesTreeElement::Ptr e, 
        &#x2F;&#x2F;tbb::parallel_do_feeder已被废弃
        tbb::feeder&lt;PrimesTreeElement::Ptr&gt;&amp; feeder)&#123;
        if(e)&#123;
          if(isPrime(e-&gt;v.first)) e-&gt;v.second &#x3D; true;
          if(e-&gt;left) feeder.add(e-&gt;left);
          if(e-&gt;right) feeder.add(e-&gt;right);
        &#125;
      &#125;                 
  );
&#125;</code></pre>
<h4 id="前向替换">前向替换</h4>
<p>前向替换（Forward Substitution）是线性代数中一种求解线性方程组的方法</p>
<p>一般解线性方程组有两种方法：</p>
<ul>
<li>直接法
<ul>
<li>高斯消元法</li>
<li>LU分解法</li>
</ul>
</li>
<li>迭代法</li>
</ul>
<p>高斯消元法：初中就学了，就是两个方程变化后相加减（也可以换元），消除变量，直到得到解。这个方法可以拓展到矩阵中，就是把线性方程转化为行阶梯矩阵（中间那个矩阵），然后简化为简化行阶梯矩阵（右边那个矩阵）</p>
<p>$$<br>
\left[<br>
\begin{matrix}<br>
2 &amp; 1 &amp; -1 &amp;|&amp; 8	\\<br>
-3 &amp; -1 &amp; 2 &amp; | &amp; -11 \\<br>
-2 &amp; 1 &amp; 2 &amp; | &amp; -3<br>
\end{matrix}<br>
\right]<br>
=&gt;<br>
\left[<br>
\begin{matrix}<br>
2 &amp; 1 &amp; -1 &amp;|&amp; 8	\\<br>
0 &amp; 1/2 &amp; 1/2 &amp; | &amp; 1 \\<br>
0 &amp; 0 &amp; -1 &amp; | &amp; 1<br>
\end{matrix}<br>
\right]<br>
=&gt;<br>
\left[<br>
\begin{matrix}<br>
1 &amp; 0 &amp; 0 &amp;|&amp; 2	\\<br>
0 &amp; 1 &amp; 0 &amp; | &amp; 3 \\<br>
0 &amp; 0 &amp; 1 &amp; | &amp; -1<br>
\end{matrix}<br>
\right]<br>
$$</p>
<p>前向替换法就是得到行阶梯矩阵后</p>
<img src="/images/前向替换.png" alt="前向替换" style="zoom:50%;" />
<p>能写出以下式子</p>
<p>$$<br>
\begin{cases}	<br>
x_1 = b_1/a_{11} \\<br>
x_2 = (b_2-a_{21}x_1)/a_{22}	\\<br>
\ \vdots	\\<br>
x_n = (b_n -a_{n1}x_1-a_{n2}x_2 - \cdots -a_{nn-1}x_{n-1})/a_{nm}<br>
\end{cases}<br>
$$</p>
<p>于是我们只需要从第一个式子开始，逐步向下替换，就能求出方程的解</p>
<p><em>如果是下三角矩阵，那就是后向替换</em></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a是一个下三角矩阵，x、b是向量
void serialFS(std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; a, std::vector&lt;double&gt;&amp; b) &#123;
    const int N &#x3D; x.size();
    for (int i &#x3D; 0; i &lt; N; ++i) &#123;
        for (int j &#x3D; 0; j &lt; i; ++j) &#123;
            b[i] -&#x3D; a[j + i*N] * x[j];
        &#125;
        x[i] &#x3D; b[i] &#x2F; a[i + i*N];
    &#125;
&#125;</code></pre>
<p>加入分块和并行后：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void parallelFS(std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a,
                std::vector&lt;double&gt; &amp;b) &#123;
  const int N &#x3D; x.size();
  const int block_size &#x3D; 512;
  const int num_blocks &#x3D; N &#x2F; block_size;
  &#x2F;&#x2F;tbb::atomic已经废弃
  std::vector&lt;std::atomic&lt;char&gt;&gt; ref_count(num_blocks * num_blocks);
  for (int r &#x3D; 0; r &lt; num_blocks; ++r) &#123;
    for (int c &#x3D; 0; c &lt;&#x3D; r; ++c) &#123;
      if (r &#x3D;&#x3D; 0 &amp;&amp; c &#x3D;&#x3D; 0)
        ref_count[r * num_blocks + c] &#x3D; 0;
      else if (c &#x3D;&#x3D; 0 || r &#x3D;&#x3D; c)
        ref_count[r * num_blocks + c] &#x3D; 1;
      else
        ref_count[r * num_blocks + c] &#x3D; 2;
    &#125;
  &#125;

  using BlockIndex &#x3D; std::pair&lt;size_t, size_t&gt;;
  BlockIndex top_left(0, 0);
  &#x2F;&#x2F;tbb::parallel_do已经废弃
  tbb::parallel_for_each(&amp;top_left, &amp;top_left + 1,
                         [&amp;](const BlockIndex &amp;bi, tbb::feeder&lt;BlockIndex&gt; &amp;feeder) &#123;
                           size_t r &#x3D; bi.first;
                           size_t c &#x3D; bi.second;
                           int i_start &#x3D; r * block_size, i_end &#x3D; i_start + block_size;
                           int j_start &#x3D; c * block_size, j_max &#x3D; j_start + block_size - 1;
                           for (int i &#x3D; i_start; i &lt; i_end; ++i) &#123;
                             int j_end &#x3D; (i &lt;&#x3D; j_max) ? i : j_max + 1;
                             for (int j &#x3D; j_start; j &lt; j_end; ++j) &#123;
                               b[i] -&#x3D; a[j + i * N] * x[j];
                             &#125;
                             if (j_end &#x3D;&#x3D; i) &#123;
                               x[i] &#x3D; b[i] &#x2F; a[i + i * N];
                             &#125;
                           &#125;
                           &#x2F;&#x2F; add successor to right if ready
                           if (c + 1 &lt;&#x3D; r &amp;&amp; --ref_count[r * num_blocks + c + 1] &#x3D;&#x3D; 0) &#123;
                             feeder.add(BlockIndex(r, c + 1));
                           &#125;
                           &#x2F;&#x2F; add succesor below if ready
                           if (r + 1 &lt; (size_t) num_blocks &amp;&amp; --ref_count[(r + 1) * num_blocks + c] &#x3D;&#x3D; 0) &#123;
                             feeder.add(BlockIndex(r + 1, c));
                           &#125;
                         &#125;
                        );
&#125;</code></pre>
<h3 id="流水线">流水线</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">void parallel_pipeline( size_t max_number_of_live_tokens, const filter&lt;void,void&gt;&amp; filter_chain );

template&lt;typename T, typename U, typename Func&gt;
filter_t&lt;T, U&gt; make_filter(filter::mode mode, const Func&amp; f);</code></pre>
<p>管线（pipeline）是过滤器（filters）的线性序列，物体（items）在通过过滤器时，会被处理</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;并行 将字符串中大写变小写
void fig_2_27(int num_tokens, std::ofstream &amp;caseBeforeFile, std::ofstream &amp;caseAfterFile) &#123;
  tbb::parallel_pipeline(
    &#x2F;&#x2F;tokens
    num_tokens,
    &#x2F;&#x2F;第一个filter，负责创建字符串
    tbb::make_filter&lt;void, CaseStringPtr&gt;(
        &#x2F;&#x2F;tbb::filter::serial_in_order已经废弃
        tbb::filter_mode::serial_in_order,
        &#x2F;&#x2F;filter body
        [&amp;](tbb::flow_control &amp;fc) -&gt; CaseStringPtr &#123;
            CaseStringPtr s_ptr &#x3D; getCaseString(caseBeforeFile);
            if (!s_ptr)
              fc.stop();
            return s_ptr;
        &#125;) 
    
    &amp; &#x2F;&#x2F; 链接
    
    &#x2F;&#x2F;第二个filter，负责修改字符串
    tbb::make_filter&lt;CaseStringPtr, CaseStringPtr&gt;(
        &#x2F;&#x2F;filter node
        tbb::filter_mode::parallel,
        &#x2F;&#x2F;filter body
        [](CaseStringPtr s_ptr) -&gt; CaseStringPtr &#123;
        		std::transform(s_ptr-&gt;begin(), s_ptr-&gt;end(), s_ptr-&gt;begin(),
                       [](char c) -&gt; char &#123;
                         if (std::islower(c))
                           return std::toupper(c);
                         else if (std::isupper(c))
                           return std::tolower(c);
                         else
                           return c;
                       &#125;);
        		return s_ptr;
      &#125;) 
    
      &amp; &#x2F;&#x2F;链接
    
      &#x2F;&#x2F;第三个filter，负责写字符串
    	tbb::make_filter&lt;CaseStringPtr, void&gt;(
          &#x2F;&#x2F;filter node
          tbb::filter_mode::serial_in_order,
          &#x2F;&#x2F;filter body
          [&amp;](CaseStringPtr s_ptr) -&gt; void &#123;
            	writeCaseString(caseAfterFile, s_ptr);
          &#125;)
      );
&#125;</code></pre>
<h2 id="Flow-Graphs">Flow Graphs</h2>
<p>并行编程另一个问题是混乱，传统并行编程为了避免程序混乱（messy），我们需要事无巨细地管理每一件事。但在上一节简单提到的Flow Graphs，提供了一个简单的管理方法</p>
<p>Flow Graphs允许我们用图（DAG）来描述程序，相比于<code>parallel_do</code>和<code>parallel_pipeline</code>，FlowGraphs自由度更高，推荐使用。</p>
<ul>
<li>每个节点是一个并行函数，箭头代表数据的流向/消息传递，我们将这个图称为数据流向图（data flow graphs）</li>
<li>图也可以描述操作的前后顺序，进而可以构建一些传统方法难以表示的独立结构体，这种图被称为依赖图（dependency graphs）</li>
</ul>
<h3 id="预热">预热</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">static void warmupTBB() &#123;
    &#x2F;&#x2F;tbb::task_scheduler_init::default_num_threads()已经弃用
    tbb::parallel_for(0, tbb::this_task_arena::max_concurrency(), [](int) &#123;
        tbb::tick_count t0 &#x3D; tbb::tick_count::now();
        while ((tbb::tick_count::now() - t0).seconds() &lt; 0.01);
    &#125;);
&#125;</code></pre>
<p>无论是web服务器、CPU/GPU并行计算，深度学习，都有warmup的概念</p>
<p>对于一个项目，如果采用冷启动的方式，从零瞬间增加计算量，可能会把系统压垮，于是我们可以使用warmup，逐步提高项目负荷。</p>
<h3 id="数据流图">数据流图</h3>
<ol>
<li>构建图对象</li>
<li>创建节点，填充节点信息</li>
<li>链接节点</li>
<li>发送消息</li>
<li>等待图完成</li>
</ol>
<pre class="language-c++" data-language="c++"><code class="language-c++">void graphSample()&#123;
    &#x2F;&#x2F;创建图对象
    tbb::flow::graph g;
    &#x2F;&#x2F;创建节点
    tbb::flow::function_node&lt;int, std::string&gt; my_first_node(
            g, tbb::flow::unlimited,
            [](const int &amp;in) -&gt; std::string&#123;
                std::cout &lt;&lt; &quot;first node received: &quot; &lt;&lt; in &lt;&lt; std::endl;
                return std::to_string(in);
            &#125;
        );
    tbb::flow::function_node&lt;std::string&gt; my_second_node(
            g, tbb::flow::unlimited,
            [](const std::string &amp;in)&#123;
                std::cout &lt;&lt; &quot;second node received: &quot; &lt;&lt; in &lt;&lt; std::endl;
            &#125;
        );
    &#x2F;&#x2F;链接
    tbb::flow::make_edge(my_first_node, my_second_node);
    &#x2F;&#x2F;发送消息
    my_first_node.try_put(10);
    &#x2F;&#x2F;等待图完成
    g.wait_for_all();
&#125;</code></pre>
<h4 id="节点">节点</h4>
<p>Flow Graphs有三种节点</p>
<ul>
<li>functional</li>
<li>control flow</li>
<li>buffering</li>
</ul>
<h5 id="function-node">function_node</h5>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Body&gt;
function_node(graph&amp; g, size_t concurrency, Body body);</code></pre>
<p>函数节点，当消息传递到该节点，会被函数处理，并将输出值传递给后继者</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;输入一个int类型，输出一个std::string类型
tbb::flow::function_node&lt;int, std::string&gt; my_first_node(
  					&#x2F;&#x2F;图对象
            g, 	
  					&#x2F;&#x2F;节点的并发限制，0是无限制(unlimited)，1是串行(serial)
  					tbb::flow::unlimited,	
  					&#x2F;&#x2F;body
            [](const int &amp;in) -&gt; std::string&#123;
                std::cout &lt;&lt; &quot;first node received: &quot; &lt;&lt; in &lt;&lt; std::endl;
                return std::to_string(in);
            &#125;
        );</code></pre>
<p>函数节点可以从他所连接（edges）其他节点获取消息，也可以使用<code>try_put</code>手动向其传递消息</p>
<h5 id="join-node">join_node</h5>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename Body, typename... Bodies&gt;
join_node(graph&amp;, Body, Bodies...)-&gt;join_node&lt;std::tuple&lt;std::decay_t&lt;input_t&lt;Body&gt;&gt;, std::decay_t&lt;input_t&lt;Bodies&gt;&gt;...&gt;, key_matching&lt;output_t&lt;Body&gt;&gt;&gt;;</code></pre>
<p>流控制节点，当消息传递到该节点，会创建一个消息元组（tuple），然后将元组广播给所有后继者</p>
<p><img src="Image/join.jpg" alt="join"></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;my_node，输入int，输出std::string
tbb::flow::function_node&lt;int, std::string&gt; my_node&#123;...&#125;;
&#x2F;&#x2F;my_other_node，输入int，输出double
tbb::flow::function_node&lt;int, double&gt; my_other_node&#123;...&#125;;
&#x2F;&#x2F;join节点，这里的作用是将两个节点的输出整合，传递给my_final_node
tbb::flow::join_node&lt;std::tuple&lt;std::string, double&gt;,
            tbb::flow::queueing&gt; my_join_node&#123;g&#125;;
&#x2F;&#x2F;my_final_node，输入一个元组
tbb::flow::function_node&lt;std::tuple&lt;std::string, double&gt;, int&gt; my_final_node&#123;g,
                   tbb::flow::unlimited,
                   [](const std::tuple&lt;std::string, double&gt;&amp; in) -&gt; int &#123;
                     std::cout &lt;&lt; &quot;final: &quot; &lt;&lt; std::get&lt;0&gt;(in)
                       &lt;&lt; &quot; and &quot; &lt;&lt; std::get&lt;1&gt;(in) &lt;&lt; std::endl;
                     return 0;
                   &#125;
                  &#125;;</code></pre>
<p>有的时候，我们需要保证<code>join_node</code>的输入的对应的。比如我想将两张照片拼成一张，我开两个节点并行读项目，再用<code>join_node</code>整合后传入merge函数节点，然而在这个过程中，我必须保证传入的两个像素点在同一位置，为此，我们可以添加一个frameNumber做标记（tags）</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;使用函数对象作为tags，可以用input_port&lt;i&gt;读出来
tbb::flow::join_node&lt;std::tuple&lt;Image, Image&gt;, tbb::flow::tag_matching &gt;
    join_images_node(g, [] (Image left) &#123; return left.frameNumber; &#125;,
                        [] (Image right) &#123; return right.frameNumber; &#125; );
...
tbb::flow::make_edge(increase_left_node, tbb::flow::input_port&lt;0&gt;(join_images_node));
tbb::flow::make_edge(increase_right_node, tbb::flow::input_port&lt;1&gt;(join_images_node));
tbb::flow::make_edge(join_images_node, merge_images_node);</code></pre>
<h4 id="链接">链接</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename Message&gt;
    inline void make_edge( sender&lt;Message&gt; &amp;p, receiver&lt;Message&gt; &amp;s );
template&lt; typename MultiOutputNode, typename MultiInputNode &gt;
    inline void make_edge( MultiOutputNode&amp; output, MultiInputNode&amp; input );</code></pre>
<p>我们可以使用<code>make_edge</code>链接两个节点</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;这里的input_port是一种sender，跟节点差不多，都能互相链接
make_edge(my_node, tbb::flow::input_port&lt;0&gt;(my_join_node));
make_edge(my_other_node, tbb::flow::input_port&lt;1&gt;(my_join_node));
make_edge(my_join_node, my_final_node);</code></pre>
<h4 id="激活">激活</h4>
<p>为了激活图，我们需要向图中传递消息，除了前文的<code>try_put</code>，我们也可以使用<code>input_port</code></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;my_node是一个input_node
my_node.activate();	&#x2F;&#x2F;将其设为活动状态，启用消息生成</code></pre>
<h4 id="等待">等待</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">g.wait_for_all();</code></pre>
<h3 id="性能限制">性能限制</h3>
<p>Flow Graphs是一个基于Task的并行框架，当消息到达一个节点时，根据节点的并发限制，创建Task。生成的Task会进一步映射为线程（跟上一节讲的循环、算法的机制一样）</p>
<p>真正限制Flow Graphs性能的有</p>
<ul>
<li>串行节点（serial node）</li>
<li>工作线程数</li>
<li>任务复杂度</li>
</ul>
<h3 id="依赖图">依赖图</h3>
<p><em>很像RenderGraph</em></p>
<table>
<thead>
<tr>
<th></th>
<th>数据流向图</th>
<th>依赖图</th>
</tr>
</thead>
<tbody>
<tr>
<td>Edges含义</td>
<td>表示数据流向</td>
<td>表示节点的先后顺序</td>
</tr>
<tr>
<td>信息传递方式</td>
<td>消息</td>
<td>shared memory</td>
</tr>
<tr>
<td>节点类型</td>
<td>function_node</td>
<td>continue_node</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>节点的先后顺序，描述的是依赖关系，只有前面节点执行结束后，后面节点才能安全、正确地执行</p>
</li>
<li>
<p>依赖图不使用函数节点，而是继续节点<code>continue_node</code>，节点间的消息传递使用，当传入<code>continue_node</code>的消息（<code>continue_msg</code>）数量等于该节点需要的消息数量，节点内的函数会开始执行</p>
</li>
<li>
<p><code>continue_node</code>只关心传入的消息数量，不关心消息源。这导致依赖图必须是非循环的（acyclic），因为一个物体循环发出两次消息，（在这里）等同于两个物体各发出一次消息</p>
</li>
</ul>
<p>构建依赖图</p>
<ol>
<li>创建图对象</li>
<li>创建节点</li>
<li>链接</li>
<li>发送信息</li>
<li>等待图完成</li>
</ol>
<h4 id="前向替换-2">前向替换</h4>
<p>之前我们使用<code>parallel_for_each</code>实现了一份前向替换，我们现在用依赖图再实现一次</p>
<p><img src="Image/%E5%89%8D%E5%90%91%E6%9B%BF%E6%8D%A2.jpg" alt="前向替换"></p>
<p>经观察，我们发现辅对角线的块/迭代器是相互独立的，他们之间没有依赖关系（上图(b)，块BC间没有依赖，他们只需要在A之后执行就可以正确运算）</p>
<p>经观察，同时并行计算的最大块数为辅对角线的长度，也就是图中标注的 a set of independent blocks</p>
<p>经观察，上图(b)中每一个块需要接受两个msg，正好与block_sizes大小相等</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">using Node &#x3D; tbb::flow::continue_node&lt;tbb::flow::continue_msg&gt;;
using NodePtr &#x3D; std::shared_ptr&lt;Node&gt;;
NodePtr createNode(tbb::flow::graph &amp;g, int r, int c, int block_size,
                   std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b);
void addEdges(std::vector&lt;NodePtr&gt; &amp;nodes, int r, int c, int block_size, int num_blocks);
void dependencyGraphFS(std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b)&#123;
    const int N &#x3D; x.size();
    const int block_size &#x3D; 1024;
    const int num_blocks &#x3D; N &#x2F; block_size;
		&#x2F;&#x2F;创建num_blocks * num_blocks个节点，只不过我们只会用到下半部分
    std::vector&lt;NodePtr&gt; nodes(num_blocks * num_blocks);
    &#x2F;&#x2F;创建图对象
    tbb::flow::graph g;
  	&#x2F;&#x2F;我们从最下面一行开始向上构建
    for(int r &#x3D; num_blocks-1; r &gt;&#x3D; 0; --r)&#123;
        for(int c &#x3D; r; c &gt;&#x3D; 0; --c)&#123;
            &#x2F;&#x2F;创建图节点
            nodes[r * num_blocks + c] &#x3D; createNode(g, r, c, block_size, x, a, b);
            &#x2F;&#x2F;链接
            addEdges(nodes, r, c, block_size, num_blocks);
        &#125;
    &#125;
    &#x2F;&#x2F;传入消息
    nodes[0]-&gt;try_put(tbb::flow::continue_msg());
    &#x2F;&#x2F;等待完成
    g.wait_for_all();
&#125;

NodePtr createNode(tbb::flow::graph &amp;g, int r, int c, int block_size,
                   std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b)&#123;
    const int N &#x3D; x.size();
    return std::make_shared&lt;Node&gt;(
            g,
            [r, c, block_size, N, &amp;x, &amp;a, &amp;b](const tbb::flow::continue_msg &amp; msg)&#123;
                int i_start &#x3D; r * block_size, i_end &#x3D; i_start + block_size;
                int j_start &#x3D; c * block_size, j_max &#x3D; j_start + block_size -1;
                &#x2F;&#x2F;对于每个块，串行进行正向替换计算
                for(int i &#x3D; i_start; i &lt; i_end; ++i)&#123;
                    int j_end &#x3D; (i &lt;&#x3D; j_max) ? i : j_max+1;
                    for(int j &#x3D; j_start; j &lt; j_end; ++j)&#123;
                        b[i] -&#x3D; a[j + i*N] * x[j];
                    &#125;
                    if(j_end &#x3D;&#x3D; i)&#123;
                        x[i] &#x3D; b[i] &#x2F; a[i + i*N];
                    &#125;
                &#125;
                return msg;
            &#125;
        );
&#125;

void addEdges(std::vector&lt;NodePtr&gt; &amp;nodes, int r, int c, int block_size, int num_blocks)&#123;
    NodePtr np &#x3D; nodes[r * num_blocks + c];
  	&#x2F;&#x2F;每个块链接自己的下面和右边，最下面和最右边不链接
    if(c + 1 &lt; num_blocks &amp;&amp; r !&#x3D; c)&#123;
        tbb::flow::make_edge(*np, *nodes[r * num_blocks + c + 1]);
    &#125;
    if(r + 1 &lt; num_blocks)&#123;
        tbb::flow::make_edge(*np, *nodes[(r+1) * num_blocks + c]);
    &#125;
&#125;</code></pre>
<h2 id="PSTL">PSTL</h2>
<p>parallel_sort</p>
<h2 id="同步">同步</h2>
<p>在并行编程中，我们要极力避免同步（Synchronization）和互斥（exclusion），这会严重影响性能</p>
<p>但是很多情况下，我们不得不同步，书中称其为“必要之恶”（necessary evil）</p>
<h3 id="写冲突">写冲突</h3>
<p>比如我们想要统计一张图中各种颜色出现的次数，如果是串行处理，我们就遍历每一个像素，用一个数组存储统计值</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 0; i &lt; N; ++i)&#123;
  hist[image[i]]++;
&#125;</code></pre>
<p>但当我们想要并行处理遍历像素时，就会出现问题。如果两个线程同时读到了同一种颜色，于是都想执行<code>hist[p]++</code>，而如果该操作不支持原子（atomic）操作，就会出现写冲突</p>
<h4 id="RMW">RMW</h4>
<p>现代操作系统将很多操作设置为原子操作，该操作被视为一个完成的操作，不可分割，因此是线程安全的。比如对齐读（Aligned Read），对齐写（Aligned Write）</p>
<p><em>原子的本意就是不可分割的意思，当年化学家和物理学家认为原子是最小的粒子（尽管并非如此）</em></p>
<p>Read-Modify-Write（RMW）设计原则，可以让复杂操作原子化，当多个线程想要对某个内存进行修改时，保证线程安全并只执行一次</p>
<p>windows原子操作的实现原理（_InterlockedIncrement）</p>
<ol>
<li>读内存</li>
<li>计算得到新值</li>
<li>若内存位置仍然是原始值，则将新值写入该内存位置
<ul>
<li>若不是原始值，则在下一个循环周期中重新操作</li>
</ul>
</li>
</ol>
<h4 id="锁">锁</h4>
<p>解决并行写冲突最简单的方法就是加锁，我们给对象加一个互斥锁（mutex），写之前上锁，写完解锁，其他线程无法操作锁住的对象。而上锁解锁操作中间的代码被称为临界区（critical section），是被锁保护的部分。</p>
<p>锁会影响性能</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;tbb::task_scheduler_init init&#123;nth&#125;已经弃用，用于设置最大线程数
tbb::global_control global_limit(tbb::global_control::max_allowed_parallelism, nth);

using my_mutex_t&#x3D;tbb::spin_mutex;
my_mutex_t my_mutex;
std::vector&lt;int&gt; hist_p(num_bins);
parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;,
             [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
             &#123;
                 &#x2F;&#x2F;这种写法比my_lock.acquire(my_mutex)、my_lock.release()好
                 my_mutex_t::scoped_lock my_lock&#123;my_mutex&#125;;
                 for (size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)
                   	hist_p[image[i]]++;
             &#125;);</code></pre>
<h4 id="原子操作">原子操作</h4>
<p>锁过于消耗性能，原子操作效果会好一些，只不过这样还是比线性慢，而且不是真共享（Sharing）</p>
<p>什么是原子？原子的原意就是不可分割的基本粒子，我们在实现<code>a++</code>时，本质是分了三步</p>
<ol>
<li>取a</li>
<li>加法运算</li>
<li>写a</li>
</ol>
<p>由于并行计算，其他线程可能在你完整完成这三步期间进行操作，于是就会出现冲突。而原子操作就是将这三步视为一步，不可分割，在完整完成这三部之前，其他线程无权访问，等到操作结束</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">std::vector&lt;std::atomic&lt;int&gt;&gt; hist_p2(num_bins);
parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, 
             [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
             &#123;
                 for(size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)
                 &#123;
                     hist_p2[image[i]]++;
                 &#125;
             &#125;
            );</code></pre>
<h3 id="Thread-Local-Storage">Thread Local Storage</h3>
<p>一个较好的解决方案是私有化（Privatization）和归并（Reduction）</p>
<p>我感觉这个的设计理念就是：如果不得不同步，那就尽可能让更多更复杂的计算并行执行，最后对统一、规范、简单的数据进行同步</p>
<p>前面并行统计Image像素信息时，会出现多个线程写冲突。但如果让每个线程都有一个Image副本，线程对自己的副本进行操作（私有化），最后将这些副本进行归并。</p>
<p>私有化确实不会出现写冲突了，尽管归并仍然存在同步问题，但这个归并更简单，毕竟归并几个数，远远比处理几个线程冲突要简单，性能开销小</p>
<p>TBB提供了多种私有化+归并的的方案，其中归并模板（parallel_reduce）在TBB基础时就讲了</p>
<ul>
<li>Thread Local Storage（TLS）：让每一个线程拥有一份副本，只不过存储开销过大，不宜过多使用
<ul>
<li>enumerable_thread_specific（ETS）</li>
<li>combinable</li>
</ul>
</li>
</ul>
<h4 id="ETS">ETS</h4>
<p><code>tbb::enumerable_thread_specific&lt;T&gt;</code>对象是一个大容器，容器内包含者每一个线程所对应的副本，我们可以使用迭代器进行访问</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">using vector_t &#x3D; std::vector&lt;int&gt;;
using priv_h_t &#x3D; tbb::enumerable_thread_specific&lt;vector_t&gt;;
priv_h_t priv_h&#123;num_bins&#125;;
&#x2F;&#x2F;私有化
parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;,
             [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
             &#123;
                 &#x2F;&#x2F;若该线程第一次使用local，那么会创建一个新的vector&lt;int&gt;，初始值为0
                 priv_h_t::reference my_hist &#x3D; priv_h.local();
                 for (size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)&#123;
                     &#x2F;&#x2F;my_hist是引用，实际上是在修改priv_h[xxx]，以此将数据传递到线程外
                     my_hist[image[i]]++;
                 &#125;     
             &#125;);
&#x2F;&#x2F;归并
vector_t hist_p3(num_bins);
for(auto i&#x3D;priv_h.begin(); i!&#x3D;priv_h.end(); ++i)&#123;
    for (int j&#x3D;0; j&lt;num_bins; ++j) &#123;
    	hist_p3[j]+&#x3D;(*i)[j];
    &#125;
&#125;</code></pre>
<p>使用STL算法替代循环，进行归并</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;我们可以使用transform替代循环遍历
for (auto&amp; i: priv_h) &#123; &#x2F;&#x2F; i traverses all private vectors
    std::transform(hist_p3.begin(),    &#x2F;&#x2F; source 1 begin
                   hist_p3.end(),      &#x2F;&#x2F; source 1 end
                   i.begin(),          &#x2F;&#x2F; source 2 begin
                   hist_p3.begin(),    &#x2F;&#x2F; destination begin
                   std::plus&lt;int&gt;() ); &#x2F;&#x2F; binary operation
	&#125;</code></pre>
<p>由于归并过于常用，TBB也对归并做了封装</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;使用combine_each
priv_h.combine_each([&amp;](vector_t i)&#123;
        std::transform(hist_p3.begin(),   	&#x2F;&#x2F; source 1 begin
                   hist_p3.end(),      		&#x2F;&#x2F; source 1 end
                   i.begin(),         		&#x2F;&#x2F; source 2 begin
                   hist_p3.begin(),    		&#x2F;&#x2F; destination begin
                   std::plus&lt;int&gt;() );		&#x2F;&#x2F; binary operation
    &#125;);
&#x2F;&#x2F;或者使用combine
vector_t hist_p &#x3D; priv_h.combine([](vector_t a, vector_t b) -&gt; vector_t &#123;
      std::transform(a.begin(),         &#x2F;&#x2F; source 1 begin
                     a.end(),           &#x2F;&#x2F; source 1 end
                     b.begin(),         &#x2F;&#x2F; source 2 begin
                     a.begin(),         &#x2F;&#x2F; destination begin
                     std::plus&lt;int&gt;() );&#x2F;&#x2F; binary operation
       return a;
    &#125;);</code></pre>
<h4 id="combinable">combinable</h4>
<p><code>combinable&lt;T&gt;</code>对象也是一个容器，每一个线程对应一个instance</p>
<p>但是与ETS不同，<code>combinable&lt;T&gt;</code>并不能使用迭代器访问，这样设计的目的是不向外暴露对象，这样归并结束后大容器和其中的数据都释放了，以此节省局部空间</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;combinable
tbb::combinable&lt;vector_t&gt; priv_h2&#123;[num_bins]()&#123;return vector_t(num_bins);&#125;&#125;;
&#x2F;&#x2F;私有化
parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;,
             [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
             &#123;
                 vector_t&amp; my_hist &#x3D; priv_h2.local();
                 for (size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)
                     my_hist[image[i]]++;
             &#125;);
&#x2F;&#x2F;归并
vector_t hist_p4(num_bins);
priv_h2.combine_each([&amp;](vector_t i)
                     &#123; &#x2F;&#x2F; for each priv histogram a
                         std::transform(hist_p4.begin(),     &#x2F;&#x2F; source 1 begin
                                        hist_p4.end(),      &#x2F;&#x2F; source 1 end
                                        i.begin(),          &#x2F;&#x2F; source 2 begin
                                        hist_p4.begin(),    &#x2F;&#x2F; destination begin
                                        std::plus&lt;int&gt;() ); &#x2F;&#x2F; binary operation
                     &#125;);</code></pre>
<p>最终性能比较，能看出TLS能大幅提高性能</p>
<pre class="language-none"><code class="language-none">Serial:       0.399203
Parallel:     2.01466
Atomic:       0.500326
ETC:          0.0348115
combinable:   0.0339478</code></pre>
<h3 id="parallel-reduce">parallel_reduce</h3>
<p>最简单的归并，还是给用tbb封装好的模板，该算法的本质是树形规约</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;parallel_reduce
using image_iterator &#x3D; std::vector&lt;uint8_t&gt;::iterator;
t0 &#x3D; tbb::tick_count::now();
vector_t hist_p5 &#x3D; parallel_reduce (
    &#x2F;*range*&#x2F;    
    tbb::blocked_range&lt;image_iterator&gt;&#123;image.begin(), image.end()&#125;,
    &#x2F;*identity*&#x2F; 
    vector_t(num_bins),
    &#x2F;&#x2F; 1st Lambda: Parallel computation on private histograms
    [](const tbb::blocked_range&lt;image_iterator&gt;&amp; r, vector_t v) &#123;
        std::for_each(r.begin(), r.end(),
                      [&amp;v](uint8_t i) &#123;v[i]++;&#125;);
        return v;
    &#125;,
    &#x2F;&#x2F; 2nd Lambda: Parallel reduction of the private histograms
    [num_bins](vector_t a, const vector_t &amp; b) -&gt; vector_t &#123;
        for(int i&#x3D;0; i&lt;num_bins; ++i) a[i] +&#x3D; b[i];
        return a;
&#125;);</code></pre>
<h2 id="并发容器">并发容器</h2>
<p>在上一节我们遇到了同步问题，处理同步会大幅降低性能，为此我们使用了TLS等方法实现了高效的显式同步，而这一节，我们将介绍TBB的核心，并发（Concurrent）</p>
<p>TBB提供了一些高效、线程安全的并发容器，他们大多是使用细粒度的锁或者无锁设计</p>
<ul>
<li>细粒度锁：指锁定真正需要锁定的地方（其实还是挺低效的），比如一个数组我们只锁我们需要的某一个元素，其他线程如果不访问我这个元素，就能正常并行</li>
<li>无锁：有的线程负责操作，有的线程负责纠错</li>
</ul>
<p>TBB的并发容器并发性能很好，但串行性能不如STL</p>
<ul>
<li>顺序表（Sequences）
<ul>
<li><code>concurrent_vector</code></li>
</ul>
</li>
<li>队列（Queues）
<ul>
<li><code>concurrent_queue</code></li>
<li><code>concurrent_bounded_queue</code></li>
<li><code>concurrent_priority_queue</code></li>
</ul>
</li>
<li>无序关联容器（Unordered associative containers）
<ul>
<li><code>concurrent_hash_map</code></li>
<li><code>map/multimap</code></li>
<li><code>set/multiset</code></li>
</ul>
</li>
<li>有序关联容器（Ordered associative containers）
<ul>
<li><code>map/multimap</code></li>
<li><code>set/multiset</code></li>
</ul>
</li>
</ul>
<h3 id="concurrent-hash-map">concurrent_hash_map</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename Key, typename T,
                 typename HashCompare &#x3D; tbb_hash_compare&lt;Key&gt;,
                 typename Allocator &#x3D; tbb_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
class concurrent_hash_map &#123;..&#125;</code></pre>
<p>这是一个字符串-Int的哈希表</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;HashCompare必须有hash函数和equal函数
struct MyHashCompare&#123;
    static size_t hash(const std::string&amp; s)&#123;
        size_t h &#x3D; 0;
        for(auto &amp;c : s)&#123;
            h &#x3D; (h*17)^c;
        &#125;
        return h;
    &#125;
    static bool equal(const std::string&amp; x, const std::string&amp; y)&#123;
        return x &#x3D;&#x3D; y;
    &#125;
&#125;;
&#x2F;&#x2F;hash map
typedef tbb::concurrent_hash_map&lt;std::string, int, MyHashCompare&gt; StringTable;
&#x2F;&#x2F;一个函数对象，用于记录table内元素数量
class Tally&#123;
private:
    StringTable&amp; table;
public:
    Tally(StringTable&amp; table_): table(table_) &#123;&#125;
    void operator() (const tbb::blocked_range&lt;std::string*&gt; range) const &#123;
        for(std::string* p &#x3D; range.begin(); p !&#x3D; range.end(); ++p)&#123;
          	&#x2F;&#x2F;accessor类似于锁、智能智能，在accessor完成前，其他线程不能lookup这个key
            StringTable::accessor a;
            table.insert(a, *p);
            a-&gt;second +&#x3D; 1;
        &#125;
    &#125;
&#125;;</code></pre>
<pre class="language-c++" data-language="c++"><code class="language-c++">int main() &#123;
    StringTable table;
    tbb::parallel_for( tbb::blocked_range&lt;std::string*&gt;( Data, Data+N, 1000 ), Tally(table) );

    for( StringTable::iterator i&#x3D;table.begin();
         i!&#x3D;table.end();
         ++i )
        printf(&quot;%s %d\n&quot;,i-&gt;first.c_str(),i-&gt;second);
    return 0;
&#125;</code></pre>
<h2 id="内存分配">内存分配</h2>
<p>内存分配最重要的是正确，TBB提供了一套可拓展的内存分配</p>
<p>现代C++推荐使用智能指针进行内存管理，不推荐使用malloc和new。TBB完全适配所有版本的C++标准，也推荐使用智能指针进行内存分配</p>
<p>TBB动态内存分配的核心是线程内存池（memory pooling by threads），该内存池可以避免内存分配带来的性能下降，也不苛求“避免cache间不必要的数据移动”</p>
<p>TBB还提供了可拓展的缓存对齐，比<code>std::aligned_alloc</code>使用更简单方便。只不过滥用缓存对齐可能会带了巨大的内存浪费</p>
<p>在并行编程中，内存分配的主要问题是：分配器的争用，缓存效果</p>
<ul>
<li>分配器争用：C++内存分存储在两个位置，堆和栈。传统的非线程分配器只能在单个全局堆中分配和释放内存，这个过程配合锁以实现互斥，很低效</li>
<li>缓存效应：某些操作可能会把缓存中的数据移动到缓存的另一处，这是很无效的行为，要避免</li>
</ul>
<h3 id="缓存填充（对齐）">缓存填充（对齐）</h3>
<p>用于解决假共享（我们在同步那一节解决了真共享带来的问题）</p>
<p>基于局部性原则，当CPU查询某个数据时：</p>
<ol>
<li>若cache中没有找到，就会去内存中寻找</li>
<li>找到后会将该数据写入cache（时间局部性，刚刚被引用过的一个内存位置容易再次被引用）</li>
<li>并将其相邻元素也写入cache（空间局部性，一个内存位置被引用，其相邻位置很可能马上被引用）</li>
</ol>
<p><img src="Image/%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7.png" alt="空间局部性"></p>
<p>如上图，CPU访问a时，先去cache去找，如果cache中没有，就会去内存中寻找，找到后将a和相邻的b写入cache的<strong>同一行</strong>。但问题出现了，如果当前cache的其他行里，已经有b了呢？</p>
<p>另一个线程也拥有一缓存行，里面存储了b，结果b却被移动到a那一行了，于是这个线程要访问b，又要去内存中找，增加了cache miss。此外多线程中，a那个线程多半是不会用到b的，于是平白做了cache位置的移动。</p>
<p>这个现象被称为假共享（false sharing），a和b并不是共享对象，但是由于他们靠的太近了，以至于在一个缓存行中，其中一个对象的更新，会强制另一个对象更新。</p>
<p>在多线程中，假共享可以通过缓存填充（cache padding）解决。缓存填充，就是在缓存中两个变量中间填充一些没有意义的数据，于是导致这两个变量不会处于同一个缓存行中，于是避免了假共享。</p>
<p>我们还是以统计图片像素为例，我们发现这种方法比直接用原子操作要快一些</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct bin&#123;
    std::atomic&lt;int&gt; count; &#x2F;&#x2F;4 bytes
    uint8_t padding[64 - sizeof(count)];    &#x2F;&#x2F;60 bytes
&#125;;
&#x2F;&#x2F;cache padding
std::vector&lt;bin, tbb::cache_aligned_allocator&lt;bin&gt;&gt; hist_p6(num_bins);
t0 &#x3D; tbb::tick_count::now();
parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;,
             [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
             &#123;
               for(size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)
               &#123;
                 hist_p6[image[i]].count++;
               &#125;
             &#125;
            );</code></pre>
<p>我们可以用C++特性来创建结构体：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct bin&#123;
    &#x2F;&#x2F;C++17后，可以用std::hardware_destructive_interference_size替代64
    alignas(64) std::atomic&lt;int&gt; count;
&#125;;</code></pre>
<h3 id="代理">代理</h3>
<p>TBB的TBBmalloc库使用代理方法，可以实现在不同操作系统，不改变代码，只需要配置一些动态库、代理库、环境变量，就可以实现全局替换new、malloc等分配函数，这对跨平台真的很重要</p>
<h2 id="Task调度">Task调度</h2>
<p>Chapter10</p>
<h2 id="资料">资料</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/Apress/pro-TBB">Pro TBB</a></p>
<p><a target="_blank" rel="noopener" href="https://spec.oneapi.io/versions/latest/elements/oneTBB/source/nested-index.html">API Document</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Reuben-Sun/TBB--Programing-Sample">代码仓库</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reuben-sun.github.io/2023/02/01/math/Pro-TBB/" data-id="clepy40oi0016glnkd97k1xnb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" rel="tag">并行计算</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/02/01/graphics/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          骨骼动画
        
      </div>
    </a>
  
  
    <a href="/2023/02/01/program/CMake%E5%85%A5%E9%97%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CMake入门</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/dcc/">dcc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/engine/">engine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/graphics/">graphics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/math/">math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/optics/">optics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/program/">program</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DX12/" rel="tag">DX12</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deferred-Render/" rel="tag">Deferred Render</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GI/" rel="tag">GI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metal/" rel="tag">Metal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PM/" rel="tag">PM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Physics/" rel="tag">Physics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SIGGRAPH/" rel="tag">SIGGRAPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPH/" rel="tag">SPH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TA/" rel="tag">TA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unreal/" rel="tag">Unreal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shader/" rel="tag">shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%89%E5%AD%A6/" rel="tag">光学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" rel="tag">并行计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" rel="tag">微积分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C#</a> <a href="/tags/C/" style="font-size: 17.5px;">C++</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/DX12/" style="font-size: 10px;">DX12</a> <a href="/tags/Deferred-Render/" style="font-size: 10px;">Deferred Render</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/GI/" style="font-size: 15px;">GI</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Metal/" style="font-size: 10px;">Metal</a> <a href="/tags/PM/" style="font-size: 10px;">PM</a> <a href="/tags/Physics/" style="font-size: 12.5px;">Physics</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/SIGGRAPH/" style="font-size: 15px;">SIGGRAPH</a> <a href="/tags/SPH/" style="font-size: 12.5px;">SPH</a> <a href="/tags/TA/" style="font-size: 15px;">TA</a> <a href="/tags/Unity/" style="font-size: 12.5px;">Unity</a> <a href="/tags/Unreal/" style="font-size: 10px;">Unreal</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/shader/" style="font-size: 10px;">shader</a> <a href="/tags/%E5%85%89%E5%AD%A6/" style="font-size: 20px;">光学</a> <a href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" style="font-size: 10px;">并行计算</a> <a href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/" style="font-size: 10px;">微积分</a> <a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 17.5px;">高等数学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/02/26/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/">光学复习</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E8%A1%8D%E5%B0%84/">衍射</a>
          </li>
        
          <li>
            <a href="/2023/02/25/optics/%E5%B9%B2%E6%B6%89/">干涉</a>
          </li>
        
          <li>
            <a href="/2023/02/18/program/AskQuestion/">提问的智慧</a>
          </li>
        
          <li>
            <a href="/2023/02/13/graphics/DOSDF/">Dynamic Occlusion with SDF</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Reuben Sun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>