{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/effectivecxx.png","path":"images/effectivecxx.png","modified":0,"renderable":0},{"_id":"themes/miccall/source/fonts/FZLT.ttf","path":"fonts/FZLT.ttf","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/backcss.css","path":"css/backcss.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/demo.css","path":"css/demo.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/dropdownMenu.css","path":"css/dropdownMenu.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/gallery.css","path":"css/gallery.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/gallery.min.css","path":"css/gallery.min.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/item.css","path":"css/item.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/mic_gallery.css","path":"css/mic_gallery.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/mic_main.css","path":"css/mic_main.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/my_link.css","path":"css/my_link.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/normalize.css","path":"css/normalize.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/noscript.css","path":"css/noscript.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/ok_prism.css","path":"css/ok_prism.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism.css","path":"css/prism.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_coy.css","path":"css/prism_coy.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_dark.css","path":"css/prism_dark.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_default.css","path":"css/prism_default.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_funky.css","path":"css/prism_funky.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_okaidia.css","path":"css/prism_okaidia.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_solarized.css","path":"css/prism_solarized.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_twilight.css","path":"css/prism_twilight.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/typo.css","path":"css/typo.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/img/bg.png","path":"img/bg.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/gallery_skel.min.js","path":"js/gallery_skel.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/gallery_skel.min.jsZone.Identifier","path":"js/gallery_skel.min.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.min.jsZone.Identifier","path":"js/jquery.min.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.scrollex.min.js","path":"js/jquery.scrollex.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.scrollex.min.jsZone.Identifier","path":"js/jquery.scrollex.min.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.scrolly.min.js","path":"js/jquery.scrolly.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.scrolly.min.jsZone.Identifier","path":"js/jquery.scrolly.min.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/lazyload.min.jsZone.Identifier","path":"js/lazyload.min.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/main.jsZone.Identifier","path":"js/main.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/mic_gallery.js","path":"js/mic_gallery.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/prism.js","path":"js/prism.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/mic_gallery.jsZone.Identifier","path":"js/mic_gallery.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/prism.jsZone.Identifier","path":"js/prism.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/skel.min.js","path":"js/skel.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/skel.min.jsZone.Identifier","path":"js/skel.min.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/util.js","path":"js/util.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/util.jsZone.Identifier","path":"js/util.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/12.jpg","path":"images/12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/3123.jpg","path":"images/3123.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/21.jpg","path":"images/21.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/me.jpg","path":"images/me.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic02.jpg","path":"images/pic02.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic01.jpg","path":"images/pic01.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic03.jpg","path":"images/pic03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic04.jpg","path":"images/pic04.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic06.jpg","path":"images/pic06.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic07.jpg","path":"images/pic07.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic08.jpg","path":"images/pic08.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/overlay.png","path":"images/overlay.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic09.jpg","path":"images/pic09.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic05.jpg","path":"images/pic05.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic11.jpg","path":"images/pic11.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic10.jpg","path":"images/pic10.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic12.jpg","path":"images/pic12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/picx03.jpg","path":"images/picx03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/arrow-small.svg","path":"css/images/arrow-small.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/arrow.svg","path":"css/images/arrow.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/close-small.svg","path":"css/images/close-small.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/close.svg","path":"css/images/close.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/close-small-alt.svg","path":"css/images/close-small-alt.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/open.svg","path":"css/images/open.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/spinner.svg","path":"css/images/spinner.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/open-small.svg","path":"css/images/open-small.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/01.jpg","path":"images/fulls/01.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/gallery/gallery.jsZone.Identifier","path":"js/gallery/gallery.jsZone.Identifier","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/02.jpg","path":"images/fulls/02.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/gallery/gallery.js","path":"js/gallery/gallery.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/05.jpg","path":"images/fulls/05.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/04.jpg","path":"images/fulls/04.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/03.jpg","path":"images/fulls/03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/08.jpg","path":"images/fulls/08.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/07.jpg","path":"images/fulls/07.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/06.jpg","path":"images/fulls/06.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/09.jpg","path":"images/fulls/09.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/10.jpg","path":"images/fulls/10.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/12.jpg","path":"images/fulls/12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/01.jpg","path":"images/thumbs/01.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/11.jpg","path":"images/fulls/11.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/02.jpg","path":"images/thumbs/02.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/04.jpg","path":"images/thumbs/04.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/03.jpg","path":"images/thumbs/03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/06.jpg","path":"images/thumbs/06.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/07.jpg","path":"images/thumbs/07.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/08.jpg","path":"images/thumbs/08.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/05.jpg","path":"images/thumbs/05.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/09.jpg","path":"images/thumbs/09.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/10.jpg","path":"images/thumbs/10.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/11.jpg","path":"images/thumbs/11.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/12.jpg","path":"images/thumbs/12.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Effective C++.md","hash":"efcbe24615e8c722bb21d81935972dc6f52784d2","modified":1675144088897},{"_id":"source/CNAME","hash":"680182c5adbce6d467a394df8ab22543d897dd45","modified":1675079480000},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1675077542000},{"_id":"source/_posts/.DS_Store","hash":"01250508fe2323148eb006bdc654a81859f4a900","modified":1675134920571},{"_id":"source/.DS_Store","hash":"ee5c90f14326493667c514ca06c0a6290ab1d32e","modified":1675144036882},{"_id":"source/images/.DS_Store","hash":"7566b5c6e49392c393ef6684ef7dea67d6779ab0","modified":1675144036881},{"_id":"source/images/effectivecxx.png","hash":"416aaa5e30b801175f88e4539a28a006e2e4767b","modified":1675135642393},{"_id":"themes/miccall/_config.yml","hash":"5de05ff001d5957968ce68c04391437e9238aa64","modified":1675145115478},{"_id":"themes/miccall/layout/post.ejs","hash":"d3c06743dfd9c137b8953e927d80d0099f169034","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/comment.ejs","hash":"c9fb1f98a18ca484cb52d60e2ad2bad25b56dfb2","modified":1540269858000},{"_id":"themes/miccall/.DS_Store","hash":"9457f542cf2c3f2a50b9ecd64858fc6f50b0d0c4","modified":1675129409957},{"_id":"themes/miccall/LICENSE","hash":"12d81f50767d4e09aa7877da077ad9d1b915d75b","modified":1540269858000},{"_id":"themes/miccall/readme.md","hash":"ee36b0cb76c688ed9fa8990eee5c49d5f2b53525","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/copyright.ejs","hash":"03f20eb5997f7132c232393b203fbca6eaec5205","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/footer.ejs","hash":"003361014b1467ce8062557c6c5952abaa9f00aa","modified":1540269858000},{"_id":"themes/miccall/layout/layout.ejs","hash":"41bd4dce5bebc122b09908c8336f404dca9db9ab","modified":1540269858000},{"_id":"themes/miccall/layout/index.ejs","hash":"f5e1bd35ce8e172ec0b5479066eec55a2ccc6c2f","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/head.ejs","hash":"de0a31f65a5efe69ffb04511c18b23c0c94f653a","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/gallery_js.ejs","hash":"2d4bf4e503f72f50e61fba396386dc7d57d3165f","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/intro.ejs","hash":"f1e136f0e6ede50d5ce5a3abbc14db63a92c04d3","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/mathjax.ejs","hash":"f98a7f202cc7645e42991c5ca75a791890160986","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/headerlogo.ejs","hash":"e9ba05cce80d7f93ba11a9ef5c8a12e958f996f2","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/importJS.ejs","hash":"31d45544f38d8016351f95f9ab5a2486c17a3acc","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/mainfirst.ejs","hash":"ea4fc5b7083f655aaf850e24bad811f5f98f6506","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/nav.ejs","hash":"05a44ee21f99b2ae8b99d924db6f1a2aa3e1e393","modified":1675138550865},{"_id":"themes/miccall/layout/_widget/page-links.ejs","hash":"bfe157e5e9f534cc40475b0470888d251fcc6f44","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/page-gallery.ejs","hash":"7d89025675f7f59395a888577e248f394f72c03c","modified":1540269858000},{"_id":"themes/miccall/source/.DS_Store","hash":"3358692d749bcd8f1292a89b85189b5662941f99","modified":1675130354890},{"_id":"themes/miccall/layout/_widget/page-tagcloud.ejs","hash":"bdd2cca14c209462c2b894de2563be5a2c6c5599","modified":1540269858000},{"_id":"themes/miccall/layout/_partial/gallery_head.ejs","hash":"4bd6fb2bdf51a21b7c5b4e95b0575f7e6ac3dcd1","modified":1540269858000},{"_id":"themes/miccall/source/css/dropdownMenu.css","hash":"3e44ce25f19c28dcf2c12db1938ccce7a081c10f","modified":1540269858000},{"_id":"themes/miccall/source/css/demo.css","hash":"99b020fe28a276c2b128a5048ab1325fc3303b96","modified":1540269858000},{"_id":"themes/miccall/source/css/backcss.css","hash":"0dddfb46461e9df113b7cb48e987ef22887133dd","modified":1675091586000},{"_id":"themes/miccall/source/css/font-awesome.min.css","hash":"03eb0a6b53db2655f3ded9bb1a4e4af07cc1efa6","modified":1540269858000},{"_id":"themes/miccall/source/css/gallery.css","hash":"4c0178ea898cdc5e010346b56d1c9845fe8da53e","modified":1540269858000},{"_id":"themes/miccall/source/css/my_link.css","hash":"c9535592792f2271df88c39e4baf8c849e23db17","modified":1540269858000},{"_id":"themes/miccall/source/css/mic_gallery.css","hash":"5c75b8ab2670599538a1250957cf7c44d0e4cbec","modified":1540269858000},{"_id":"themes/miccall/source/css/item.css","hash":"da1277164b611ccba56beda47960f9075c61dbab","modified":1540269858000},{"_id":"themes/miccall/source/css/noscript.css","hash":"5579ccdecc63139609db824704331d8d4af61538","modified":1540269858000},{"_id":"themes/miccall/source/css/ok_prism.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1540269858000},{"_id":"themes/miccall/source/css/prism_coy.css","hash":"24ebf5f3e5f68341522204dcaaf33f429d3c3718","modified":1540269858000},{"_id":"themes/miccall/source/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1540269858000},{"_id":"themes/miccall/source/css/prism_default.css","hash":"3600bee175b309662e306b50e494ac73495619c2","modified":1675143868409},{"_id":"themes/miccall/source/css/normalize.css","hash":"a0ff1e2feee0b1bb7e54a88fd6367ba3e7435aaf","modified":1540269858000},{"_id":"themes/miccall/source/css/prism_dark.css","hash":"8085542cdb4583ffb78b2edd146ebe9511bf668c","modified":1540269858000},{"_id":"themes/miccall/source/css/prism.css","hash":"b39768264f9923a770bcc3f289be0a2bd8e64268","modified":1540269858000},{"_id":"themes/miccall/source/css/prism_funky.css","hash":"aa0e3a37fb8ccce44457d7805a13d7c6094d1f5e","modified":1540269858000},{"_id":"themes/miccall/source/css/prism_twilight.css","hash":"17498435f6d964243c1a50deb563e6003aebe0e6","modified":1540269858000},{"_id":"themes/miccall/source/css/prism_solarized.css","hash":"73759f72dc43870aaf76dca7ef4e61a142b6b4f0","modified":1540269858000},{"_id":"themes/miccall/source/css/prism_okaidia.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1540269858000},{"_id":"themes/miccall/source/css/typo.css","hash":"768004dae4204dfbda865d412229feaa618ec3b7","modified":1540269858000},{"_id":"themes/miccall/source/img/logo.png","hash":"3760812b7f67b5f09b2d2da02a8da71fbfa80001","modified":1675088740000},{"_id":"themes/miccall/source/js/jquery.scrollex.min.js","hash":"57fa1d1de2eca4fabbe75d6d160edc45cc398075","modified":1540269858000},{"_id":"themes/miccall/source/js/gallery_skel.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/js/jquery.scrolly.min.js","hash":"6807fda8e44d95117e7007563a4db951818df82b","modified":1540269858000},{"_id":"themes/miccall/source/js/gallery_skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1540269858000},{"_id":"themes/miccall/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1540269858000},{"_id":"themes/miccall/source/js/jquery.scrolly.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/js/main.js","hash":"509935fbbf5896ee1e8f2047e961dd58894ae74d","modified":1540269858000},{"_id":"themes/miccall/source/js/jquery.scrollex.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/js/jquery.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/js/lazyload.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/js/mic_gallery.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/js/skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1540269858000},{"_id":"themes/miccall/source/js/main.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/js/util.js","hash":"3ece9010adc07dd3dc27ced0e22e7ac8bcd16e14","modified":1540269858000},{"_id":"themes/miccall/source/js/prism.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/js/mic_gallery.js","hash":"9f5d540f90fcef501df7a9f8272203d1604cd507","modified":1540269858000},{"_id":"themes/miccall/source/js/skel.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/img/.DS_Store","hash":"e0fc7a216220c32cc11cf1c801b10eb3b8c00c5a","modified":1675129490284},{"_id":"themes/miccall/source/js/util.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/images/12.jpg","hash":"88d68b169744a76ca7b21a258fc0812bc03ee701","modified":1540269858000},{"_id":"themes/miccall/source/images/3123.jpg","hash":"fc005184ff616231647c5dc85c63167040d810ba","modified":1540269858000},{"_id":"themes/miccall/source/images/pic02.jpg","hash":"ab77495fef5102f94e36b71d4308cd682dd4b1a8","modified":1540269858000},{"_id":"themes/miccall/source/images/.DS_Store","hash":"2bc8f117a40ea525672449ef1e7e0b7ef374bf19","modified":1675130354890},{"_id":"themes/miccall/source/images/pic01.jpg","hash":"774db644cdac607e0d9d72ca65a4961f9a250c11","modified":1540269858000},{"_id":"themes/miccall/source/images/pic03.jpg","hash":"ec46b8b1490a794ea5d4c61058959b9a52ac262f","modified":1540269858000},{"_id":"themes/miccall/source/images/pic04.jpg","hash":"ee299cd40108e50d7151333de525049f8ec4f150","modified":1540269858000},{"_id":"themes/miccall/source/images/pic09.jpg","hash":"6aae76e8215e3a6e785ce2a65484e4df03ed5fe9","modified":1540269858000},{"_id":"themes/miccall/source/images/overlay.png","hash":"e978d81201508e6fcbe0fe95485dae1a4b983a8d","modified":1540269858000},{"_id":"themes/miccall/source/images/pic07.jpg","hash":"de06b4eee3d0e42ddcac415adc8c83466f430253","modified":1540269858000},{"_id":"themes/miccall/source/images/pic06.jpg","hash":"3d8572663edf8a77b99bdfd93491d4f6a7298aaf","modified":1540269858000},{"_id":"themes/miccall/source/images/pic05.jpg","hash":"b74d638c0aa9e90f94b056db4c0a886e382973f1","modified":1540269858000},{"_id":"themes/miccall/source/images/pic08.jpg","hash":"993e8ff91c20b6d28b6302d3a18367547610c58a","modified":1540269858000},{"_id":"themes/miccall/source/images/pic11.jpg","hash":"a034beb80041d238f36685706a019a269f159ac1","modified":1540269858000},{"_id":"themes/miccall/source/images/pic12.jpg","hash":"ae93f2674a3b1f1dcbfe9692f2e172e106c02d96","modified":1540269858000},{"_id":"themes/miccall/source/css/images/close-small.svg","hash":"23e81571a4e597278e80a593c9e82a0f03d9d167","modified":1540269858000},{"_id":"themes/miccall/source/images/picx03.jpg","hash":"cffaa38c9489f131f6f37763b37b937811b316df","modified":1540269858000},{"_id":"themes/miccall/source/css/images/arrow.svg","hash":"84ad7a183fce70ac31766748919292d9db68c3c8","modified":1540269858000},{"_id":"themes/miccall/source/images/pic10.jpg","hash":"814a661f2966a3c8fe2c89034f62e828f291d770","modified":1540269858000},{"_id":"themes/miccall/source/css/images/arrow-small.svg","hash":"f00360be7c8c06c0ab9d008b3485429cd07b8621","modified":1540269858000},{"_id":"themes/miccall/source/css/images/close-small-alt.svg","hash":"6b0204bb16fc15963977c3921d631209afff8180","modified":1540269858000},{"_id":"themes/miccall/source/css/images/close.svg","hash":"7e524252c4610461102bf6da4b41eaa60845b642","modified":1540269858000},{"_id":"themes/miccall/source/css/images/open-small.svg","hash":"7ee24df085722b308c03d3b827fd0769a63e49f2","modified":1540269858000},{"_id":"themes/miccall/source/js/gallery/gallery.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1540269858000},{"_id":"themes/miccall/source/css/images/spinner.svg","hash":"7ef1bb9afa8be7be3509ba644c990b23f5876863","modified":1540269858000},{"_id":"themes/miccall/source/css/images/open.svg","hash":"f376adaf38d3fc3a2a0209e560a7d181105c75a6","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/01.jpg","hash":"cfc928948301b97ab2873e837284cd83cc3c6cff","modified":1540269858000},{"_id":"themes/miccall/source/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/02.jpg","hash":"1a729f597316a7483ebcf39b5984ced1612a0410","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/05.jpg","hash":"232b0b9e3b6e751ebb2e6c4284651639526200e3","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/07.jpg","hash":"eb41675450650b613195806b154c6badbb7eca4d","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/06.jpg","hash":"e97b29127a50c69cf445d0591cd94daab0f50e33","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/08.jpg","hash":"d31c389218f04bc7ec510ac236fbe343048e3cfc","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/09.jpg","hash":"61fab3aa8ceee938efb4965042ce2b5f51d3a584","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/10.jpg","hash":"9a284568752a54ab9e8e9cd19c41750e05975d2a","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/04.jpg","hash":"806679d4c4398335413b6b53941709a4aef7c3cd","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/12.jpg","hash":"a631491537584e2e23926d9d6f50ce60bb884b18","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/03.jpg","hash":"e3915b1cc3283b5ec33f49e2591ebf2e6be2362e","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/06.jpg","hash":"ffc80bb5fe28626d9462e06d9f01d2a5f99b0ae9","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/03.jpg","hash":"0f8c8109f8b605aa46ef571df1d16e8bdd43d090","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/01.jpg","hash":"4f5a2b9fdf44146d60f8dd3a32c81a8419b9148f","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/04.jpg","hash":"3c60445217b1b52b1fd6cae4578356c564d7624d","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/08.jpg","hash":"e0384120f6acfa64ad0b5bd0d7e114e9f239294e","modified":1540269858000},{"_id":"themes/miccall/source/images/fulls/11.jpg","hash":"cff6219163e3154c1263ee1d7f924c0ae3ccc9e7","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/02.jpg","hash":"396a422cbc1b94b6c9b00f6a34c02b05913230ba","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/07.jpg","hash":"45194a98089345e4f135c0f0bfffeee7ccdd9c99","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/disqus_click/common.ejs","hash":"d243f576b366a62191066459efcc6fd0ab79d00a","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/11.jpg","hash":"66a7fb237824b1b2fd550a068bb6a32f5031ab8f","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/09.jpg","hash":"bc8a02decf65e44657f02dcc11c7395bfa41ffdb","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/12.jpg","hash":"17ab685447ed06b6c12e4d42f38111c684221bc7","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/disqus/main.ejs","hash":"e545ec7bab21e2d345e058ed438e2031e3e1f353","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/disqus_click/enter.ejs","hash":"d82f0296f8bae25223ec44e6e05b817d3a234884","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/changyan/enter.ejs","hash":"e3cfb4f37ea35457f112f3e822e130c930086497","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/disqus/common.ejs","hash":"c11cfceb0906a96399dede5da01ff7fe4787f8a5","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/changyan/main.ejs","hash":"77539ff32cc9d1204b848e01b5277fff5cbd61e0","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/disqus/enter.ejs","hash":"ecde1e8e072cd6ec5b69287186c3551d246feb78","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/disqus_click/main.ejs","hash":"afc734b693b98128f0c45e70b4ecb5702b482829","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/changyan/common.ejs","hash":"40e1fc76d6b7f64e226693fb2fe1a6bb17bae245","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/valine/enter.ejs","hash":"0f1c274517b7d9008adbafdf456bbd24a615ffd3","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/05.jpg","hash":"3e28c2253db93ba42d16ba9a1f451dbc452fd947","modified":1540269858000},{"_id":"themes/miccall/layout/_widget/comment/valine/main.ejs","hash":"5f026c923ed86a46fd87086deff2ee2a9d13a8f5","modified":1540269858000},{"_id":"themes/miccall/source/images/thumbs/10.jpg","hash":"ccfee49fbca187bad971336cb8fda7dec05ab01e","modified":1540269858000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1540269858000},{"_id":"themes/miccall/source/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1540269858000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1540269858000},{"_id":"themes/miccall/source/css/mic_main.css","hash":"5c71bf6f16e51382c81c1828bf0324b3f25c075d","modified":1675133265713},{"_id":"themes/miccall/source/js/jquery.min.js","hash":"276c87ff3e1e3155679c318938e74e5c1b76d809","modified":1540269858000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1540269858000},{"_id":"themes/miccall/source/images/logo.png","hash":"ee2cf634d838f8acab5b826400edb0b42c8ce52b","modified":1540269858000},{"_id":"themes/miccall/source/images/me.jpg","hash":"742dfe1274e813c130933467d8088a49ff758306","modified":1675129375460},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1540269858000},{"_id":"themes/miccall/source/js/prism.js","hash":"0868d642f4661649a37dfb45b93fa30b4d92d4e4","modified":1540269858000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1540269858000},{"_id":"themes/miccall/source/images/21.jpg","hash":"0b2570df0e6d9b79a0c50d0b4ce8799bd40ea421","modified":1540269858000},{"_id":"themes/miccall/source/img/bg.png","hash":"26bde011d0c938038c3946443933e4dd6f9a4b79","modified":1675089246000},{"_id":"themes/miccall/source/fonts/FZLT.ttf","hash":"24dfab81236612d596c97eb38b3adf5de99f669c","modified":1540269858000},{"_id":"public/search.xml","hash":"98dd60d7471665b70bd88ad80f60ad39a684fe27","modified":1675145464529},{"_id":"public/2023/01/30/hello-world/index.html","hash":"3fef9c845309a0704be0784898f9c93a8fe24c72","modified":1675145464529},{"_id":"public/categories/Algorithm/index.html","hash":"db5de8a8eeac85e94c4754509fb4f56cdf6fd2aa","modified":1675145464529},{"_id":"public/index.html","hash":"c66a001ae688437a16c7e388902e59f648a05a68","modified":1675145464529},{"_id":"public/tags/C/index.html","hash":"db5de8a8eeac85e94c4754509fb4f56cdf6fd2aa","modified":1675145464529},{"_id":"public/archives/index.html","hash":"61d5d73747413ebfebba8efcb187b6f08fde15bf","modified":1675145464529},{"_id":"public/archives/2023/index.html","hash":"61d5d73747413ebfebba8efcb187b6f08fde15bf","modified":1675145464529},{"_id":"public/archives/2023/01/index.html","hash":"61d5d73747413ebfebba8efcb187b6f08fde15bf","modified":1675145464529},{"_id":"public/2023/01/31/Effective C++/index.html","hash":"acae5c3e9760e7df57514000a2aaec90c804cdd2","modified":1675145464529},{"_id":"public/CNAME","hash":"680182c5adbce6d467a394df8ab22543d897dd45","modified":1675145145077},{"_id":"public/img/logo.png","hash":"3760812b7f67b5f09b2d2da02a8da71fbfa80001","modified":1675145145077},{"_id":"public/js/jquery.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/js/jquery.scrolly.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/js/gallery_skel.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/js/jquery.scrollex.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/js/main.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/js/lazyload.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/images/12.jpg","hash":"88d68b169744a76ca7b21a258fc0812bc03ee701","modified":1675145145077},{"_id":"public/js/skel.min.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/js/util.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/images/3123.jpg","hash":"fc005184ff616231647c5dc85c63167040d810ba","modified":1675145145077},{"_id":"public/js/mic_gallery.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/js/prism.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/images/pic02.jpg","hash":"ab77495fef5102f94e36b71d4308cd682dd4b1a8","modified":1675145145077},{"_id":"public/images/pic01.jpg","hash":"774db644cdac607e0d9d72ca65a4961f9a250c11","modified":1675145145077},{"_id":"public/images/pic04.jpg","hash":"ee299cd40108e50d7151333de525049f8ec4f150","modified":1675145145077},{"_id":"public/images/pic06.jpg","hash":"3d8572663edf8a77b99bdfd93491d4f6a7298aaf","modified":1675145145077},{"_id":"public/images/pic07.jpg","hash":"de06b4eee3d0e42ddcac415adc8c83466f430253","modified":1675145145077},{"_id":"public/images/pic08.jpg","hash":"993e8ff91c20b6d28b6302d3a18367547610c58a","modified":1675145145077},{"_id":"public/images/pic09.jpg","hash":"6aae76e8215e3a6e785ce2a65484e4df03ed5fe9","modified":1675145145077},{"_id":"public/images/overlay.png","hash":"e978d81201508e6fcbe0fe95485dae1a4b983a8d","modified":1675145145077},{"_id":"public/images/pic03.jpg","hash":"ec46b8b1490a794ea5d4c61058959b9a52ac262f","modified":1675145145077},{"_id":"public/images/pic05.jpg","hash":"b74d638c0aa9e90f94b056db4c0a886e382973f1","modified":1675145145077},{"_id":"public/images/pic10.jpg","hash":"814a661f2966a3c8fe2c89034f62e828f291d770","modified":1675145145077},{"_id":"public/images/pic12.jpg","hash":"ae93f2674a3b1f1dcbfe9692f2e172e106c02d96","modified":1675145145077},{"_id":"public/css/images/arrow.svg","hash":"84ad7a183fce70ac31766748919292d9db68c3c8","modified":1675145145077},{"_id":"public/css/images/arrow-small.svg","hash":"f00360be7c8c06c0ab9d008b3485429cd07b8621","modified":1675145145077},{"_id":"public/images/picx03.jpg","hash":"cffaa38c9489f131f6f37763b37b937811b316df","modified":1675145145077},{"_id":"public/css/images/close.svg","hash":"7e524252c4610461102bf6da4b41eaa60845b642","modified":1675145145077},{"_id":"public/css/images/close-small-alt.svg","hash":"6b0204bb16fc15963977c3921d631209afff8180","modified":1675145145077},{"_id":"public/css/images/open.svg","hash":"f376adaf38d3fc3a2a0209e560a7d181105c75a6","modified":1675145145077},{"_id":"public/images/pic11.jpg","hash":"a034beb80041d238f36685706a019a269f159ac1","modified":1675145145077},{"_id":"public/css/images/close-small.svg","hash":"23e81571a4e597278e80a593c9e82a0f03d9d167","modified":1675145145077},{"_id":"public/css/images/spinner.svg","hash":"7ef1bb9afa8be7be3509ba644c990b23f5876863","modified":1675145145077},{"_id":"public/css/images/open-small.svg","hash":"7ee24df085722b308c03d3b827fd0769a63e49f2","modified":1675145145077},{"_id":"public/images/fulls/02.jpg","hash":"1a729f597316a7483ebcf39b5984ced1612a0410","modified":1675145145077},{"_id":"public/js/gallery/gallery.jsZone.Identifier","hash":"7e23cfba5e8908bfbd757427a2218bee1c041e4a","modified":1675145145077},{"_id":"public/images/fulls/04.jpg","hash":"806679d4c4398335413b6b53941709a4aef7c3cd","modified":1675145145077},{"_id":"public/images/fulls/03.jpg","hash":"0f8c8109f8b605aa46ef571df1d16e8bdd43d090","modified":1675145145077},{"_id":"public/images/fulls/07.jpg","hash":"eb41675450650b613195806b154c6badbb7eca4d","modified":1675145145077},{"_id":"public/images/fulls/05.jpg","hash":"232b0b9e3b6e751ebb2e6c4284651639526200e3","modified":1675145145077},{"_id":"public/images/fulls/08.jpg","hash":"d31c389218f04bc7ec510ac236fbe343048e3cfc","modified":1675145145077},{"_id":"public/images/fulls/09.jpg","hash":"61fab3aa8ceee938efb4965042ce2b5f51d3a584","modified":1675145145077},{"_id":"public/images/fulls/06.jpg","hash":"e97b29127a50c69cf445d0591cd94daab0f50e33","modified":1675145145077},{"_id":"public/images/thumbs/01.jpg","hash":"4f5a2b9fdf44146d60f8dd3a32c81a8419b9148f","modified":1675145145077},{"_id":"public/images/fulls/10.jpg","hash":"9a284568752a54ab9e8e9cd19c41750e05975d2a","modified":1675145145077},{"_id":"public/images/fulls/11.jpg","hash":"cff6219163e3154c1263ee1d7f924c0ae3ccc9e7","modified":1675145145077},{"_id":"public/images/thumbs/03.jpg","hash":"e3915b1cc3283b5ec33f49e2591ebf2e6be2362e","modified":1675145145077},{"_id":"public/images/fulls/01.jpg","hash":"cfc928948301b97ab2873e837284cd83cc3c6cff","modified":1675145145077},{"_id":"public/images/thumbs/06.jpg","hash":"ffc80bb5fe28626d9462e06d9f01d2a5f99b0ae9","modified":1675145145077},{"_id":"public/images/fulls/12.jpg","hash":"a631491537584e2e23926d9d6f50ce60bb884b18","modified":1675145145077},{"_id":"public/images/thumbs/08.jpg","hash":"e0384120f6acfa64ad0b5bd0d7e114e9f239294e","modified":1675145145077},{"_id":"public/images/thumbs/07.jpg","hash":"45194a98089345e4f135c0f0bfffeee7ccdd9c99","modified":1675145145077},{"_id":"public/images/thumbs/04.jpg","hash":"3c60445217b1b52b1fd6cae4578356c564d7624d","modified":1675145145077},{"_id":"public/images/thumbs/09.jpg","hash":"bc8a02decf65e44657f02dcc11c7395bfa41ffdb","modified":1675145145077},{"_id":"public/images/thumbs/10.jpg","hash":"ccfee49fbca187bad971336cb8fda7dec05ab01e","modified":1675145145077},{"_id":"public/images/thumbs/05.jpg","hash":"3e28c2253db93ba42d16ba9a1f451dbc452fd947","modified":1675145145077},{"_id":"public/images/thumbs/02.jpg","hash":"396a422cbc1b94b6c9b00f6a34c02b05913230ba","modified":1675145145077},{"_id":"public/images/thumbs/12.jpg","hash":"17ab685447ed06b6c12e4d42f38111c684221bc7","modified":1675145145077},{"_id":"public/images/thumbs/11.jpg","hash":"66a7fb237824b1b2fd550a068bb6a32f5031ab8f","modified":1675145145077},{"_id":"public/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1675145145077},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1675145145077},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1675145145077},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1675145145077},{"_id":"public/images/logo.png","hash":"ee2cf634d838f8acab5b826400edb0b42c8ce52b","modified":1675145145077},{"_id":"public/images/me.jpg","hash":"742dfe1274e813c130933467d8088a49ff758306","modified":1675145145077},{"_id":"public/css/demo.css","hash":"99b020fe28a276c2b128a5048ab1325fc3303b96","modified":1675145145077},{"_id":"public/css/backcss.css","hash":"0dddfb46461e9df113b7cb48e987ef22887133dd","modified":1675145145077},{"_id":"public/css/my_link.css","hash":"c9535592792f2271df88c39e4baf8c849e23db17","modified":1675145145077},{"_id":"public/css/prism_coy.css","hash":"24ebf5f3e5f68341522204dcaaf33f429d3c3718","modified":1675145145077},{"_id":"public/css/dropdownMenu.css","hash":"3e44ce25f19c28dcf2c12db1938ccce7a081c10f","modified":1675145145077},{"_id":"public/css/prism.css","hash":"b39768264f9923a770bcc3f289be0a2bd8e64268","modified":1675145145077},{"_id":"public/css/prism_default.css","hash":"3600bee175b309662e306b50e494ac73495619c2","modified":1675145145077},{"_id":"public/css/prism_dark.css","hash":"8085542cdb4583ffb78b2edd146ebe9511bf668c","modified":1675145145077},{"_id":"public/css/normalize.css","hash":"a0ff1e2feee0b1bb7e54a88fd6367ba3e7435aaf","modified":1675145145077},{"_id":"public/css/prism_okaidia.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1675145145077},{"_id":"public/css/prism_funky.css","hash":"aa0e3a37fb8ccce44457d7805a13d7c6094d1f5e","modified":1675145145077},{"_id":"public/css/noscript.css","hash":"5579ccdecc63139609db824704331d8d4af61538","modified":1675145145077},{"_id":"public/css/prism_solarized.css","hash":"73759f72dc43870aaf76dca7ef4e61a142b6b4f0","modified":1675145145077},{"_id":"public/css/prism_twilight.css","hash":"17498435f6d964243c1a50deb563e6003aebe0e6","modified":1675145145077},{"_id":"public/css/typo.css","hash":"768004dae4204dfbda865d412229feaa618ec3b7","modified":1675145145077},{"_id":"public/css/ok_prism.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1675145145077},{"_id":"public/js/gallery_skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1675145145077},{"_id":"public/js/jquery.scrollex.min.js","hash":"57fa1d1de2eca4fabbe75d6d160edc45cc398075","modified":1675145145077},{"_id":"public/js/skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1675145145077},{"_id":"public/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1675145145077},{"_id":"public/js/jquery.scrolly.min.js","hash":"6807fda8e44d95117e7007563a4db951818df82b","modified":1675145145077},{"_id":"public/js/mic_gallery.js","hash":"9f5d540f90fcef501df7a9f8272203d1604cd507","modified":1675145145077},{"_id":"public/js/util.js","hash":"3ece9010adc07dd3dc27ced0e22e7ac8bcd16e14","modified":1675145145077},{"_id":"public/js/main.js","hash":"509935fbbf5896ee1e8f2047e961dd58894ae74d","modified":1675145145077},{"_id":"public/css/gallery.css","hash":"4c0178ea898cdc5e010346b56d1c9845fe8da53e","modified":1675145145077},{"_id":"public/css/font-awesome.min.css","hash":"03eb0a6b53db2655f3ded9bb1a4e4af07cc1efa6","modified":1675145145077},{"_id":"public/css/mic_gallery.css","hash":"5c75b8ab2670599538a1250957cf7c44d0e4cbec","modified":1675145145077},{"_id":"public/css/item.css","hash":"da1277164b611ccba56beda47960f9075c61dbab","modified":1675145145077},{"_id":"public/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1675145145077},{"_id":"public/css/mic_main.css","hash":"5c71bf6f16e51382c81c1828bf0324b3f25c075d","modified":1675145145077},{"_id":"public/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1675145145077},{"_id":"public/js/jquery.min.js","hash":"276c87ff3e1e3155679c318938e74e5c1b76d809","modified":1675145145077},{"_id":"public/js/prism.js","hash":"0868d642f4661649a37dfb45b93fa30b4d92d4e4","modified":1675145145077},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1675145145077},{"_id":"public/images/effectivecxx.png","hash":"416aaa5e30b801175f88e4539a28a006e2e4767b","modified":1675145145077},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1675145145077},{"_id":"public/images/21.jpg","hash":"0b2570df0e6d9b79a0c50d0b4ce8799bd40ea421","modified":1675145145077},{"_id":"public/img/bg.png","hash":"26bde011d0c938038c3946443933e4dd6f9a4b79","modified":1675145145077},{"_id":"public/fonts/FZLT.ttf","hash":"24dfab81236612d596c97eb38b3adf5de99f669c","modified":1675145145077}],"Category":[{"name":"Algorithm","_id":"cldju62dt0002qq3cdu711c55"}],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2023-01-30T11:19:02.000Z","updated":"2023-01-30T11:19:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldju62dp0000qq3c4eqiacb5","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<h3 id=\"Create-a-new-post\">Create a new post</h3>\n<pre><code class=\"language-bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\">Run server</h3>\n<pre><code class=\"language-bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\">Generate static files</h3>\n<pre><code class=\"language-bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\">Deploy to remote sites</h3>\n<pre><code class=\"language-bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<h3 id=\"Create-a-new-post\">Create a new post</h3>\n<pre><code class=\"language-bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\">Run server</h3>\n<pre><code class=\"language-bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\">Generate static files</h3>\n<pre><code class=\"language-bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\">Deploy to remote sites</h3>\n<pre><code class=\"language-bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Effective C++","date":"2023-01-31T02:01:25.000Z","thumbnail":"/images/effectivecxx.png","_content":"# Effective C++\n\n## 一：C++基础\n\n### C++很成熟，很NB\n\nC++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）\n\n其核心是四个部分\n\n- C\n  - 区块block\n  - 语句statements\n  - 预处理器preprocessor\n  - 内置数据类型\n  - 数组arrays\n  - 指针pointers\n- Object-Orientend C++\n  - 类classes（构造函数，析构函数）\n  - 封装encapsulation\n  - 继承inheritance\n  - 多态polymorphism\n  - 虚函数virtual（动态绑定）\n- Template C++\n- STL\n\n### 替换#define\n\n使用编译器替代预处理器\n\n尽量使用const、enum定义常量，使用inlines定义函数宏\n\n#### const\n\n```c++\n#define PI 3.1415926\n```\n\n因为`#define`不是语言的一部分，在编译器开始工作前，`PI`就会被处理掉，所以一旦报错，你无法追踪到`PI`，只能看到`3.1415926`，这会**浪费你的时间**\n\n应该改为\n\n```c++\nconst double Pi 3.1415926;\n```\n\n值得注意的事\n\n- 定义常量指针指向char*-based字符串\n\n```c++\nconst char* const authorName = \"Reuben\";\n```\n\n- 作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员\n\n```c++\nclass GemePlayer{\nprivate:\n\tstatic const int NumTurns = 5;\t//这只是一个声明式\n\tint scores[NumTurns];\n};\nconst int GamePlayer::NumTurns;\t\t//这是定义式，因为在声明时已经赋值，所以这里就不赋值了\n```\n\nC++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式\n\n从这里可以看出，**const可以封装**，而#define不行\n\n#### enum\n\n```c++\nclass GemePlayer{\nprivate:\n\tenum { NumTurns = 5 };\n\tint scores[NumTurns];\n};\n```\n\n### const指针\n\nconst在星号左边，被指物是常量\n\n```c++\nchar greeting[] = \"Hello\";\nconst char* p = greeting;\n```\n\nconst在星号右边，指针本身是常量\n\n```c++\nchar greeting[] = \"Hello\";\nchar* const p = greeting;\n```\n\nconst在星号两边，被指物和指针都是常量\n\n```c++\nchar greeting[] = \"Hello\";\nconst char* const p = greeting;\n```\n\n### 确认对象在使用前已经被初始化\n\nC++初始化顺序\n\n- 基类比子类先初始化\n- 成员变量根据其声明次序初始化\n\n## 二：构造/析构/赋值\n\n### 空类的默认函数\n\n一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数\n\n一个类，如果没有构造函数，也会自动声明一个default构造函数\n\n这些函数都是public且inline的\n\n### 禁用自动生成的函数\n\n如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）\n\n- 你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）\n\n```c++\nclass HomeForSale{\nprivate:\n\tHomeForSale(const HomeForSale&);\n  HomeForSale& operator=(const HomeForSale&);\n};\n```\n\n可以制作一个不可被copy的类，让子类继承\n\n```c++\nclass Uncopyable{\nprotected:\n\tUncopyable(){}\n  ~Uncopyable(){}\nprivate:\n  Uncopyable(const Uncopyable&);\n  Uncopyable& operator=(const Uncopyable&);\n};\n\nclass HomeForSale: private Uncopyable{\n  ...\n};\n```\n\n### 为多态基类声明virtual析构函数\n\n#### 一定要有一个virtual析构函数\n\n- 如果这个类要成为一个基类，那么一定要有一个virtual析构函数\n\n在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错\n\n```c++\nclass TimeKeeper{\npublic:\n\t...\n};\nclass AtomicClock: public TimeKeeper {...};\nclass WaterClock: public TimeKeeper {...};\n```\n\n```c++\nTimeKeeper* ptk = getTimeKeeper();\t\t//创建一个动态分配对象\n...\ndelete ptk;\t//释放对象，避免资源泄漏\n```\n\n上面这个过程的问题其实出在`getTimeKeeper()`指向一个派生类（derived class）对象（比如`AtomicClock`），而这个对象却要经由一个基类（base class）指针删除（比如`TimeKeeper*`）\n\n如果这个基类的析构函数不是virtual的，就会出现问题：\n\n- 如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象\n\n解决方法就是给基类一个virtual析构函数\n\n```c++\nclass TimeKeeper{\npublic:\n\tTimeKeeper();\n  virtual ~TimeKeeper();\n  ...\n};\n```\n\n#### 最好不要有virtual析构函数\n\n- 如果这个类不可能成为基类，那么最好不要有virtual析构函数\n\n为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由**vptr（virtual table pointer）**指针携带，这个指针指向一个由函数指针构成的数组，称为**vtbl（virtual table）**，每一个带有virtual函数的类都有一个属于自己的vtbl\n\n**这个vtbl会增大对象的体积**，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍\n\n**这个vtbl会让代码失去兼容性**，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性\n\n#### 请不要继承没有virtual析构函数的类\n\n比如string、vector、list、set等等\n\n而且 C++没有像 Java的`final classes`或者C#的`sealed classes`的禁止派生机制\n\n### 不要在析构函数里抛出异常\n\n当一个`vector v`容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为\n\n有两个不怎么好的解决方法\n\n- 遇到异常，直接`std::abort()`，即遇到异常，宁愿直接强制停止程序，也不要让异常传播\n- 遇到异常，把异常记录下来，另程序继续运转，即**吞下异常**\n  - 这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好\n\n比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容\n\n```c++\nclass DBConnevtion{\npublic:\n    ...\n    static DBConnevtion create();\n    void close();     \n};\nclass DBConn{\npublic:\n    ...\n    void close()\t//封装给客户用的,关闭连接的函数\n    {\n        db.close();\n        closed = true;\n    }\n    ~DBConn(){\n        if(!closed){\n            try{\n                db.close();\n            }\n            catch(...){\n                ...\n                //强制关闭程序或者吞下异常\n            }\n        }\n    }\nprivate:\n    DBConnection db;\n    bool closed;\n};\n```\n\n### 不要在构造和析构过程中调用virtual函数\n\n在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果\n\n可以简单理解为**在C++中，基类构造期间，vritual函数不是vritual函数**\n\n因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数\n\n同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的\n\n### 令operator=返回一个对\\*this的引用\n\n连续赋值\n\n```c++\nx = y = z = 15;\n//其实就等于x = (y = (z = 15))；\n```\n\n为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参\n\n```c++\nclass Widget{\npublic:\n    Widget& operator=(const Widget& rhs)\n    {\n    \t...\n        return *this;\n    }\n    Widget& operator+=(const Widget& rhs){\n        ...\n        return *this;\n    }\n};\n```\n\n### 在operator=中处理自我赋值\n\n如果对象自己赋给自己，我们称之为自我赋值\n\n```c++\nw = w;\na[i] = a[j]; //当i=j时，自我赋值\n*px = *py;\t//px和py指向同一个物体时，自我赋值\n```\n\n在赋值操作中：\n\n1. 我们会先另左边的操作数先释放掉当前使用的数据\n2. 令其使用右操作数的副本\n3. 最后返回左操作数\n\n```c++\nclass Widget{\n    ...\nprivate:\n    Bitmap *pb;\n};\n//!!!这个不安全\nWidget& Widget::operator=(const Widget& rhs){\n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\n}\n```\n\n如果自我赋值，即rhs和pb指向同一个对象，那么`delete pb`后，这个对象就已经被销毁了，下面使用的`*rhs`就是一个已经被删除的对象\n\n解决方法1：延后delete\n\n```c++\nWidget& Widget::operator=(const Widget& rhs){\n    Bitmap* pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\n    delete pOrig;\n    return *this;\n}\n```\n\n解决方法2：使用copy and swap技术\n\n```c++\nWidget& Widget::operator=(const Widget& rhs){\n    Widget temp(rhs);\n    swap(temp);\t\t//令*this与temp交换\n    return *this;\n}\n```\n\n### 复制对象的一切\n\n如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错\n\n派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）\n\n所以copy函数需要\n\n- 复制所有local变量\n- 调用所有基类中的适当的copy函数\n\n## 三：资源管理\n\n### 让对象管理资源\n\n将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源\n\n- 申请资源后立即将其放进对象中，**资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）**\n- 在对象的析构函数中释放资源\n\nC++的`auto_ptr`是一个**类指针（pointer-like）对象**，也就是**智能指针**，其析构函数会自动delete掉其所指向的对象\n\n注意：\n\n- 不要让多个`auto_ptr`指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”\n- `auto_ptr`如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权\n\n**RCSP（引用计数型智能指针）**也是一种智能指针（比如`tr1::shared_ptr`），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源\n\n### 小心copy行为\n\n大多数RAII对象的copy函数：\n\n- 禁止复制\n- 采用引用计数法（RCSP）\n- 复制底部资源（深拷贝）\n- 转移底层资源所有权（auto_ptr）\n\n### 在资源管理类中提供对原始资源的访问\n\n有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）\n\n### new与delete一个数组\n\n一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？\n\n- 如果new了一个数组，就delete一个数组\n\n```c++\nstring* ptr1 = new string[100];\ndelete [] ptr1;\n```\n\n- 如果new了一个对象，就delete一个对象\n\n```c++\nstring* ptr2 = new string;\ndelete ptr2;\n```\n\n很多时候很难确定当前这个对象是数组还是一个对象\n\n```c++\ntypedef string AddressLines[4];\nstring* pal = new AddressLines;\ndelete [] pal;\n```\n\n最简单的方法是不用数组，使用STL里的容器，如`vector<string>`\n\n### 以独立语句将newed对象置入智能指针\n\nC++中调用一个函数，会先计算每一个传递进去的实参\n\n如果按下面的写法，将newed对象置入智能指针中\n\n```c++\n分配函数(shared_ptr<Widget>(new Widget), 资源访问);\t\t//不要这样写\n```\n\n需要执行一下函数\n\n- 调用“资源访问”函数（A）\n- 执行`new Widget`（B）\n- 调用`shared_ptr`构造函数（C）\n\n然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）\n\n如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏\n\n所以简单的方法是分离语句\n\n```c++\nshared_ptr<Widget> pw(new Widget);\n分配函数(pw, 资源访问);\n```\n\n## 四：设计与声明\n\n### 让接口容易被正确使用\n\n客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）\n\n#### 限制参数传递\n\n这是一个日期类\n\n```c++\nclass Date{\npublic:\n  Date(int month, int day, int year);\n  ...\n};\n...\nDate d(4, 20, 2022);\n```\n\n客户很有可能填错顺序，也有可能填入一个无效的参数\n\n可以使用**外覆类型（wrapper types）**，当然做出类会更好\n\n```c++\nstruct Day{\n  explict Day(int d) : val(d) {}\n  int val;\n};\nstruct Month{\n  explict Month(int m) : val(m) {}\n  int val;\n};\nstruct Year{\n  explict Year(int y) : val(y) {}\n  int val;\n};\nclass Date{\npublic:\n  Date(const Mouth& month, const Day& day, const Year& year);\n  ...\n};\n...\nDate d(Month(4), Day(20), Year(2022));\n```\n\n#### 一致性\n\n自定义的行为要与内置类型的行为一致，比如你不能把`operator*`重载成`operator+`\n\n或则像STL中，容器的接口都很一致，比如`size`、`push_back`等等\n\n### 设计class犹如设计type\n\n- 对象要如何创建和销毁\n- 对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）\n- 对象如果被值传递，意味着什么（深浅拷贝）\n- 约束成员变量的合法值\n- 是否可以/需要被继承\n- 能否类型转换，如何类型转换\n- 支持何种操作符\n- 成员变量的访问修饰\n- 成员函数的访问修饰\n- 未声明接口（undecided interface）\n- 是否需要定义模版\n- 真的需要一个新类吗？\n\n### 多用引用传递\n\nC++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些**很大的自定义类型**来说性能非常糟糕\n\n使用const引用传递会好很多\n\n- 不会创建新的对象\n- 不会改变原有对象\n- 可以避免**对象切割**问题\n  - 对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了\n\n只不过引用传递是大多是通过指针实现的，在处理一些**简单的内置类型**时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递\n\n### 必须返回对象时，不要返回引用\n\n如果必须返回对象，请不要返回引用（比如`operator*`，`operator==`），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个**右值**的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用\n\n### 将成员变量隐藏\n\n成员变量应该为private，而不是public\n\n- 客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）\n- 分离读写权限（这一点C#做的更好？）\n- 封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）\n- 便于对成员变量进行约束（更不容易出现异常值）\n- protected并不比public更具有封装性\n\n### 使用非成员函数\n\n- C#，java选手可以略过\n- C++标准库就是这样写的\n\n这里有一个类，其中有多个成员函数\n\n```c++\nclass WebBrowser{\npublic:\n\tvoid doA();\n  void doB();\n  void doC();\n  ...\n};\n```\n\n现在需要令一个函数做ABC三件事，有两种写法\n\n- 成员函数\n\n```c++\nclass WebBrowser{\npublic:\n\t...\n  void doEverything(){\n    doA();\n    doB();\n    doC();\n  }\n  ...\n};\n```\n\n- 非成员函数\n\n```c++\nvoid doEverything(WebBrowser& wb){\n\twb.doA();\n  wb.doB();\n  wb.doC();\n}\n```\n\n令人意外的是，第二种方法（使用非成员函数）更好\n\n#### 什么是封装\n\n一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强\n\n为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物\n\n#### 为什么第二种比第一种封装性更强\n\n因为第一种给用户两种调用方法，一个是调用成员函数`doEverything()`，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性\n\n- 注意第一种方法中，`doEverything()`和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利\n\n那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的**静态成员（static member）函数**即可\n\n或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）\n\n```c++\nnamespace WebBrowserStuff{\n\tclass WebBrowser{...};\n\tvoid doEverything(WebBrowser& wb){...}\n}\n```\n\n- 可拓展性更强\n  - 客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）\n\n- 可拆分\n  - 用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）\n\n### 如果所有参数都需要进行类型转换，使用非成员函数\n\n令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时\n\n比如一个有理数乘法\n\n```c++\nclass Rational{\npublic:\n  //这个类没有自定义的explict构造函数\n  const Rational opertaor* (const Rational& rhs) const;\n  ...\n};\n```\n\n```c++\nRational oneEighth(1,8);\nRational oneHalf(1,2);\nRational result = oneHalf * oneEighth;\t//成功\nresult = result * oneEighth;\t//成功\nresult = oneHalf * 2;\t\t//成功，等价于 result = oneHalf.operator*(2)\nresult = 2 * oneHalf;\t\t//失败，等价于 result = 2.operator*(oneHalf)\n```\n\n`result = oneHalf * 2;`为什么成功，因为这里发生了一次隐式转换，将`2`转化为了一个`Rational`类型\n\n在编译器中可能等价于\n\n```c++\nconst Rational temp(2);\nresult = oneHalf * temp;\n```\n\n- 如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将`2`转化为一个`Rational`类型\n\n`result = 2 * oneHalf;\t`为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时`2`就是一个int类型，没有我们所自定义的`operator*`函数，自然会失败\n\n可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）\n\n```c++\nconst Rational operator*(const Rational& lhs, const Rational& rhs){\n  return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());\n}\n```\n\n- 此外要极力避免使用**友元（friend）函数**\n- 成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数\n\n\n\n### 写一个不抛异常的swap函数\n\nswap函数原本是STL的一部分，后来称为了**异常安全性编程**的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要\n\nstd是一个很特殊的命名空间，客户可以**全特化**（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定\n\n全特化：针对某个类做模板函数的特例，如对`std::swap`做一个针对`Widget`的特化\n\n```c++\nclass WidgetImpl{...};\t\t//这个类的对象中存储着真正的数据\nclass Widget{\npublic:\n    Widget& operator=(const Widget& rhs){\n        ...\n        *pImpl = *(rhs.pImpl);\n        ...\n    }\n    ...\n    void swap(Widget& other){\t//这个函数决对不可抛异常\n        using std::swap;\n        swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针\n    }\n    ...\nprivate:\n    WidgetImple* pImpl;\t\t//这个类有一个指向资源对象的指针\n};\nnamespace std{\n\ttemplate<>\n    void swap<Widget>(Widget& a, Widget& b){\t//这个可以抛异常\n        a.swap(b);\t\n    }\n}\n```\n\n此外，C++的STL容器就是上面这种写法，提供了`public swap`成员函数和`std::swap`的特化版本\n\n## 五：实现（Implementations）\n\n- 随意定义变量可能会导致性能降低\n- 过度使用转型（casts）可能会导致性能降低，难以维护，可读性低\n- 返回对象的内部数据的handles，可能会破坏封装\n- 未考虑异常可能会导致资源泄露和数据败坏\n- 过度使用inline可能会导致包体膨胀\n- 过度耦合（coupling）可能会增加构建时间（build times）\n\n### 尽量延后变量定义式的出现时间\n\n#### 避免未曾使用的变量\n\n如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过\n\n此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、\n\n#### 避免无意义的默认构造函数\n\n如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好\n\n#### 循环\n\n此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？\n\n**循环内**\n\n```c++\nfor(int i = 0; i < n; i++){\n  Widget w(...);\n  ...\n}\n```\n\n- n个构造函数+n个析构函数\n\n- 如果`Widget`是一个很敏感的类，这样会让其作用域更小，更容易理解和维护\n\n**循环外**\n\n```c++\nWidget w;\nfor(int i = 0; i < n; i++){\n  w = ...;\n  ...\n}\n```\n\n- 一个构造函数+一个析构函数+n个赋值操作\n- 如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）\n\n### 少做转型\n\nC++是强类型语言，设计目标应该是保证类型错误绝不发生，然而**类型转换**破坏了类型系统\n\nJava、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险\n\nC++的类型转化\n\n- 旧式转换\n  - `(T)expression`\n  - `T(expression)`\n- 新式转换\n  - `const_cast<T>(expression)`\n    - 用于将对象的**常量性转除（cast away the constness）**\n    - 比如将`const`转化为`non-const`\n  - `dynamic_cast<T>(expression)`\n    - 用来**安全向下转型**\n    - 无法由旧式语句执行\n    - 耗费巨大\n  - `reinterpret_cast<T>(expression)`\n    - 用于低级转型，实际操作取决于编译器，不可移植\n    - 极其少用\n  - `static_cast<T>(expression)`\n    - 用于**强迫隐式转换（implicit conversions）**\n    - 比如`non-const`转化为`const`，`int`转化为`double`，`void*`转化为`typed`，基类指针转化为派生类指针\n\n避免C++类型转换出问题的核心是**避免使用基类的接口处理派生类**\n\n#### 一个对象多个地址\n\nC++很神奇，如果一个基类指针指向一个派生类对象，如\n\n```C++\nDervied d;\nBase* b = &d;\n```\n\n这可能会导致两个指针值不一样，即这个对象有两个地址，一个`Derivied*`指针一个`Base*`指针，这派生类指针上往往会有一个**偏移量（offset）**，通过这个偏移量，可以通过派生类指针找到基类指针\n\n上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以**请不要假定对象在C++中如何布局**，更不应该基于这个假设对对象进行类型转换\n\n如果你想让当前对象调用基类的函数，如果对`*this`做强制转化，转换为基类，`*this`其实是先前产生的`*this`对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题\n\n```c++\nclass SpecialWindow: public Window{\npublic:\n  virtual void onResize(){\n    //static_cast<Window>(*this).onResize();\t//这样不好\n    Window::onResize();\t\t//请用这种方式调用基类的onResize函数（作用到当前对象上）\n    ...\n  }\n}\n```\n\n#### dynamic_cast\n\n这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象\n\n什么时候使用这个东西？当**你想在**一个你认为是派生类对象的**对象上执行**派生类的操作**函数**，但你手里却只有一个指向基类的引用/指针时\n\n解决方法：\n\n- 使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器\n- 在基类中提供virtual函数\n\n### 避免返回指向对象内部成分的handles\n\n前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便\n\n但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的\n\n```c++\nclass Point{\npublic:\n  ...\n  void setX(int val);\n  ...\n};\nstruct RectData{\n  Point ulhc;\t\t//upper left hand corner\n  Point lrhc;\t\t//lower right hand corner\n};\nclass Rectangle{\npublic:\n  ...\n  Point& upperLeft() const { return pData->ulhc; }\t//这样返回了引用，非常不好\n  ...\nprivate:\n  std::tr1::shared_ptr<RectData> pData;\n};\n...\nrec.upperLeft().setX(50);\t\t//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改\n```\n\n`upperLeft`函数本来只是为了提供给客户获得（get）`Rectangle`的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了`Rectangle`本身，而且还是一个内部数据`RectData`\n\n为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）\n\n解决方法很简单，只要让handles不可以被修改，就可以了\n\n```c++\nclass Rectangle{\npublic:\n  ...\n  const Point& upperLeft() const { return pData->ulhc; }\t\n  ...\n};\n```\n\n但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致**dangling handles（空悬的号码牌）**，比如返回了一个对local变量的引用，依然特别危险\n\n当然，有的时候不得不返回handles，比如`operator[]`\n\n### 异常安全性很重要\n\n**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：\n\n- 不泄漏任何资源\n- 不允许数据败坏\n\n不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂\n\n三个保证：\n\n- 基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏\n- 强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过`copy-and-swap`实现）\n- 不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）\n\n**异常安全码**必须提供上述三种保障之一，如果不能保障，则不具备异常安全性\n\n### 了解inline函数\n\n内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化\n\n缺点也很明显，会让包体变大，会导致**换页行为（paging）**，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数\n\n内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联\n\n### 降低文件间的编译依存\n\n如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译\n\n为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用）\n\n这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类\n\n*话说应该不会有人不知道implementation是实现的意思吧*\n\n```c++\nclass PersonImpl;\t//pimpl写法，这是Person类的前置声明\nclass Data;\t\t\t\t//Data的前置声明\nclass Address;\t\t//Address的前置声明\n\nclass Persion{\t//像这样使用pimpl的类，往往被称为Handle classes\npublic:\n  ...\n  std::string name() const;\n  ...\nprivate:\n  std::tr1::shared_ptr<PersonImpl> pImpl;\n};\n```\n\n在这种设计下，`Person`就与`Data`、`Address`以及`Persons`的实现分离了，改动这些类也不会导致使用`Person`的客户重新编译，客户无法看到`Person`的实现细节，真正实现**接口与实现分离**\n\n这个操作的本质是用**声明的依赖性**替换**定义的依赖性**\n\n此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明\n\n此外还有另一种制作`Handle class`的方法，就是令`Person`成为一个特殊的抽象基类，称为`Interface class`，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）\n\n```c++\nclass Person{\t\t//Interface class\npublic:\n  virtual ~Person();\n  virtual std::string name() const = 0;\n  ...\n};\nclass Person{\t\t//具现化\npublic:\n  static std::tr1::shared_ptr<Person> create(const std::string& name...);\n  ...\n};\n...\n//使用\nstd::tr1::shared_ptr<Person> pp(Person::create(name...));\nstd::cout << pp->name();\n```\n\n```c++\nclass RealPerson: public Person{\t\npublic:\n  RealPerson(const std::string& name, ...): theName(name), ...{}\n  virtual ~RealPerson() {}\n  std::string name() const;\t\t\n  ...\nprivate:\n\tstd::string theName;\n};\nstd::string ReakPerson::name(){...}\nstd::tr1::shared_ptr<Person> Person::create(const std::string& name, ...){\n  retrun std::tr1::shared_ptr<Person>(new RealPerson(name, ...));\n}\n```\n\n## 六：继承与面向对象\n\n- `is-a`：是一个\n- `has-a`：有一个\n- `is-implemented-in-terms-of`：根据xx实现出\n\n### public继承是is-a关系\n\n```c++\nclass Student: public Person{...};\t//Student is a Person\n```\n\n每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化\n\n**public继承下，可以把子类当父类用**，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用\n\n这就出现了一个问题，子类一定要`is a`父类，不然会出现问题\n\n错误的继承：\n\n- 企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？\n- 正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？\n\n### 避免遮掩父类成员\n\n```c++\nint x;\nvoid Fun(){\n    double x;\n    ...\n}\n```\n\n由于**作用域**的**名称遮掩规则**，函数内部的local变量x覆盖了全局变量x\n\n#### 子类名称会遮掩父类名称，在public继承下是错误的\n\n在OOP中，如果子类重载了父类的`non-virtual`函数，就意味着子类使用同名函数遮掩了父类函数，就意味着**这个父类函数没有被子类继承！**，那么在这种情况下，继承就不是`is-a`关系了\n\n**在public继承下，子类继承了父类的一切**\n\n```c++\nclass Base{\npublic:\n    virtual void f1() = 0;\n    virtual void f1(int);\n    void f2();\n    void f2(double);\n    ...\nprivate:\n    int x;\n};\nclass Derived: public Base{\npublic:\n    virtual void f1();\n    void f2();\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)\n```\n\n#### 将被遮掩的名称重见天日\n\n解决起来很简单，只需要让父类的函数在子类作用域内可见，可以**使用using关键字**\n\n```c++\nclass Derived: public Base{\npublic:\n    using Base::f1;\n    using Base::f2;\n    virtual void f1();\n    void f2();\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//正确，调用Base::f1\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//正确，调用Base::f2\n```\n\n如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以**使用转交函数**，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中\n\n```c++\nclass Derived: private Base{\npublic:\n    virtual void f1(){\n        Base::f1();\t\t//inline转交函数\n    }\n    ...\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1\n```\n\n### 区分接口继承和实现继承\n\npublic继承分为两个部分\n\n- 函数接口继承\n- 函数实现继承\n\n|                 | 接口继承 | 实现继承         |\n| --------------- | -------- | ---------------- |\n| 纯虚函数        | 具体指定 | 不继承           |\n| 非纯虚函数      | 具体指定 | 继承一份缺省实现 |\n| non-virtual函数 | 具体指定 | 继承一份强制实现 |\n\n### 考虑使用virtual以外的选择\n\n#### 基于NVI的Template Method模式\n\nNon-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数\n\n```c++\nclass GameCharacter{\npublic：\n    int healthValue() const\n\t{\n    \t...\n    \tint retVal = doHealthValue();\n    \t...\n    \treturn retVal;\n\t}\nprivate：\n    virtual int doHealthValue() const\n    {\n\t\t...\n    }\n};\n```\n\n其中`healthValue()`被称为virtual函数的**外覆器（wrapper）**\n\n#### 基于函数指针的Strategy模式\n\n```c++\nclass GameCharacter;\nint defaultHealthCalc(const GameCharacter& gc);\nclass GameCharacter{\npublic:\n    typedef int (*HealthCalcFunc)(const GameCharacter&);\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf){}\n    int healthValue() const { return healthFunc(*this); }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\n在这种模式下，`defaultHealthCalc`函数不再是`GameCharacter`体系内的成员函数，通过修改函数指针，就可以让`GameCharacter`使用不同种类的计算函数，弹性更强，而且可以在运行时变更\n\n此外`defaultHealthCalc`函数不需要/不能访问`GameCharacter`内的`non-public`部分，\n\n####  基于tr1::function的Strategy模式\n\n上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如`tr1::function`对象\n\n```c++\nclass GameCharacter;\nint defaultHealthCalc(const GameCharacter& gc);\nclass GameCharacter{\npublic:\n    typedef std::tr1::function<int (const GameCharacter&)> HealthCalcFunc;\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf){}\n    int healthValue() const { return healthFunc(*this); }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\n#### 古典的Strategy模式\n\n```c++\nclass GameCharacter;\nclass HealthCalcFunc{\npublic:\n    ...\n    virtual int calc(const GameCharacter& gc) const{...}\n    ...\n};\nHealthCalcFunc defaultHealthCalc;\nclass GameCharacter{\npublic:\n    explicit GameCharacter(HealthCalcFunc* phcf = &defaultHealthCalc): pHealthFunc(phcf){}\n    int healthValue() const { return phealthFunc->calc(*this); }\n    ...\nprivate:\n    HealthCalcFunc* pHealthFunc;\n};\n```\n\n### 绝不重新定义继承而来的non-virtual函数\n\n- 静态绑定（staticcally bound）：non-virtual就是这种\n- 动态绑定（dynamically bound）：virtual就是这种\n\n```c++\nclass B{\npublic:\n\tvoid f();\n\t...\n};\nclass D: public B{\npublic:\n  void f();\n  ...\n};\n...\nD x;\nB* pB = &x;\nD* pD = &x;\npB->f();\t//调用B::f\npD->f();\t//调用D::f\n```\n\n### 绝对不重新定义继承而来的缺省参数值\n\n**virtual函数是动态绑定的，缺省参数值是静态绑定的**\n\n```c++\nclass Cricle: public Shape{...};\n...\nShape* p1;\t//p1的静态类型是Shape*，没有动态类型\nShape* p2 = new Circle;\t//p2的静态类型是Shape*，动态类型是Circle*\n```\n\n- 静态类型\n  - 指针的类型就是**静态类型**\n- 动态类型\n  - 所指向的对象的类型是**动态类型**\n  - 动态类型可以通过赋值等操作改变\n\nvirtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载\n\n但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数\n\n### has-a和根据xx实现出\n\n一个类中有多个小类，这种关系被称为**复合（composition）**，其中这些小类被称为**合成成分物（composed object）**\n\n- 在应用域，复合意味着`has-a`\n  - 人有名字（也不尽然）\n- 在实现域，复合意味着`is-implemented-in-terms-of`\n  - 队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）\n\n### 少用private继承\n\n*经典 C++糟粕，请问 C#有这个吗？*\n\n本质上是一种`is-implemented-in-terms-of`关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术\n\n- private继承，编译器无法自动将子类对象转化为父类对象\n- private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）\n\n**尽量使用复合来替代pirvate继承**，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数\n\n此外private继承的对象有可能比复合的对象要小\n\n### 少用多重继承\n\n*经典 C++糟粕，请问 C#有这个吗？*\n\n- 可能会导致歧义\n  - 当然你可以在调用函数的时候指出是来自哪一个基类\n- 可能会导致菱形继承\n  - 菱形继承可能会导致变量重复\n\n## 七：模版与泛型\n\n模板（templates）是泛型编程（generic programming）的基础\n\n模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译\n\n### 评价\n\n优点：\n\n1. 模板编程能够实现非常灵活且类型安全的接口\n2. 极好的性能（更小的文件、更短的运行期，更少的内存需求）\n3. 可以将一些运行时才能侦测到的错误，在编译期找出来\n\n缺点：\n\n1. 难以编程和维护\n2. 编译报错信息难以理解\n3. 难以重构\n4. 编译时间大幅变长\n\n因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释\n\n### 隐式接口和编译期多态\n\n- OOP中经常使用显式接口和运行时多态\n- 泛型编程更多使用隐式接口和编译期多态\n\n```C++\ntemplate<typename T>\nvoid doProcessing(T& w)\n{\n    if(w.size() > 10 && w != someNastyWidget){\n        T temp(w)\n        temp.normalize();\n        temp.swap(w);\n    }\n}\n```\n\n从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组**隐式接口**\n\n所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功\n\n这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是**编译期多态**\n\n### Traits\n\n一种约定俗成的技术方案，为同一类数据提供统一的操作函数\n\n比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。\n\n```C++\nenum Type{\n    TYPE_1;\n    TYPE_2;\n};\nclass FOO{\n    Type type = Type::TYPE_1;\n};\nclass Bar{\n    Type type = Type::TYPE_2;\n};\n//统一的模板函数\ntemplate<typename T>\nvoid decode(const T& data, char* buf){\n    if(T::type == Type::TYPE_1){\n        ...\n    }\n    else if(T::type == Type::TYPE_2){\n        ...\n    }\n}\n```\n\n但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术\n\n```C++\nenum Type{\n    TYPE_1;\n    TYPE_2;\n};\nclass FOO{\n    Type type = Type::TYPE_1;\n};\nclass Bar{\n    Type type = Type::TYPE_2;\n};\n\ntemplate<typename T>\nstruct type_traits{\n    Type type = T::type;\n}\n//为内置数据类型特化为独有的 type_traits\ntemplate<typename int>\nstruct type_traits{\n    Type type = Type::TYPE_1;\n}\n//统一的模板函数\ntemplate<typename T>\nvoid decode(const T& data, char* buf){\n    if(type_traits<T>::type == Type::TYPE_1){\n        ...\n    }\n    else if(type_traits<T>::type == Type::TYPE_2){\n        ...\n    }\n}\n```\n\n该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因\n\n### 模板元编程\n\nTMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化\n\n如果一门语言具备以下功能，则称为图灵完全\n\n1. 数值运算和符号运算\n2. 判断\n3. 递归\n\n#### 数值运算+递归\n\n```C++\n//一个TMP计算阶乘，而且阶乘的技术发生在编译期\ntemplate<unsigned n>\nstruct Factorial\n{\n    enum { value = n * Factorial<n-1>::value };\n};\ntemplate<>\nstruct Factorial<0>\n{\n    enum { value = 1 };\n};\n\nint main()\n{\n    std::cout << Factorial<5>::value;\n}\n```\n\nC++11TMP这种函数式编程得到了加强，上文也可以这样写\n\n```C++\ntemplate<unsigned n>\nstruct Factorial\n{\n    constexpr static auto value{ n * Factorial<n - 1>::value };\n};\ntemplate<>\nstruct Factorial<0>\n{\n    constexpr static auto value = 1;\n};\n```\n\n#### 判断\n\n```C++\ntemplate<bool Value>\nstruct if_constexpr\n{\n    constexpr static auto value = 1;\n};\n\ntemplate<>\nstruct if_constexpr<false> {\n    constexpr static auto value = 2;\n};\n\nint main()\n{\n    std::cout << if_constexpr<true>::value << std::endl;\n    std::cout << if_constexpr<false>::value << std::endl;\n}\n```\n\n### typedef\n\n在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名\n\n下面是一个函数指针的示例\n\n```C++\nvoid add(int x, int y) {\n    std::cout << \"x+y=\" << x + y << std::endl;\n}\nvoid dec(int x, int y) {\n    std::cout << \"x-y=\" << x - y << std::endl;\n}\nvoid mul(int x, int y) {\n    std::cout << \"x*y=\" << x*y << std::endl;\n}\n\nvoid (*op[3])(int, int) = { add, dec, mul };\n\nint main()\n{\n    for (int i = 0; i < 3; ++i) {\n        （*op[i])(4, 3);\n    }\n}\n```\n\n如果使用typedef\n\n```C++\ntypedef void (*Func[3])(int, int);\nFunc f = { add, dec, mul };\n\nint main()\n{\n    for (int i = 0; i < 3; ++i) {\n        f[i](4, 3);\n    }\n}\n```\n\n## 八：定制new和delete\n\nJava和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目\n\n### new-handler\n\n当`operator new`无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即`new-handler`\n\n使用`set_new_handler`来指定`new-handler`\n\n```c++\nvoid outOfMem(){\n  std::cerr << \"内存不足\\n\";\n  std::abort();\n}\nint main(){\n  std::set_new_handler(outOfMem);\t\t//该函数的参数是一个函数指针\n  int* array = new int[10000000L];\n  ...\n}\n```\n\n当`operator new`无法满足内存申请时，会不断调用`new-handler`函数，直到找到足够的内存，所以`new-handler`函数应该满足\n\n- 让更多的内存可被使用\n  - 实现方法是程序开始时就分配一大块内存，每次调用`new-handler`时就释放一点点\n- 安装另一个`new-handler`\n  - 如果现在这个`new-handler`无法获取更多内存，需要知道哪一个`new-handler`具备增大内存的实力，然后使用`set_new_handler`来替换自己\n- 卸除`new-handler`\n  - 通过`set_new_handler`赋值`null`，将`new-handler`卸载，使得在内存分配不足时，会抛异常\n- 抛出`bad_alloc`异常\n  - 这种异常不会被`operator new`捕获，会被传播至内存索求处\n- 不反回\n  - 调用`abort`或者`exit`\n\n```c++\nclass NewHandlerHolder{\npublic:\n  explicit NewHandlerHolder(std::new_handler nh): handler(nh) {}\t//获取当前的new_handler\n  ~NewHandlerHolder() { std::set_new_handler(handler); }\t\nprivate:\n  std::new_handler handler;\t\t//用于记录当前的new_handler\n};\nvoid* Widget::operator new(std::size_t size) throw(std::bad_alloc){\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\t//安装Widget的new-handler\n  return ::operator new(size);\t//分配对象或者抛异常\n}\n//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值\n```\n\n```c++\nvoid outOfMem();\nWidget::set_new_handler(outOfMem);\nWidget* pwl = new Widget;\t//内存不足时会调用outOfMem\n```\n\nmixin风格的写法\n\n```c++\ntemplate<typename T>\nclass NewHandlerSupport{\npublic:\n  static std::new_handler_set set_new_handler(std::new_handler p) throw();\n  static void* operator new(std::size_t size) throw(std::bad_alloc);\n  ...\nprivate:\n  static std::new_handler currentHandler;\n};\n\ntemplate<typename T>\nstd::new_handler NewHandlerSupport<T>::set_new_handler(std::new_handler p) throw(){\n  std::new_handler oldHandler = currentHandler;\n  currentHandler = p;\n  return oldHandler;\n}\n\ntemplate<typename T>\nvoid* NewHandlerSupport<T>::operator new(std::size_t size) throw(std::bad_alloc){\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\n  return ::operator new(size);\n}\n```\n\n```c++\nclass Widget: public NewHandlerSupport<Widget>{\n\t...\n};\n```\n\n像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为**怪异的循环模版模式（curiously recurring template pattern，CRTP）**\n\n### 替换new和delete的时机\n\nC++中所有的news返回的指针都必须要**地址对齐**，int要4对齐，double要8对齐\n\n写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换\n\n### 编写new和delete的规则\n\n如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则\n\n- new\n  - 应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用`new-handler`\n  - 有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）\n  - new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理**比正确大小更大的（错误）申请**\n\n- delete\n  - 收到null指针时不做任何事\n  - 处理**比正确大小更大的（错误）申请**\n\n### 编写new时也要写对应的delete\n\n```c++\nWidget* pw = new Widget;\n```\n\n在这里调用了两个函数，一个时用以分配内存的`operator new`，一个是`Widget`的构造函数\n\n如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的\n\n运行时系统会调用`operator new`所对应的`operator delete`来释放地址，对于拥有正常签名式的new和delete来说不成问题\n\n```c++\nvoid* operator new(std::size_t) throw(std::bad_alloc);\t//普通的new\nvoid operator delete(void* rawMemory) throw();\t//global中的普通的new\nvoid operator delete(void* rawMemory, std::size_t size) throw();\t//class中的new\n```\n\n但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题\n\n```c++\nvoid* operator new(std::size_t, void* pMemory) throw();\t//placement new，比普通new多带一个参数\n\nWidget* pw = new (std::cerr) Widget;\t//调用operator new，并以cerr作为其实参\n```\n\n当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的`operator new`时如何运作的，所以运行时系统会去寻找**参数个数与类型**都与`operator new`相同的某个`operator delete`\n\n```c++\nvoid operator delete(void*, std::ostream&) throw();\t//palcement delete\n```\n\n```c++\nclass Widget{\npublic:\n  static void* operator new(std::size_t size, std::ostream& logStream) throw(std::bad_alloc);\n  static void operator delete(void* pMemory) throw();\n  static void operator delete(void* pMemoty, std::ostream& logStream) throw();\n  ...\n};\n```\n\n如果此时调用`delete pw`，只会调用普通的`delete`，因为只有在构造时发生异常时，运行时系统才会调用placement delete\n\n最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete\n\n## 九：杂项\n\n### 不要忽视编译器警告\n\n很多人忽视警告，毕竟一个问题如果真的很严重，应该报错\n\n比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为\n\n```c++\nclass B{\npublic:\n  virtual void f() const;\n};\nclass D: public B{\n  virtual void f();\n};\n```\n\n报警告\n\n```c++\nwarning: D::f() hides virtual B::f()\n```\n\n原本的目的是为了在D中重新定义virtual函数`f()`，但由于B中`f()`是const，在D中不是，此时B中的`f()`并没有在D中重新被声明，而是被整个遮掩了\n\n### 去熟悉标准程序库\n\n尤其是TR1\n\n#### C++98有什么\n\n- STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器\n- Iostream\n- 国际化支持\n- 数值处理，包括复数（complex）和纯数值数组（valarray）\n- 异常阶层体系\n- C89标准程序库\n\n#### TR1有什么（全在`std::tr1`中）\n\n- 智能指针`tr1::shared_ptr`和`tr1::weak_ptr`\n- `tr1::function`\n- `tr1::bind`\n\n和（彼此无关的独立组件）\n\n- 哈希表\n- 正则表达式\n- Tuple变量组\n- `tr1::array`\n- `tr1::mem_fn`\n- `tr1::reference_wrapper`\n- 随机数生成工具\n- 数学特殊函数\n- C99兼容\n\n和（基于template）\n\n- Type traits\n- `tr1::result_of`\n\n### 熟悉Boost\n\n\n\n\n\n\n\n","source":"_posts/Effective C++.md","raw":"---\ntitle: Effective C++  \ndate: 2023/1/31 10:01:25  # 文章发表时间\ntags:\n\n- C++\ncategories: Algorithm # 分类\nthumbnail: /images/effectivecxx.png # 略缩图\n\n---\n# Effective C++\n\n## 一：C++基础\n\n### C++很成熟，很NB\n\nC++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）\n\n其核心是四个部分\n\n- C\n  - 区块block\n  - 语句statements\n  - 预处理器preprocessor\n  - 内置数据类型\n  - 数组arrays\n  - 指针pointers\n- Object-Orientend C++\n  - 类classes（构造函数，析构函数）\n  - 封装encapsulation\n  - 继承inheritance\n  - 多态polymorphism\n  - 虚函数virtual（动态绑定）\n- Template C++\n- STL\n\n### 替换#define\n\n使用编译器替代预处理器\n\n尽量使用const、enum定义常量，使用inlines定义函数宏\n\n#### const\n\n```c++\n#define PI 3.1415926\n```\n\n因为`#define`不是语言的一部分，在编译器开始工作前，`PI`就会被处理掉，所以一旦报错，你无法追踪到`PI`，只能看到`3.1415926`，这会**浪费你的时间**\n\n应该改为\n\n```c++\nconst double Pi 3.1415926;\n```\n\n值得注意的事\n\n- 定义常量指针指向char*-based字符串\n\n```c++\nconst char* const authorName = \"Reuben\";\n```\n\n- 作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员\n\n```c++\nclass GemePlayer{\nprivate:\n\tstatic const int NumTurns = 5;\t//这只是一个声明式\n\tint scores[NumTurns];\n};\nconst int GamePlayer::NumTurns;\t\t//这是定义式，因为在声明时已经赋值，所以这里就不赋值了\n```\n\nC++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式\n\n从这里可以看出，**const可以封装**，而#define不行\n\n#### enum\n\n```c++\nclass GemePlayer{\nprivate:\n\tenum { NumTurns = 5 };\n\tint scores[NumTurns];\n};\n```\n\n### const指针\n\nconst在星号左边，被指物是常量\n\n```c++\nchar greeting[] = \"Hello\";\nconst char* p = greeting;\n```\n\nconst在星号右边，指针本身是常量\n\n```c++\nchar greeting[] = \"Hello\";\nchar* const p = greeting;\n```\n\nconst在星号两边，被指物和指针都是常量\n\n```c++\nchar greeting[] = \"Hello\";\nconst char* const p = greeting;\n```\n\n### 确认对象在使用前已经被初始化\n\nC++初始化顺序\n\n- 基类比子类先初始化\n- 成员变量根据其声明次序初始化\n\n## 二：构造/析构/赋值\n\n### 空类的默认函数\n\n一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数\n\n一个类，如果没有构造函数，也会自动声明一个default构造函数\n\n这些函数都是public且inline的\n\n### 禁用自动生成的函数\n\n如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）\n\n- 你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）\n\n```c++\nclass HomeForSale{\nprivate:\n\tHomeForSale(const HomeForSale&);\n  HomeForSale& operator=(const HomeForSale&);\n};\n```\n\n可以制作一个不可被copy的类，让子类继承\n\n```c++\nclass Uncopyable{\nprotected:\n\tUncopyable(){}\n  ~Uncopyable(){}\nprivate:\n  Uncopyable(const Uncopyable&);\n  Uncopyable& operator=(const Uncopyable&);\n};\n\nclass HomeForSale: private Uncopyable{\n  ...\n};\n```\n\n### 为多态基类声明virtual析构函数\n\n#### 一定要有一个virtual析构函数\n\n- 如果这个类要成为一个基类，那么一定要有一个virtual析构函数\n\n在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错\n\n```c++\nclass TimeKeeper{\npublic:\n\t...\n};\nclass AtomicClock: public TimeKeeper {...};\nclass WaterClock: public TimeKeeper {...};\n```\n\n```c++\nTimeKeeper* ptk = getTimeKeeper();\t\t//创建一个动态分配对象\n...\ndelete ptk;\t//释放对象，避免资源泄漏\n```\n\n上面这个过程的问题其实出在`getTimeKeeper()`指向一个派生类（derived class）对象（比如`AtomicClock`），而这个对象却要经由一个基类（base class）指针删除（比如`TimeKeeper*`）\n\n如果这个基类的析构函数不是virtual的，就会出现问题：\n\n- 如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象\n\n解决方法就是给基类一个virtual析构函数\n\n```c++\nclass TimeKeeper{\npublic:\n\tTimeKeeper();\n  virtual ~TimeKeeper();\n  ...\n};\n```\n\n#### 最好不要有virtual析构函数\n\n- 如果这个类不可能成为基类，那么最好不要有virtual析构函数\n\n为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由**vptr（virtual table pointer）**指针携带，这个指针指向一个由函数指针构成的数组，称为**vtbl（virtual table）**，每一个带有virtual函数的类都有一个属于自己的vtbl\n\n**这个vtbl会增大对象的体积**，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍\n\n**这个vtbl会让代码失去兼容性**，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性\n\n#### 请不要继承没有virtual析构函数的类\n\n比如string、vector、list、set等等\n\n而且 C++没有像 Java的`final classes`或者C#的`sealed classes`的禁止派生机制\n\n### 不要在析构函数里抛出异常\n\n当一个`vector v`容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为\n\n有两个不怎么好的解决方法\n\n- 遇到异常，直接`std::abort()`，即遇到异常，宁愿直接强制停止程序，也不要让异常传播\n- 遇到异常，把异常记录下来，另程序继续运转，即**吞下异常**\n  - 这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好\n\n比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容\n\n```c++\nclass DBConnevtion{\npublic:\n    ...\n    static DBConnevtion create();\n    void close();     \n};\nclass DBConn{\npublic:\n    ...\n    void close()\t//封装给客户用的,关闭连接的函数\n    {\n        db.close();\n        closed = true;\n    }\n    ~DBConn(){\n        if(!closed){\n            try{\n                db.close();\n            }\n            catch(...){\n                ...\n                //强制关闭程序或者吞下异常\n            }\n        }\n    }\nprivate:\n    DBConnection db;\n    bool closed;\n};\n```\n\n### 不要在构造和析构过程中调用virtual函数\n\n在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果\n\n可以简单理解为**在C++中，基类构造期间，vritual函数不是vritual函数**\n\n因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数\n\n同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的\n\n### 令operator=返回一个对\\*this的引用\n\n连续赋值\n\n```c++\nx = y = z = 15;\n//其实就等于x = (y = (z = 15))；\n```\n\n为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参\n\n```c++\nclass Widget{\npublic:\n    Widget& operator=(const Widget& rhs)\n    {\n    \t...\n        return *this;\n    }\n    Widget& operator+=(const Widget& rhs){\n        ...\n        return *this;\n    }\n};\n```\n\n### 在operator=中处理自我赋值\n\n如果对象自己赋给自己，我们称之为自我赋值\n\n```c++\nw = w;\na[i] = a[j]; //当i=j时，自我赋值\n*px = *py;\t//px和py指向同一个物体时，自我赋值\n```\n\n在赋值操作中：\n\n1. 我们会先另左边的操作数先释放掉当前使用的数据\n2. 令其使用右操作数的副本\n3. 最后返回左操作数\n\n```c++\nclass Widget{\n    ...\nprivate:\n    Bitmap *pb;\n};\n//!!!这个不安全\nWidget& Widget::operator=(const Widget& rhs){\n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\n}\n```\n\n如果自我赋值，即rhs和pb指向同一个对象，那么`delete pb`后，这个对象就已经被销毁了，下面使用的`*rhs`就是一个已经被删除的对象\n\n解决方法1：延后delete\n\n```c++\nWidget& Widget::operator=(const Widget& rhs){\n    Bitmap* pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\n    delete pOrig;\n    return *this;\n}\n```\n\n解决方法2：使用copy and swap技术\n\n```c++\nWidget& Widget::operator=(const Widget& rhs){\n    Widget temp(rhs);\n    swap(temp);\t\t//令*this与temp交换\n    return *this;\n}\n```\n\n### 复制对象的一切\n\n如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错\n\n派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）\n\n所以copy函数需要\n\n- 复制所有local变量\n- 调用所有基类中的适当的copy函数\n\n## 三：资源管理\n\n### 让对象管理资源\n\n将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源\n\n- 申请资源后立即将其放进对象中，**资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）**\n- 在对象的析构函数中释放资源\n\nC++的`auto_ptr`是一个**类指针（pointer-like）对象**，也就是**智能指针**，其析构函数会自动delete掉其所指向的对象\n\n注意：\n\n- 不要让多个`auto_ptr`指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”\n- `auto_ptr`如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权\n\n**RCSP（引用计数型智能指针）**也是一种智能指针（比如`tr1::shared_ptr`），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源\n\n### 小心copy行为\n\n大多数RAII对象的copy函数：\n\n- 禁止复制\n- 采用引用计数法（RCSP）\n- 复制底部资源（深拷贝）\n- 转移底层资源所有权（auto_ptr）\n\n### 在资源管理类中提供对原始资源的访问\n\n有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）\n\n### new与delete一个数组\n\n一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？\n\n- 如果new了一个数组，就delete一个数组\n\n```c++\nstring* ptr1 = new string[100];\ndelete [] ptr1;\n```\n\n- 如果new了一个对象，就delete一个对象\n\n```c++\nstring* ptr2 = new string;\ndelete ptr2;\n```\n\n很多时候很难确定当前这个对象是数组还是一个对象\n\n```c++\ntypedef string AddressLines[4];\nstring* pal = new AddressLines;\ndelete [] pal;\n```\n\n最简单的方法是不用数组，使用STL里的容器，如`vector<string>`\n\n### 以独立语句将newed对象置入智能指针\n\nC++中调用一个函数，会先计算每一个传递进去的实参\n\n如果按下面的写法，将newed对象置入智能指针中\n\n```c++\n分配函数(shared_ptr<Widget>(new Widget), 资源访问);\t\t//不要这样写\n```\n\n需要执行一下函数\n\n- 调用“资源访问”函数（A）\n- 执行`new Widget`（B）\n- 调用`shared_ptr`构造函数（C）\n\n然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）\n\n如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏\n\n所以简单的方法是分离语句\n\n```c++\nshared_ptr<Widget> pw(new Widget);\n分配函数(pw, 资源访问);\n```\n\n## 四：设计与声明\n\n### 让接口容易被正确使用\n\n客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）\n\n#### 限制参数传递\n\n这是一个日期类\n\n```c++\nclass Date{\npublic:\n  Date(int month, int day, int year);\n  ...\n};\n...\nDate d(4, 20, 2022);\n```\n\n客户很有可能填错顺序，也有可能填入一个无效的参数\n\n可以使用**外覆类型（wrapper types）**，当然做出类会更好\n\n```c++\nstruct Day{\n  explict Day(int d) : val(d) {}\n  int val;\n};\nstruct Month{\n  explict Month(int m) : val(m) {}\n  int val;\n};\nstruct Year{\n  explict Year(int y) : val(y) {}\n  int val;\n};\nclass Date{\npublic:\n  Date(const Mouth& month, const Day& day, const Year& year);\n  ...\n};\n...\nDate d(Month(4), Day(20), Year(2022));\n```\n\n#### 一致性\n\n自定义的行为要与内置类型的行为一致，比如你不能把`operator*`重载成`operator+`\n\n或则像STL中，容器的接口都很一致，比如`size`、`push_back`等等\n\n### 设计class犹如设计type\n\n- 对象要如何创建和销毁\n- 对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）\n- 对象如果被值传递，意味着什么（深浅拷贝）\n- 约束成员变量的合法值\n- 是否可以/需要被继承\n- 能否类型转换，如何类型转换\n- 支持何种操作符\n- 成员变量的访问修饰\n- 成员函数的访问修饰\n- 未声明接口（undecided interface）\n- 是否需要定义模版\n- 真的需要一个新类吗？\n\n### 多用引用传递\n\nC++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些**很大的自定义类型**来说性能非常糟糕\n\n使用const引用传递会好很多\n\n- 不会创建新的对象\n- 不会改变原有对象\n- 可以避免**对象切割**问题\n  - 对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了\n\n只不过引用传递是大多是通过指针实现的，在处理一些**简单的内置类型**时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递\n\n### 必须返回对象时，不要返回引用\n\n如果必须返回对象，请不要返回引用（比如`operator*`，`operator==`），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个**右值**的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用\n\n### 将成员变量隐藏\n\n成员变量应该为private，而不是public\n\n- 客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）\n- 分离读写权限（这一点C#做的更好？）\n- 封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）\n- 便于对成员变量进行约束（更不容易出现异常值）\n- protected并不比public更具有封装性\n\n### 使用非成员函数\n\n- C#，java选手可以略过\n- C++标准库就是这样写的\n\n这里有一个类，其中有多个成员函数\n\n```c++\nclass WebBrowser{\npublic:\n\tvoid doA();\n  void doB();\n  void doC();\n  ...\n};\n```\n\n现在需要令一个函数做ABC三件事，有两种写法\n\n- 成员函数\n\n```c++\nclass WebBrowser{\npublic:\n\t...\n  void doEverything(){\n    doA();\n    doB();\n    doC();\n  }\n  ...\n};\n```\n\n- 非成员函数\n\n```c++\nvoid doEverything(WebBrowser& wb){\n\twb.doA();\n  wb.doB();\n  wb.doC();\n}\n```\n\n令人意外的是，第二种方法（使用非成员函数）更好\n\n#### 什么是封装\n\n一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强\n\n为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物\n\n#### 为什么第二种比第一种封装性更强\n\n因为第一种给用户两种调用方法，一个是调用成员函数`doEverything()`，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性\n\n- 注意第一种方法中，`doEverything()`和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利\n\n那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的**静态成员（static member）函数**即可\n\n或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）\n\n```c++\nnamespace WebBrowserStuff{\n\tclass WebBrowser{...};\n\tvoid doEverything(WebBrowser& wb){...}\n}\n```\n\n- 可拓展性更强\n  - 客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）\n\n- 可拆分\n  - 用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）\n\n### 如果所有参数都需要进行类型转换，使用非成员函数\n\n令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时\n\n比如一个有理数乘法\n\n```c++\nclass Rational{\npublic:\n  //这个类没有自定义的explict构造函数\n  const Rational opertaor* (const Rational& rhs) const;\n  ...\n};\n```\n\n```c++\nRational oneEighth(1,8);\nRational oneHalf(1,2);\nRational result = oneHalf * oneEighth;\t//成功\nresult = result * oneEighth;\t//成功\nresult = oneHalf * 2;\t\t//成功，等价于 result = oneHalf.operator*(2)\nresult = 2 * oneHalf;\t\t//失败，等价于 result = 2.operator*(oneHalf)\n```\n\n`result = oneHalf * 2;`为什么成功，因为这里发生了一次隐式转换，将`2`转化为了一个`Rational`类型\n\n在编译器中可能等价于\n\n```c++\nconst Rational temp(2);\nresult = oneHalf * temp;\n```\n\n- 如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将`2`转化为一个`Rational`类型\n\n`result = 2 * oneHalf;\t`为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时`2`就是一个int类型，没有我们所自定义的`operator*`函数，自然会失败\n\n可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）\n\n```c++\nconst Rational operator*(const Rational& lhs, const Rational& rhs){\n  return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());\n}\n```\n\n- 此外要极力避免使用**友元（friend）函数**\n- 成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数\n\n\n\n### 写一个不抛异常的swap函数\n\nswap函数原本是STL的一部分，后来称为了**异常安全性编程**的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要\n\nstd是一个很特殊的命名空间，客户可以**全特化**（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定\n\n全特化：针对某个类做模板函数的特例，如对`std::swap`做一个针对`Widget`的特化\n\n```c++\nclass WidgetImpl{...};\t\t//这个类的对象中存储着真正的数据\nclass Widget{\npublic:\n    Widget& operator=(const Widget& rhs){\n        ...\n        *pImpl = *(rhs.pImpl);\n        ...\n    }\n    ...\n    void swap(Widget& other){\t//这个函数决对不可抛异常\n        using std::swap;\n        swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针\n    }\n    ...\nprivate:\n    WidgetImple* pImpl;\t\t//这个类有一个指向资源对象的指针\n};\nnamespace std{\n\ttemplate<>\n    void swap<Widget>(Widget& a, Widget& b){\t//这个可以抛异常\n        a.swap(b);\t\n    }\n}\n```\n\n此外，C++的STL容器就是上面这种写法，提供了`public swap`成员函数和`std::swap`的特化版本\n\n## 五：实现（Implementations）\n\n- 随意定义变量可能会导致性能降低\n- 过度使用转型（casts）可能会导致性能降低，难以维护，可读性低\n- 返回对象的内部数据的handles，可能会破坏封装\n- 未考虑异常可能会导致资源泄露和数据败坏\n- 过度使用inline可能会导致包体膨胀\n- 过度耦合（coupling）可能会增加构建时间（build times）\n\n### 尽量延后变量定义式的出现时间\n\n#### 避免未曾使用的变量\n\n如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过\n\n此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、\n\n#### 避免无意义的默认构造函数\n\n如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好\n\n#### 循环\n\n此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？\n\n**循环内**\n\n```c++\nfor(int i = 0; i < n; i++){\n  Widget w(...);\n  ...\n}\n```\n\n- n个构造函数+n个析构函数\n\n- 如果`Widget`是一个很敏感的类，这样会让其作用域更小，更容易理解和维护\n\n**循环外**\n\n```c++\nWidget w;\nfor(int i = 0; i < n; i++){\n  w = ...;\n  ...\n}\n```\n\n- 一个构造函数+一个析构函数+n个赋值操作\n- 如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）\n\n### 少做转型\n\nC++是强类型语言，设计目标应该是保证类型错误绝不发生，然而**类型转换**破坏了类型系统\n\nJava、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险\n\nC++的类型转化\n\n- 旧式转换\n  - `(T)expression`\n  - `T(expression)`\n- 新式转换\n  - `const_cast<T>(expression)`\n    - 用于将对象的**常量性转除（cast away the constness）**\n    - 比如将`const`转化为`non-const`\n  - `dynamic_cast<T>(expression)`\n    - 用来**安全向下转型**\n    - 无法由旧式语句执行\n    - 耗费巨大\n  - `reinterpret_cast<T>(expression)`\n    - 用于低级转型，实际操作取决于编译器，不可移植\n    - 极其少用\n  - `static_cast<T>(expression)`\n    - 用于**强迫隐式转换（implicit conversions）**\n    - 比如`non-const`转化为`const`，`int`转化为`double`，`void*`转化为`typed`，基类指针转化为派生类指针\n\n避免C++类型转换出问题的核心是**避免使用基类的接口处理派生类**\n\n#### 一个对象多个地址\n\nC++很神奇，如果一个基类指针指向一个派生类对象，如\n\n```C++\nDervied d;\nBase* b = &d;\n```\n\n这可能会导致两个指针值不一样，即这个对象有两个地址，一个`Derivied*`指针一个`Base*`指针，这派生类指针上往往会有一个**偏移量（offset）**，通过这个偏移量，可以通过派生类指针找到基类指针\n\n上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以**请不要假定对象在C++中如何布局**，更不应该基于这个假设对对象进行类型转换\n\n如果你想让当前对象调用基类的函数，如果对`*this`做强制转化，转换为基类，`*this`其实是先前产生的`*this`对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题\n\n```c++\nclass SpecialWindow: public Window{\npublic:\n  virtual void onResize(){\n    //static_cast<Window>(*this).onResize();\t//这样不好\n    Window::onResize();\t\t//请用这种方式调用基类的onResize函数（作用到当前对象上）\n    ...\n  }\n}\n```\n\n#### dynamic_cast\n\n这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象\n\n什么时候使用这个东西？当**你想在**一个你认为是派生类对象的**对象上执行**派生类的操作**函数**，但你手里却只有一个指向基类的引用/指针时\n\n解决方法：\n\n- 使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器\n- 在基类中提供virtual函数\n\n### 避免返回指向对象内部成分的handles\n\n前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便\n\n但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的\n\n```c++\nclass Point{\npublic:\n  ...\n  void setX(int val);\n  ...\n};\nstruct RectData{\n  Point ulhc;\t\t//upper left hand corner\n  Point lrhc;\t\t//lower right hand corner\n};\nclass Rectangle{\npublic:\n  ...\n  Point& upperLeft() const { return pData->ulhc; }\t//这样返回了引用，非常不好\n  ...\nprivate:\n  std::tr1::shared_ptr<RectData> pData;\n};\n...\nrec.upperLeft().setX(50);\t\t//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改\n```\n\n`upperLeft`函数本来只是为了提供给客户获得（get）`Rectangle`的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了`Rectangle`本身，而且还是一个内部数据`RectData`\n\n为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）\n\n解决方法很简单，只要让handles不可以被修改，就可以了\n\n```c++\nclass Rectangle{\npublic:\n  ...\n  const Point& upperLeft() const { return pData->ulhc; }\t\n  ...\n};\n```\n\n但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致**dangling handles（空悬的号码牌）**，比如返回了一个对local变量的引用，依然特别危险\n\n当然，有的时候不得不返回handles，比如`operator[]`\n\n### 异常安全性很重要\n\n**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：\n\n- 不泄漏任何资源\n- 不允许数据败坏\n\n不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂\n\n三个保证：\n\n- 基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏\n- 强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过`copy-and-swap`实现）\n- 不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）\n\n**异常安全码**必须提供上述三种保障之一，如果不能保障，则不具备异常安全性\n\n### 了解inline函数\n\n内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化\n\n缺点也很明显，会让包体变大，会导致**换页行为（paging）**，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数\n\n内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联\n\n### 降低文件间的编译依存\n\n如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译\n\n为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用）\n\n这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类\n\n*话说应该不会有人不知道implementation是实现的意思吧*\n\n```c++\nclass PersonImpl;\t//pimpl写法，这是Person类的前置声明\nclass Data;\t\t\t\t//Data的前置声明\nclass Address;\t\t//Address的前置声明\n\nclass Persion{\t//像这样使用pimpl的类，往往被称为Handle classes\npublic:\n  ...\n  std::string name() const;\n  ...\nprivate:\n  std::tr1::shared_ptr<PersonImpl> pImpl;\n};\n```\n\n在这种设计下，`Person`就与`Data`、`Address`以及`Persons`的实现分离了，改动这些类也不会导致使用`Person`的客户重新编译，客户无法看到`Person`的实现细节，真正实现**接口与实现分离**\n\n这个操作的本质是用**声明的依赖性**替换**定义的依赖性**\n\n此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明\n\n此外还有另一种制作`Handle class`的方法，就是令`Person`成为一个特殊的抽象基类，称为`Interface class`，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）\n\n```c++\nclass Person{\t\t//Interface class\npublic:\n  virtual ~Person();\n  virtual std::string name() const = 0;\n  ...\n};\nclass Person{\t\t//具现化\npublic:\n  static std::tr1::shared_ptr<Person> create(const std::string& name...);\n  ...\n};\n...\n//使用\nstd::tr1::shared_ptr<Person> pp(Person::create(name...));\nstd::cout << pp->name();\n```\n\n```c++\nclass RealPerson: public Person{\t\npublic:\n  RealPerson(const std::string& name, ...): theName(name), ...{}\n  virtual ~RealPerson() {}\n  std::string name() const;\t\t\n  ...\nprivate:\n\tstd::string theName;\n};\nstd::string ReakPerson::name(){...}\nstd::tr1::shared_ptr<Person> Person::create(const std::string& name, ...){\n  retrun std::tr1::shared_ptr<Person>(new RealPerson(name, ...));\n}\n```\n\n## 六：继承与面向对象\n\n- `is-a`：是一个\n- `has-a`：有一个\n- `is-implemented-in-terms-of`：根据xx实现出\n\n### public继承是is-a关系\n\n```c++\nclass Student: public Person{...};\t//Student is a Person\n```\n\n每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化\n\n**public继承下，可以把子类当父类用**，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用\n\n这就出现了一个问题，子类一定要`is a`父类，不然会出现问题\n\n错误的继承：\n\n- 企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？\n- 正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？\n\n### 避免遮掩父类成员\n\n```c++\nint x;\nvoid Fun(){\n    double x;\n    ...\n}\n```\n\n由于**作用域**的**名称遮掩规则**，函数内部的local变量x覆盖了全局变量x\n\n#### 子类名称会遮掩父类名称，在public继承下是错误的\n\n在OOP中，如果子类重载了父类的`non-virtual`函数，就意味着子类使用同名函数遮掩了父类函数，就意味着**这个父类函数没有被子类继承！**，那么在这种情况下，继承就不是`is-a`关系了\n\n**在public继承下，子类继承了父类的一切**\n\n```c++\nclass Base{\npublic:\n    virtual void f1() = 0;\n    virtual void f1(int);\n    void f2();\n    void f2(double);\n    ...\nprivate:\n    int x;\n};\nclass Derived: public Base{\npublic:\n    virtual void f1();\n    void f2();\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)\n```\n\n#### 将被遮掩的名称重见天日\n\n解决起来很简单，只需要让父类的函数在子类作用域内可见，可以**使用using关键字**\n\n```c++\nclass Derived: public Base{\npublic:\n    using Base::f1;\n    using Base::f2;\n    virtual void f1();\n    void f2();\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//正确，调用Base::f1\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//正确，调用Base::f2\n```\n\n如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以**使用转交函数**，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中\n\n```c++\nclass Derived: private Base{\npublic:\n    virtual void f1(){\n        Base::f1();\t\t//inline转交函数\n    }\n    ...\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1\n```\n\n### 区分接口继承和实现继承\n\npublic继承分为两个部分\n\n- 函数接口继承\n- 函数实现继承\n\n|                 | 接口继承 | 实现继承         |\n| --------------- | -------- | ---------------- |\n| 纯虚函数        | 具体指定 | 不继承           |\n| 非纯虚函数      | 具体指定 | 继承一份缺省实现 |\n| non-virtual函数 | 具体指定 | 继承一份强制实现 |\n\n### 考虑使用virtual以外的选择\n\n#### 基于NVI的Template Method模式\n\nNon-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数\n\n```c++\nclass GameCharacter{\npublic：\n    int healthValue() const\n\t{\n    \t...\n    \tint retVal = doHealthValue();\n    \t...\n    \treturn retVal;\n\t}\nprivate：\n    virtual int doHealthValue() const\n    {\n\t\t...\n    }\n};\n```\n\n其中`healthValue()`被称为virtual函数的**外覆器（wrapper）**\n\n#### 基于函数指针的Strategy模式\n\n```c++\nclass GameCharacter;\nint defaultHealthCalc(const GameCharacter& gc);\nclass GameCharacter{\npublic:\n    typedef int (*HealthCalcFunc)(const GameCharacter&);\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf){}\n    int healthValue() const { return healthFunc(*this); }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\n在这种模式下，`defaultHealthCalc`函数不再是`GameCharacter`体系内的成员函数，通过修改函数指针，就可以让`GameCharacter`使用不同种类的计算函数，弹性更强，而且可以在运行时变更\n\n此外`defaultHealthCalc`函数不需要/不能访问`GameCharacter`内的`non-public`部分，\n\n####  基于tr1::function的Strategy模式\n\n上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如`tr1::function`对象\n\n```c++\nclass GameCharacter;\nint defaultHealthCalc(const GameCharacter& gc);\nclass GameCharacter{\npublic:\n    typedef std::tr1::function<int (const GameCharacter&)> HealthCalcFunc;\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf){}\n    int healthValue() const { return healthFunc(*this); }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\n#### 古典的Strategy模式\n\n```c++\nclass GameCharacter;\nclass HealthCalcFunc{\npublic:\n    ...\n    virtual int calc(const GameCharacter& gc) const{...}\n    ...\n};\nHealthCalcFunc defaultHealthCalc;\nclass GameCharacter{\npublic:\n    explicit GameCharacter(HealthCalcFunc* phcf = &defaultHealthCalc): pHealthFunc(phcf){}\n    int healthValue() const { return phealthFunc->calc(*this); }\n    ...\nprivate:\n    HealthCalcFunc* pHealthFunc;\n};\n```\n\n### 绝不重新定义继承而来的non-virtual函数\n\n- 静态绑定（staticcally bound）：non-virtual就是这种\n- 动态绑定（dynamically bound）：virtual就是这种\n\n```c++\nclass B{\npublic:\n\tvoid f();\n\t...\n};\nclass D: public B{\npublic:\n  void f();\n  ...\n};\n...\nD x;\nB* pB = &x;\nD* pD = &x;\npB->f();\t//调用B::f\npD->f();\t//调用D::f\n```\n\n### 绝对不重新定义继承而来的缺省参数值\n\n**virtual函数是动态绑定的，缺省参数值是静态绑定的**\n\n```c++\nclass Cricle: public Shape{...};\n...\nShape* p1;\t//p1的静态类型是Shape*，没有动态类型\nShape* p2 = new Circle;\t//p2的静态类型是Shape*，动态类型是Circle*\n```\n\n- 静态类型\n  - 指针的类型就是**静态类型**\n- 动态类型\n  - 所指向的对象的类型是**动态类型**\n  - 动态类型可以通过赋值等操作改变\n\nvirtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载\n\n但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数\n\n### has-a和根据xx实现出\n\n一个类中有多个小类，这种关系被称为**复合（composition）**，其中这些小类被称为**合成成分物（composed object）**\n\n- 在应用域，复合意味着`has-a`\n  - 人有名字（也不尽然）\n- 在实现域，复合意味着`is-implemented-in-terms-of`\n  - 队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）\n\n### 少用private继承\n\n*经典 C++糟粕，请问 C#有这个吗？*\n\n本质上是一种`is-implemented-in-terms-of`关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术\n\n- private继承，编译器无法自动将子类对象转化为父类对象\n- private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）\n\n**尽量使用复合来替代pirvate继承**，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数\n\n此外private继承的对象有可能比复合的对象要小\n\n### 少用多重继承\n\n*经典 C++糟粕，请问 C#有这个吗？*\n\n- 可能会导致歧义\n  - 当然你可以在调用函数的时候指出是来自哪一个基类\n- 可能会导致菱形继承\n  - 菱形继承可能会导致变量重复\n\n## 七：模版与泛型\n\n模板（templates）是泛型编程（generic programming）的基础\n\n模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译\n\n### 评价\n\n优点：\n\n1. 模板编程能够实现非常灵活且类型安全的接口\n2. 极好的性能（更小的文件、更短的运行期，更少的内存需求）\n3. 可以将一些运行时才能侦测到的错误，在编译期找出来\n\n缺点：\n\n1. 难以编程和维护\n2. 编译报错信息难以理解\n3. 难以重构\n4. 编译时间大幅变长\n\n因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释\n\n### 隐式接口和编译期多态\n\n- OOP中经常使用显式接口和运行时多态\n- 泛型编程更多使用隐式接口和编译期多态\n\n```C++\ntemplate<typename T>\nvoid doProcessing(T& w)\n{\n    if(w.size() > 10 && w != someNastyWidget){\n        T temp(w)\n        temp.normalize();\n        temp.swap(w);\n    }\n}\n```\n\n从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组**隐式接口**\n\n所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功\n\n这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是**编译期多态**\n\n### Traits\n\n一种约定俗成的技术方案，为同一类数据提供统一的操作函数\n\n比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。\n\n```C++\nenum Type{\n    TYPE_1;\n    TYPE_2;\n};\nclass FOO{\n    Type type = Type::TYPE_1;\n};\nclass Bar{\n    Type type = Type::TYPE_2;\n};\n//统一的模板函数\ntemplate<typename T>\nvoid decode(const T& data, char* buf){\n    if(T::type == Type::TYPE_1){\n        ...\n    }\n    else if(T::type == Type::TYPE_2){\n        ...\n    }\n}\n```\n\n但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术\n\n```C++\nenum Type{\n    TYPE_1;\n    TYPE_2;\n};\nclass FOO{\n    Type type = Type::TYPE_1;\n};\nclass Bar{\n    Type type = Type::TYPE_2;\n};\n\ntemplate<typename T>\nstruct type_traits{\n    Type type = T::type;\n}\n//为内置数据类型特化为独有的 type_traits\ntemplate<typename int>\nstruct type_traits{\n    Type type = Type::TYPE_1;\n}\n//统一的模板函数\ntemplate<typename T>\nvoid decode(const T& data, char* buf){\n    if(type_traits<T>::type == Type::TYPE_1){\n        ...\n    }\n    else if(type_traits<T>::type == Type::TYPE_2){\n        ...\n    }\n}\n```\n\n该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因\n\n### 模板元编程\n\nTMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化\n\n如果一门语言具备以下功能，则称为图灵完全\n\n1. 数值运算和符号运算\n2. 判断\n3. 递归\n\n#### 数值运算+递归\n\n```C++\n//一个TMP计算阶乘，而且阶乘的技术发生在编译期\ntemplate<unsigned n>\nstruct Factorial\n{\n    enum { value = n * Factorial<n-1>::value };\n};\ntemplate<>\nstruct Factorial<0>\n{\n    enum { value = 1 };\n};\n\nint main()\n{\n    std::cout << Factorial<5>::value;\n}\n```\n\nC++11TMP这种函数式编程得到了加强，上文也可以这样写\n\n```C++\ntemplate<unsigned n>\nstruct Factorial\n{\n    constexpr static auto value{ n * Factorial<n - 1>::value };\n};\ntemplate<>\nstruct Factorial<0>\n{\n    constexpr static auto value = 1;\n};\n```\n\n#### 判断\n\n```C++\ntemplate<bool Value>\nstruct if_constexpr\n{\n    constexpr static auto value = 1;\n};\n\ntemplate<>\nstruct if_constexpr<false> {\n    constexpr static auto value = 2;\n};\n\nint main()\n{\n    std::cout << if_constexpr<true>::value << std::endl;\n    std::cout << if_constexpr<false>::value << std::endl;\n}\n```\n\n### typedef\n\n在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名\n\n下面是一个函数指针的示例\n\n```C++\nvoid add(int x, int y) {\n    std::cout << \"x+y=\" << x + y << std::endl;\n}\nvoid dec(int x, int y) {\n    std::cout << \"x-y=\" << x - y << std::endl;\n}\nvoid mul(int x, int y) {\n    std::cout << \"x*y=\" << x*y << std::endl;\n}\n\nvoid (*op[3])(int, int) = { add, dec, mul };\n\nint main()\n{\n    for (int i = 0; i < 3; ++i) {\n        （*op[i])(4, 3);\n    }\n}\n```\n\n如果使用typedef\n\n```C++\ntypedef void (*Func[3])(int, int);\nFunc f = { add, dec, mul };\n\nint main()\n{\n    for (int i = 0; i < 3; ++i) {\n        f[i](4, 3);\n    }\n}\n```\n\n## 八：定制new和delete\n\nJava和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目\n\n### new-handler\n\n当`operator new`无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即`new-handler`\n\n使用`set_new_handler`来指定`new-handler`\n\n```c++\nvoid outOfMem(){\n  std::cerr << \"内存不足\\n\";\n  std::abort();\n}\nint main(){\n  std::set_new_handler(outOfMem);\t\t//该函数的参数是一个函数指针\n  int* array = new int[10000000L];\n  ...\n}\n```\n\n当`operator new`无法满足内存申请时，会不断调用`new-handler`函数，直到找到足够的内存，所以`new-handler`函数应该满足\n\n- 让更多的内存可被使用\n  - 实现方法是程序开始时就分配一大块内存，每次调用`new-handler`时就释放一点点\n- 安装另一个`new-handler`\n  - 如果现在这个`new-handler`无法获取更多内存，需要知道哪一个`new-handler`具备增大内存的实力，然后使用`set_new_handler`来替换自己\n- 卸除`new-handler`\n  - 通过`set_new_handler`赋值`null`，将`new-handler`卸载，使得在内存分配不足时，会抛异常\n- 抛出`bad_alloc`异常\n  - 这种异常不会被`operator new`捕获，会被传播至内存索求处\n- 不反回\n  - 调用`abort`或者`exit`\n\n```c++\nclass NewHandlerHolder{\npublic:\n  explicit NewHandlerHolder(std::new_handler nh): handler(nh) {}\t//获取当前的new_handler\n  ~NewHandlerHolder() { std::set_new_handler(handler); }\t\nprivate:\n  std::new_handler handler;\t\t//用于记录当前的new_handler\n};\nvoid* Widget::operator new(std::size_t size) throw(std::bad_alloc){\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\t//安装Widget的new-handler\n  return ::operator new(size);\t//分配对象或者抛异常\n}\n//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值\n```\n\n```c++\nvoid outOfMem();\nWidget::set_new_handler(outOfMem);\nWidget* pwl = new Widget;\t//内存不足时会调用outOfMem\n```\n\nmixin风格的写法\n\n```c++\ntemplate<typename T>\nclass NewHandlerSupport{\npublic:\n  static std::new_handler_set set_new_handler(std::new_handler p) throw();\n  static void* operator new(std::size_t size) throw(std::bad_alloc);\n  ...\nprivate:\n  static std::new_handler currentHandler;\n};\n\ntemplate<typename T>\nstd::new_handler NewHandlerSupport<T>::set_new_handler(std::new_handler p) throw(){\n  std::new_handler oldHandler = currentHandler;\n  currentHandler = p;\n  return oldHandler;\n}\n\ntemplate<typename T>\nvoid* NewHandlerSupport<T>::operator new(std::size_t size) throw(std::bad_alloc){\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\n  return ::operator new(size);\n}\n```\n\n```c++\nclass Widget: public NewHandlerSupport<Widget>{\n\t...\n};\n```\n\n像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为**怪异的循环模版模式（curiously recurring template pattern，CRTP）**\n\n### 替换new和delete的时机\n\nC++中所有的news返回的指针都必须要**地址对齐**，int要4对齐，double要8对齐\n\n写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换\n\n### 编写new和delete的规则\n\n如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则\n\n- new\n  - 应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用`new-handler`\n  - 有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）\n  - new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理**比正确大小更大的（错误）申请**\n\n- delete\n  - 收到null指针时不做任何事\n  - 处理**比正确大小更大的（错误）申请**\n\n### 编写new时也要写对应的delete\n\n```c++\nWidget* pw = new Widget;\n```\n\n在这里调用了两个函数，一个时用以分配内存的`operator new`，一个是`Widget`的构造函数\n\n如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的\n\n运行时系统会调用`operator new`所对应的`operator delete`来释放地址，对于拥有正常签名式的new和delete来说不成问题\n\n```c++\nvoid* operator new(std::size_t) throw(std::bad_alloc);\t//普通的new\nvoid operator delete(void* rawMemory) throw();\t//global中的普通的new\nvoid operator delete(void* rawMemory, std::size_t size) throw();\t//class中的new\n```\n\n但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题\n\n```c++\nvoid* operator new(std::size_t, void* pMemory) throw();\t//placement new，比普通new多带一个参数\n\nWidget* pw = new (std::cerr) Widget;\t//调用operator new，并以cerr作为其实参\n```\n\n当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的`operator new`时如何运作的，所以运行时系统会去寻找**参数个数与类型**都与`operator new`相同的某个`operator delete`\n\n```c++\nvoid operator delete(void*, std::ostream&) throw();\t//palcement delete\n```\n\n```c++\nclass Widget{\npublic:\n  static void* operator new(std::size_t size, std::ostream& logStream) throw(std::bad_alloc);\n  static void operator delete(void* pMemory) throw();\n  static void operator delete(void* pMemoty, std::ostream& logStream) throw();\n  ...\n};\n```\n\n如果此时调用`delete pw`，只会调用普通的`delete`，因为只有在构造时发生异常时，运行时系统才会调用placement delete\n\n最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete\n\n## 九：杂项\n\n### 不要忽视编译器警告\n\n很多人忽视警告，毕竟一个问题如果真的很严重，应该报错\n\n比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为\n\n```c++\nclass B{\npublic:\n  virtual void f() const;\n};\nclass D: public B{\n  virtual void f();\n};\n```\n\n报警告\n\n```c++\nwarning: D::f() hides virtual B::f()\n```\n\n原本的目的是为了在D中重新定义virtual函数`f()`，但由于B中`f()`是const，在D中不是，此时B中的`f()`并没有在D中重新被声明，而是被整个遮掩了\n\n### 去熟悉标准程序库\n\n尤其是TR1\n\n#### C++98有什么\n\n- STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器\n- Iostream\n- 国际化支持\n- 数值处理，包括复数（complex）和纯数值数组（valarray）\n- 异常阶层体系\n- C89标准程序库\n\n#### TR1有什么（全在`std::tr1`中）\n\n- 智能指针`tr1::shared_ptr`和`tr1::weak_ptr`\n- `tr1::function`\n- `tr1::bind`\n\n和（彼此无关的独立组件）\n\n- 哈希表\n- 正则表达式\n- Tuple变量组\n- `tr1::array`\n- `tr1::mem_fn`\n- `tr1::reference_wrapper`\n- 随机数生成工具\n- 数学特殊函数\n- C99兼容\n\n和（基于template）\n\n- Type traits\n- `tr1::result_of`\n\n### 熟悉Boost\n\n\n\n\n\n\n\n","slug":"Effective C++","published":1,"updated":"2023-01-31T05:48:08.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldju62ds0001qq3c81yeei2c","content":"<h1>Effective C++</h1>\n<h2 id=\"一：C-基础\">一：C++基础</h2>\n<h3 id=\"C-很成熟，很NB\">C++很成熟，很NB</h3>\n<p>C++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）</p>\n<p>其核心是四个部分</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>C</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">区块block</li>\n<li class=\"lvl-4\">语句statements</li>\n<li class=\"lvl-4\">预处理器preprocessor</li>\n<li class=\"lvl-4\">内置数据类型</li>\n<li class=\"lvl-4\">数组arrays</li>\n<li class=\"lvl-4\">指针pointers</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Object-Orientend C++</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">类classes（构造函数，析构函数）</li>\n<li class=\"lvl-4\">封装encapsulation</li>\n<li class=\"lvl-4\">继承inheritance</li>\n<li class=\"lvl-4\">多态polymorphism</li>\n<li class=\"lvl-4\">虚函数virtual（动态绑定）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Template C++</p>\n</li>\n<li class=\"lvl-2\">\n<p>STL</p>\n</li>\n</ul>\n<h3 id=\"替换-define\">替换#define</h3>\n<p>使用编译器替代预处理器</p>\n<p>尽量使用const、enum定义常量，使用inlines定义函数宏</p>\n<h4 id=\"const\">const</h4>\n<pre><code class=\"language-c++\">#define PI 3.1415926\n</code></pre>\n<p>因为<code>#define</code>不是语言的一部分，在编译器开始工作前，<code>PI</code>就会被处理掉，所以一旦报错，你无法追踪到<code>PI</code>，只能看到<code>3.1415926</code>，这会<strong>浪费你的时间</strong></p>\n<p>应该改为</p>\n<pre><code class=\"language-c++\">const double Pi 3.1415926;\n</code></pre>\n<p>值得注意的事</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>定义常量指针指向char*-based字符串</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">const char* const authorName = &quot;Reuben&quot;;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class GemePlayer&#123;\nprivate:\n\tstatic const int NumTurns = 5;\t//这只是一个声明式\n\tint scores[NumTurns];\n&#125;;\nconst int GamePlayer::NumTurns;\t\t//这是定义式，因为在声明时已经赋值，所以这里就不赋值了\n</code></pre>\n<p>C++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式</p>\n<p>从这里可以看出，<strong>const可以封装</strong>，而#define不行</p>\n<h4 id=\"enum\">enum</h4>\n<pre><code class=\"language-c++\">class GemePlayer&#123;\nprivate:\n\tenum &#123; NumTurns = 5 &#125;;\n\tint scores[NumTurns];\n&#125;;\n</code></pre>\n<h3 id=\"const指针\">const指针</h3>\n<p>const在星号左边，被指物是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nconst char* p = greeting;\n</code></pre>\n<p>const在星号右边，指针本身是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nchar* const p = greeting;\n</code></pre>\n<p>const在星号两边，被指物和指针都是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nconst char* const p = greeting;\n</code></pre>\n<h3 id=\"确认对象在使用前已经被初始化\">确认对象在使用前已经被初始化</h3>\n<p>C++初始化顺序</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基类比子类先初始化</p>\n</li>\n<li class=\"lvl-2\">\n<p>成员变量根据其声明次序初始化</p>\n</li>\n</ul>\n<h2 id=\"二：构造-析构-赋值\">二：构造/析构/赋值</h2>\n<h3 id=\"空类的默认函数\">空类的默认函数</h3>\n<p>一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数</p>\n<p>一个类，如果没有构造函数，也会自动声明一个default构造函数</p>\n<p>这些函数都是public且inline的</p>\n<h3 id=\"禁用自动生成的函数\">禁用自动生成的函数</h3>\n<p>如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class HomeForSale&#123;\nprivate:\n\tHomeForSale(const HomeForSale&amp;);\n  HomeForSale&amp; operator=(const HomeForSale&amp;);\n&#125;;\n</code></pre>\n<p>可以制作一个不可被copy的类，让子类继承</p>\n<pre><code class=\"language-c++\">class Uncopyable&#123;\nprotected:\n\tUncopyable()&#123;&#125;\n  ~Uncopyable()&#123;&#125;\nprivate:\n  Uncopyable(const Uncopyable&amp;);\n  Uncopyable&amp; operator=(const Uncopyable&amp;);\n&#125;;\n\nclass HomeForSale: private Uncopyable&#123;\n  ...\n&#125;;\n</code></pre>\n<h3 id=\"为多态基类声明virtual析构函数\">为多态基类声明virtual析构函数</h3>\n<h4 id=\"一定要有一个virtual析构函数\">一定要有一个virtual析构函数</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果这个类要成为一个基类，那么一定要有一个virtual析构函数</p>\n</li>\n</ul>\n<p>在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错</p>\n<pre><code class=\"language-c++\">class TimeKeeper&#123;\npublic:\n\t...\n&#125;;\nclass AtomicClock: public TimeKeeper &#123;...&#125;;\nclass WaterClock: public TimeKeeper &#123;...&#125;;\n</code></pre>\n<pre><code class=\"language-c++\">TimeKeeper* ptk = getTimeKeeper();\t\t//创建一个动态分配对象\n...\ndelete ptk;\t//释放对象，避免资源泄漏\n</code></pre>\n<p>上面这个过程的问题其实出在<code>getTimeKeeper()</code>指向一个派生类（derived class）对象（比如<code>AtomicClock</code>），而这个对象却要经由一个基类（base class）指针删除（比如<code>TimeKeeper*</code>）</p>\n<p>如果这个基类的析构函数不是virtual的，就会出现问题：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象</p>\n</li>\n</ul>\n<p>解决方法就是给基类一个virtual析构函数</p>\n<pre><code class=\"language-c++\">class TimeKeeper&#123;\npublic:\n\tTimeKeeper();\n  virtual ~TimeKeeper();\n  ...\n&#125;;\n</code></pre>\n<h4 id=\"最好不要有virtual析构函数\">最好不要有virtual析构函数</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果这个类不可能成为基类，那么最好不要有virtual析构函数</p>\n</li>\n</ul>\n<p>为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由<strong>vptr（virtual table pointer）<strong>指针携带，这个指针指向一个由函数指针构成的数组，称为</strong>vtbl（virtual table）</strong>，每一个带有virtual函数的类都有一个属于自己的vtbl</p>\n<p><strong>这个vtbl会增大对象的体积</strong>，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍</p>\n<p><strong>这个vtbl会让代码失去兼容性</strong>，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性</p>\n<h4 id=\"请不要继承没有virtual析构函数的类\">请不要继承没有virtual析构函数的类</h4>\n<p>比如string、vector、list、set等等</p>\n<p>而且 C++没有像 Java的<code>final classes</code>或者C#的<code>sealed classes</code>的禁止派生机制</p>\n<h3 id=\"不要在析构函数里抛出异常\">不要在析构函数里抛出异常</h3>\n<p>当一个<code>vector v</code>容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为</p>\n<p>有两个不怎么好的解决方法</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>遇到异常，直接<code>std::abort()</code>，即遇到异常，宁愿直接强制停止程序，也不要让异常传播</p>\n</li>\n<li class=\"lvl-2\">\n<p>遇到异常，把异常记录下来，另程序继续运转，即<strong>吞下异常</strong></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好</li>\n</ul>\n</li>\n</ul>\n<p>比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容</p>\n<pre><code class=\"language-c++\">class DBConnevtion&#123;\npublic:\n    ...\n    static DBConnevtion create();\n    void close();     \n&#125;;\nclass DBConn&#123;\npublic:\n    ...\n    void close()\t//封装给客户用的,关闭连接的函数\n    &#123;\n        db.close();\n        closed = true;\n    &#125;\n    ~DBConn()&#123;\n        if(!closed)&#123;\n            try&#123;\n                db.close();\n            &#125;\n            catch(...)&#123;\n                ...\n                //强制关闭程序或者吞下异常\n            &#125;\n        &#125;\n    &#125;\nprivate:\n    DBConnection db;\n    bool closed;\n&#125;;\n</code></pre>\n<h3 id=\"不要在构造和析构过程中调用virtual函数\">不要在构造和析构过程中调用virtual函数</h3>\n<p>在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果</p>\n<p>可以简单理解为<strong>在C++中，基类构造期间，vritual函数不是vritual函数</strong></p>\n<p>因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数</p>\n<p>同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的</p>\n<h3 id=\"令operator-返回一个对-this的引用\">令operator=返回一个对*this的引用</h3>\n<p>连续赋值</p>\n<pre><code class=\"language-c++\">x = y = z = 15;\n//其实就等于x = (y = (z = 15))；\n</code></pre>\n<p>为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参</p>\n<pre><code class=\"language-c++\">class Widget&#123;\npublic:\n    Widget&amp; operator=(const Widget&amp; rhs)\n    &#123;\n    \t...\n        return *this;\n    &#125;\n    Widget&amp; operator+=(const Widget&amp; rhs)&#123;\n        ...\n        return *this;\n    &#125;\n&#125;;\n</code></pre>\n<h3 id=\"在operator-中处理自我赋值\">在operator=中处理自我赋值</h3>\n<p>如果对象自己赋给自己，我们称之为自我赋值</p>\n<pre><code class=\"language-c++\">w = w;\na[i] = a[j]; //当i=j时，自我赋值\n*px = *py;\t//px和py指向同一个物体时，自我赋值\n</code></pre>\n<p>在赋值操作中：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>我们会先另左边的操作数先释放掉当前使用的数据</p>\n</li>\n<li class=\"lvl-3\">\n<p>令其使用右操作数的副本</p>\n</li>\n<li class=\"lvl-3\">\n<p>最后返回左操作数</p>\n</li>\n</ol>\n<pre><code class=\"language-c++\">class Widget&#123;\n    ...\nprivate:\n    Bitmap *pb;\n&#125;;\n//!!!这个不安全\nWidget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\n&#125;\n</code></pre>\n<p>如果自我赋值，即rhs和pb指向同一个对象，那么<code>delete pb</code>后，这个对象就已经被销毁了，下面使用的<code>*rhs</code>就是一个已经被删除的对象</p>\n<p>解决方法1：延后delete</p>\n<pre><code class=\"language-c++\">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    Bitmap* pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\n    delete pOrig;\n    return *this;\n&#125;\n</code></pre>\n<p>解决方法2：使用copy and swap技术</p>\n<pre><code class=\"language-c++\">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    Widget temp(rhs);\n    swap(temp);\t\t//令*this与temp交换\n    return *this;\n&#125;\n</code></pre>\n<h3 id=\"复制对象的一切\">复制对象的一切</h3>\n<p>如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错</p>\n<p>派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）</p>\n<p>所以copy函数需要</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>复制所有local变量</p>\n</li>\n<li class=\"lvl-2\">\n<p>调用所有基类中的适当的copy函数</p>\n</li>\n</ul>\n<h2 id=\"三：资源管理\">三：资源管理</h2>\n<h3 id=\"让对象管理资源\">让对象管理资源</h3>\n<p>将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>申请资源后立即将其放进对象中，<strong>资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>在对象的析构函数中释放资源</p>\n</li>\n</ul>\n<p>C++的<code>auto_ptr</code>是一个<strong>类指针（pointer-like）对象</strong>，也就是<strong>智能指针</strong>，其析构函数会自动delete掉其所指向的对象</p>\n<p>注意：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不要让多个<code>auto_ptr</code>指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>auto_ptr</code>如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权</p>\n</li>\n</ul>\n<p>**RCSP（引用计数型智能指针）**也是一种智能指针（比如<code>tr1::shared_ptr</code>），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源</p>\n<h3 id=\"小心copy行为\">小心copy行为</h3>\n<p>大多数RAII对象的copy函数：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>禁止复制</p>\n</li>\n<li class=\"lvl-2\">\n<p>采用引用计数法（RCSP）</p>\n</li>\n<li class=\"lvl-2\">\n<p>复制底部资源（深拷贝）</p>\n</li>\n<li class=\"lvl-2\">\n<p>转移底层资源所有权（auto_ptr）</p>\n</li>\n</ul>\n<h3 id=\"在资源管理类中提供对原始资源的访问\">在资源管理类中提供对原始资源的访问</h3>\n<p>有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）</p>\n<h3 id=\"new与delete一个数组\">new与delete一个数组</h3>\n<p>一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果new了一个数组，就delete一个数组</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">string* ptr1 = new string[100];\ndelete [] ptr1;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果new了一个对象，就delete一个对象</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">string* ptr2 = new string;\ndelete ptr2;\n</code></pre>\n<p>很多时候很难确定当前这个对象是数组还是一个对象</p>\n<pre><code class=\"language-c++\">typedef string AddressLines[4];\nstring* pal = new AddressLines;\ndelete [] pal;\n</code></pre>\n<p>最简单的方法是不用数组，使用STL里的容器，如<code>vector&lt;string&gt;</code></p>\n<h3 id=\"以独立语句将newed对象置入智能指针\">以独立语句将newed对象置入智能指针</h3>\n<p>C++中调用一个函数，会先计算每一个传递进去的实参</p>\n<p>如果按下面的写法，将newed对象置入智能指针中</p>\n<pre><code class=\"language-c++\">分配函数(shared_ptr&lt;Widget&gt;(new Widget), 资源访问);\t\t//不要这样写\n</code></pre>\n<p>需要执行一下函数</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>调用“资源访问”函数（A）</p>\n</li>\n<li class=\"lvl-2\">\n<p>执行<code>new Widget</code>（B）</p>\n</li>\n<li class=\"lvl-2\">\n<p>调用<code>shared_ptr</code>构造函数（C）</p>\n</li>\n</ul>\n<p>然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）</p>\n<p>如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏</p>\n<p>所以简单的方法是分离语句</p>\n<pre><code class=\"language-c++\">shared_ptr&lt;Widget&gt; pw(new Widget);\n分配函数(pw, 资源访问);\n</code></pre>\n<h2 id=\"四：设计与声明\">四：设计与声明</h2>\n<h3 id=\"让接口容易被正确使用\">让接口容易被正确使用</h3>\n<p>客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）</p>\n<h4 id=\"限制参数传递\">限制参数传递</h4>\n<p>这是一个日期类</p>\n<pre><code class=\"language-c++\">class Date&#123;\npublic:\n  Date(int month, int day, int year);\n  ...\n&#125;;\n...\nDate d(4, 20, 2022);\n</code></pre>\n<p>客户很有可能填错顺序，也有可能填入一个无效的参数</p>\n<p>可以使用<strong>外覆类型（wrapper types）</strong>，当然做出类会更好</p>\n<pre><code class=\"language-c++\">struct Day&#123;\n  explict Day(int d) : val(d) &#123;&#125;\n  int val;\n&#125;;\nstruct Month&#123;\n  explict Month(int m) : val(m) &#123;&#125;\n  int val;\n&#125;;\nstruct Year&#123;\n  explict Year(int y) : val(y) &#123;&#125;\n  int val;\n&#125;;\nclass Date&#123;\npublic:\n  Date(const Mouth&amp; month, const Day&amp; day, const Year&amp; year);\n  ...\n&#125;;\n...\nDate d(Month(4), Day(20), Year(2022));\n</code></pre>\n<h4 id=\"一致性\">一致性</h4>\n<p>自定义的行为要与内置类型的行为一致，比如你不能把<code>operator*</code>重载成<code>operator+</code></p>\n<p>或则像STL中，容器的接口都很一致，比如<code>size</code>、<code>push_back</code>等等</p>\n<h3 id=\"设计class犹如设计type\">设计class犹如设计type</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对象要如何创建和销毁</p>\n</li>\n<li class=\"lvl-2\">\n<p>对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）</p>\n</li>\n<li class=\"lvl-2\">\n<p>对象如果被值传递，意味着什么（深浅拷贝）</p>\n</li>\n<li class=\"lvl-2\">\n<p>约束成员变量的合法值</p>\n</li>\n<li class=\"lvl-2\">\n<p>是否可以/需要被继承</p>\n</li>\n<li class=\"lvl-2\">\n<p>能否类型转换，如何类型转换</p>\n</li>\n<li class=\"lvl-2\">\n<p>支持何种操作符</p>\n</li>\n<li class=\"lvl-2\">\n<p>成员变量的访问修饰</p>\n</li>\n<li class=\"lvl-2\">\n<p>成员函数的访问修饰</p>\n</li>\n<li class=\"lvl-2\">\n<p>未声明接口（undecided interface）</p>\n</li>\n<li class=\"lvl-2\">\n<p>是否需要定义模版</p>\n</li>\n<li class=\"lvl-2\">\n<p>真的需要一个新类吗？</p>\n</li>\n</ul>\n<h3 id=\"多用引用传递\">多用引用传递</h3>\n<p>C++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些<strong>很大的自定义类型</strong>来说性能非常糟糕</p>\n<p>使用const引用传递会好很多</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不会创建新的对象</p>\n</li>\n<li class=\"lvl-2\">\n<p>不会改变原有对象</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以避免<strong>对象切割</strong>问题</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了</li>\n</ul>\n</li>\n</ul>\n<p>只不过引用传递是大多是通过指针实现的，在处理一些<strong>简单的内置类型</strong>时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递</p>\n<h3 id=\"必须返回对象时，不要返回引用\">必须返回对象时，不要返回引用</h3>\n<p>如果必须返回对象，请不要返回引用（比如<code>operator*</code>，<code>operator==</code>），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个<strong>右值</strong>的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用</p>\n<h3 id=\"将成员变量隐藏\">将成员变量隐藏</h3>\n<p>成员变量应该为private，而不是public</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）</p>\n</li>\n<li class=\"lvl-2\">\n<p>分离读写权限（这一点C#做的更好？）</p>\n</li>\n<li class=\"lvl-2\">\n<p>封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）</p>\n</li>\n<li class=\"lvl-2\">\n<p>便于对成员变量进行约束（更不容易出现异常值）</p>\n</li>\n<li class=\"lvl-2\">\n<p>protected并不比public更具有封装性</p>\n</li>\n</ul>\n<h3 id=\"使用非成员函数\">使用非成员函数</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>C#，java选手可以略过</p>\n</li>\n<li class=\"lvl-2\">\n<p>C++标准库就是这样写的</p>\n</li>\n</ul>\n<p>这里有一个类，其中有多个成员函数</p>\n<pre><code class=\"language-c++\">class WebBrowser&#123;\npublic:\n\tvoid doA();\n  void doB();\n  void doC();\n  ...\n&#125;;\n</code></pre>\n<p>现在需要令一个函数做ABC三件事，有两种写法</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>成员函数</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class WebBrowser&#123;\npublic:\n\t...\n  void doEverything()&#123;\n    doA();\n    doB();\n    doC();\n  &#125;\n  ...\n&#125;;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>非成员函数</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">void doEverything(WebBrowser&amp; wb)&#123;\n\twb.doA();\n  wb.doB();\n  wb.doC();\n&#125;\n</code></pre>\n<p>令人意外的是，第二种方法（使用非成员函数）更好</p>\n<h4 id=\"什么是封装\">什么是封装</h4>\n<p>一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强</p>\n<p>为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物</p>\n<h4 id=\"为什么第二种比第一种封装性更强\">为什么第二种比第一种封装性更强</h4>\n<p>因为第一种给用户两种调用方法，一个是调用成员函数<code>doEverything()</code>，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>注意第一种方法中，<code>doEverything()</code>和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利</p>\n</li>\n</ul>\n<p>那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的<strong>静态成员（static member）函数</strong>即可</p>\n<p>或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）</p>\n<pre><code class=\"language-c++\">namespace WebBrowserStuff&#123;\n\tclass WebBrowser&#123;...&#125;;\n\tvoid doEverything(WebBrowser&amp; wb)&#123;...&#125;\n&#125;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可拓展性更强</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>可拆分</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如果所有参数都需要进行类型转换，使用非成员函数\">如果所有参数都需要进行类型转换，使用非成员函数</h3>\n<p>令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时</p>\n<p>比如一个有理数乘法</p>\n<pre><code class=\"language-c++\">class Rational&#123;\npublic:\n  //这个类没有自定义的explict构造函数\n  const Rational opertaor* (const Rational&amp; rhs) const;\n  ...\n&#125;;\n</code></pre>\n<pre><code class=\"language-c++\">Rational oneEighth(1,8);\nRational oneHalf(1,2);\nRational result = oneHalf * oneEighth;\t//成功\nresult = result * oneEighth;\t//成功\nresult = oneHalf * 2;\t\t//成功，等价于 result = oneHalf.operator*(2)\nresult = 2 * oneHalf;\t\t//失败，等价于 result = 2.operator*(oneHalf)\n</code></pre>\n<p><code>result = oneHalf * 2;</code>为什么成功，因为这里发生了一次隐式转换，将<code>2</code>转化为了一个<code>Rational</code>类型</p>\n<p>在编译器中可能等价于</p>\n<pre><code class=\"language-c++\">const Rational temp(2);\nresult = oneHalf * temp;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将<code>2</code>转化为一个<code>Rational</code>类型</p>\n</li>\n</ul>\n<p><code>result = 2 * oneHalf;\t</code>为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时<code>2</code>就是一个int类型，没有我们所自定义的<code>operator*</code>函数，自然会失败</p>\n<p>可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）</p>\n<pre><code class=\"language-c++\">const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123;\n  return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());\n&#125;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此外要极力避免使用<strong>友元（friend）函数</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数</p>\n</li>\n</ul>\n<h3 id=\"写一个不抛异常的swap函数\">写一个不抛异常的swap函数</h3>\n<p>swap函数原本是STL的一部分，后来称为了<strong>异常安全性编程</strong>的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要</p>\n<p>std是一个很特殊的命名空间，客户可以<strong>全特化</strong>（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定</p>\n<p>全特化：针对某个类做模板函数的特例，如对<code>std::swap</code>做一个针对<code>Widget</code>的特化</p>\n<pre><code class=\"language-c++\">class WidgetImpl&#123;...&#125;;\t\t//这个类的对象中存储着真正的数据\nclass Widget&#123;\npublic:\n    Widget&amp; operator=(const Widget&amp; rhs)&#123;\n        ...\n        *pImpl = *(rhs.pImpl);\n        ...\n    &#125;\n    ...\n    void swap(Widget&amp; other)&#123;\t//这个函数决对不可抛异常\n        using std::swap;\n        swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针\n    &#125;\n    ...\nprivate:\n    WidgetImple* pImpl;\t\t//这个类有一个指向资源对象的指针\n&#125;;\nnamespace std&#123;\n\ttemplate&lt;&gt;\n    void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;\t//这个可以抛异常\n        a.swap(b);\t\n    &#125;\n&#125;\n</code></pre>\n<p>此外，C++的STL容器就是上面这种写法，提供了<code>public swap</code>成员函数和<code>std::swap</code>的特化版本</p>\n<h2 id=\"五：实现（Implementations）\">五：实现（Implementations）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>随意定义变量可能会导致性能降低</p>\n</li>\n<li class=\"lvl-2\">\n<p>过度使用转型（casts）可能会导致性能降低，难以维护，可读性低</p>\n</li>\n<li class=\"lvl-2\">\n<p>返回对象的内部数据的handles，可能会破坏封装</p>\n</li>\n<li class=\"lvl-2\">\n<p>未考虑异常可能会导致资源泄露和数据败坏</p>\n</li>\n<li class=\"lvl-2\">\n<p>过度使用inline可能会导致包体膨胀</p>\n</li>\n<li class=\"lvl-2\">\n<p>过度耦合（coupling）可能会增加构建时间（build times）</p>\n</li>\n</ul>\n<h3 id=\"尽量延后变量定义式的出现时间\">尽量延后变量定义式的出现时间</h3>\n<h4 id=\"避免未曾使用的变量\">避免未曾使用的变量</h4>\n<p>如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过</p>\n<p>此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、</p>\n<h4 id=\"避免无意义的默认构造函数\">避免无意义的默认构造函数</h4>\n<p>如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好</p>\n<h4 id=\"循环\">循环</h4>\n<p>此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？</p>\n<p><strong>循环内</strong></p>\n<pre><code class=\"language-c++\">for(int i = 0; i &lt; n; i++)&#123;\n  Widget w(...);\n  ...\n&#125;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>n个构造函数+n个析构函数</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果<code>Widget</code>是一个很敏感的类，这样会让其作用域更小，更容易理解和维护</p>\n</li>\n</ul>\n<p><strong>循环外</strong></p>\n<pre><code class=\"language-c++\">Widget w;\nfor(int i = 0; i &lt; n; i++)&#123;\n  w = ...;\n  ...\n&#125;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个构造函数+一个析构函数+n个赋值操作</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）</p>\n</li>\n</ul>\n<h3 id=\"少做转型\">少做转型</h3>\n<p>C++是强类型语言，设计目标应该是保证类型错误绝不发生，然而<strong>类型转换</strong>破坏了类型系统</p>\n<p>Java、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险</p>\n<p>C++的类型转化</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>旧式转换</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\"><code>(T)expression</code></li>\n<li class=\"lvl-4\"><code>T(expression)</code></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>新式转换</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\"><code>const_cast&lt;T&gt;(expression)</code>\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">用于将对象的<strong>常量性转除（cast away the constness）</strong></li>\n<li class=\"lvl-6\">比如将<code>const</code>转化为<code>non-const</code></li>\n</ul>\n</li>\n<li class=\"lvl-4\"><code>dynamic_cast&lt;T&gt;(expression)</code>\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">用来<strong>安全向下转型</strong></li>\n<li class=\"lvl-6\">无法由旧式语句执行</li>\n<li class=\"lvl-6\">耗费巨大</li>\n</ul>\n</li>\n<li class=\"lvl-4\"><code>reinterpret_cast&lt;T&gt;(expression)</code>\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">用于低级转型，实际操作取决于编译器，不可移植</li>\n<li class=\"lvl-6\">极其少用</li>\n</ul>\n</li>\n<li class=\"lvl-4\"><code>static_cast&lt;T&gt;(expression)</code>\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">用于<strong>强迫隐式转换（implicit conversions）</strong></li>\n<li class=\"lvl-6\">比如<code>non-const</code>转化为<code>const</code>，<code>int</code>转化为<code>double</code>，<code>void*</code>转化为<code>typed</code>，基类指针转化为派生类指针</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>避免C++类型转换出问题的核心是<strong>避免使用基类的接口处理派生类</strong></p>\n<h4 id=\"一个对象多个地址\">一个对象多个地址</h4>\n<p>C++很神奇，如果一个基类指针指向一个派生类对象，如</p>\n<pre><code class=\"language-C++\">Dervied d;\nBase* b = &amp;d;\n</code></pre>\n<p>这可能会导致两个指针值不一样，即这个对象有两个地址，一个<code>Derivied*</code>指针一个<code>Base*</code>指针，这派生类指针上往往会有一个<strong>偏移量（offset）</strong>，通过这个偏移量，可以通过派生类指针找到基类指针</p>\n<p>上面这种事在Java、C#、C中绝对不会发生，但是C<ins>可以多继承，很容易出现这种情况（单继承时也会出现），所以**请不要假定对象在C</ins>中如何布局**，更不应该基于这个假设对对象进行类型转换</p>\n<p>如果你想让当前对象调用基类的函数，如果对<code>*this</code>做强制转化，转换为基类，<code>*this</code>其实是先前产生的<code>*this</code>对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题</p>\n<pre><code class=\"language-c++\">class SpecialWindow: public Window&#123;\npublic:\n  virtual void onResize()&#123;\n    //static_cast&lt;Window&gt;(*this).onResize();\t//这样不好\n    Window::onResize();\t\t//请用这种方式调用基类的onResize函数（作用到当前对象上）\n    ...\n  &#125;\n&#125;\n</code></pre>\n<h4 id=\"dynamic-cast\">dynamic_cast</h4>\n<p>这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象</p>\n<p>什么时候使用这个东西？当<strong>你想在</strong>一个你认为是派生类对象的<strong>对象上执行</strong>派生类的操作<strong>函数</strong>，但你手里却只有一个指向基类的引用/指针时</p>\n<p>解决方法：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器</p>\n</li>\n<li class=\"lvl-2\">\n<p>在基类中提供virtual函数</p>\n</li>\n</ul>\n<h3 id=\"避免返回指向对象内部成分的handles\">避免返回指向对象内部成分的handles</h3>\n<p>前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便</p>\n<p>但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的</p>\n<pre><code class=\"language-c++\">class Point&#123;\npublic:\n  ...\n  void setX(int val);\n  ...\n&#125;;\nstruct RectData&#123;\n  Point ulhc;\t\t//upper left hand corner\n  Point lrhc;\t\t//lower right hand corner\n&#125;;\nclass Rectangle&#123;\npublic:\n  ...\n  Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;\t//这样返回了引用，非常不好\n  ...\nprivate:\n  std::tr1::shared_ptr&lt;RectData&gt; pData;\n&#125;;\n...\nrec.upperLeft().setX(50);\t\t//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改\n</code></pre>\n<p><code>upperLeft</code>函数本来只是为了提供给客户获得（get）<code>Rectangle</code>的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了<code>Rectangle</code>本身，而且还是一个内部数据<code>RectData</code></p>\n<p>为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）</p>\n<p>解决方法很简单，只要让handles不可以被修改，就可以了</p>\n<pre><code class=\"language-c++\">class Rectangle&#123;\npublic:\n  ...\n  const Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;\t\n  ...\n&#125;;\n</code></pre>\n<p>但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致<strong>dangling handles（空悬的号码牌）</strong>，比如返回了一个对local变量的引用，依然特别危险</p>\n<p>当然，有的时候不得不返回handles，比如<code>operator[]</code></p>\n<h3 id=\"异常安全性很重要\">异常安全性很重要</h3>\n<p>**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不泄漏任何资源</p>\n</li>\n<li class=\"lvl-2\">\n<p>不允许数据败坏</p>\n</li>\n</ul>\n<p>不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂</p>\n<p>三个保证：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏</p>\n</li>\n<li class=\"lvl-2\">\n<p>强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过<code>copy-and-swap</code>实现）</p>\n</li>\n<li class=\"lvl-2\">\n<p>不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）</p>\n</li>\n</ul>\n<p><strong>异常安全码</strong>必须提供上述三种保障之一，如果不能保障，则不具备异常安全性</p>\n<h3 id=\"了解inline函数\">了解inline函数</h3>\n<p>内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化</p>\n<p>缺点也很明显，会让包体变大，会导致<strong>换页行为（paging）</strong>，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数</p>\n<p>内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联</p>\n<h3 id=\"降低文件间的编译依存\">降低文件间的编译依存</h3>\n<p>如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译</p>\n<p>为什么C<ins>要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C</ins>为什么需要先定义，后使用）</p>\n<p>这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类</p>\n<p><em>话说应该不会有人不知道implementation是实现的意思吧</em></p>\n<pre><code class=\"language-c++\">class PersonImpl;\t//pimpl写法，这是Person类的前置声明\nclass Data;\t\t\t\t//Data的前置声明\nclass Address;\t\t//Address的前置声明\n\nclass Persion&#123;\t//像这样使用pimpl的类，往往被称为Handle classes\npublic:\n  ...\n  std::string name() const;\n  ...\nprivate:\n  std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;\n&#125;;\n</code></pre>\n<p>在这种设计下，<code>Person</code>就与<code>Data</code>、<code>Address</code>以及<code>Persons</code>的实现分离了，改动这些类也不会导致使用<code>Person</code>的客户重新编译，客户无法看到<code>Person</code>的实现细节，真正实现<strong>接口与实现分离</strong></p>\n<p>这个操作的本质是用<strong>声明的依赖性</strong>替换<strong>定义的依赖性</strong></p>\n<p>此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明</p>\n<p>此外还有另一种制作<code>Handle class</code>的方法，就是令<code>Person</code>成为一个特殊的抽象基类，称为<code>Interface class</code>，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）</p>\n<pre><code class=\"language-c++\">class Person&#123;\t\t//Interface class\npublic:\n  virtual ~Person();\n  virtual std::string name() const = 0;\n  ...\n&#125;;\nclass Person&#123;\t\t//具现化\npublic:\n  static std::tr1::shared_ptr&lt;Person&gt; create(const std::string&amp; name...);\n  ...\n&#125;;\n...\n//使用\nstd::tr1::shared_ptr&lt;Person&gt; pp(Person::create(name...));\nstd::cout &lt;&lt; pp-&gt;name();\n</code></pre>\n<pre><code class=\"language-c++\">class RealPerson: public Person&#123;\t\npublic:\n  RealPerson(const std::string&amp; name, ...): theName(name), ...&#123;&#125;\n  virtual ~RealPerson() &#123;&#125;\n  std::string name() const;\t\t\n  ...\nprivate:\n\tstd::string theName;\n&#125;;\nstd::string ReakPerson::name()&#123;...&#125;\nstd::tr1::shared_ptr&lt;Person&gt; Person::create(const std::string&amp; name, ...)&#123;\n  retrun std::tr1::shared_ptr&lt;Person&gt;(new RealPerson(name, ...));\n&#125;\n</code></pre>\n<h2 id=\"六：继承与面向对象\">六：继承与面向对象</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>is-a</code>：是一个</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>has-a</code>：有一个</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>is-implemented-in-terms-of</code>：根据xx实现出</p>\n</li>\n</ul>\n<h3 id=\"public继承是is-a关系\">public继承是is-a关系</h3>\n<pre><code class=\"language-c++\">class Student: public Person&#123;...&#125;;\t//Student is a Person\n</code></pre>\n<p>每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化</p>\n<p><strong>public继承下，可以把子类当父类用</strong>，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用</p>\n<p>这就出现了一个问题，子类一定要<code>is a</code>父类，不然会出现问题</p>\n<p>错误的继承：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？</p>\n</li>\n<li class=\"lvl-2\">\n<p>正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？</p>\n</li>\n</ul>\n<h3 id=\"避免遮掩父类成员\">避免遮掩父类成员</h3>\n<pre><code class=\"language-c++\">int x;\nvoid Fun()&#123;\n    double x;\n    ...\n&#125;\n</code></pre>\n<p>由于<strong>作用域</strong>的<strong>名称遮掩规则</strong>，函数内部的local变量x覆盖了全局变量x</p>\n<h4 id=\"子类名称会遮掩父类名称，在public继承下是错误的\">子类名称会遮掩父类名称，在public继承下是错误的</h4>\n<p>在OOP中，如果子类重载了父类的<code>non-virtual</code>函数，就意味着子类使用同名函数遮掩了父类函数，就意味着<strong>这个父类函数没有被子类继承！</strong>，那么在这种情况下，继承就不是<code>is-a</code>关系了</p>\n<p><strong>在public继承下，子类继承了父类的一切</strong></p>\n<pre><code class=\"language-c++\">class Base&#123;\npublic:\n    virtual void f1() = 0;\n    virtual void f1(int);\n    void f2();\n    void f2(double);\n    ...\nprivate:\n    int x;\n&#125;;\nclass Derived: public Base&#123;\npublic:\n    virtual void f1();\n    void f2();\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)\n</code></pre>\n<h4 id=\"将被遮掩的名称重见天日\">将被遮掩的名称重见天日</h4>\n<p>解决起来很简单，只需要让父类的函数在子类作用域内可见，可以<strong>使用using关键字</strong></p>\n<pre><code class=\"language-c++\">class Derived: public Base&#123;\npublic:\n    using Base::f1;\n    using Base::f2;\n    virtual void f1();\n    void f2();\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//正确，调用Base::f1\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//正确，调用Base::f2\n</code></pre>\n<p>如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以<strong>使用转交函数</strong>，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中</p>\n<pre><code class=\"language-c++\">class Derived: private Base&#123;\npublic:\n    virtual void f1()&#123;\n        Base::f1();\t\t//inline转交函数\n    &#125;\n    ...\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1\n</code></pre>\n<h3 id=\"区分接口继承和实现继承\">区分接口继承和实现继承</h3>\n<p>public继承分为两个部分</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>函数接口继承</p>\n</li>\n<li class=\"lvl-2\">\n<p>函数实现继承</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>接口继承</th>\n<th>实现继承</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>纯虚函数</td>\n<td>具体指定</td>\n<td>不继承</td>\n</tr>\n<tr>\n<td>非纯虚函数</td>\n<td>具体指定</td>\n<td>继承一份缺省实现</td>\n</tr>\n<tr>\n<td>non-virtual函数</td>\n<td>具体指定</td>\n<td>继承一份强制实现</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"考虑使用virtual以外的选择\">考虑使用virtual以外的选择</h3>\n<h4 id=\"基于NVI的Template-Method模式\">基于NVI的Template Method模式</h4>\n<p>Non-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数</p>\n<pre><code class=\"language-c++\">class GameCharacter&#123;\npublic：\n    int healthValue() const\n\t&#123;\n    \t...\n    \tint retVal = doHealthValue();\n    \t...\n    \treturn retVal;\n\t&#125;\nprivate：\n    virtual int doHealthValue() const\n    &#123;\n\t\t...\n    &#125;\n&#125;;\n</code></pre>\n<p>其中<code>healthValue()</code>被称为virtual函数的<strong>外覆器（wrapper）</strong></p>\n<h4 id=\"基于函数指针的Strategy模式\">基于函数指针的Strategy模式</h4>\n<pre><code class=\"language-c++\">class GameCharacter;\nint defaultHealthCalc(const GameCharacter&amp; gc);\nclass GameCharacter&#123;\npublic:\n    typedef int (*HealthCalcFunc)(const GameCharacter&amp;);\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125;\n    int healthValue() const &#123; return healthFunc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n&#125;;\n</code></pre>\n<p>在这种模式下，<code>defaultHealthCalc</code>函数不再是<code>GameCharacter</code>体系内的成员函数，通过修改函数指针，就可以让<code>GameCharacter</code>使用不同种类的计算函数，弹性更强，而且可以在运行时变更</p>\n<p>此外<code>defaultHealthCalc</code>函数不需要/不能访问<code>GameCharacter</code>内的<code>non-public</code>部分，</p>\n<h4 id=\"基于tr1-function的Strategy模式\">基于tr1::function的Strategy模式</h4>\n<p>上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如<code>tr1::function</code>对象</p>\n<pre><code class=\"language-c++\">class GameCharacter;\nint defaultHealthCalc(const GameCharacter&amp; gc);\nclass GameCharacter&#123;\npublic:\n    typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125;\n    int healthValue() const &#123; return healthFunc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n&#125;;\n</code></pre>\n<h4 id=\"古典的Strategy模式\">古典的Strategy模式</h4>\n<pre><code class=\"language-c++\">class GameCharacter;\nclass HealthCalcFunc&#123;\npublic:\n    ...\n    virtual int calc(const GameCharacter&amp; gc) const&#123;...&#125;\n    ...\n&#125;;\nHealthCalcFunc defaultHealthCalc;\nclass GameCharacter&#123;\npublic:\n    explicit GameCharacter(HealthCalcFunc* phcf = &amp;defaultHealthCalc): pHealthFunc(phcf)&#123;&#125;\n    int healthValue() const &#123; return phealthFunc-&gt;calc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc* pHealthFunc;\n&#125;;\n</code></pre>\n<h3 id=\"绝不重新定义继承而来的non-virtual函数\">绝不重新定义继承而来的non-virtual函数</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>静态绑定（staticcally bound）：non-virtual就是这种</p>\n</li>\n<li class=\"lvl-2\">\n<p>动态绑定（dynamically bound）：virtual就是这种</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class B&#123;\npublic:\n\tvoid f();\n\t...\n&#125;;\nclass D: public B&#123;\npublic:\n  void f();\n  ...\n&#125;;\n...\nD x;\nB* pB = &amp;x;\nD* pD = &amp;x;\npB-&gt;f();\t//调用B::f\npD-&gt;f();\t//调用D::f\n</code></pre>\n<h3 id=\"绝对不重新定义继承而来的缺省参数值\">绝对不重新定义继承而来的缺省参数值</h3>\n<p><strong>virtual函数是动态绑定的，缺省参数值是静态绑定的</strong></p>\n<pre><code class=\"language-c++\">class Cricle: public Shape&#123;...&#125;;\n...\nShape* p1;\t//p1的静态类型是Shape*，没有动态类型\nShape* p2 = new Circle;\t//p2的静态类型是Shape*，动态类型是Circle*\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>静态类型</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">指针的类型就是<strong>静态类型</strong></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>动态类型</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">所指向的对象的类型是<strong>动态类型</strong></li>\n<li class=\"lvl-4\">动态类型可以通过赋值等操作改变</li>\n</ul>\n</li>\n</ul>\n<p>virtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载</p>\n<p>但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数</p>\n<h3 id=\"has-a和根据xx实现出\">has-a和根据xx实现出</h3>\n<p>一个类中有多个小类，这种关系被称为<strong>复合（composition）</strong>，其中这些小类被称为<strong>合成成分物（composed object）</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在应用域，复合意味着<code>has-a</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">人有名字（也不尽然）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>在实现域，复合意味着<code>is-implemented-in-terms-of</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"少用private继承\">少用private继承</h3>\n<p><em>经典 C++糟粕，请问 C#有这个吗？</em></p>\n<p>本质上是一种<code>is-implemented-in-terms-of</code>关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>private继承，编译器无法自动将子类对象转化为父类对象</p>\n</li>\n<li class=\"lvl-2\">\n<p>private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）</p>\n</li>\n</ul>\n<p><strong>尽量使用复合来替代pirvate继承</strong>，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数</p>\n<p>此外private继承的对象有可能比复合的对象要小</p>\n<h3 id=\"少用多重继承\">少用多重继承</h3>\n<p><em>经典 C++糟粕，请问 C#有这个吗？</em></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可能会导致歧义</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">当然你可以在调用函数的时候指出是来自哪一个基类</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>可能会导致菱形继承</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">菱形继承可能会导致变量重复</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"七：模版与泛型\">七：模版与泛型</h2>\n<p>模板（templates）是泛型编程（generic programming）的基础</p>\n<p>模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译</p>\n<h3 id=\"评价\">评价</h3>\n<p>优点：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>模板编程能够实现非常灵活且类型安全的接口</p>\n</li>\n<li class=\"lvl-3\">\n<p>极好的性能（更小的文件、更短的运行期，更少的内存需求）</p>\n</li>\n<li class=\"lvl-3\">\n<p>可以将一些运行时才能侦测到的错误，在编译期找出来</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>难以编程和维护</p>\n</li>\n<li class=\"lvl-3\">\n<p>编译报错信息难以理解</p>\n</li>\n<li class=\"lvl-3\">\n<p>难以重构</p>\n</li>\n<li class=\"lvl-3\">\n<p>编译时间大幅变长</p>\n</li>\n</ol>\n<p>因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释</p>\n<h3 id=\"隐式接口和编译期多态\">隐式接口和编译期多态</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>OOP中经常使用显式接口和运行时多态</p>\n</li>\n<li class=\"lvl-2\">\n<p>泛型编程更多使用隐式接口和编译期多态</p>\n</li>\n</ul>\n<pre><code class=\"language-C++\">template&lt;typename T&gt;\nvoid doProcessing(T&amp; w)\n&#123;\n    if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget)&#123;\n        T temp(w)\n        temp.normalize();\n        temp.swap(w);\n    &#125;\n&#125;\n</code></pre>\n<p>从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组<strong>隐式接口</strong></p>\n<p>所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功</p>\n<p>这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是<strong>编译期多态</strong></p>\n<h3 id=\"Traits\">Traits</h3>\n<p>一种约定俗成的技术方案，为同一类数据提供统一的操作函数</p>\n<p>比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。</p>\n<pre><code class=\"language-C++\">enum Type&#123;\n    TYPE_1;\n    TYPE_2;\n&#125;;\nclass FOO&#123;\n    Type type = Type::TYPE_1;\n&#125;;\nclass Bar&#123;\n    Type type = Type::TYPE_2;\n&#125;;\n//统一的模板函数\ntemplate&lt;typename T&gt;\nvoid decode(const T&amp; data, char* buf)&#123;\n    if(T::type == Type::TYPE_1)&#123;\n        ...\n    &#125;\n    else if(T::type == Type::TYPE_2)&#123;\n        ...\n    &#125;\n&#125;\n</code></pre>\n<p>但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术</p>\n<pre><code class=\"language-C++\">enum Type&#123;\n    TYPE_1;\n    TYPE_2;\n&#125;;\nclass FOO&#123;\n    Type type = Type::TYPE_1;\n&#125;;\nclass Bar&#123;\n    Type type = Type::TYPE_2;\n&#125;;\n\ntemplate&lt;typename T&gt;\nstruct type_traits&#123;\n    Type type = T::type;\n&#125;\n//为内置数据类型特化为独有的 type_traits\ntemplate&lt;typename int&gt;\nstruct type_traits&#123;\n    Type type = Type::TYPE_1;\n&#125;\n//统一的模板函数\ntemplate&lt;typename T&gt;\nvoid decode(const T&amp; data, char* buf)&#123;\n    if(type_traits&lt;T&gt;::type == Type::TYPE_1)&#123;\n        ...\n    &#125;\n    else if(type_traits&lt;T&gt;::type == Type::TYPE_2)&#123;\n        ...\n    &#125;\n&#125;\n</code></pre>\n<p>该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因</p>\n<h3 id=\"模板元编程\">模板元编程</h3>\n<p>TMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化</p>\n<p>如果一门语言具备以下功能，则称为图灵完全</p>\n<ol>\n<li class=\"lvl-3\">\n<p>数值运算和符号运算</p>\n</li>\n<li class=\"lvl-3\">\n<p>判断</p>\n</li>\n<li class=\"lvl-3\">\n<p>递归</p>\n</li>\n</ol>\n<h4 id=\"数值运算-递归\">数值运算+递归</h4>\n<pre><code class=\"language-C++\">//一个TMP计算阶乘，而且阶乘的技术发生在编译期\ntemplate&lt;unsigned n&gt;\nstruct Factorial\n&#123;\n    enum &#123; value = n * Factorial&lt;n-1&gt;::value &#125;;\n&#125;;\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt;\n&#123;\n    enum &#123; value = 1 &#125;;\n&#125;;\n\nint main()\n&#123;\n    std::cout &lt;&lt; Factorial&lt;5&gt;::value;\n&#125;\n</code></pre>\n<p>C++11TMP这种函数式编程得到了加强，上文也可以这样写</p>\n<pre><code class=\"language-C++\">template&lt;unsigned n&gt;\nstruct Factorial\n&#123;\n    constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;;\n&#125;;\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt;\n&#123;\n    constexpr static auto value = 1;\n&#125;;\n</code></pre>\n<h4 id=\"判断\">判断</h4>\n<pre><code class=\"language-C++\">template&lt;bool Value&gt;\nstruct if_constexpr\n&#123;\n    constexpr static auto value = 1;\n&#125;;\n\ntemplate&lt;&gt;\nstruct if_constexpr&lt;false&gt; &#123;\n    constexpr static auto value = 2;\n&#125;;\n\nint main()\n&#123;\n    std::cout &lt;&lt; if_constexpr&lt;true&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; if_constexpr&lt;false&gt;::value &lt;&lt; std::endl;\n&#125;\n</code></pre>\n<h3 id=\"typedef\">typedef</h3>\n<p>在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名</p>\n<p>下面是一个函数指针的示例</p>\n<pre><code class=\"language-C++\">void add(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; x + y &lt;&lt; std::endl;\n&#125;\nvoid dec(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x-y=&quot; &lt;&lt; x - y &lt;&lt; std::endl;\n&#125;\nvoid mul(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x*y=&quot; &lt;&lt; x*y &lt;&lt; std::endl;\n&#125;\n\nvoid (*op[3])(int, int) = &#123; add, dec, mul &#125;;\n\nint main()\n&#123;\n    for (int i = 0; i &lt; 3; ++i) &#123;\n        （*op[i])(4, 3);\n    &#125;\n&#125;\n</code></pre>\n<p>如果使用typedef</p>\n<pre><code class=\"language-C++\">typedef void (*Func[3])(int, int);\nFunc f = &#123; add, dec, mul &#125;;\n\nint main()\n&#123;\n    for (int i = 0; i &lt; 3; ++i) &#123;\n        f[i](4, 3);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"八：定制new和delete\">八：定制new和delete</h2>\n<p>Java和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目</p>\n<h3 id=\"new-handler\">new-handler</h3>\n<p>当<code>operator new</code>无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即<code>new-handler</code></p>\n<p>使用<code>set_new_handler</code>来指定<code>new-handler</code></p>\n<pre><code class=\"language-c++\">void outOfMem()&#123;\n  std::cerr &lt;&lt; &quot;内存不足\\n&quot;;\n  std::abort();\n&#125;\nint main()&#123;\n  std::set_new_handler(outOfMem);\t\t//该函数的参数是一个函数指针\n  int* array = new int[10000000L];\n  ...\n&#125;\n</code></pre>\n<p>当<code>operator new</code>无法满足内存申请时，会不断调用<code>new-handler</code>函数，直到找到足够的内存，所以<code>new-handler</code>函数应该满足</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>让更多的内存可被使用</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">实现方法是程序开始时就分配一大块内存，每次调用<code>new-handler</code>时就释放一点点</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>安装另一个<code>new-handler</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">如果现在这个<code>new-handler</code>无法获取更多内存，需要知道哪一个<code>new-handler</code>具备增大内存的实力，然后使用<code>set_new_handler</code>来替换自己</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>卸除<code>new-handler</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">通过<code>set_new_handler</code>赋值<code>null</code>，将<code>new-handler</code>卸载，使得在内存分配不足时，会抛异常</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>抛出<code>bad_alloc</code>异常</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">这种异常不会被<code>operator new</code>捕获，会被传播至内存索求处</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>不反回</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">调用<code>abort</code>或者<code>exit</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class NewHandlerHolder&#123;\npublic:\n  explicit NewHandlerHolder(std::new_handler nh): handler(nh) &#123;&#125;\t//获取当前的new_handler\n  ~NewHandlerHolder() &#123; std::set_new_handler(handler); &#125;\t\nprivate:\n  std::new_handler handler;\t\t//用于记录当前的new_handler\n&#125;;\nvoid* Widget::operator new(std::size_t size) throw(std::bad_alloc)&#123;\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\t//安装Widget的new-handler\n  return ::operator new(size);\t//分配对象或者抛异常\n&#125;\n//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值\n</code></pre>\n<pre><code class=\"language-c++\">void outOfMem();\nWidget::set_new_handler(outOfMem);\nWidget* pwl = new Widget;\t//内存不足时会调用outOfMem\n</code></pre>\n<p>mixin风格的写法</p>\n<pre><code class=\"language-c++\">template&lt;typename T&gt;\nclass NewHandlerSupport&#123;\npublic:\n  static std::new_handler_set set_new_handler(std::new_handler p) throw();\n  static void* operator new(std::size_t size) throw(std::bad_alloc);\n  ...\nprivate:\n  static std::new_handler currentHandler;\n&#125;;\n\ntemplate&lt;typename T&gt;\nstd::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()&#123;\n  std::new_handler oldHandler = currentHandler;\n  currentHandler = p;\n  return oldHandler;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) throw(std::bad_alloc)&#123;\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\n  return ::operator new(size);\n&#125;\n</code></pre>\n<pre><code class=\"language-c++\">class Widget: public NewHandlerSupport&lt;Widget&gt;&#123;\n\t...\n&#125;;\n</code></pre>\n<p>像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为<strong>怪异的循环模版模式（curiously recurring template pattern，CRTP）</strong></p>\n<h3 id=\"替换new和delete的时机\">替换new和delete的时机</h3>\n<p>C++中所有的news返回的指针都必须要<strong>地址对齐</strong>，int要4对齐，double要8对齐</p>\n<p>写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换</p>\n<h3 id=\"编写new和delete的规则\">编写new和delete的规则</h3>\n<p>如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>new</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用<code>new-handler</code></li>\n<li class=\"lvl-4\">有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）</li>\n<li class=\"lvl-4\">new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理<strong>比正确大小更大的（错误）申请</strong></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>delete</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">收到null指针时不做任何事</li>\n<li class=\"lvl-4\">处理<strong>比正确大小更大的（错误）申请</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"编写new时也要写对应的delete\">编写new时也要写对应的delete</h3>\n<pre><code class=\"language-c++\">Widget* pw = new Widget;\n</code></pre>\n<p>在这里调用了两个函数，一个时用以分配内存的<code>operator new</code>，一个是<code>Widget</code>的构造函数</p>\n<p>如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的</p>\n<p>运行时系统会调用<code>operator new</code>所对应的<code>operator delete</code>来释放地址，对于拥有正常签名式的new和delete来说不成问题</p>\n<pre><code class=\"language-c++\">void* operator new(std::size_t) throw(std::bad_alloc);\t//普通的new\nvoid operator delete(void* rawMemory) throw();\t//global中的普通的new\nvoid operator delete(void* rawMemory, std::size_t size) throw();\t//class中的new\n</code></pre>\n<p>但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题</p>\n<pre><code class=\"language-c++\">void* operator new(std::size_t, void* pMemory) throw();\t//placement new，比普通new多带一个参数\n\nWidget* pw = new (std::cerr) Widget;\t//调用operator new，并以cerr作为其实参\n</code></pre>\n<p>当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的<code>operator new</code>时如何运作的，所以运行时系统会去寻找<strong>参数个数与类型</strong>都与<code>operator new</code>相同的某个<code>operator delete</code></p>\n<pre><code class=\"language-c++\">void operator delete(void*, std::ostream&amp;) throw();\t//palcement delete\n</code></pre>\n<pre><code class=\"language-c++\">class Widget&#123;\npublic:\n  static void* operator new(std::size_t size, std::ostream&amp; logStream) throw(std::bad_alloc);\n  static void operator delete(void* pMemory) throw();\n  static void operator delete(void* pMemoty, std::ostream&amp; logStream) throw();\n  ...\n&#125;;\n</code></pre>\n<p>如果此时调用<code>delete pw</code>，只会调用普通的<code>delete</code>，因为只有在构造时发生异常时，运行时系统才会调用placement delete</p>\n<p>最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete</p>\n<h2 id=\"九：杂项\">九：杂项</h2>\n<h3 id=\"不要忽视编译器警告\">不要忽视编译器警告</h3>\n<p>很多人忽视警告，毕竟一个问题如果真的很严重，应该报错</p>\n<p>比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为</p>\n<pre><code class=\"language-c++\">class B&#123;\npublic:\n  virtual void f() const;\n&#125;;\nclass D: public B&#123;\n  virtual void f();\n&#125;;\n</code></pre>\n<p>报警告</p>\n<pre><code class=\"language-c++\">warning: D::f() hides virtual B::f()\n</code></pre>\n<p>原本的目的是为了在D中重新定义virtual函数<code>f()</code>，但由于B中<code>f()</code>是const，在D中不是，此时B中的<code>f()</code>并没有在D中重新被声明，而是被整个遮掩了</p>\n<h3 id=\"去熟悉标准程序库\">去熟悉标准程序库</h3>\n<p>尤其是TR1</p>\n<h4 id=\"C-98有什么\">C++98有什么</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器</p>\n</li>\n<li class=\"lvl-2\">\n<p>Iostream</p>\n</li>\n<li class=\"lvl-2\">\n<p>国际化支持</p>\n</li>\n<li class=\"lvl-2\">\n<p>数值处理，包括复数（complex）和纯数值数组（valarray）</p>\n</li>\n<li class=\"lvl-2\">\n<p>异常阶层体系</p>\n</li>\n<li class=\"lvl-2\">\n<p>C89标准程序库</p>\n</li>\n</ul>\n<h4 id=\"TR1有什么（全在std-tr1中）\">TR1有什么（全在<code>std::tr1</code>中）</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>智能指针<code>tr1::shared_ptr</code>和<code>tr1::weak_ptr</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::function</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::bind</code></p>\n</li>\n</ul>\n<p>和（彼此无关的独立组件）</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>哈希表</p>\n</li>\n<li class=\"lvl-2\">\n<p>正则表达式</p>\n</li>\n<li class=\"lvl-2\">\n<p>Tuple变量组</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::array</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::mem_fn</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::reference_wrapper</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>随机数生成工具</p>\n</li>\n<li class=\"lvl-2\">\n<p>数学特殊函数</p>\n</li>\n<li class=\"lvl-2\">\n<p>C99兼容</p>\n</li>\n</ul>\n<p>和（基于template）</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Type traits</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::result_of</code></p>\n</li>\n</ul>\n<h3 id=\"熟悉Boost\">熟悉Boost</h3>\n","site":{"data":{}},"excerpt":"","more":"<h1>Effective C++</h1>\n<h2 id=\"一：C-基础\">一：C++基础</h2>\n<h3 id=\"C-很成熟，很NB\">C++很成熟，很NB</h3>\n<p>C++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）</p>\n<p>其核心是四个部分</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>C</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">区块block</li>\n<li class=\"lvl-4\">语句statements</li>\n<li class=\"lvl-4\">预处理器preprocessor</li>\n<li class=\"lvl-4\">内置数据类型</li>\n<li class=\"lvl-4\">数组arrays</li>\n<li class=\"lvl-4\">指针pointers</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Object-Orientend C++</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">类classes（构造函数，析构函数）</li>\n<li class=\"lvl-4\">封装encapsulation</li>\n<li class=\"lvl-4\">继承inheritance</li>\n<li class=\"lvl-4\">多态polymorphism</li>\n<li class=\"lvl-4\">虚函数virtual（动态绑定）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>Template C++</p>\n</li>\n<li class=\"lvl-2\">\n<p>STL</p>\n</li>\n</ul>\n<h3 id=\"替换-define\">替换#define</h3>\n<p>使用编译器替代预处理器</p>\n<p>尽量使用const、enum定义常量，使用inlines定义函数宏</p>\n<h4 id=\"const\">const</h4>\n<pre><code class=\"language-c++\">#define PI 3.1415926\n</code></pre>\n<p>因为<code>#define</code>不是语言的一部分，在编译器开始工作前，<code>PI</code>就会被处理掉，所以一旦报错，你无法追踪到<code>PI</code>，只能看到<code>3.1415926</code>，这会<strong>浪费你的时间</strong></p>\n<p>应该改为</p>\n<pre><code class=\"language-c++\">const double Pi 3.1415926;\n</code></pre>\n<p>值得注意的事</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>定义常量指针指向char*-based字符串</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">const char* const authorName = &quot;Reuben&quot;;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class GemePlayer&#123;\nprivate:\n\tstatic const int NumTurns = 5;\t//这只是一个声明式\n\tint scores[NumTurns];\n&#125;;\nconst int GamePlayer::NumTurns;\t\t//这是定义式，因为在声明时已经赋值，所以这里就不赋值了\n</code></pre>\n<p>C++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式</p>\n<p>从这里可以看出，<strong>const可以封装</strong>，而#define不行</p>\n<h4 id=\"enum\">enum</h4>\n<pre><code class=\"language-c++\">class GemePlayer&#123;\nprivate:\n\tenum &#123; NumTurns = 5 &#125;;\n\tint scores[NumTurns];\n&#125;;\n</code></pre>\n<h3 id=\"const指针\">const指针</h3>\n<p>const在星号左边，被指物是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nconst char* p = greeting;\n</code></pre>\n<p>const在星号右边，指针本身是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nchar* const p = greeting;\n</code></pre>\n<p>const在星号两边，被指物和指针都是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nconst char* const p = greeting;\n</code></pre>\n<h3 id=\"确认对象在使用前已经被初始化\">确认对象在使用前已经被初始化</h3>\n<p>C++初始化顺序</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基类比子类先初始化</p>\n</li>\n<li class=\"lvl-2\">\n<p>成员变量根据其声明次序初始化</p>\n</li>\n</ul>\n<h2 id=\"二：构造-析构-赋值\">二：构造/析构/赋值</h2>\n<h3 id=\"空类的默认函数\">空类的默认函数</h3>\n<p>一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数</p>\n<p>一个类，如果没有构造函数，也会自动声明一个default构造函数</p>\n<p>这些函数都是public且inline的</p>\n<h3 id=\"禁用自动生成的函数\">禁用自动生成的函数</h3>\n<p>如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class HomeForSale&#123;\nprivate:\n\tHomeForSale(const HomeForSale&amp;);\n  HomeForSale&amp; operator=(const HomeForSale&amp;);\n&#125;;\n</code></pre>\n<p>可以制作一个不可被copy的类，让子类继承</p>\n<pre><code class=\"language-c++\">class Uncopyable&#123;\nprotected:\n\tUncopyable()&#123;&#125;\n  ~Uncopyable()&#123;&#125;\nprivate:\n  Uncopyable(const Uncopyable&amp;);\n  Uncopyable&amp; operator=(const Uncopyable&amp;);\n&#125;;\n\nclass HomeForSale: private Uncopyable&#123;\n  ...\n&#125;;\n</code></pre>\n<h3 id=\"为多态基类声明virtual析构函数\">为多态基类声明virtual析构函数</h3>\n<h4 id=\"一定要有一个virtual析构函数\">一定要有一个virtual析构函数</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果这个类要成为一个基类，那么一定要有一个virtual析构函数</p>\n</li>\n</ul>\n<p>在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错</p>\n<pre><code class=\"language-c++\">class TimeKeeper&#123;\npublic:\n\t...\n&#125;;\nclass AtomicClock: public TimeKeeper &#123;...&#125;;\nclass WaterClock: public TimeKeeper &#123;...&#125;;\n</code></pre>\n<pre><code class=\"language-c++\">TimeKeeper* ptk = getTimeKeeper();\t\t//创建一个动态分配对象\n...\ndelete ptk;\t//释放对象，避免资源泄漏\n</code></pre>\n<p>上面这个过程的问题其实出在<code>getTimeKeeper()</code>指向一个派生类（derived class）对象（比如<code>AtomicClock</code>），而这个对象却要经由一个基类（base class）指针删除（比如<code>TimeKeeper*</code>）</p>\n<p>如果这个基类的析构函数不是virtual的，就会出现问题：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象</p>\n</li>\n</ul>\n<p>解决方法就是给基类一个virtual析构函数</p>\n<pre><code class=\"language-c++\">class TimeKeeper&#123;\npublic:\n\tTimeKeeper();\n  virtual ~TimeKeeper();\n  ...\n&#125;;\n</code></pre>\n<h4 id=\"最好不要有virtual析构函数\">最好不要有virtual析构函数</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果这个类不可能成为基类，那么最好不要有virtual析构函数</p>\n</li>\n</ul>\n<p>为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由<strong>vptr（virtual table pointer）<strong>指针携带，这个指针指向一个由函数指针构成的数组，称为</strong>vtbl（virtual table）</strong>，每一个带有virtual函数的类都有一个属于自己的vtbl</p>\n<p><strong>这个vtbl会增大对象的体积</strong>，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍</p>\n<p><strong>这个vtbl会让代码失去兼容性</strong>，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性</p>\n<h4 id=\"请不要继承没有virtual析构函数的类\">请不要继承没有virtual析构函数的类</h4>\n<p>比如string、vector、list、set等等</p>\n<p>而且 C++没有像 Java的<code>final classes</code>或者C#的<code>sealed classes</code>的禁止派生机制</p>\n<h3 id=\"不要在析构函数里抛出异常\">不要在析构函数里抛出异常</h3>\n<p>当一个<code>vector v</code>容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为</p>\n<p>有两个不怎么好的解决方法</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>遇到异常，直接<code>std::abort()</code>，即遇到异常，宁愿直接强制停止程序，也不要让异常传播</p>\n</li>\n<li class=\"lvl-2\">\n<p>遇到异常，把异常记录下来，另程序继续运转，即<strong>吞下异常</strong></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好</li>\n</ul>\n</li>\n</ul>\n<p>比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容</p>\n<pre><code class=\"language-c++\">class DBConnevtion&#123;\npublic:\n    ...\n    static DBConnevtion create();\n    void close();     \n&#125;;\nclass DBConn&#123;\npublic:\n    ...\n    void close()\t//封装给客户用的,关闭连接的函数\n    &#123;\n        db.close();\n        closed = true;\n    &#125;\n    ~DBConn()&#123;\n        if(!closed)&#123;\n            try&#123;\n                db.close();\n            &#125;\n            catch(...)&#123;\n                ...\n                //强制关闭程序或者吞下异常\n            &#125;\n        &#125;\n    &#125;\nprivate:\n    DBConnection db;\n    bool closed;\n&#125;;\n</code></pre>\n<h3 id=\"不要在构造和析构过程中调用virtual函数\">不要在构造和析构过程中调用virtual函数</h3>\n<p>在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果</p>\n<p>可以简单理解为<strong>在C++中，基类构造期间，vritual函数不是vritual函数</strong></p>\n<p>因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数</p>\n<p>同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的</p>\n<h3 id=\"令operator-返回一个对-this的引用\">令operator=返回一个对*this的引用</h3>\n<p>连续赋值</p>\n<pre><code class=\"language-c++\">x = y = z = 15;\n//其实就等于x = (y = (z = 15))；\n</code></pre>\n<p>为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参</p>\n<pre><code class=\"language-c++\">class Widget&#123;\npublic:\n    Widget&amp; operator=(const Widget&amp; rhs)\n    &#123;\n    \t...\n        return *this;\n    &#125;\n    Widget&amp; operator+=(const Widget&amp; rhs)&#123;\n        ...\n        return *this;\n    &#125;\n&#125;;\n</code></pre>\n<h3 id=\"在operator-中处理自我赋值\">在operator=中处理自我赋值</h3>\n<p>如果对象自己赋给自己，我们称之为自我赋值</p>\n<pre><code class=\"language-c++\">w = w;\na[i] = a[j]; //当i=j时，自我赋值\n*px = *py;\t//px和py指向同一个物体时，自我赋值\n</code></pre>\n<p>在赋值操作中：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>我们会先另左边的操作数先释放掉当前使用的数据</p>\n</li>\n<li class=\"lvl-3\">\n<p>令其使用右操作数的副本</p>\n</li>\n<li class=\"lvl-3\">\n<p>最后返回左操作数</p>\n</li>\n</ol>\n<pre><code class=\"language-c++\">class Widget&#123;\n    ...\nprivate:\n    Bitmap *pb;\n&#125;;\n//!!!这个不安全\nWidget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\n&#125;\n</code></pre>\n<p>如果自我赋值，即rhs和pb指向同一个对象，那么<code>delete pb</code>后，这个对象就已经被销毁了，下面使用的<code>*rhs</code>就是一个已经被删除的对象</p>\n<p>解决方法1：延后delete</p>\n<pre><code class=\"language-c++\">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    Bitmap* pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\n    delete pOrig;\n    return *this;\n&#125;\n</code></pre>\n<p>解决方法2：使用copy and swap技术</p>\n<pre><code class=\"language-c++\">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    Widget temp(rhs);\n    swap(temp);\t\t//令*this与temp交换\n    return *this;\n&#125;\n</code></pre>\n<h3 id=\"复制对象的一切\">复制对象的一切</h3>\n<p>如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错</p>\n<p>派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）</p>\n<p>所以copy函数需要</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>复制所有local变量</p>\n</li>\n<li class=\"lvl-2\">\n<p>调用所有基类中的适当的copy函数</p>\n</li>\n</ul>\n<h2 id=\"三：资源管理\">三：资源管理</h2>\n<h3 id=\"让对象管理资源\">让对象管理资源</h3>\n<p>将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>申请资源后立即将其放进对象中，<strong>资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>在对象的析构函数中释放资源</p>\n</li>\n</ul>\n<p>C++的<code>auto_ptr</code>是一个<strong>类指针（pointer-like）对象</strong>，也就是<strong>智能指针</strong>，其析构函数会自动delete掉其所指向的对象</p>\n<p>注意：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不要让多个<code>auto_ptr</code>指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>auto_ptr</code>如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权</p>\n</li>\n</ul>\n<p>**RCSP（引用计数型智能指针）**也是一种智能指针（比如<code>tr1::shared_ptr</code>），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源</p>\n<h3 id=\"小心copy行为\">小心copy行为</h3>\n<p>大多数RAII对象的copy函数：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>禁止复制</p>\n</li>\n<li class=\"lvl-2\">\n<p>采用引用计数法（RCSP）</p>\n</li>\n<li class=\"lvl-2\">\n<p>复制底部资源（深拷贝）</p>\n</li>\n<li class=\"lvl-2\">\n<p>转移底层资源所有权（auto_ptr）</p>\n</li>\n</ul>\n<h3 id=\"在资源管理类中提供对原始资源的访问\">在资源管理类中提供对原始资源的访问</h3>\n<p>有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）</p>\n<h3 id=\"new与delete一个数组\">new与delete一个数组</h3>\n<p>一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果new了一个数组，就delete一个数组</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">string* ptr1 = new string[100];\ndelete [] ptr1;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果new了一个对象，就delete一个对象</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">string* ptr2 = new string;\ndelete ptr2;\n</code></pre>\n<p>很多时候很难确定当前这个对象是数组还是一个对象</p>\n<pre><code class=\"language-c++\">typedef string AddressLines[4];\nstring* pal = new AddressLines;\ndelete [] pal;\n</code></pre>\n<p>最简单的方法是不用数组，使用STL里的容器，如<code>vector&lt;string&gt;</code></p>\n<h3 id=\"以独立语句将newed对象置入智能指针\">以独立语句将newed对象置入智能指针</h3>\n<p>C++中调用一个函数，会先计算每一个传递进去的实参</p>\n<p>如果按下面的写法，将newed对象置入智能指针中</p>\n<pre><code class=\"language-c++\">分配函数(shared_ptr&lt;Widget&gt;(new Widget), 资源访问);\t\t//不要这样写\n</code></pre>\n<p>需要执行一下函数</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>调用“资源访问”函数（A）</p>\n</li>\n<li class=\"lvl-2\">\n<p>执行<code>new Widget</code>（B）</p>\n</li>\n<li class=\"lvl-2\">\n<p>调用<code>shared_ptr</code>构造函数（C）</p>\n</li>\n</ul>\n<p>然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）</p>\n<p>如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏</p>\n<p>所以简单的方法是分离语句</p>\n<pre><code class=\"language-c++\">shared_ptr&lt;Widget&gt; pw(new Widget);\n分配函数(pw, 资源访问);\n</code></pre>\n<h2 id=\"四：设计与声明\">四：设计与声明</h2>\n<h3 id=\"让接口容易被正确使用\">让接口容易被正确使用</h3>\n<p>客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）</p>\n<h4 id=\"限制参数传递\">限制参数传递</h4>\n<p>这是一个日期类</p>\n<pre><code class=\"language-c++\">class Date&#123;\npublic:\n  Date(int month, int day, int year);\n  ...\n&#125;;\n...\nDate d(4, 20, 2022);\n</code></pre>\n<p>客户很有可能填错顺序，也有可能填入一个无效的参数</p>\n<p>可以使用<strong>外覆类型（wrapper types）</strong>，当然做出类会更好</p>\n<pre><code class=\"language-c++\">struct Day&#123;\n  explict Day(int d) : val(d) &#123;&#125;\n  int val;\n&#125;;\nstruct Month&#123;\n  explict Month(int m) : val(m) &#123;&#125;\n  int val;\n&#125;;\nstruct Year&#123;\n  explict Year(int y) : val(y) &#123;&#125;\n  int val;\n&#125;;\nclass Date&#123;\npublic:\n  Date(const Mouth&amp; month, const Day&amp; day, const Year&amp; year);\n  ...\n&#125;;\n...\nDate d(Month(4), Day(20), Year(2022));\n</code></pre>\n<h4 id=\"一致性\">一致性</h4>\n<p>自定义的行为要与内置类型的行为一致，比如你不能把<code>operator*</code>重载成<code>operator+</code></p>\n<p>或则像STL中，容器的接口都很一致，比如<code>size</code>、<code>push_back</code>等等</p>\n<h3 id=\"设计class犹如设计type\">设计class犹如设计type</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对象要如何创建和销毁</p>\n</li>\n<li class=\"lvl-2\">\n<p>对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）</p>\n</li>\n<li class=\"lvl-2\">\n<p>对象如果被值传递，意味着什么（深浅拷贝）</p>\n</li>\n<li class=\"lvl-2\">\n<p>约束成员变量的合法值</p>\n</li>\n<li class=\"lvl-2\">\n<p>是否可以/需要被继承</p>\n</li>\n<li class=\"lvl-2\">\n<p>能否类型转换，如何类型转换</p>\n</li>\n<li class=\"lvl-2\">\n<p>支持何种操作符</p>\n</li>\n<li class=\"lvl-2\">\n<p>成员变量的访问修饰</p>\n</li>\n<li class=\"lvl-2\">\n<p>成员函数的访问修饰</p>\n</li>\n<li class=\"lvl-2\">\n<p>未声明接口（undecided interface）</p>\n</li>\n<li class=\"lvl-2\">\n<p>是否需要定义模版</p>\n</li>\n<li class=\"lvl-2\">\n<p>真的需要一个新类吗？</p>\n</li>\n</ul>\n<h3 id=\"多用引用传递\">多用引用传递</h3>\n<p>C++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些<strong>很大的自定义类型</strong>来说性能非常糟糕</p>\n<p>使用const引用传递会好很多</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不会创建新的对象</p>\n</li>\n<li class=\"lvl-2\">\n<p>不会改变原有对象</p>\n</li>\n<li class=\"lvl-2\">\n<p>可以避免<strong>对象切割</strong>问题</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了</li>\n</ul>\n</li>\n</ul>\n<p>只不过引用传递是大多是通过指针实现的，在处理一些<strong>简单的内置类型</strong>时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递</p>\n<h3 id=\"必须返回对象时，不要返回引用\">必须返回对象时，不要返回引用</h3>\n<p>如果必须返回对象，请不要返回引用（比如<code>operator*</code>，<code>operator==</code>），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个<strong>右值</strong>的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用</p>\n<h3 id=\"将成员变量隐藏\">将成员变量隐藏</h3>\n<p>成员变量应该为private，而不是public</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）</p>\n</li>\n<li class=\"lvl-2\">\n<p>分离读写权限（这一点C#做的更好？）</p>\n</li>\n<li class=\"lvl-2\">\n<p>封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）</p>\n</li>\n<li class=\"lvl-2\">\n<p>便于对成员变量进行约束（更不容易出现异常值）</p>\n</li>\n<li class=\"lvl-2\">\n<p>protected并不比public更具有封装性</p>\n</li>\n</ul>\n<h3 id=\"使用非成员函数\">使用非成员函数</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>C#，java选手可以略过</p>\n</li>\n<li class=\"lvl-2\">\n<p>C++标准库就是这样写的</p>\n</li>\n</ul>\n<p>这里有一个类，其中有多个成员函数</p>\n<pre><code class=\"language-c++\">class WebBrowser&#123;\npublic:\n\tvoid doA();\n  void doB();\n  void doC();\n  ...\n&#125;;\n</code></pre>\n<p>现在需要令一个函数做ABC三件事，有两种写法</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>成员函数</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class WebBrowser&#123;\npublic:\n\t...\n  void doEverything()&#123;\n    doA();\n    doB();\n    doC();\n  &#125;\n  ...\n&#125;;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>非成员函数</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">void doEverything(WebBrowser&amp; wb)&#123;\n\twb.doA();\n  wb.doB();\n  wb.doC();\n&#125;\n</code></pre>\n<p>令人意外的是，第二种方法（使用非成员函数）更好</p>\n<h4 id=\"什么是封装\">什么是封装</h4>\n<p>一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强</p>\n<p>为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物</p>\n<h4 id=\"为什么第二种比第一种封装性更强\">为什么第二种比第一种封装性更强</h4>\n<p>因为第一种给用户两种调用方法，一个是调用成员函数<code>doEverything()</code>，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>注意第一种方法中，<code>doEverything()</code>和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利</p>\n</li>\n</ul>\n<p>那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的<strong>静态成员（static member）函数</strong>即可</p>\n<p>或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）</p>\n<pre><code class=\"language-c++\">namespace WebBrowserStuff&#123;\n\tclass WebBrowser&#123;...&#125;;\n\tvoid doEverything(WebBrowser&amp; wb)&#123;...&#125;\n&#125;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可拓展性更强</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>可拆分</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如果所有参数都需要进行类型转换，使用非成员函数\">如果所有参数都需要进行类型转换，使用非成员函数</h3>\n<p>令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时</p>\n<p>比如一个有理数乘法</p>\n<pre><code class=\"language-c++\">class Rational&#123;\npublic:\n  //这个类没有自定义的explict构造函数\n  const Rational opertaor* (const Rational&amp; rhs) const;\n  ...\n&#125;;\n</code></pre>\n<pre><code class=\"language-c++\">Rational oneEighth(1,8);\nRational oneHalf(1,2);\nRational result = oneHalf * oneEighth;\t//成功\nresult = result * oneEighth;\t//成功\nresult = oneHalf * 2;\t\t//成功，等价于 result = oneHalf.operator*(2)\nresult = 2 * oneHalf;\t\t//失败，等价于 result = 2.operator*(oneHalf)\n</code></pre>\n<p><code>result = oneHalf * 2;</code>为什么成功，因为这里发生了一次隐式转换，将<code>2</code>转化为了一个<code>Rational</code>类型</p>\n<p>在编译器中可能等价于</p>\n<pre><code class=\"language-c++\">const Rational temp(2);\nresult = oneHalf * temp;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将<code>2</code>转化为一个<code>Rational</code>类型</p>\n</li>\n</ul>\n<p><code>result = 2 * oneHalf;\t</code>为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时<code>2</code>就是一个int类型，没有我们所自定义的<code>operator*</code>函数，自然会失败</p>\n<p>可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）</p>\n<pre><code class=\"language-c++\">const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123;\n  return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());\n&#125;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>此外要极力避免使用<strong>友元（friend）函数</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数</p>\n</li>\n</ul>\n<h3 id=\"写一个不抛异常的swap函数\">写一个不抛异常的swap函数</h3>\n<p>swap函数原本是STL的一部分，后来称为了<strong>异常安全性编程</strong>的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要</p>\n<p>std是一个很特殊的命名空间，客户可以<strong>全特化</strong>（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定</p>\n<p>全特化：针对某个类做模板函数的特例，如对<code>std::swap</code>做一个针对<code>Widget</code>的特化</p>\n<pre><code class=\"language-c++\">class WidgetImpl&#123;...&#125;;\t\t//这个类的对象中存储着真正的数据\nclass Widget&#123;\npublic:\n    Widget&amp; operator=(const Widget&amp; rhs)&#123;\n        ...\n        *pImpl = *(rhs.pImpl);\n        ...\n    &#125;\n    ...\n    void swap(Widget&amp; other)&#123;\t//这个函数决对不可抛异常\n        using std::swap;\n        swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针\n    &#125;\n    ...\nprivate:\n    WidgetImple* pImpl;\t\t//这个类有一个指向资源对象的指针\n&#125;;\nnamespace std&#123;\n\ttemplate&lt;&gt;\n    void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;\t//这个可以抛异常\n        a.swap(b);\t\n    &#125;\n&#125;\n</code></pre>\n<p>此外，C++的STL容器就是上面这种写法，提供了<code>public swap</code>成员函数和<code>std::swap</code>的特化版本</p>\n<h2 id=\"五：实现（Implementations）\">五：实现（Implementations）</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>随意定义变量可能会导致性能降低</p>\n</li>\n<li class=\"lvl-2\">\n<p>过度使用转型（casts）可能会导致性能降低，难以维护，可读性低</p>\n</li>\n<li class=\"lvl-2\">\n<p>返回对象的内部数据的handles，可能会破坏封装</p>\n</li>\n<li class=\"lvl-2\">\n<p>未考虑异常可能会导致资源泄露和数据败坏</p>\n</li>\n<li class=\"lvl-2\">\n<p>过度使用inline可能会导致包体膨胀</p>\n</li>\n<li class=\"lvl-2\">\n<p>过度耦合（coupling）可能会增加构建时间（build times）</p>\n</li>\n</ul>\n<h3 id=\"尽量延后变量定义式的出现时间\">尽量延后变量定义式的出现时间</h3>\n<h4 id=\"避免未曾使用的变量\">避免未曾使用的变量</h4>\n<p>如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过</p>\n<p>此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、</p>\n<h4 id=\"避免无意义的默认构造函数\">避免无意义的默认构造函数</h4>\n<p>如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好</p>\n<h4 id=\"循环\">循环</h4>\n<p>此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？</p>\n<p><strong>循环内</strong></p>\n<pre><code class=\"language-c++\">for(int i = 0; i &lt; n; i++)&#123;\n  Widget w(...);\n  ...\n&#125;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>n个构造函数+n个析构函数</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果<code>Widget</code>是一个很敏感的类，这样会让其作用域更小，更容易理解和维护</p>\n</li>\n</ul>\n<p><strong>循环外</strong></p>\n<pre><code class=\"language-c++\">Widget w;\nfor(int i = 0; i &lt; n; i++)&#123;\n  w = ...;\n  ...\n&#125;\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>一个构造函数+一个析构函数+n个赋值操作</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）</p>\n</li>\n</ul>\n<h3 id=\"少做转型\">少做转型</h3>\n<p>C++是强类型语言，设计目标应该是保证类型错误绝不发生，然而<strong>类型转换</strong>破坏了类型系统</p>\n<p>Java、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险</p>\n<p>C++的类型转化</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>旧式转换</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\"><code>(T)expression</code></li>\n<li class=\"lvl-4\"><code>T(expression)</code></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>新式转换</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\"><code>const_cast&lt;T&gt;(expression)</code>\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">用于将对象的<strong>常量性转除（cast away the constness）</strong></li>\n<li class=\"lvl-6\">比如将<code>const</code>转化为<code>non-const</code></li>\n</ul>\n</li>\n<li class=\"lvl-4\"><code>dynamic_cast&lt;T&gt;(expression)</code>\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">用来<strong>安全向下转型</strong></li>\n<li class=\"lvl-6\">无法由旧式语句执行</li>\n<li class=\"lvl-6\">耗费巨大</li>\n</ul>\n</li>\n<li class=\"lvl-4\"><code>reinterpret_cast&lt;T&gt;(expression)</code>\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">用于低级转型，实际操作取决于编译器，不可移植</li>\n<li class=\"lvl-6\">极其少用</li>\n</ul>\n</li>\n<li class=\"lvl-4\"><code>static_cast&lt;T&gt;(expression)</code>\n<ul class=\"lvl-4\">\n<li class=\"lvl-6\">用于<strong>强迫隐式转换（implicit conversions）</strong></li>\n<li class=\"lvl-6\">比如<code>non-const</code>转化为<code>const</code>，<code>int</code>转化为<code>double</code>，<code>void*</code>转化为<code>typed</code>，基类指针转化为派生类指针</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>避免C++类型转换出问题的核心是<strong>避免使用基类的接口处理派生类</strong></p>\n<h4 id=\"一个对象多个地址\">一个对象多个地址</h4>\n<p>C++很神奇，如果一个基类指针指向一个派生类对象，如</p>\n<pre><code class=\"language-C++\">Dervied d;\nBase* b = &amp;d;\n</code></pre>\n<p>这可能会导致两个指针值不一样，即这个对象有两个地址，一个<code>Derivied*</code>指针一个<code>Base*</code>指针，这派生类指针上往往会有一个<strong>偏移量（offset）</strong>，通过这个偏移量，可以通过派生类指针找到基类指针</p>\n<p>上面这种事在Java、C#、C中绝对不会发生，但是C<ins>可以多继承，很容易出现这种情况（单继承时也会出现），所以**请不要假定对象在C</ins>中如何布局**，更不应该基于这个假设对对象进行类型转换</p>\n<p>如果你想让当前对象调用基类的函数，如果对<code>*this</code>做强制转化，转换为基类，<code>*this</code>其实是先前产生的<code>*this</code>对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题</p>\n<pre><code class=\"language-c++\">class SpecialWindow: public Window&#123;\npublic:\n  virtual void onResize()&#123;\n    //static_cast&lt;Window&gt;(*this).onResize();\t//这样不好\n    Window::onResize();\t\t//请用这种方式调用基类的onResize函数（作用到当前对象上）\n    ...\n  &#125;\n&#125;\n</code></pre>\n<h4 id=\"dynamic-cast\">dynamic_cast</h4>\n<p>这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象</p>\n<p>什么时候使用这个东西？当<strong>你想在</strong>一个你认为是派生类对象的<strong>对象上执行</strong>派生类的操作<strong>函数</strong>，但你手里却只有一个指向基类的引用/指针时</p>\n<p>解决方法：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器</p>\n</li>\n<li class=\"lvl-2\">\n<p>在基类中提供virtual函数</p>\n</li>\n</ul>\n<h3 id=\"避免返回指向对象内部成分的handles\">避免返回指向对象内部成分的handles</h3>\n<p>前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便</p>\n<p>但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的</p>\n<pre><code class=\"language-c++\">class Point&#123;\npublic:\n  ...\n  void setX(int val);\n  ...\n&#125;;\nstruct RectData&#123;\n  Point ulhc;\t\t//upper left hand corner\n  Point lrhc;\t\t//lower right hand corner\n&#125;;\nclass Rectangle&#123;\npublic:\n  ...\n  Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;\t//这样返回了引用，非常不好\n  ...\nprivate:\n  std::tr1::shared_ptr&lt;RectData&gt; pData;\n&#125;;\n...\nrec.upperLeft().setX(50);\t\t//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改\n</code></pre>\n<p><code>upperLeft</code>函数本来只是为了提供给客户获得（get）<code>Rectangle</code>的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了<code>Rectangle</code>本身，而且还是一个内部数据<code>RectData</code></p>\n<p>为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）</p>\n<p>解决方法很简单，只要让handles不可以被修改，就可以了</p>\n<pre><code class=\"language-c++\">class Rectangle&#123;\npublic:\n  ...\n  const Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;\t\n  ...\n&#125;;\n</code></pre>\n<p>但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致<strong>dangling handles（空悬的号码牌）</strong>，比如返回了一个对local变量的引用，依然特别危险</p>\n<p>当然，有的时候不得不返回handles，比如<code>operator[]</code></p>\n<h3 id=\"异常安全性很重要\">异常安全性很重要</h3>\n<p>**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不泄漏任何资源</p>\n</li>\n<li class=\"lvl-2\">\n<p>不允许数据败坏</p>\n</li>\n</ul>\n<p>不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂</p>\n<p>三个保证：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏</p>\n</li>\n<li class=\"lvl-2\">\n<p>强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过<code>copy-and-swap</code>实现）</p>\n</li>\n<li class=\"lvl-2\">\n<p>不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）</p>\n</li>\n</ul>\n<p><strong>异常安全码</strong>必须提供上述三种保障之一，如果不能保障，则不具备异常安全性</p>\n<h3 id=\"了解inline函数\">了解inline函数</h3>\n<p>内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化</p>\n<p>缺点也很明显，会让包体变大，会导致<strong>换页行为（paging）</strong>，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数</p>\n<p>内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联</p>\n<h3 id=\"降低文件间的编译依存\">降低文件间的编译依存</h3>\n<p>如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译</p>\n<p>为什么C<ins>要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C</ins>为什么需要先定义，后使用）</p>\n<p>这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类</p>\n<p><em>话说应该不会有人不知道implementation是实现的意思吧</em></p>\n<pre><code class=\"language-c++\">class PersonImpl;\t//pimpl写法，这是Person类的前置声明\nclass Data;\t\t\t\t//Data的前置声明\nclass Address;\t\t//Address的前置声明\n\nclass Persion&#123;\t//像这样使用pimpl的类，往往被称为Handle classes\npublic:\n  ...\n  std::string name() const;\n  ...\nprivate:\n  std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;\n&#125;;\n</code></pre>\n<p>在这种设计下，<code>Person</code>就与<code>Data</code>、<code>Address</code>以及<code>Persons</code>的实现分离了，改动这些类也不会导致使用<code>Person</code>的客户重新编译，客户无法看到<code>Person</code>的实现细节，真正实现<strong>接口与实现分离</strong></p>\n<p>这个操作的本质是用<strong>声明的依赖性</strong>替换<strong>定义的依赖性</strong></p>\n<p>此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明</p>\n<p>此外还有另一种制作<code>Handle class</code>的方法，就是令<code>Person</code>成为一个特殊的抽象基类，称为<code>Interface class</code>，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）</p>\n<pre><code class=\"language-c++\">class Person&#123;\t\t//Interface class\npublic:\n  virtual ~Person();\n  virtual std::string name() const = 0;\n  ...\n&#125;;\nclass Person&#123;\t\t//具现化\npublic:\n  static std::tr1::shared_ptr&lt;Person&gt; create(const std::string&amp; name...);\n  ...\n&#125;;\n...\n//使用\nstd::tr1::shared_ptr&lt;Person&gt; pp(Person::create(name...));\nstd::cout &lt;&lt; pp-&gt;name();\n</code></pre>\n<pre><code class=\"language-c++\">class RealPerson: public Person&#123;\t\npublic:\n  RealPerson(const std::string&amp; name, ...): theName(name), ...&#123;&#125;\n  virtual ~RealPerson() &#123;&#125;\n  std::string name() const;\t\t\n  ...\nprivate:\n\tstd::string theName;\n&#125;;\nstd::string ReakPerson::name()&#123;...&#125;\nstd::tr1::shared_ptr&lt;Person&gt; Person::create(const std::string&amp; name, ...)&#123;\n  retrun std::tr1::shared_ptr&lt;Person&gt;(new RealPerson(name, ...));\n&#125;\n</code></pre>\n<h2 id=\"六：继承与面向对象\">六：继承与面向对象</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>is-a</code>：是一个</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>has-a</code>：有一个</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>is-implemented-in-terms-of</code>：根据xx实现出</p>\n</li>\n</ul>\n<h3 id=\"public继承是is-a关系\">public继承是is-a关系</h3>\n<pre><code class=\"language-c++\">class Student: public Person&#123;...&#125;;\t//Student is a Person\n</code></pre>\n<p>每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化</p>\n<p><strong>public继承下，可以把子类当父类用</strong>，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用</p>\n<p>这就出现了一个问题，子类一定要<code>is a</code>父类，不然会出现问题</p>\n<p>错误的继承：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？</p>\n</li>\n<li class=\"lvl-2\">\n<p>正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？</p>\n</li>\n</ul>\n<h3 id=\"避免遮掩父类成员\">避免遮掩父类成员</h3>\n<pre><code class=\"language-c++\">int x;\nvoid Fun()&#123;\n    double x;\n    ...\n&#125;\n</code></pre>\n<p>由于<strong>作用域</strong>的<strong>名称遮掩规则</strong>，函数内部的local变量x覆盖了全局变量x</p>\n<h4 id=\"子类名称会遮掩父类名称，在public继承下是错误的\">子类名称会遮掩父类名称，在public继承下是错误的</h4>\n<p>在OOP中，如果子类重载了父类的<code>non-virtual</code>函数，就意味着子类使用同名函数遮掩了父类函数，就意味着<strong>这个父类函数没有被子类继承！</strong>，那么在这种情况下，继承就不是<code>is-a</code>关系了</p>\n<p><strong>在public继承下，子类继承了父类的一切</strong></p>\n<pre><code class=\"language-c++\">class Base&#123;\npublic:\n    virtual void f1() = 0;\n    virtual void f1(int);\n    void f2();\n    void f2(double);\n    ...\nprivate:\n    int x;\n&#125;;\nclass Derived: public Base&#123;\npublic:\n    virtual void f1();\n    void f2();\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)\n</code></pre>\n<h4 id=\"将被遮掩的名称重见天日\">将被遮掩的名称重见天日</h4>\n<p>解决起来很简单，只需要让父类的函数在子类作用域内可见，可以<strong>使用using关键字</strong></p>\n<pre><code class=\"language-c++\">class Derived: public Base&#123;\npublic:\n    using Base::f1;\n    using Base::f2;\n    virtual void f1();\n    void f2();\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//正确，调用Base::f1\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//正确，调用Base::f2\n</code></pre>\n<p>如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以<strong>使用转交函数</strong>，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中</p>\n<pre><code class=\"language-c++\">class Derived: private Base&#123;\npublic:\n    virtual void f1()&#123;\n        Base::f1();\t\t//inline转交函数\n    &#125;\n    ...\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1\n</code></pre>\n<h3 id=\"区分接口继承和实现继承\">区分接口继承和实现继承</h3>\n<p>public继承分为两个部分</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>函数接口继承</p>\n</li>\n<li class=\"lvl-2\">\n<p>函数实现继承</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>接口继承</th>\n<th>实现继承</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>纯虚函数</td>\n<td>具体指定</td>\n<td>不继承</td>\n</tr>\n<tr>\n<td>非纯虚函数</td>\n<td>具体指定</td>\n<td>继承一份缺省实现</td>\n</tr>\n<tr>\n<td>non-virtual函数</td>\n<td>具体指定</td>\n<td>继承一份强制实现</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"考虑使用virtual以外的选择\">考虑使用virtual以外的选择</h3>\n<h4 id=\"基于NVI的Template-Method模式\">基于NVI的Template Method模式</h4>\n<p>Non-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数</p>\n<pre><code class=\"language-c++\">class GameCharacter&#123;\npublic：\n    int healthValue() const\n\t&#123;\n    \t...\n    \tint retVal = doHealthValue();\n    \t...\n    \treturn retVal;\n\t&#125;\nprivate：\n    virtual int doHealthValue() const\n    &#123;\n\t\t...\n    &#125;\n&#125;;\n</code></pre>\n<p>其中<code>healthValue()</code>被称为virtual函数的<strong>外覆器（wrapper）</strong></p>\n<h4 id=\"基于函数指针的Strategy模式\">基于函数指针的Strategy模式</h4>\n<pre><code class=\"language-c++\">class GameCharacter;\nint defaultHealthCalc(const GameCharacter&amp; gc);\nclass GameCharacter&#123;\npublic:\n    typedef int (*HealthCalcFunc)(const GameCharacter&amp;);\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125;\n    int healthValue() const &#123; return healthFunc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n&#125;;\n</code></pre>\n<p>在这种模式下，<code>defaultHealthCalc</code>函数不再是<code>GameCharacter</code>体系内的成员函数，通过修改函数指针，就可以让<code>GameCharacter</code>使用不同种类的计算函数，弹性更强，而且可以在运行时变更</p>\n<p>此外<code>defaultHealthCalc</code>函数不需要/不能访问<code>GameCharacter</code>内的<code>non-public</code>部分，</p>\n<h4 id=\"基于tr1-function的Strategy模式\">基于tr1::function的Strategy模式</h4>\n<p>上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如<code>tr1::function</code>对象</p>\n<pre><code class=\"language-c++\">class GameCharacter;\nint defaultHealthCalc(const GameCharacter&amp; gc);\nclass GameCharacter&#123;\npublic:\n    typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125;\n    int healthValue() const &#123; return healthFunc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n&#125;;\n</code></pre>\n<h4 id=\"古典的Strategy模式\">古典的Strategy模式</h4>\n<pre><code class=\"language-c++\">class GameCharacter;\nclass HealthCalcFunc&#123;\npublic:\n    ...\n    virtual int calc(const GameCharacter&amp; gc) const&#123;...&#125;\n    ...\n&#125;;\nHealthCalcFunc defaultHealthCalc;\nclass GameCharacter&#123;\npublic:\n    explicit GameCharacter(HealthCalcFunc* phcf = &amp;defaultHealthCalc): pHealthFunc(phcf)&#123;&#125;\n    int healthValue() const &#123; return phealthFunc-&gt;calc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc* pHealthFunc;\n&#125;;\n</code></pre>\n<h3 id=\"绝不重新定义继承而来的non-virtual函数\">绝不重新定义继承而来的non-virtual函数</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>静态绑定（staticcally bound）：non-virtual就是这种</p>\n</li>\n<li class=\"lvl-2\">\n<p>动态绑定（dynamically bound）：virtual就是这种</p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class B&#123;\npublic:\n\tvoid f();\n\t...\n&#125;;\nclass D: public B&#123;\npublic:\n  void f();\n  ...\n&#125;;\n...\nD x;\nB* pB = &amp;x;\nD* pD = &amp;x;\npB-&gt;f();\t//调用B::f\npD-&gt;f();\t//调用D::f\n</code></pre>\n<h3 id=\"绝对不重新定义继承而来的缺省参数值\">绝对不重新定义继承而来的缺省参数值</h3>\n<p><strong>virtual函数是动态绑定的，缺省参数值是静态绑定的</strong></p>\n<pre><code class=\"language-c++\">class Cricle: public Shape&#123;...&#125;;\n...\nShape* p1;\t//p1的静态类型是Shape*，没有动态类型\nShape* p2 = new Circle;\t//p2的静态类型是Shape*，动态类型是Circle*\n</code></pre>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>静态类型</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">指针的类型就是<strong>静态类型</strong></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>动态类型</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">所指向的对象的类型是<strong>动态类型</strong></li>\n<li class=\"lvl-4\">动态类型可以通过赋值等操作改变</li>\n</ul>\n</li>\n</ul>\n<p>virtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载</p>\n<p>但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数</p>\n<h3 id=\"has-a和根据xx实现出\">has-a和根据xx实现出</h3>\n<p>一个类中有多个小类，这种关系被称为<strong>复合（composition）</strong>，其中这些小类被称为<strong>合成成分物（composed object）</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在应用域，复合意味着<code>has-a</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">人有名字（也不尽然）</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>在实现域，复合意味着<code>is-implemented-in-terms-of</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"少用private继承\">少用private继承</h3>\n<p><em>经典 C++糟粕，请问 C#有这个吗？</em></p>\n<p>本质上是一种<code>is-implemented-in-terms-of</code>关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>private继承，编译器无法自动将子类对象转化为父类对象</p>\n</li>\n<li class=\"lvl-2\">\n<p>private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）</p>\n</li>\n</ul>\n<p><strong>尽量使用复合来替代pirvate继承</strong>，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数</p>\n<p>此外private继承的对象有可能比复合的对象要小</p>\n<h3 id=\"少用多重继承\">少用多重继承</h3>\n<p><em>经典 C++糟粕，请问 C#有这个吗？</em></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>可能会导致歧义</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">当然你可以在调用函数的时候指出是来自哪一个基类</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>可能会导致菱形继承</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">菱形继承可能会导致变量重复</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"七：模版与泛型\">七：模版与泛型</h2>\n<p>模板（templates）是泛型编程（generic programming）的基础</p>\n<p>模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译</p>\n<h3 id=\"评价\">评价</h3>\n<p>优点：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>模板编程能够实现非常灵活且类型安全的接口</p>\n</li>\n<li class=\"lvl-3\">\n<p>极好的性能（更小的文件、更短的运行期，更少的内存需求）</p>\n</li>\n<li class=\"lvl-3\">\n<p>可以将一些运行时才能侦测到的错误，在编译期找出来</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>难以编程和维护</p>\n</li>\n<li class=\"lvl-3\">\n<p>编译报错信息难以理解</p>\n</li>\n<li class=\"lvl-3\">\n<p>难以重构</p>\n</li>\n<li class=\"lvl-3\">\n<p>编译时间大幅变长</p>\n</li>\n</ol>\n<p>因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释</p>\n<h3 id=\"隐式接口和编译期多态\">隐式接口和编译期多态</h3>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>OOP中经常使用显式接口和运行时多态</p>\n</li>\n<li class=\"lvl-2\">\n<p>泛型编程更多使用隐式接口和编译期多态</p>\n</li>\n</ul>\n<pre><code class=\"language-C++\">template&lt;typename T&gt;\nvoid doProcessing(T&amp; w)\n&#123;\n    if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget)&#123;\n        T temp(w)\n        temp.normalize();\n        temp.swap(w);\n    &#125;\n&#125;\n</code></pre>\n<p>从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组<strong>隐式接口</strong></p>\n<p>所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功</p>\n<p>这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是<strong>编译期多态</strong></p>\n<h3 id=\"Traits\">Traits</h3>\n<p>一种约定俗成的技术方案，为同一类数据提供统一的操作函数</p>\n<p>比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。</p>\n<pre><code class=\"language-C++\">enum Type&#123;\n    TYPE_1;\n    TYPE_2;\n&#125;;\nclass FOO&#123;\n    Type type = Type::TYPE_1;\n&#125;;\nclass Bar&#123;\n    Type type = Type::TYPE_2;\n&#125;;\n//统一的模板函数\ntemplate&lt;typename T&gt;\nvoid decode(const T&amp; data, char* buf)&#123;\n    if(T::type == Type::TYPE_1)&#123;\n        ...\n    &#125;\n    else if(T::type == Type::TYPE_2)&#123;\n        ...\n    &#125;\n&#125;\n</code></pre>\n<p>但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术</p>\n<pre><code class=\"language-C++\">enum Type&#123;\n    TYPE_1;\n    TYPE_2;\n&#125;;\nclass FOO&#123;\n    Type type = Type::TYPE_1;\n&#125;;\nclass Bar&#123;\n    Type type = Type::TYPE_2;\n&#125;;\n\ntemplate&lt;typename T&gt;\nstruct type_traits&#123;\n    Type type = T::type;\n&#125;\n//为内置数据类型特化为独有的 type_traits\ntemplate&lt;typename int&gt;\nstruct type_traits&#123;\n    Type type = Type::TYPE_1;\n&#125;\n//统一的模板函数\ntemplate&lt;typename T&gt;\nvoid decode(const T&amp; data, char* buf)&#123;\n    if(type_traits&lt;T&gt;::type == Type::TYPE_1)&#123;\n        ...\n    &#125;\n    else if(type_traits&lt;T&gt;::type == Type::TYPE_2)&#123;\n        ...\n    &#125;\n&#125;\n</code></pre>\n<p>该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因</p>\n<h3 id=\"模板元编程\">模板元编程</h3>\n<p>TMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化</p>\n<p>如果一门语言具备以下功能，则称为图灵完全</p>\n<ol>\n<li class=\"lvl-3\">\n<p>数值运算和符号运算</p>\n</li>\n<li class=\"lvl-3\">\n<p>判断</p>\n</li>\n<li class=\"lvl-3\">\n<p>递归</p>\n</li>\n</ol>\n<h4 id=\"数值运算-递归\">数值运算+递归</h4>\n<pre><code class=\"language-C++\">//一个TMP计算阶乘，而且阶乘的技术发生在编译期\ntemplate&lt;unsigned n&gt;\nstruct Factorial\n&#123;\n    enum &#123; value = n * Factorial&lt;n-1&gt;::value &#125;;\n&#125;;\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt;\n&#123;\n    enum &#123; value = 1 &#125;;\n&#125;;\n\nint main()\n&#123;\n    std::cout &lt;&lt; Factorial&lt;5&gt;::value;\n&#125;\n</code></pre>\n<p>C++11TMP这种函数式编程得到了加强，上文也可以这样写</p>\n<pre><code class=\"language-C++\">template&lt;unsigned n&gt;\nstruct Factorial\n&#123;\n    constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;;\n&#125;;\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt;\n&#123;\n    constexpr static auto value = 1;\n&#125;;\n</code></pre>\n<h4 id=\"判断\">判断</h4>\n<pre><code class=\"language-C++\">template&lt;bool Value&gt;\nstruct if_constexpr\n&#123;\n    constexpr static auto value = 1;\n&#125;;\n\ntemplate&lt;&gt;\nstruct if_constexpr&lt;false&gt; &#123;\n    constexpr static auto value = 2;\n&#125;;\n\nint main()\n&#123;\n    std::cout &lt;&lt; if_constexpr&lt;true&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; if_constexpr&lt;false&gt;::value &lt;&lt; std::endl;\n&#125;\n</code></pre>\n<h3 id=\"typedef\">typedef</h3>\n<p>在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名</p>\n<p>下面是一个函数指针的示例</p>\n<pre><code class=\"language-C++\">void add(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; x + y &lt;&lt; std::endl;\n&#125;\nvoid dec(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x-y=&quot; &lt;&lt; x - y &lt;&lt; std::endl;\n&#125;\nvoid mul(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x*y=&quot; &lt;&lt; x*y &lt;&lt; std::endl;\n&#125;\n\nvoid (*op[3])(int, int) = &#123; add, dec, mul &#125;;\n\nint main()\n&#123;\n    for (int i = 0; i &lt; 3; ++i) &#123;\n        （*op[i])(4, 3);\n    &#125;\n&#125;\n</code></pre>\n<p>如果使用typedef</p>\n<pre><code class=\"language-C++\">typedef void (*Func[3])(int, int);\nFunc f = &#123; add, dec, mul &#125;;\n\nint main()\n&#123;\n    for (int i = 0; i &lt; 3; ++i) &#123;\n        f[i](4, 3);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"八：定制new和delete\">八：定制new和delete</h2>\n<p>Java和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目</p>\n<h3 id=\"new-handler\">new-handler</h3>\n<p>当<code>operator new</code>无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即<code>new-handler</code></p>\n<p>使用<code>set_new_handler</code>来指定<code>new-handler</code></p>\n<pre><code class=\"language-c++\">void outOfMem()&#123;\n  std::cerr &lt;&lt; &quot;内存不足\\n&quot;;\n  std::abort();\n&#125;\nint main()&#123;\n  std::set_new_handler(outOfMem);\t\t//该函数的参数是一个函数指针\n  int* array = new int[10000000L];\n  ...\n&#125;\n</code></pre>\n<p>当<code>operator new</code>无法满足内存申请时，会不断调用<code>new-handler</code>函数，直到找到足够的内存，所以<code>new-handler</code>函数应该满足</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>让更多的内存可被使用</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">实现方法是程序开始时就分配一大块内存，每次调用<code>new-handler</code>时就释放一点点</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>安装另一个<code>new-handler</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">如果现在这个<code>new-handler</code>无法获取更多内存，需要知道哪一个<code>new-handler</code>具备增大内存的实力，然后使用<code>set_new_handler</code>来替换自己</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>卸除<code>new-handler</code></p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">通过<code>set_new_handler</code>赋值<code>null</code>，将<code>new-handler</code>卸载，使得在内存分配不足时，会抛异常</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>抛出<code>bad_alloc</code>异常</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">这种异常不会被<code>operator new</code>捕获，会被传播至内存索求处</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>不反回</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">调用<code>abort</code>或者<code>exit</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class NewHandlerHolder&#123;\npublic:\n  explicit NewHandlerHolder(std::new_handler nh): handler(nh) &#123;&#125;\t//获取当前的new_handler\n  ~NewHandlerHolder() &#123; std::set_new_handler(handler); &#125;\t\nprivate:\n  std::new_handler handler;\t\t//用于记录当前的new_handler\n&#125;;\nvoid* Widget::operator new(std::size_t size) throw(std::bad_alloc)&#123;\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\t//安装Widget的new-handler\n  return ::operator new(size);\t//分配对象或者抛异常\n&#125;\n//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值\n</code></pre>\n<pre><code class=\"language-c++\">void outOfMem();\nWidget::set_new_handler(outOfMem);\nWidget* pwl = new Widget;\t//内存不足时会调用outOfMem\n</code></pre>\n<p>mixin风格的写法</p>\n<pre><code class=\"language-c++\">template&lt;typename T&gt;\nclass NewHandlerSupport&#123;\npublic:\n  static std::new_handler_set set_new_handler(std::new_handler p) throw();\n  static void* operator new(std::size_t size) throw(std::bad_alloc);\n  ...\nprivate:\n  static std::new_handler currentHandler;\n&#125;;\n\ntemplate&lt;typename T&gt;\nstd::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()&#123;\n  std::new_handler oldHandler = currentHandler;\n  currentHandler = p;\n  return oldHandler;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) throw(std::bad_alloc)&#123;\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\n  return ::operator new(size);\n&#125;\n</code></pre>\n<pre><code class=\"language-c++\">class Widget: public NewHandlerSupport&lt;Widget&gt;&#123;\n\t...\n&#125;;\n</code></pre>\n<p>像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为<strong>怪异的循环模版模式（curiously recurring template pattern，CRTP）</strong></p>\n<h3 id=\"替换new和delete的时机\">替换new和delete的时机</h3>\n<p>C++中所有的news返回的指针都必须要<strong>地址对齐</strong>，int要4对齐，double要8对齐</p>\n<p>写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换</p>\n<h3 id=\"编写new和delete的规则\">编写new和delete的规则</h3>\n<p>如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>new</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用<code>new-handler</code></li>\n<li class=\"lvl-4\">有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）</li>\n<li class=\"lvl-4\">new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理<strong>比正确大小更大的（错误）申请</strong></li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>delete</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-4\">收到null指针时不做任何事</li>\n<li class=\"lvl-4\">处理<strong>比正确大小更大的（错误）申请</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"编写new时也要写对应的delete\">编写new时也要写对应的delete</h3>\n<pre><code class=\"language-c++\">Widget* pw = new Widget;\n</code></pre>\n<p>在这里调用了两个函数，一个时用以分配内存的<code>operator new</code>，一个是<code>Widget</code>的构造函数</p>\n<p>如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的</p>\n<p>运行时系统会调用<code>operator new</code>所对应的<code>operator delete</code>来释放地址，对于拥有正常签名式的new和delete来说不成问题</p>\n<pre><code class=\"language-c++\">void* operator new(std::size_t) throw(std::bad_alloc);\t//普通的new\nvoid operator delete(void* rawMemory) throw();\t//global中的普通的new\nvoid operator delete(void* rawMemory, std::size_t size) throw();\t//class中的new\n</code></pre>\n<p>但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题</p>\n<pre><code class=\"language-c++\">void* operator new(std::size_t, void* pMemory) throw();\t//placement new，比普通new多带一个参数\n\nWidget* pw = new (std::cerr) Widget;\t//调用operator new，并以cerr作为其实参\n</code></pre>\n<p>当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的<code>operator new</code>时如何运作的，所以运行时系统会去寻找<strong>参数个数与类型</strong>都与<code>operator new</code>相同的某个<code>operator delete</code></p>\n<pre><code class=\"language-c++\">void operator delete(void*, std::ostream&amp;) throw();\t//palcement delete\n</code></pre>\n<pre><code class=\"language-c++\">class Widget&#123;\npublic:\n  static void* operator new(std::size_t size, std::ostream&amp; logStream) throw(std::bad_alloc);\n  static void operator delete(void* pMemory) throw();\n  static void operator delete(void* pMemoty, std::ostream&amp; logStream) throw();\n  ...\n&#125;;\n</code></pre>\n<p>如果此时调用<code>delete pw</code>，只会调用普通的<code>delete</code>，因为只有在构造时发生异常时，运行时系统才会调用placement delete</p>\n<p>最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete</p>\n<h2 id=\"九：杂项\">九：杂项</h2>\n<h3 id=\"不要忽视编译器警告\">不要忽视编译器警告</h3>\n<p>很多人忽视警告，毕竟一个问题如果真的很严重，应该报错</p>\n<p>比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为</p>\n<pre><code class=\"language-c++\">class B&#123;\npublic:\n  virtual void f() const;\n&#125;;\nclass D: public B&#123;\n  virtual void f();\n&#125;;\n</code></pre>\n<p>报警告</p>\n<pre><code class=\"language-c++\">warning: D::f() hides virtual B::f()\n</code></pre>\n<p>原本的目的是为了在D中重新定义virtual函数<code>f()</code>，但由于B中<code>f()</code>是const，在D中不是，此时B中的<code>f()</code>并没有在D中重新被声明，而是被整个遮掩了</p>\n<h3 id=\"去熟悉标准程序库\">去熟悉标准程序库</h3>\n<p>尤其是TR1</p>\n<h4 id=\"C-98有什么\">C++98有什么</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器</p>\n</li>\n<li class=\"lvl-2\">\n<p>Iostream</p>\n</li>\n<li class=\"lvl-2\">\n<p>国际化支持</p>\n</li>\n<li class=\"lvl-2\">\n<p>数值处理，包括复数（complex）和纯数值数组（valarray）</p>\n</li>\n<li class=\"lvl-2\">\n<p>异常阶层体系</p>\n</li>\n<li class=\"lvl-2\">\n<p>C89标准程序库</p>\n</li>\n</ul>\n<h4 id=\"TR1有什么（全在std-tr1中）\">TR1有什么（全在<code>std::tr1</code>中）</h4>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>智能指针<code>tr1::shared_ptr</code>和<code>tr1::weak_ptr</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::function</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::bind</code></p>\n</li>\n</ul>\n<p>和（彼此无关的独立组件）</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>哈希表</p>\n</li>\n<li class=\"lvl-2\">\n<p>正则表达式</p>\n</li>\n<li class=\"lvl-2\">\n<p>Tuple变量组</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::array</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::mem_fn</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::reference_wrapper</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>随机数生成工具</p>\n</li>\n<li class=\"lvl-2\">\n<p>数学特殊函数</p>\n</li>\n<li class=\"lvl-2\">\n<p>C99兼容</p>\n</li>\n</ul>\n<p>和（基于template）</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Type traits</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>tr1::result_of</code></p>\n</li>\n</ul>\n<h3 id=\"熟悉Boost\">熟悉Boost</h3>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cldju62ds0001qq3c81yeei2c","category_id":"cldju62dt0002qq3cdu711c55","_id":"cldju62dv0005qq3c3ymt06cf"}],"PostTag":[{"post_id":"cldju62ds0001qq3c81yeei2c","tag_id":"cldju62du0003qq3cewky6e3d","_id":"cldju62du0004qq3cbutp1m1v"}],"Tag":[{"name":"C++","_id":"cldju62du0003qq3cewky6e3d"}]}}