{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/effectivecxx.png","path":"images/effectivecxx.png","modified":0,"renderable":0},{"_id":"source/images/logo.png","path":"images/logo.png","modified":0,"renderable":0},{"_id":"themes/Volantis/source/css/Readme.md","path":"css/Readme.md","modified":0,"renderable":1},{"_id":"themes/Volantis/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/Volantis/source/images/bg.png","path":"images/bg.png","modified":0,"renderable":1},{"_id":"themes/Volantis/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/Volantis/source/css/first.styl","path":"css/first.styl","modified":0,"renderable":1},{"_id":"themes/Volantis/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/Volantis/source/js/plugins/aplayer.js","path":"js/plugins/aplayer.js","modified":0,"renderable":1},{"_id":"themes/Volantis/source/js/plugins/parallax.js","path":"js/plugins/parallax.js","modified":0,"renderable":1},{"_id":"themes/Volantis/source/js/plugins/rightMenus.js","path":"js/plugins/rightMenus.js","modified":0,"renderable":1},{"_id":"themes/Volantis/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/Volantis/source/js/search/hexo.js","path":"js/search/hexo.js","modified":0,"renderable":1},{"_id":"themes/Volantis/source/js/search/meilisearch.js","path":"js/search/meilisearch.js","modified":0,"renderable":1},{"_id":"themes/Volantis/source/js/plugins/tags/contributors.js","path":"js/plugins/tags/contributors.js","modified":0,"renderable":1},{"_id":"themes/Volantis/source/js/plugins/tags/friends.js","path":"js/plugins/tags/friends.js","modified":0,"renderable":1},{"_id":"themes/Volantis/source/js/plugins/tags/sites.js","path":"js/plugins/tags/sites.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Effective C++.md","hash":"0e5e69f6d3339fe36d6f7884d34097334029a3fb","modified":1675171557688},{"_id":"source/_posts/hello-world.md","hash":"fbbffbc1e4d83a338ab1e20bbe6c00d5454c8e4b","modified":1675177807077},{"_id":"source/.DS_Store","hash":"cb92ffd17ccad357289db4f7d75342ba6f115553","modified":1675153236874},{"_id":"source/CNAME","hash":"680182c5adbce6d467a394df8ab22543d897dd45","modified":1675079480000},{"_id":"source/images/logo.png","hash":"3760812b7f67b5f09b2d2da02a8da71fbfa80001","modified":1675088740000},{"_id":"source/_posts/.DS_Store","hash":"e3fd3bbe1069ee3747121a2ca2553346954be5b3","modified":1675174231482},{"_id":"source/images/.DS_Store","hash":"7566b5c6e49392c393ef6684ef7dea67d6779ab0","modified":1675144036881},{"_id":"source/images/effectivecxx.png","hash":"416aaa5e30b801175f88e4539a28a006e2e4767b","modified":1675135642393},{"_id":"themes/Volantis/layout/_partial/_cover/blank.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1674124614000},{"_id":"themes/Volantis/.gitignore","hash":"634017e600d424f2f08082d7f521b73f1089d95f","modified":1674124614000},{"_id":"themes/Volantis/LICENSE","hash":"13b0862f4ed1914abe887a47df2c3ca5adfa8f3f","modified":1674124614000},{"_id":"themes/Volantis/_cdn.yml","hash":"96aa311d8ad8fea6860dcb0f59000b9b0360549e","modified":1674124614000},{"_id":"themes/Volantis/package.json","hash":"2134b0a13df1d4ae305bd1c2773ec9be0cc05722","modified":1674124614000},{"_id":"themes/Volantis/CHANGELOG.md","hash":"602612b2aad8c74059adc705a589cc71defd7e6a","modified":1674124614000},{"_id":"themes/Volantis/.github/config.yml","hash":"7f6dd1ed4a0b4837548747b93b098e64b10038ca","modified":1674124614000},{"_id":"themes/Volantis/.DS_Store","hash":"11395b8d473c3a31045c20007b96810367ed0113","modified":1675156879078},{"_id":"themes/Volantis/.github/publish.sh","hash":"1fd47e7903fc28f111f702be4d67eb3a6ca87f87","modified":1674124614000},{"_id":"themes/Volantis/README.md","hash":"7c43923ced74698b0dfffb0ff1c53a70ad16e6fb","modified":1674124614000},{"_id":"themes/Volantis/.github/dependabot.yml","hash":"3ab95d1e72ed72aa5dcc053c7e5d116d3a5adc6f","modified":1674124614000},{"_id":"themes/Volantis/.github/label-commenter-config.yml","hash":"6a559be080d3378841b7e456d1f7debc8fbfede9","modified":1674124614000},{"_id":"themes/Volantis/.npmignore","hash":"517c3c4cc55122fb3958764c539e94fb2f23bb04","modified":1674124614000},{"_id":"themes/Volantis/_config.yml","hash":"8308353dfbf19818a211972930f5257cf95206d0","modified":1675178499741},{"_id":"themes/Volantis/.github/PULL_REQUEST_TEMPLATE.md","hash":"95c9cebeac47ba213a59e13067db022f568716ff","modified":1674124614000},{"_id":"themes/Volantis/languages/zh-TW.yml","hash":"55ecd5f710c23964a3de62cc55a85dc46274915a","modified":1674124614000},{"_id":"themes/Volantis/layout/404.ejs","hash":"48e160ad704be637cafc433d2365fc0eb8bab8cb","modified":1674124614000},{"_id":"themes/Volantis/languages/en.yml","hash":"9e595dcdc39242f19f0635f5f13490769d2eb878","modified":1674124614000},{"_id":"themes/Volantis/layout/archive.ejs","hash":"f99913b253f8ab22f81280a6ce5145bec3cd3de6","modified":1674124614000},{"_id":"themes/Volantis/layout/friends.ejs","hash":"4d7b154da92a9a7d9a2d1d9b40a5620585b0fd90","modified":1674124614000},{"_id":"themes/Volantis/layout/_pre.ejs","hash":"3ac804505c282ff8b16858037c1d2bf9305c3063","modified":1674124614000},{"_id":"themes/Volantis/layout/category.ejs","hash":"9ee883e5f73c05b3963770b74b63d7bb7e4e1ed5","modified":1674124614000},{"_id":"themes/Volantis/layout/docs.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1674124614000},{"_id":"themes/Volantis/layout/list.ejs","hash":"a85b2984717ee6d5058ec5635f3f287f45c3d4ba","modified":1674124614000},{"_id":"themes/Volantis/layout/layout.ejs","hash":"12d4ad6f7d1edfea87e61ba8b705e49a22611c47","modified":1674124614000},{"_id":"themes/Volantis/layout/tag.ejs","hash":"696e7b1c70b4438e6a8d925f99cbc4222dd4035d","modified":1674124614000},{"_id":"themes/Volantis/languages/zh-CN.yml","hash":"71a503cd9af4a9645a9db7a60897de1433600c74","modified":1674124614000},{"_id":"themes/Volantis/layout/post.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1674124614000},{"_id":"themes/Volantis/layout/index.ejs","hash":"8ea7d49272b068cd1a4037846c72eb37e9823512","modified":1674124614000},{"_id":"themes/Volantis/.github/ISSUE_TEMPLATE/config.yml","hash":"300ba3bbbbd863bd08cf77dd245a6ec3108c5da3","modified":1674124614000},{"_id":"themes/Volantis/.github/ISSUE_TEMPLATE/zh-cn-1-help.yaml","hash":"8bf2cc91f08e414b32201cdfd8a0a7d6cd038e1c","modified":1674124614000},{"_id":"themes/Volantis/source/.DS_Store","hash":"4cf1f8232384f26d2561a20ca14afd76a526de72","modified":1675171294950},{"_id":"themes/Volantis/.github/ISSUE_TEMPLATE/zh-cn-5-feature-request.yaml","hash":"1a393fb8e8595d2360d5e91bd9345b9b0e89a48b","modified":1674124614000},{"_id":"themes/Volantis/.github/ISSUE_TEMPLATE/zh-cn-8-bug-report.yaml","hash":"5d742a43c376a072276dd288d95a7e694cf1c153","modified":1674124614000},{"_id":"themes/Volantis/.github/workflows/labeler.yml","hash":"c4be217120c8fab992fea35c6808ae3325aaf7c4","modified":1674124614000},{"_id":"themes/Volantis/.github/workflows/label-commenter.yml","hash":"28e897eed56943daceadaa484eff2d8ebe9183b9","modified":1674124614000},{"_id":"themes/Volantis/.github/ISSUE_TEMPLATE/zh-cn-9-other-issue.yaml","hash":"f4ca5c0d88683583f3135c64c0a654be7887d1ae","modified":1674124614000},{"_id":"themes/Volantis/.github/workflows/merge-squash-main.yml","hash":"cba0e27114adc4702596191def222b30e6734bed","modified":1674124614000},{"_id":"themes/Volantis/.github/workflows/npm-publish.yml","hash":"43d1b9e45898b223bb5fcfe90a115c5e019157e5","modified":1674124614000},{"_id":"themes/Volantis/.github/workflows/merge-conflicts.yml","hash":"5461fc75e0798022d2dfba9f3e73054f5ee9cfc0","modified":1674124614000},{"_id":"themes/Volantis/layout/page.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1674124614000},{"_id":"themes/Volantis/scripts/filters/replace.js","hash":"aa6fe807d7b24a60475ce8126a1be7b314cd26ba","modified":1674124614000},{"_id":"themes/Volantis/scripts/filters/content-visibility.js","hash":"048a8f1b80e8999d5f7a37bb8c4dabdebbebabdc","modified":1674124614000},{"_id":"themes/Volantis/.github/workflows/sync-coding.yml","hash":"434fb744858e0166077a9644f5bf3ef6323b9431","modified":1674124614000},{"_id":"themes/Volantis/scripts/filters/z-lazyload.js","hash":"df6c5b0a6eff5e655d2b8de85c646ba1e5a16535","modified":1674124614000},{"_id":"themes/Volantis/.github/workflows/test-deploy.yml","hash":"f21a593dcbf2bcf3adbbf3bd0fc3f91800f20784","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/btn.js","hash":"e9b6e26f106505cf14a72524ab5e8b5bc85f362a","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/btns.js","hash":"648671420faa0ac00076a8c7bb011c908b83fd5a","modified":1674124614000},{"_id":"themes/Volantis/.github/workflows/pr-updater.yml","hash":"a2f93ca9a1a221466937cdd96ba454c070ea12dd","modified":1674124614000},{"_id":"themes/Volantis/scripts/filters/img.js","hash":"160732831bec5baf89fa07a85fec5229c3cb9cd7","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/dropmenu.js","hash":"19176a6edf7acc6ad31c96961e59da526f200980","modified":1674124614000},{"_id":"themes/Volantis/scripts/events/index.js","hash":"af7aaa4431393889671853db03c8b684265eaa50","modified":1674124614000},{"_id":"themes/Volantis/.github/workflows/release-please.yml","hash":"5d34d4b133b61a61e4ed15329bc52da65bcbd3c7","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/folding.js","hash":"a809988c63f358e2ae903d905dc81ed80860bacd","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/fancybox.js","hash":"9b7a33c40cd322798afd2925c28078a01fdc9108","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/contributors.js","hash":"ce3fb8ea5407237a2a080fb7e4ed6dd4a8ee8114","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/ghcard.js","hash":"8a6e80141c789cc0df3809ac64dbf28e6a1254fd","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/frame.js","hash":"e78834c005bda8f80ba86c78911b9db7566b878b","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/friends.js","hash":"ab78df7349252f036355ef5182ca0658a19eb6ad","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/md.js","hash":"355d78589b045b9b128a9d100e0ba41e3bce84b9","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/image.js","hash":"63a4b3e1e3d661b6ab2b3fcfcfb657e3b632b9cb","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/media.js","hash":"fb8d031b48cb3f6174948c2be0bd15fa92d8a6df","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/checkbox.js","hash":"0798edc6833d5978709ca5ed56aed33cea46e694","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/pandown.js","hash":"4d6f6dab955106ade379d6c55603e1e7eb97a107","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/link.js","hash":"9dec9c65819d1135a7a248adaa26acbf24427cd0","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/site.js","hash":"461d24b71dd1a6ff643372c05718121f516a9237","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/inline-labels.js","hash":"08fbdc0ea622270e1236a28778f875c8ad2e5516","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/table.js","hash":"ad82046fc64f932019d8a7b3e9a8ff07973a6c3b","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/tabs.js","hash":"f0054f1c970cac728b3ad289a3c531c070c06896","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/timeline.js","hash":"9b6b88ada712a8f3a04a825cf73a409f072ed045","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/custom-files.js","hash":"8483fcdc7dbbfde40276dc3daa1ddc5e40380360","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/first-style.js","hash":"ba2e2325a365704abae3f1d204b058731e21bfbf","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/getList.js","hash":"595400c37b79599f779876808e0308ead7de0a32","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/note.js","hash":"ac86ba50da98d9546522feaca672259620b053d8","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/related-posts.js","hash":"cab8c291a8ff460b29b3248ac86827c143aca9ee","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/文章推荐.js","hash":"c1e0466407c487ddfbaf72e54291103af64530e6","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/span.js","hash":"b825115f037386797efa1b0aee3a1df21629f243","modified":1674124614000},{"_id":"themes/Volantis/scripts/tags/swiper.js","hash":"f0171f07f494c0b0f3f8af265344add15813a676","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/cover.ejs","hash":"53cb6c2b2af0386c1d2fe4a7d1cf67a6d0457393","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/archive.ejs","hash":"d5f776437c108c72c002b11f1d23d30b50e0079a","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/head.ejs","hash":"577c937231054c265f6cf2c54539e4626962c68f","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/header.ejs","hash":"2201789620e181b205c90f2907de0c47e0390ae5","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/categories.ejs","hash":"c2bc61780cab948ef8ab5076511ebccacab1cd79","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/side.ejs","hash":"27f9df84585ffb24e2ba2423761f90f690c65787","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/meta.ejs","hash":"ced9c966a9f4d84e485c325ef3551be218ddd033","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/post.ejs","hash":"7d144c80f2980efaab6198512746c0c5d77f03db","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/footer.ejs","hash":"fd48b63b60dc8aa69280e6d4fec3ebdc70a495f4","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/article.ejs","hash":"adce449fe0914e349994925024fd840cb32812f8","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/category.ejs","hash":"d423a2b15a8e267454c7521d6203b7188e5f5e75","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/_pre.ejs","hash":"2a738e0a4f93339b6a51fc124400fa5a8b2640bc","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/group.ejs","hash":"2eed9614049441b51e6819f393f80faf5441870b","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/lastupdate.ejs","hash":"4668b511f660da0c8e76181c8aa840092c540483","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/copyright.ejs","hash":"a93a1f181e9f2dfe01556b0b101b0f8d85e7769f","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/blogger.ejs","hash":"f59fa64cbc1b63f9edf6ea23abe01e28d073e30e","modified":1675160012319},{"_id":"themes/Volantis/layout/_widget/list.ejs","hash":"18a352d9d84d9abec51644d1e89829b1aa0c9f49","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/load.ejs","hash":"c4746b7f538d08df034a39dbf94ad2432b6bf845","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/music.ejs","hash":"47c578384a870d32adf3969d9bebf0c3f5766682","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/page.ejs","hash":"264fc908e7b8972310396f1cf03186d1d71a5a8b","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/qrcode.ejs","hash":"6b9e27bd3a88e9d8ae69b746e042bf9e3aa19ba5","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/references.ejs","hash":"08f2dbd23fc9835f4c24bdda4cf288593d61c25a","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/grid.ejs","hash":"ce6caf29104ed62efccdcb5bc23aa4a50f6c1286","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/related_posts.ejs","hash":"ec750915735bdf88ad258c3450d41fce148c89c8","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/header.ejs","hash":"b132e332ddf12d1bb1d99480200561d8c38edd04","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/tagcloud.ejs","hash":"1a44b7b317871193becb1a7bc2132192c00f0b98","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/counter.ejs","hash":"2fbd81d196526059e1a4d43614d4c433ae697bf7","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/webinfo.ejs","hash":"ab83ae57a679d7da724924328adf25f0ef1533ae","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/text.ejs","hash":"7c37bb1a302cc4fb75ac51451cdd15acad603993","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/category.ejs","hash":"bbf3ca01ebb7bf1e58f32307f8b669af10a36c51","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/author.ejs","hash":"68e8f198c406b6946fbf0a0f756e8a334982ba84","modified":1674124614000},{"_id":"themes/Volantis/layout/_widget/toc.ejs","hash":"a89e47426e2abf79c695661f56963caaccb9a954","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/music.ejs","hash":"2c1884e59131d47a82d2556ac28ef784b4ddaa10","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/thumbnail.ejs","hash":"60045f2bf695b4be5ad3fd19db46890f1cdee68a","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/share.ejs","hash":"0f3b1db92319734baa8da1636340839ed2d37a7b","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/date.ejs","hash":"ba6c554dbc6c1870debb2b87c5fa25caa089be8f","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/artalkcount.ejs","hash":"94c9e591e38ac00d6beafa44de4d29e70680c673","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/updated.ejs","hash":"edf445ad8153419a5dc7c4ec4c8490967cd9d33d","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/walinecount.ejs","hash":"038b1c17a316f4611812c3e1056d7aef91de6910","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/tags.ejs","hash":"3d6812e845b2ec82e43dd4b4563298c19cb48097","modified":1674124614000},{"_id":"themes/Volantis/layout/_meta/wordcount.ejs","hash":"eebaab3821af95ee64d8d56f33ca6c9c60b9b6f0","modified":1674124614000},{"_id":"themes/Volantis/.github/labeler.yml","hash":"a908c69338be4281253fb67cc11acfdcb6b56930","modified":1674124614000},{"_id":"themes/Volantis/source/css/first.styl","hash":"55fe35847a1d1d831eb71288c0233efb1dd8a630","modified":1674124614000},{"_id":"themes/Volantis/source/css/style.styl","hash":"00892839230a1b05a5f9d9350baacd67d894fc85","modified":1674124614000},{"_id":"themes/Volantis/scripts/events/lib/cdn.js","hash":"adf2a07d3adef7b79ffa33291b843410fe4371fe","modified":1674124614000},{"_id":"themes/Volantis/scripts/events/lib/check-configuration.js","hash":"d4c00593ebbbf417b9f18f1b755b0b45c5415fa9","modified":1674124614000},{"_id":"themes/Volantis/source/css/Readme.md","hash":"cf408308dcbc62f4fc2bd5aa38303b368cc88a7e","modified":1674124614000},{"_id":"themes/Volantis/scripts/events/lib/config.js","hash":"501968a736d73e6a34e8ef833c54bfa89d0190e2","modified":1674124614000},{"_id":"themes/Volantis/scripts/events/lib/stellar-tag-utils.js","hash":"8d62893faf26d15d2833f8090bd6257a7282f5e2","modified":1674124614000},{"_id":"themes/Volantis/scripts/events/lib/render-stylus.js","hash":"36c2f32d2101eaa84041daf70393df6f3a3fa331","modified":1674124614000},{"_id":"themes/Volantis/scripts/events/lib/check-environment.js","hash":"9d29a3f34ea715a0dc7cb5c2f76b5713d718e6e6","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/head/autoCanonical.js","hash":"f3ea74759129c71041371a1d77c687eb6aa88d3a","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/head/generate_seo.js","hash":"e0059a60cc5978be6792dcf795a2ece3a509f41a","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/head/generate_preload_fontfamily.js","hash":"d37dbe38fa9125fdce99b2ef9e92582ed08eea82","modified":1674124614000},{"_id":"themes/Volantis/source/images/logo.png","hash":"3760812b7f67b5f09b2d2da02a8da71fbfa80001","modified":1675159516270},{"_id":"themes/Volantis/source/js/app.js","hash":"3bf50c7fcd705d2912d5fadcca2d42a0e374efa0","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/head/generate_title__keywords__description.js","hash":"179a07b7b2270398216a34d79595d98e30962b22","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/_cover/dock.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/_cover/featured.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/_cover/focus.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/_cover/layout.ejs","hash":"39a463ce33ce6138d40055e72118941515ba2f63","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/_cover/search.ejs","hash":"2f536370d1b51fa7c33798be21e690638f0df74e","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/scripts/_ctrl.ejs","hash":"ccd73af4ac2cacf5d484d36374e17c263b1a5a13","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/scripts/config.ejs","hash":"0d07aac1b6e02714cb76284eb156e278b533b128","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/structured-data/index.js","hash":"bcb770787c77e39cdc156b7fd58cde8e00b79153","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/scripts/global.ejs","hash":"69bb5fae2bdc6f391ff36e3c29ee067a63717d83","modified":1674124614000},{"_id":"themes/Volantis/layout/_partial/scripts/index.ejs","hash":"dfcf31a498e7d9ebaa0645e31724ed0d556ba771","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/analytics/script.ejs","hash":"84d80907189e66730772984fca426fbb487c7709","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/_page_plugins/index.ejs","hash":"462334ae298659214464f3a8af3da1c514cf76e1","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/aplayer/script.ejs","hash":"51d49a076c30e57efe14ce3575018d3c226a2741","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/chat/index.ejs","hash":"56d2e577fbd08859e118cfb1d1b8d230850a3675","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/aplayer/layout.ejs","hash":"822212208fbbb4fa189abc503cd14b9b6e385901","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/darkmode/script.ejs","hash":"4b492f244d69a36ec8c01353648b45bd3bd2664c","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/content-visibility/script.ejs","hash":"837f89fa589ad74ad28a1436a90f5283ee4fcb92","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/end-of-support/script.ejs","hash":"b415d8e5dfca4a47c199b1adeb220ff57eaec219","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/github-api/script.ejs","hash":"230071963d5f599a8e2fd55bf13f9c40a53851d3","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/highlight/script.ejs","hash":"06befe70f47454fbfaa95245fe4cdb8d4f6f9f3c","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/lazyload/script.ejs","hash":"072020c969763742de5b78ae8653a71d753232eb","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/index.ejs","hash":"3d781c01f494b89d1d31d3210c100c822787c9b7","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/nodewaves/script.ejs","hash":"72c937530f0a6bef00e225377266752a60f4e083","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/preload/script.ejs","hash":"f35821683c3bac5e898face2f74135a52bec5254","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/parallax/script.ejs","hash":"8465663815c089a367cdd35862d5bad68d0545f7","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/pace/script.ejs","hash":"571cc2d9cd15cc4df21d34394a75dec083c6256f","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/scrollreveal/script.ejs","hash":"09ca33499a24acf08af6e619e16354e2d13000a2","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/search/script.ejs","hash":"a9e0939ae1c58fc7419eaf2c5e5664be8da6dccb","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/share/layout.ejs","hash":"017e6315b814bfdfd230ac681b83231f7b8867b7","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/swiper/script.ejs","hash":"1c1ca7640311d176123260642ca9fca3242b220f","modified":1674124614000},{"_id":"themes/Volantis/source/css/_defines/AutoPrefixCSS.styl","hash":"c76f624d332c59b73c1d6b95b30b2afb560976eb","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/slow-network/script.ejs","hash":"5a2f3eaadb6dbe4350e6d32094a0bad62ba240bc","modified":1674124614000},{"_id":"themes/Volantis/source/css/_defines/effect.styl","hash":"47db4f84182194a8a233931424c9bc79c6cf0117","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/rightmenus/layout.ejs","hash":"de6d7f3d274617edfb8f9f71b652d5dbdaba9bad","modified":1674124614000},{"_id":"themes/Volantis/source/css/_defines/fonts.styl","hash":"fa199b11b568a6b0d6fc4e87ef12ab36ac254966","modified":1674124614000},{"_id":"themes/Volantis/source/css/_defines/layout.styl","hash":"d1bdce2e7974b1feb585adcdf95e36a054a36ec4","modified":1674124614000},{"_id":"themes/Volantis/source/css/_first/base_first.styl","hash":"2db7ec30d52473fa40bca89dcd29854498e8ca3e","modified":1674124614000},{"_id":"themes/Volantis/source/css/_first/cover_first.styl","hash":"32f0e09eba832607165096c68f70698a75d685b5","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/toc/script.ejs","hash":"a51b1e0c57301a77857c2b1b334b172050494a5f","modified":1674124614000},{"_id":"themes/Volantis/source/css/_defines/color.styl","hash":"02d9bbe630f33ec2c604cb8acdddbe28431fcb05","modified":1674124614000},{"_id":"themes/Volantis/source/css/_first/dark_first.styl","hash":"bcb419588c1972bd47869309dea43ff319440d33","modified":1674124614000},{"_id":"themes/Volantis/source/css/_defines/func.styl","hash":"430adedc7e6f57013e54d15e6f8dce21e9ea2579","modified":1674124614000},{"_id":"themes/Volantis/source/css/_first/fontfamily_first.styl","hash":"5024a9162f4787ac4234d5b8549fad40dbecf865","modified":1674124614000},{"_id":"themes/Volantis/source/css/_first/search_first.styl","hash":"955c9eb68b90b97dba0bd27909347cfc91ce68c5","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/index.styl","hash":"835b3640c257cd229b20c088536b053b92c9796c","modified":1674124614000},{"_id":"themes/Volantis/source/css/_defines/Readme.md","hash":"77d9e986d24898b98eba2010185951fd1fb8b95c","modified":1674124614000},{"_id":"themes/Volantis/source/js/plugins/aplayer.js","hash":"95f2e47535c8d37e90cab7726d25845cf01ca477","modified":1674124614000},{"_id":"themes/Volantis/source/js/plugins/parallax.js","hash":"3c3210bde6e86d7d157c34c14796abe98cb1bbd0","modified":1674124614000},{"_id":"themes/Volantis/source/js/search/algolia.js","hash":"97591a9f07c6d235cb8df01bbd699bfec67c321e","modified":1674124614000},{"_id":"themes/Volantis/source/js/search/hexo.js","hash":"bed5846e373244ab851b50f21337f8d12270d638","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/structured-data/lib/index.js","hash":"41e4af773dfb4755752cb74a6d70e4b5b0c1ce4d","modified":1674124614000},{"_id":"themes/Volantis/source/js/plugins/rightMenus.js","hash":"45f1d78b180b5ef7355afc748bb65406bc16faef","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/structured-data/lib/config.js","hash":"e4c3c23e58f0bac72010f962d92da641445e748a","modified":1674124614000},{"_id":"themes/Volantis/source/css/_first/navbar_first.styl","hash":"e268d81dc78fdf9758d314cdc5cc087aec1c70e6","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/structured-data/lib/website.js","hash":"556f28164d31b3898d06cb8f76472bc6547bb1db","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/structured-data/lib/organization.js","hash":"02c08f0362aec5d310b8c7e69823cd88ed49ea5e","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/structured-data/lib/person.js","hash":"afca448311d62a44566d9471594a43495a6be6db","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/structured-data/lib/blogposting.js","hash":"f8543b0460c9a5b23ee43d8ed49e018c1c627439","modified":1674124614000},{"_id":"themes/Volantis/source/js/search/meilisearch.js","hash":"833816876a74646bfdd395c05985c8b64c0856a2","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/_page_plugins/bbtalk/index.ejs","hash":"458661a5d1b4e549e6564d38d9df1d276a917002","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/_page_plugins/artitalk/index.ejs","hash":"0e716837d0febab52d3783832eda893b4785c776","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/_page_plugins/gitter/index.ejs","hash":"85baf33f1c90eca55ee91eb8d0955b2770909443","modified":1674124614000},{"_id":"themes/Volantis/scripts/helpers/structured-data/lib/breadcrumblist.js","hash":"df6316082af2df061f16bb01d5b5d3478f98c662","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/_page_plugins/katex/index.ejs","hash":"c42b9d80ae66e804d0c37b29a04ce643ea78f005","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/_page_plugins/fcircle/index.ejs","hash":"cdaf8d752a3317519240b651b972f9915021c762","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/_page_plugins/snackbar/index.ejs","hash":"bddb75f7112d2b438f462a6ebef79810ef5ac291","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/chat/gitter/script.ejs","hash":"e4f06c50c23d433a0e63fc703a35704c336ba090","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/_page_plugins/mathjax/index.ejs","hash":"917593e8966621a9d4c1e739f9b0b1e175d2687f","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/chat/tidio/script.ejs","hash":"bb678b5e8a9fb87fc1c1e48914da3a1a052a8e02","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/artalk/script.ejs","hash":"355d9358fbc2ab6fe66db2adbcc509423a6e2d6f","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/beaudar/script.ejs","hash":"ac577e21ec4872738f197d63a0a4e21704e042dc","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/disqus/script.ejs","hash":"42073427f301403c885f21168f804127583d7c16","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/_page_plugins/indent/index.ejs","hash":"7d112cde9b8d1785d8c541cde94361e0bfc60f30","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/disqusjs/script.ejs","hash":"1c031f73e28faa8a72aab3d0272dc09981c19cb6","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/giscus/script.ejs","hash":"472a5267d8b557699e062723b189ce4d7949e71a","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/isso/script.ejs","hash":"27608c396eb8b0d54a87e0dc58bf675ad5711549","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/hashover/script.ejs","hash":"1852d00413991ad1968b43232eefd48e50fba861","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/livere/script.ejs","hash":"73a37600f7815a1408ce6b03b4d65f3755ef7efe","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/twikoo/script.ejs","hash":"8532298f430cd2a032f14359541816b1809dbc3c","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/vssue/script.ejs","hash":"7bc0f788a3039a1dcf3a78438466b4b8cb97f811","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/discuss/script.ejs","hash":"f088f02c8ca9ae9eb434f906320ad54145c7d5f5","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/gitalk/script.ejs","hash":"576841484dca739aeb41d4763a3c0b71dce02683","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/waline/script.ejs","hash":"810ee7bd496485b69e0d61d7fb8e2615960b57c0","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/z-custom/script.ejs","hash":"e5cfe25fb88b7a3dd0c68e20b2e17d44eb2a1f04","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/highlight/highlightjs/script.ejs","hash":"1624bee754dbc9d3a227563e61180b6c34579917","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/highlight/prismjs/script.ejs","hash":"46b987c826a9fa1bfa92976188d28b8a33bfa2c4","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_base/base.styl","hash":"712eb4803dc595eb111ebd89546e6ed3fb1ec7ce","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_base/fontfamily_async.styl","hash":"48c006682b8f44681662e4b0f8d3ebfdf85add69","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/aplayer.styl","hash":"da809e1dde8adb9d1c98f0daeb52a2d920d497f7","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/cursor.styl","hash":"bc055048c7d017be8cf25a3385f516656c96cf66","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/fontcolor.styl","hash":"fa13f91f8be68b62210048d1481c3b23e23f939b","modified":1674124614000},{"_id":"themes/Volantis/layout/_plugins/comments/utterances/script.ejs","hash":"d1bc3bc83d554158f943e9a3755595242cd7fd11","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/index.styl","hash":"088e20899e200b0ed78e2c033384d10361703913","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/mathjax.styl","hash":"11ee86571f31f9aa61dcc48b40977dcd974d76a4","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/message.styl","hash":"995b46084664f2ed2cf025c1a208089ecfe1147e","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/btns.styl","hash":"bf592cd78c146bb671217f106632b9e5bcc7c145","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/dropmenu.styl","hash":"a136ebb90bedef15c1d8b8d75e09b37c3873f5e8","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/fancybox.styl","hash":"1b4709787f9bda8ce565aa9a4aaf7f1f58751b44","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/folding.styl","hash":"253f13e60218e0d014a1df99933f5cdba507f3b1","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/gitalk.styl","hash":"c4c9950fd6654f87ca4f481cf3065ca4069fac48","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/checkbox.styl","hash":"8c62dd38914d939069d9222c54787a24cb5c31f7","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/frame.styl","hash":"6ffbb29514781aa4fa7d7653706554ce33f4525b","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/friends.styl","hash":"8f9e60b94c02197e4555f923d357017742bf8d7b","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/Readme.md","hash":"51986550e80990e1db23e2ee4165e5e4800e4b9f","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/link.styl","hash":"82cdcc537612eec3e1af40d00edf80b14116c191","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/ghcard.styl","hash":"58adb206695a704b1f40df42e2dc10e9e9055aeb","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/image.styl","hash":"bb4b07841602592e421597ba8dd7110edec789d8","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/span.styl","hash":"6e9f8b453244d9241d3fceed0a56e12c86a4b446","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/sites.styl","hash":"01593f3b8a233bc2c3193796707e4ed77df217bb","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/note.styl","hash":"005d3c55c2216d7c88661f79ad466ad89fad4784","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/media.styl","hash":"576c9eede3a8f9ec2ba1a970e92a49154ec3acb3","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/swiper.styl","hash":"819385594f1825e26074ade900835a3f4031fe42","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/table.styl","hash":"ef07ab4fe8a391ea9039fbe53333aaf58e3ce033","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/tabs.styl","hash":"a2366f4fe1d9f06e47a7a994cfc80a1edbf6c535","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/archive.styl","hash":"a96709230abbc8d4fc40361b8fc02d4249abb4a1","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/text.styl","hash":"b2c2f3946fb611ad052c61d7309098edbf494c86","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/timeline.styl","hash":"f84f411a3b7dcdbfd4fb19ac4e0f91300c5e19be","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_tag-plugins/tag.json","hash":"506f87e397f258b097ba24ce16c33b5353bab462","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/article.styl","hash":"de23aac33b178c59531ef45168e98a0d98ad6151","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/friends-simpleuser.styl","hash":"07c477e15bf75615faff5587cc82dbc6004a901a","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/footer.styl","hash":"bb850b4707ee025e267e079fcf85484849cf4f41","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/img.styl","hash":"55d79f07b717d3e28515b41401f656d1593be624","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/loading.styl","hash":"56a2b9f46edd5b87e49d11647dc9396b0d833d54","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/main.styl","hash":"92f948df742f3de6d69a180b7653827c7242f1d3","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/md.styl","hash":"d9b25d8199d3d5260c89e8ad84f1a17531b85588","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/pagination.styl","hash":"65dacf95771fc518a06cbf301f4c0b06201d7321","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/posts.styl","hash":"31cf7bdbb44caa173f3dfd49d98157cb6be85c6f","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/search.styl","hash":"fdabe3b9a14040f86c0a715ab48f26bfb8a3f7bc","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/sidebar.styl","hash":"4b75b29b67b88ef5ee365535d521c3ee8256a1ea","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/snackbar.styl","hash":"752a7fea5284a61fd9305d3b0fcaa43f2e64862f","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/toc.styl","hash":"3346fbcbcbc2533997a8bf1fbbf801d9120b03ab","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/friends-traditional.styl","hash":"2da0419cd5874d03d7d5bafdb081beb6cb786608","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_layout/video.styl","hash":"680e8cf8fc5d62913dad4ccd06135caad2bb3e92","modified":1674124614000},{"_id":"themes/Volantis/source/js/plugins/tags/contributors.js","hash":"d9f6a153494fe5ff78382322f8f236a4d81ec482","modified":1674124614000},{"_id":"themes/Volantis/source/js/plugins/tags/sites.js","hash":"e29b1908689477f3ef19987b0cc65505c7d514ac","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_dark/dark_async.styl","hash":"a5da6f0b232a767057321fa51e382fd2d86bd98d","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_highlight/index.styl","hash":"6c681c760fa63425e7564c0d68532bb5ac95690a","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_dark/dark_plugins.styl","hash":"c56c2271847809e21e4938d770577622aeb161aa","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_rightmenu/reading.styl","hash":"cb01065424dbd32c79b973b06fcdbc1c72917bc6","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_rightmenu/rightmenu.styl","hash":"ef456a92173c303b61015f3581450aa14f0d2b41","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_highlight/highlightjs/clipboard.styl","hash":"6818ba853fd6a319ff4eb50d228b1d625db9a0fd","modified":1674124614000},{"_id":"themes/Volantis/source/js/plugins/tags/friends.js","hash":"d9fa94b4e54bd739bf8d32e2be313a750386a639","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_highlight/highlightjs/color.styl","hash":"319ccc46d5d387ee14a22e0de1a518288331629b","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_highlight/highlightjs/language.styl","hash":"4fade2fe067f557d3b420d0b9a9d88d18feb9a72","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_highlight/prismjs/language.styl","hash":"3af7fae25a0e2c54f0aacb1d8cbe383d5c1e60a5","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_highlight/prismjs/index.styl","hash":"215face68fab1c31cfa8d4c21941c72efe54cb78","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_highlight/prismjs/clipboard.styl","hash":"0f92935e3bb9732b6e1cc7f305577144f1fe99a8","modified":1674124614000},{"_id":"themes/Volantis/source/css/_style/_plugins/_highlight/highlightjs/index.styl","hash":"38089b686a0cfdde555539c1c0c5b3fe402afada","modified":1674124614000},{"_id":"themes/Volantis/source/images/bg.png","hash":"26bde011d0c938038c3946443933e4dd6f9a4b79","modified":1675089246000},{"_id":"public/search.xml","hash":"d25676f29c72e6139ab162763e065851fd2a1984","modified":1675177811347},{"_id":"public/2023/01/31/hello-world/index.html","hash":"94af426660c44962f259426eb090799309c7cee9","modified":1675179093723},{"_id":"public/2023/01/31/Effective C++/index.html","hash":"9968567c0c29dcab085ef5ea259e05b62c86178c","modified":1675179093723},{"_id":"public/archives/index.html","hash":"77e5b45bcba66ef7aef8e2b0759f4692bafe9804","modified":1675179093723},{"_id":"public/archives/2023/index.html","hash":"750fd11587884a65e64b92fcf73e3deb9e4f2e37","modified":1675179093723},{"_id":"public/archives/2023/01/index.html","hash":"1757e6e588e020648eea94016b6208f4137ee871","modified":1675179093723},{"_id":"public/categories/program/index.html","hash":"ecde26fcab62abe48dc578f5060794fab423e27a","modified":1675179093723},{"_id":"public/index.html","hash":"5a8b850f0a6b3d05e6f23285af3ef87206244e86","modified":1675179093723},{"_id":"public/tags/C/index.html","hash":"251388a6d4215d8656722c50aaacd52560bb0ab3","modified":1675179093723},{"_id":"public/CNAME","hash":"680182c5adbce6d467a394df8ab22543d897dd45","modified":1675171570266},{"_id":"public/images/logo.png","hash":"3760812b7f67b5f09b2d2da02a8da71fbfa80001","modified":1675171570266},{"_id":"public/js/plugins/parallax.js","hash":"3c3210bde6e86d7d157c34c14796abe98cb1bbd0","modified":1675171570266},{"_id":"public/js/plugins/aplayer.js","hash":"95f2e47535c8d37e90cab7726d25845cf01ca477","modified":1675171570266},{"_id":"public/js/search/algolia.js","hash":"7a00ea2e53fa7148449ffa58a6707f0b82243a1b","modified":1675171570266},{"_id":"public/css/Readme.html","hash":"e84f2918c0e13b0159058ca1493be5ad3d2ef1d1","modified":1675171570266},{"_id":"public/js/search/hexo.js","hash":"bed5846e373244ab851b50f21337f8d12270d638","modified":1675171570266},{"_id":"public/js/plugins/tags/sites.js","hash":"e29b1908689477f3ef19987b0cc65505c7d514ac","modified":1675171570266},{"_id":"public/js/plugins/tags/contributors.js","hash":"d9f6a153494fe5ff78382322f8f236a4d81ec482","modified":1675171570266},{"_id":"public/js/plugins/tags/friends.js","hash":"d9fa94b4e54bd739bf8d32e2be313a750386a639","modified":1675171570266},{"_id":"public/js/search/meilisearch.js","hash":"3738a3436c92d569e4883f0c2688414fdc4b0399","modified":1675171570266},{"_id":"public/css/style.css","hash":"e9627547683d46d0b40f032f331fb95f69146d0c","modified":1675171570266},{"_id":"public/js/app.js","hash":"3bf50c7fcd705d2912d5fadcca2d42a0e374efa0","modified":1675171570266},{"_id":"public/js/plugins/rightMenus.js","hash":"ac38377646954046fa9ced47d5c9e0dada7dd5bb","modified":1675171570266},{"_id":"public/css/first.css","hash":"8bfb0d0b8f88df8e205e1da0536fad968b357002","modified":1675171570266},{"_id":"public/images/effectivecxx.png","hash":"416aaa5e30b801175f88e4539a28a006e2e4767b","modified":1675171570266},{"_id":"public/images/bg.png","hash":"26bde011d0c938038c3946443933e4dd6f9a4b79","modified":1675171570266},{"_id":"source/_posts/hello-world2.md","hash":"3bacdf34404bc1cac990d4d372117620474ef71f","modified":1675172939726},{"_id":"source/_posts/hello-world4.md","hash":"8c7c52347b62e49b43285f74bb25d6f1342110d6","modified":1675172950562},{"_id":"source/_posts/hello-world3.md","hash":"765a27e0857f3cb770fe9c86442223377145b7fd","modified":1675172943105},{"_id":"source/_posts/hello-world5.md","hash":"22f71a95ef0bd8c240c4bd2659719fb1fca229bb","modified":1675172971823},{"_id":"public/2023/01/31/hello-world4/index.html","hash":"fded2d9f003c1dae7346358a69082a791ddb86d1","modified":1675179093723},{"_id":"public/2023/01/31/hello-world3/index.html","hash":"17c237ff8d2148ea08d153ca6fdb80d2decc3f0b","modified":1675179093723},{"_id":"public/2023/01/31/hello-world5/index.html","hash":"077c90f1e3bfcf2e3ad226904327f8e4673b08c9","modified":1675179093723},{"_id":"public/2023/01/31/hello-world2/index.html","hash":"f3803e707698da1c742feca771f7e83900bc0b9e","modified":1675179093723},{"_id":"public/categories/graphics/index.html","hash":"437078418f5bd3acab3e049ec1b656117fbf5e03","modified":1675179093723},{"_id":"public/categories/engine/index.html","hash":"750c40ffa46ebe1528546ee647ea2d49108c54bc","modified":1675179093723},{"_id":"public/categories/math/index.html","hash":"7f9bcf36eacd7890385ccf8a92aff81e732644e8","modified":1675179093723},{"_id":"public/categories/optics/index.html","hash":"d455e09efccd03a749bf8739af79d95c8de1afa2","modified":1675179093723},{"_id":"public/categories/dcc/index.html","hash":"8ab0126fdb99d7aeb57bb4e4ac92cba3ac168e8c","modified":1675179093723},{"_id":"source/categories/index.md","hash":"bcbd5f0ff024207da43bd32b4b58cb8998f4db4c","modified":1675175859476},{"_id":"public/categories/index.html","hash":"f3696838ad24d6969f574af1a7ff9860a38c9e61","modified":1675179093723},{"_id":"source/tags/index.md","hash":"c611dc2ac446dcc83a01ccd88bc1148bca4fe9cf","modified":1675175914417},{"_id":"public/tags/index.html","hash":"831405ef5e336720096fc810c9970c81803d6355","modified":1675179093723}],"Category":[{"name":"program","_id":"cldk9wg6t0002wu3c7yur81bd"},{"name":"graphics","_id":"cldkaoyms0002xz3c1akbhzo7"},{"name":"engine","_id":"cldkappdc000mxz3cgmys5kpn"},{"name":"math","_id":"cldkapvlp000oxz3cgmti4p97"},{"name":"optics","_id":"cldkaq1aq000qxz3cb3xicuix"},{"name":"dcc","_id":"cldkaqhrh000yxz3cep6t35wm"}],"Data":[],"Page":[{"layout":"category","index":true,"title":"所有分类","_content":"","source":"categories/index.md","raw":"---\nlayout: category\nindex: true\ntitle: 所有分类\n---","date":"2023-01-31T14:37:39.476Z","updated":"2023-01-31T14:37:39.476Z","path":"categories/index.html","_id":"cldkcg9wx0000xi3c7uc0gnlm","comments":1,"content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tag","index":true,"title":"所有标签","_content":"","source":"tags/index.md","raw":"---\nlayout: tag\nindex: true\ntitle: 所有标签\n---","date":"2023-01-31T14:38:34.417Z","updated":"2023-01-31T14:38:34.417Z","path":"tags/index.html","_id":"cldkchgjk0000vg3c3um5b4ph","comments":1,"content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"test","date":"2023-01-31T02:01:25.000Z","thumbnail":"/images/effectivecxx.png","cover":true,"toc":true,"plugins":["mathjax"],"_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n$\\Delta x$\n$$\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s\n$$\n\n```cpp\nint main(){\n\tcout << \"Hello\";\n}\n```\n\n\n\n```csharp\nusing System;\n\nnamespace Test\n{\n    class MainClass\n    {\n        public class Adder\n        {\n            private int c;\n            public Adder(int c) { this.c = c; }\n            public int Add(int a, int b)\n            {\n                return a + b + c;\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            Adder adder = new Adder(1);\n            Func<int, int, int> method = adder.Add;\n            Console.WriteLine(method(2, 3));\n        }\n    }\n}\n```\n\n```javascript\n\"use strict\";\nconst vertex = [-0.5, 0.5, 1, 1, 0.5, -0.5];\nconst color = [0.8, 0.8, 0.6];\nwindow.onload = initGL;\nfunction initGL() {\n    var _a, _b, _c;\n    const gl = (_a = document.getElementById(\"glcanvas\")) === null || _a === void 0 ? void 0 : _a.getContext(\"webgl\"), vsSource = (_b = document.getElementById(\"vertex-shader\")) === null || _b === void 0 ? void 0 : _b.textContent, fsSource = (_c = document.getElementById(\"fragment-shader\")) === null || _c === void 0 ? void 0 : _c.textContent;\n    if (!gl) {\n        alert('Browser does not support webgl.');\n        return;\n    }\n    if (!(vsSource && fsSource)) {\n        throw 'No shader found.';\n    }\n    gl.clearColor(1, 1, 1, 1);\n    gl.clearDepth(0);\n    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\n    gl.useProgram(shaderProgram);\n    const programInfo = {\n        pos: gl.getAttribLocation(shaderProgram, \"pos\"),\n        color: gl.getUniformLocation(shaderProgram, \"color\")\n    };\n    initBuffers(gl);\n    gl.vertexAttribPointer(programInfo.pos, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(programInfo.pos);\n    gl.uniform3fv(programInfo.color, color);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n}\n\n```\n\n```css\n* {\n  box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  outline: none;\n  margin: 0;\n  padding: 0;\n}\n```\n\n","source":"_posts/hello-world.md","raw":"---\nlayout: post\n# 标题\ntitle: test  \n# 发布时间\ndate: 2023/1/31 10:01:25  \n# 分类\ncategories: [graphics] \n# 标签\ntags:\n  - C++\n# 作者\n#author: Reuben\n# 缩略图\nthumbnail: /images/effectivecxx.png \n# 显示封面\ncover: true\n# 显示目录\ntoc: true\n# 启用插件\nplugins:\n  - mathjax\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n$\\Delta x$\n$$\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s\n$$\n\n```cpp\nint main(){\n\tcout << \"Hello\";\n}\n```\n\n\n\n```csharp\nusing System;\n\nnamespace Test\n{\n    class MainClass\n    {\n        public class Adder\n        {\n            private int c;\n            public Adder(int c) { this.c = c; }\n            public int Add(int a, int b)\n            {\n                return a + b + c;\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            Adder adder = new Adder(1);\n            Func<int, int, int> method = adder.Add;\n            Console.WriteLine(method(2, 3));\n        }\n    }\n}\n```\n\n```javascript\n\"use strict\";\nconst vertex = [-0.5, 0.5, 1, 1, 0.5, -0.5];\nconst color = [0.8, 0.8, 0.6];\nwindow.onload = initGL;\nfunction initGL() {\n    var _a, _b, _c;\n    const gl = (_a = document.getElementById(\"glcanvas\")) === null || _a === void 0 ? void 0 : _a.getContext(\"webgl\"), vsSource = (_b = document.getElementById(\"vertex-shader\")) === null || _b === void 0 ? void 0 : _b.textContent, fsSource = (_c = document.getElementById(\"fragment-shader\")) === null || _c === void 0 ? void 0 : _c.textContent;\n    if (!gl) {\n        alert('Browser does not support webgl.');\n        return;\n    }\n    if (!(vsSource && fsSource)) {\n        throw 'No shader found.';\n    }\n    gl.clearColor(1, 1, 1, 1);\n    gl.clearDepth(0);\n    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\n    gl.useProgram(shaderProgram);\n    const programInfo = {\n        pos: gl.getAttribLocation(shaderProgram, \"pos\"),\n        color: gl.getUniformLocation(shaderProgram, \"color\")\n    };\n    initBuffers(gl);\n    gl.vertexAttribPointer(programInfo.pos, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(programInfo.pos);\n    gl.uniform3fv(programInfo.color, color);\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n}\n\n```\n\n```css\n* {\n  box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  outline: none;\n  margin: 0;\n  padding: 0;\n}\n```\n\n","slug":"hello-world","published":1,"updated":"2023-01-31T15:10:07.077Z","_id":"cldk9wg6p0000wu3c38sb29ey","comments":1,"photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<p>$\\Delta x$<br>\n$$<br>\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s<br>\n$$</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">using</span> <span class=\"token namespace\">System</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">namespace</span> <span class=\"token namespace\">Test</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainClass</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Adder</span>\n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">private</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> c<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">public</span> <span class=\"token function\">Adder</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>c <span class=\"token operator\">=</span> c<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> a<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> b<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">+</span> c<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> args<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">Adder</span> adder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Adder</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">Func<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span> method <span class=\"token operator\">=</span> adder<span class=\"token punctuation\">.</span>Add<span class=\"token punctuation\">;</span>\n            Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> vertex <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> color <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0.8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nwindow<span class=\"token punctuation\">.</span>onload <span class=\"token operator\">=</span> initGL<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">initGL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> _a<span class=\"token punctuation\">,</span> _b<span class=\"token punctuation\">,</span> _c<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> gl <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_a <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"glcanvas\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _a <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> _a<span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"webgl\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> vsSource <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_b <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"vertex-shader\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _b <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> _b<span class=\"token punctuation\">.</span>textContent<span class=\"token punctuation\">,</span> fsSource <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_c <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fragment-shader\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _c <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> _c<span class=\"token punctuation\">.</span>textContent<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>gl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Browser does not support webgl.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>vsSource <span class=\"token operator\">&amp;&amp;</span> fsSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token string\">'No shader found.'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">clearColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">clearDepth</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span>gl<span class=\"token punctuation\">.</span><span class=\"token constant\">DEPTH_BUFFER_BIT</span> <span class=\"token operator\">|</span> gl<span class=\"token punctuation\">.</span><span class=\"token constant\">COLOR_BUFFER_BIT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> shaderProgram <span class=\"token operator\">=</span> <span class=\"token function\">initShaderProgram</span><span class=\"token punctuation\">(</span>gl<span class=\"token punctuation\">,</span> vsSource<span class=\"token punctuation\">,</span> fsSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">useProgram</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> programInfo <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token literal-property property\">pos</span><span class=\"token operator\">:</span> gl<span class=\"token punctuation\">.</span><span class=\"token function\">getAttribLocation</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">,</span> <span class=\"token string\">\"pos\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">color</span><span class=\"token operator\">:</span> gl<span class=\"token punctuation\">.</span><span class=\"token function\">getUniformLocation</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">,</span> <span class=\"token string\">\"color\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">initBuffers</span><span class=\"token punctuation\">(</span>gl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">vertexAttribPointer</span><span class=\"token punctuation\">(</span>programInfo<span class=\"token punctuation\">.</span>pos<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> gl<span class=\"token punctuation\">.</span><span class=\"token constant\">FLOAT</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">enableVertexAttribArray</span><span class=\"token punctuation\">(</span>programInfo<span class=\"token punctuation\">.</span>pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">uniform3fv</span><span class=\"token punctuation\">(</span>programInfo<span class=\"token punctuation\">.</span>color<span class=\"token punctuation\">,</span> color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">drawArrays</span><span class=\"token punctuation\">(</span>gl<span class=\"token punctuation\">.</span><span class=\"token constant\">TRIANGLES</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\"><span class=\"token selector\">*</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token property\">box-sizing</span><span class=\"token punctuation\">:</span> border-box<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">-webkit-box-sizing</span><span class=\"token punctuation\">:</span> border-box<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">-moz-box-sizing</span><span class=\"token punctuation\">:</span> border-box<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">outline</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> 0<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span> 0<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<p>$\\Delta x$<br>\n$$<br>\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s<br>\n$$</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">using</span> <span class=\"token namespace\">System</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">namespace</span> <span class=\"token namespace\">Test</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainClass</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Adder</span>\n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">private</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> c<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">public</span> <span class=\"token function\">Adder</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>c <span class=\"token operator\">=</span> c<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> a<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> b<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">+</span> c<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> args<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">Adder</span> adder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Adder</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">Func<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span> method <span class=\"token operator\">=</span> adder<span class=\"token punctuation\">.</span>Add<span class=\"token punctuation\">;</span>\n            Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> vertex <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> color <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0.8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nwindow<span class=\"token punctuation\">.</span>onload <span class=\"token operator\">=</span> initGL<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">initGL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> _a<span class=\"token punctuation\">,</span> _b<span class=\"token punctuation\">,</span> _c<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> gl <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_a <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"glcanvas\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _a <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> _a<span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"webgl\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> vsSource <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_b <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"vertex-shader\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _b <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> _b<span class=\"token punctuation\">.</span>textContent<span class=\"token punctuation\">,</span> fsSource <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_c <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fragment-shader\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> _c <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> _c<span class=\"token punctuation\">.</span>textContent<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>gl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Browser does not support webgl.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>vsSource <span class=\"token operator\">&amp;&amp;</span> fsSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token string\">'No shader found.'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">clearColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">clearDepth</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span>gl<span class=\"token punctuation\">.</span><span class=\"token constant\">DEPTH_BUFFER_BIT</span> <span class=\"token operator\">|</span> gl<span class=\"token punctuation\">.</span><span class=\"token constant\">COLOR_BUFFER_BIT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> shaderProgram <span class=\"token operator\">=</span> <span class=\"token function\">initShaderProgram</span><span class=\"token punctuation\">(</span>gl<span class=\"token punctuation\">,</span> vsSource<span class=\"token punctuation\">,</span> fsSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">useProgram</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> programInfo <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token literal-property property\">pos</span><span class=\"token operator\">:</span> gl<span class=\"token punctuation\">.</span><span class=\"token function\">getAttribLocation</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">,</span> <span class=\"token string\">\"pos\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">color</span><span class=\"token operator\">:</span> gl<span class=\"token punctuation\">.</span><span class=\"token function\">getUniformLocation</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">,</span> <span class=\"token string\">\"color\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">initBuffers</span><span class=\"token punctuation\">(</span>gl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">vertexAttribPointer</span><span class=\"token punctuation\">(</span>programInfo<span class=\"token punctuation\">.</span>pos<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> gl<span class=\"token punctuation\">.</span><span class=\"token constant\">FLOAT</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">enableVertexAttribArray</span><span class=\"token punctuation\">(</span>programInfo<span class=\"token punctuation\">.</span>pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">uniform3fv</span><span class=\"token punctuation\">(</span>programInfo<span class=\"token punctuation\">.</span>color<span class=\"token punctuation\">,</span> color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gl<span class=\"token punctuation\">.</span><span class=\"token function\">drawArrays</span><span class=\"token punctuation\">(</span>gl<span class=\"token punctuation\">.</span><span class=\"token constant\">TRIANGLES</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\"><span class=\"token selector\">*</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token property\">box-sizing</span><span class=\"token punctuation\">:</span> border-box<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">-webkit-box-sizing</span><span class=\"token punctuation\">:</span> border-box<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">-moz-box-sizing</span><span class=\"token punctuation\">:</span> border-box<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">outline</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> 0<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span> 0<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n"},{"layout":"post","title":"Effective C++","date":"2023-01-31T02:01:25.000Z","thumbnail":"/images/effectivecxx.png","cover":true,"toc":true,"plugins":["mathjax"],"_content":"# Effective C++\n\n## 一：C++基础\n\n### C++很成熟，很NB\n\nC++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）\n\n其核心是四个部分\n\n- C\n  - 区块block\n  - 语句statements\n  - 预处理器preprocessor\n  - 内置数据类型\n  - 数组arrays\n  - 指针pointers\n- Object-Orientend C++\n  - 类classes（构造函数，析构函数）\n  - 封装encapsulation\n  - 继承inheritance\n  - 多态polymorphism\n  - 虚函数virtual（动态绑定）\n- Template C++\n- STL\n\n### 替换#define\n\n使用编译器替代预处理器\n\n尽量使用const、enum定义常量，使用inlines定义函数宏\n\n#### const\n\n```c++\n#define PI 3.1415926\n```\n\n因为`#define`不是语言的一部分，在编译器开始工作前，`PI`就会被处理掉，所以一旦报错，你无法追踪到`PI`，只能看到`3.1415926`，这会**浪费你的时间**\n\n应该改为\n\n```c++\nconst double Pi 3.1415926;\n```\n\n值得注意的事\n\n- 定义常量指针指向char*-based字符串\n\n```c++\nconst char* const authorName = \"Reuben\";\n```\n\n- 作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员\n\n```c++\nclass GemePlayer{\nprivate:\n\tstatic const int NumTurns = 5;\t//这只是一个声明式\n\tint scores[NumTurns];\n};\nconst int GamePlayer::NumTurns;\t\t//这是定义式，因为在声明时已经赋值，所以这里就不赋值了\n```\n\nC++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式\n\n从这里可以看出，**const可以封装**，而#define不行\n\n#### enum\n\n```c++\nclass GemePlayer{\nprivate:\n\tenum { NumTurns = 5 };\n\tint scores[NumTurns];\n};\n```\n\n### const指针\n\nconst在星号左边，被指物是常量\n\n```c++\nchar greeting[] = \"Hello\";\nconst char* p = greeting;\n```\n\nconst在星号右边，指针本身是常量\n\n```c++\nchar greeting[] = \"Hello\";\nchar* const p = greeting;\n```\n\nconst在星号两边，被指物和指针都是常量\n\n```c++\nchar greeting[] = \"Hello\";\nconst char* const p = greeting;\n```\n\n### 确认对象在使用前已经被初始化\n\nC++初始化顺序\n\n- 基类比子类先初始化\n- 成员变量根据其声明次序初始化\n\n## 二：构造/析构/赋值\n\n### 空类的默认函数\n\n一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数\n\n一个类，如果没有构造函数，也会自动声明一个default构造函数\n\n这些函数都是public且inline的\n\n### 禁用自动生成的函数\n\n如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）\n\n- 你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）\n\n```c++\nclass HomeForSale{\nprivate:\n\tHomeForSale(const HomeForSale&);\n  HomeForSale& operator=(const HomeForSale&);\n};\n```\n\n可以制作一个不可被copy的类，让子类继承\n\n```c++\nclass Uncopyable{\nprotected:\n\tUncopyable(){}\n  ~Uncopyable(){}\nprivate:\n  Uncopyable(const Uncopyable&);\n  Uncopyable& operator=(const Uncopyable&);\n};\n\nclass HomeForSale: private Uncopyable{\n  ...\n};\n```\n\n### 为多态基类声明virtual析构函数\n\n#### 一定要有一个virtual析构函数\n\n- 如果这个类要成为一个基类，那么一定要有一个virtual析构函数\n\n在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错\n\n```c++\nclass TimeKeeper{\npublic:\n\t...\n};\nclass AtomicClock: public TimeKeeper {...};\nclass WaterClock: public TimeKeeper {...};\n```\n\n```c++\nTimeKeeper* ptk = getTimeKeeper();\t\t//创建一个动态分配对象\n...\ndelete ptk;\t//释放对象，避免资源泄漏\n```\n\n上面这个过程的问题其实出在`getTimeKeeper()`指向一个派生类（derived class）对象（比如`AtomicClock`），而这个对象却要经由一个基类（base class）指针删除（比如`TimeKeeper*`）\n\n如果这个基类的析构函数不是virtual的，就会出现问题：\n\n- 如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象\n\n解决方法就是给基类一个virtual析构函数\n\n```c++\nclass TimeKeeper{\npublic:\n\tTimeKeeper();\n  virtual ~TimeKeeper();\n  ...\n};\n```\n\n#### 最好不要有virtual析构函数\n\n- 如果这个类不可能成为基类，那么最好不要有virtual析构函数\n\n为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由**vptr（virtual table pointer）**指针携带，这个指针指向一个由函数指针构成的数组，称为**vtbl（virtual table）**，每一个带有virtual函数的类都有一个属于自己的vtbl\n\n**这个vtbl会增大对象的体积**，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍\n\n**这个vtbl会让代码失去兼容性**，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性\n\n#### 请不要继承没有virtual析构函数的类\n\n比如string、vector、list、set等等\n\n而且 C++没有像 Java的`final classes`或者C#的`sealed classes`的禁止派生机制\n\n### 不要在析构函数里抛出异常\n\n当一个`vector v`容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为\n\n有两个不怎么好的解决方法\n\n- 遇到异常，直接`std::abort()`，即遇到异常，宁愿直接强制停止程序，也不要让异常传播\n- 遇到异常，把异常记录下来，另程序继续运转，即**吞下异常**\n  - 这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好\n\n比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容\n\n```c++\nclass DBConnevtion{\npublic:\n    ...\n    static DBConnevtion create();\n    void close();     \n};\nclass DBConn{\npublic:\n    ...\n    void close()\t//封装给客户用的,关闭连接的函数\n    {\n        db.close();\n        closed = true;\n    }\n    ~DBConn(){\n        if(!closed){\n            try{\n                db.close();\n            }\n            catch(...){\n                ...\n                //强制关闭程序或者吞下异常\n            }\n        }\n    }\nprivate:\n    DBConnection db;\n    bool closed;\n};\n```\n\n### 不要在构造和析构过程中调用virtual函数\n\n在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果\n\n可以简单理解为**在C++中，基类构造期间，vritual函数不是vritual函数**\n\n因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数\n\n同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的\n\n### 令operator=返回一个对\\*this的引用\n\n连续赋值\n\n```c++\nx = y = z = 15;\n//其实就等于x = (y = (z = 15))；\n```\n\n为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参\n\n```c++\nclass Widget{\npublic:\n    Widget& operator=(const Widget& rhs)\n    {\n    \t...\n        return *this;\n    }\n    Widget& operator+=(const Widget& rhs){\n        ...\n        return *this;\n    }\n};\n```\n\n### 在operator=中处理自我赋值\n\n如果对象自己赋给自己，我们称之为自我赋值\n\n```c++\nw = w;\na[i] = a[j]; //当i=j时，自我赋值\n*px = *py;\t//px和py指向同一个物体时，自我赋值\n```\n\n在赋值操作中：\n\n1. 我们会先另左边的操作数先释放掉当前使用的数据\n2. 令其使用右操作数的副本\n3. 最后返回左操作数\n\n```c++\nclass Widget{\n    ...\nprivate:\n    Bitmap *pb;\n};\n//!!!这个不安全\nWidget& Widget::operator=(const Widget& rhs){\n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\n}\n```\n\n如果自我赋值，即rhs和pb指向同一个对象，那么`delete pb`后，这个对象就已经被销毁了，下面使用的`*rhs`就是一个已经被删除的对象\n\n解决方法1：延后delete\n\n```c++\nWidget& Widget::operator=(const Widget& rhs){\n    Bitmap* pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\n    delete pOrig;\n    return *this;\n}\n```\n\n解决方法2：使用copy and swap技术\n\n```c++\nWidget& Widget::operator=(const Widget& rhs){\n    Widget temp(rhs);\n    swap(temp);\t\t//令*this与temp交换\n    return *this;\n}\n```\n\n### 复制对象的一切\n\n如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错\n\n派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）\n\n所以copy函数需要\n\n- 复制所有local变量\n- 调用所有基类中的适当的copy函数\n\n## 三：资源管理\n\n### 让对象管理资源\n\n将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源\n\n- 申请资源后立即将其放进对象中，**资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）**\n- 在对象的析构函数中释放资源\n\nC++的`auto_ptr`是一个**类指针（pointer-like）对象**，也就是**智能指针**，其析构函数会自动delete掉其所指向的对象\n\n注意：\n\n- 不要让多个`auto_ptr`指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”\n- `auto_ptr`如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权\n\n**RCSP（引用计数型智能指针）**也是一种智能指针（比如`tr1::shared_ptr`），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源\n\n### 小心copy行为\n\n大多数RAII对象的copy函数：\n\n- 禁止复制\n- 采用引用计数法（RCSP）\n- 复制底部资源（深拷贝）\n- 转移底层资源所有权（auto_ptr）\n\n### 在资源管理类中提供对原始资源的访问\n\n有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）\n\n### new与delete一个数组\n\n一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？\n\n- 如果new了一个数组，就delete一个数组\n\n```c++\nstring* ptr1 = new string[100];\ndelete [] ptr1;\n```\n\n- 如果new了一个对象，就delete一个对象\n\n```c++\nstring* ptr2 = new string;\ndelete ptr2;\n```\n\n很多时候很难确定当前这个对象是数组还是一个对象\n\n```c++\ntypedef string AddressLines[4];\nstring* pal = new AddressLines;\ndelete [] pal;\n```\n\n最简单的方法是不用数组，使用STL里的容器，如`vector<string>`\n\n### 以独立语句将newed对象置入智能指针\n\nC++中调用一个函数，会先计算每一个传递进去的实参\n\n如果按下面的写法，将newed对象置入智能指针中\n\n```c++\n分配函数(shared_ptr<Widget>(new Widget), 资源访问);\t\t//不要这样写\n```\n\n需要执行一下函数\n\n- 调用“资源访问”函数（A）\n- 执行`new Widget`（B）\n- 调用`shared_ptr`构造函数（C）\n\n然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）\n\n如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏\n\n所以简单的方法是分离语句\n\n```c++\nshared_ptr<Widget> pw(new Widget);\n分配函数(pw, 资源访问);\n```\n\n## 四：设计与声明\n\n### 让接口容易被正确使用\n\n客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）\n\n#### 限制参数传递\n\n这是一个日期类\n\n```c++\nclass Date{\npublic:\n  Date(int month, int day, int year);\n  ...\n};\n...\nDate d(4, 20, 2022);\n```\n\n客户很有可能填错顺序，也有可能填入一个无效的参数\n\n可以使用**外覆类型（wrapper types）**，当然做出类会更好\n\n```c++\nstruct Day{\n  explict Day(int d) : val(d) {}\n  int val;\n};\nstruct Month{\n  explict Month(int m) : val(m) {}\n  int val;\n};\nstruct Year{\n  explict Year(int y) : val(y) {}\n  int val;\n};\nclass Date{\npublic:\n  Date(const Mouth& month, const Day& day, const Year& year);\n  ...\n};\n...\nDate d(Month(4), Day(20), Year(2022));\n```\n\n#### 一致性\n\n自定义的行为要与内置类型的行为一致，比如你不能把`operator*`重载成`operator+`\n\n或则像STL中，容器的接口都很一致，比如`size`、`push_back`等等\n\n### 设计class犹如设计type\n\n- 对象要如何创建和销毁\n- 对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）\n- 对象如果被值传递，意味着什么（深浅拷贝）\n- 约束成员变量的合法值\n- 是否可以/需要被继承\n- 能否类型转换，如何类型转换\n- 支持何种操作符\n- 成员变量的访问修饰\n- 成员函数的访问修饰\n- 未声明接口（undecided interface）\n- 是否需要定义模版\n- 真的需要一个新类吗？\n\n### 多用引用传递\n\nC++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些**很大的自定义类型**来说性能非常糟糕\n\n使用const引用传递会好很多\n\n- 不会创建新的对象\n- 不会改变原有对象\n- 可以避免**对象切割**问题\n  - 对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了\n\n只不过引用传递是大多是通过指针实现的，在处理一些**简单的内置类型**时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递\n\n### 必须返回对象时，不要返回引用\n\n如果必须返回对象，请不要返回引用（比如`operator*`，`operator==`），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个**右值**的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用\n\n### 将成员变量隐藏\n\n成员变量应该为private，而不是public\n\n- 客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）\n- 分离读写权限（这一点C#做的更好？）\n- 封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）\n- 便于对成员变量进行约束（更不容易出现异常值）\n- protected并不比public更具有封装性\n\n### 使用非成员函数\n\n- C#，java选手可以略过\n- C++标准库就是这样写的\n\n这里有一个类，其中有多个成员函数\n\n```c++\nclass WebBrowser{\npublic:\n\tvoid doA();\n  void doB();\n  void doC();\n  ...\n};\n```\n\n现在需要令一个函数做ABC三件事，有两种写法\n\n- 成员函数\n\n```c++\nclass WebBrowser{\npublic:\n\t...\n  void doEverything(){\n    doA();\n    doB();\n    doC();\n  }\n  ...\n};\n```\n\n- 非成员函数\n\n```c++\nvoid doEverything(WebBrowser& wb){\n\twb.doA();\n  wb.doB();\n  wb.doC();\n}\n```\n\n令人意外的是，第二种方法（使用非成员函数）更好\n\n#### 什么是封装\n\n一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强\n\n为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物\n\n#### 为什么第二种比第一种封装性更强\n\n因为第一种给用户两种调用方法，一个是调用成员函数`doEverything()`，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性\n\n- 注意第一种方法中，`doEverything()`和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利\n\n那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的**静态成员（static member）函数**即可\n\n或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）\n\n```c++\nnamespace WebBrowserStuff{\n\tclass WebBrowser{...};\n\tvoid doEverything(WebBrowser& wb){...}\n}\n```\n\n- 可拓展性更强\n  - 客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）\n\n- 可拆分\n  - 用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）\n\n### 如果所有参数都需要进行类型转换，使用非成员函数\n\n令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时\n\n比如一个有理数乘法\n\n```c++\nclass Rational{\npublic:\n  //这个类没有自定义的explict构造函数\n  const Rational opertaor* (const Rational& rhs) const;\n  ...\n};\n```\n\n```c++\nRational oneEighth(1,8);\nRational oneHalf(1,2);\nRational result = oneHalf * oneEighth;\t//成功\nresult = result * oneEighth;\t//成功\nresult = oneHalf * 2;\t\t//成功，等价于 result = oneHalf.operator*(2)\nresult = 2 * oneHalf;\t\t//失败，等价于 result = 2.operator*(oneHalf)\n```\n\n`result = oneHalf * 2;`为什么成功，因为这里发生了一次隐式转换，将`2`转化为了一个`Rational`类型\n\n在编译器中可能等价于\n\n```c++\nconst Rational temp(2);\nresult = oneHalf * temp;\n```\n\n- 如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将`2`转化为一个`Rational`类型\n\n`result = 2 * oneHalf;\t`为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时`2`就是一个int类型，没有我们所自定义的`operator*`函数，自然会失败\n\n可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）\n\n```c++\nconst Rational operator*(const Rational& lhs, const Rational& rhs){\n  return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());\n}\n```\n\n- 此外要极力避免使用**友元（friend）函数**\n- 成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数\n\n\n\n### 写一个不抛异常的swap函数\n\nswap函数原本是STL的一部分，后来称为了**异常安全性编程**的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要\n\nstd是一个很特殊的命名空间，客户可以**全特化**（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定\n\n全特化：针对某个类做模板函数的特例，如对`std::swap`做一个针对`Widget`的特化\n\n```c++\nclass WidgetImpl{...};\t\t//这个类的对象中存储着真正的数据\nclass Widget{\npublic:\n    Widget& operator=(const Widget& rhs){\n        ...\n        *pImpl = *(rhs.pImpl);\n        ...\n    }\n    ...\n    void swap(Widget& other){\t//这个函数决对不可抛异常\n        using std::swap;\n        swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针\n    }\n    ...\nprivate:\n    WidgetImple* pImpl;\t\t//这个类有一个指向资源对象的指针\n};\nnamespace std{\n\ttemplate<>\n    void swap<Widget>(Widget& a, Widget& b){\t//这个可以抛异常\n        a.swap(b);\t\n    }\n}\n```\n\n此外，C++的STL容器就是上面这种写法，提供了`public swap`成员函数和`std::swap`的特化版本\n\n## 五：实现（Implementations）\n\n- 随意定义变量可能会导致性能降低\n- 过度使用转型（casts）可能会导致性能降低，难以维护，可读性低\n- 返回对象的内部数据的handles，可能会破坏封装\n- 未考虑异常可能会导致资源泄露和数据败坏\n- 过度使用inline可能会导致包体膨胀\n- 过度耦合（coupling）可能会增加构建时间（build times）\n\n### 尽量延后变量定义式的出现时间\n\n#### 避免未曾使用的变量\n\n如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过\n\n此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、\n\n#### 避免无意义的默认构造函数\n\n如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好\n\n#### 循环\n\n此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？\n\n**循环内**\n\n```c++\nfor(int i = 0; i < n; i++){\n  Widget w(...);\n  ...\n}\n```\n\n- n个构造函数+n个析构函数\n\n- 如果`Widget`是一个很敏感的类，这样会让其作用域更小，更容易理解和维护\n\n**循环外**\n\n```c++\nWidget w;\nfor(int i = 0; i < n; i++){\n  w = ...;\n  ...\n}\n```\n\n- 一个构造函数+一个析构函数+n个赋值操作\n- 如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）\n\n### 少做转型\n\nC++是强类型语言，设计目标应该是保证类型错误绝不发生，然而**类型转换**破坏了类型系统\n\nJava、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险\n\nC++的类型转化\n\n- 旧式转换\n  - `(T)expression`\n  - `T(expression)`\n- 新式转换\n  - `const_cast<T>(expression)`\n    - 用于将对象的**常量性转除（cast away the constness）**\n    - 比如将`const`转化为`non-const`\n  - `dynamic_cast<T>(expression)`\n    - 用来**安全向下转型**\n    - 无法由旧式语句执行\n    - 耗费巨大\n  - `reinterpret_cast<T>(expression)`\n    - 用于低级转型，实际操作取决于编译器，不可移植\n    - 极其少用\n  - `static_cast<T>(expression)`\n    - 用于**强迫隐式转换（implicit conversions）**\n    - 比如`non-const`转化为`const`，`int`转化为`double`，`void*`转化为`typed`，基类指针转化为派生类指针\n\n避免C++类型转换出问题的核心是**避免使用基类的接口处理派生类**\n\n#### 一个对象多个地址\n\nC++很神奇，如果一个基类指针指向一个派生类对象，如\n\n```C++\nDervied d;\nBase* b = &d;\n```\n\n这可能会导致两个指针值不一样，即这个对象有两个地址，一个`Derivied*`指针一个`Base*`指针，这派生类指针上往往会有一个**偏移量（offset）**，通过这个偏移量，可以通过派生类指针找到基类指针\n\n上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以**请不要假定对象在C++中如何布局**，更不应该基于这个假设对对象进行类型转换\n\n如果你想让当前对象调用基类的函数，如果对`*this`做强制转化，转换为基类，`*this`其实是先前产生的`*this`对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题\n\n```c++\nclass SpecialWindow: public Window{\npublic:\n  virtual void onResize(){\n    //static_cast<Window>(*this).onResize();\t//这样不好\n    Window::onResize();\t\t//请用这种方式调用基类的onResize函数（作用到当前对象上）\n    ...\n  }\n}\n```\n\n#### dynamic_cast\n\n这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象\n\n什么时候使用这个东西？当**你想在**一个你认为是派生类对象的**对象上执行**派生类的操作**函数**，但你手里却只有一个指向基类的引用/指针时\n\n解决方法：\n\n- 使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器\n- 在基类中提供virtual函数\n\n### 避免返回指向对象内部成分的handles\n\n前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便\n\n但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的\n\n```c++\nclass Point{\npublic:\n  ...\n  void setX(int val);\n  ...\n};\nstruct RectData{\n  Point ulhc;\t\t//upper left hand corner\n  Point lrhc;\t\t//lower right hand corner\n};\nclass Rectangle{\npublic:\n  ...\n  Point& upperLeft() const { return pData->ulhc; }\t//这样返回了引用，非常不好\n  ...\nprivate:\n  std::tr1::shared_ptr<RectData> pData;\n};\n...\nrec.upperLeft().setX(50);\t\t//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改\n```\n\n`upperLeft`函数本来只是为了提供给客户获得（get）`Rectangle`的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了`Rectangle`本身，而且还是一个内部数据`RectData`\n\n为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）\n\n解决方法很简单，只要让handles不可以被修改，就可以了\n\n```c++\nclass Rectangle{\npublic:\n  ...\n  const Point& upperLeft() const { return pData->ulhc; }\t\n  ...\n};\n```\n\n但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致**dangling handles（空悬的号码牌）**，比如返回了一个对local变量的引用，依然特别危险\n\n当然，有的时候不得不返回handles，比如`operator[]`\n\n### 异常安全性很重要\n\n**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：\n\n- 不泄漏任何资源\n- 不允许数据败坏\n\n不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂\n\n三个保证：\n\n- 基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏\n- 强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过`copy-and-swap`实现）\n- 不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）\n\n**异常安全码**必须提供上述三种保障之一，如果不能保障，则不具备异常安全性\n\n### 了解inline函数\n\n内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化\n\n缺点也很明显，会让包体变大，会导致**换页行为（paging）**，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数\n\n内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联\n\n### 降低文件间的编译依存\n\n如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译\n\n为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用）\n\n这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类\n\n*话说应该不会有人不知道implementation是实现的意思吧*\n\n```c++\nclass PersonImpl;\t//pimpl写法，这是Person类的前置声明\nclass Data;\t\t\t\t//Data的前置声明\nclass Address;\t\t//Address的前置声明\n\nclass Persion{\t//像这样使用pimpl的类，往往被称为Handle classes\npublic:\n  ...\n  std::string name() const;\n  ...\nprivate:\n  std::tr1::shared_ptr<PersonImpl> pImpl;\n};\n```\n\n在这种设计下，`Person`就与`Data`、`Address`以及`Persons`的实现分离了，改动这些类也不会导致使用`Person`的客户重新编译，客户无法看到`Person`的实现细节，真正实现**接口与实现分离**\n\n这个操作的本质是用**声明的依赖性**替换**定义的依赖性**\n\n此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明\n\n此外还有另一种制作`Handle class`的方法，就是令`Person`成为一个特殊的抽象基类，称为`Interface class`，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）\n\n```c++\nclass Person{\t\t//Interface class\npublic:\n  virtual ~Person();\n  virtual std::string name() const = 0;\n  ...\n};\nclass Person{\t\t//具现化\npublic:\n  static std::tr1::shared_ptr<Person> create(const std::string& name...);\n  ...\n};\n...\n//使用\nstd::tr1::shared_ptr<Person> pp(Person::create(name...));\nstd::cout << pp->name();\n```\n\n```c++\nclass RealPerson: public Person{\t\npublic:\n  RealPerson(const std::string& name, ...): theName(name), ...{}\n  virtual ~RealPerson() {}\n  std::string name() const;\t\t\n  ...\nprivate:\n\tstd::string theName;\n};\nstd::string ReakPerson::name(){...}\nstd::tr1::shared_ptr<Person> Person::create(const std::string& name, ...){\n  retrun std::tr1::shared_ptr<Person>(new RealPerson(name, ...));\n}\n```\n\n## 六：继承与面向对象\n\n- `is-a`：是一个\n- `has-a`：有一个\n- `is-implemented-in-terms-of`：根据xx实现出\n\n### public继承是is-a关系\n\n```c++\nclass Student: public Person{...};\t//Student is a Person\n```\n\n每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化\n\n**public继承下，可以把子类当父类用**，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用\n\n这就出现了一个问题，子类一定要`is a`父类，不然会出现问题\n\n错误的继承：\n\n- 企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？\n- 正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？\n\n### 避免遮掩父类成员\n\n```c++\nint x;\nvoid Fun(){\n    double x;\n    ...\n}\n```\n\n由于**作用域**的**名称遮掩规则**，函数内部的local变量x覆盖了全局变量x\n\n#### 子类名称会遮掩父类名称，在public继承下是错误的\n\n在OOP中，如果子类重载了父类的`non-virtual`函数，就意味着子类使用同名函数遮掩了父类函数，就意味着**这个父类函数没有被子类继承！**，那么在这种情况下，继承就不是`is-a`关系了\n\n**在public继承下，子类继承了父类的一切**\n\n```c++\nclass Base{\npublic:\n    virtual void f1() = 0;\n    virtual void f1(int);\n    void f2();\n    void f2(double);\n    ...\nprivate:\n    int x;\n};\nclass Derived: public Base{\npublic:\n    virtual void f1();\n    void f2();\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)\n```\n\n#### 将被遮掩的名称重见天日\n\n解决起来很简单，只需要让父类的函数在子类作用域内可见，可以**使用using关键字**\n\n```c++\nclass Derived: public Base{\npublic:\n    using Base::f1;\n    using Base::f2;\n    virtual void f1();\n    void f2();\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//正确，调用Base::f1\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//正确，调用Base::f2\n```\n\n如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以**使用转交函数**，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中\n\n```c++\nclass Derived: private Base{\npublic:\n    virtual void f1(){\n        Base::f1();\t\t//inline转交函数\n    }\n    ...\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1\n```\n\n### 区分接口继承和实现继承\n\npublic继承分为两个部分\n\n- 函数接口继承\n- 函数实现继承\n\n|                 | 接口继承 | 实现继承         |\n| --------------- | -------- | ---------------- |\n| 纯虚函数        | 具体指定 | 不继承           |\n| 非纯虚函数      | 具体指定 | 继承一份缺省实现 |\n| non-virtual函数 | 具体指定 | 继承一份强制实现 |\n\n### 考虑使用virtual以外的选择\n\n#### 基于NVI的Template Method模式\n\nNon-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数\n\n```c++\nclass GameCharacter{\npublic：\n    int healthValue() const\n\t{\n    \t...\n    \tint retVal = doHealthValue();\n    \t...\n    \treturn retVal;\n\t}\nprivate：\n    virtual int doHealthValue() const\n    {\n\t\t...\n    }\n};\n```\n\n其中`healthValue()`被称为virtual函数的**外覆器（wrapper）**\n\n#### 基于函数指针的Strategy模式\n\n```c++\nclass GameCharacter;\nint defaultHealthCalc(const GameCharacter& gc);\nclass GameCharacter{\npublic:\n    typedef int (*HealthCalcFunc)(const GameCharacter&);\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf){}\n    int healthValue() const { return healthFunc(*this); }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\n在这种模式下，`defaultHealthCalc`函数不再是`GameCharacter`体系内的成员函数，通过修改函数指针，就可以让`GameCharacter`使用不同种类的计算函数，弹性更强，而且可以在运行时变更\n\n此外`defaultHealthCalc`函数不需要/不能访问`GameCharacter`内的`non-public`部分，\n\n####  基于tr1::function的Strategy模式\n\n上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如`tr1::function`对象\n\n```c++\nclass GameCharacter;\nint defaultHealthCalc(const GameCharacter& gc);\nclass GameCharacter{\npublic:\n    typedef std::tr1::function<int (const GameCharacter&)> HealthCalcFunc;\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf){}\n    int healthValue() const { return healthFunc(*this); }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\n#### 古典的Strategy模式\n\n```c++\nclass GameCharacter;\nclass HealthCalcFunc{\npublic:\n    ...\n    virtual int calc(const GameCharacter& gc) const{...}\n    ...\n};\nHealthCalcFunc defaultHealthCalc;\nclass GameCharacter{\npublic:\n    explicit GameCharacter(HealthCalcFunc* phcf = &defaultHealthCalc): pHealthFunc(phcf){}\n    int healthValue() const { return phealthFunc->calc(*this); }\n    ...\nprivate:\n    HealthCalcFunc* pHealthFunc;\n};\n```\n\n### 绝不重新定义继承而来的non-virtual函数\n\n- 静态绑定（staticcally bound）：non-virtual就是这种\n- 动态绑定（dynamically bound）：virtual就是这种\n\n```c++\nclass B{\npublic:\n\tvoid f();\n\t...\n};\nclass D: public B{\npublic:\n  void f();\n  ...\n};\n...\nD x;\nB* pB = &x;\nD* pD = &x;\npB->f();\t//调用B::f\npD->f();\t//调用D::f\n```\n\n### 绝对不重新定义继承而来的缺省参数值\n\n**virtual函数是动态绑定的，缺省参数值是静态绑定的**\n\n```c++\nclass Cricle: public Shape{...};\n...\nShape* p1;\t//p1的静态类型是Shape*，没有动态类型\nShape* p2 = new Circle;\t//p2的静态类型是Shape*，动态类型是Circle*\n```\n\n- 静态类型\n  - 指针的类型就是**静态类型**\n- 动态类型\n  - 所指向的对象的类型是**动态类型**\n  - 动态类型可以通过赋值等操作改变\n\nvirtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载\n\n但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数\n\n### has-a和根据xx实现出\n\n一个类中有多个小类，这种关系被称为**复合（composition）**，其中这些小类被称为**合成成分物（composed object）**\n\n- 在应用域，复合意味着`has-a`\n  - 人有名字（也不尽然）\n- 在实现域，复合意味着`is-implemented-in-terms-of`\n  - 队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）\n\n### 少用private继承\n\n*经典 C++糟粕，请问 C#有这个吗？*\n\n本质上是一种`is-implemented-in-terms-of`关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术\n\n- private继承，编译器无法自动将子类对象转化为父类对象\n- private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）\n\n**尽量使用复合来替代pirvate继承**，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数\n\n此外private继承的对象有可能比复合的对象要小\n\n### 少用多重继承\n\n*经典 C++糟粕，请问 C#有这个吗？*\n\n- 可能会导致歧义\n  - 当然你可以在调用函数的时候指出是来自哪一个基类\n- 可能会导致菱形继承\n  - 菱形继承可能会导致变量重复\n\n## 七：模版与泛型\n\n模板（templates）是泛型编程（generic programming）的基础\n\n模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译\n\n### 评价\n\n优点：\n\n1. 模板编程能够实现非常灵活且类型安全的接口\n2. 极好的性能（更小的文件、更短的运行期，更少的内存需求）\n3. 可以将一些运行时才能侦测到的错误，在编译期找出来\n\n缺点：\n\n1. 难以编程和维护\n2. 编译报错信息难以理解\n3. 难以重构\n4. 编译时间大幅变长\n\n因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释\n\n### 隐式接口和编译期多态\n\n- OOP中经常使用显式接口和运行时多态\n- 泛型编程更多使用隐式接口和编译期多态\n\n```C++\ntemplate<typename T>\nvoid doProcessing(T& w)\n{\n    if(w.size() > 10 && w != someNastyWidget){\n        T temp(w)\n        temp.normalize();\n        temp.swap(w);\n    }\n}\n```\n\n从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组**隐式接口**\n\n所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功\n\n这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是**编译期多态**\n\n### Traits\n\n一种约定俗成的技术方案，为同一类数据提供统一的操作函数\n\n比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。\n\n```C++\nenum Type{\n    TYPE_1;\n    TYPE_2;\n};\nclass FOO{\n    Type type = Type::TYPE_1;\n};\nclass Bar{\n    Type type = Type::TYPE_2;\n};\n//统一的模板函数\ntemplate<typename T>\nvoid decode(const T& data, char* buf){\n    if(T::type == Type::TYPE_1){\n        ...\n    }\n    else if(T::type == Type::TYPE_2){\n        ...\n    }\n}\n```\n\n但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术\n\n```C++\nenum Type{\n    TYPE_1;\n    TYPE_2;\n};\nclass FOO{\n    Type type = Type::TYPE_1;\n};\nclass Bar{\n    Type type = Type::TYPE_2;\n};\n\ntemplate<typename T>\nstruct type_traits{\n    Type type = T::type;\n}\n//为内置数据类型特化为独有的 type_traits\ntemplate<typename int>\nstruct type_traits{\n    Type type = Type::TYPE_1;\n}\n//统一的模板函数\ntemplate<typename T>\nvoid decode(const T& data, char* buf){\n    if(type_traits<T>::type == Type::TYPE_1){\n        ...\n    }\n    else if(type_traits<T>::type == Type::TYPE_2){\n        ...\n    }\n}\n```\n\n该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因\n\n### 模板元编程\n\nTMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化\n\n如果一门语言具备以下功能，则称为图灵完全\n\n1. 数值运算和符号运算\n2. 判断\n3. 递归\n\n#### 数值运算+递归\n\n```C++\n//一个TMP计算阶乘，而且阶乘的技术发生在编译期\ntemplate<unsigned n>\nstruct Factorial\n{\n    enum { value = n * Factorial<n-1>::value };\n};\ntemplate<>\nstruct Factorial<0>\n{\n    enum { value = 1 };\n};\n\nint main()\n{\n    std::cout << Factorial<5>::value;\n}\n```\n\nC++11TMP这种函数式编程得到了加强，上文也可以这样写\n\n```C++\ntemplate<unsigned n>\nstruct Factorial\n{\n    constexpr static auto value{ n * Factorial<n - 1>::value };\n};\ntemplate<>\nstruct Factorial<0>\n{\n    constexpr static auto value = 1;\n};\n```\n\n#### 判断\n\n```C++\ntemplate<bool Value>\nstruct if_constexpr\n{\n    constexpr static auto value = 1;\n};\n\ntemplate<>\nstruct if_constexpr<false> {\n    constexpr static auto value = 2;\n};\n\nint main()\n{\n    std::cout << if_constexpr<true>::value << std::endl;\n    std::cout << if_constexpr<false>::value << std::endl;\n}\n```\n\n### typedef\n\n在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名\n\n下面是一个函数指针的示例\n\n```C++\nvoid add(int x, int y) {\n    std::cout << \"x+y=\" << x + y << std::endl;\n}\nvoid dec(int x, int y) {\n    std::cout << \"x-y=\" << x - y << std::endl;\n}\nvoid mul(int x, int y) {\n    std::cout << \"x*y=\" << x*y << std::endl;\n}\n\nvoid (*op[3])(int, int) = { add, dec, mul };\n\nint main()\n{\n    for (int i = 0; i < 3; ++i) {\n        （*op[i])(4, 3);\n    }\n}\n```\n\n如果使用typedef\n\n```C++\ntypedef void (*Func[3])(int, int);\nFunc f = { add, dec, mul };\n\nint main()\n{\n    for (int i = 0; i < 3; ++i) {\n        f[i](4, 3);\n    }\n}\n```\n\n## 八：定制new和delete\n\nJava和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目\n\n### new-handler\n\n当`operator new`无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即`new-handler`\n\n使用`set_new_handler`来指定`new-handler`\n\n```c++\nvoid outOfMem(){\n  std::cerr << \"内存不足\\n\";\n  std::abort();\n}\nint main(){\n  std::set_new_handler(outOfMem);\t\t//该函数的参数是一个函数指针\n  int* array = new int[10000000L];\n  ...\n}\n```\n\n当`operator new`无法满足内存申请时，会不断调用`new-handler`函数，直到找到足够的内存，所以`new-handler`函数应该满足\n\n- 让更多的内存可被使用\n  - 实现方法是程序开始时就分配一大块内存，每次调用`new-handler`时就释放一点点\n- 安装另一个`new-handler`\n  - 如果现在这个`new-handler`无法获取更多内存，需要知道哪一个`new-handler`具备增大内存的实力，然后使用`set_new_handler`来替换自己\n- 卸除`new-handler`\n  - 通过`set_new_handler`赋值`null`，将`new-handler`卸载，使得在内存分配不足时，会抛异常\n- 抛出`bad_alloc`异常\n  - 这种异常不会被`operator new`捕获，会被传播至内存索求处\n- 不反回\n  - 调用`abort`或者`exit`\n\n```c++\nclass NewHandlerHolder{\npublic:\n  explicit NewHandlerHolder(std::new_handler nh): handler(nh) {}\t//获取当前的new_handler\n  ~NewHandlerHolder() { std::set_new_handler(handler); }\t\nprivate:\n  std::new_handler handler;\t\t//用于记录当前的new_handler\n};\nvoid* Widget::operator new(std::size_t size) throw(std::bad_alloc){\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\t//安装Widget的new-handler\n  return ::operator new(size);\t//分配对象或者抛异常\n}\n//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值\n```\n\n```c++\nvoid outOfMem();\nWidget::set_new_handler(outOfMem);\nWidget* pwl = new Widget;\t//内存不足时会调用outOfMem\n```\n\nmixin风格的写法\n\n```c++\ntemplate<typename T>\nclass NewHandlerSupport{\npublic:\n  static std::new_handler_set set_new_handler(std::new_handler p) throw();\n  static void* operator new(std::size_t size) throw(std::bad_alloc);\n  ...\nprivate:\n  static std::new_handler currentHandler;\n};\n\ntemplate<typename T>\nstd::new_handler NewHandlerSupport<T>::set_new_handler(std::new_handler p) throw(){\n  std::new_handler oldHandler = currentHandler;\n  currentHandler = p;\n  return oldHandler;\n}\n\ntemplate<typename T>\nvoid* NewHandlerSupport<T>::operator new(std::size_t size) throw(std::bad_alloc){\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\n  return ::operator new(size);\n}\n```\n\n```c++\nclass Widget: public NewHandlerSupport<Widget>{\n\t...\n};\n```\n\n像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为**怪异的循环模版模式（curiously recurring template pattern，CRTP）**\n\n### 替换new和delete的时机\n\nC++中所有的news返回的指针都必须要**地址对齐**，int要4对齐，double要8对齐\n\n写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换\n\n### 编写new和delete的规则\n\n如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则\n\n- new\n  - 应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用`new-handler`\n  - 有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）\n  - new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理**比正确大小更大的（错误）申请**\n\n- delete\n  - 收到null指针时不做任何事\n  - 处理**比正确大小更大的（错误）申请**\n\n### 编写new时也要写对应的delete\n\n```c++\nWidget* pw = new Widget;\n```\n\n在这里调用了两个函数，一个时用以分配内存的`operator new`，一个是`Widget`的构造函数\n\n如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的\n\n运行时系统会调用`operator new`所对应的`operator delete`来释放地址，对于拥有正常签名式的new和delete来说不成问题\n\n```c++\nvoid* operator new(std::size_t) throw(std::bad_alloc);\t//普通的new\nvoid operator delete(void* rawMemory) throw();\t//global中的普通的new\nvoid operator delete(void* rawMemory, std::size_t size) throw();\t//class中的new\n```\n\n但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题\n\n```c++\nvoid* operator new(std::size_t, void* pMemory) throw();\t//placement new，比普通new多带一个参数\n\nWidget* pw = new (std::cerr) Widget;\t//调用operator new，并以cerr作为其实参\n```\n\n当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的`operator new`时如何运作的，所以运行时系统会去寻找**参数个数与类型**都与`operator new`相同的某个`operator delete`\n\n```c++\nvoid operator delete(void*, std::ostream&) throw();\t//palcement delete\n```\n\n```c++\nclass Widget{\npublic:\n  static void* operator new(std::size_t size, std::ostream& logStream) throw(std::bad_alloc);\n  static void operator delete(void* pMemory) throw();\n  static void operator delete(void* pMemoty, std::ostream& logStream) throw();\n  ...\n};\n```\n\n如果此时调用`delete pw`，只会调用普通的`delete`，因为只有在构造时发生异常时，运行时系统才会调用placement delete\n\n最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete\n\n## 九：杂项\n\n### 不要忽视编译器警告\n\n很多人忽视警告，毕竟一个问题如果真的很严重，应该报错\n\n比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为\n\n```c++\nclass B{\npublic:\n  virtual void f() const;\n};\nclass D: public B{\n  virtual void f();\n};\n```\n\n报警告\n\n```c++\nwarning: D::f() hides virtual B::f()\n```\n\n原本的目的是为了在D中重新定义virtual函数`f()`，但由于B中`f()`是const，在D中不是，此时B中的`f()`并没有在D中重新被声明，而是被整个遮掩了\n\n### 去熟悉标准程序库\n\n尤其是TR1\n\n#### C++98有什么\n\n- STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器\n- Iostream\n- 国际化支持\n- 数值处理，包括复数（complex）和纯数值数组（valarray）\n- 异常阶层体系\n- C89标准程序库\n\n#### TR1有什么（全在`std::tr1`中）\n\n- 智能指针`tr1::shared_ptr`和`tr1::weak_ptr`\n- `tr1::function`\n- `tr1::bind`\n\n和（彼此无关的独立组件）\n\n- 哈希表\n- 正则表达式\n- Tuple变量组\n- `tr1::array`\n- `tr1::mem_fn`\n- `tr1::reference_wrapper`\n- 随机数生成工具\n- 数学特殊函数\n- C99兼容\n\n和（基于template）\n\n- Type traits\n- `tr1::result_of`\n\n### 熟悉Boost\n\n\n\n\n\n\n\n","source":"_posts/Effective C++.md","raw":"---\nlayout: post\n# 标题\ntitle: Effective C++  \n# 发布时间\ndate: 2023/1/31 10:01:25  \n# 分类\ncategories: [program] \n# 标签\ntags:\n  - C++\n# 作者\n#author: Reuben\n# 缩略图\nthumbnail: /images/effectivecxx.png \n# 显示封面\ncover: true\n# 显示目录\ntoc: true\n# 启用插件\nplugins:\n  - mathjax\n---\n# Effective C++\n\n## 一：C++基础\n\n### C++很成熟，很NB\n\nC++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）\n\n其核心是四个部分\n\n- C\n  - 区块block\n  - 语句statements\n  - 预处理器preprocessor\n  - 内置数据类型\n  - 数组arrays\n  - 指针pointers\n- Object-Orientend C++\n  - 类classes（构造函数，析构函数）\n  - 封装encapsulation\n  - 继承inheritance\n  - 多态polymorphism\n  - 虚函数virtual（动态绑定）\n- Template C++\n- STL\n\n### 替换#define\n\n使用编译器替代预处理器\n\n尽量使用const、enum定义常量，使用inlines定义函数宏\n\n#### const\n\n```c++\n#define PI 3.1415926\n```\n\n因为`#define`不是语言的一部分，在编译器开始工作前，`PI`就会被处理掉，所以一旦报错，你无法追踪到`PI`，只能看到`3.1415926`，这会**浪费你的时间**\n\n应该改为\n\n```c++\nconst double Pi 3.1415926;\n```\n\n值得注意的事\n\n- 定义常量指针指向char*-based字符串\n\n```c++\nconst char* const authorName = \"Reuben\";\n```\n\n- 作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员\n\n```c++\nclass GemePlayer{\nprivate:\n\tstatic const int NumTurns = 5;\t//这只是一个声明式\n\tint scores[NumTurns];\n};\nconst int GamePlayer::NumTurns;\t\t//这是定义式，因为在声明时已经赋值，所以这里就不赋值了\n```\n\nC++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式\n\n从这里可以看出，**const可以封装**，而#define不行\n\n#### enum\n\n```c++\nclass GemePlayer{\nprivate:\n\tenum { NumTurns = 5 };\n\tint scores[NumTurns];\n};\n```\n\n### const指针\n\nconst在星号左边，被指物是常量\n\n```c++\nchar greeting[] = \"Hello\";\nconst char* p = greeting;\n```\n\nconst在星号右边，指针本身是常量\n\n```c++\nchar greeting[] = \"Hello\";\nchar* const p = greeting;\n```\n\nconst在星号两边，被指物和指针都是常量\n\n```c++\nchar greeting[] = \"Hello\";\nconst char* const p = greeting;\n```\n\n### 确认对象在使用前已经被初始化\n\nC++初始化顺序\n\n- 基类比子类先初始化\n- 成员变量根据其声明次序初始化\n\n## 二：构造/析构/赋值\n\n### 空类的默认函数\n\n一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数\n\n一个类，如果没有构造函数，也会自动声明一个default构造函数\n\n这些函数都是public且inline的\n\n### 禁用自动生成的函数\n\n如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）\n\n- 你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）\n\n```c++\nclass HomeForSale{\nprivate:\n\tHomeForSale(const HomeForSale&);\n  HomeForSale& operator=(const HomeForSale&);\n};\n```\n\n可以制作一个不可被copy的类，让子类继承\n\n```c++\nclass Uncopyable{\nprotected:\n\tUncopyable(){}\n  ~Uncopyable(){}\nprivate:\n  Uncopyable(const Uncopyable&);\n  Uncopyable& operator=(const Uncopyable&);\n};\n\nclass HomeForSale: private Uncopyable{\n  ...\n};\n```\n\n### 为多态基类声明virtual析构函数\n\n#### 一定要有一个virtual析构函数\n\n- 如果这个类要成为一个基类，那么一定要有一个virtual析构函数\n\n在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错\n\n```c++\nclass TimeKeeper{\npublic:\n\t...\n};\nclass AtomicClock: public TimeKeeper {...};\nclass WaterClock: public TimeKeeper {...};\n```\n\n```c++\nTimeKeeper* ptk = getTimeKeeper();\t\t//创建一个动态分配对象\n...\ndelete ptk;\t//释放对象，避免资源泄漏\n```\n\n上面这个过程的问题其实出在`getTimeKeeper()`指向一个派生类（derived class）对象（比如`AtomicClock`），而这个对象却要经由一个基类（base class）指针删除（比如`TimeKeeper*`）\n\n如果这个基类的析构函数不是virtual的，就会出现问题：\n\n- 如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象\n\n解决方法就是给基类一个virtual析构函数\n\n```c++\nclass TimeKeeper{\npublic:\n\tTimeKeeper();\n  virtual ~TimeKeeper();\n  ...\n};\n```\n\n#### 最好不要有virtual析构函数\n\n- 如果这个类不可能成为基类，那么最好不要有virtual析构函数\n\n为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由**vptr（virtual table pointer）**指针携带，这个指针指向一个由函数指针构成的数组，称为**vtbl（virtual table）**，每一个带有virtual函数的类都有一个属于自己的vtbl\n\n**这个vtbl会增大对象的体积**，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍\n\n**这个vtbl会让代码失去兼容性**，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性\n\n#### 请不要继承没有virtual析构函数的类\n\n比如string、vector、list、set等等\n\n而且 C++没有像 Java的`final classes`或者C#的`sealed classes`的禁止派生机制\n\n### 不要在析构函数里抛出异常\n\n当一个`vector v`容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为\n\n有两个不怎么好的解决方法\n\n- 遇到异常，直接`std::abort()`，即遇到异常，宁愿直接强制停止程序，也不要让异常传播\n- 遇到异常，把异常记录下来，另程序继续运转，即**吞下异常**\n  - 这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好\n\n比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容\n\n```c++\nclass DBConnevtion{\npublic:\n    ...\n    static DBConnevtion create();\n    void close();     \n};\nclass DBConn{\npublic:\n    ...\n    void close()\t//封装给客户用的,关闭连接的函数\n    {\n        db.close();\n        closed = true;\n    }\n    ~DBConn(){\n        if(!closed){\n            try{\n                db.close();\n            }\n            catch(...){\n                ...\n                //强制关闭程序或者吞下异常\n            }\n        }\n    }\nprivate:\n    DBConnection db;\n    bool closed;\n};\n```\n\n### 不要在构造和析构过程中调用virtual函数\n\n在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果\n\n可以简单理解为**在C++中，基类构造期间，vritual函数不是vritual函数**\n\n因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数\n\n同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的\n\n### 令operator=返回一个对\\*this的引用\n\n连续赋值\n\n```c++\nx = y = z = 15;\n//其实就等于x = (y = (z = 15))；\n```\n\n为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参\n\n```c++\nclass Widget{\npublic:\n    Widget& operator=(const Widget& rhs)\n    {\n    \t...\n        return *this;\n    }\n    Widget& operator+=(const Widget& rhs){\n        ...\n        return *this;\n    }\n};\n```\n\n### 在operator=中处理自我赋值\n\n如果对象自己赋给自己，我们称之为自我赋值\n\n```c++\nw = w;\na[i] = a[j]; //当i=j时，自我赋值\n*px = *py;\t//px和py指向同一个物体时，自我赋值\n```\n\n在赋值操作中：\n\n1. 我们会先另左边的操作数先释放掉当前使用的数据\n2. 令其使用右操作数的副本\n3. 最后返回左操作数\n\n```c++\nclass Widget{\n    ...\nprivate:\n    Bitmap *pb;\n};\n//!!!这个不安全\nWidget& Widget::operator=(const Widget& rhs){\n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\n}\n```\n\n如果自我赋值，即rhs和pb指向同一个对象，那么`delete pb`后，这个对象就已经被销毁了，下面使用的`*rhs`就是一个已经被删除的对象\n\n解决方法1：延后delete\n\n```c++\nWidget& Widget::operator=(const Widget& rhs){\n    Bitmap* pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\n    delete pOrig;\n    return *this;\n}\n```\n\n解决方法2：使用copy and swap技术\n\n```c++\nWidget& Widget::operator=(const Widget& rhs){\n    Widget temp(rhs);\n    swap(temp);\t\t//令*this与temp交换\n    return *this;\n}\n```\n\n### 复制对象的一切\n\n如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错\n\n派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）\n\n所以copy函数需要\n\n- 复制所有local变量\n- 调用所有基类中的适当的copy函数\n\n## 三：资源管理\n\n### 让对象管理资源\n\n将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源\n\n- 申请资源后立即将其放进对象中，**资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）**\n- 在对象的析构函数中释放资源\n\nC++的`auto_ptr`是一个**类指针（pointer-like）对象**，也就是**智能指针**，其析构函数会自动delete掉其所指向的对象\n\n注意：\n\n- 不要让多个`auto_ptr`指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”\n- `auto_ptr`如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权\n\n**RCSP（引用计数型智能指针）**也是一种智能指针（比如`tr1::shared_ptr`），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源\n\n### 小心copy行为\n\n大多数RAII对象的copy函数：\n\n- 禁止复制\n- 采用引用计数法（RCSP）\n- 复制底部资源（深拷贝）\n- 转移底层资源所有权（auto_ptr）\n\n### 在资源管理类中提供对原始资源的访问\n\n有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）\n\n### new与delete一个数组\n\n一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？\n\n- 如果new了一个数组，就delete一个数组\n\n```c++\nstring* ptr1 = new string[100];\ndelete [] ptr1;\n```\n\n- 如果new了一个对象，就delete一个对象\n\n```c++\nstring* ptr2 = new string;\ndelete ptr2;\n```\n\n很多时候很难确定当前这个对象是数组还是一个对象\n\n```c++\ntypedef string AddressLines[4];\nstring* pal = new AddressLines;\ndelete [] pal;\n```\n\n最简单的方法是不用数组，使用STL里的容器，如`vector<string>`\n\n### 以独立语句将newed对象置入智能指针\n\nC++中调用一个函数，会先计算每一个传递进去的实参\n\n如果按下面的写法，将newed对象置入智能指针中\n\n```c++\n分配函数(shared_ptr<Widget>(new Widget), 资源访问);\t\t//不要这样写\n```\n\n需要执行一下函数\n\n- 调用“资源访问”函数（A）\n- 执行`new Widget`（B）\n- 调用`shared_ptr`构造函数（C）\n\n然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）\n\n如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏\n\n所以简单的方法是分离语句\n\n```c++\nshared_ptr<Widget> pw(new Widget);\n分配函数(pw, 资源访问);\n```\n\n## 四：设计与声明\n\n### 让接口容易被正确使用\n\n客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）\n\n#### 限制参数传递\n\n这是一个日期类\n\n```c++\nclass Date{\npublic:\n  Date(int month, int day, int year);\n  ...\n};\n...\nDate d(4, 20, 2022);\n```\n\n客户很有可能填错顺序，也有可能填入一个无效的参数\n\n可以使用**外覆类型（wrapper types）**，当然做出类会更好\n\n```c++\nstruct Day{\n  explict Day(int d) : val(d) {}\n  int val;\n};\nstruct Month{\n  explict Month(int m) : val(m) {}\n  int val;\n};\nstruct Year{\n  explict Year(int y) : val(y) {}\n  int val;\n};\nclass Date{\npublic:\n  Date(const Mouth& month, const Day& day, const Year& year);\n  ...\n};\n...\nDate d(Month(4), Day(20), Year(2022));\n```\n\n#### 一致性\n\n自定义的行为要与内置类型的行为一致，比如你不能把`operator*`重载成`operator+`\n\n或则像STL中，容器的接口都很一致，比如`size`、`push_back`等等\n\n### 设计class犹如设计type\n\n- 对象要如何创建和销毁\n- 对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）\n- 对象如果被值传递，意味着什么（深浅拷贝）\n- 约束成员变量的合法值\n- 是否可以/需要被继承\n- 能否类型转换，如何类型转换\n- 支持何种操作符\n- 成员变量的访问修饰\n- 成员函数的访问修饰\n- 未声明接口（undecided interface）\n- 是否需要定义模版\n- 真的需要一个新类吗？\n\n### 多用引用传递\n\nC++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些**很大的自定义类型**来说性能非常糟糕\n\n使用const引用传递会好很多\n\n- 不会创建新的对象\n- 不会改变原有对象\n- 可以避免**对象切割**问题\n  - 对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了\n\n只不过引用传递是大多是通过指针实现的，在处理一些**简单的内置类型**时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递\n\n### 必须返回对象时，不要返回引用\n\n如果必须返回对象，请不要返回引用（比如`operator*`，`operator==`），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个**右值**的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用\n\n### 将成员变量隐藏\n\n成员变量应该为private，而不是public\n\n- 客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）\n- 分离读写权限（这一点C#做的更好？）\n- 封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）\n- 便于对成员变量进行约束（更不容易出现异常值）\n- protected并不比public更具有封装性\n\n### 使用非成员函数\n\n- C#，java选手可以略过\n- C++标准库就是这样写的\n\n这里有一个类，其中有多个成员函数\n\n```c++\nclass WebBrowser{\npublic:\n\tvoid doA();\n  void doB();\n  void doC();\n  ...\n};\n```\n\n现在需要令一个函数做ABC三件事，有两种写法\n\n- 成员函数\n\n```c++\nclass WebBrowser{\npublic:\n\t...\n  void doEverything(){\n    doA();\n    doB();\n    doC();\n  }\n  ...\n};\n```\n\n- 非成员函数\n\n```c++\nvoid doEverything(WebBrowser& wb){\n\twb.doA();\n  wb.doB();\n  wb.doC();\n}\n```\n\n令人意外的是，第二种方法（使用非成员函数）更好\n\n#### 什么是封装\n\n一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强\n\n为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物\n\n#### 为什么第二种比第一种封装性更强\n\n因为第一种给用户两种调用方法，一个是调用成员函数`doEverything()`，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性\n\n- 注意第一种方法中，`doEverything()`和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利\n\n那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的**静态成员（static member）函数**即可\n\n或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）\n\n```c++\nnamespace WebBrowserStuff{\n\tclass WebBrowser{...};\n\tvoid doEverything(WebBrowser& wb){...}\n}\n```\n\n- 可拓展性更强\n  - 客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）\n\n- 可拆分\n  - 用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）\n\n### 如果所有参数都需要进行类型转换，使用非成员函数\n\n令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时\n\n比如一个有理数乘法\n\n```c++\nclass Rational{\npublic:\n  //这个类没有自定义的explict构造函数\n  const Rational opertaor* (const Rational& rhs) const;\n  ...\n};\n```\n\n```c++\nRational oneEighth(1,8);\nRational oneHalf(1,2);\nRational result = oneHalf * oneEighth;\t//成功\nresult = result * oneEighth;\t//成功\nresult = oneHalf * 2;\t\t//成功，等价于 result = oneHalf.operator*(2)\nresult = 2 * oneHalf;\t\t//失败，等价于 result = 2.operator*(oneHalf)\n```\n\n`result = oneHalf * 2;`为什么成功，因为这里发生了一次隐式转换，将`2`转化为了一个`Rational`类型\n\n在编译器中可能等价于\n\n```c++\nconst Rational temp(2);\nresult = oneHalf * temp;\n```\n\n- 如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将`2`转化为一个`Rational`类型\n\n`result = 2 * oneHalf;\t`为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时`2`就是一个int类型，没有我们所自定义的`operator*`函数，自然会失败\n\n可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）\n\n```c++\nconst Rational operator*(const Rational& lhs, const Rational& rhs){\n  return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());\n}\n```\n\n- 此外要极力避免使用**友元（friend）函数**\n- 成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数\n\n\n\n### 写一个不抛异常的swap函数\n\nswap函数原本是STL的一部分，后来称为了**异常安全性编程**的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要\n\nstd是一个很特殊的命名空间，客户可以**全特化**（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定\n\n全特化：针对某个类做模板函数的特例，如对`std::swap`做一个针对`Widget`的特化\n\n```c++\nclass WidgetImpl{...};\t\t//这个类的对象中存储着真正的数据\nclass Widget{\npublic:\n    Widget& operator=(const Widget& rhs){\n        ...\n        *pImpl = *(rhs.pImpl);\n        ...\n    }\n    ...\n    void swap(Widget& other){\t//这个函数决对不可抛异常\n        using std::swap;\n        swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针\n    }\n    ...\nprivate:\n    WidgetImple* pImpl;\t\t//这个类有一个指向资源对象的指针\n};\nnamespace std{\n\ttemplate<>\n    void swap<Widget>(Widget& a, Widget& b){\t//这个可以抛异常\n        a.swap(b);\t\n    }\n}\n```\n\n此外，C++的STL容器就是上面这种写法，提供了`public swap`成员函数和`std::swap`的特化版本\n\n## 五：实现（Implementations）\n\n- 随意定义变量可能会导致性能降低\n- 过度使用转型（casts）可能会导致性能降低，难以维护，可读性低\n- 返回对象的内部数据的handles，可能会破坏封装\n- 未考虑异常可能会导致资源泄露和数据败坏\n- 过度使用inline可能会导致包体膨胀\n- 过度耦合（coupling）可能会增加构建时间（build times）\n\n### 尽量延后变量定义式的出现时间\n\n#### 避免未曾使用的变量\n\n如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过\n\n此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、\n\n#### 避免无意义的默认构造函数\n\n如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好\n\n#### 循环\n\n此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？\n\n**循环内**\n\n```c++\nfor(int i = 0; i < n; i++){\n  Widget w(...);\n  ...\n}\n```\n\n- n个构造函数+n个析构函数\n\n- 如果`Widget`是一个很敏感的类，这样会让其作用域更小，更容易理解和维护\n\n**循环外**\n\n```c++\nWidget w;\nfor(int i = 0; i < n; i++){\n  w = ...;\n  ...\n}\n```\n\n- 一个构造函数+一个析构函数+n个赋值操作\n- 如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）\n\n### 少做转型\n\nC++是强类型语言，设计目标应该是保证类型错误绝不发生，然而**类型转换**破坏了类型系统\n\nJava、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险\n\nC++的类型转化\n\n- 旧式转换\n  - `(T)expression`\n  - `T(expression)`\n- 新式转换\n  - `const_cast<T>(expression)`\n    - 用于将对象的**常量性转除（cast away the constness）**\n    - 比如将`const`转化为`non-const`\n  - `dynamic_cast<T>(expression)`\n    - 用来**安全向下转型**\n    - 无法由旧式语句执行\n    - 耗费巨大\n  - `reinterpret_cast<T>(expression)`\n    - 用于低级转型，实际操作取决于编译器，不可移植\n    - 极其少用\n  - `static_cast<T>(expression)`\n    - 用于**强迫隐式转换（implicit conversions）**\n    - 比如`non-const`转化为`const`，`int`转化为`double`，`void*`转化为`typed`，基类指针转化为派生类指针\n\n避免C++类型转换出问题的核心是**避免使用基类的接口处理派生类**\n\n#### 一个对象多个地址\n\nC++很神奇，如果一个基类指针指向一个派生类对象，如\n\n```C++\nDervied d;\nBase* b = &d;\n```\n\n这可能会导致两个指针值不一样，即这个对象有两个地址，一个`Derivied*`指针一个`Base*`指针，这派生类指针上往往会有一个**偏移量（offset）**，通过这个偏移量，可以通过派生类指针找到基类指针\n\n上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以**请不要假定对象在C++中如何布局**，更不应该基于这个假设对对象进行类型转换\n\n如果你想让当前对象调用基类的函数，如果对`*this`做强制转化，转换为基类，`*this`其实是先前产生的`*this`对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题\n\n```c++\nclass SpecialWindow: public Window{\npublic:\n  virtual void onResize(){\n    //static_cast<Window>(*this).onResize();\t//这样不好\n    Window::onResize();\t\t//请用这种方式调用基类的onResize函数（作用到当前对象上）\n    ...\n  }\n}\n```\n\n#### dynamic_cast\n\n这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象\n\n什么时候使用这个东西？当**你想在**一个你认为是派生类对象的**对象上执行**派生类的操作**函数**，但你手里却只有一个指向基类的引用/指针时\n\n解决方法：\n\n- 使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器\n- 在基类中提供virtual函数\n\n### 避免返回指向对象内部成分的handles\n\n前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便\n\n但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的\n\n```c++\nclass Point{\npublic:\n  ...\n  void setX(int val);\n  ...\n};\nstruct RectData{\n  Point ulhc;\t\t//upper left hand corner\n  Point lrhc;\t\t//lower right hand corner\n};\nclass Rectangle{\npublic:\n  ...\n  Point& upperLeft() const { return pData->ulhc; }\t//这样返回了引用，非常不好\n  ...\nprivate:\n  std::tr1::shared_ptr<RectData> pData;\n};\n...\nrec.upperLeft().setX(50);\t\t//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改\n```\n\n`upperLeft`函数本来只是为了提供给客户获得（get）`Rectangle`的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了`Rectangle`本身，而且还是一个内部数据`RectData`\n\n为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）\n\n解决方法很简单，只要让handles不可以被修改，就可以了\n\n```c++\nclass Rectangle{\npublic:\n  ...\n  const Point& upperLeft() const { return pData->ulhc; }\t\n  ...\n};\n```\n\n但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致**dangling handles（空悬的号码牌）**，比如返回了一个对local变量的引用，依然特别危险\n\n当然，有的时候不得不返回handles，比如`operator[]`\n\n### 异常安全性很重要\n\n**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：\n\n- 不泄漏任何资源\n- 不允许数据败坏\n\n不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂\n\n三个保证：\n\n- 基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏\n- 强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过`copy-and-swap`实现）\n- 不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）\n\n**异常安全码**必须提供上述三种保障之一，如果不能保障，则不具备异常安全性\n\n### 了解inline函数\n\n内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化\n\n缺点也很明显，会让包体变大，会导致**换页行为（paging）**，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数\n\n内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联\n\n### 降低文件间的编译依存\n\n如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译\n\n为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用）\n\n这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类\n\n*话说应该不会有人不知道implementation是实现的意思吧*\n\n```c++\nclass PersonImpl;\t//pimpl写法，这是Person类的前置声明\nclass Data;\t\t\t\t//Data的前置声明\nclass Address;\t\t//Address的前置声明\n\nclass Persion{\t//像这样使用pimpl的类，往往被称为Handle classes\npublic:\n  ...\n  std::string name() const;\n  ...\nprivate:\n  std::tr1::shared_ptr<PersonImpl> pImpl;\n};\n```\n\n在这种设计下，`Person`就与`Data`、`Address`以及`Persons`的实现分离了，改动这些类也不会导致使用`Person`的客户重新编译，客户无法看到`Person`的实现细节，真正实现**接口与实现分离**\n\n这个操作的本质是用**声明的依赖性**替换**定义的依赖性**\n\n此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明\n\n此外还有另一种制作`Handle class`的方法，就是令`Person`成为一个特殊的抽象基类，称为`Interface class`，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）\n\n```c++\nclass Person{\t\t//Interface class\npublic:\n  virtual ~Person();\n  virtual std::string name() const = 0;\n  ...\n};\nclass Person{\t\t//具现化\npublic:\n  static std::tr1::shared_ptr<Person> create(const std::string& name...);\n  ...\n};\n...\n//使用\nstd::tr1::shared_ptr<Person> pp(Person::create(name...));\nstd::cout << pp->name();\n```\n\n```c++\nclass RealPerson: public Person{\t\npublic:\n  RealPerson(const std::string& name, ...): theName(name), ...{}\n  virtual ~RealPerson() {}\n  std::string name() const;\t\t\n  ...\nprivate:\n\tstd::string theName;\n};\nstd::string ReakPerson::name(){...}\nstd::tr1::shared_ptr<Person> Person::create(const std::string& name, ...){\n  retrun std::tr1::shared_ptr<Person>(new RealPerson(name, ...));\n}\n```\n\n## 六：继承与面向对象\n\n- `is-a`：是一个\n- `has-a`：有一个\n- `is-implemented-in-terms-of`：根据xx实现出\n\n### public继承是is-a关系\n\n```c++\nclass Student: public Person{...};\t//Student is a Person\n```\n\n每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化\n\n**public继承下，可以把子类当父类用**，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用\n\n这就出现了一个问题，子类一定要`is a`父类，不然会出现问题\n\n错误的继承：\n\n- 企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？\n- 正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？\n\n### 避免遮掩父类成员\n\n```c++\nint x;\nvoid Fun(){\n    double x;\n    ...\n}\n```\n\n由于**作用域**的**名称遮掩规则**，函数内部的local变量x覆盖了全局变量x\n\n#### 子类名称会遮掩父类名称，在public继承下是错误的\n\n在OOP中，如果子类重载了父类的`non-virtual`函数，就意味着子类使用同名函数遮掩了父类函数，就意味着**这个父类函数没有被子类继承！**，那么在这种情况下，继承就不是`is-a`关系了\n\n**在public继承下，子类继承了父类的一切**\n\n```c++\nclass Base{\npublic:\n    virtual void f1() = 0;\n    virtual void f1(int);\n    void f2();\n    void f2(double);\n    ...\nprivate:\n    int x;\n};\nclass Derived: public Base{\npublic:\n    virtual void f1();\n    void f2();\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)\n```\n\n#### 将被遮掩的名称重见天日\n\n解决起来很简单，只需要让父类的函数在子类作用域内可见，可以**使用using关键字**\n\n```c++\nclass Derived: public Base{\npublic:\n    using Base::f1;\n    using Base::f2;\n    virtual void f1();\n    void f2();\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//正确，调用Base::f1\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//正确，调用Base::f2\n```\n\n如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以**使用转交函数**，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中\n\n```c++\nclass Derived: private Base{\npublic:\n    virtual void f1(){\n        Base::f1();\t\t//inline转交函数\n    }\n    ...\n};\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1\n```\n\n### 区分接口继承和实现继承\n\npublic继承分为两个部分\n\n- 函数接口继承\n- 函数实现继承\n\n|                 | 接口继承 | 实现继承         |\n| --------------- | -------- | ---------------- |\n| 纯虚函数        | 具体指定 | 不继承           |\n| 非纯虚函数      | 具体指定 | 继承一份缺省实现 |\n| non-virtual函数 | 具体指定 | 继承一份强制实现 |\n\n### 考虑使用virtual以外的选择\n\n#### 基于NVI的Template Method模式\n\nNon-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数\n\n```c++\nclass GameCharacter{\npublic：\n    int healthValue() const\n\t{\n    \t...\n    \tint retVal = doHealthValue();\n    \t...\n    \treturn retVal;\n\t}\nprivate：\n    virtual int doHealthValue() const\n    {\n\t\t...\n    }\n};\n```\n\n其中`healthValue()`被称为virtual函数的**外覆器（wrapper）**\n\n#### 基于函数指针的Strategy模式\n\n```c++\nclass GameCharacter;\nint defaultHealthCalc(const GameCharacter& gc);\nclass GameCharacter{\npublic:\n    typedef int (*HealthCalcFunc)(const GameCharacter&);\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf){}\n    int healthValue() const { return healthFunc(*this); }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\n在这种模式下，`defaultHealthCalc`函数不再是`GameCharacter`体系内的成员函数，通过修改函数指针，就可以让`GameCharacter`使用不同种类的计算函数，弹性更强，而且可以在运行时变更\n\n此外`defaultHealthCalc`函数不需要/不能访问`GameCharacter`内的`non-public`部分，\n\n####  基于tr1::function的Strategy模式\n\n上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如`tr1::function`对象\n\n```c++\nclass GameCharacter;\nint defaultHealthCalc(const GameCharacter& gc);\nclass GameCharacter{\npublic:\n    typedef std::tr1::function<int (const GameCharacter&)> HealthCalcFunc;\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf){}\n    int healthValue() const { return healthFunc(*this); }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\n#### 古典的Strategy模式\n\n```c++\nclass GameCharacter;\nclass HealthCalcFunc{\npublic:\n    ...\n    virtual int calc(const GameCharacter& gc) const{...}\n    ...\n};\nHealthCalcFunc defaultHealthCalc;\nclass GameCharacter{\npublic:\n    explicit GameCharacter(HealthCalcFunc* phcf = &defaultHealthCalc): pHealthFunc(phcf){}\n    int healthValue() const { return phealthFunc->calc(*this); }\n    ...\nprivate:\n    HealthCalcFunc* pHealthFunc;\n};\n```\n\n### 绝不重新定义继承而来的non-virtual函数\n\n- 静态绑定（staticcally bound）：non-virtual就是这种\n- 动态绑定（dynamically bound）：virtual就是这种\n\n```c++\nclass B{\npublic:\n\tvoid f();\n\t...\n};\nclass D: public B{\npublic:\n  void f();\n  ...\n};\n...\nD x;\nB* pB = &x;\nD* pD = &x;\npB->f();\t//调用B::f\npD->f();\t//调用D::f\n```\n\n### 绝对不重新定义继承而来的缺省参数值\n\n**virtual函数是动态绑定的，缺省参数值是静态绑定的**\n\n```c++\nclass Cricle: public Shape{...};\n...\nShape* p1;\t//p1的静态类型是Shape*，没有动态类型\nShape* p2 = new Circle;\t//p2的静态类型是Shape*，动态类型是Circle*\n```\n\n- 静态类型\n  - 指针的类型就是**静态类型**\n- 动态类型\n  - 所指向的对象的类型是**动态类型**\n  - 动态类型可以通过赋值等操作改变\n\nvirtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载\n\n但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数\n\n### has-a和根据xx实现出\n\n一个类中有多个小类，这种关系被称为**复合（composition）**，其中这些小类被称为**合成成分物（composed object）**\n\n- 在应用域，复合意味着`has-a`\n  - 人有名字（也不尽然）\n- 在实现域，复合意味着`is-implemented-in-terms-of`\n  - 队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）\n\n### 少用private继承\n\n*经典 C++糟粕，请问 C#有这个吗？*\n\n本质上是一种`is-implemented-in-terms-of`关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术\n\n- private继承，编译器无法自动将子类对象转化为父类对象\n- private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）\n\n**尽量使用复合来替代pirvate继承**，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数\n\n此外private继承的对象有可能比复合的对象要小\n\n### 少用多重继承\n\n*经典 C++糟粕，请问 C#有这个吗？*\n\n- 可能会导致歧义\n  - 当然你可以在调用函数的时候指出是来自哪一个基类\n- 可能会导致菱形继承\n  - 菱形继承可能会导致变量重复\n\n## 七：模版与泛型\n\n模板（templates）是泛型编程（generic programming）的基础\n\n模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译\n\n### 评价\n\n优点：\n\n1. 模板编程能够实现非常灵活且类型安全的接口\n2. 极好的性能（更小的文件、更短的运行期，更少的内存需求）\n3. 可以将一些运行时才能侦测到的错误，在编译期找出来\n\n缺点：\n\n1. 难以编程和维护\n2. 编译报错信息难以理解\n3. 难以重构\n4. 编译时间大幅变长\n\n因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释\n\n### 隐式接口和编译期多态\n\n- OOP中经常使用显式接口和运行时多态\n- 泛型编程更多使用隐式接口和编译期多态\n\n```C++\ntemplate<typename T>\nvoid doProcessing(T& w)\n{\n    if(w.size() > 10 && w != someNastyWidget){\n        T temp(w)\n        temp.normalize();\n        temp.swap(w);\n    }\n}\n```\n\n从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组**隐式接口**\n\n所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功\n\n这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是**编译期多态**\n\n### Traits\n\n一种约定俗成的技术方案，为同一类数据提供统一的操作函数\n\n比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。\n\n```C++\nenum Type{\n    TYPE_1;\n    TYPE_2;\n};\nclass FOO{\n    Type type = Type::TYPE_1;\n};\nclass Bar{\n    Type type = Type::TYPE_2;\n};\n//统一的模板函数\ntemplate<typename T>\nvoid decode(const T& data, char* buf){\n    if(T::type == Type::TYPE_1){\n        ...\n    }\n    else if(T::type == Type::TYPE_2){\n        ...\n    }\n}\n```\n\n但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术\n\n```C++\nenum Type{\n    TYPE_1;\n    TYPE_2;\n};\nclass FOO{\n    Type type = Type::TYPE_1;\n};\nclass Bar{\n    Type type = Type::TYPE_2;\n};\n\ntemplate<typename T>\nstruct type_traits{\n    Type type = T::type;\n}\n//为内置数据类型特化为独有的 type_traits\ntemplate<typename int>\nstruct type_traits{\n    Type type = Type::TYPE_1;\n}\n//统一的模板函数\ntemplate<typename T>\nvoid decode(const T& data, char* buf){\n    if(type_traits<T>::type == Type::TYPE_1){\n        ...\n    }\n    else if(type_traits<T>::type == Type::TYPE_2){\n        ...\n    }\n}\n```\n\n该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因\n\n### 模板元编程\n\nTMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化\n\n如果一门语言具备以下功能，则称为图灵完全\n\n1. 数值运算和符号运算\n2. 判断\n3. 递归\n\n#### 数值运算+递归\n\n```C++\n//一个TMP计算阶乘，而且阶乘的技术发生在编译期\ntemplate<unsigned n>\nstruct Factorial\n{\n    enum { value = n * Factorial<n-1>::value };\n};\ntemplate<>\nstruct Factorial<0>\n{\n    enum { value = 1 };\n};\n\nint main()\n{\n    std::cout << Factorial<5>::value;\n}\n```\n\nC++11TMP这种函数式编程得到了加强，上文也可以这样写\n\n```C++\ntemplate<unsigned n>\nstruct Factorial\n{\n    constexpr static auto value{ n * Factorial<n - 1>::value };\n};\ntemplate<>\nstruct Factorial<0>\n{\n    constexpr static auto value = 1;\n};\n```\n\n#### 判断\n\n```C++\ntemplate<bool Value>\nstruct if_constexpr\n{\n    constexpr static auto value = 1;\n};\n\ntemplate<>\nstruct if_constexpr<false> {\n    constexpr static auto value = 2;\n};\n\nint main()\n{\n    std::cout << if_constexpr<true>::value << std::endl;\n    std::cout << if_constexpr<false>::value << std::endl;\n}\n```\n\n### typedef\n\n在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名\n\n下面是一个函数指针的示例\n\n```C++\nvoid add(int x, int y) {\n    std::cout << \"x+y=\" << x + y << std::endl;\n}\nvoid dec(int x, int y) {\n    std::cout << \"x-y=\" << x - y << std::endl;\n}\nvoid mul(int x, int y) {\n    std::cout << \"x*y=\" << x*y << std::endl;\n}\n\nvoid (*op[3])(int, int) = { add, dec, mul };\n\nint main()\n{\n    for (int i = 0; i < 3; ++i) {\n        （*op[i])(4, 3);\n    }\n}\n```\n\n如果使用typedef\n\n```C++\ntypedef void (*Func[3])(int, int);\nFunc f = { add, dec, mul };\n\nint main()\n{\n    for (int i = 0; i < 3; ++i) {\n        f[i](4, 3);\n    }\n}\n```\n\n## 八：定制new和delete\n\nJava和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目\n\n### new-handler\n\n当`operator new`无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即`new-handler`\n\n使用`set_new_handler`来指定`new-handler`\n\n```c++\nvoid outOfMem(){\n  std::cerr << \"内存不足\\n\";\n  std::abort();\n}\nint main(){\n  std::set_new_handler(outOfMem);\t\t//该函数的参数是一个函数指针\n  int* array = new int[10000000L];\n  ...\n}\n```\n\n当`operator new`无法满足内存申请时，会不断调用`new-handler`函数，直到找到足够的内存，所以`new-handler`函数应该满足\n\n- 让更多的内存可被使用\n  - 实现方法是程序开始时就分配一大块内存，每次调用`new-handler`时就释放一点点\n- 安装另一个`new-handler`\n  - 如果现在这个`new-handler`无法获取更多内存，需要知道哪一个`new-handler`具备增大内存的实力，然后使用`set_new_handler`来替换自己\n- 卸除`new-handler`\n  - 通过`set_new_handler`赋值`null`，将`new-handler`卸载，使得在内存分配不足时，会抛异常\n- 抛出`bad_alloc`异常\n  - 这种异常不会被`operator new`捕获，会被传播至内存索求处\n- 不反回\n  - 调用`abort`或者`exit`\n\n```c++\nclass NewHandlerHolder{\npublic:\n  explicit NewHandlerHolder(std::new_handler nh): handler(nh) {}\t//获取当前的new_handler\n  ~NewHandlerHolder() { std::set_new_handler(handler); }\t\nprivate:\n  std::new_handler handler;\t\t//用于记录当前的new_handler\n};\nvoid* Widget::operator new(std::size_t size) throw(std::bad_alloc){\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\t//安装Widget的new-handler\n  return ::operator new(size);\t//分配对象或者抛异常\n}\n//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值\n```\n\n```c++\nvoid outOfMem();\nWidget::set_new_handler(outOfMem);\nWidget* pwl = new Widget;\t//内存不足时会调用outOfMem\n```\n\nmixin风格的写法\n\n```c++\ntemplate<typename T>\nclass NewHandlerSupport{\npublic:\n  static std::new_handler_set set_new_handler(std::new_handler p) throw();\n  static void* operator new(std::size_t size) throw(std::bad_alloc);\n  ...\nprivate:\n  static std::new_handler currentHandler;\n};\n\ntemplate<typename T>\nstd::new_handler NewHandlerSupport<T>::set_new_handler(std::new_handler p) throw(){\n  std::new_handler oldHandler = currentHandler;\n  currentHandler = p;\n  return oldHandler;\n}\n\ntemplate<typename T>\nvoid* NewHandlerSupport<T>::operator new(std::size_t size) throw(std::bad_alloc){\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\n  return ::operator new(size);\n}\n```\n\n```c++\nclass Widget: public NewHandlerSupport<Widget>{\n\t...\n};\n```\n\n像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为**怪异的循环模版模式（curiously recurring template pattern，CRTP）**\n\n### 替换new和delete的时机\n\nC++中所有的news返回的指针都必须要**地址对齐**，int要4对齐，double要8对齐\n\n写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换\n\n### 编写new和delete的规则\n\n如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则\n\n- new\n  - 应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用`new-handler`\n  - 有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）\n  - new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理**比正确大小更大的（错误）申请**\n\n- delete\n  - 收到null指针时不做任何事\n  - 处理**比正确大小更大的（错误）申请**\n\n### 编写new时也要写对应的delete\n\n```c++\nWidget* pw = new Widget;\n```\n\n在这里调用了两个函数，一个时用以分配内存的`operator new`，一个是`Widget`的构造函数\n\n如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的\n\n运行时系统会调用`operator new`所对应的`operator delete`来释放地址，对于拥有正常签名式的new和delete来说不成问题\n\n```c++\nvoid* operator new(std::size_t) throw(std::bad_alloc);\t//普通的new\nvoid operator delete(void* rawMemory) throw();\t//global中的普通的new\nvoid operator delete(void* rawMemory, std::size_t size) throw();\t//class中的new\n```\n\n但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题\n\n```c++\nvoid* operator new(std::size_t, void* pMemory) throw();\t//placement new，比普通new多带一个参数\n\nWidget* pw = new (std::cerr) Widget;\t//调用operator new，并以cerr作为其实参\n```\n\n当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的`operator new`时如何运作的，所以运行时系统会去寻找**参数个数与类型**都与`operator new`相同的某个`operator delete`\n\n```c++\nvoid operator delete(void*, std::ostream&) throw();\t//palcement delete\n```\n\n```c++\nclass Widget{\npublic:\n  static void* operator new(std::size_t size, std::ostream& logStream) throw(std::bad_alloc);\n  static void operator delete(void* pMemory) throw();\n  static void operator delete(void* pMemoty, std::ostream& logStream) throw();\n  ...\n};\n```\n\n如果此时调用`delete pw`，只会调用普通的`delete`，因为只有在构造时发生异常时，运行时系统才会调用placement delete\n\n最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete\n\n## 九：杂项\n\n### 不要忽视编译器警告\n\n很多人忽视警告，毕竟一个问题如果真的很严重，应该报错\n\n比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为\n\n```c++\nclass B{\npublic:\n  virtual void f() const;\n};\nclass D: public B{\n  virtual void f();\n};\n```\n\n报警告\n\n```c++\nwarning: D::f() hides virtual B::f()\n```\n\n原本的目的是为了在D中重新定义virtual函数`f()`，但由于B中`f()`是const，在D中不是，此时B中的`f()`并没有在D中重新被声明，而是被整个遮掩了\n\n### 去熟悉标准程序库\n\n尤其是TR1\n\n#### C++98有什么\n\n- STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器\n- Iostream\n- 国际化支持\n- 数值处理，包括复数（complex）和纯数值数组（valarray）\n- 异常阶层体系\n- C89标准程序库\n\n#### TR1有什么（全在`std::tr1`中）\n\n- 智能指针`tr1::shared_ptr`和`tr1::weak_ptr`\n- `tr1::function`\n- `tr1::bind`\n\n和（彼此无关的独立组件）\n\n- 哈希表\n- 正则表达式\n- Tuple变量组\n- `tr1::array`\n- `tr1::mem_fn`\n- `tr1::reference_wrapper`\n- 随机数生成工具\n- 数学特殊函数\n- C99兼容\n\n和（基于template）\n\n- Type traits\n- `tr1::result_of`\n\n### 熟悉Boost\n\n\n\n\n\n\n\n","slug":"Effective C++","published":1,"updated":"2023-01-31T13:25:57.688Z","_id":"cldk9wg6s0001wu3c3d9h8cl7","comments":1,"photos":[],"link":"","content":"<h1>Effective C++</h1>\n<h2 id=\"一：C-基础\">一：C++基础</h2>\n<h3 id=\"C-很成熟，很NB\">C++很成熟，很NB</h3>\n<p>C++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）</p>\n<p>其核心是四个部分</p>\n<ul>\n<li>C\n<ul>\n<li>区块block</li>\n<li>语句statements</li>\n<li>预处理器preprocessor</li>\n<li>内置数据类型</li>\n<li>数组arrays</li>\n<li>指针pointers</li>\n</ul>\n</li>\n<li>Object-Orientend C++\n<ul>\n<li>类classes（构造函数，析构函数）</li>\n<li>封装encapsulation</li>\n<li>继承inheritance</li>\n<li>多态polymorphism</li>\n<li>虚函数virtual（动态绑定）</li>\n</ul>\n</li>\n<li>Template C++</li>\n<li>STL</li>\n</ul>\n<h3 id=\"替换-define\">替换#define</h3>\n<p>使用编译器替代预处理器</p>\n<p>尽量使用const、enum定义常量，使用inlines定义函数宏</p>\n<h4 id=\"const\">const</h4>\n<pre><code class=\"language-c++\">#define PI 3.1415926\n</code></pre>\n<p>因为<code>#define</code>不是语言的一部分，在编译器开始工作前，<code>PI</code>就会被处理掉，所以一旦报错，你无法追踪到<code>PI</code>，只能看到<code>3.1415926</code>，这会<strong>浪费你的时间</strong></p>\n<p>应该改为</p>\n<pre><code class=\"language-c++\">const double Pi 3.1415926;\n</code></pre>\n<p>值得注意的事</p>\n<ul>\n<li>定义常量指针指向char*-based字符串</li>\n</ul>\n<pre><code class=\"language-c++\">const char* const authorName = &quot;Reuben&quot;;\n</code></pre>\n<ul>\n<li>作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员</li>\n</ul>\n<pre><code class=\"language-c++\">class GemePlayer&#123;\nprivate:\n\tstatic const int NumTurns = 5;\t//这只是一个声明式\n\tint scores[NumTurns];\n&#125;;\nconst int GamePlayer::NumTurns;\t\t//这是定义式，因为在声明时已经赋值，所以这里就不赋值了\n</code></pre>\n<p>C++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式</p>\n<p>从这里可以看出，<strong>const可以封装</strong>，而#define不行</p>\n<h4 id=\"enum\">enum</h4>\n<pre><code class=\"language-c++\">class GemePlayer&#123;\nprivate:\n\tenum &#123; NumTurns = 5 &#125;;\n\tint scores[NumTurns];\n&#125;;\n</code></pre>\n<h3 id=\"const指针\">const指针</h3>\n<p>const在星号左边，被指物是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nconst char* p = greeting;\n</code></pre>\n<p>const在星号右边，指针本身是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nchar* const p = greeting;\n</code></pre>\n<p>const在星号两边，被指物和指针都是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nconst char* const p = greeting;\n</code></pre>\n<h3 id=\"确认对象在使用前已经被初始化\">确认对象在使用前已经被初始化</h3>\n<p>C++初始化顺序</p>\n<ul>\n<li>基类比子类先初始化</li>\n<li>成员变量根据其声明次序初始化</li>\n</ul>\n<h2 id=\"二：构造-析构-赋值\">二：构造/析构/赋值</h2>\n<h3 id=\"空类的默认函数\">空类的默认函数</h3>\n<p>一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数</p>\n<p>一个类，如果没有构造函数，也会自动声明一个default构造函数</p>\n<p>这些函数都是public且inline的</p>\n<h3 id=\"禁用自动生成的函数\">禁用自动生成的函数</h3>\n<p>如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）</p>\n<ul>\n<li>你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）</li>\n</ul>\n<pre><code class=\"language-c++\">class HomeForSale&#123;\nprivate:\n\tHomeForSale(const HomeForSale&amp;);\n  HomeForSale&amp; operator=(const HomeForSale&amp;);\n&#125;;\n</code></pre>\n<p>可以制作一个不可被copy的类，让子类继承</p>\n<pre><code class=\"language-c++\">class Uncopyable&#123;\nprotected:\n\tUncopyable()&#123;&#125;\n  ~Uncopyable()&#123;&#125;\nprivate:\n  Uncopyable(const Uncopyable&amp;);\n  Uncopyable&amp; operator=(const Uncopyable&amp;);\n&#125;;\n\nclass HomeForSale: private Uncopyable&#123;\n  ...\n&#125;;\n</code></pre>\n<h3 id=\"为多态基类声明virtual析构函数\">为多态基类声明virtual析构函数</h3>\n<h4 id=\"一定要有一个virtual析构函数\">一定要有一个virtual析构函数</h4>\n<ul>\n<li>如果这个类要成为一个基类，那么一定要有一个virtual析构函数</li>\n</ul>\n<p>在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错</p>\n<pre><code class=\"language-c++\">class TimeKeeper&#123;\npublic:\n\t...\n&#125;;\nclass AtomicClock: public TimeKeeper &#123;...&#125;;\nclass WaterClock: public TimeKeeper &#123;...&#125;;\n</code></pre>\n<pre><code class=\"language-c++\">TimeKeeper* ptk = getTimeKeeper();\t\t//创建一个动态分配对象\n...\ndelete ptk;\t//释放对象，避免资源泄漏\n</code></pre>\n<p>上面这个过程的问题其实出在<code>getTimeKeeper()</code>指向一个派生类（derived class）对象（比如<code>AtomicClock</code>），而这个对象却要经由一个基类（base class）指针删除（比如<code>TimeKeeper*</code>）</p>\n<p>如果这个基类的析构函数不是virtual的，就会出现问题：</p>\n<ul>\n<li>如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象</li>\n</ul>\n<p>解决方法就是给基类一个virtual析构函数</p>\n<pre><code class=\"language-c++\">class TimeKeeper&#123;\npublic:\n\tTimeKeeper();\n  virtual ~TimeKeeper();\n  ...\n&#125;;\n</code></pre>\n<h4 id=\"最好不要有virtual析构函数\">最好不要有virtual析构函数</h4>\n<ul>\n<li>如果这个类不可能成为基类，那么最好不要有virtual析构函数</li>\n</ul>\n<p>为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由<strong>vptr（virtual table pointer）<strong>指针携带，这个指针指向一个由函数指针构成的数组，称为</strong>vtbl（virtual table）</strong>，每一个带有virtual函数的类都有一个属于自己的vtbl</p>\n<p><strong>这个vtbl会增大对象的体积</strong>，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍</p>\n<p><strong>这个vtbl会让代码失去兼容性</strong>，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性</p>\n<h4 id=\"请不要继承没有virtual析构函数的类\">请不要继承没有virtual析构函数的类</h4>\n<p>比如string、vector、list、set等等</p>\n<p>而且 C++没有像 Java的<code>final classes</code>或者C#的<code>sealed classes</code>的禁止派生机制</p>\n<h3 id=\"不要在析构函数里抛出异常\">不要在析构函数里抛出异常</h3>\n<p>当一个<code>vector v</code>容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为</p>\n<p>有两个不怎么好的解决方法</p>\n<ul>\n<li>遇到异常，直接<code>std::abort()</code>，即遇到异常，宁愿直接强制停止程序，也不要让异常传播</li>\n<li>遇到异常，把异常记录下来，另程序继续运转，即<strong>吞下异常</strong>\n<ul>\n<li>这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好</li>\n</ul>\n</li>\n</ul>\n<p>比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容</p>\n<pre><code class=\"language-c++\">class DBConnevtion&#123;\npublic:\n    ...\n    static DBConnevtion create();\n    void close();     \n&#125;;\nclass DBConn&#123;\npublic:\n    ...\n    void close()\t//封装给客户用的,关闭连接的函数\n    &#123;\n        db.close();\n        closed = true;\n    &#125;\n    ~DBConn()&#123;\n        if(!closed)&#123;\n            try&#123;\n                db.close();\n            &#125;\n            catch(...)&#123;\n                ...\n                //强制关闭程序或者吞下异常\n            &#125;\n        &#125;\n    &#125;\nprivate:\n    DBConnection db;\n    bool closed;\n&#125;;\n</code></pre>\n<h3 id=\"不要在构造和析构过程中调用virtual函数\">不要在构造和析构过程中调用virtual函数</h3>\n<p>在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果</p>\n<p>可以简单理解为<strong>在C++中，基类构造期间，vritual函数不是vritual函数</strong></p>\n<p>因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数</p>\n<p>同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的</p>\n<h3 id=\"令operator-返回一个对-this的引用\">令operator=返回一个对*this的引用</h3>\n<p>连续赋值</p>\n<pre><code class=\"language-c++\">x = y = z = 15;\n//其实就等于x = (y = (z = 15))；\n</code></pre>\n<p>为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参</p>\n<pre><code class=\"language-c++\">class Widget&#123;\npublic:\n    Widget&amp; operator=(const Widget&amp; rhs)\n    &#123;\n    \t...\n        return *this;\n    &#125;\n    Widget&amp; operator+=(const Widget&amp; rhs)&#123;\n        ...\n        return *this;\n    &#125;\n&#125;;\n</code></pre>\n<h3 id=\"在operator-中处理自我赋值\">在operator=中处理自我赋值</h3>\n<p>如果对象自己赋给自己，我们称之为自我赋值</p>\n<pre><code class=\"language-c++\">w = w;\na[i] = a[j]; //当i=j时，自我赋值\n*px = *py;\t//px和py指向同一个物体时，自我赋值\n</code></pre>\n<p>在赋值操作中：</p>\n<ol>\n<li>我们会先另左边的操作数先释放掉当前使用的数据</li>\n<li>令其使用右操作数的副本</li>\n<li>最后返回左操作数</li>\n</ol>\n<pre><code class=\"language-c++\">class Widget&#123;\n    ...\nprivate:\n    Bitmap *pb;\n&#125;;\n//!!!这个不安全\nWidget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\n&#125;\n</code></pre>\n<p>如果自我赋值，即rhs和pb指向同一个对象，那么<code>delete pb</code>后，这个对象就已经被销毁了，下面使用的<code>*rhs</code>就是一个已经被删除的对象</p>\n<p>解决方法1：延后delete</p>\n<pre><code class=\"language-c++\">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    Bitmap* pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\n    delete pOrig;\n    return *this;\n&#125;\n</code></pre>\n<p>解决方法2：使用copy and swap技术</p>\n<pre><code class=\"language-c++\">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    Widget temp(rhs);\n    swap(temp);\t\t//令*this与temp交换\n    return *this;\n&#125;\n</code></pre>\n<h3 id=\"复制对象的一切\">复制对象的一切</h3>\n<p>如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错</p>\n<p>派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）</p>\n<p>所以copy函数需要</p>\n<ul>\n<li>复制所有local变量</li>\n<li>调用所有基类中的适当的copy函数</li>\n</ul>\n<h2 id=\"三：资源管理\">三：资源管理</h2>\n<h3 id=\"让对象管理资源\">让对象管理资源</h3>\n<p>将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源</p>\n<ul>\n<li>申请资源后立即将其放进对象中，<strong>资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）</strong></li>\n<li>在对象的析构函数中释放资源</li>\n</ul>\n<p>C++的<code>auto_ptr</code>是一个<strong>类指针（pointer-like）对象</strong>，也就是<strong>智能指针</strong>，其析构函数会自动delete掉其所指向的对象</p>\n<p>注意：</p>\n<ul>\n<li>不要让多个<code>auto_ptr</code>指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”</li>\n<li><code>auto_ptr</code>如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权</li>\n</ul>\n<p>**RCSP（引用计数型智能指针）**也是一种智能指针（比如<code>tr1::shared_ptr</code>），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源</p>\n<h3 id=\"小心copy行为\">小心copy行为</h3>\n<p>大多数RAII对象的copy函数：</p>\n<ul>\n<li>禁止复制</li>\n<li>采用引用计数法（RCSP）</li>\n<li>复制底部资源（深拷贝）</li>\n<li>转移底层资源所有权（auto_ptr）</li>\n</ul>\n<h3 id=\"在资源管理类中提供对原始资源的访问\">在资源管理类中提供对原始资源的访问</h3>\n<p>有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）</p>\n<h3 id=\"new与delete一个数组\">new与delete一个数组</h3>\n<p>一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？</p>\n<ul>\n<li>如果new了一个数组，就delete一个数组</li>\n</ul>\n<pre><code class=\"language-c++\">string* ptr1 = new string[100];\ndelete [] ptr1;\n</code></pre>\n<ul>\n<li>如果new了一个对象，就delete一个对象</li>\n</ul>\n<pre><code class=\"language-c++\">string* ptr2 = new string;\ndelete ptr2;\n</code></pre>\n<p>很多时候很难确定当前这个对象是数组还是一个对象</p>\n<pre><code class=\"language-c++\">typedef string AddressLines[4];\nstring* pal = new AddressLines;\ndelete [] pal;\n</code></pre>\n<p>最简单的方法是不用数组，使用STL里的容器，如<code>vector&lt;string&gt;</code></p>\n<h3 id=\"以独立语句将newed对象置入智能指针\">以独立语句将newed对象置入智能指针</h3>\n<p>C++中调用一个函数，会先计算每一个传递进去的实参</p>\n<p>如果按下面的写法，将newed对象置入智能指针中</p>\n<pre><code class=\"language-c++\">分配函数(shared_ptr&lt;Widget&gt;(new Widget), 资源访问);\t\t//不要这样写\n</code></pre>\n<p>需要执行一下函数</p>\n<ul>\n<li>调用“资源访问”函数（A）</li>\n<li>执行<code>new Widget</code>（B）</li>\n<li>调用<code>shared_ptr</code>构造函数（C）</li>\n</ul>\n<p>然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）</p>\n<p>如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏</p>\n<p>所以简单的方法是分离语句</p>\n<pre><code class=\"language-c++\">shared_ptr&lt;Widget&gt; pw(new Widget);\n分配函数(pw, 资源访问);\n</code></pre>\n<h2 id=\"四：设计与声明\">四：设计与声明</h2>\n<h3 id=\"让接口容易被正确使用\">让接口容易被正确使用</h3>\n<p>客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）</p>\n<h4 id=\"限制参数传递\">限制参数传递</h4>\n<p>这是一个日期类</p>\n<pre><code class=\"language-c++\">class Date&#123;\npublic:\n  Date(int month, int day, int year);\n  ...\n&#125;;\n...\nDate d(4, 20, 2022);\n</code></pre>\n<p>客户很有可能填错顺序，也有可能填入一个无效的参数</p>\n<p>可以使用<strong>外覆类型（wrapper types）</strong>，当然做出类会更好</p>\n<pre><code class=\"language-c++\">struct Day&#123;\n  explict Day(int d) : val(d) &#123;&#125;\n  int val;\n&#125;;\nstruct Month&#123;\n  explict Month(int m) : val(m) &#123;&#125;\n  int val;\n&#125;;\nstruct Year&#123;\n  explict Year(int y) : val(y) &#123;&#125;\n  int val;\n&#125;;\nclass Date&#123;\npublic:\n  Date(const Mouth&amp; month, const Day&amp; day, const Year&amp; year);\n  ...\n&#125;;\n...\nDate d(Month(4), Day(20), Year(2022));\n</code></pre>\n<h4 id=\"一致性\">一致性</h4>\n<p>自定义的行为要与内置类型的行为一致，比如你不能把<code>operator*</code>重载成<code>operator+</code></p>\n<p>或则像STL中，容器的接口都很一致，比如<code>size</code>、<code>push_back</code>等等</p>\n<h3 id=\"设计class犹如设计type\">设计class犹如设计type</h3>\n<ul>\n<li>对象要如何创建和销毁</li>\n<li>对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）</li>\n<li>对象如果被值传递，意味着什么（深浅拷贝）</li>\n<li>约束成员变量的合法值</li>\n<li>是否可以/需要被继承</li>\n<li>能否类型转换，如何类型转换</li>\n<li>支持何种操作符</li>\n<li>成员变量的访问修饰</li>\n<li>成员函数的访问修饰</li>\n<li>未声明接口（undecided interface）</li>\n<li>是否需要定义模版</li>\n<li>真的需要一个新类吗？</li>\n</ul>\n<h3 id=\"多用引用传递\">多用引用传递</h3>\n<p>C++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些<strong>很大的自定义类型</strong>来说性能非常糟糕</p>\n<p>使用const引用传递会好很多</p>\n<ul>\n<li>不会创建新的对象</li>\n<li>不会改变原有对象</li>\n<li>可以避免<strong>对象切割</strong>问题\n<ul>\n<li>对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了</li>\n</ul>\n</li>\n</ul>\n<p>只不过引用传递是大多是通过指针实现的，在处理一些<strong>简单的内置类型</strong>时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递</p>\n<h3 id=\"必须返回对象时，不要返回引用\">必须返回对象时，不要返回引用</h3>\n<p>如果必须返回对象，请不要返回引用（比如<code>operator*</code>，<code>operator==</code>），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个<strong>右值</strong>的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用</p>\n<h3 id=\"将成员变量隐藏\">将成员变量隐藏</h3>\n<p>成员变量应该为private，而不是public</p>\n<ul>\n<li>客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）</li>\n<li>分离读写权限（这一点C#做的更好？）</li>\n<li>封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）</li>\n<li>便于对成员变量进行约束（更不容易出现异常值）</li>\n<li>protected并不比public更具有封装性</li>\n</ul>\n<h3 id=\"使用非成员函数\">使用非成员函数</h3>\n<ul>\n<li>C#，java选手可以略过</li>\n<li>C++标准库就是这样写的</li>\n</ul>\n<p>这里有一个类，其中有多个成员函数</p>\n<pre><code class=\"language-c++\">class WebBrowser&#123;\npublic:\n\tvoid doA();\n  void doB();\n  void doC();\n  ...\n&#125;;\n</code></pre>\n<p>现在需要令一个函数做ABC三件事，有两种写法</p>\n<ul>\n<li>成员函数</li>\n</ul>\n<pre><code class=\"language-c++\">class WebBrowser&#123;\npublic:\n\t...\n  void doEverything()&#123;\n    doA();\n    doB();\n    doC();\n  &#125;\n  ...\n&#125;;\n</code></pre>\n<ul>\n<li>非成员函数</li>\n</ul>\n<pre><code class=\"language-c++\">void doEverything(WebBrowser&amp; wb)&#123;\n\twb.doA();\n  wb.doB();\n  wb.doC();\n&#125;\n</code></pre>\n<p>令人意外的是，第二种方法（使用非成员函数）更好</p>\n<h4 id=\"什么是封装\">什么是封装</h4>\n<p>一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强</p>\n<p>为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物</p>\n<h4 id=\"为什么第二种比第一种封装性更强\">为什么第二种比第一种封装性更强</h4>\n<p>因为第一种给用户两种调用方法，一个是调用成员函数<code>doEverything()</code>，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性</p>\n<ul>\n<li>注意第一种方法中，<code>doEverything()</code>和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利</li>\n</ul>\n<p>那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的<strong>静态成员（static member）函数</strong>即可</p>\n<p>或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）</p>\n<pre><code class=\"language-c++\">namespace WebBrowserStuff&#123;\n\tclass WebBrowser&#123;...&#125;;\n\tvoid doEverything(WebBrowser&amp; wb)&#123;...&#125;\n&#125;\n</code></pre>\n<ul>\n<li>\n<p>可拓展性更强</p>\n<ul>\n<li>客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）</li>\n</ul>\n</li>\n<li>\n<p>可拆分</p>\n<ul>\n<li>用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如果所有参数都需要进行类型转换，使用非成员函数\">如果所有参数都需要进行类型转换，使用非成员函数</h3>\n<p>令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时</p>\n<p>比如一个有理数乘法</p>\n<pre><code class=\"language-c++\">class Rational&#123;\npublic:\n  //这个类没有自定义的explict构造函数\n  const Rational opertaor* (const Rational&amp; rhs) const;\n  ...\n&#125;;\n</code></pre>\n<pre><code class=\"language-c++\">Rational oneEighth(1,8);\nRational oneHalf(1,2);\nRational result = oneHalf * oneEighth;\t//成功\nresult = result * oneEighth;\t//成功\nresult = oneHalf * 2;\t\t//成功，等价于 result = oneHalf.operator*(2)\nresult = 2 * oneHalf;\t\t//失败，等价于 result = 2.operator*(oneHalf)\n</code></pre>\n<p><code>result = oneHalf * 2;</code>为什么成功，因为这里发生了一次隐式转换，将<code>2</code>转化为了一个<code>Rational</code>类型</p>\n<p>在编译器中可能等价于</p>\n<pre><code class=\"language-c++\">const Rational temp(2);\nresult = oneHalf * temp;\n</code></pre>\n<ul>\n<li>如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将<code>2</code>转化为一个<code>Rational</code>类型</li>\n</ul>\n<p><code>result = 2 * oneHalf;\t</code>为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时<code>2</code>就是一个int类型，没有我们所自定义的<code>operator*</code>函数，自然会失败</p>\n<p>可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）</p>\n<pre><code class=\"language-c++\">const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123;\n  return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());\n&#125;\n</code></pre>\n<ul>\n<li>此外要极力避免使用<strong>友元（friend）函数</strong></li>\n<li>成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数</li>\n</ul>\n<h3 id=\"写一个不抛异常的swap函数\">写一个不抛异常的swap函数</h3>\n<p>swap函数原本是STL的一部分，后来称为了<strong>异常安全性编程</strong>的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要</p>\n<p>std是一个很特殊的命名空间，客户可以<strong>全特化</strong>（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定</p>\n<p>全特化：针对某个类做模板函数的特例，如对<code>std::swap</code>做一个针对<code>Widget</code>的特化</p>\n<pre><code class=\"language-c++\">class WidgetImpl&#123;...&#125;;\t\t//这个类的对象中存储着真正的数据\nclass Widget&#123;\npublic:\n    Widget&amp; operator=(const Widget&amp; rhs)&#123;\n        ...\n        *pImpl = *(rhs.pImpl);\n        ...\n    &#125;\n    ...\n    void swap(Widget&amp; other)&#123;\t//这个函数决对不可抛异常\n        using std::swap;\n        swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针\n    &#125;\n    ...\nprivate:\n    WidgetImple* pImpl;\t\t//这个类有一个指向资源对象的指针\n&#125;;\nnamespace std&#123;\n\ttemplate&lt;&gt;\n    void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;\t//这个可以抛异常\n        a.swap(b);\t\n    &#125;\n&#125;\n</code></pre>\n<p>此外，C++的STL容器就是上面这种写法，提供了<code>public swap</code>成员函数和<code>std::swap</code>的特化版本</p>\n<h2 id=\"五：实现（Implementations）\">五：实现（Implementations）</h2>\n<ul>\n<li>随意定义变量可能会导致性能降低</li>\n<li>过度使用转型（casts）可能会导致性能降低，难以维护，可读性低</li>\n<li>返回对象的内部数据的handles，可能会破坏封装</li>\n<li>未考虑异常可能会导致资源泄露和数据败坏</li>\n<li>过度使用inline可能会导致包体膨胀</li>\n<li>过度耦合（coupling）可能会增加构建时间（build times）</li>\n</ul>\n<h3 id=\"尽量延后变量定义式的出现时间\">尽量延后变量定义式的出现时间</h3>\n<h4 id=\"避免未曾使用的变量\">避免未曾使用的变量</h4>\n<p>如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过</p>\n<p>此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、</p>\n<h4 id=\"避免无意义的默认构造函数\">避免无意义的默认构造函数</h4>\n<p>如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好</p>\n<h4 id=\"循环\">循环</h4>\n<p>此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？</p>\n<p><strong>循环内</strong></p>\n<pre><code class=\"language-c++\">for(int i = 0; i &lt; n; i++)&#123;\n  Widget w(...);\n  ...\n&#125;\n</code></pre>\n<ul>\n<li>\n<p>n个构造函数+n个析构函数</p>\n</li>\n<li>\n<p>如果<code>Widget</code>是一个很敏感的类，这样会让其作用域更小，更容易理解和维护</p>\n</li>\n</ul>\n<p><strong>循环外</strong></p>\n<pre><code class=\"language-c++\">Widget w;\nfor(int i = 0; i &lt; n; i++)&#123;\n  w = ...;\n  ...\n&#125;\n</code></pre>\n<ul>\n<li>一个构造函数+一个析构函数+n个赋值操作</li>\n<li>如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）</li>\n</ul>\n<h3 id=\"少做转型\">少做转型</h3>\n<p>C++是强类型语言，设计目标应该是保证类型错误绝不发生，然而<strong>类型转换</strong>破坏了类型系统</p>\n<p>Java、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险</p>\n<p>C++的类型转化</p>\n<ul>\n<li>旧式转换\n<ul>\n<li><code>(T)expression</code></li>\n<li><code>T(expression)</code></li>\n</ul>\n</li>\n<li>新式转换\n<ul>\n<li><code>const_cast&lt;T&gt;(expression)</code>\n<ul>\n<li>用于将对象的<strong>常量性转除（cast away the constness）</strong></li>\n<li>比如将<code>const</code>转化为<code>non-const</code></li>\n</ul>\n</li>\n<li><code>dynamic_cast&lt;T&gt;(expression)</code>\n<ul>\n<li>用来<strong>安全向下转型</strong></li>\n<li>无法由旧式语句执行</li>\n<li>耗费巨大</li>\n</ul>\n</li>\n<li><code>reinterpret_cast&lt;T&gt;(expression)</code>\n<ul>\n<li>用于低级转型，实际操作取决于编译器，不可移植</li>\n<li>极其少用</li>\n</ul>\n</li>\n<li><code>static_cast&lt;T&gt;(expression)</code>\n<ul>\n<li>用于<strong>强迫隐式转换（implicit conversions）</strong></li>\n<li>比如<code>non-const</code>转化为<code>const</code>，<code>int</code>转化为<code>double</code>，<code>void*</code>转化为<code>typed</code>，基类指针转化为派生类指针</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>避免C++类型转换出问题的核心是<strong>避免使用基类的接口处理派生类</strong></p>\n<h4 id=\"一个对象多个地址\">一个对象多个地址</h4>\n<p>C++很神奇，如果一个基类指针指向一个派生类对象，如</p>\n<pre><code class=\"language-C++\">Dervied d;\nBase* b = &amp;d;\n</code></pre>\n<p>这可能会导致两个指针值不一样，即这个对象有两个地址，一个<code>Derivied*</code>指针一个<code>Base*</code>指针，这派生类指针上往往会有一个<strong>偏移量（offset）</strong>，通过这个偏移量，可以通过派生类指针找到基类指针</p>\n<p>上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以<strong>请不要假定对象在C++中如何布局</strong>，更不应该基于这个假设对对象进行类型转换</p>\n<p>如果你想让当前对象调用基类的函数，如果对<code>*this</code>做强制转化，转换为基类，<code>*this</code>其实是先前产生的<code>*this</code>对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题</p>\n<pre><code class=\"language-c++\">class SpecialWindow: public Window&#123;\npublic:\n  virtual void onResize()&#123;\n    //static_cast&lt;Window&gt;(*this).onResize();\t//这样不好\n    Window::onResize();\t\t//请用这种方式调用基类的onResize函数（作用到当前对象上）\n    ...\n  &#125;\n&#125;\n</code></pre>\n<h4 id=\"dynamic-cast\">dynamic_cast</h4>\n<p>这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象</p>\n<p>什么时候使用这个东西？当<strong>你想在</strong>一个你认为是派生类对象的<strong>对象上执行</strong>派生类的操作<strong>函数</strong>，但你手里却只有一个指向基类的引用/指针时</p>\n<p>解决方法：</p>\n<ul>\n<li>使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器</li>\n<li>在基类中提供virtual函数</li>\n</ul>\n<h3 id=\"避免返回指向对象内部成分的handles\">避免返回指向对象内部成分的handles</h3>\n<p>前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便</p>\n<p>但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的</p>\n<pre><code class=\"language-c++\">class Point&#123;\npublic:\n  ...\n  void setX(int val);\n  ...\n&#125;;\nstruct RectData&#123;\n  Point ulhc;\t\t//upper left hand corner\n  Point lrhc;\t\t//lower right hand corner\n&#125;;\nclass Rectangle&#123;\npublic:\n  ...\n  Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;\t//这样返回了引用，非常不好\n  ...\nprivate:\n  std::tr1::shared_ptr&lt;RectData&gt; pData;\n&#125;;\n...\nrec.upperLeft().setX(50);\t\t//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改\n</code></pre>\n<p><code>upperLeft</code>函数本来只是为了提供给客户获得（get）<code>Rectangle</code>的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了<code>Rectangle</code>本身，而且还是一个内部数据<code>RectData</code></p>\n<p>为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）</p>\n<p>解决方法很简单，只要让handles不可以被修改，就可以了</p>\n<pre><code class=\"language-c++\">class Rectangle&#123;\npublic:\n  ...\n  const Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;\t\n  ...\n&#125;;\n</code></pre>\n<p>但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致<strong>dangling handles（空悬的号码牌）</strong>，比如返回了一个对local变量的引用，依然特别危险</p>\n<p>当然，有的时候不得不返回handles，比如<code>operator[]</code></p>\n<h3 id=\"异常安全性很重要\">异常安全性很重要</h3>\n<p>**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：</p>\n<ul>\n<li>不泄漏任何资源</li>\n<li>不允许数据败坏</li>\n</ul>\n<p>不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂</p>\n<p>三个保证：</p>\n<ul>\n<li>基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏</li>\n<li>强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过<code>copy-and-swap</code>实现）</li>\n<li>不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）</li>\n</ul>\n<p><strong>异常安全码</strong>必须提供上述三种保障之一，如果不能保障，则不具备异常安全性</p>\n<h3 id=\"了解inline函数\">了解inline函数</h3>\n<p>内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化</p>\n<p>缺点也很明显，会让包体变大，会导致<strong>换页行为（paging）</strong>，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数</p>\n<p>内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联</p>\n<h3 id=\"降低文件间的编译依存\">降低文件间的编译依存</h3>\n<p>如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译</p>\n<p>为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用）</p>\n<p>这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类</p>\n<p><em>话说应该不会有人不知道implementation是实现的意思吧</em></p>\n<pre><code class=\"language-c++\">class PersonImpl;\t//pimpl写法，这是Person类的前置声明\nclass Data;\t\t\t\t//Data的前置声明\nclass Address;\t\t//Address的前置声明\n\nclass Persion&#123;\t//像这样使用pimpl的类，往往被称为Handle classes\npublic:\n  ...\n  std::string name() const;\n  ...\nprivate:\n  std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;\n&#125;;\n</code></pre>\n<p>在这种设计下，<code>Person</code>就与<code>Data</code>、<code>Address</code>以及<code>Persons</code>的实现分离了，改动这些类也不会导致使用<code>Person</code>的客户重新编译，客户无法看到<code>Person</code>的实现细节，真正实现<strong>接口与实现分离</strong></p>\n<p>这个操作的本质是用<strong>声明的依赖性</strong>替换<strong>定义的依赖性</strong></p>\n<p>此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明</p>\n<p>此外还有另一种制作<code>Handle class</code>的方法，就是令<code>Person</code>成为一个特殊的抽象基类，称为<code>Interface class</code>，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）</p>\n<pre><code class=\"language-c++\">class Person&#123;\t\t//Interface class\npublic:\n  virtual ~Person();\n  virtual std::string name() const = 0;\n  ...\n&#125;;\nclass Person&#123;\t\t//具现化\npublic:\n  static std::tr1::shared_ptr&lt;Person&gt; create(const std::string&amp; name...);\n  ...\n&#125;;\n...\n//使用\nstd::tr1::shared_ptr&lt;Person&gt; pp(Person::create(name...));\nstd::cout &lt;&lt; pp-&gt;name();\n</code></pre>\n<pre><code class=\"language-c++\">class RealPerson: public Person&#123;\t\npublic:\n  RealPerson(const std::string&amp; name, ...): theName(name), ...&#123;&#125;\n  virtual ~RealPerson() &#123;&#125;\n  std::string name() const;\t\t\n  ...\nprivate:\n\tstd::string theName;\n&#125;;\nstd::string ReakPerson::name()&#123;...&#125;\nstd::tr1::shared_ptr&lt;Person&gt; Person::create(const std::string&amp; name, ...)&#123;\n  retrun std::tr1::shared_ptr&lt;Person&gt;(new RealPerson(name, ...));\n&#125;\n</code></pre>\n<h2 id=\"六：继承与面向对象\">六：继承与面向对象</h2>\n<ul>\n<li><code>is-a</code>：是一个</li>\n<li><code>has-a</code>：有一个</li>\n<li><code>is-implemented-in-terms-of</code>：根据xx实现出</li>\n</ul>\n<h3 id=\"public继承是is-a关系\">public继承是is-a关系</h3>\n<pre><code class=\"language-c++\">class Student: public Person&#123;...&#125;;\t//Student is a Person\n</code></pre>\n<p>每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化</p>\n<p><strong>public继承下，可以把子类当父类用</strong>，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用</p>\n<p>这就出现了一个问题，子类一定要<code>is a</code>父类，不然会出现问题</p>\n<p>错误的继承：</p>\n<ul>\n<li>企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？</li>\n<li>正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？</li>\n</ul>\n<h3 id=\"避免遮掩父类成员\">避免遮掩父类成员</h3>\n<pre><code class=\"language-c++\">int x;\nvoid Fun()&#123;\n    double x;\n    ...\n&#125;\n</code></pre>\n<p>由于<strong>作用域</strong>的<strong>名称遮掩规则</strong>，函数内部的local变量x覆盖了全局变量x</p>\n<h4 id=\"子类名称会遮掩父类名称，在public继承下是错误的\">子类名称会遮掩父类名称，在public继承下是错误的</h4>\n<p>在OOP中，如果子类重载了父类的<code>non-virtual</code>函数，就意味着子类使用同名函数遮掩了父类函数，就意味着<strong>这个父类函数没有被子类继承！</strong>，那么在这种情况下，继承就不是<code>is-a</code>关系了</p>\n<p><strong>在public继承下，子类继承了父类的一切</strong></p>\n<pre><code class=\"language-c++\">class Base&#123;\npublic:\n    virtual void f1() = 0;\n    virtual void f1(int);\n    void f2();\n    void f2(double);\n    ...\nprivate:\n    int x;\n&#125;;\nclass Derived: public Base&#123;\npublic:\n    virtual void f1();\n    void f2();\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)\n</code></pre>\n<h4 id=\"将被遮掩的名称重见天日\">将被遮掩的名称重见天日</h4>\n<p>解决起来很简单，只需要让父类的函数在子类作用域内可见，可以<strong>使用using关键字</strong></p>\n<pre><code class=\"language-c++\">class Derived: public Base&#123;\npublic:\n    using Base::f1;\n    using Base::f2;\n    virtual void f1();\n    void f2();\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//正确，调用Base::f1\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//正确，调用Base::f2\n</code></pre>\n<p>如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以<strong>使用转交函数</strong>，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中</p>\n<pre><code class=\"language-c++\">class Derived: private Base&#123;\npublic:\n    virtual void f1()&#123;\n        Base::f1();\t\t//inline转交函数\n    &#125;\n    ...\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1\n</code></pre>\n<h3 id=\"区分接口继承和实现继承\">区分接口继承和实现继承</h3>\n<p>public继承分为两个部分</p>\n<ul>\n<li>函数接口继承</li>\n<li>函数实现继承</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>接口继承</th>\n<th>实现继承</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>纯虚函数</td>\n<td>具体指定</td>\n<td>不继承</td>\n</tr>\n<tr>\n<td>非纯虚函数</td>\n<td>具体指定</td>\n<td>继承一份缺省实现</td>\n</tr>\n<tr>\n<td>non-virtual函数</td>\n<td>具体指定</td>\n<td>继承一份强制实现</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"考虑使用virtual以外的选择\">考虑使用virtual以外的选择</h3>\n<h4 id=\"基于NVI的Template-Method模式\">基于NVI的Template Method模式</h4>\n<p>Non-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数</p>\n<pre><code class=\"language-c++\">class GameCharacter&#123;\npublic：\n    int healthValue() const\n\t&#123;\n    \t...\n    \tint retVal = doHealthValue();\n    \t...\n    \treturn retVal;\n\t&#125;\nprivate：\n    virtual int doHealthValue() const\n    &#123;\n\t\t...\n    &#125;\n&#125;;\n</code></pre>\n<p>其中<code>healthValue()</code>被称为virtual函数的<strong>外覆器（wrapper）</strong></p>\n<h4 id=\"基于函数指针的Strategy模式\">基于函数指针的Strategy模式</h4>\n<pre><code class=\"language-c++\">class GameCharacter;\nint defaultHealthCalc(const GameCharacter&amp; gc);\nclass GameCharacter&#123;\npublic:\n    typedef int (*HealthCalcFunc)(const GameCharacter&amp;);\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125;\n    int healthValue() const &#123; return healthFunc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n&#125;;\n</code></pre>\n<p>在这种模式下，<code>defaultHealthCalc</code>函数不再是<code>GameCharacter</code>体系内的成员函数，通过修改函数指针，就可以让<code>GameCharacter</code>使用不同种类的计算函数，弹性更强，而且可以在运行时变更</p>\n<p>此外<code>defaultHealthCalc</code>函数不需要/不能访问<code>GameCharacter</code>内的<code>non-public</code>部分，</p>\n<h4 id=\"基于tr1-function的Strategy模式\">基于tr1::function的Strategy模式</h4>\n<p>上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如<code>tr1::function</code>对象</p>\n<pre><code class=\"language-c++\">class GameCharacter;\nint defaultHealthCalc(const GameCharacter&amp; gc);\nclass GameCharacter&#123;\npublic:\n    typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125;\n    int healthValue() const &#123; return healthFunc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n&#125;;\n</code></pre>\n<h4 id=\"古典的Strategy模式\">古典的Strategy模式</h4>\n<pre><code class=\"language-c++\">class GameCharacter;\nclass HealthCalcFunc&#123;\npublic:\n    ...\n    virtual int calc(const GameCharacter&amp; gc) const&#123;...&#125;\n    ...\n&#125;;\nHealthCalcFunc defaultHealthCalc;\nclass GameCharacter&#123;\npublic:\n    explicit GameCharacter(HealthCalcFunc* phcf = &amp;defaultHealthCalc): pHealthFunc(phcf)&#123;&#125;\n    int healthValue() const &#123; return phealthFunc-&gt;calc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc* pHealthFunc;\n&#125;;\n</code></pre>\n<h3 id=\"绝不重新定义继承而来的non-virtual函数\">绝不重新定义继承而来的non-virtual函数</h3>\n<ul>\n<li>静态绑定（staticcally bound）：non-virtual就是这种</li>\n<li>动态绑定（dynamically bound）：virtual就是这种</li>\n</ul>\n<pre><code class=\"language-c++\">class B&#123;\npublic:\n\tvoid f();\n\t...\n&#125;;\nclass D: public B&#123;\npublic:\n  void f();\n  ...\n&#125;;\n...\nD x;\nB* pB = &amp;x;\nD* pD = &amp;x;\npB-&gt;f();\t//调用B::f\npD-&gt;f();\t//调用D::f\n</code></pre>\n<h3 id=\"绝对不重新定义继承而来的缺省参数值\">绝对不重新定义继承而来的缺省参数值</h3>\n<p><strong>virtual函数是动态绑定的，缺省参数值是静态绑定的</strong></p>\n<pre><code class=\"language-c++\">class Cricle: public Shape&#123;...&#125;;\n...\nShape* p1;\t//p1的静态类型是Shape*，没有动态类型\nShape* p2 = new Circle;\t//p2的静态类型是Shape*，动态类型是Circle*\n</code></pre>\n<ul>\n<li>静态类型\n<ul>\n<li>指针的类型就是<strong>静态类型</strong></li>\n</ul>\n</li>\n<li>动态类型\n<ul>\n<li>所指向的对象的类型是<strong>动态类型</strong></li>\n<li>动态类型可以通过赋值等操作改变</li>\n</ul>\n</li>\n</ul>\n<p>virtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载</p>\n<p>但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数</p>\n<h3 id=\"has-a和根据xx实现出\">has-a和根据xx实现出</h3>\n<p>一个类中有多个小类，这种关系被称为<strong>复合（composition）</strong>，其中这些小类被称为<strong>合成成分物（composed object）</strong></p>\n<ul>\n<li>在应用域，复合意味着<code>has-a</code>\n<ul>\n<li>人有名字（也不尽然）</li>\n</ul>\n</li>\n<li>在实现域，复合意味着<code>is-implemented-in-terms-of</code>\n<ul>\n<li>队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"少用private继承\">少用private继承</h3>\n<p><em>经典 C++糟粕，请问 C#有这个吗？</em></p>\n<p>本质上是一种<code>is-implemented-in-terms-of</code>关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术</p>\n<ul>\n<li>private继承，编译器无法自动将子类对象转化为父类对象</li>\n<li>private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）</li>\n</ul>\n<p><strong>尽量使用复合来替代pirvate继承</strong>，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数</p>\n<p>此外private继承的对象有可能比复合的对象要小</p>\n<h3 id=\"少用多重继承\">少用多重继承</h3>\n<p><em>经典 C++糟粕，请问 C#有这个吗？</em></p>\n<ul>\n<li>可能会导致歧义\n<ul>\n<li>当然你可以在调用函数的时候指出是来自哪一个基类</li>\n</ul>\n</li>\n<li>可能会导致菱形继承\n<ul>\n<li>菱形继承可能会导致变量重复</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"七：模版与泛型\">七：模版与泛型</h2>\n<p>模板（templates）是泛型编程（generic programming）的基础</p>\n<p>模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译</p>\n<h3 id=\"评价\">评价</h3>\n<p>优点：</p>\n<ol>\n<li>模板编程能够实现非常灵活且类型安全的接口</li>\n<li>极好的性能（更小的文件、更短的运行期，更少的内存需求）</li>\n<li>可以将一些运行时才能侦测到的错误，在编译期找出来</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>难以编程和维护</li>\n<li>编译报错信息难以理解</li>\n<li>难以重构</li>\n<li>编译时间大幅变长</li>\n</ol>\n<p>因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释</p>\n<h3 id=\"隐式接口和编译期多态\">隐式接口和编译期多态</h3>\n<ul>\n<li>OOP中经常使用显式接口和运行时多态</li>\n<li>泛型编程更多使用隐式接口和编译期多态</li>\n</ul>\n<pre><code class=\"language-C++\">template&lt;typename T&gt;\nvoid doProcessing(T&amp; w)\n&#123;\n    if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget)&#123;\n        T temp(w)\n        temp.normalize();\n        temp.swap(w);\n    &#125;\n&#125;\n</code></pre>\n<p>从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组<strong>隐式接口</strong></p>\n<p>所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功</p>\n<p>这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是<strong>编译期多态</strong></p>\n<h3 id=\"Traits\">Traits</h3>\n<p>一种约定俗成的技术方案，为同一类数据提供统一的操作函数</p>\n<p>比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。</p>\n<pre><code class=\"language-C++\">enum Type&#123;\n    TYPE_1;\n    TYPE_2;\n&#125;;\nclass FOO&#123;\n    Type type = Type::TYPE_1;\n&#125;;\nclass Bar&#123;\n    Type type = Type::TYPE_2;\n&#125;;\n//统一的模板函数\ntemplate&lt;typename T&gt;\nvoid decode(const T&amp; data, char* buf)&#123;\n    if(T::type == Type::TYPE_1)&#123;\n        ...\n    &#125;\n    else if(T::type == Type::TYPE_2)&#123;\n        ...\n    &#125;\n&#125;\n</code></pre>\n<p>但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术</p>\n<pre><code class=\"language-C++\">enum Type&#123;\n    TYPE_1;\n    TYPE_2;\n&#125;;\nclass FOO&#123;\n    Type type = Type::TYPE_1;\n&#125;;\nclass Bar&#123;\n    Type type = Type::TYPE_2;\n&#125;;\n\ntemplate&lt;typename T&gt;\nstruct type_traits&#123;\n    Type type = T::type;\n&#125;\n//为内置数据类型特化为独有的 type_traits\ntemplate&lt;typename int&gt;\nstruct type_traits&#123;\n    Type type = Type::TYPE_1;\n&#125;\n//统一的模板函数\ntemplate&lt;typename T&gt;\nvoid decode(const T&amp; data, char* buf)&#123;\n    if(type_traits&lt;T&gt;::type == Type::TYPE_1)&#123;\n        ...\n    &#125;\n    else if(type_traits&lt;T&gt;::type == Type::TYPE_2)&#123;\n        ...\n    &#125;\n&#125;\n</code></pre>\n<p>该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因</p>\n<h3 id=\"模板元编程\">模板元编程</h3>\n<p>TMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化</p>\n<p>如果一门语言具备以下功能，则称为图灵完全</p>\n<ol>\n<li>数值运算和符号运算</li>\n<li>判断</li>\n<li>递归</li>\n</ol>\n<h4 id=\"数值运算-递归\">数值运算+递归</h4>\n<pre><code class=\"language-C++\">//一个TMP计算阶乘，而且阶乘的技术发生在编译期\ntemplate&lt;unsigned n&gt;\nstruct Factorial\n&#123;\n    enum &#123; value = n * Factorial&lt;n-1&gt;::value &#125;;\n&#125;;\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt;\n&#123;\n    enum &#123; value = 1 &#125;;\n&#125;;\n\nint main()\n&#123;\n    std::cout &lt;&lt; Factorial&lt;5&gt;::value;\n&#125;\n</code></pre>\n<p>C++11TMP这种函数式编程得到了加强，上文也可以这样写</p>\n<pre><code class=\"language-C++\">template&lt;unsigned n&gt;\nstruct Factorial\n&#123;\n    constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;;\n&#125;;\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt;\n&#123;\n    constexpr static auto value = 1;\n&#125;;\n</code></pre>\n<h4 id=\"判断\">判断</h4>\n<pre><code class=\"language-C++\">template&lt;bool Value&gt;\nstruct if_constexpr\n&#123;\n    constexpr static auto value = 1;\n&#125;;\n\ntemplate&lt;&gt;\nstruct if_constexpr&lt;false&gt; &#123;\n    constexpr static auto value = 2;\n&#125;;\n\nint main()\n&#123;\n    std::cout &lt;&lt; if_constexpr&lt;true&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; if_constexpr&lt;false&gt;::value &lt;&lt; std::endl;\n&#125;\n</code></pre>\n<h3 id=\"typedef\">typedef</h3>\n<p>在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名</p>\n<p>下面是一个函数指针的示例</p>\n<pre><code class=\"language-C++\">void add(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; x + y &lt;&lt; std::endl;\n&#125;\nvoid dec(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x-y=&quot; &lt;&lt; x - y &lt;&lt; std::endl;\n&#125;\nvoid mul(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x*y=&quot; &lt;&lt; x*y &lt;&lt; std::endl;\n&#125;\n\nvoid (*op[3])(int, int) = &#123; add, dec, mul &#125;;\n\nint main()\n&#123;\n    for (int i = 0; i &lt; 3; ++i) &#123;\n        （*op[i])(4, 3);\n    &#125;\n&#125;\n</code></pre>\n<p>如果使用typedef</p>\n<pre><code class=\"language-C++\">typedef void (*Func[3])(int, int);\nFunc f = &#123; add, dec, mul &#125;;\n\nint main()\n&#123;\n    for (int i = 0; i &lt; 3; ++i) &#123;\n        f[i](4, 3);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"八：定制new和delete\">八：定制new和delete</h2>\n<p>Java和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目</p>\n<h3 id=\"new-handler\">new-handler</h3>\n<p>当<code>operator new</code>无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即<code>new-handler</code></p>\n<p>使用<code>set_new_handler</code>来指定<code>new-handler</code></p>\n<pre><code class=\"language-c++\">void outOfMem()&#123;\n  std::cerr &lt;&lt; &quot;内存不足\\n&quot;;\n  std::abort();\n&#125;\nint main()&#123;\n  std::set_new_handler(outOfMem);\t\t//该函数的参数是一个函数指针\n  int* array = new int[10000000L];\n  ...\n&#125;\n</code></pre>\n<p>当<code>operator new</code>无法满足内存申请时，会不断调用<code>new-handler</code>函数，直到找到足够的内存，所以<code>new-handler</code>函数应该满足</p>\n<ul>\n<li>让更多的内存可被使用\n<ul>\n<li>实现方法是程序开始时就分配一大块内存，每次调用<code>new-handler</code>时就释放一点点</li>\n</ul>\n</li>\n<li>安装另一个<code>new-handler</code>\n<ul>\n<li>如果现在这个<code>new-handler</code>无法获取更多内存，需要知道哪一个<code>new-handler</code>具备增大内存的实力，然后使用<code>set_new_handler</code>来替换自己</li>\n</ul>\n</li>\n<li>卸除<code>new-handler</code>\n<ul>\n<li>通过<code>set_new_handler</code>赋值<code>null</code>，将<code>new-handler</code>卸载，使得在内存分配不足时，会抛异常</li>\n</ul>\n</li>\n<li>抛出<code>bad_alloc</code>异常\n<ul>\n<li>这种异常不会被<code>operator new</code>捕获，会被传播至内存索求处</li>\n</ul>\n</li>\n<li>不反回\n<ul>\n<li>调用<code>abort</code>或者<code>exit</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class NewHandlerHolder&#123;\npublic:\n  explicit NewHandlerHolder(std::new_handler nh): handler(nh) &#123;&#125;\t//获取当前的new_handler\n  ~NewHandlerHolder() &#123; std::set_new_handler(handler); &#125;\t\nprivate:\n  std::new_handler handler;\t\t//用于记录当前的new_handler\n&#125;;\nvoid* Widget::operator new(std::size_t size) throw(std::bad_alloc)&#123;\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\t//安装Widget的new-handler\n  return ::operator new(size);\t//分配对象或者抛异常\n&#125;\n//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值\n</code></pre>\n<pre><code class=\"language-c++\">void outOfMem();\nWidget::set_new_handler(outOfMem);\nWidget* pwl = new Widget;\t//内存不足时会调用outOfMem\n</code></pre>\n<p>mixin风格的写法</p>\n<pre><code class=\"language-c++\">template&lt;typename T&gt;\nclass NewHandlerSupport&#123;\npublic:\n  static std::new_handler_set set_new_handler(std::new_handler p) throw();\n  static void* operator new(std::size_t size) throw(std::bad_alloc);\n  ...\nprivate:\n  static std::new_handler currentHandler;\n&#125;;\n\ntemplate&lt;typename T&gt;\nstd::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()&#123;\n  std::new_handler oldHandler = currentHandler;\n  currentHandler = p;\n  return oldHandler;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) throw(std::bad_alloc)&#123;\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\n  return ::operator new(size);\n&#125;\n</code></pre>\n<pre><code class=\"language-c++\">class Widget: public NewHandlerSupport&lt;Widget&gt;&#123;\n\t...\n&#125;;\n</code></pre>\n<p>像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为<strong>怪异的循环模版模式（curiously recurring template pattern，CRTP）</strong></p>\n<h3 id=\"替换new和delete的时机\">替换new和delete的时机</h3>\n<p>C++中所有的news返回的指针都必须要<strong>地址对齐</strong>，int要4对齐，double要8对齐</p>\n<p>写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换</p>\n<h3 id=\"编写new和delete的规则\">编写new和delete的规则</h3>\n<p>如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则</p>\n<ul>\n<li>\n<p>new</p>\n<ul>\n<li>应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用<code>new-handler</code></li>\n<li>有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）</li>\n<li>new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理<strong>比正确大小更大的（错误）申请</strong></li>\n</ul>\n</li>\n<li>\n<p>delete</p>\n<ul>\n<li>收到null指针时不做任何事</li>\n<li>处理<strong>比正确大小更大的（错误）申请</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"编写new时也要写对应的delete\">编写new时也要写对应的delete</h3>\n<pre><code class=\"language-c++\">Widget* pw = new Widget;\n</code></pre>\n<p>在这里调用了两个函数，一个时用以分配内存的<code>operator new</code>，一个是<code>Widget</code>的构造函数</p>\n<p>如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的</p>\n<p>运行时系统会调用<code>operator new</code>所对应的<code>operator delete</code>来释放地址，对于拥有正常签名式的new和delete来说不成问题</p>\n<pre><code class=\"language-c++\">void* operator new(std::size_t) throw(std::bad_alloc);\t//普通的new\nvoid operator delete(void* rawMemory) throw();\t//global中的普通的new\nvoid operator delete(void* rawMemory, std::size_t size) throw();\t//class中的new\n</code></pre>\n<p>但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题</p>\n<pre><code class=\"language-c++\">void* operator new(std::size_t, void* pMemory) throw();\t//placement new，比普通new多带一个参数\n\nWidget* pw = new (std::cerr) Widget;\t//调用operator new，并以cerr作为其实参\n</code></pre>\n<p>当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的<code>operator new</code>时如何运作的，所以运行时系统会去寻找<strong>参数个数与类型</strong>都与<code>operator new</code>相同的某个<code>operator delete</code></p>\n<pre><code class=\"language-c++\">void operator delete(void*, std::ostream&amp;) throw();\t//palcement delete\n</code></pre>\n<pre><code class=\"language-c++\">class Widget&#123;\npublic:\n  static void* operator new(std::size_t size, std::ostream&amp; logStream) throw(std::bad_alloc);\n  static void operator delete(void* pMemory) throw();\n  static void operator delete(void* pMemoty, std::ostream&amp; logStream) throw();\n  ...\n&#125;;\n</code></pre>\n<p>如果此时调用<code>delete pw</code>，只会调用普通的<code>delete</code>，因为只有在构造时发生异常时，运行时系统才会调用placement delete</p>\n<p>最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete</p>\n<h2 id=\"九：杂项\">九：杂项</h2>\n<h3 id=\"不要忽视编译器警告\">不要忽视编译器警告</h3>\n<p>很多人忽视警告，毕竟一个问题如果真的很严重，应该报错</p>\n<p>比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为</p>\n<pre><code class=\"language-c++\">class B&#123;\npublic:\n  virtual void f() const;\n&#125;;\nclass D: public B&#123;\n  virtual void f();\n&#125;;\n</code></pre>\n<p>报警告</p>\n<pre><code class=\"language-c++\">warning: D::f() hides virtual B::f()\n</code></pre>\n<p>原本的目的是为了在D中重新定义virtual函数<code>f()</code>，但由于B中<code>f()</code>是const，在D中不是，此时B中的<code>f()</code>并没有在D中重新被声明，而是被整个遮掩了</p>\n<h3 id=\"去熟悉标准程序库\">去熟悉标准程序库</h3>\n<p>尤其是TR1</p>\n<h4 id=\"C-98有什么\">C++98有什么</h4>\n<ul>\n<li>STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器</li>\n<li>Iostream</li>\n<li>国际化支持</li>\n<li>数值处理，包括复数（complex）和纯数值数组（valarray）</li>\n<li>异常阶层体系</li>\n<li>C89标准程序库</li>\n</ul>\n<h4 id=\"TR1有什么（全在std-tr1中）\">TR1有什么（全在<code>std::tr1</code>中）</h4>\n<ul>\n<li>智能指针<code>tr1::shared_ptr</code>和<code>tr1::weak_ptr</code></li>\n<li><code>tr1::function</code></li>\n<li><code>tr1::bind</code></li>\n</ul>\n<p>和（彼此无关的独立组件）</p>\n<ul>\n<li>哈希表</li>\n<li>正则表达式</li>\n<li>Tuple变量组</li>\n<li><code>tr1::array</code></li>\n<li><code>tr1::mem_fn</code></li>\n<li><code>tr1::reference_wrapper</code></li>\n<li>随机数生成工具</li>\n<li>数学特殊函数</li>\n<li>C99兼容</li>\n</ul>\n<p>和（基于template）</p>\n<ul>\n<li>Type traits</li>\n<li><code>tr1::result_of</code></li>\n</ul>\n<h3 id=\"熟悉Boost\">熟悉Boost</h3>\n","site":{"data":{}},"excerpt":"","more":"<h1>Effective C++</h1>\n<h2 id=\"一：C-基础\">一：C++基础</h2>\n<h3 id=\"C-很成熟，很NB\">C++很成熟，很NB</h3>\n<p>C++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）</p>\n<p>其核心是四个部分</p>\n<ul>\n<li>C\n<ul>\n<li>区块block</li>\n<li>语句statements</li>\n<li>预处理器preprocessor</li>\n<li>内置数据类型</li>\n<li>数组arrays</li>\n<li>指针pointers</li>\n</ul>\n</li>\n<li>Object-Orientend C++\n<ul>\n<li>类classes（构造函数，析构函数）</li>\n<li>封装encapsulation</li>\n<li>继承inheritance</li>\n<li>多态polymorphism</li>\n<li>虚函数virtual（动态绑定）</li>\n</ul>\n</li>\n<li>Template C++</li>\n<li>STL</li>\n</ul>\n<h3 id=\"替换-define\">替换#define</h3>\n<p>使用编译器替代预处理器</p>\n<p>尽量使用const、enum定义常量，使用inlines定义函数宏</p>\n<h4 id=\"const\">const</h4>\n<pre><code class=\"language-c++\">#define PI 3.1415926\n</code></pre>\n<p>因为<code>#define</code>不是语言的一部分，在编译器开始工作前，<code>PI</code>就会被处理掉，所以一旦报错，你无法追踪到<code>PI</code>，只能看到<code>3.1415926</code>，这会<strong>浪费你的时间</strong></p>\n<p>应该改为</p>\n<pre><code class=\"language-c++\">const double Pi 3.1415926;\n</code></pre>\n<p>值得注意的事</p>\n<ul>\n<li>定义常量指针指向char*-based字符串</li>\n</ul>\n<pre><code class=\"language-c++\">const char* const authorName = &quot;Reuben&quot;;\n</code></pre>\n<ul>\n<li>作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员</li>\n</ul>\n<pre><code class=\"language-c++\">class GemePlayer&#123;\nprivate:\n\tstatic const int NumTurns = 5;\t//这只是一个声明式\n\tint scores[NumTurns];\n&#125;;\nconst int GamePlayer::NumTurns;\t\t//这是定义式，因为在声明时已经赋值，所以这里就不赋值了\n</code></pre>\n<p>C++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式</p>\n<p>从这里可以看出，<strong>const可以封装</strong>，而#define不行</p>\n<h4 id=\"enum\">enum</h4>\n<pre><code class=\"language-c++\">class GemePlayer&#123;\nprivate:\n\tenum &#123; NumTurns = 5 &#125;;\n\tint scores[NumTurns];\n&#125;;\n</code></pre>\n<h3 id=\"const指针\">const指针</h3>\n<p>const在星号左边，被指物是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nconst char* p = greeting;\n</code></pre>\n<p>const在星号右边，指针本身是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nchar* const p = greeting;\n</code></pre>\n<p>const在星号两边，被指物和指针都是常量</p>\n<pre><code class=\"language-c++\">char greeting[] = &quot;Hello&quot;;\nconst char* const p = greeting;\n</code></pre>\n<h3 id=\"确认对象在使用前已经被初始化\">确认对象在使用前已经被初始化</h3>\n<p>C++初始化顺序</p>\n<ul>\n<li>基类比子类先初始化</li>\n<li>成员变量根据其声明次序初始化</li>\n</ul>\n<h2 id=\"二：构造-析构-赋值\">二：构造/析构/赋值</h2>\n<h3 id=\"空类的默认函数\">空类的默认函数</h3>\n<p>一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数</p>\n<p>一个类，如果没有构造函数，也会自动声明一个default构造函数</p>\n<p>这些函数都是public且inline的</p>\n<h3 id=\"禁用自动生成的函数\">禁用自动生成的函数</h3>\n<p>如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）</p>\n<ul>\n<li>你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）</li>\n</ul>\n<pre><code class=\"language-c++\">class HomeForSale&#123;\nprivate:\n\tHomeForSale(const HomeForSale&amp;);\n  HomeForSale&amp; operator=(const HomeForSale&amp;);\n&#125;;\n</code></pre>\n<p>可以制作一个不可被copy的类，让子类继承</p>\n<pre><code class=\"language-c++\">class Uncopyable&#123;\nprotected:\n\tUncopyable()&#123;&#125;\n  ~Uncopyable()&#123;&#125;\nprivate:\n  Uncopyable(const Uncopyable&amp;);\n  Uncopyable&amp; operator=(const Uncopyable&amp;);\n&#125;;\n\nclass HomeForSale: private Uncopyable&#123;\n  ...\n&#125;;\n</code></pre>\n<h3 id=\"为多态基类声明virtual析构函数\">为多态基类声明virtual析构函数</h3>\n<h4 id=\"一定要有一个virtual析构函数\">一定要有一个virtual析构函数</h4>\n<ul>\n<li>如果这个类要成为一个基类，那么一定要有一个virtual析构函数</li>\n</ul>\n<p>在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错</p>\n<pre><code class=\"language-c++\">class TimeKeeper&#123;\npublic:\n\t...\n&#125;;\nclass AtomicClock: public TimeKeeper &#123;...&#125;;\nclass WaterClock: public TimeKeeper &#123;...&#125;;\n</code></pre>\n<pre><code class=\"language-c++\">TimeKeeper* ptk = getTimeKeeper();\t\t//创建一个动态分配对象\n...\ndelete ptk;\t//释放对象，避免资源泄漏\n</code></pre>\n<p>上面这个过程的问题其实出在<code>getTimeKeeper()</code>指向一个派生类（derived class）对象（比如<code>AtomicClock</code>），而这个对象却要经由一个基类（base class）指针删除（比如<code>TimeKeeper*</code>）</p>\n<p>如果这个基类的析构函数不是virtual的，就会出现问题：</p>\n<ul>\n<li>如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象</li>\n</ul>\n<p>解决方法就是给基类一个virtual析构函数</p>\n<pre><code class=\"language-c++\">class TimeKeeper&#123;\npublic:\n\tTimeKeeper();\n  virtual ~TimeKeeper();\n  ...\n&#125;;\n</code></pre>\n<h4 id=\"最好不要有virtual析构函数\">最好不要有virtual析构函数</h4>\n<ul>\n<li>如果这个类不可能成为基类，那么最好不要有virtual析构函数</li>\n</ul>\n<p>为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由<strong>vptr（virtual table pointer）<strong>指针携带，这个指针指向一个由函数指针构成的数组，称为</strong>vtbl（virtual table）</strong>，每一个带有virtual函数的类都有一个属于自己的vtbl</p>\n<p><strong>这个vtbl会增大对象的体积</strong>，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍</p>\n<p><strong>这个vtbl会让代码失去兼容性</strong>，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性</p>\n<h4 id=\"请不要继承没有virtual析构函数的类\">请不要继承没有virtual析构函数的类</h4>\n<p>比如string、vector、list、set等等</p>\n<p>而且 C++没有像 Java的<code>final classes</code>或者C#的<code>sealed classes</code>的禁止派生机制</p>\n<h3 id=\"不要在析构函数里抛出异常\">不要在析构函数里抛出异常</h3>\n<p>当一个<code>vector v</code>容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为</p>\n<p>有两个不怎么好的解决方法</p>\n<ul>\n<li>遇到异常，直接<code>std::abort()</code>，即遇到异常，宁愿直接强制停止程序，也不要让异常传播</li>\n<li>遇到异常，把异常记录下来，另程序继续运转，即<strong>吞下异常</strong>\n<ul>\n<li>这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好</li>\n</ul>\n</li>\n</ul>\n<p>比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容</p>\n<pre><code class=\"language-c++\">class DBConnevtion&#123;\npublic:\n    ...\n    static DBConnevtion create();\n    void close();     \n&#125;;\nclass DBConn&#123;\npublic:\n    ...\n    void close()\t//封装给客户用的,关闭连接的函数\n    &#123;\n        db.close();\n        closed = true;\n    &#125;\n    ~DBConn()&#123;\n        if(!closed)&#123;\n            try&#123;\n                db.close();\n            &#125;\n            catch(...)&#123;\n                ...\n                //强制关闭程序或者吞下异常\n            &#125;\n        &#125;\n    &#125;\nprivate:\n    DBConnection db;\n    bool closed;\n&#125;;\n</code></pre>\n<h3 id=\"不要在构造和析构过程中调用virtual函数\">不要在构造和析构过程中调用virtual函数</h3>\n<p>在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果</p>\n<p>可以简单理解为<strong>在C++中，基类构造期间，vritual函数不是vritual函数</strong></p>\n<p>因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数</p>\n<p>同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的</p>\n<h3 id=\"令operator-返回一个对-this的引用\">令operator=返回一个对*this的引用</h3>\n<p>连续赋值</p>\n<pre><code class=\"language-c++\">x = y = z = 15;\n//其实就等于x = (y = (z = 15))；\n</code></pre>\n<p>为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参</p>\n<pre><code class=\"language-c++\">class Widget&#123;\npublic:\n    Widget&amp; operator=(const Widget&amp; rhs)\n    &#123;\n    \t...\n        return *this;\n    &#125;\n    Widget&amp; operator+=(const Widget&amp; rhs)&#123;\n        ...\n        return *this;\n    &#125;\n&#125;;\n</code></pre>\n<h3 id=\"在operator-中处理自我赋值\">在operator=中处理自我赋值</h3>\n<p>如果对象自己赋给自己，我们称之为自我赋值</p>\n<pre><code class=\"language-c++\">w = w;\na[i] = a[j]; //当i=j时，自我赋值\n*px = *py;\t//px和py指向同一个物体时，自我赋值\n</code></pre>\n<p>在赋值操作中：</p>\n<ol>\n<li>我们会先另左边的操作数先释放掉当前使用的数据</li>\n<li>令其使用右操作数的副本</li>\n<li>最后返回左操作数</li>\n</ol>\n<pre><code class=\"language-c++\">class Widget&#123;\n    ...\nprivate:\n    Bitmap *pb;\n&#125;;\n//!!!这个不安全\nWidget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\n&#125;\n</code></pre>\n<p>如果自我赋值，即rhs和pb指向同一个对象，那么<code>delete pb</code>后，这个对象就已经被销毁了，下面使用的<code>*rhs</code>就是一个已经被删除的对象</p>\n<p>解决方法1：延后delete</p>\n<pre><code class=\"language-c++\">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    Bitmap* pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\n    delete pOrig;\n    return *this;\n&#125;\n</code></pre>\n<p>解决方法2：使用copy and swap技术</p>\n<pre><code class=\"language-c++\">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;\n    Widget temp(rhs);\n    swap(temp);\t\t//令*this与temp交换\n    return *this;\n&#125;\n</code></pre>\n<h3 id=\"复制对象的一切\">复制对象的一切</h3>\n<p>如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错</p>\n<p>派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）</p>\n<p>所以copy函数需要</p>\n<ul>\n<li>复制所有local变量</li>\n<li>调用所有基类中的适当的copy函数</li>\n</ul>\n<h2 id=\"三：资源管理\">三：资源管理</h2>\n<h3 id=\"让对象管理资源\">让对象管理资源</h3>\n<p>将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源</p>\n<ul>\n<li>申请资源后立即将其放进对象中，<strong>资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）</strong></li>\n<li>在对象的析构函数中释放资源</li>\n</ul>\n<p>C++的<code>auto_ptr</code>是一个<strong>类指针（pointer-like）对象</strong>，也就是<strong>智能指针</strong>，其析构函数会自动delete掉其所指向的对象</p>\n<p>注意：</p>\n<ul>\n<li>不要让多个<code>auto_ptr</code>指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”</li>\n<li><code>auto_ptr</code>如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权</li>\n</ul>\n<p>**RCSP（引用计数型智能指针）**也是一种智能指针（比如<code>tr1::shared_ptr</code>），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源</p>\n<h3 id=\"小心copy行为\">小心copy行为</h3>\n<p>大多数RAII对象的copy函数：</p>\n<ul>\n<li>禁止复制</li>\n<li>采用引用计数法（RCSP）</li>\n<li>复制底部资源（深拷贝）</li>\n<li>转移底层资源所有权（auto_ptr）</li>\n</ul>\n<h3 id=\"在资源管理类中提供对原始资源的访问\">在资源管理类中提供对原始资源的访问</h3>\n<p>有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）</p>\n<h3 id=\"new与delete一个数组\">new与delete一个数组</h3>\n<p>一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？</p>\n<ul>\n<li>如果new了一个数组，就delete一个数组</li>\n</ul>\n<pre><code class=\"language-c++\">string* ptr1 = new string[100];\ndelete [] ptr1;\n</code></pre>\n<ul>\n<li>如果new了一个对象，就delete一个对象</li>\n</ul>\n<pre><code class=\"language-c++\">string* ptr2 = new string;\ndelete ptr2;\n</code></pre>\n<p>很多时候很难确定当前这个对象是数组还是一个对象</p>\n<pre><code class=\"language-c++\">typedef string AddressLines[4];\nstring* pal = new AddressLines;\ndelete [] pal;\n</code></pre>\n<p>最简单的方法是不用数组，使用STL里的容器，如<code>vector&lt;string&gt;</code></p>\n<h3 id=\"以独立语句将newed对象置入智能指针\">以独立语句将newed对象置入智能指针</h3>\n<p>C++中调用一个函数，会先计算每一个传递进去的实参</p>\n<p>如果按下面的写法，将newed对象置入智能指针中</p>\n<pre><code class=\"language-c++\">分配函数(shared_ptr&lt;Widget&gt;(new Widget), 资源访问);\t\t//不要这样写\n</code></pre>\n<p>需要执行一下函数</p>\n<ul>\n<li>调用“资源访问”函数（A）</li>\n<li>执行<code>new Widget</code>（B）</li>\n<li>调用<code>shared_ptr</code>构造函数（C）</li>\n</ul>\n<p>然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）</p>\n<p>如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏</p>\n<p>所以简单的方法是分离语句</p>\n<pre><code class=\"language-c++\">shared_ptr&lt;Widget&gt; pw(new Widget);\n分配函数(pw, 资源访问);\n</code></pre>\n<h2 id=\"四：设计与声明\">四：设计与声明</h2>\n<h3 id=\"让接口容易被正确使用\">让接口容易被正确使用</h3>\n<p>客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）</p>\n<h4 id=\"限制参数传递\">限制参数传递</h4>\n<p>这是一个日期类</p>\n<pre><code class=\"language-c++\">class Date&#123;\npublic:\n  Date(int month, int day, int year);\n  ...\n&#125;;\n...\nDate d(4, 20, 2022);\n</code></pre>\n<p>客户很有可能填错顺序，也有可能填入一个无效的参数</p>\n<p>可以使用<strong>外覆类型（wrapper types）</strong>，当然做出类会更好</p>\n<pre><code class=\"language-c++\">struct Day&#123;\n  explict Day(int d) : val(d) &#123;&#125;\n  int val;\n&#125;;\nstruct Month&#123;\n  explict Month(int m) : val(m) &#123;&#125;\n  int val;\n&#125;;\nstruct Year&#123;\n  explict Year(int y) : val(y) &#123;&#125;\n  int val;\n&#125;;\nclass Date&#123;\npublic:\n  Date(const Mouth&amp; month, const Day&amp; day, const Year&amp; year);\n  ...\n&#125;;\n...\nDate d(Month(4), Day(20), Year(2022));\n</code></pre>\n<h4 id=\"一致性\">一致性</h4>\n<p>自定义的行为要与内置类型的行为一致，比如你不能把<code>operator*</code>重载成<code>operator+</code></p>\n<p>或则像STL中，容器的接口都很一致，比如<code>size</code>、<code>push_back</code>等等</p>\n<h3 id=\"设计class犹如设计type\">设计class犹如设计type</h3>\n<ul>\n<li>对象要如何创建和销毁</li>\n<li>对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）</li>\n<li>对象如果被值传递，意味着什么（深浅拷贝）</li>\n<li>约束成员变量的合法值</li>\n<li>是否可以/需要被继承</li>\n<li>能否类型转换，如何类型转换</li>\n<li>支持何种操作符</li>\n<li>成员变量的访问修饰</li>\n<li>成员函数的访问修饰</li>\n<li>未声明接口（undecided interface）</li>\n<li>是否需要定义模版</li>\n<li>真的需要一个新类吗？</li>\n</ul>\n<h3 id=\"多用引用传递\">多用引用传递</h3>\n<p>C++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些<strong>很大的自定义类型</strong>来说性能非常糟糕</p>\n<p>使用const引用传递会好很多</p>\n<ul>\n<li>不会创建新的对象</li>\n<li>不会改变原有对象</li>\n<li>可以避免<strong>对象切割</strong>问题\n<ul>\n<li>对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了</li>\n</ul>\n</li>\n</ul>\n<p>只不过引用传递是大多是通过指针实现的，在处理一些<strong>简单的内置类型</strong>时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递</p>\n<h3 id=\"必须返回对象时，不要返回引用\">必须返回对象时，不要返回引用</h3>\n<p>如果必须返回对象，请不要返回引用（比如<code>operator*</code>，<code>operator==</code>），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个<strong>右值</strong>的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用</p>\n<h3 id=\"将成员变量隐藏\">将成员变量隐藏</h3>\n<p>成员变量应该为private，而不是public</p>\n<ul>\n<li>客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）</li>\n<li>分离读写权限（这一点C#做的更好？）</li>\n<li>封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）</li>\n<li>便于对成员变量进行约束（更不容易出现异常值）</li>\n<li>protected并不比public更具有封装性</li>\n</ul>\n<h3 id=\"使用非成员函数\">使用非成员函数</h3>\n<ul>\n<li>C#，java选手可以略过</li>\n<li>C++标准库就是这样写的</li>\n</ul>\n<p>这里有一个类，其中有多个成员函数</p>\n<pre><code class=\"language-c++\">class WebBrowser&#123;\npublic:\n\tvoid doA();\n  void doB();\n  void doC();\n  ...\n&#125;;\n</code></pre>\n<p>现在需要令一个函数做ABC三件事，有两种写法</p>\n<ul>\n<li>成员函数</li>\n</ul>\n<pre><code class=\"language-c++\">class WebBrowser&#123;\npublic:\n\t...\n  void doEverything()&#123;\n    doA();\n    doB();\n    doC();\n  &#125;\n  ...\n&#125;;\n</code></pre>\n<ul>\n<li>非成员函数</li>\n</ul>\n<pre><code class=\"language-c++\">void doEverything(WebBrowser&amp; wb)&#123;\n\twb.doA();\n  wb.doB();\n  wb.doC();\n&#125;\n</code></pre>\n<p>令人意外的是，第二种方法（使用非成员函数）更好</p>\n<h4 id=\"什么是封装\">什么是封装</h4>\n<p>一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强</p>\n<p>为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物</p>\n<h4 id=\"为什么第二种比第一种封装性更强\">为什么第二种比第一种封装性更强</h4>\n<p>因为第一种给用户两种调用方法，一个是调用成员函数<code>doEverything()</code>，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性</p>\n<ul>\n<li>注意第一种方法中，<code>doEverything()</code>和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利</li>\n</ul>\n<p>那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的<strong>静态成员（static member）函数</strong>即可</p>\n<p>或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）</p>\n<pre><code class=\"language-c++\">namespace WebBrowserStuff&#123;\n\tclass WebBrowser&#123;...&#125;;\n\tvoid doEverything(WebBrowser&amp; wb)&#123;...&#125;\n&#125;\n</code></pre>\n<ul>\n<li>\n<p>可拓展性更强</p>\n<ul>\n<li>客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）</li>\n</ul>\n</li>\n<li>\n<p>可拆分</p>\n<ul>\n<li>用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如果所有参数都需要进行类型转换，使用非成员函数\">如果所有参数都需要进行类型转换，使用非成员函数</h3>\n<p>令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时</p>\n<p>比如一个有理数乘法</p>\n<pre><code class=\"language-c++\">class Rational&#123;\npublic:\n  //这个类没有自定义的explict构造函数\n  const Rational opertaor* (const Rational&amp; rhs) const;\n  ...\n&#125;;\n</code></pre>\n<pre><code class=\"language-c++\">Rational oneEighth(1,8);\nRational oneHalf(1,2);\nRational result = oneHalf * oneEighth;\t//成功\nresult = result * oneEighth;\t//成功\nresult = oneHalf * 2;\t\t//成功，等价于 result = oneHalf.operator*(2)\nresult = 2 * oneHalf;\t\t//失败，等价于 result = 2.operator*(oneHalf)\n</code></pre>\n<p><code>result = oneHalf * 2;</code>为什么成功，因为这里发生了一次隐式转换，将<code>2</code>转化为了一个<code>Rational</code>类型</p>\n<p>在编译器中可能等价于</p>\n<pre><code class=\"language-c++\">const Rational temp(2);\nresult = oneHalf * temp;\n</code></pre>\n<ul>\n<li>如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将<code>2</code>转化为一个<code>Rational</code>类型</li>\n</ul>\n<p><code>result = 2 * oneHalf;\t</code>为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时<code>2</code>就是一个int类型，没有我们所自定义的<code>operator*</code>函数，自然会失败</p>\n<p>可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）</p>\n<pre><code class=\"language-c++\">const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123;\n  return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());\n&#125;\n</code></pre>\n<ul>\n<li>此外要极力避免使用<strong>友元（friend）函数</strong></li>\n<li>成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数</li>\n</ul>\n<h3 id=\"写一个不抛异常的swap函数\">写一个不抛异常的swap函数</h3>\n<p>swap函数原本是STL的一部分，后来称为了<strong>异常安全性编程</strong>的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要</p>\n<p>std是一个很特殊的命名空间，客户可以<strong>全特化</strong>（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定</p>\n<p>全特化：针对某个类做模板函数的特例，如对<code>std::swap</code>做一个针对<code>Widget</code>的特化</p>\n<pre><code class=\"language-c++\">class WidgetImpl&#123;...&#125;;\t\t//这个类的对象中存储着真正的数据\nclass Widget&#123;\npublic:\n    Widget&amp; operator=(const Widget&amp; rhs)&#123;\n        ...\n        *pImpl = *(rhs.pImpl);\n        ...\n    &#125;\n    ...\n    void swap(Widget&amp; other)&#123;\t//这个函数决对不可抛异常\n        using std::swap;\n        swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针\n    &#125;\n    ...\nprivate:\n    WidgetImple* pImpl;\t\t//这个类有一个指向资源对象的指针\n&#125;;\nnamespace std&#123;\n\ttemplate&lt;&gt;\n    void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;\t//这个可以抛异常\n        a.swap(b);\t\n    &#125;\n&#125;\n</code></pre>\n<p>此外，C++的STL容器就是上面这种写法，提供了<code>public swap</code>成员函数和<code>std::swap</code>的特化版本</p>\n<h2 id=\"五：实现（Implementations）\">五：实现（Implementations）</h2>\n<ul>\n<li>随意定义变量可能会导致性能降低</li>\n<li>过度使用转型（casts）可能会导致性能降低，难以维护，可读性低</li>\n<li>返回对象的内部数据的handles，可能会破坏封装</li>\n<li>未考虑异常可能会导致资源泄露和数据败坏</li>\n<li>过度使用inline可能会导致包体膨胀</li>\n<li>过度耦合（coupling）可能会增加构建时间（build times）</li>\n</ul>\n<h3 id=\"尽量延后变量定义式的出现时间\">尽量延后变量定义式的出现时间</h3>\n<h4 id=\"避免未曾使用的变量\">避免未曾使用的变量</h4>\n<p>如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过</p>\n<p>此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、</p>\n<h4 id=\"避免无意义的默认构造函数\">避免无意义的默认构造函数</h4>\n<p>如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好</p>\n<h4 id=\"循环\">循环</h4>\n<p>此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？</p>\n<p><strong>循环内</strong></p>\n<pre><code class=\"language-c++\">for(int i = 0; i &lt; n; i++)&#123;\n  Widget w(...);\n  ...\n&#125;\n</code></pre>\n<ul>\n<li>\n<p>n个构造函数+n个析构函数</p>\n</li>\n<li>\n<p>如果<code>Widget</code>是一个很敏感的类，这样会让其作用域更小，更容易理解和维护</p>\n</li>\n</ul>\n<p><strong>循环外</strong></p>\n<pre><code class=\"language-c++\">Widget w;\nfor(int i = 0; i &lt; n; i++)&#123;\n  w = ...;\n  ...\n&#125;\n</code></pre>\n<ul>\n<li>一个构造函数+一个析构函数+n个赋值操作</li>\n<li>如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）</li>\n</ul>\n<h3 id=\"少做转型\">少做转型</h3>\n<p>C++是强类型语言，设计目标应该是保证类型错误绝不发生，然而<strong>类型转换</strong>破坏了类型系统</p>\n<p>Java、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险</p>\n<p>C++的类型转化</p>\n<ul>\n<li>旧式转换\n<ul>\n<li><code>(T)expression</code></li>\n<li><code>T(expression)</code></li>\n</ul>\n</li>\n<li>新式转换\n<ul>\n<li><code>const_cast&lt;T&gt;(expression)</code>\n<ul>\n<li>用于将对象的<strong>常量性转除（cast away the constness）</strong></li>\n<li>比如将<code>const</code>转化为<code>non-const</code></li>\n</ul>\n</li>\n<li><code>dynamic_cast&lt;T&gt;(expression)</code>\n<ul>\n<li>用来<strong>安全向下转型</strong></li>\n<li>无法由旧式语句执行</li>\n<li>耗费巨大</li>\n</ul>\n</li>\n<li><code>reinterpret_cast&lt;T&gt;(expression)</code>\n<ul>\n<li>用于低级转型，实际操作取决于编译器，不可移植</li>\n<li>极其少用</li>\n</ul>\n</li>\n<li><code>static_cast&lt;T&gt;(expression)</code>\n<ul>\n<li>用于<strong>强迫隐式转换（implicit conversions）</strong></li>\n<li>比如<code>non-const</code>转化为<code>const</code>，<code>int</code>转化为<code>double</code>，<code>void*</code>转化为<code>typed</code>，基类指针转化为派生类指针</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>避免C++类型转换出问题的核心是<strong>避免使用基类的接口处理派生类</strong></p>\n<h4 id=\"一个对象多个地址\">一个对象多个地址</h4>\n<p>C++很神奇，如果一个基类指针指向一个派生类对象，如</p>\n<pre><code class=\"language-C++\">Dervied d;\nBase* b = &amp;d;\n</code></pre>\n<p>这可能会导致两个指针值不一样，即这个对象有两个地址，一个<code>Derivied*</code>指针一个<code>Base*</code>指针，这派生类指针上往往会有一个<strong>偏移量（offset）</strong>，通过这个偏移量，可以通过派生类指针找到基类指针</p>\n<p>上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以<strong>请不要假定对象在C++中如何布局</strong>，更不应该基于这个假设对对象进行类型转换</p>\n<p>如果你想让当前对象调用基类的函数，如果对<code>*this</code>做强制转化，转换为基类，<code>*this</code>其实是先前产生的<code>*this</code>对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题</p>\n<pre><code class=\"language-c++\">class SpecialWindow: public Window&#123;\npublic:\n  virtual void onResize()&#123;\n    //static_cast&lt;Window&gt;(*this).onResize();\t//这样不好\n    Window::onResize();\t\t//请用这种方式调用基类的onResize函数（作用到当前对象上）\n    ...\n  &#125;\n&#125;\n</code></pre>\n<h4 id=\"dynamic-cast\">dynamic_cast</h4>\n<p>这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象</p>\n<p>什么时候使用这个东西？当<strong>你想在</strong>一个你认为是派生类对象的<strong>对象上执行</strong>派生类的操作<strong>函数</strong>，但你手里却只有一个指向基类的引用/指针时</p>\n<p>解决方法：</p>\n<ul>\n<li>使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器</li>\n<li>在基类中提供virtual函数</li>\n</ul>\n<h3 id=\"避免返回指向对象内部成分的handles\">避免返回指向对象内部成分的handles</h3>\n<p>前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便</p>\n<p>但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的</p>\n<pre><code class=\"language-c++\">class Point&#123;\npublic:\n  ...\n  void setX(int val);\n  ...\n&#125;;\nstruct RectData&#123;\n  Point ulhc;\t\t//upper left hand corner\n  Point lrhc;\t\t//lower right hand corner\n&#125;;\nclass Rectangle&#123;\npublic:\n  ...\n  Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;\t//这样返回了引用，非常不好\n  ...\nprivate:\n  std::tr1::shared_ptr&lt;RectData&gt; pData;\n&#125;;\n...\nrec.upperLeft().setX(50);\t\t//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改\n</code></pre>\n<p><code>upperLeft</code>函数本来只是为了提供给客户获得（get）<code>Rectangle</code>的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了<code>Rectangle</code>本身，而且还是一个内部数据<code>RectData</code></p>\n<p>为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）</p>\n<p>解决方法很简单，只要让handles不可以被修改，就可以了</p>\n<pre><code class=\"language-c++\">class Rectangle&#123;\npublic:\n  ...\n  const Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;\t\n  ...\n&#125;;\n</code></pre>\n<p>但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致<strong>dangling handles（空悬的号码牌）</strong>，比如返回了一个对local变量的引用，依然特别危险</p>\n<p>当然，有的时候不得不返回handles，比如<code>operator[]</code></p>\n<h3 id=\"异常安全性很重要\">异常安全性很重要</h3>\n<p>**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：</p>\n<ul>\n<li>不泄漏任何资源</li>\n<li>不允许数据败坏</li>\n</ul>\n<p>不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂</p>\n<p>三个保证：</p>\n<ul>\n<li>基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏</li>\n<li>强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过<code>copy-and-swap</code>实现）</li>\n<li>不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）</li>\n</ul>\n<p><strong>异常安全码</strong>必须提供上述三种保障之一，如果不能保障，则不具备异常安全性</p>\n<h3 id=\"了解inline函数\">了解inline函数</h3>\n<p>内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化</p>\n<p>缺点也很明显，会让包体变大，会导致<strong>换页行为（paging）</strong>，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数</p>\n<p>内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联</p>\n<h3 id=\"降低文件间的编译依存\">降低文件间的编译依存</h3>\n<p>如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译</p>\n<p>为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用）</p>\n<p>这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类</p>\n<p><em>话说应该不会有人不知道implementation是实现的意思吧</em></p>\n<pre><code class=\"language-c++\">class PersonImpl;\t//pimpl写法，这是Person类的前置声明\nclass Data;\t\t\t\t//Data的前置声明\nclass Address;\t\t//Address的前置声明\n\nclass Persion&#123;\t//像这样使用pimpl的类，往往被称为Handle classes\npublic:\n  ...\n  std::string name() const;\n  ...\nprivate:\n  std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;\n&#125;;\n</code></pre>\n<p>在这种设计下，<code>Person</code>就与<code>Data</code>、<code>Address</code>以及<code>Persons</code>的实现分离了，改动这些类也不会导致使用<code>Person</code>的客户重新编译，客户无法看到<code>Person</code>的实现细节，真正实现<strong>接口与实现分离</strong></p>\n<p>这个操作的本质是用<strong>声明的依赖性</strong>替换<strong>定义的依赖性</strong></p>\n<p>此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明</p>\n<p>此外还有另一种制作<code>Handle class</code>的方法，就是令<code>Person</code>成为一个特殊的抽象基类，称为<code>Interface class</code>，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）</p>\n<pre><code class=\"language-c++\">class Person&#123;\t\t//Interface class\npublic:\n  virtual ~Person();\n  virtual std::string name() const = 0;\n  ...\n&#125;;\nclass Person&#123;\t\t//具现化\npublic:\n  static std::tr1::shared_ptr&lt;Person&gt; create(const std::string&amp; name...);\n  ...\n&#125;;\n...\n//使用\nstd::tr1::shared_ptr&lt;Person&gt; pp(Person::create(name...));\nstd::cout &lt;&lt; pp-&gt;name();\n</code></pre>\n<pre><code class=\"language-c++\">class RealPerson: public Person&#123;\t\npublic:\n  RealPerson(const std::string&amp; name, ...): theName(name), ...&#123;&#125;\n  virtual ~RealPerson() &#123;&#125;\n  std::string name() const;\t\t\n  ...\nprivate:\n\tstd::string theName;\n&#125;;\nstd::string ReakPerson::name()&#123;...&#125;\nstd::tr1::shared_ptr&lt;Person&gt; Person::create(const std::string&amp; name, ...)&#123;\n  retrun std::tr1::shared_ptr&lt;Person&gt;(new RealPerson(name, ...));\n&#125;\n</code></pre>\n<h2 id=\"六：继承与面向对象\">六：继承与面向对象</h2>\n<ul>\n<li><code>is-a</code>：是一个</li>\n<li><code>has-a</code>：有一个</li>\n<li><code>is-implemented-in-terms-of</code>：根据xx实现出</li>\n</ul>\n<h3 id=\"public继承是is-a关系\">public继承是is-a关系</h3>\n<pre><code class=\"language-c++\">class Student: public Person&#123;...&#125;;\t//Student is a Person\n</code></pre>\n<p>每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化</p>\n<p><strong>public继承下，可以把子类当父类用</strong>，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用</p>\n<p>这就出现了一个问题，子类一定要<code>is a</code>父类，不然会出现问题</p>\n<p>错误的继承：</p>\n<ul>\n<li>企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？</li>\n<li>正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？</li>\n</ul>\n<h3 id=\"避免遮掩父类成员\">避免遮掩父类成员</h3>\n<pre><code class=\"language-c++\">int x;\nvoid Fun()&#123;\n    double x;\n    ...\n&#125;\n</code></pre>\n<p>由于<strong>作用域</strong>的<strong>名称遮掩规则</strong>，函数内部的local变量x覆盖了全局变量x</p>\n<h4 id=\"子类名称会遮掩父类名称，在public继承下是错误的\">子类名称会遮掩父类名称，在public继承下是错误的</h4>\n<p>在OOP中，如果子类重载了父类的<code>non-virtual</code>函数，就意味着子类使用同名函数遮掩了父类函数，就意味着<strong>这个父类函数没有被子类继承！</strong>，那么在这种情况下，继承就不是<code>is-a</code>关系了</p>\n<p><strong>在public继承下，子类继承了父类的一切</strong></p>\n<pre><code class=\"language-c++\">class Base&#123;\npublic:\n    virtual void f1() = 0;\n    virtual void f1(int);\n    void f2();\n    void f2(double);\n    ...\nprivate:\n    int x;\n&#125;;\nclass Derived: public Base&#123;\npublic:\n    virtual void f1();\n    void f2();\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)\n</code></pre>\n<h4 id=\"将被遮掩的名称重见天日\">将被遮掩的名称重见天日</h4>\n<p>解决起来很简单，只需要让父类的函数在子类作用域内可见，可以<strong>使用using关键字</strong></p>\n<pre><code class=\"language-c++\">class Derived: public Base&#123;\npublic:\n    using Base::f1;\n    using Base::f2;\n    virtual void f1();\n    void f2();\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//正确，调用Base::f1\nd.f2();\t\t//正确，调用Derived::f2\nd.f2(x);\t//正确，调用Base::f2\n</code></pre>\n<p>如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以<strong>使用转交函数</strong>，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中</p>\n<pre><code class=\"language-c++\">class Derived: private Base&#123;\npublic:\n    virtual void f1()&#123;\n        Base::f1();\t\t//inline转交函数\n    &#125;\n    ...\n&#125;;\n...\nDerived d;\nint x;\nd.f1();\t\t//正确，调用Derived::f1\nd.f1(x);\t//错误，因为Derived::f1遮掩了Base::f1\n</code></pre>\n<h3 id=\"区分接口继承和实现继承\">区分接口继承和实现继承</h3>\n<p>public继承分为两个部分</p>\n<ul>\n<li>函数接口继承</li>\n<li>函数实现继承</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>接口继承</th>\n<th>实现继承</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>纯虚函数</td>\n<td>具体指定</td>\n<td>不继承</td>\n</tr>\n<tr>\n<td>非纯虚函数</td>\n<td>具体指定</td>\n<td>继承一份缺省实现</td>\n</tr>\n<tr>\n<td>non-virtual函数</td>\n<td>具体指定</td>\n<td>继承一份强制实现</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"考虑使用virtual以外的选择\">考虑使用virtual以外的选择</h3>\n<h4 id=\"基于NVI的Template-Method模式\">基于NVI的Template Method模式</h4>\n<p>Non-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数</p>\n<pre><code class=\"language-c++\">class GameCharacter&#123;\npublic：\n    int healthValue() const\n\t&#123;\n    \t...\n    \tint retVal = doHealthValue();\n    \t...\n    \treturn retVal;\n\t&#125;\nprivate：\n    virtual int doHealthValue() const\n    &#123;\n\t\t...\n    &#125;\n&#125;;\n</code></pre>\n<p>其中<code>healthValue()</code>被称为virtual函数的<strong>外覆器（wrapper）</strong></p>\n<h4 id=\"基于函数指针的Strategy模式\">基于函数指针的Strategy模式</h4>\n<pre><code class=\"language-c++\">class GameCharacter;\nint defaultHealthCalc(const GameCharacter&amp; gc);\nclass GameCharacter&#123;\npublic:\n    typedef int (*HealthCalcFunc)(const GameCharacter&amp;);\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125;\n    int healthValue() const &#123; return healthFunc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n&#125;;\n</code></pre>\n<p>在这种模式下，<code>defaultHealthCalc</code>函数不再是<code>GameCharacter</code>体系内的成员函数，通过修改函数指针，就可以让<code>GameCharacter</code>使用不同种类的计算函数，弹性更强，而且可以在运行时变更</p>\n<p>此外<code>defaultHealthCalc</code>函数不需要/不能访问<code>GameCharacter</code>内的<code>non-public</code>部分，</p>\n<h4 id=\"基于tr1-function的Strategy模式\">基于tr1::function的Strategy模式</h4>\n<p>上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如<code>tr1::function</code>对象</p>\n<pre><code class=\"language-c++\">class GameCharacter;\nint defaultHealthCalc(const GameCharacter&amp; gc);\nclass GameCharacter&#123;\npublic:\n    typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;\n    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125;\n    int healthValue() const &#123; return healthFunc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n&#125;;\n</code></pre>\n<h4 id=\"古典的Strategy模式\">古典的Strategy模式</h4>\n<pre><code class=\"language-c++\">class GameCharacter;\nclass HealthCalcFunc&#123;\npublic:\n    ...\n    virtual int calc(const GameCharacter&amp; gc) const&#123;...&#125;\n    ...\n&#125;;\nHealthCalcFunc defaultHealthCalc;\nclass GameCharacter&#123;\npublic:\n    explicit GameCharacter(HealthCalcFunc* phcf = &amp;defaultHealthCalc): pHealthFunc(phcf)&#123;&#125;\n    int healthValue() const &#123; return phealthFunc-&gt;calc(*this); &#125;\n    ...\nprivate:\n    HealthCalcFunc* pHealthFunc;\n&#125;;\n</code></pre>\n<h3 id=\"绝不重新定义继承而来的non-virtual函数\">绝不重新定义继承而来的non-virtual函数</h3>\n<ul>\n<li>静态绑定（staticcally bound）：non-virtual就是这种</li>\n<li>动态绑定（dynamically bound）：virtual就是这种</li>\n</ul>\n<pre><code class=\"language-c++\">class B&#123;\npublic:\n\tvoid f();\n\t...\n&#125;;\nclass D: public B&#123;\npublic:\n  void f();\n  ...\n&#125;;\n...\nD x;\nB* pB = &amp;x;\nD* pD = &amp;x;\npB-&gt;f();\t//调用B::f\npD-&gt;f();\t//调用D::f\n</code></pre>\n<h3 id=\"绝对不重新定义继承而来的缺省参数值\">绝对不重新定义继承而来的缺省参数值</h3>\n<p><strong>virtual函数是动态绑定的，缺省参数值是静态绑定的</strong></p>\n<pre><code class=\"language-c++\">class Cricle: public Shape&#123;...&#125;;\n...\nShape* p1;\t//p1的静态类型是Shape*，没有动态类型\nShape* p2 = new Circle;\t//p2的静态类型是Shape*，动态类型是Circle*\n</code></pre>\n<ul>\n<li>静态类型\n<ul>\n<li>指针的类型就是<strong>静态类型</strong></li>\n</ul>\n</li>\n<li>动态类型\n<ul>\n<li>所指向的对象的类型是<strong>动态类型</strong></li>\n<li>动态类型可以通过赋值等操作改变</li>\n</ul>\n</li>\n</ul>\n<p>virtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载</p>\n<p>但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数</p>\n<h3 id=\"has-a和根据xx实现出\">has-a和根据xx实现出</h3>\n<p>一个类中有多个小类，这种关系被称为<strong>复合（composition）</strong>，其中这些小类被称为<strong>合成成分物（composed object）</strong></p>\n<ul>\n<li>在应用域，复合意味着<code>has-a</code>\n<ul>\n<li>人有名字（也不尽然）</li>\n</ul>\n</li>\n<li>在实现域，复合意味着<code>is-implemented-in-terms-of</code>\n<ul>\n<li>队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"少用private继承\">少用private继承</h3>\n<p><em>经典 C++糟粕，请问 C#有这个吗？</em></p>\n<p>本质上是一种<code>is-implemented-in-terms-of</code>关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术</p>\n<ul>\n<li>private继承，编译器无法自动将子类对象转化为父类对象</li>\n<li>private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）</li>\n</ul>\n<p><strong>尽量使用复合来替代pirvate继承</strong>，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数</p>\n<p>此外private继承的对象有可能比复合的对象要小</p>\n<h3 id=\"少用多重继承\">少用多重继承</h3>\n<p><em>经典 C++糟粕，请问 C#有这个吗？</em></p>\n<ul>\n<li>可能会导致歧义\n<ul>\n<li>当然你可以在调用函数的时候指出是来自哪一个基类</li>\n</ul>\n</li>\n<li>可能会导致菱形继承\n<ul>\n<li>菱形继承可能会导致变量重复</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"七：模版与泛型\">七：模版与泛型</h2>\n<p>模板（templates）是泛型编程（generic programming）的基础</p>\n<p>模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译</p>\n<h3 id=\"评价\">评价</h3>\n<p>优点：</p>\n<ol>\n<li>模板编程能够实现非常灵活且类型安全的接口</li>\n<li>极好的性能（更小的文件、更短的运行期，更少的内存需求）</li>\n<li>可以将一些运行时才能侦测到的错误，在编译期找出来</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>难以编程和维护</li>\n<li>编译报错信息难以理解</li>\n<li>难以重构</li>\n<li>编译时间大幅变长</li>\n</ol>\n<p>因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释</p>\n<h3 id=\"隐式接口和编译期多态\">隐式接口和编译期多态</h3>\n<ul>\n<li>OOP中经常使用显式接口和运行时多态</li>\n<li>泛型编程更多使用隐式接口和编译期多态</li>\n</ul>\n<pre><code class=\"language-C++\">template&lt;typename T&gt;\nvoid doProcessing(T&amp; w)\n&#123;\n    if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget)&#123;\n        T temp(w)\n        temp.normalize();\n        temp.swap(w);\n    &#125;\n&#125;\n</code></pre>\n<p>从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组<strong>隐式接口</strong></p>\n<p>所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功</p>\n<p>这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是<strong>编译期多态</strong></p>\n<h3 id=\"Traits\">Traits</h3>\n<p>一种约定俗成的技术方案，为同一类数据提供统一的操作函数</p>\n<p>比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。</p>\n<pre><code class=\"language-C++\">enum Type&#123;\n    TYPE_1;\n    TYPE_2;\n&#125;;\nclass FOO&#123;\n    Type type = Type::TYPE_1;\n&#125;;\nclass Bar&#123;\n    Type type = Type::TYPE_2;\n&#125;;\n//统一的模板函数\ntemplate&lt;typename T&gt;\nvoid decode(const T&amp; data, char* buf)&#123;\n    if(T::type == Type::TYPE_1)&#123;\n        ...\n    &#125;\n    else if(T::type == Type::TYPE_2)&#123;\n        ...\n    &#125;\n&#125;\n</code></pre>\n<p>但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术</p>\n<pre><code class=\"language-C++\">enum Type&#123;\n    TYPE_1;\n    TYPE_2;\n&#125;;\nclass FOO&#123;\n    Type type = Type::TYPE_1;\n&#125;;\nclass Bar&#123;\n    Type type = Type::TYPE_2;\n&#125;;\n\ntemplate&lt;typename T&gt;\nstruct type_traits&#123;\n    Type type = T::type;\n&#125;\n//为内置数据类型特化为独有的 type_traits\ntemplate&lt;typename int&gt;\nstruct type_traits&#123;\n    Type type = Type::TYPE_1;\n&#125;\n//统一的模板函数\ntemplate&lt;typename T&gt;\nvoid decode(const T&amp; data, char* buf)&#123;\n    if(type_traits&lt;T&gt;::type == Type::TYPE_1)&#123;\n        ...\n    &#125;\n    else if(type_traits&lt;T&gt;::type == Type::TYPE_2)&#123;\n        ...\n    &#125;\n&#125;\n</code></pre>\n<p>该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因</p>\n<h3 id=\"模板元编程\">模板元编程</h3>\n<p>TMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化</p>\n<p>如果一门语言具备以下功能，则称为图灵完全</p>\n<ol>\n<li>数值运算和符号运算</li>\n<li>判断</li>\n<li>递归</li>\n</ol>\n<h4 id=\"数值运算-递归\">数值运算+递归</h4>\n<pre><code class=\"language-C++\">//一个TMP计算阶乘，而且阶乘的技术发生在编译期\ntemplate&lt;unsigned n&gt;\nstruct Factorial\n&#123;\n    enum &#123; value = n * Factorial&lt;n-1&gt;::value &#125;;\n&#125;;\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt;\n&#123;\n    enum &#123; value = 1 &#125;;\n&#125;;\n\nint main()\n&#123;\n    std::cout &lt;&lt; Factorial&lt;5&gt;::value;\n&#125;\n</code></pre>\n<p>C++11TMP这种函数式编程得到了加强，上文也可以这样写</p>\n<pre><code class=\"language-C++\">template&lt;unsigned n&gt;\nstruct Factorial\n&#123;\n    constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;;\n&#125;;\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt;\n&#123;\n    constexpr static auto value = 1;\n&#125;;\n</code></pre>\n<h4 id=\"判断\">判断</h4>\n<pre><code class=\"language-C++\">template&lt;bool Value&gt;\nstruct if_constexpr\n&#123;\n    constexpr static auto value = 1;\n&#125;;\n\ntemplate&lt;&gt;\nstruct if_constexpr&lt;false&gt; &#123;\n    constexpr static auto value = 2;\n&#125;;\n\nint main()\n&#123;\n    std::cout &lt;&lt; if_constexpr&lt;true&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; if_constexpr&lt;false&gt;::value &lt;&lt; std::endl;\n&#125;\n</code></pre>\n<h3 id=\"typedef\">typedef</h3>\n<p>在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名</p>\n<p>下面是一个函数指针的示例</p>\n<pre><code class=\"language-C++\">void add(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; x + y &lt;&lt; std::endl;\n&#125;\nvoid dec(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x-y=&quot; &lt;&lt; x - y &lt;&lt; std::endl;\n&#125;\nvoid mul(int x, int y) &#123;\n    std::cout &lt;&lt; &quot;x*y=&quot; &lt;&lt; x*y &lt;&lt; std::endl;\n&#125;\n\nvoid (*op[3])(int, int) = &#123; add, dec, mul &#125;;\n\nint main()\n&#123;\n    for (int i = 0; i &lt; 3; ++i) &#123;\n        （*op[i])(4, 3);\n    &#125;\n&#125;\n</code></pre>\n<p>如果使用typedef</p>\n<pre><code class=\"language-C++\">typedef void (*Func[3])(int, int);\nFunc f = &#123; add, dec, mul &#125;;\n\nint main()\n&#123;\n    for (int i = 0; i &lt; 3; ++i) &#123;\n        f[i](4, 3);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"八：定制new和delete\">八：定制new和delete</h2>\n<p>Java和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目</p>\n<h3 id=\"new-handler\">new-handler</h3>\n<p>当<code>operator new</code>无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即<code>new-handler</code></p>\n<p>使用<code>set_new_handler</code>来指定<code>new-handler</code></p>\n<pre><code class=\"language-c++\">void outOfMem()&#123;\n  std::cerr &lt;&lt; &quot;内存不足\\n&quot;;\n  std::abort();\n&#125;\nint main()&#123;\n  std::set_new_handler(outOfMem);\t\t//该函数的参数是一个函数指针\n  int* array = new int[10000000L];\n  ...\n&#125;\n</code></pre>\n<p>当<code>operator new</code>无法满足内存申请时，会不断调用<code>new-handler</code>函数，直到找到足够的内存，所以<code>new-handler</code>函数应该满足</p>\n<ul>\n<li>让更多的内存可被使用\n<ul>\n<li>实现方法是程序开始时就分配一大块内存，每次调用<code>new-handler</code>时就释放一点点</li>\n</ul>\n</li>\n<li>安装另一个<code>new-handler</code>\n<ul>\n<li>如果现在这个<code>new-handler</code>无法获取更多内存，需要知道哪一个<code>new-handler</code>具备增大内存的实力，然后使用<code>set_new_handler</code>来替换自己</li>\n</ul>\n</li>\n<li>卸除<code>new-handler</code>\n<ul>\n<li>通过<code>set_new_handler</code>赋值<code>null</code>，将<code>new-handler</code>卸载，使得在内存分配不足时，会抛异常</li>\n</ul>\n</li>\n<li>抛出<code>bad_alloc</code>异常\n<ul>\n<li>这种异常不会被<code>operator new</code>捕获，会被传播至内存索求处</li>\n</ul>\n</li>\n<li>不反回\n<ul>\n<li>调用<code>abort</code>或者<code>exit</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-c++\">class NewHandlerHolder&#123;\npublic:\n  explicit NewHandlerHolder(std::new_handler nh): handler(nh) &#123;&#125;\t//获取当前的new_handler\n  ~NewHandlerHolder() &#123; std::set_new_handler(handler); &#125;\t\nprivate:\n  std::new_handler handler;\t\t//用于记录当前的new_handler\n&#125;;\nvoid* Widget::operator new(std::size_t size) throw(std::bad_alloc)&#123;\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\t//安装Widget的new-handler\n  return ::operator new(size);\t//分配对象或者抛异常\n&#125;\n//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值\n</code></pre>\n<pre><code class=\"language-c++\">void outOfMem();\nWidget::set_new_handler(outOfMem);\nWidget* pwl = new Widget;\t//内存不足时会调用outOfMem\n</code></pre>\n<p>mixin风格的写法</p>\n<pre><code class=\"language-c++\">template&lt;typename T&gt;\nclass NewHandlerSupport&#123;\npublic:\n  static std::new_handler_set set_new_handler(std::new_handler p) throw();\n  static void* operator new(std::size_t size) throw(std::bad_alloc);\n  ...\nprivate:\n  static std::new_handler currentHandler;\n&#125;;\n\ntemplate&lt;typename T&gt;\nstd::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()&#123;\n  std::new_handler oldHandler = currentHandler;\n  currentHandler = p;\n  return oldHandler;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) throw(std::bad_alloc)&#123;\n  NewHandlerHolder h(std::set_new_handler(currentHandler));\n  return ::operator new(size);\n&#125;\n</code></pre>\n<pre><code class=\"language-c++\">class Widget: public NewHandlerSupport&lt;Widget&gt;&#123;\n\t...\n&#125;;\n</code></pre>\n<p>像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为<strong>怪异的循环模版模式（curiously recurring template pattern，CRTP）</strong></p>\n<h3 id=\"替换new和delete的时机\">替换new和delete的时机</h3>\n<p>C++中所有的news返回的指针都必须要<strong>地址对齐</strong>，int要4对齐，double要8对齐</p>\n<p>写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换</p>\n<h3 id=\"编写new和delete的规则\">编写new和delete的规则</h3>\n<p>如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则</p>\n<ul>\n<li>\n<p>new</p>\n<ul>\n<li>应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用<code>new-handler</code></li>\n<li>有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）</li>\n<li>new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理<strong>比正确大小更大的（错误）申请</strong></li>\n</ul>\n</li>\n<li>\n<p>delete</p>\n<ul>\n<li>收到null指针时不做任何事</li>\n<li>处理<strong>比正确大小更大的（错误）申请</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"编写new时也要写对应的delete\">编写new时也要写对应的delete</h3>\n<pre><code class=\"language-c++\">Widget* pw = new Widget;\n</code></pre>\n<p>在这里调用了两个函数，一个时用以分配内存的<code>operator new</code>，一个是<code>Widget</code>的构造函数</p>\n<p>如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的</p>\n<p>运行时系统会调用<code>operator new</code>所对应的<code>operator delete</code>来释放地址，对于拥有正常签名式的new和delete来说不成问题</p>\n<pre><code class=\"language-c++\">void* operator new(std::size_t) throw(std::bad_alloc);\t//普通的new\nvoid operator delete(void* rawMemory) throw();\t//global中的普通的new\nvoid operator delete(void* rawMemory, std::size_t size) throw();\t//class中的new\n</code></pre>\n<p>但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题</p>\n<pre><code class=\"language-c++\">void* operator new(std::size_t, void* pMemory) throw();\t//placement new，比普通new多带一个参数\n\nWidget* pw = new (std::cerr) Widget;\t//调用operator new，并以cerr作为其实参\n</code></pre>\n<p>当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的<code>operator new</code>时如何运作的，所以运行时系统会去寻找<strong>参数个数与类型</strong>都与<code>operator new</code>相同的某个<code>operator delete</code></p>\n<pre><code class=\"language-c++\">void operator delete(void*, std::ostream&amp;) throw();\t//palcement delete\n</code></pre>\n<pre><code class=\"language-c++\">class Widget&#123;\npublic:\n  static void* operator new(std::size_t size, std::ostream&amp; logStream) throw(std::bad_alloc);\n  static void operator delete(void* pMemory) throw();\n  static void operator delete(void* pMemoty, std::ostream&amp; logStream) throw();\n  ...\n&#125;;\n</code></pre>\n<p>如果此时调用<code>delete pw</code>，只会调用普通的<code>delete</code>，因为只有在构造时发生异常时，运行时系统才会调用placement delete</p>\n<p>最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete</p>\n<h2 id=\"九：杂项\">九：杂项</h2>\n<h3 id=\"不要忽视编译器警告\">不要忽视编译器警告</h3>\n<p>很多人忽视警告，毕竟一个问题如果真的很严重，应该报错</p>\n<p>比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为</p>\n<pre><code class=\"language-c++\">class B&#123;\npublic:\n  virtual void f() const;\n&#125;;\nclass D: public B&#123;\n  virtual void f();\n&#125;;\n</code></pre>\n<p>报警告</p>\n<pre><code class=\"language-c++\">warning: D::f() hides virtual B::f()\n</code></pre>\n<p>原本的目的是为了在D中重新定义virtual函数<code>f()</code>，但由于B中<code>f()</code>是const，在D中不是，此时B中的<code>f()</code>并没有在D中重新被声明，而是被整个遮掩了</p>\n<h3 id=\"去熟悉标准程序库\">去熟悉标准程序库</h3>\n<p>尤其是TR1</p>\n<h4 id=\"C-98有什么\">C++98有什么</h4>\n<ul>\n<li>STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器</li>\n<li>Iostream</li>\n<li>国际化支持</li>\n<li>数值处理，包括复数（complex）和纯数值数组（valarray）</li>\n<li>异常阶层体系</li>\n<li>C89标准程序库</li>\n</ul>\n<h4 id=\"TR1有什么（全在std-tr1中）\">TR1有什么（全在<code>std::tr1</code>中）</h4>\n<ul>\n<li>智能指针<code>tr1::shared_ptr</code>和<code>tr1::weak_ptr</code></li>\n<li><code>tr1::function</code></li>\n<li><code>tr1::bind</code></li>\n</ul>\n<p>和（彼此无关的独立组件）</p>\n<ul>\n<li>哈希表</li>\n<li>正则表达式</li>\n<li>Tuple变量组</li>\n<li><code>tr1::array</code></li>\n<li><code>tr1::mem_fn</code></li>\n<li><code>tr1::reference_wrapper</code></li>\n<li>随机数生成工具</li>\n<li>数学特殊函数</li>\n<li>C99兼容</li>\n</ul>\n<p>和（基于template）</p>\n<ul>\n<li>Type traits</li>\n<li><code>tr1::result_of</code></li>\n</ul>\n<h3 id=\"熟悉Boost\">熟悉Boost</h3>\n"},{"layout":"post","title":"test","date":"2023-01-31T02:01:25.000Z","thumbnail":"/images/effectivecxx.png","cover":true,"toc":true,"plugins":["mathjax"],"_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n$\\Delta x$\n$$\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s\n$$\n","source":"_posts/hello-world2.md","raw":"---\nlayout: post\n# 标题\ntitle: test  \n# 发布时间\ndate: 2023/1/31 10:01:25  \n# 分类\ncategories: [engine] \n# 标签\ntags:\n  - C++\n# 作者\n#author: Reuben\n# 缩略图\nthumbnail: /images/effectivecxx.png \n# 显示封面\ncover: true\n# 显示目录\ntoc: true\n# 启用插件\nplugins:\n  - mathjax\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n$\\Delta x$\n$$\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s\n$$\n","slug":"hello-world2","published":1,"updated":"2023-01-31T13:48:59.726Z","_id":"cldkap8hs000dxz3c15ph91xi","comments":1,"photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<p>$\\Delta x$<br>\n$$<br>\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s<br>\n$$</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<p>$\\Delta x$<br>\n$$<br>\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s<br>\n$$</p>\n"},{"layout":"post","title":"test","date":"2023-01-31T02:01:25.000Z","thumbnail":"/images/effectivecxx.png","cover":true,"toc":true,"plugins":["mathjax"],"_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n$\\Delta x$\n$$\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s\n$$\n","source":"_posts/hello-world3.md","raw":"---\nlayout: post\n# 标题\ntitle: test  \n# 发布时间\ndate: 2023/1/31 10:01:25  \n# 分类\ncategories: [math] \n# 标签\ntags:\n  - C++\n# 作者\n#author: Reuben\n# 缩略图\nthumbnail: /images/effectivecxx.png \n# 显示封面\ncover: true\n# 显示目录\ntoc: true\n# 启用插件\nplugins:\n  - mathjax\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n$\\Delta x$\n$$\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s\n$$\n","slug":"hello-world3","published":1,"updated":"2023-01-31T13:49:03.105Z","_id":"cldkapc9p000gxz3c2f6l2kuf","comments":1,"photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<p>$\\Delta x$<br>\n$$<br>\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s<br>\n$$</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<p>$\\Delta x$<br>\n$$<br>\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s<br>\n$$</p>\n"},{"layout":"post","title":"test","date":"2023-01-31T02:01:25.000Z","thumbnail":"/images/effectivecxx.png","cover":true,"toc":true,"plugins":["mathjax"],"_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n$\\Delta x$\n$$\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s\n$$\n","source":"_posts/hello-world4.md","raw":"---\nlayout: post\n# 标题\ntitle: test  \n# 发布时间\ndate: 2023/1/31 10:01:25  \n# 分类\ncategories: [optics] \n# 标签\ntags:\n  - C++\n# 作者\n#author: Reuben\n# 缩略图\nthumbnail: /images/effectivecxx.png \n# 显示封面\ncover: true\n# 显示目录\ntoc: true\n# 启用插件\nplugins:\n  - mathjax\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n$\\Delta x$\n$$\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s\n$$\n","slug":"hello-world4","published":1,"updated":"2023-01-31T13:49:10.562Z","_id":"cldkapf6e000jxz3cbxikb2sf","comments":1,"photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<p>$\\Delta x$<br>\n$$<br>\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s<br>\n$$</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<p>$\\Delta x$<br>\n$$<br>\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s<br>\n$$</p>\n"},{"layout":"post","title":"test","date":"2023-01-31T02:01:25.000Z","thumbnail":"/images/effectivecxx.png","cover":true,"toc":true,"plugins":["mathjax"],"_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n$\\Delta x$\n$$\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s\n$$\n","source":"_posts/hello-world5.md","raw":"---\nlayout: post\n# 标题\ntitle: test  \n# 发布时间\ndate: 2023/1/31 10:01:25  \n# 分类\ncategories: [dcc] \n# 标签\ntags:\n  - C++\n# 作者\n#author: Reuben\n# 缩略图\nthumbnail: /images/effectivecxx.png \n# 显示封面\ncover: true\n# 显示目录\ntoc: true\n# 启用插件\nplugins:\n  - mathjax\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n$\\Delta x$\n$$\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s\n$$\n","slug":"hello-world5","published":1,"updated":"2023-01-31T13:49:31.823Z","_id":"cldkaq8it000vxz3cfzv3g7yg","comments":1,"photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<p>$\\Delta x$<br>\n$$<br>\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s<br>\n$$</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<p>$\\Delta x$<br>\n$$<br>\n\\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s<br>\n$$</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cldk9wg6s0001wu3c3d9h8cl7","category_id":"cldk9wg6t0002wu3c7yur81bd","_id":"cldk9wg6u0005wu3c3xkuhlq9"},{"post_id":"cldk9wg6p0000wu3c38sb29ey","category_id":"cldkaoyms0002xz3c1akbhzo7","_id":"cldkaoymu0003xz3c7zn76kbs"},{"post_id":"cldkap8hs000dxz3c15ph91xi","category_id":"cldkappdc000mxz3cgmys5kpn","_id":"cldkappdd000nxz3chnif4oxm"},{"post_id":"cldkapc9p000gxz3c2f6l2kuf","category_id":"cldkapvlp000oxz3cgmti4p97","_id":"cldkapvlq000pxz3c57k55sl7"},{"post_id":"cldkapf6e000jxz3cbxikb2sf","category_id":"cldkaq1aq000qxz3cb3xicuix","_id":"cldkaq1ar000rxz3cgx1m5r3z"},{"post_id":"cldkaq8it000vxz3cfzv3g7yg","category_id":"cldkaqhrh000yxz3cep6t35wm","_id":"cldkaqhri000zxz3c6sh987v4"}],"PostTag":[{"post_id":"cldk9wg6s0001wu3c3d9h8cl7","tag_id":"cldk9wg6u0003wu3ccpsq7ktp","_id":"cldk9wg6u0004wu3cba0e4spn"},{"post_id":"cldk9wg6p0000wu3c38sb29ey","tag_id":"cldk9wg6u0003wu3ccpsq7ktp","_id":"cldkao78g0000xz3cevfpa2pk"},{"post_id":"cldkap8hs000dxz3c15ph91xi","tag_id":"cldk9wg6u0003wu3ccpsq7ktp","_id":"cldkap8ht000exz3ca65fgn41"},{"post_id":"cldkapc9p000gxz3c2f6l2kuf","tag_id":"cldk9wg6u0003wu3ccpsq7ktp","_id":"cldkapc9q000hxz3cg3bwdbl2"},{"post_id":"cldkapf6e000jxz3cbxikb2sf","tag_id":"cldk9wg6u0003wu3ccpsq7ktp","_id":"cldkapf6f000kxz3c65h3495j"},{"post_id":"cldkaq8it000vxz3cfzv3g7yg","tag_id":"cldk9wg6u0003wu3ccpsq7ktp","_id":"cldkaq8iu000wxz3c35mp18cl"}],"Tag":[{"name":"C++","_id":"cldk9wg6u0003wu3ccpsq7ktp"}]}}