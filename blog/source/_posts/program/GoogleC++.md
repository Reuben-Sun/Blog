---
layout: post
# 标题
title: Google C++代码规范
# 发布时间
date: 2023/2/9 19:01:25  
# 分类
categories: [program] 
# 标签
tags:
  - C++
# 作者
#author: Reuben
# 缩略图
thumbnail: 
# 显示封面
cover: true
# 显示目录
toc: true
# 启用插件
plugins:
  - mathjax
---

# Google C++ 代码规范

[Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)

Google提出的一套代码规范，能提高代码的可读性，减少出错。建议配合[Effective C++](/2023/01/31/program/Effective%20C++/)阅读

## 头文件

### 所有头文件都应该自给自足（self-contained）

> self-contained : compile on their own

确保你的header files包含了你需要的所有东西，而不是假设你#include进来的某个（些）headers帮你包含了你需要的东西。

A.h包含了B.h和C.h，而B.h也包含了C.h，那么在A.h中使用C.h时，会难以判断到底该用哪一个

### \#define 保护

每个头文件都要使用`#pragma once`保护

### 前置声明

我个人理解的前置声明，是指在一个`.h`文件中开头声明另一个`.h`文件中的类，以此来实现类似`#include`某个文件的某一部分

与之对应的是直接使用`#include`引入文件，但这样实际会增加编译工作量，降低编译速度，于是我们非必要不`#include`

> Google建议要避免使用前置声明，因为使用前置声明会影响类的修改，也容易产生错误
>
> 但使用前置声明可以提高编译速度，因此需要按情况选择

优点

- 节省编译时间，避免很多不必要的（因为头文件改动而导致的）重新编译

缺点

- 隐藏了依赖关系
- 头文件改动时会破坏后续，影响开发者改动API（比如当你要添加一个形参时）
  - 但这个是不是可以通过宏的方法避免？`#define Func Func`

#### 两个类互相引用

前置声明（Forward Declarations）基本仅用于两个类互相引用

```cpp
// A.h
#include "B.h"
class A
{
    B b;	//A中使用了B，因此
    ...
}
```

```cpp
// B.h
class A;
class B
{
	A* a;
    ...
}
```

#### 失去依赖关系

前置声明最大的问题是失去依赖关系

```cpp
// B.h
struct B {};
struct D : B {};	//这里的D继承自B
```

```cpp
#include "b.h"
//如果使用前置声明替换掉#include，就会出现错误
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // Calls f(B*)
```

### 内联函数

除非是极其高频调用，确定是性能瓶颈的地方，不然不用内联函数

不要内敛超过十行的函数

析构函数远比表面要长，因为他隐式调用着成员和基类的析构函数

### \#include路径

按照源码目录树结构排列，避免使用UNIX的快捷目录，比如`.`（当前目录）和`..`（上级目录）

### \#include顺序

1. C头文件
2. C++头文件
3. 第三方库头文件
4. 本项目头文件

## 作用域

命名空间将全局作用域细分为独立具体的作用域，可以有效防止全局命名冲突

```C++
#include "a.h"

namespace MyNamespace
{
    class MyClass
    {
        ...
    };
}    //namespace MyNamespace
```

### 请在命名空间最后注释出命名空间的名字

### 不要污染命名空间

- 不要在std命名空间中声明任何东西
- 不要使用`using namespace xxx`
- 不要在头文件中使用命名空间别名，如`namespace bbb = ::Foo::Bar::Baz`

### 静态变量

不要在.h文件中声明静态变量，至少不能用全裸的静态变量

不要定义静态存储周期**非**POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中静态变量的构造和析构顺序不确定，会导致bug（除非你使用constexpr）

原生数据类型（POD，Olain Old Data），如int、char、float，int*、int[]、结构体

在同一编译单元，静态初始化会优先于动态初始化，并按照声明顺序初始化，以逆序销毁

但是不同编译单元，初始化、销毁顺序是未定义行为

## 类

### 构造函数不要调用虚函数

在类被完全初始化前，这个类其实是基类+其他部分，此时调用虚函数不一定会指向子类的重载，可能会报错、出错

优点

- 不需要考虑类是否被完全初始化
- 初始化的对象可以为const类型

如果你想进行有意义的non-trivial初始化，可以使用明确的Init()方法，或者工厂模式

### 析构函数要设为虚函数

### 不要隐式类型转换

不要使用隐式类型转换

- 隐式转换会降低代码可读性，由于是存在函数重载时，让人难以判断到底在用哪一个函数
- 隐式转化可能会导致类型不匹配的错误

使用explict关键词（常用于**单参数**构造函数和类型转化操作符），可以使当前类型只能被显示类型转换，如果使用隐式转化，会报错

```C++
class Foo
{
    explicit Foo(int x, int y);    //这个类型不能被隐式转化，调用Func({42, 3.14})会报错
    ...
}
void Func(Foo f);
```

### 拷贝和移动

如果你的类型需要拷贝和支持，就请实现它，否则禁用它（`=delete`）

std::unique_ptr<int> 可移动，但是不能复制

- 可拷贝类型，可以使用相同类型的另一对象进行初始化，当前对象会得到相同的值，同时不改变源对象。
  - 用户通过定义拷贝构造函数、拷贝赋值操作符实现
- 可移动对象，可以使用相同类型的临时对象进行初始化，当前对象会得到相同的值
  - 用户通过定义移动构造函数、移动赋值操作符实现

不要为任何有可能有子类的类型提供拷贝和移动，可能会导致对象割裂

### 除了数据成员，其他一律用class

C++的class和struct很像，但是class有构造和析构函数，

