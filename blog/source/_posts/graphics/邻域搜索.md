---
layout: post
# 标题
title: SPH：邻域搜索
# 发布时间
date: 2023/2/6 19:33:25  
# 分类
categories: [graphics] 
# 标签
tags:
  - SPH
  - Physics
# 作者
#author: Reuben
# 缩略图
thumbnail: 
# 显示封面
cover: true
# 显示目录
toc: true
# 启用插件
plugins:
  - mathjax
---

# 邻域搜索

由于核函数存在作用范围，我们在积分时，只需要得到核半径内其他粒子的信息。这样相较于nxn的遍历，能大幅减少计算。

临域搜索是一种基于网格（grid）构建粒子拓扑关系的算法，找到该粒子所在位置和其相邻位置有哪些粒子

## 网格

我们在粒子作用范围构建一个网格，网格的边长等于核半径$\hslash $，我们发现网格是一个立方体，而核函数是一个球，$(i,j,k)$表示粒子所在网格的坐标

<img src="/images/grid.png" alt="grid" style="zoom: 33%;" />

### 球的作用范围

我们发现核函数球最少位于8个网格中（一个2x2x2的立方体），最多位于27个网格中（一个3x3x3的立方体），我们只使用8个网格作为临域（舍弃那些不重要的网格），很显然，球心向哪个方向靠，我们就使用哪8个网格

1. 找到球心所在网格坐标，构建临域坐标表，临域坐标初始均设为球心位置
2. 判断中心网格的中心坐标与球心的坐标位置关系
3. 存储临域Hash Key

```glsl
void GetNearbyKeys(int3 originIndex, float3 position, out int nearbyKeys[8]) 
{
    int3 nearbyBucketIndices[8];
    for (int i = 0; i < 8; i++) 
    {
        nearbyBucketIndices[i] = originIndex;
    }

    if ((originIndex.x + 0.5f) * CellSize <= position.x) 
    {        
        nearbyBucketIndices[4].x += 1;
        nearbyBucketIndices[5].x += 1;
        nearbyBucketIndices[6].x += 1;
        nearbyBucketIndices[7].x += 1;
    }
    else
    {
        nearbyBucketIndices[4].x -= 1;
        nearbyBucketIndices[5].x -= 1;
        nearbyBucketIndices[6].x -= 1;
        nearbyBucketIndices[7].x -= 1;
    }
    if ((originIndex.y + 0.5f) * CellSize <= position.y) 
    {
        nearbyBucketIndices[2].y += 1;
        nearbyBucketIndices[3].y += 1;
        nearbyBucketIndices[6].y += 1;
        nearbyBucketIndices[7].y += 1;
    }
    else
    {
        nearbyBucketIndices[2].y -= 1;
        nearbyBucketIndices[3].y -= 1;
        nearbyBucketIndices[6].y -= 1;
        nearbyBucketIndices[7].y -= 1;
    }
    if ((originIndex.z + 0.5f) * CellSize <= position.z) 
    {
        nearbyBucketIndices[1].z += 1;
        nearbyBucketIndices[3].z += 1;
        nearbyBucketIndices[5].z += 1;
        nearbyBucketIndices[7].z += 1;
    }
    else
    {
        nearbyBucketIndices[1].z -= 1;
        nearbyBucketIndices[3].z -= 1;
        nearbyBucketIndices[5].z -= 1;
        nearbyBucketIndices[7].z -= 1;
    }

    for (int j = 0; j < 8; j++) 
    {
        int3 nbcellIndex = nearbyBucketIndices[j];
        if (nbcellIndex.x < 0 || nbcellIndex.x >= Dimensions || nbcellIndex.y < 0 || nbcellIndex.y >= Dimensions || nbcellIndex.z < 0 || nbcellIndex.z >= Dimensions) 
        {
            nearbyKeys[j] = -1;		//出界了
        }
        else 
        {
            nearbyKeys[j] = Hash(nearbyBucketIndices[j]);
        }
    }
}
//将三维坐标转化为一维hash key
int Hash(int3 cell) {
    return cell.x + Dimensions * (cell.y + Dimensions * cell.z);
}
```

## 优化

> 先不优化，先把功能实现了再说，后面会回来更新的

### 紧凑哈希

在上面，我们给空间中每一个网格都分配了内存，即使该网格附近完全没有粒子，于是我们的，这很显然存在性能浪费

我们可以使用[紧凑哈希](https://github.com/InteractiveComputerGraphics/CompactNSearch)来节约内存

<img src="/images/紧凑哈希.png" alt="紧凑哈希" style="zoom:50%;" />





### 参考

[alen-cell](https://github.com/alen-cell/PhysicsEngine)

[A parallel SPH implementation on multi-core CPUs](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.187.5321&rep=rep1&type=pdf)
