<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2023/01/31/hello-world/"/>
      <url>/2023/01/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><p>$\Delta x$<br>$$<br>\lim_{n \rightarrow \infty}s_n=\lim_{n \rightarrow \infty}s_{2n}=s<br>$$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span><span class="token keyword">namespace</span> <span class="token namespace">Test</span><span class="token punctuation">&#123;</span>    <span class="token keyword">class</span> <span class="token class-name">MainClass</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adder</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">int</span></span> c<span class="token punctuation">;</span>            <span class="token keyword">public</span> <span class="token function">Adder</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token class-name">Adder</span> adder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Adder</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">></span></span> method <span class="token operator">=</span> adder<span class="token punctuation">.</span>Add<span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">const</span> vertex <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">0.6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span>onload <span class="token operator">=</span> initGL<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">initGL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> _a<span class="token punctuation">,</span> _b<span class="token punctuation">,</span> _c<span class="token punctuation">;</span>    <span class="token keyword">const</span> gl <span class="token operator">=</span> <span class="token punctuation">(</span>_a <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"glcanvas"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> _a <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token keyword">void</span> <span class="token number">0</span> <span class="token operator">:</span> _a<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"webgl"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vsSource <span class="token operator">=</span> <span class="token punctuation">(</span>_b <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"vertex-shader"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> _b <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token keyword">void</span> <span class="token number">0</span> <span class="token operator">:</span> _b<span class="token punctuation">.</span>textContent<span class="token punctuation">,</span> fsSource <span class="token operator">=</span> <span class="token punctuation">(</span>_c <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"fragment-shader"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> _c <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token keyword">void</span> <span class="token number">0</span> <span class="token operator">:</span> _c<span class="token punctuation">.</span>textContent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>gl<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Browser does not support webgl.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>vsSource <span class="token operator">&amp;&amp;</span> fsSource<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token string">'No shader found.'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    gl<span class="token punctuation">.</span><span class="token function">clearColor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">clearDepth</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>gl<span class="token punctuation">.</span><span class="token constant">DEPTH_BUFFER_BIT</span> <span class="token operator">|</span> gl<span class="token punctuation">.</span><span class="token constant">COLOR_BUFFER_BIT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> shaderProgram <span class="token operator">=</span> <span class="token function">initShaderProgram</span><span class="token punctuation">(</span>gl<span class="token punctuation">,</span> vsSource<span class="token punctuation">,</span> fsSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">useProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> programInfo <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">pos</span><span class="token operator">:</span> gl<span class="token punctuation">.</span><span class="token function">getAttribLocation</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> <span class="token string">"pos"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token literal-property property">color</span><span class="token operator">:</span> gl<span class="token punctuation">.</span><span class="token function">getUniformLocation</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> <span class="token string">"color"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">initBuffers</span><span class="token punctuation">(</span>gl<span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">vertexAttribPointer</span><span class="token punctuation">(</span>programInfo<span class="token punctuation">.</span>pos<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> gl<span class="token punctuation">.</span><span class="token constant">FLOAT</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">enableVertexAttribArray</span><span class="token punctuation">(</span>programInfo<span class="token punctuation">.</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">uniform3fv</span><span class="token punctuation">(</span>programInfo<span class="token punctuation">.</span>color<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">drawArrays</span><span class="token punctuation">(</span>gl<span class="token punctuation">.</span><span class="token constant">TRIANGLES</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">*</span> <span class="token punctuation">&#123;</span>  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">-webkit-box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">-moz-box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>  <span class="token property">outline</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++</title>
      <link href="/2023/01/31/Effective%20C++/"/>
      <url>/2023/01/31/Effective%20C++/</url>
      
        <content type="html"><![CDATA[<h1>Effective C++</h1><h2 id="一：C-基础">一：C++基础</h2><h3 id="C-很成熟，很NB">C++很成熟，很NB</h3><p>C++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）</p><p>其核心是四个部分</p><ul><li>C<ul><li>区块block</li><li>语句statements</li><li>预处理器preprocessor</li><li>内置数据类型</li><li>数组arrays</li><li>指针pointers</li></ul></li><li>Object-Orientend C++<ul><li>类classes（构造函数，析构函数）</li><li>封装encapsulation</li><li>继承inheritance</li><li>多态polymorphism</li><li>虚函数virtual（动态绑定）</li></ul></li><li>Template C++</li><li>STL</li></ul><h3 id="替换-define">替换#define</h3><p>使用编译器替代预处理器</p><p>尽量使用const、enum定义常量，使用inlines定义函数宏</p><h4 id="const">const</h4><pre><code class="language-c++">#define PI 3.1415926</code></pre><p>因为<code>#define</code>不是语言的一部分，在编译器开始工作前，<code>PI</code>就会被处理掉，所以一旦报错，你无法追踪到<code>PI</code>，只能看到<code>3.1415926</code>，这会<strong>浪费你的时间</strong></p><p>应该改为</p><pre><code class="language-c++">const double Pi 3.1415926;</code></pre><p>值得注意的事</p><ul><li>定义常量指针指向char*-based字符串</li></ul><pre><code class="language-c++">const char* const authorName = &quot;Reuben&quot;;</code></pre><ul><li>作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员</li></ul><pre><code class="language-c++">class GemePlayer&#123;private:static const int NumTurns = 5;//这只是一个声明式int scores[NumTurns];&#125;;const int GamePlayer::NumTurns;//这是定义式，因为在声明时已经赋值，所以这里就不赋值了</code></pre><p>C++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式</p><p>从这里可以看出，<strong>const可以封装</strong>，而#define不行</p><h4 id="enum">enum</h4><pre><code class="language-c++">class GemePlayer&#123;private:enum &#123; NumTurns = 5 &#125;;int scores[NumTurns];&#125;;</code></pre><h3 id="const指针">const指针</h3><p>const在星号左边，被指物是常量</p><pre><code class="language-c++">char greeting[] = &quot;Hello&quot;;const char* p = greeting;</code></pre><p>const在星号右边，指针本身是常量</p><pre><code class="language-c++">char greeting[] = &quot;Hello&quot;;char* const p = greeting;</code></pre><p>const在星号两边，被指物和指针都是常量</p><pre><code class="language-c++">char greeting[] = &quot;Hello&quot;;const char* const p = greeting;</code></pre><h3 id="确认对象在使用前已经被初始化">确认对象在使用前已经被初始化</h3><p>C++初始化顺序</p><ul><li>基类比子类先初始化</li><li>成员变量根据其声明次序初始化</li></ul><h2 id="二：构造-析构-赋值">二：构造/析构/赋值</h2><h3 id="空类的默认函数">空类的默认函数</h3><p>一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数</p><p>一个类，如果没有构造函数，也会自动声明一个default构造函数</p><p>这些函数都是public且inline的</p><h3 id="禁用自动生成的函数">禁用自动生成的函数</h3><p>如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）</p><ul><li>你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）</li></ul><pre><code class="language-c++">class HomeForSale&#123;private:HomeForSale(const HomeForSale&amp;);  HomeForSale&amp; operator=(const HomeForSale&amp;);&#125;;</code></pre><p>可以制作一个不可被copy的类，让子类继承</p><pre><code class="language-c++">class Uncopyable&#123;protected:Uncopyable()&#123;&#125;  ~Uncopyable()&#123;&#125;private:  Uncopyable(const Uncopyable&amp;);  Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;;class HomeForSale: private Uncopyable&#123;  ...&#125;;</code></pre><h3 id="为多态基类声明virtual析构函数">为多态基类声明virtual析构函数</h3><h4 id="一定要有一个virtual析构函数">一定要有一个virtual析构函数</h4><ul><li>如果这个类要成为一个基类，那么一定要有一个virtual析构函数</li></ul><p>在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错</p><pre><code class="language-c++">class TimeKeeper&#123;public:...&#125;;class AtomicClock: public TimeKeeper &#123;...&#125;;class WaterClock: public TimeKeeper &#123;...&#125;;</code></pre><pre><code class="language-c++">TimeKeeper* ptk = getTimeKeeper();//创建一个动态分配对象...delete ptk;//释放对象，避免资源泄漏</code></pre><p>上面这个过程的问题其实出在<code>getTimeKeeper()</code>指向一个派生类（derived class）对象（比如<code>AtomicClock</code>），而这个对象却要经由一个基类（base class）指针删除（比如<code>TimeKeeper*</code>）</p><p>如果这个基类的析构函数不是virtual的，就会出现问题：</p><ul><li>如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象</li></ul><p>解决方法就是给基类一个virtual析构函数</p><pre><code class="language-c++">class TimeKeeper&#123;public:TimeKeeper();  virtual ~TimeKeeper();  ...&#125;;</code></pre><h4 id="最好不要有virtual析构函数">最好不要有virtual析构函数</h4><ul><li>如果这个类不可能成为基类，那么最好不要有virtual析构函数</li></ul><p>为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由<strong>vptr（virtual table pointer）<strong>指针携带，这个指针指向一个由函数指针构成的数组，称为</strong>vtbl（virtual table）</strong>，每一个带有virtual函数的类都有一个属于自己的vtbl</p><p><strong>这个vtbl会增大对象的体积</strong>，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍</p><p><strong>这个vtbl会让代码失去兼容性</strong>，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性</p><h4 id="请不要继承没有virtual析构函数的类">请不要继承没有virtual析构函数的类</h4><p>比如string、vector、list、set等等</p><p>而且 C++没有像 Java的<code>final classes</code>或者C#的<code>sealed classes</code>的禁止派生机制</p><h3 id="不要在析构函数里抛出异常">不要在析构函数里抛出异常</h3><p>当一个<code>vector v</code>容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为</p><p>有两个不怎么好的解决方法</p><ul><li>遇到异常，直接<code>std::abort()</code>，即遇到异常，宁愿直接强制停止程序，也不要让异常传播</li><li>遇到异常，把异常记录下来，另程序继续运转，即<strong>吞下异常</strong><ul><li>这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好</li></ul></li></ul><p>比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容</p><pre><code class="language-c++">class DBConnevtion&#123;public:    ...    static DBConnevtion create();    void close();     &#125;;class DBConn&#123;public:    ...    void close()//封装给客户用的,关闭连接的函数    &#123;        db.close();        closed = true;    &#125;    ~DBConn()&#123;        if(!closed)&#123;            try&#123;                db.close();            &#125;            catch(...)&#123;                ...                //强制关闭程序或者吞下异常            &#125;        &#125;    &#125;private:    DBConnection db;    bool closed;&#125;;</code></pre><h3 id="不要在构造和析构过程中调用virtual函数">不要在构造和析构过程中调用virtual函数</h3><p>在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果</p><p>可以简单理解为<strong>在C++中，基类构造期间，vritual函数不是vritual函数</strong></p><p>因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数</p><p>同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的</p><h3 id="令operator-返回一个对-this的引用">令operator=返回一个对*this的引用</h3><p>连续赋值</p><pre><code class="language-c++">x = y = z = 15;//其实就等于x = (y = (z = 15))；</code></pre><p>为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参</p><pre><code class="language-c++">class Widget&#123;public:    Widget&amp; operator=(const Widget&amp; rhs)    &#123;    ...        return *this;    &#125;    Widget&amp; operator+=(const Widget&amp; rhs)&#123;        ...        return *this;    &#125;&#125;;</code></pre><h3 id="在operator-中处理自我赋值">在operator=中处理自我赋值</h3><p>如果对象自己赋给自己，我们称之为自我赋值</p><pre><code class="language-c++">w = w;a[i] = a[j]; //当i=j时，自我赋值*px = *py;//px和py指向同一个物体时，自我赋值</code></pre><p>在赋值操作中：</p><ol><li>我们会先另左边的操作数先释放掉当前使用的数据</li><li>令其使用右操作数的副本</li><li>最后返回左操作数</li></ol><pre><code class="language-c++">class Widget&#123;    ...private:    Bitmap *pb;&#125;;//!!!这个不安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;    delete pb;    pb = new Bitmap(*rhs.pb);    return *this;&#125;</code></pre><p>如果自我赋值，即rhs和pb指向同一个对象，那么<code>delete pb</code>后，这个对象就已经被销毁了，下面使用的<code>*rhs</code>就是一个已经被删除的对象</p><p>解决方法1：延后delete</p><pre><code class="language-c++">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;    Bitmap* pOrig = pb;    pb = new Bitmap(*rhs.pb);    delete pOrig;    return *this;&#125;</code></pre><p>解决方法2：使用copy and swap技术</p><pre><code class="language-c++">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;    Widget temp(rhs);    swap(temp);//令*this与temp交换    return *this;&#125;</code></pre><h3 id="复制对象的一切">复制对象的一切</h3><p>如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错</p><p>派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）</p><p>所以copy函数需要</p><ul><li>复制所有local变量</li><li>调用所有基类中的适当的copy函数</li></ul><h2 id="三：资源管理">三：资源管理</h2><h3 id="让对象管理资源">让对象管理资源</h3><p>将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源</p><ul><li>申请资源后立即将其放进对象中，<strong>资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）</strong></li><li>在对象的析构函数中释放资源</li></ul><p>C++的<code>auto_ptr</code>是一个<strong>类指针（pointer-like）对象</strong>，也就是<strong>智能指针</strong>，其析构函数会自动delete掉其所指向的对象</p><p>注意：</p><ul><li>不要让多个<code>auto_ptr</code>指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”</li><li><code>auto_ptr</code>如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权</li></ul><p>**RCSP（引用计数型智能指针）**也是一种智能指针（比如<code>tr1::shared_ptr</code>），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源</p><h3 id="小心copy行为">小心copy行为</h3><p>大多数RAII对象的copy函数：</p><ul><li>禁止复制</li><li>采用引用计数法（RCSP）</li><li>复制底部资源（深拷贝）</li><li>转移底层资源所有权（auto_ptr）</li></ul><h3 id="在资源管理类中提供对原始资源的访问">在资源管理类中提供对原始资源的访问</h3><p>有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）</p><h3 id="new与delete一个数组">new与delete一个数组</h3><p>一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？</p><ul><li>如果new了一个数组，就delete一个数组</li></ul><pre><code class="language-c++">string* ptr1 = new string[100];delete [] ptr1;</code></pre><ul><li>如果new了一个对象，就delete一个对象</li></ul><pre><code class="language-c++">string* ptr2 = new string;delete ptr2;</code></pre><p>很多时候很难确定当前这个对象是数组还是一个对象</p><pre><code class="language-c++">typedef string AddressLines[4];string* pal = new AddressLines;delete [] pal;</code></pre><p>最简单的方法是不用数组，使用STL里的容器，如<code>vector&lt;string&gt;</code></p><h3 id="以独立语句将newed对象置入智能指针">以独立语句将newed对象置入智能指针</h3><p>C++中调用一个函数，会先计算每一个传递进去的实参</p><p>如果按下面的写法，将newed对象置入智能指针中</p><pre><code class="language-c++">分配函数(shared_ptr&lt;Widget&gt;(new Widget), 资源访问);//不要这样写</code></pre><p>需要执行一下函数</p><ul><li>调用“资源访问”函数（A）</li><li>执行<code>new Widget</code>（B）</li><li>调用<code>shared_ptr</code>构造函数（C）</li></ul><p>然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）</p><p>如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏</p><p>所以简单的方法是分离语句</p><pre><code class="language-c++">shared_ptr&lt;Widget&gt; pw(new Widget);分配函数(pw, 资源访问);</code></pre><h2 id="四：设计与声明">四：设计与声明</h2><h3 id="让接口容易被正确使用">让接口容易被正确使用</h3><p>客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）</p><h4 id="限制参数传递">限制参数传递</h4><p>这是一个日期类</p><pre><code class="language-c++">class Date&#123;public:  Date(int month, int day, int year);  ...&#125;;...Date d(4, 20, 2022);</code></pre><p>客户很有可能填错顺序，也有可能填入一个无效的参数</p><p>可以使用<strong>外覆类型（wrapper types）</strong>，当然做出类会更好</p><pre><code class="language-c++">struct Day&#123;  explict Day(int d) : val(d) &#123;&#125;  int val;&#125;;struct Month&#123;  explict Month(int m) : val(m) &#123;&#125;  int val;&#125;;struct Year&#123;  explict Year(int y) : val(y) &#123;&#125;  int val;&#125;;class Date&#123;public:  Date(const Mouth&amp; month, const Day&amp; day, const Year&amp; year);  ...&#125;;...Date d(Month(4), Day(20), Year(2022));</code></pre><h4 id="一致性">一致性</h4><p>自定义的行为要与内置类型的行为一致，比如你不能把<code>operator*</code>重载成<code>operator+</code></p><p>或则像STL中，容器的接口都很一致，比如<code>size</code>、<code>push_back</code>等等</p><h3 id="设计class犹如设计type">设计class犹如设计type</h3><ul><li>对象要如何创建和销毁</li><li>对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）</li><li>对象如果被值传递，意味着什么（深浅拷贝）</li><li>约束成员变量的合法值</li><li>是否可以/需要被继承</li><li>能否类型转换，如何类型转换</li><li>支持何种操作符</li><li>成员变量的访问修饰</li><li>成员函数的访问修饰</li><li>未声明接口（undecided interface）</li><li>是否需要定义模版</li><li>真的需要一个新类吗？</li></ul><h3 id="多用引用传递">多用引用传递</h3><p>C++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些<strong>很大的自定义类型</strong>来说性能非常糟糕</p><p>使用const引用传递会好很多</p><ul><li>不会创建新的对象</li><li>不会改变原有对象</li><li>可以避免<strong>对象切割</strong>问题<ul><li>对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了</li></ul></li></ul><p>只不过引用传递是大多是通过指针实现的，在处理一些<strong>简单的内置类型</strong>时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递</p><h3 id="必须返回对象时，不要返回引用">必须返回对象时，不要返回引用</h3><p>如果必须返回对象，请不要返回引用（比如<code>operator*</code>，<code>operator==</code>），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个<strong>右值</strong>的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用</p><h3 id="将成员变量隐藏">将成员变量隐藏</h3><p>成员变量应该为private，而不是public</p><ul><li>客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）</li><li>分离读写权限（这一点C#做的更好？）</li><li>封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）</li><li>便于对成员变量进行约束（更不容易出现异常值）</li><li>protected并不比public更具有封装性</li></ul><h3 id="使用非成员函数">使用非成员函数</h3><ul><li>C#，java选手可以略过</li><li>C++标准库就是这样写的</li></ul><p>这里有一个类，其中有多个成员函数</p><pre><code class="language-c++">class WebBrowser&#123;public:void doA();  void doB();  void doC();  ...&#125;;</code></pre><p>现在需要令一个函数做ABC三件事，有两种写法</p><ul><li>成员函数</li></ul><pre><code class="language-c++">class WebBrowser&#123;public:...  void doEverything()&#123;    doA();    doB();    doC();  &#125;  ...&#125;;</code></pre><ul><li>非成员函数</li></ul><pre><code class="language-c++">void doEverything(WebBrowser&amp; wb)&#123;wb.doA();  wb.doB();  wb.doC();&#125;</code></pre><p>令人意外的是，第二种方法（使用非成员函数）更好</p><h4 id="什么是封装">什么是封装</h4><p>一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强</p><p>为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物</p><h4 id="为什么第二种比第一种封装性更强">为什么第二种比第一种封装性更强</h4><p>因为第一种给用户两种调用方法，一个是调用成员函数<code>doEverything()</code>，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性</p><ul><li>注意第一种方法中，<code>doEverything()</code>和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利</li></ul><p>那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的<strong>静态成员（static member）函数</strong>即可</p><p>或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）</p><pre><code class="language-c++">namespace WebBrowserStuff&#123;class WebBrowser&#123;...&#125;;void doEverything(WebBrowser&amp; wb)&#123;...&#125;&#125;</code></pre><ul><li><p>可拓展性更强</p><ul><li>客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）</li></ul></li><li><p>可拆分</p><ul><li>用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）</li></ul></li></ul><h3 id="如果所有参数都需要进行类型转换，使用非成员函数">如果所有参数都需要进行类型转换，使用非成员函数</h3><p>令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时</p><p>比如一个有理数乘法</p><pre><code class="language-c++">class Rational&#123;public:  //这个类没有自定义的explict构造函数  const Rational opertaor* (const Rational&amp; rhs) const;  ...&#125;;</code></pre><pre><code class="language-c++">Rational oneEighth(1,8);Rational oneHalf(1,2);Rational result = oneHalf * oneEighth;//成功result = result * oneEighth;//成功result = oneHalf * 2;//成功，等价于 result = oneHalf.operator*(2)result = 2 * oneHalf;//失败，等价于 result = 2.operator*(oneHalf)</code></pre><p><code>result = oneHalf * 2;</code>为什么成功，因为这里发生了一次隐式转换，将<code>2</code>转化为了一个<code>Rational</code>类型</p><p>在编译器中可能等价于</p><pre><code class="language-c++">const Rational temp(2);result = oneHalf * temp;</code></pre><ul><li>如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将<code>2</code>转化为一个<code>Rational</code>类型</li></ul><p><code>result = 2 * oneHalf;</code>为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时<code>2</code>就是一个int类型，没有我们所自定义的<code>operator*</code>函数，自然会失败</p><p>可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）</p><pre><code class="language-c++">const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123;  return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125;</code></pre><ul><li>此外要极力避免使用<strong>友元（friend）函数</strong></li><li>成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数</li></ul><h3 id="写一个不抛异常的swap函数">写一个不抛异常的swap函数</h3><p>swap函数原本是STL的一部分，后来称为了<strong>异常安全性编程</strong>的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要</p><p>std是一个很特殊的命名空间，客户可以<strong>全特化</strong>（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定</p><p>全特化：针对某个类做模板函数的特例，如对<code>std::swap</code>做一个针对<code>Widget</code>的特化</p><pre><code class="language-c++">class WidgetImpl&#123;...&#125;;//这个类的对象中存储着真正的数据class Widget&#123;public:    Widget&amp; operator=(const Widget&amp; rhs)&#123;        ...        *pImpl = *(rhs.pImpl);        ...    &#125;    ...    void swap(Widget&amp; other)&#123;//这个函数决对不可抛异常        using std::swap;        swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针    &#125;    ...private:    WidgetImple* pImpl;//这个类有一个指向资源对象的指针&#125;;namespace std&#123;template&lt;&gt;    void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;//这个可以抛异常        a.swap(b);    &#125;&#125;</code></pre><p>此外，C++的STL容器就是上面这种写法，提供了<code>public swap</code>成员函数和<code>std::swap</code>的特化版本</p><h2 id="五：实现（Implementations）">五：实现（Implementations）</h2><ul><li>随意定义变量可能会导致性能降低</li><li>过度使用转型（casts）可能会导致性能降低，难以维护，可读性低</li><li>返回对象的内部数据的handles，可能会破坏封装</li><li>未考虑异常可能会导致资源泄露和数据败坏</li><li>过度使用inline可能会导致包体膨胀</li><li>过度耦合（coupling）可能会增加构建时间（build times）</li></ul><h3 id="尽量延后变量定义式的出现时间">尽量延后变量定义式的出现时间</h3><h4 id="避免未曾使用的变量">避免未曾使用的变量</h4><p>如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过</p><p>此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、</p><h4 id="避免无意义的默认构造函数">避免无意义的默认构造函数</h4><p>如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好</p><h4 id="循环">循环</h4><p>此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？</p><p><strong>循环内</strong></p><pre><code class="language-c++">for(int i = 0; i &lt; n; i++)&#123;  Widget w(...);  ...&#125;</code></pre><ul><li><p>n个构造函数+n个析构函数</p></li><li><p>如果<code>Widget</code>是一个很敏感的类，这样会让其作用域更小，更容易理解和维护</p></li></ul><p><strong>循环外</strong></p><pre><code class="language-c++">Widget w;for(int i = 0; i &lt; n; i++)&#123;  w = ...;  ...&#125;</code></pre><ul><li>一个构造函数+一个析构函数+n个赋值操作</li><li>如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）</li></ul><h3 id="少做转型">少做转型</h3><p>C++是强类型语言，设计目标应该是保证类型错误绝不发生，然而<strong>类型转换</strong>破坏了类型系统</p><p>Java、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险</p><p>C++的类型转化</p><ul><li>旧式转换<ul><li><code>(T)expression</code></li><li><code>T(expression)</code></li></ul></li><li>新式转换<ul><li><code>const_cast&lt;T&gt;(expression)</code><ul><li>用于将对象的<strong>常量性转除（cast away the constness）</strong></li><li>比如将<code>const</code>转化为<code>non-const</code></li></ul></li><li><code>dynamic_cast&lt;T&gt;(expression)</code><ul><li>用来<strong>安全向下转型</strong></li><li>无法由旧式语句执行</li><li>耗费巨大</li></ul></li><li><code>reinterpret_cast&lt;T&gt;(expression)</code><ul><li>用于低级转型，实际操作取决于编译器，不可移植</li><li>极其少用</li></ul></li><li><code>static_cast&lt;T&gt;(expression)</code><ul><li>用于<strong>强迫隐式转换（implicit conversions）</strong></li><li>比如<code>non-const</code>转化为<code>const</code>，<code>int</code>转化为<code>double</code>，<code>void*</code>转化为<code>typed</code>，基类指针转化为派生类指针</li></ul></li></ul></li></ul><p>避免C++类型转换出问题的核心是<strong>避免使用基类的接口处理派生类</strong></p><h4 id="一个对象多个地址">一个对象多个地址</h4><p>C++很神奇，如果一个基类指针指向一个派生类对象，如</p><pre><code class="language-C++">Dervied d;Base* b = &amp;d;</code></pre><p>这可能会导致两个指针值不一样，即这个对象有两个地址，一个<code>Derivied*</code>指针一个<code>Base*</code>指针，这派生类指针上往往会有一个<strong>偏移量（offset）</strong>，通过这个偏移量，可以通过派生类指针找到基类指针</p><p>上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以<strong>请不要假定对象在C++中如何布局</strong>，更不应该基于这个假设对对象进行类型转换</p><p>如果你想让当前对象调用基类的函数，如果对<code>*this</code>做强制转化，转换为基类，<code>*this</code>其实是先前产生的<code>*this</code>对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题</p><pre><code class="language-c++">class SpecialWindow: public Window&#123;public:  virtual void onResize()&#123;    //static_cast&lt;Window&gt;(*this).onResize();//这样不好    Window::onResize();//请用这种方式调用基类的onResize函数（作用到当前对象上）    ...  &#125;&#125;</code></pre><h4 id="dynamic-cast">dynamic_cast</h4><p>这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象</p><p>什么时候使用这个东西？当<strong>你想在</strong>一个你认为是派生类对象的<strong>对象上执行</strong>派生类的操作<strong>函数</strong>，但你手里却只有一个指向基类的引用/指针时</p><p>解决方法：</p><ul><li>使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器</li><li>在基类中提供virtual函数</li></ul><h3 id="避免返回指向对象内部成分的handles">避免返回指向对象内部成分的handles</h3><p>前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便</p><p>但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的</p><pre><code class="language-c++">class Point&#123;public:  ...  void setX(int val);  ...&#125;;struct RectData&#123;  Point ulhc;//upper left hand corner  Point lrhc;//lower right hand corner&#125;;class Rectangle&#123;public:  ...  Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;//这样返回了引用，非常不好  ...private:  std::tr1::shared_ptr&lt;RectData&gt; pData;&#125;;...rec.upperLeft().setX(50);//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改</code></pre><p><code>upperLeft</code>函数本来只是为了提供给客户获得（get）<code>Rectangle</code>的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了<code>Rectangle</code>本身，而且还是一个内部数据<code>RectData</code></p><p>为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）</p><p>解决方法很简单，只要让handles不可以被修改，就可以了</p><pre><code class="language-c++">class Rectangle&#123;public:  ...  const Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;  ...&#125;;</code></pre><p>但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致<strong>dangling handles（空悬的号码牌）</strong>，比如返回了一个对local变量的引用，依然特别危险</p><p>当然，有的时候不得不返回handles，比如<code>operator[]</code></p><h3 id="异常安全性很重要">异常安全性很重要</h3><p>**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：</p><ul><li>不泄漏任何资源</li><li>不允许数据败坏</li></ul><p>不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂</p><p>三个保证：</p><ul><li>基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏</li><li>强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过<code>copy-and-swap</code>实现）</li><li>不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）</li></ul><p><strong>异常安全码</strong>必须提供上述三种保障之一，如果不能保障，则不具备异常安全性</p><h3 id="了解inline函数">了解inline函数</h3><p>内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化</p><p>缺点也很明显，会让包体变大，会导致<strong>换页行为（paging）</strong>，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数</p><p>内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联</p><h3 id="降低文件间的编译依存">降低文件间的编译依存</h3><p>如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译</p><p>为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用）</p><p>这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类</p><p><em>话说应该不会有人不知道implementation是实现的意思吧</em></p><pre><code class="language-c++">class PersonImpl;//pimpl写法，这是Person类的前置声明class Data;//Data的前置声明class Address;//Address的前置声明class Persion&#123;//像这样使用pimpl的类，往往被称为Handle classespublic:  ...  std::string name() const;  ...private:  std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;&#125;;</code></pre><p>在这种设计下，<code>Person</code>就与<code>Data</code>、<code>Address</code>以及<code>Persons</code>的实现分离了，改动这些类也不会导致使用<code>Person</code>的客户重新编译，客户无法看到<code>Person</code>的实现细节，真正实现<strong>接口与实现分离</strong></p><p>这个操作的本质是用<strong>声明的依赖性</strong>替换<strong>定义的依赖性</strong></p><p>此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明</p><p>此外还有另一种制作<code>Handle class</code>的方法，就是令<code>Person</code>成为一个特殊的抽象基类，称为<code>Interface class</code>，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）</p><pre><code class="language-c++">class Person&#123;//Interface classpublic:  virtual ~Person();  virtual std::string name() const = 0;  ...&#125;;class Person&#123;//具现化public:  static std::tr1::shared_ptr&lt;Person&gt; create(const std::string&amp; name...);  ...&#125;;...//使用std::tr1::shared_ptr&lt;Person&gt; pp(Person::create(name...));std::cout &lt;&lt; pp-&gt;name();</code></pre><pre><code class="language-c++">class RealPerson: public Person&#123;public:  RealPerson(const std::string&amp; name, ...): theName(name), ...&#123;&#125;  virtual ~RealPerson() &#123;&#125;  std::string name() const;  ...private:std::string theName;&#125;;std::string ReakPerson::name()&#123;...&#125;std::tr1::shared_ptr&lt;Person&gt; Person::create(const std::string&amp; name, ...)&#123;  retrun std::tr1::shared_ptr&lt;Person&gt;(new RealPerson(name, ...));&#125;</code></pre><h2 id="六：继承与面向对象">六：继承与面向对象</h2><ul><li><code>is-a</code>：是一个</li><li><code>has-a</code>：有一个</li><li><code>is-implemented-in-terms-of</code>：根据xx实现出</li></ul><h3 id="public继承是is-a关系">public继承是is-a关系</h3><pre><code class="language-c++">class Student: public Person&#123;...&#125;;//Student is a Person</code></pre><p>每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化</p><p><strong>public继承下，可以把子类当父类用</strong>，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用</p><p>这就出现了一个问题，子类一定要<code>is a</code>父类，不然会出现问题</p><p>错误的继承：</p><ul><li>企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？</li><li>正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？</li></ul><h3 id="避免遮掩父类成员">避免遮掩父类成员</h3><pre><code class="language-c++">int x;void Fun()&#123;    double x;    ...&#125;</code></pre><p>由于<strong>作用域</strong>的<strong>名称遮掩规则</strong>，函数内部的local变量x覆盖了全局变量x</p><h4 id="子类名称会遮掩父类名称，在public继承下是错误的">子类名称会遮掩父类名称，在public继承下是错误的</h4><p>在OOP中，如果子类重载了父类的<code>non-virtual</code>函数，就意味着子类使用同名函数遮掩了父类函数，就意味着<strong>这个父类函数没有被子类继承！</strong>，那么在这种情况下，继承就不是<code>is-a</code>关系了</p><p><strong>在public继承下，子类继承了父类的一切</strong></p><pre><code class="language-c++">class Base&#123;public:    virtual void f1() = 0;    virtual void f1(int);    void f2();    void f2(double);    ...private:    int x;&#125;;class Derived: public Base&#123;public:    virtual void f1();    void f2();&#125;;...Derived d;int x;d.f1();//正确，调用Derived::f1d.f1(x);//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)d.f2();//正确，调用Derived::f2d.f2(x);//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)</code></pre><h4 id="将被遮掩的名称重见天日">将被遮掩的名称重见天日</h4><p>解决起来很简单，只需要让父类的函数在子类作用域内可见，可以<strong>使用using关键字</strong></p><pre><code class="language-c++">class Derived: public Base&#123;public:    using Base::f1;    using Base::f2;    virtual void f1();    void f2();&#125;;...Derived d;int x;d.f1();//正确，调用Derived::f1d.f1(x);//正确，调用Base::f1d.f2();//正确，调用Derived::f2d.f2(x);//正确，调用Base::f2</code></pre><p>如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以<strong>使用转交函数</strong>，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中</p><pre><code class="language-c++">class Derived: private Base&#123;public:    virtual void f1()&#123;        Base::f1();//inline转交函数    &#125;    ...&#125;;...Derived d;int x;d.f1();//正确，调用Derived::f1d.f1(x);//错误，因为Derived::f1遮掩了Base::f1</code></pre><h3 id="区分接口继承和实现继承">区分接口继承和实现继承</h3><p>public继承分为两个部分</p><ul><li>函数接口继承</li><li>函数实现继承</li></ul><table><thead><tr><th></th><th>接口继承</th><th>实现继承</th></tr></thead><tbody><tr><td>纯虚函数</td><td>具体指定</td><td>不继承</td></tr><tr><td>非纯虚函数</td><td>具体指定</td><td>继承一份缺省实现</td></tr><tr><td>non-virtual函数</td><td>具体指定</td><td>继承一份强制实现</td></tr></tbody></table><h3 id="考虑使用virtual以外的选择">考虑使用virtual以外的选择</h3><h4 id="基于NVI的Template-Method模式">基于NVI的Template Method模式</h4><p>Non-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数</p><pre><code class="language-c++">class GameCharacter&#123;public：    int healthValue() const&#123;    ...    int retVal = doHealthValue();    ...    return retVal;&#125;private：    virtual int doHealthValue() const    &#123;...    &#125;&#125;;</code></pre><p>其中<code>healthValue()</code>被称为virtual函数的<strong>外覆器（wrapper）</strong></p><h4 id="基于函数指针的Strategy模式">基于函数指针的Strategy模式</h4><pre><code class="language-c++">class GameCharacter;int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public:    typedef int (*HealthCalcFunc)(const GameCharacter&amp;);    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125;    int healthValue() const &#123; return healthFunc(*this); &#125;    ...private:    HealthCalcFunc healthFunc;&#125;;</code></pre><p>在这种模式下，<code>defaultHealthCalc</code>函数不再是<code>GameCharacter</code>体系内的成员函数，通过修改函数指针，就可以让<code>GameCharacter</code>使用不同种类的计算函数，弹性更强，而且可以在运行时变更</p><p>此外<code>defaultHealthCalc</code>函数不需要/不能访问<code>GameCharacter</code>内的<code>non-public</code>部分，</p><h4 id="基于tr1-function的Strategy模式">基于tr1::function的Strategy模式</h4><p>上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如<code>tr1::function</code>对象</p><pre><code class="language-c++">class GameCharacter;int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public:    typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125;    int healthValue() const &#123; return healthFunc(*this); &#125;    ...private:    HealthCalcFunc healthFunc;&#125;;</code></pre><h4 id="古典的Strategy模式">古典的Strategy模式</h4><pre><code class="language-c++">class GameCharacter;class HealthCalcFunc&#123;public:    ...    virtual int calc(const GameCharacter&amp; gc) const&#123;...&#125;    ...&#125;;HealthCalcFunc defaultHealthCalc;class GameCharacter&#123;public:    explicit GameCharacter(HealthCalcFunc* phcf = &amp;defaultHealthCalc): pHealthFunc(phcf)&#123;&#125;    int healthValue() const &#123; return phealthFunc-&gt;calc(*this); &#125;    ...private:    HealthCalcFunc* pHealthFunc;&#125;;</code></pre><h3 id="绝不重新定义继承而来的non-virtual函数">绝不重新定义继承而来的non-virtual函数</h3><ul><li>静态绑定（staticcally bound）：non-virtual就是这种</li><li>动态绑定（dynamically bound）：virtual就是这种</li></ul><pre><code class="language-c++">class B&#123;public:void f();...&#125;;class D: public B&#123;public:  void f();  ...&#125;;...D x;B* pB = &amp;x;D* pD = &amp;x;pB-&gt;f();//调用B::fpD-&gt;f();//调用D::f</code></pre><h3 id="绝对不重新定义继承而来的缺省参数值">绝对不重新定义继承而来的缺省参数值</h3><p><strong>virtual函数是动态绑定的，缺省参数值是静态绑定的</strong></p><pre><code class="language-c++">class Cricle: public Shape&#123;...&#125;;...Shape* p1;//p1的静态类型是Shape*，没有动态类型Shape* p2 = new Circle;//p2的静态类型是Shape*，动态类型是Circle*</code></pre><ul><li>静态类型<ul><li>指针的类型就是<strong>静态类型</strong></li></ul></li><li>动态类型<ul><li>所指向的对象的类型是<strong>动态类型</strong></li><li>动态类型可以通过赋值等操作改变</li></ul></li></ul><p>virtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载</p><p>但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数</p><h3 id="has-a和根据xx实现出">has-a和根据xx实现出</h3><p>一个类中有多个小类，这种关系被称为<strong>复合（composition）</strong>，其中这些小类被称为<strong>合成成分物（composed object）</strong></p><ul><li>在应用域，复合意味着<code>has-a</code><ul><li>人有名字（也不尽然）</li></ul></li><li>在实现域，复合意味着<code>is-implemented-in-terms-of</code><ul><li>队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）</li></ul></li></ul><h3 id="少用private继承">少用private继承</h3><p><em>经典 C++糟粕，请问 C#有这个吗？</em></p><p>本质上是一种<code>is-implemented-in-terms-of</code>关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术</p><ul><li>private继承，编译器无法自动将子类对象转化为父类对象</li><li>private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）</li></ul><p><strong>尽量使用复合来替代pirvate继承</strong>，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数</p><p>此外private继承的对象有可能比复合的对象要小</p><h3 id="少用多重继承">少用多重继承</h3><p><em>经典 C++糟粕，请问 C#有这个吗？</em></p><ul><li>可能会导致歧义<ul><li>当然你可以在调用函数的时候指出是来自哪一个基类</li></ul></li><li>可能会导致菱形继承<ul><li>菱形继承可能会导致变量重复</li></ul></li></ul><h2 id="七：模版与泛型">七：模版与泛型</h2><p>模板（templates）是泛型编程（generic programming）的基础</p><p>模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译</p><h3 id="评价">评价</h3><p>优点：</p><ol><li>模板编程能够实现非常灵活且类型安全的接口</li><li>极好的性能（更小的文件、更短的运行期，更少的内存需求）</li><li>可以将一些运行时才能侦测到的错误，在编译期找出来</li></ol><p>缺点：</p><ol><li>难以编程和维护</li><li>编译报错信息难以理解</li><li>难以重构</li><li>编译时间大幅变长</li></ol><p>因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释</p><h3 id="隐式接口和编译期多态">隐式接口和编译期多态</h3><ul><li>OOP中经常使用显式接口和运行时多态</li><li>泛型编程更多使用隐式接口和编译期多态</li></ul><pre><code class="language-C++">template&lt;typename T&gt;void doProcessing(T&amp; w)&#123;    if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget)&#123;        T temp(w)        temp.normalize();        temp.swap(w);    &#125;&#125;</code></pre><p>从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组<strong>隐式接口</strong></p><p>所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功</p><p>这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是<strong>编译期多态</strong></p><h3 id="Traits">Traits</h3><p>一种约定俗成的技术方案，为同一类数据提供统一的操作函数</p><p>比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。</p><pre><code class="language-C++">enum Type&#123;    TYPE_1;    TYPE_2;&#125;;class FOO&#123;    Type type = Type::TYPE_1;&#125;;class Bar&#123;    Type type = Type::TYPE_2;&#125;;//统一的模板函数template&lt;typename T&gt;void decode(const T&amp; data, char* buf)&#123;    if(T::type == Type::TYPE_1)&#123;        ...    &#125;    else if(T::type == Type::TYPE_2)&#123;        ...    &#125;&#125;</code></pre><p>但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术</p><pre><code class="language-C++">enum Type&#123;    TYPE_1;    TYPE_2;&#125;;class FOO&#123;    Type type = Type::TYPE_1;&#125;;class Bar&#123;    Type type = Type::TYPE_2;&#125;;template&lt;typename T&gt;struct type_traits&#123;    Type type = T::type;&#125;//为内置数据类型特化为独有的 type_traitstemplate&lt;typename int&gt;struct type_traits&#123;    Type type = Type::TYPE_1;&#125;//统一的模板函数template&lt;typename T&gt;void decode(const T&amp; data, char* buf)&#123;    if(type_traits&lt;T&gt;::type == Type::TYPE_1)&#123;        ...    &#125;    else if(type_traits&lt;T&gt;::type == Type::TYPE_2)&#123;        ...    &#125;&#125;</code></pre><p>该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因</p><h3 id="模板元编程">模板元编程</h3><p>TMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化</p><p>如果一门语言具备以下功能，则称为图灵完全</p><ol><li>数值运算和符号运算</li><li>判断</li><li>递归</li></ol><h4 id="数值运算-递归">数值运算+递归</h4><pre><code class="language-C++">//一个TMP计算阶乘，而且阶乘的技术发生在编译期template&lt;unsigned n&gt;struct Factorial&#123;    enum &#123; value = n * Factorial&lt;n-1&gt;::value &#125;;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123;    enum &#123; value = 1 &#125;;&#125;;int main()&#123;    std::cout &lt;&lt; Factorial&lt;5&gt;::value;&#125;</code></pre><p>C++11TMP这种函数式编程得到了加强，上文也可以这样写</p><pre><code class="language-C++">template&lt;unsigned n&gt;struct Factorial&#123;    constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123;    constexpr static auto value = 1;&#125;;</code></pre><h4 id="判断">判断</h4><pre><code class="language-C++">template&lt;bool Value&gt;struct if_constexpr&#123;    constexpr static auto value = 1;&#125;;template&lt;&gt;struct if_constexpr&lt;false&gt; &#123;    constexpr static auto value = 2;&#125;;int main()&#123;    std::cout &lt;&lt; if_constexpr&lt;true&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; if_constexpr&lt;false&gt;::value &lt;&lt; std::endl;&#125;</code></pre><h3 id="typedef">typedef</h3><p>在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名</p><p>下面是一个函数指针的示例</p><pre><code class="language-C++">void add(int x, int y) &#123;    std::cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; x + y &lt;&lt; std::endl;&#125;void dec(int x, int y) &#123;    std::cout &lt;&lt; &quot;x-y=&quot; &lt;&lt; x - y &lt;&lt; std::endl;&#125;void mul(int x, int y) &#123;    std::cout &lt;&lt; &quot;x*y=&quot; &lt;&lt; x*y &lt;&lt; std::endl;&#125;void (*op[3])(int, int) = &#123; add, dec, mul &#125;;int main()&#123;    for (int i = 0; i &lt; 3; ++i) &#123;        （*op[i])(4, 3);    &#125;&#125;</code></pre><p>如果使用typedef</p><pre><code class="language-C++">typedef void (*Func[3])(int, int);Func f = &#123; add, dec, mul &#125;;int main()&#123;    for (int i = 0; i &lt; 3; ++i) &#123;        f[i](4, 3);    &#125;&#125;</code></pre><h2 id="八：定制new和delete">八：定制new和delete</h2><p>Java和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目</p><h3 id="new-handler">new-handler</h3><p>当<code>operator new</code>无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即<code>new-handler</code></p><p>使用<code>set_new_handler</code>来指定<code>new-handler</code></p><pre><code class="language-c++">void outOfMem()&#123;  std::cerr &lt;&lt; &quot;内存不足\n&quot;;  std::abort();&#125;int main()&#123;  std::set_new_handler(outOfMem);//该函数的参数是一个函数指针  int* array = new int[10000000L];  ...&#125;</code></pre><p>当<code>operator new</code>无法满足内存申请时，会不断调用<code>new-handler</code>函数，直到找到足够的内存，所以<code>new-handler</code>函数应该满足</p><ul><li>让更多的内存可被使用<ul><li>实现方法是程序开始时就分配一大块内存，每次调用<code>new-handler</code>时就释放一点点</li></ul></li><li>安装另一个<code>new-handler</code><ul><li>如果现在这个<code>new-handler</code>无法获取更多内存，需要知道哪一个<code>new-handler</code>具备增大内存的实力，然后使用<code>set_new_handler</code>来替换自己</li></ul></li><li>卸除<code>new-handler</code><ul><li>通过<code>set_new_handler</code>赋值<code>null</code>，将<code>new-handler</code>卸载，使得在内存分配不足时，会抛异常</li></ul></li><li>抛出<code>bad_alloc</code>异常<ul><li>这种异常不会被<code>operator new</code>捕获，会被传播至内存索求处</li></ul></li><li>不反回<ul><li>调用<code>abort</code>或者<code>exit</code></li></ul></li></ul><pre><code class="language-c++">class NewHandlerHolder&#123;public:  explicit NewHandlerHolder(std::new_handler nh): handler(nh) &#123;&#125;//获取当前的new_handler  ~NewHandlerHolder() &#123; std::set_new_handler(handler); &#125;private:  std::new_handler handler;//用于记录当前的new_handler&#125;;void* Widget::operator new(std::size_t size) throw(std::bad_alloc)&#123;  NewHandlerHolder h(std::set_new_handler(currentHandler));//安装Widget的new-handler  return ::operator new(size);//分配对象或者抛异常&#125;//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值</code></pre><pre><code class="language-c++">void outOfMem();Widget::set_new_handler(outOfMem);Widget* pwl = new Widget;//内存不足时会调用outOfMem</code></pre><p>mixin风格的写法</p><pre><code class="language-c++">template&lt;typename T&gt;class NewHandlerSupport&#123;public:  static std::new_handler_set set_new_handler(std::new_handler p) throw();  static void* operator new(std::size_t size) throw(std::bad_alloc);  ...private:  static std::new_handler currentHandler;&#125;;template&lt;typename T&gt;std::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()&#123;  std::new_handler oldHandler = currentHandler;  currentHandler = p;  return oldHandler;&#125;template&lt;typename T&gt;void* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) throw(std::bad_alloc)&#123;  NewHandlerHolder h(std::set_new_handler(currentHandler));  return ::operator new(size);&#125;</code></pre><pre><code class="language-c++">class Widget: public NewHandlerSupport&lt;Widget&gt;&#123;...&#125;;</code></pre><p>像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为<strong>怪异的循环模版模式（curiously recurring template pattern，CRTP）</strong></p><h3 id="替换new和delete的时机">替换new和delete的时机</h3><p>C++中所有的news返回的指针都必须要<strong>地址对齐</strong>，int要4对齐，double要8对齐</p><p>写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换</p><h3 id="编写new和delete的规则">编写new和delete的规则</h3><p>如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则</p><ul><li><p>new</p><ul><li>应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用<code>new-handler</code></li><li>有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）</li><li>new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理<strong>比正确大小更大的（错误）申请</strong></li></ul></li><li><p>delete</p><ul><li>收到null指针时不做任何事</li><li>处理<strong>比正确大小更大的（错误）申请</strong></li></ul></li></ul><h3 id="编写new时也要写对应的delete">编写new时也要写对应的delete</h3><pre><code class="language-c++">Widget* pw = new Widget;</code></pre><p>在这里调用了两个函数，一个时用以分配内存的<code>operator new</code>，一个是<code>Widget</code>的构造函数</p><p>如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的</p><p>运行时系统会调用<code>operator new</code>所对应的<code>operator delete</code>来释放地址，对于拥有正常签名式的new和delete来说不成问题</p><pre><code class="language-c++">void* operator new(std::size_t) throw(std::bad_alloc);//普通的newvoid operator delete(void* rawMemory) throw();//global中的普通的newvoid operator delete(void* rawMemory, std::size_t size) throw();//class中的new</code></pre><p>但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题</p><pre><code class="language-c++">void* operator new(std::size_t, void* pMemory) throw();//placement new，比普通new多带一个参数Widget* pw = new (std::cerr) Widget;//调用operator new，并以cerr作为其实参</code></pre><p>当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的<code>operator new</code>时如何运作的，所以运行时系统会去寻找<strong>参数个数与类型</strong>都与<code>operator new</code>相同的某个<code>operator delete</code></p><pre><code class="language-c++">void operator delete(void*, std::ostream&amp;) throw();//palcement delete</code></pre><pre><code class="language-c++">class Widget&#123;public:  static void* operator new(std::size_t size, std::ostream&amp; logStream) throw(std::bad_alloc);  static void operator delete(void* pMemory) throw();  static void operator delete(void* pMemoty, std::ostream&amp; logStream) throw();  ...&#125;;</code></pre><p>如果此时调用<code>delete pw</code>，只会调用普通的<code>delete</code>，因为只有在构造时发生异常时，运行时系统才会调用placement delete</p><p>最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete</p><h2 id="九：杂项">九：杂项</h2><h3 id="不要忽视编译器警告">不要忽视编译器警告</h3><p>很多人忽视警告，毕竟一个问题如果真的很严重，应该报错</p><p>比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为</p><pre><code class="language-c++">class B&#123;public:  virtual void f() const;&#125;;class D: public B&#123;  virtual void f();&#125;;</code></pre><p>报警告</p><pre><code class="language-c++">warning: D::f() hides virtual B::f()</code></pre><p>原本的目的是为了在D中重新定义virtual函数<code>f()</code>，但由于B中<code>f()</code>是const，在D中不是，此时B中的<code>f()</code>并没有在D中重新被声明，而是被整个遮掩了</p><h3 id="去熟悉标准程序库">去熟悉标准程序库</h3><p>尤其是TR1</p><h4 id="C-98有什么">C++98有什么</h4><ul><li>STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器</li><li>Iostream</li><li>国际化支持</li><li>数值处理，包括复数（complex）和纯数值数组（valarray）</li><li>异常阶层体系</li><li>C89标准程序库</li></ul><h4 id="TR1有什么（全在std-tr1中）">TR1有什么（全在<code>std::tr1</code>中）</h4><ul><li>智能指针<code>tr1::shared_ptr</code>和<code>tr1::weak_ptr</code></li><li><code>tr1::function</code></li><li><code>tr1::bind</code></li></ul><p>和（彼此无关的独立组件）</p><ul><li>哈希表</li><li>正则表达式</li><li>Tuple变量组</li><li><code>tr1::array</code></li><li><code>tr1::mem_fn</code></li><li><code>tr1::reference_wrapper</code></li><li>随机数生成工具</li><li>数学特殊函数</li><li>C99兼容</li></ul><p>和（基于template）</p><ul><li>Type traits</li><li><code>tr1::result_of</code></li></ul><h3 id="熟悉Boost">熟悉Boost</h3>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/01/31/hello-world2/"/>
      <url>/2023/01/31/hello-world2/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><p>$\Delta x$<br>$$<br>\lim_{n \rightarrow \infty}s_n=\lim_{n \rightarrow \infty}s_{2n}=s<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/01/31/hello-world3/"/>
      <url>/2023/01/31/hello-world3/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><p>$\Delta x$<br>$$<br>\lim_{n \rightarrow \infty}s_n=\lim_{n \rightarrow \infty}s_{2n}=s<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/01/31/hello-world4/"/>
      <url>/2023/01/31/hello-world4/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><p>$\Delta x$<br>$$<br>\lim_{n \rightarrow \infty}s_n=\lim_{n \rightarrow \infty}s_{2n}=s<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/01/31/hello-world5/"/>
      <url>/2023/01/31/hello-world5/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><p>$\Delta x$<br>$$<br>\lim_{n \rightarrow \infty}s_n=\lim_{n \rightarrow \infty}s_{2n}=s<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
