<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2023/01/31/hello-world5/"/>
      <url>/2023/01/31/hello-world5/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><p>$\Delta x$<br>$$<br>\lim_{n \rightarrow \infty}s_n=\lim_{n \rightarrow \infty}s_{2n}=s<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> dcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++</title>
      <link href="/2023/01/31/Effective%20C++/"/>
      <url>/2023/01/31/Effective%20C++/</url>
      
        <content type="html"><![CDATA[<h1>Effective C++</h1><h2 id="一：C-基础">一：C++基础</h2><h3 id="C-很成熟，很NB">C++很成熟，很NB</h3><p>C++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）</p><p>其核心是四个部分</p><ul><li>C<ul><li>区块block</li><li>语句statements</li><li>预处理器preprocessor</li><li>内置数据类型</li><li>数组arrays</li><li>指针pointers</li></ul></li><li>Object-Orientend C++<ul><li>类classes（构造函数，析构函数）</li><li>封装encapsulation</li><li>继承inheritance</li><li>多态polymorphism</li><li>虚函数virtual（动态绑定）</li></ul></li><li>Template C++</li><li>STL</li></ul><h3 id="替换-define">替换#define</h3><p>使用编译器替代预处理器</p><p>尽量使用const、enum定义常量，使用inlines定义函数宏</p><h4 id="const">const</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PI</span> <span class="token expression"><span class="token number">3.1415926</span></span></span></code></pre><p>因为<code>#define</code>不是语言的一部分，在编译器开始工作前，<code>PI</code>就会被处理掉，所以一旦报错，你无法追踪到<code>PI</code>，只能看到<code>3.1415926</code>，这会<strong>浪费你的时间</strong></p><p>应该改为</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">double</span> Pi <span class="token number">3.1415926</span><span class="token punctuation">;</span></code></pre><p>值得注意的事</p><ul><li>定义常量指针指向char*-based字符串</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> authorName <span class="token operator">=</span> <span class="token string">"Reuben"</span><span class="token punctuation">;</span></code></pre><ul><li>作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GemePlayer</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> NumTurns <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//这只是一个声明式</span><span class="token keyword">int</span> scores<span class="token punctuation">[</span>NumTurns<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> GamePlayer<span class="token double-colon punctuation">::</span>NumTurns<span class="token punctuation">;</span><span class="token comment">//这是定义式，因为在声明时已经赋值，所以这里就不赋值了</span></code></pre><p>C++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式</p><p>从这里可以看出，<strong>const可以封装</strong>，而#define不行</p><h4 id="enum">enum</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GemePlayer</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span> NumTurns <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> scores<span class="token punctuation">[</span>NumTurns<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="const指针">const指针</h3><p>const在星号左边，被指物是常量</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> greeting<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span></code></pre><p>const在星号右边，指针本身是常量</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> greeting<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span></code></pre><p>const在星号两边，被指物和指针都是常量</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> greeting<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span></code></pre><h3 id="确认对象在使用前已经被初始化">确认对象在使用前已经被初始化</h3><p>C++初始化顺序</p><ul><li>基类比子类先初始化</li><li>成员变量根据其声明次序初始化</li></ul><h2 id="二：构造-析构-赋值">二：构造/析构/赋值</h2><h3 id="空类的默认函数">空类的默认函数</h3><p>一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数</p><p>一个类，如果没有构造函数，也会自动声明一个default构造函数</p><p>这些函数都是public且inline的</p><h3 id="禁用自动生成的函数">禁用自动生成的函数</h3><p>如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的）</p><ul><li>你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名）</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">HomeForSale</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token function">HomeForSale</span><span class="token punctuation">(</span><span class="token keyword">const</span> HomeForSale<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  HomeForSale<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HomeForSale<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>可以制作一个不可被copy的类，让子类继承</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Uncopyable</span><span class="token punctuation">&#123;</span><span class="token keyword">protected</span><span class="token operator">:</span><span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token operator">~</span><span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Uncopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">HomeForSale</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">Uncopyable</span></span><span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="为多态基类声明virtual析构函数">为多态基类声明virtual析构函数</h3><h4 id="一定要有一个virtual析构函数">一定要有一个virtual析构函数</h4><ul><li>如果这个类要成为一个基类，那么一定要有一个virtual析构函数</li></ul><p>在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TimeKeeper</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">AtomicClock</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">TimeKeeper</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">WaterClock</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">TimeKeeper</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp">TimeKeeper<span class="token operator">*</span> ptk <span class="token operator">=</span> <span class="token function">getTimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个动态分配对象</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">delete</span> ptk<span class="token punctuation">;</span><span class="token comment">//释放对象，避免资源泄漏</span></code></pre><p>上面这个过程的问题其实出在<code>getTimeKeeper()</code>指向一个派生类（derived class）对象（比如<code>AtomicClock</code>），而这个对象却要经由一个基类（base class）指针删除（比如<code>TimeKeeper*</code>）</p><p>如果这个基类的析构函数不是virtual的，就会出现问题：</p><ul><li>如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象</li></ul><p>解决方法就是给基类一个virtual析构函数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TimeKeeper</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="最好不要有virtual析构函数">最好不要有virtual析构函数</h4><ul><li>如果这个类不可能成为基类，那么最好不要有virtual析构函数</li></ul><p>为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由<strong>vptr（virtual table pointer）<strong>指针携带，这个指针指向一个由函数指针构成的数组，称为</strong>vtbl（virtual table）</strong>，每一个带有virtual函数的类都有一个属于自己的vtbl</p><p><strong>这个vtbl会增大对象的体积</strong>，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍</p><p><strong>这个vtbl会让代码失去兼容性</strong>，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性</p><h4 id="请不要继承没有virtual析构函数的类">请不要继承没有virtual析构函数的类</h4><p>比如string、vector、list、set等等</p><p>而且 C++没有像 Java的<code>final classes</code>或者C#的<code>sealed classes</code>的禁止派生机制</p><h3 id="不要在析构函数里抛出异常">不要在析构函数里抛出异常</h3><p>当一个<code>vector v</code>容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为</p><p>有两个不怎么好的解决方法</p><ul><li>遇到异常，直接<code>std::abort()</code>，即遇到异常，宁愿直接强制停止程序，也不要让异常传播</li><li>遇到异常，把异常记录下来，另程序继续运转，即<strong>吞下异常</strong><ul><li>这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好</li></ul></li></ul><p>比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DBConnevtion</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">static</span> DBConnevtion <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DBConn</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//封装给客户用的,关闭连接的函数</span>    <span class="token punctuation">&#123;</span>        db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        closed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>closed<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">try</span><span class="token punctuation">&#123;</span>                db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token comment">//强制关闭程序或者吞下异常</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    DBConnection db<span class="token punctuation">;</span>    <span class="token keyword">bool</span> closed<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="不要在构造和析构过程中调用virtual函数">不要在构造和析构过程中调用virtual函数</h3><p>在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果</p><p>可以简单理解为<strong>在C++中，基类构造期间，vritual函数不是vritual函数</strong></p><p>因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数</p><p>同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的</p><h3 id="令operator-返回一个对-this的引用">令operator=返回一个对*this的引用</h3><p>连续赋值</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">x <span class="token operator">=</span> y <span class="token operator">=</span> z <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span><span class="token comment">//其实就等于x = (y = (z = 15))；</span></code></pre><p>为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="在operator-中处理自我赋值">在operator=中处理自我赋值</h3><p>如果对象自己赋给自己，我们称之为自我赋值</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">w <span class="token operator">=</span> w<span class="token punctuation">;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//当i=j时，自我赋值</span><span class="token operator">*</span>px <span class="token operator">=</span> <span class="token operator">*</span>py<span class="token punctuation">;</span><span class="token comment">//px和py指向同一个物体时，自我赋值</span></code></pre><p>在赋值操作中：</p><ol><li>我们会先另左边的操作数先释放掉当前使用的数据</li><li>令其使用右操作数的副本</li><li>最后返回左操作数</li></ol><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    Bitmap <span class="token operator">*</span>pb<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//!!!这个不安全</span>Widget<span class="token operator">&amp;</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">delete</span> pb<span class="token punctuation">;</span>    pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>如果自我赋值，即rhs和pb指向同一个对象，那么<code>delete pb</code>后，这个对象就已经被销毁了，下面使用的<code>*rhs</code>就是一个已经被删除的对象</p><p>解决方法1：延后delete</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Bitmap<span class="token operator">*</span> pOrig <span class="token operator">=</span> pb<span class="token punctuation">;</span>    pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pOrig<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>解决方法2：使用copy and swap技术</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Widget <span class="token function">temp</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//令*this与temp交换</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="复制对象的一切">复制对象的一切</h3><p>如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错</p><p>派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的）</p><p>所以copy函数需要</p><ul><li>复制所有local变量</li><li>调用所有基类中的适当的copy函数</li></ul><h2 id="三：资源管理">三：资源管理</h2><h3 id="让对象管理资源">让对象管理资源</h3><p>将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源</p><ul><li>申请资源后立即将其放进对象中，<strong>资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII）</strong></li><li>在对象的析构函数中释放资源</li></ul><p>C++的<code>auto_ptr</code>是一个<strong>类指针（pointer-like）对象</strong>，也就是<strong>智能指针</strong>，其析构函数会自动delete掉其所指向的对象</p><p>注意：</p><ul><li>不要让多个<code>auto_ptr</code>指向同一个对象，因为一个对象被多次删除就会导致“未定义行为”</li><li><code>auto_ptr</code>如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权</li></ul><p>**RCSP（引用计数型智能指针）**也是一种智能指针（比如<code>tr1::shared_ptr</code>），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源</p><h3 id="小心copy行为">小心copy行为</h3><p>大多数RAII对象的copy函数：</p><ul><li>禁止复制</li><li>采用引用计数法（RCSP）</li><li>复制底部资源（深拷贝）</li><li>转移底层资源所有权（auto_ptr）</li></ul><h3 id="在资源管理类中提供对原始资源的访问">在资源管理类中提供对原始资源的访问</h3><p>有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件）</p><h3 id="new与delete一个数组">new与delete一个数组</h3><p>一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？</p><ul><li>如果new了一个数组，就delete一个数组</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">string<span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> ptr1<span class="token punctuation">;</span></code></pre><ul><li>如果new了一个对象，就delete一个对象</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">string<span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">;</span><span class="token keyword">delete</span> ptr2<span class="token punctuation">;</span></code></pre><p>很多时候很难确定当前这个对象是数组还是一个对象</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> string AddressLines<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>string<span class="token operator">*</span> pal <span class="token operator">=</span> <span class="token keyword">new</span> AddressLines<span class="token punctuation">;</span><span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> pal<span class="token punctuation">;</span></code></pre><p>最简单的方法是不用数组，使用STL里的容器，如<code>vector&lt;string&gt;</code></p><h3 id="以独立语句将newed对象置入智能指针">以独立语句将newed对象置入智能指针</h3><p>C++中调用一个函数，会先计算每一个传递进去的实参</p><p>如果按下面的写法，将newed对象置入智能指针中</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">分配函数<span class="token punctuation">(</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">,</span> 资源访问<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不要这样写</span></code></pre><p>需要执行一下函数</p><ul><li>调用“资源访问”函数（A）</li><li>执行<code>new Widget</code>（B）</li><li>调用<code>shared_ptr</code>构造函数（C）</li></ul><p>然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行）</p><p>如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏</p><p>所以简单的方法是分离语句</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>分配函数<span class="token punctuation">(</span>pw<span class="token punctuation">,</span> 资源访问<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="四：设计与声明">四：设计与声明</h2><h3 id="让接口容易被正确使用">让接口容易被正确使用</h3><p>客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记）</p><h4 id="限制参数传递">限制参数传递</h4><p>这是一个日期类</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Date <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">2022</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>客户很有可能填错顺序，也有可能填入一个无效的参数</p><p>可以使用<strong>外覆类型（wrapper types）</strong>，当然做出类会更好</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Day</span><span class="token punctuation">&#123;</span>  explict <span class="token function">Day</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">int</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Month</span><span class="token punctuation">&#123;</span>  explict <span class="token function">Month</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">int</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Year</span><span class="token punctuation">&#123;</span>  explict <span class="token function">Year</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">int</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">const</span> Mouth<span class="token operator">&amp;</span> month<span class="token punctuation">,</span> <span class="token keyword">const</span> Day<span class="token operator">&amp;</span> day<span class="token punctuation">,</span> <span class="token keyword">const</span> Year<span class="token operator">&amp;</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Date <span class="token function">d</span><span class="token punctuation">(</span><span class="token function">Month</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Day</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Year</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="一致性">一致性</h4><p>自定义的行为要与内置类型的行为一致，比如你不能把<code>operator*</code>重载成<code>operator+</code></p><p>或则像STL中，容器的接口都很一致，比如<code>size</code>、<code>push_back</code>等等</p><h3 id="设计class犹如设计type">设计class犹如设计type</h3><ul><li>对象要如何创建和销毁</li><li>对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作）</li><li>对象如果被值传递，意味着什么（深浅拷贝）</li><li>约束成员变量的合法值</li><li>是否可以/需要被继承</li><li>能否类型转换，如何类型转换</li><li>支持何种操作符</li><li>成员变量的访问修饰</li><li>成员函数的访问修饰</li><li>未声明接口（undecided interface）</li><li>是否需要定义模版</li><li>真的需要一个新类吗？</li></ul><h3 id="多用引用传递">多用引用传递</h3><p>C++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些<strong>很大的自定义类型</strong>来说性能非常糟糕</p><p>使用const引用传递会好很多</p><ul><li>不会创建新的对象</li><li>不会改变原有对象</li><li>可以避免<strong>对象切割</strong>问题<ul><li>对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了</li></ul></li></ul><p>只不过引用传递是大多是通过指针实现的，在处理一些<strong>简单的内置类型</strong>时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递</p><h3 id="必须返回对象时，不要返回引用">必须返回对象时，不要返回引用</h3><p>如果必须返回对象，请不要返回引用（比如<code>operator*</code>，<code>operator==</code>），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个<strong>右值</strong>的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用</p><h3 id="将成员变量隐藏">将成员变量隐藏</h3><p>成员变量应该为private，而不是public</p><ul><li>客户只能通过成员函数访问变量，于是可以统一接口（全都是函数）</li><li>分离读写权限（这一点C#做的更好？）</li><li>封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问）</li><li>便于对成员变量进行约束（更不容易出现异常值）</li><li>protected并不比public更具有封装性</li></ul><h3 id="使用非成员函数">使用非成员函数</h3><ul><li>C#，java选手可以略过</li><li>C++标准库就是这样写的</li></ul><p>这里有一个类，其中有多个成员函数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">doA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">doB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">doC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>现在需要令一个函数做ABC三件事，有两种写法</p><ul><li>成员函数</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">void</span> <span class="token function">doEverything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">doA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">doB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">doC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ul><li>非成员函数</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">doEverything</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>wb<span class="token punctuation">.</span><span class="token function">doA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  wb<span class="token punctuation">.</span><span class="token function">doB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  wb<span class="token punctuation">.</span><span class="token function">doC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>令人意外的是，第二种方法（使用非成员函数）更好</p><h4 id="什么是封装">什么是封装</h4><p>一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强</p><p>为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物</p><h4 id="为什么第二种比第一种封装性更强">为什么第二种比第一种封装性更强</h4><p>因为第一种给用户两种调用方法，一个是调用成员函数<code>doEverything()</code>，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性</p><ul><li>注意第一种方法中，<code>doEverything()</code>和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利</li></ul><p>那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的<strong>静态成员（static member）函数</strong>即可</p><p>或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用）</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> WebBrowserStuff<span class="token punctuation">&#123;</span><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">doEverything</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p>可拓展性更强</p><ul><li>客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的）</li></ul></li><li><p>可拆分</p><ul><li>用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割）</li></ul></li></ul><h3 id="如果所有参数都需要进行类型转换，使用非成员函数">如果所有参数都需要进行类型转换，使用非成员函数</h3><p>令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时</p><p>比如一个有理数乘法</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">//这个类没有自定义的explict构造函数</span>  <span class="token keyword">const</span> Rational opertaor<span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp">Rational <span class="token function">oneEighth</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> oneEighth<span class="token punctuation">;</span><span class="token comment">//成功</span>result <span class="token operator">=</span> result <span class="token operator">*</span> oneEighth<span class="token punctuation">;</span><span class="token comment">//成功</span>result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//成功，等价于 result = oneHalf.operator*(2)</span>result <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> oneHalf<span class="token punctuation">;</span><span class="token comment">//失败，等价于 result = 2.operator*(oneHalf)</span></code></pre><p><code>result = oneHalf * 2;</code>为什么成功，因为这里发生了一次隐式转换，将<code>2</code>转化为了一个<code>Rational</code>类型</p><p>在编译器中可能等价于</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational <span class="token function">temp</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> temp<span class="token punctuation">;</span></code></pre><ul><li>如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将<code>2</code>转化为一个<code>Rational</code>类型</li></ul><p><code>result = 2 * oneHalf;</code>为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时<code>2</code>就是一个int类型，没有我们所自定义的<code>operator*</code>函数，自然会失败</p><p>可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换）</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>此外要极力避免使用<strong>友元（friend）函数</strong></li><li>成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数</li></ul><h3 id="写一个不抛异常的swap函数">写一个不抛异常的swap函数</h3><p>swap函数原本是STL的一部分，后来称为了<strong>异常安全性编程</strong>的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要</p><p>std是一个很特殊的命名空间，客户可以<strong>全特化</strong>（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定</p><p>全特化：针对某个类做模板函数的特例，如对<code>std::swap</code>做一个针对<code>Widget</code>的特化</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WidgetImpl</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//这个类的对象中存储着真正的数据</span><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token operator">*</span>pImpl <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//这个函数决对不可抛异常</span>        <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>pImpl<span class="token punctuation">,</span> other<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这是pimpl写法，交换两个对象只需要置换其pImpl指针</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    WidgetImple<span class="token operator">*</span> pImpl<span class="token punctuation">;</span><span class="token comment">//这个类有一个指向资源对象的指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">namespace</span> std<span class="token punctuation">&#123;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>    <span class="token keyword">void</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//这个可以抛异常</span>        a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>此外，C++的STL容器就是上面这种写法，提供了<code>public swap</code>成员函数和<code>std::swap</code>的特化版本</p><h2 id="五：实现（Implementations）">五：实现（Implementations）</h2><ul><li>随意定义变量可能会导致性能降低</li><li>过度使用转型（casts）可能会导致性能降低，难以维护，可读性低</li><li>返回对象的内部数据的handles，可能会破坏封装</li><li>未考虑异常可能会导致资源泄露和数据败坏</li><li>过度使用inline可能会导致包体膨胀</li><li>过度耦合（coupling）可能会增加构建时间（build times）</li></ul><h3 id="尽量延后变量定义式的出现时间">尽量延后变量定义式的出现时间</h3><h4 id="避免未曾使用的变量">避免未曾使用的变量</h4><p>如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过</p><p>此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、</p><h4 id="避免无意义的默认构造函数">避免无意义的默认构造函数</h4><p>如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好</p><h4 id="循环">循环</h4><p>此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？</p><p><strong>循环内</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  Widget <span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p>n个构造函数+n个析构函数</p></li><li><p>如果<code>Widget</code>是一个很敏感的类，这样会让其作用域更小，更容易理解和维护</p></li></ul><p><strong>循环外</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  w <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><ul><li>一个构造函数+一个析构函数+n个赋值操作</li><li>如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候）</li></ul><h3 id="少做转型">少做转型</h3><p>C++是强类型语言，设计目标应该是保证类型错误绝不发生，然而<strong>类型转换</strong>破坏了类型系统</p><p>Java、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险</p><p>C++的类型转化</p><ul><li>旧式转换<ul><li><code>(T)expression</code></li><li><code>T(expression)</code></li></ul></li><li>新式转换<ul><li><code>const_cast&lt;T&gt;(expression)</code><ul><li>用于将对象的<strong>常量性转除（cast away the constness）</strong></li><li>比如将<code>const</code>转化为<code>non-const</code></li></ul></li><li><code>dynamic_cast&lt;T&gt;(expression)</code><ul><li>用来<strong>安全向下转型</strong></li><li>无法由旧式语句执行</li><li>耗费巨大</li></ul></li><li><code>reinterpret_cast&lt;T&gt;(expression)</code><ul><li>用于低级转型，实际操作取决于编译器，不可移植</li><li>极其少用</li></ul></li><li><code>static_cast&lt;T&gt;(expression)</code><ul><li>用于<strong>强迫隐式转换（implicit conversions）</strong></li><li>比如<code>non-const</code>转化为<code>const</code>，<code>int</code>转化为<code>double</code>，<code>void*</code>转化为<code>typed</code>，基类指针转化为派生类指针</li></ul></li></ul></li></ul><p>避免C++类型转换出问题的核心是<strong>避免使用基类的接口处理派生类</strong></p><h4 id="一个对象多个地址">一个对象多个地址</h4><p>C++很神奇，如果一个基类指针指向一个派生类对象，如</p><pre class="language-C++" data-language="C++"><code class="language-C++">Dervied d;Base* b &#x3D; &amp;d;</code></pre><p>这可能会导致两个指针值不一样，即这个对象有两个地址，一个<code>Derivied*</code>指针一个<code>Base*</code>指针，这派生类指针上往往会有一个<strong>偏移量（offset）</strong>，通过这个偏移量，可以通过派生类指针找到基类指针</p><p>上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以<strong>请不要假定对象在C++中如何布局</strong>，更不应该基于这个假设对对象进行类型转换</p><p>如果你想让当前对象调用基类的函数，如果对<code>*this</code>做强制转化，转换为基类，<code>*this</code>其实是先前产生的<code>*this</code>对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SpecialWindow</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Window</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">onResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//static_cast&lt;Window>(*this).onResize();//这样不好</span>    <span class="token class-name">Window</span><span class="token double-colon punctuation">::</span><span class="token function">onResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//请用这种方式调用基类的onResize函数（作用到当前对象上）</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="dynamic-cast">dynamic_cast</h4><p>这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象</p><p>什么时候使用这个东西？当<strong>你想在</strong>一个你认为是派生类对象的<strong>对象上执行</strong>派生类的操作<strong>函数</strong>，但你手里却只有一个指向基类的引用/指针时</p><p>解决方法：</p><ul><li>使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器</li><li>在基类中提供virtual函数</li></ul><h3 id="避免返回指向对象内部成分的handles">避免返回指向对象内部成分的handles</h3><p>前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便</p><p>但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">RectData</span><span class="token punctuation">&#123;</span>  Point ulhc<span class="token punctuation">;</span><span class="token comment">//upper left hand corner</span>  Point lrhc<span class="token punctuation">;</span><span class="token comment">//lower right hand corner</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  Point<span class="token operator">&amp;</span> <span class="token function">upperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pData<span class="token operator">-></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//这样返回了引用，非常不好</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>  std<span class="token double-colon punctuation">::</span>tr1<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>RectData<span class="token operator">></span> pData<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>rec<span class="token punctuation">.</span><span class="token function">upperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setX</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改</span></code></pre><p><code>upperLeft</code>函数本来只是为了提供给客户获得（get）<code>Rectangle</code>的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了<code>Rectangle</code>本身，而且还是一个内部数据<code>RectData</code></p><p>为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器）</p><p>解决方法很简单，只要让handles不可以被修改，就可以了</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rectangle</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token function">upperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pData<span class="token operator">-></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致<strong>dangling handles（空悬的号码牌）</strong>，比如返回了一个对local变量的引用，依然特别危险</p><p>当然，有的时候不得不返回handles，比如<code>operator[]</code></p><h3 id="异常安全性很重要">异常安全性很重要</h3><p>**异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件：</p><ul><li>不泄漏任何资源</li><li>不允许数据败坏</li></ul><p>不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂</p><p>三个保证：</p><ul><li>基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏</li><li>强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过<code>copy-and-swap</code>实现）</li><li>不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现）</li></ul><p><strong>异常安全码</strong>必须提供上述三种保障之一，如果不能保障，则不具备异常安全性</p><h3 id="了解inline函数">了解inline函数</h3><p>内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化</p><p>缺点也很明显，会让包体变大，会导致<strong>换页行为（paging）</strong>，会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数</p><p>内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联</p><h3 id="降低文件间的编译依存">降低文件间的编译依存</h3><p>如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译</p><p>为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用）</p><p>这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类</p><p><em>话说应该不会有人不知道implementation是实现的意思吧</em></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PersonImpl</span><span class="token punctuation">;</span><span class="token comment">//pimpl写法，这是Person类的前置声明</span><span class="token keyword">class</span> <span class="token class-name">Data</span><span class="token punctuation">;</span><span class="token comment">//Data的前置声明</span><span class="token keyword">class</span> <span class="token class-name">Address</span><span class="token punctuation">;</span><span class="token comment">//Address的前置声明</span><span class="token keyword">class</span> <span class="token class-name">Persion</span><span class="token punctuation">&#123;</span><span class="token comment">//像这样使用pimpl的类，往往被称为Handle classes</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>  std<span class="token double-colon punctuation">::</span>tr1<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>PersonImpl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>在这种设计下，<code>Person</code>就与<code>Data</code>、<code>Address</code>以及<code>Persons</code>的实现分离了，改动这些类也不会导致使用<code>Person</code>的客户重新编译，客户无法看到<code>Person</code>的实现细节，真正实现<strong>接口与实现分离</strong></p><p>这个操作的本质是用<strong>声明的依赖性</strong>替换<strong>定义的依赖性</strong></p><p>此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明</p><p>此外还有另一种制作<code>Handle class</code>的方法，就是令<code>Person</code>成为一个特殊的抽象基类，称为<code>Interface class</code>，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数）</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span><span class="token comment">//Interface class</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span>  <span class="token keyword">virtual</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span><span class="token comment">//具现化</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>tr1<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//使用</span>std<span class="token double-colon punctuation">::</span>tr1<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token function">pp</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token double-colon punctuation">::</span><span class="token function">create</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> pp<span class="token operator">-></span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">RealPerson</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>string theName<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>string <span class="token class-name">ReakPerson</span><span class="token double-colon punctuation">::</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>std<span class="token double-colon punctuation">::</span>tr1<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token class-name">Person</span><span class="token double-colon punctuation">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  retrun std<span class="token double-colon punctuation">::</span>tr1<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Person<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">RealPerson</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="六：继承与面向对象">六：继承与面向对象</h2><ul><li><code>is-a</code>：是一个</li><li><code>has-a</code>：有一个</li><li><code>is-implemented-in-terms-of</code>：根据xx实现出</li></ul><h3 id="public继承是is-a关系">public继承是is-a关系</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//Student is a Person</span></code></pre><p>每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化</p><p><strong>public继承下，可以把子类当父类用</strong>，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用</p><p>这就出现了一个问题，子类一定要<code>is a</code>父类，不然会出现问题</p><p>错误的继承：</p><ul><li>企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？</li><li>正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？</li></ul><h3 id="避免遮掩父类成员">避免遮掩父类成员</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>由于<strong>作用域</strong>的<strong>名称遮掩规则</strong>，函数内部的local变量x覆盖了全局变量x</p><h4 id="子类名称会遮掩父类名称，在public继承下是错误的">子类名称会遮掩父类名称，在public继承下是错误的</h4><p>在OOP中，如果子类重载了父类的<code>non-virtual</code>函数，就意味着子类使用同名函数遮掩了父类函数，就意味着<strong>这个父类函数没有被子类继承！</strong>，那么在这种情况下，继承就不是<code>is-a</code>关系了</p><p><strong>在public继承下，子类继承了父类的一切</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Derived d<span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，调用Derived::f1</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)</span>d<span class="token punctuation">.</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，调用Derived::f2</span>d<span class="token punctuation">.</span><span class="token function">f2</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double)</span></code></pre><h4 id="将被遮掩的名称重见天日">将被遮掩的名称重见天日</h4><p>解决起来很简单，只需要让父类的函数在子类作用域内可见，可以<strong>使用using关键字</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>f1<span class="token punctuation">;</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>f2<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Derived d<span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，调用Derived::f1</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，调用Base::f1</span>d<span class="token punctuation">.</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，调用Derived::f2</span>d<span class="token punctuation">.</span><span class="token function">f2</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，调用Base::f2</span></code></pre><p>如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以<strong>使用转交函数</strong>，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//inline转交函数</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Derived d<span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，调用Derived::f1</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误，因为Derived::f1遮掩了Base::f1</span></code></pre><h3 id="区分接口继承和实现继承">区分接口继承和实现继承</h3><p>public继承分为两个部分</p><ul><li>函数接口继承</li><li>函数实现继承</li></ul><table><thead><tr><th></th><th>接口继承</th><th>实现继承</th></tr></thead><tbody><tr><td>纯虚函数</td><td>具体指定</td><td>不继承</td></tr><tr><td>非纯虚函数</td><td>具体指定</td><td>继承一份缺省实现</td></tr><tr><td>non-virtual函数</td><td>具体指定</td><td>继承一份强制实现</td></tr></tbody></table><h3 id="考虑使用virtual以外的选择">考虑使用virtual以外的选择</h3><h4 id="基于NVI的Template-Method模式">基于NVI的Template Method模式</h4><p>Non-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span>：    <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> retVal <span class="token operator">=</span> <span class="token function">doHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> retVal<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span>：    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">doHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>其中<code>healthValue()</code>被称为virtual函数的<strong>外覆器（wrapper）</strong></p><h4 id="基于函数指针的Strategy模式">基于函数指针的Strategy模式</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">defaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span> gc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>HealthCalcFunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc hcf <span class="token operator">=</span> defaultHealthCalc<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc healthFunc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>在这种模式下，<code>defaultHealthCalc</code>函数不再是<code>GameCharacter</code>体系内的成员函数，通过修改函数指针，就可以让<code>GameCharacter</code>使用不同种类的计算函数，弹性更强，而且可以在运行时变更</p><p>此外<code>defaultHealthCalc</code>函数不需要/不能访问<code>GameCharacter</code>内的<code>non-public</code>部分，</p><h4 id="基于tr1-function的Strategy模式">基于tr1::function的Strategy模式</h4><p>上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如<code>tr1::function</code>对象</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">defaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span> gc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>tr1<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span> HealthCalcFunc<span class="token punctuation">;</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc hcf <span class="token operator">=</span> defaultHealthCalc<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc healthFunc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="古典的Strategy模式">古典的Strategy模式</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">HealthCalcFunc</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span> gc<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>HealthCalcFunc defaultHealthCalc<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc<span class="token operator">*</span> phcf <span class="token operator">=</span> <span class="token operator">&amp;</span>defaultHealthCalc<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">pHealthFunc</span><span class="token punctuation">(</span>phcf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> phealthFunc<span class="token operator">-></span><span class="token function">calc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc<span class="token operator">*</span> pHealthFunc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="绝不重新定义继承而来的non-virtual函数">绝不重新定义继承而来的non-virtual函数</h3><ul><li>静态绑定（staticcally bound）：non-virtual就是这种</li><li>动态绑定（dynamically bound）：virtual就是这种</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>D x<span class="token punctuation">;</span>B<span class="token operator">*</span> pB <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>D<span class="token operator">*</span> pD <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>pB<span class="token operator">-></span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用B::f</span>pD<span class="token operator">-></span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用D::f</span></code></pre><h3 id="绝对不重新定义继承而来的缺省参数值">绝对不重新定义继承而来的缺省参数值</h3><p><strong>virtual函数是动态绑定的，缺省参数值是静态绑定的</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Cricle</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Shape</span></span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Shape<span class="token operator">*</span> p1<span class="token punctuation">;</span><span class="token comment">//p1的静态类型是Shape*，没有动态类型</span>Shape<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> Circle<span class="token punctuation">;</span><span class="token comment">//p2的静态类型是Shape*，动态类型是Circle*</span></code></pre><ul><li>静态类型<ul><li>指针的类型就是<strong>静态类型</strong></li></ul></li><li>动态类型<ul><li>所指向的对象的类型是<strong>动态类型</strong></li><li>动态类型可以通过赋值等操作改变</li></ul></li></ul><p>virtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载</p><p>但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数</p><h3 id="has-a和根据xx实现出">has-a和根据xx实现出</h3><p>一个类中有多个小类，这种关系被称为<strong>复合（composition）</strong>，其中这些小类被称为<strong>合成成分物（composed object）</strong></p><ul><li>在应用域，复合意味着<code>has-a</code><ul><li>人有名字（也不尽然）</li></ul></li><li>在实现域，复合意味着<code>is-implemented-in-terms-of</code><ul><li>队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现）</li></ul></li></ul><h3 id="少用private继承">少用private继承</h3><p><em>经典 C++糟粕，请问 C#有这个吗？</em></p><p>本质上是一种<code>is-implemented-in-terms-of</code>关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术</p><ul><li>private继承，编译器无法自动将子类对象转化为父类对象</li><li>private继承，父类中所有属性变成private类型（比如父类中的public、protected类型）</li></ul><p><strong>尽量使用复合来替代pirvate继承</strong>，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数</p><p>此外private继承的对象有可能比复合的对象要小</p><h3 id="少用多重继承">少用多重继承</h3><p><em>经典 C++糟粕，请问 C#有这个吗？</em></p><ul><li>可能会导致歧义<ul><li>当然你可以在调用函数的时候指出是来自哪一个基类</li></ul></li><li>可能会导致菱形继承<ul><li>菱形继承可能会导致变量重复</li></ul></li></ul><h2 id="七：模版与泛型">七：模版与泛型</h2><p>模板（templates）是泛型编程（generic programming）的基础</p><p>模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译</p><h3 id="评价">评价</h3><p>优点：</p><ol><li>模板编程能够实现非常灵活且类型安全的接口</li><li>极好的性能（更小的文件、更短的运行期，更少的内存需求）</li><li>可以将一些运行时才能侦测到的错误，在编译期找出来</li></ol><p>缺点：</p><ol><li>难以编程和维护</li><li>编译报错信息难以理解</li><li>难以重构</li><li>编译时间大幅变长</li></ol><p>因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释</p><h3 id="隐式接口和编译期多态">隐式接口和编译期多态</h3><ul><li>OOP中经常使用显式接口和运行时多态</li><li>泛型编程更多使用隐式接口和编译期多态</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;void doProcessing(T&amp; w)&#123;    if(w.size() &gt; 10 &amp;&amp; w !&#x3D; someNastyWidget)&#123;        T temp(w)        temp.normalize();        temp.swap(w);    &#125;&#125;</code></pre><p>从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组<strong>隐式接口</strong></p><p>所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功</p><p>这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是<strong>编译期多态</strong></p><h3 id="Traits">Traits</h3><p>一种约定俗成的技术方案，为同一类数据提供统一的操作函数</p><p>比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。</p><pre class="language-C++" data-language="C++"><code class="language-C++">enum Type&#123;    TYPE_1;    TYPE_2;&#125;;class FOO&#123;    Type type &#x3D; Type::TYPE_1;&#125;;class Bar&#123;    Type type &#x3D; Type::TYPE_2;&#125;;&#x2F;&#x2F;统一的模板函数template&lt;typename T&gt;void decode(const T&amp; data, char* buf)&#123;    if(T::type &#x3D;&#x3D; Type::TYPE_1)&#123;        ...    &#125;    else if(T::type &#x3D;&#x3D; Type::TYPE_2)&#123;        ...    &#125;&#125;</code></pre><p>但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术</p><pre class="language-C++" data-language="C++"><code class="language-C++">enum Type&#123;    TYPE_1;    TYPE_2;&#125;;class FOO&#123;    Type type &#x3D; Type::TYPE_1;&#125;;class Bar&#123;    Type type &#x3D; Type::TYPE_2;&#125;;template&lt;typename T&gt;struct type_traits&#123;    Type type &#x3D; T::type;&#125;&#x2F;&#x2F;为内置数据类型特化为独有的 type_traitstemplate&lt;typename int&gt;struct type_traits&#123;    Type type &#x3D; Type::TYPE_1;&#125;&#x2F;&#x2F;统一的模板函数template&lt;typename T&gt;void decode(const T&amp; data, char* buf)&#123;    if(type_traits&lt;T&gt;::type &#x3D;&#x3D; Type::TYPE_1)&#123;        ...    &#125;    else if(type_traits&lt;T&gt;::type &#x3D;&#x3D; Type::TYPE_2)&#123;        ...    &#125;&#125;</code></pre><p>该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因</p><h3 id="模板元编程">模板元编程</h3><p>TMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化</p><p>如果一门语言具备以下功能，则称为图灵完全</p><ol><li>数值运算和符号运算</li><li>判断</li><li>递归</li></ol><h4 id="数值运算-递归">数值运算+递归</h4><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;一个TMP计算阶乘，而且阶乘的技术发生在编译期template&lt;unsigned n&gt;struct Factorial&#123;    enum &#123; value &#x3D; n * Factorial&lt;n-1&gt;::value &#125;;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123;    enum &#123; value &#x3D; 1 &#125;;&#125;;int main()&#123;    std::cout &lt;&lt; Factorial&lt;5&gt;::value;&#125;</code></pre><p>C++11TMP这种函数式编程得到了加强，上文也可以这样写</p><pre class="language-C++" data-language="C++"><code class="language-C++">template&lt;unsigned n&gt;struct Factorial&#123;    constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123;    constexpr static auto value &#x3D; 1;&#125;;</code></pre><h4 id="判断">判断</h4><pre class="language-C++" data-language="C++"><code class="language-C++">template&lt;bool Value&gt;struct if_constexpr&#123;    constexpr static auto value &#x3D; 1;&#125;;template&lt;&gt;struct if_constexpr&lt;false&gt; &#123;    constexpr static auto value &#x3D; 2;&#125;;int main()&#123;    std::cout &lt;&lt; if_constexpr&lt;true&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; if_constexpr&lt;false&gt;::value &lt;&lt; std::endl;&#125;</code></pre><h3 id="typedef">typedef</h3><p>在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名</p><p>下面是一个函数指针的示例</p><pre class="language-C++" data-language="C++"><code class="language-C++">void add(int x, int y) &#123;    std::cout &lt;&lt; &quot;x+y&#x3D;&quot; &lt;&lt; x + y &lt;&lt; std::endl;&#125;void dec(int x, int y) &#123;    std::cout &lt;&lt; &quot;x-y&#x3D;&quot; &lt;&lt; x - y &lt;&lt; std::endl;&#125;void mul(int x, int y) &#123;    std::cout &lt;&lt; &quot;x*y&#x3D;&quot; &lt;&lt; x*y &lt;&lt; std::endl;&#125;void (*op[3])(int, int) &#x3D; &#123; add, dec, mul &#125;;int main()&#123;    for (int i &#x3D; 0; i &lt; 3; ++i) &#123;        （*op[i])(4, 3);    &#125;&#125;</code></pre><p>如果使用typedef</p><pre class="language-C++" data-language="C++"><code class="language-C++">typedef void (*Func[3])(int, int);Func f &#x3D; &#123; add, dec, mul &#125;;int main()&#123;    for (int i &#x3D; 0; i &lt; 3; ++i) &#123;        f[i](4, 3);    &#125;&#125;</code></pre><h2 id="八：定制new和delete">八：定制new和delete</h2><p>Java和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目</p><h3 id="new-handler">new-handler</h3><p>当<code>operator new</code>无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即<code>new-handler</code></p><p>使用<code>set_new_handler</code>来指定<code>new-handler</code></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">outOfMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"内存不足\n"</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>outOfMem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该函数的参数是一个函数指针</span>  <span class="token keyword">int</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000000L</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>当<code>operator new</code>无法满足内存申请时，会不断调用<code>new-handler</code>函数，直到找到足够的内存，所以<code>new-handler</code>函数应该满足</p><ul><li>让更多的内存可被使用<ul><li>实现方法是程序开始时就分配一大块内存，每次调用<code>new-handler</code>时就释放一点点</li></ul></li><li>安装另一个<code>new-handler</code><ul><li>如果现在这个<code>new-handler</code>无法获取更多内存，需要知道哪一个<code>new-handler</code>具备增大内存的实力，然后使用<code>set_new_handler</code>来替换自己</li></ul></li><li>卸除<code>new-handler</code><ul><li>通过<code>set_new_handler</code>赋值<code>null</code>，将<code>new-handler</code>卸载，使得在内存分配不足时，会抛异常</li></ul></li><li>抛出<code>bad_alloc</code>异常<ul><li>这种异常不会被<code>operator new</code>捕获，会被传播至内存索求处</li></ul></li><li>不反回<ul><li>调用<code>abort</code>或者<code>exit</code></li></ul></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">NewHandlerHolder</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">explicit</span> <span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler nh<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">handler</span><span class="token punctuation">(</span>nh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//获取当前的new_handler</span>  <span class="token operator">~</span><span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>  std<span class="token double-colon punctuation">::</span>new_handler handler<span class="token punctuation">;</span><span class="token comment">//用于记录当前的new_handler</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  NewHandlerHolder <span class="token function">h</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//安装Widget的new-handler</span>  <span class="token keyword">return</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配对象或者抛异常</span><span class="token punctuation">&#125;</span><span class="token comment">//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值</span></code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">outOfMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>outOfMem<span class="token punctuation">)</span><span class="token punctuation">;</span>Widget<span class="token operator">*</span> pwl <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span><span class="token comment">//内存不足时会调用outOfMem</span></code></pre><p>mixin风格的写法</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">NewHandlerSupport</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>new_handler_set <span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>new_handler currentHandler<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>std<span class="token double-colon punctuation">::</span>new_handler <span class="token class-name">NewHandlerSupport</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  std<span class="token double-colon punctuation">::</span>new_handler oldHandler <span class="token operator">=</span> currentHandler<span class="token punctuation">;</span>  currentHandler <span class="token operator">=</span> p<span class="token punctuation">;</span>  <span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span><span class="token operator">*</span> NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  NewHandlerHolder <span class="token function">h</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">NewHandlerSupport</span><span class="token operator">&lt;</span><span class="token class-name">Widget</span><span class="token operator">></span></span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为<strong>怪异的循环模版模式（curiously recurring template pattern，CRTP）</strong></p><h3 id="替换new和delete的时机">替换new和delete的时机</h3><p>C++中所有的news返回的指针都必须要<strong>地址对齐</strong>，int要4对齐，double要8对齐</p><p>写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换</p><h3 id="编写new和delete的规则">编写new和delete的规则</h3><p>如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则</p><ul><li><p>new</p><ul><li>应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用<code>new-handler</code></li><li>有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请）</li><li>new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理<strong>比正确大小更大的（错误）申请</strong></li></ul></li><li><p>delete</p><ul><li>收到null指针时不做任何事</li><li>处理<strong>比正确大小更大的（错误）申请</strong></li></ul></li></ul><h3 id="编写new时也要写对应的delete">编写new时也要写对应的delete</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">Widget<span class="token operator">*</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span></code></pre><p>在这里调用了两个函数，一个时用以分配内存的<code>operator new</code>，一个是<code>Widget</code>的构造函数</p><p>如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的</p><p>运行时系统会调用<code>operator new</code>所对应的<code>operator delete</code>来释放地址，对于拥有正常签名式的new和delete来说不成问题</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//普通的new</span><span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> rawMemory<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//global中的普通的new</span><span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> rawMemory<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//class中的new</span></code></pre><p>但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//placement new，比普通new多带一个参数</span>Widget<span class="token operator">*</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cerr<span class="token punctuation">)</span> Widget<span class="token punctuation">;</span><span class="token comment">//调用operator new，并以cerr作为其实参</span></code></pre><p>当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的<code>operator new</code>时如何运作的，所以运行时系统会去寻找<strong>参数个数与类型</strong>都与<code>operator new</code>相同的某个<code>operator delete</code></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//palcement delete</span></code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemoty<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>如果此时调用<code>delete pw</code>，只会调用普通的<code>delete</code>，因为只有在构造时发生异常时，运行时系统才会调用placement delete</p><p>最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete</p><h2 id="九：杂项">九：杂项</h2><h3 id="不要忽视编译器警告">不要忽视编译器警告</h3><p>很多人忽视警告，毕竟一个问题如果真的很严重，应该报错</p><p>比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span><span class="token punctuation">&#123;</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>报警告</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">warning<span class="token operator">:</span> <span class="token class-name">D</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> hides <span class="token keyword">virtual</span> <span class="token class-name">B</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>原本的目的是为了在D中重新定义virtual函数<code>f()</code>，但由于B中<code>f()</code>是const，在D中不是，此时B中的<code>f()</code>并没有在D中重新被声明，而是被整个遮掩了</p><h3 id="去熟悉标准程序库">去熟悉标准程序库</h3><p>尤其是TR1</p><h4 id="C-98有什么">C++98有什么</h4><ul><li>STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器</li><li>Iostream</li><li>国际化支持</li><li>数值处理，包括复数（complex）和纯数值数组（valarray）</li><li>异常阶层体系</li><li>C89标准程序库</li></ul><h4 id="TR1有什么（全在std-tr1中）">TR1有什么（全在<code>std::tr1</code>中）</h4><ul><li>智能指针<code>tr1::shared_ptr</code>和<code>tr1::weak_ptr</code></li><li><code>tr1::function</code></li><li><code>tr1::bind</code></li></ul><p>和（彼此无关的独立组件）</p><ul><li>哈希表</li><li>正则表达式</li><li>Tuple变量组</li><li><code>tr1::array</code></li><li><code>tr1::mem_fn</code></li><li><code>tr1::reference_wrapper</code></li><li>随机数生成工具</li><li>数学特殊函数</li><li>C99兼容</li></ul><p>和（基于template）</p><ul><li>Type traits</li><li><code>tr1::result_of</code></li></ul><h3 id="熟悉Boost">熟悉Boost</h3>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TA面试题</title>
      <link href="/2023/01/31/TA%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/01/31/TA%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>TA面试题</h1><p>这里面不少答案都是我自己凭感觉答的，不保真</p><h4 id="什么是渲染管线">什么是渲染管线</h4><p><strong>渲染管线</strong>是通过安排CPU发出Draw Call的内容以及顺序，指导GPU进行一系列操作，并协同将开发者期待的图像渲染在屏幕上</p><ul><li>剔除</li><li>渲染</li><li>后处理</li></ul><h4 id="什么是Draw-Call">什么是Draw Call</h4><p>Draw Call是CPU为GPU准备渲染数据，并指令GPU进行一次渲染的操作，是重量级的</p><h4 id="什么是Batching">什么是Batching</h4><p>将多个简单、使用同一材质的物体合并渲染的方式叫Batching</p><p><em>batch是批的意思</em></p><h4 id="渲染管线的渲染流程">渲染管线的渲染流程</h4><ul><li><p>延迟着色阶段（光栅化）Deferred Shading (rasterization)</p></li><li><p>直接阴影阶段（光线追踪或光栅化）Direct shadows (ray trace or rasterization)</p></li><li><p>光照阶段（计算着色器+光线追踪）Lighting (compute + ray trace)</p></li><li><p>反射阶段（光线追踪或计算着色器）Reflections(ray trace or compute)</p></li><li><p>全局光照阶段（计算着色器+光线追踪）Global Illumination (compute and ray trace)</p></li><li><p>环境光遮蔽阶段（光线追踪或计算着色器） Ambient occlusion (ray trace or compute)</p></li><li><p>透明与半透明渲染阶段（光线追踪+计算着色器）Transparency &amp; Translucency (ray trace and compute)</p></li><li><p>后处理阶段（计算着色器）Post processing (compute)</p></li></ul><h4 id="渲染流水线的基本流程">渲染流水线的基本流程</h4><p>渲染就是从一个三维场景出发，获得一个二维图像的过程。分为四个过程，应用阶段、几何阶段、光栅化阶段、像素处理阶段，其中几何阶段光栅化阶段主要在GPU中进行。</p><p>几何阶段分为五个步骤：顶点着色器、曲面细分着色器、几何着色器、裁剪、屏幕映射</p><p>光栅化阶段分为四个步骤：三角形设置、三角形遍历、片元着色器、逐片元操作</p><img src="/images/pipeline.png" class="lazyload" data-srcset="/images/pipeline.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1" style="zoom:33%;" /><h5 id="什么是顶点着色器">什么是顶点着色器</h5><ul><li><p>输入值是CPU通过Draw Call发出的顶点数组（没有索引）</p></li><li><p>输出值是齐次裁剪空间坐标（如果不使用细分着色器和几何着色器）</p></li></ul><h5 id="什么是细分着色器">什么是细分着色器</h5><ul><li><p>在显卡中**视口变换器(Viewport Transform)**中实现</p></li><li><p>将复杂的曲面转化为简单的点、线、三角形，可以增加网格细度，并在细分后的顶点上生成插值属性</p></li><li><p>如果使用了曲面细分着色器，顶点着色器就不会处理空间变化（如果没有顶点动画的需求，顶点着色器只负责传递数据），而是交给曲面着色器和几何着色器</p></li><li><p>在不改变网格外形的情况下，对网格进行平滑操作</p></li></ul><h5 id="什么是几何着色器">什么是几何着色器</h5><ul><li>在视口变换器中实现，输出值是齐次裁剪空间</li><li>能改变顶点数量</li><li>能按索引访问顶点</li></ul><h5 id="什么是网格着色器">什么是网格着色器</h5><ul><li>新一代三合一着色器，用于整合顶点、细分、几何着色器</li><li>可以实现无矩式渲染</li></ul><h5 id="屏幕映射">屏幕映射</h5><ul><li>输入齐次裁剪空间</li><li>（通过透视除法）转化到<strong>归一化设备坐标(NDC)</strong>，最后输出屏幕空间坐标</li></ul><h4 id="什么是渲染路径">什么是渲染路径</h4><p><strong>渲染路径</strong>是一系列对光照和着色(尤其是光照)的控制选项的集合</p><p>主流引擎支持前向渲染，延迟渲染，和自定义渲染</p><ul><li>前向渲染<ul><li>批次数=相机数x对象数x（除了主有向平行光外的逐片元光照数+1）</li><li>随着片元光照数量增多，性能大幅下降</li></ul></li><li>延迟渲染<ul><li>类似一种后处理</li><li>批次数=相机数x（网格数+逐片元光照数）</li><li>将几何通路和光照渲染通路分开，几何通道结果输送到G-Buffer中，然后对每个像素只进行一次光照计算</li></ul></li><li>自定义渲染<ul><li>屏幕后处理、天空盒、透明物体</li></ul></li></ul><h4 id="延迟渲染">延迟渲染</h4><h5 id="为什么延迟渲染不支持透明度混合">为什么延迟渲染不支持透明度混合</h5><p>因为半透明网格在G-Buffer中会被其他片元覆盖</p><h5 id="为什么延迟渲染不支持真的对抗锯齿">为什么延迟渲染不支持真的对抗锯齿</h5><p>因为G-Buffer需要的带宽远远大于帧缓冲，在多重抗锯齿下难以满足负载</p><h4 id="前向渲染">前向渲染</h4><p>前向渲染的渲染通路（Pass）有两种，分布是<strong>基本通路（forwardbase）<strong>和</strong>附加通路（forwardadd）</strong></p><p><strong>forwardbase</strong></p><ul><li>对所有的默认的<strong>有向平行光源</strong>及其产生的阴影进行逐片元计算，同时对其它基于顶点的和基于球谐光照的光源，以及物体的自发光、统一环境光和光照贴图进行计算</li><li>只对一个有效灯光执行一次，所以只会执行一次</li></ul><p><strong>forwardadd</strong></p><ul><li>对剩下的<strong>使用逐片元光照的光源</strong>进行光照计算</li><li>必须和forwardbase一同使用，不然会被忽略掉</li><li>对forwardbase外所有有效灯光都执行一次，所以会执行多次</li></ul><h4 id="向量">向量</h4><h5 id="向量点乘叉乘的几何意义">向量点乘叉乘的几何意义</h5><p>点乘是投影，叉乘是法向量（方向符合右手定则，沿大拇指方向）</p><h5 id="向量点乘叉乘的数学意义">向量点乘叉乘的数学意义</h5><p>$\mathbf{a} =\left( x_{1},y_{1},z_{1}\right)  $</p><p>$\mathbf{b} =\left( x_{2},y_{2},z_{2}\right)  $</p><p>$\mathbf{a} \cdot \mathbf{b} =|\mathbf{a} ||\mathbf{b} |\cos \theta =x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}$</p><img src="/images/叉积.png" class="lazyload" data-srcset="/images/叉积.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="叉积" style="zoom: 67%;" /><h5 id="求向量-mathbf-a-关于向量-mathbf-b-的对称向量-mathbf-c">求向量$\mathbf{a}$关于向量$\mathbf{b}$的对称向量$\mathbf{c}$</h5><p>$\mathbf{a} \cdot \mathbf{b}=\mathbf{c} \cdot \mathbf{b}$</p><p>$|\mathbf{a} |=|\mathbf{c} |$</p><h5 id="求点M关于直线l的对称点N">求点M关于直线l的对称点N</h5><p>M和N的中点在直线上</p><p>$\overrightarrow{MN} $与直线垂直</p><h4 id="欧拉角是什么？有何优缺点">欧拉角是什么？有何优缺点</h4><p>欧拉角是一个直观利用三维向量表达旋转的方法</p><p>优点：占用的空间小，不会遇到非法输入</p><p>缺点：没有统一标准、不能跨平台；三个分量可能不正交，可能有无法表示的角度；不能插值运算</p><h4 id="图形渲染用到哪些空间">图形渲染用到哪些空间</h4><ul><li>顶点着色器：模型空间–M–世界空间–V–观察空间–P–齐次裁剪空间----屏幕空间</li></ul><h4 id="什么是模版测试">什么是模版测试</h4><p>将屏幕的部分像素通过一个通道盖住，在渲染时剔除通道上不满足条件的值</p><h4 id="如何渲染半透明物体">如何渲染半透明物体</h4><ul><li>透明度测试</li><li>透明度混合</li></ul><h4 id="如何优化着色器代码">如何优化着色器代码</h4><ul><li>复杂计算放在顶点着色器中</li><li>简化等式，比如说：p = sqrt(2*(X+1))可以改写成1.414*sqrt(X+1)等</li><li>尽量使用内建函数</li><li>重复度低的操作可以交给CPU</li><li>使用顺序结构代替分支</li><li>丢弃片元时直接将alpha设为0</li><li>纹理图尽量使用2的n次方大小</li><li>将许多小纹理拼成一个大纹理</li><li>近点采样能满足要求就不要使用线性采样</li></ul><h4 id="如何判断多边形是凸多边形">如何判断多边形是凸多边形</h4><ul><li>角度法：内角是否小于180°</li><li>凸包法：如果凸包和原始多边形点数一样多，那么就是凸多边形</li><li>顶点凹凸性：本质上还是角度法，就是相邻顶点组成向量叉乘</li></ul><h4 id="相交测试">相交测试</h4><p><em>见图形学笔记</em></p><h4 id="法线贴图">法线贴图</h4><p>纹理就是贴图</p><p>法线纹理用RGB三个通道分布存储法向量在XYZ轴上分量大小</p><p>由于法线贴图大部分文素的方向都是朝向法线方向，于是法线贴图大多是蓝色的</p><h4 id="如何渲染阴影">如何渲染阴影</h4><ul><li>体积阴影法</li><li>深度阴影法</li></ul><h4 id="什么是HDR">什么是HDR</h4><p>高动态范围，一种颜色缓冲技术，使用更高的精度来表示亮度，能更真实的反应光照</p><p>HDR通过色调映射转到LDR</p><h4 id="什么是伽马矫正">什么是伽马矫正</h4><p>早期摄像机通过伽马加码，将实际亮度存储为更亮的值，显示时通过该骂解码获得正确的功率</p><h4 id="什么是色调映射">什么是色调映射</h4><p>就是利用显示器有限的亮度范围来近似实现HDR，就是将亮度映射到[0,1]的范围内，并压缩到8位的渲染目标上</p><h4 id="什么是PBR">什么是PBR</h4><p>基于物理的渲染</p><h4 id="正交投影和透视投影的区别">正交投影和透视投影的区别</h4><ul><li>都是源于对针孔摄像机对数学建模</li><li>视锥形状不一样</li></ul><h4 id="什么是齐次坐标">什么是齐次坐标</h4><p>为了实现仿射变换，将三维顶点引入四维空间，这个空间叫做齐次坐标空间</p><h4 id="旋转平移矩阵">旋转平移矩阵</h4><p><em>见图形学笔记</em></p><h4 id="高光模型">高光模型</h4><p>漫反射模型</p><ul><li>Lambert模型：反射光强度和 表面法线和光源的夹角的 余弦值成正比</li><li>半Lambert模型：光照有一个保底值，于是没有黑面</li><li>Minnaert模型：用于模拟丝绒</li><li>Oren-Nayar模型：风之旅人的沙子</li></ul><p>高光反射模型</p><ul><li>Phong模型：纯几何的经验模型，就是在Lambert漫反射上加了一点高光，强度与 视角方向和反射光方向的夹角的 余弦值成正比</li><li>Blinn-Phong模型：Phong的改进，不计算反射光，而是计算视角方向和光源方向的角平分矢量h，用h替代反射方向计算高光</li><li>Schlick模型：对BP模型的优化，简化一些运算，能获得更类似于油漆的效果</li></ul><p>基于物理的模型</p><ul><li>Cook-Torrance模型</li></ul><h4 id="什么是光栅化">什么是光栅化</h4><p>是渲染流水线的一个重要阶段</p><p>三角形设置和三角形遍历可以合成光栅化，计算三角网格，并进行线性插值</p><h4 id="阴影，软阴影">阴影，软阴影</h4><h4 id="什么是抗锯齿">什么是抗锯齿</h4><p>锯齿是走样的一种，指在渲染三角形、线的时候，像素要么存在，要么不存在，于是出现锯齿现象</p><ul><li>SSAA，超级采样抗锯齿，翻倍渲染向下采样</li><li>MSAA，多重采样抗锯齿，每个像素内有多个采样点，渲染时以点数加权获得（性能好，不支持延迟渲染）</li><li>FXAA/TXAA，放弃精度，让边缘模糊</li></ul><h4 id="延时渲染">延时渲染</h4><p>场景中有大量实时光源时，前向渲染效率会下降，使用两个Pass，一个不计算光照，只计算片元是否可见</p><p>不支持抗锯齿，不能处理透明物体</p><h4 id="故障检测">故障检测</h4><h4 id="后处理">后处理</h4><ul><li>亮度饱和度对比度</li><li>边缘检测</li><li>高斯模糊</li><li>动态模糊</li><li>Bloom效果</li></ul><h4 id="贴图技术">贴图技术</h4><p>贴图就是纹理</p><h4 id="BRDF">BRDF</h4><p>双向反射分布函数</p><h4 id="作品集里实现原理">作品集里实现原理</h4><p>ezy-slice原理：网格中存储了顶点数据、三角形数据、法线数据，使用MeshFilter获得sharemesh（mesh是新网格，sharemesh是原始网格）</p><p>物体的节点和三角形被分为三个部分（上下和切割面），相交处的三角形做分割操作，然后让原始网格不可见</p><h4 id="如何区分位置和方向">如何区分位置和方向</h4><p>齐次坐标，w==0就是位置，w==1就是方向</p><h4 id="SSAO">SSAO</h4><p>SS（Screen Space），都是后处理</p><p>SSGI屏幕空间全局光照</p><p>SSAO屏幕空间环境光遮蔽，对屏幕空间上每一个片元，在其法线范围的半球体中进行采样，采样点在深度纹理采样，从而判断该点是否被遮蔽</p><p>一般来说使用SSAO后还要在进行一次模糊，还需要进行时域平滑来避免闪动</p><h4 id="SSR">SSR</h4><p>SSR屏幕空间反射，在相机中发射出n条光线，然后根据物体的法向量和摄像机的射线方向计算出这条光线的反射方向。再对他进行raymarch（光线步进）计算。</p><h4 id="动态模糊">动态模糊</h4><p>种类</p><ul><li>相机动态模糊</li><li>对象动态模糊</li></ul><p>原理</p><ul><li>保存多帧数据进行混合</li><li>速度映射图，图中存储了每一个像素的速度，沿着这个速度采集像素，进行加权混合，得到模糊效果</li></ul><h4 id="线框">线框</h4><h5 id="方法1-深度偏移（这玩意不是线框，是描边）">方法1:深度偏移（这玩意不是线框，是描边）</h5><p>使用两个Pass渲染，一个正常渲染，一个在深度偏移的情况下渲染一遍线</p><ul><li>两个Pass有性能损失</li><li>深度偏移是为了防止线条被遮挡，这会导致多边形和线框在相同位置的片元的深度值不一样</li></ul><h5 id="方法2-几何着色器（这才是线框）">方法2:几何着色器（这才是线框）</h5><p>几何着色器可以使用索引数组访问顶点的拓扑结构</p><p>线框渲染可以使用几何着色器访问三角形，并计算每个顶点到对边的垂线长度，于是通过插值获得三角形中每个点到三角形三个边的最短距离</p><p>我们知道在光栅化阶段要插值上色，那么我们可以在插值的时候进行判断，当垂线距离符合条件时（离三角形边特别近）就染上线框的颜色</p><h4 id="片元着色器和像素着色器的区别">片元着色器和像素着色器的区别</h4><p><em>在大部分情况下没有区别</em></p><p>在极个别情况下（大概是OpenGL那边）我门认为如果片元着色器中的输入数据是恰好覆盖屏幕的四边形时，这个片元着色器被称为像素着色器</p><h4 id="SDF">SDF</h4><p>距离函数</p><p>shadertoy的本质就是通过编写（2D）距离函数来绘制物体</p><h4 id="为什么shader中少用分支和循环">为什么shader中少用分支和循环</h4><p>因为在gpu中，分支的实现原理是两个分支都执行，然后丢弃不需要的分支，这个增长是指数级的（2^n^）</p><h4 id="什么是Cubemap">什么是Cubemap</h4><p>立方体纹理，是实现环境映射的一种方法</p><h4 id="什么是光照探针">什么是光照探针</h4><p>是一组封装后的Cubemap，在烘培或预计算时，对空间中的一些采样点（光照探针）采集Cubemap，在运行环境渲染运动物体时，CPU会从离物体最近的光照探针中获取Cubemap，按照距离进行插值。</p><p>这个过程实现了CPU和GPU的解耦，CPU只需要维护一组固定的光照探针组，GPU只需要处理与这个物体相关的临近Cubemap</p><p>通过光照探针获取环境景象需要对场景进行六次渲染（毕竟有六个面）</p><h4 id="什么是球偕函数">什么是球偕函数</h4><p>将真实环境中连续的光照方程进行离散化，通过球形坐标系分解简化反射方程，通过球偕变换获得球偕系数，在运行时根据球偕系数重建方程</p><p>采样-分解-变换-重构</p><h4 id="参数和分量">参数和分量</h4><p>参数是黑盒，分量是白盒（你可以理解的是，别人在unity面板上拖动的属性多半是参数，一种东西的组成是分量，比如颜色可能就有由高光、漫反射等分量）</p><h4 id="为什么次表面散射用漫反射做高斯模糊">为什么次表面散射用漫反射做高斯模糊</h4><p>因为lambert的光照强度与入射光线和法线夹角有关，而折射和反射的比例也与这个夹角有关（菲涅尔）</p><p>折射光是次表面散射的入射光，折射的光越强，散射的光也会越强</p><h4 id="什么是光线步进">什么是光线步进</h4><p><strong>光线步进（raymarching）</strong>：从摄像机位置向屏幕每一个像素点发射一条光线，光线按照一定步长前进，并检测当前光线是否位于物体表面，据此调整光线前进幅度，直到抵达物体表面，再按照一般光线追踪的方法计算颜色值。</p><h4 id="什么是MC算法">什么是MC算法</h4><p>**步进立方体算法（Marching Cube）**是一种在密度场中采样来生成多边形的算法，在生成多边形之后再依照多边形渲染的过程进行正常的渲染。 相比射线扫描算法，步进立方体算法可以生成并保存多边形，所以在密度场的修改频率不高的情况下，使用步进立方体算法可以节省很多不必要的性能消耗。</p><p>核心：确定等值面</p><h4 id="什么是屏幕空间阴影纹理">什么是屏幕空间阴影纹理</h4><p>对于多光源的情况，每个光源都可以产生一个深度阴影纹理。在着色器中对这些深度阴影纹理逐个进行处理，可以得到若干个屏幕空间的阴影纹理，将这些屏幕空间下的阴影纹理混合就可得到一个总的屏幕空间阴影纹理，它表示了在屏幕空间中某个片元接受到的来自所有光源产生的阴影强度的总和</p><h4 id="什么是URP">什么是URP</h4><p>unity内的**渲染管线（Render pipelines）**包括</p><ul><li>内置渲染管线（Build-in）</li><li>可编程渲染管线（Scriptable Render Pipeline，SRP）<ul><li>高清渲染管线（High Definition Render Pipeline，HDRP）</li><li>通用渲染管线（Universal Render Pipeline，URP）</li></ul></li></ul><h4 id="什么是滤波模式">什么是滤波模式</h4><p>纹素坐标是整数值，但UV坐标不是，所以要有一种方法由UV坐标获得纹素值</p><h5 id="最近相邻滤波-Nearest-neighbor-filtering，或者Point-sampling">最近相邻滤波(Nearest neighbor filtering，或者Point sampling)</h5><ul><li><p>UV坐标 x 纹理大小，然后四舍五入取最近的纹素</p></li><li><p>有明显的像素块</p></li></ul><h5 id="双线性滤波-Bilinear-filtering，或者liner-filtering">双线性滤波(Bilinear filtering，或者liner filtering)</h5><ul><li>根据一个坐标到其附近最近的四个像素点的距离进行加权平均，得到一个混合的颜色</li></ul><img src="/images/双线性滤波.png" class="lazyload" data-srcset="/images/双线性滤波.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="双线性滤波" style="zoom: 33%;" /><h5 id="三线性滤波-Trilinear-filtering">三线性滤波(Trilinear filtering)</h5><ul><li>在相邻的两个Mipmap层次上分别进行双线性滤波，再对得到的两个值进行线性插值</li><li>当距离非常大或非常小的时候，三线性滤波会退化为双线性滤波</li></ul><h5 id="各项异性滤波-Anisotropic-filtering">各项异性滤波(Anisotropic filtering)</h5><p>当一个目标表面和透视摄像机之间的角度较大时，纹理的填充面积实际上并不是正方形，这引入了模糊和闪烁等瑕疵</p><ul><li>需要在一个非正方形区域内采样和混合</li><li>有的使用长方形，有的使用梯形</li></ul><h4 id="什么是纹理映射">什么是纹理映射</h4><p><em>就是将三维的空间坐标点转化为二维的纹理坐标点</em></p><p><strong>步骤</strong>：</p><ol><li>投影映射</li><li>变换函数</li><li>纹理采样</li><li>纹理转换</li></ol><h4 id="什么是纹理压缩">什么是纹理压缩</h4><p>这是一种有损压缩，对于一张原始纹理，会创建两张小纹理A和B，同时还有一个矩阵M，M的行列和原始纹理的长宽一致，里面的值类似于调色板中的索引，实现纹理A和纹理B的混合</p><h4 id="GPU的寻址方式">GPU的寻址方式</h4><h5 id="集成显卡">集成显卡</h5><p>对集成显卡来说，GPU使用CPU专门划分出来的一份内存空间**UMA（Unified Memory Architecture，一致性储存架构）**作为显存，GPU和CPU使用不同的虚拟地址对UMA中同一个物理地址进行寻址，两者共享总线。</p><p>在渲染时，CPU将顶点数据存储到主存中，然后GPU通过**GART(Graphic Address Remapping Table，显存地址重定位表)**访问UMA</p><h5 id="独立显卡">独立显卡</h5><p>独立显卡中CPU和显卡的沟通是使用异步的**DMA(Direct Memory Access，内存直接访问)**实现的。</p><ol><li>CPU将DMA命令从内存中读取，并写入DMA控制器</li><li>DMA控制器直接操控内存总线，在不依赖CPU的情况下将数据传输给显卡驱动</li><li>显卡驱动给DMA控制器发送信息（握手）</li><li>DMA占用内存总线，向内存请求地址，向显卡发送信号</li><li>显卡接受信号后将数据传输到内存，并清除DMA请求信号</li><li>沟通结束，触发一次CPU中断</li></ol><h4 id="CPU和GPU分支预测方式有何差别">CPU和GPU分支预测方式有何差别</h4><h5 id="CPU">CPU</h5><p>CPU在流水线中进行分支预测</p><ul><li>静态分支预测</li><li>动态分支预测</li><li>协同分支预测</li></ul><h5 id="GPU">GPU</h5><p>将两个结果都运行一次，然后丢弃不需要的分支，这样会严重影响性能（指数级），这个现象被称为<strong>线路分歧</strong></p><h4 id="纹理数据在GPU中是如何排列的">纹理数据在GPU中是如何排列的</h4><p>纹理存储器中的数据以一维/二维/三维数组的形式存储在显存中，可以通过缓存加速访问</p><p>在kernel中访问纹理存储器的操作称为<strong>纹理拾取(texture fetching)</strong></p><p>将显存中的数据与纹理参照系关联的操作，称为将数据与<strong>纹理绑定(texture binding)</strong></p><h4 id="shader中的变量类型（OpenGL）">shader中的变量类型（OpenGL）</h4><h5 id="uniform">uniform</h5><p>在顶点着色器和片元着色器中的声明方式完全一样，可以视为被双方共享的全局变量</p><h5 id="attribute">attribute</h5><p>只能在顶点着色器中使用的变量，一般用于存储顶点的位置、法线、uv、颜色信息</p><h5 id="varying">varying</h5><p>顶点着色器和片元着色器之间做数据传输用的变量，必须保证在两者中声明保持一致</p><h4 id="如何保证顶点着色器传入片元着色器的数据一致性">如何保证顶点着色器传入片元着色器的数据一致性</h4><p>varying变量声明一致？</p><h4 id="矩阵乘法">矩阵乘法</h4><p>两条直线的交点就是C的位置</p><img src="/images/矩阵乘法.png" class="lazyload" data-srcset="/images/矩阵乘法.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="矩阵乘法" style="zoom:50%;" /><p>x左乘A</p><p><img src="/images/x%E5%B7%A6%E4%B9%98A.png" class="lazyload" data-srcset="/images/x%E5%B7%A6%E4%B9%98A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="x左乘A"></p><p>x右乘A</p><img src="/images/x右乘A.png" class="lazyload" data-srcset="/images/x右乘A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="x右乘A" style="zoom:50%;" /><h4 id="直线扫描转化法">直线扫描转化法</h4><h5 id="数值微分法DDA">数值微分法DDA</h5><p>思想：步进和通过舍入选择像素</p><p>$P_{0}(0,0)$到$P_{1}(5,2)$</p><p>k=0.4</p><table><thead><tr><th>$i$</th><th>$x_{i}=x_{i-1}+1$</th><th>$y_{i}=y_{i-1}+k$</th><th>$round(y_{i})$</th><th>坐标</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>(0,0)</td></tr><tr><td>1</td><td>1</td><td>0+0.4=0.4</td><td>0</td><td>(1.0)</td></tr><tr><td>2</td><td>2</td><td>0.4+0.4=0.8</td><td>1</td><td>(2,1)</td></tr><tr><td>3</td><td>3</td><td>0.8+0.4=1.2</td><td>1</td><td>(3,1)</td></tr><tr><td>4</td><td>4</td><td>1.2+0.4=1.6</td><td>2</td><td>(4,2)</td></tr><tr><td>5</td><td>5</td><td>1.6+0.4=2.0</td><td>2</td><td>(5,2)</td></tr></tbody></table><h5 id="中点画线法">中点画线法</h5><p>相比于DDA算法，省去了浮点数运算</p><p>直线方程$F(x,y)=Ax+By+C=0$，若$F(x,y)&gt;0$则位于直线上方，若$&lt;0$则位于直线下方，若$=0$则在点上</p><p>使用步进思想，根据<strong>中点误差项</strong>判断是向右移动还是向右上移动（如果0&lt;k&lt;1)</p><img src="/images/中点画线.png" class="lazyload" data-srcset="/images/中点画线.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="中点画线" style="zoom: 33%;" /><p>直线已经经过点$P$，下一步经过了点$P_{u}$和$P_{d}$，他们的中点是M，我们将M带入直线方程，通过判断大小来决定是不是</p><p>为了进一步降低消耗，使用步进，每一次就将点$P(x_{i}+1,y_{i}+0.5)$带入直线方程$Ax+By+C=0$</p><ul><li><p>d&lt;0就取右边的点，$d_{i+1}=d_{i}+A+B$</p></li><li><p>d&gt;0就取右上的点，$d_{i+1}=d_{i}+A$</p></li></ul><p>只不过我们只关心符号，所以可以用2d代替d</p><ul><li><p>d&lt;0就取右边的点，$d_{i+1}=d_{i}+2A+2B$</p></li><li><p>d&gt;0就取右上的点，$d_{i+1}=d_{i}+2A$</p></li></ul><h5 id="Bresenham画线法">Bresenham画线法</h5><p>本质上和中点画线一样</p><ul><li><p>$d_{i}&lt;0$就取右边的点，$d_{i+1}=d_{i}+2\Delta y$</p></li><li><p>$d_{i}\geqslant 0$就取右上的点，$d_{i+1}=d_{i}+2\Delta y-2\Delta x$</p></li><li><p>$d_{1}=2\Delta y-\Delta x$</p></li></ul><p>$P_{0}(0,0)$到$P_{1}(5,2)$</p><p>k=0.4</p><p>$\Delta y=2$</p><p>$\Delta x=5$</p><table><thead><tr><th>$i$</th><th>$d_{i}$</th><th>$x_{i}$</th><th>$y_{i}$</th><th>坐标</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>(0,0)</td></tr><tr><td>1</td><td>$d_{1}=2\Delta y-\Delta x=-1&lt;0$</td><td>1</td><td>0</td><td>(1.0)</td></tr><tr><td>2</td><td>$d_{2}=d_{1}+2\Delta y=3&gt;0$</td><td>2</td><td>1</td><td>(2,1)</td></tr><tr><td>3</td><td>$d_{3}=d_{2}+2\Delta y-2\Delta x=-3&lt;0$</td><td>3</td><td>1</td><td>(3,1)</td></tr><tr><td>4</td><td>$d_{4}=d_{3}+2\Delta y=1&gt;0$</td><td>4</td><td>2</td><td>(4,2)</td></tr><tr><td>5</td><td>$d_{5}=d_{4}+2\Delta y-2\Delta x=-5&lt;0$</td><td>5</td><td>2</td><td>(5,2)</td></tr></tbody></table><h4 id="构建贝塞尔曲线">构建贝塞尔曲线</h4><h5 id="一阶">一阶</h5><p>两个点$P_{0},P_{1}$</p><p>直接坐标线形插值</p><p>$B_{1}(t)=(1-t)P_{0}+tP_{1}$</p><h5 id="二阶">二阶</h5><p>三个点$P_{0},P_{1},P_{2}$</p><p>先求$P_{0}P_{1}$和$P_{1}P_{2}$的一阶贝塞尔，然后再对两个一阶进行线性插值</p><h5 id="n阶">n阶</h5><p>$$<br>B_{i,n}\left( t\right)  =\frac{n!}{i!\left( n-i\right)  !} t^{i}\left( 1-t\right)^{n-i}<br>$$</p><ul><li>$i$是第几项，从0开始</li><li>$n$是控制点总数</li></ul><h4 id="线段的裁剪">线段的裁剪</h4><h5 id="Cohen-Sutherland">Cohen-Sutherland</h5><p>尽量避免求交运算</p><p>编码，把空间分为九个部分，其中中间部分是屏幕，其outcode编码为</p><img src="/images/裁剪.png" class="lazyload" data-srcset="/images/裁剪.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="裁剪" style="zoom:50%;" /><p>判断时，两个端点的outcode值为$o_{1}和o_{2}$</p><ul><li>若$o_{1}=o_{2}=0（其实是0000）$：说明两个点都在屏幕中间</li><li>若$o_{1}\neq 0,o_{2}=0（12顺序可以颠倒）$：说明一个在屏幕内，一个在屏幕外，而非零端点的编码说明了线段与裁剪窗口哪一个边（或者两个边）相交，需要计算交点</li><li>若$o_{1}&amp;o_{2}\neq 0$：说明两个点在裁剪窗口的同一侧，可以直接丢弃</li><li>若$o_{1}&amp;o_{2}= 0$：需要计算交点</li></ul><h5 id="Liang-Barsky">Liang-Barsky</h5><img src="/images/梁友栋.png" class="lazyload" data-srcset="/images/梁友栋.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="梁友栋" style="zoom: 25%;" /><p>窗口$Wx_{l}=0,Wx_{r}=4,Wy_{b}=0,Wy_{t}=3$</p><p>直线：<br>$$<br>\begin{cases}x=-2+u\left( 7+2\right)  &amp;\ y=6+u(-2-6)&amp;\end{cases}<br>$$</p><p>$$<br>\begin{cases}u_{1}=2/9&amp;\ u_{2}=2/3&amp;\ u_{3}=3/4&amp;\ u_{4}=3/8&amp;\end{cases}<br>$$</p><p>$u_{max}=\max(0,2/9,3/8)=3/8$</p><p>$u_{min}=\min(1,2/3,3/4=2/3)$</p><p>所以保留$u_{2}u_{4}$，其中$u_{2}=(4,2/3)\ u_{4}=(11/8,3)$</p><h3 id="Early-z">Early-z</h3><p>在vertex后，fragment前做一次深度测试，如果失败，则不进行fragment（如果成功，还是要在fragment中做ZTest），这样可以大幅提高性能</p><p>开启AlphaTest需要关闭Early-Z，因为AlphaTest通过会写入深度值，而新写入的深度值无法通过Early-Z，于是本该输出的颜色被剔除了（现在硬件做了优化，可以更智能的自动开关Early-Z）</p><h3 id="什么是球面度">什么是球面度</h3><p><strong>球面度sr</strong>是立体角的国际单位（平面角的单位是<strong>角度/弧度</strong>），可以理解为三维的弧度</p><ul><li><p>弧度</p><ul><li>在一个圆上切一个扇形，弧长等于$r$所对应的角为1弧度</li><li>一个完整的圆的弧度为$2\pi$</li></ul></li><li><p>球面度</p><ul><li>在一个球上切一个“锥形”，锥形的底面积等于$r^2$所对应的角为1球面度</li><li>一个完整的球的球面度为$4\pi$</li></ul></li></ul><img src="/images/球面度.png" class="lazyload" data-srcset="/images/球面度.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="球面度" style="zoom:50%;" /><h3 id="为什么BRDF-函数的单位是-1-sr">为什么BRDF 函数的单位是 1/sr</h3><p>BRDF，双向反射分布函数，是材质表面某一点出射**辐射率（Radiance）<strong>和入射</strong>辐照度（Irradiance）**的比值<br>$$<br>BRDF=\frac{dL\left( \omega_{o} \right)  }{dE\left( \omega_{i} \right)  }<br>$$</p><ul><li>辐射率$L$：每单位面积每单位**投影固体角（projected solid angle）**上的能量</li><li>辐照度$E$：每单位面积上的能量</li></ul><h4 id="为什么BRDF不直接用出射辐射率-入射辐射率呢？">为什么BRDF不直接用出射辐射率/入射辐射率呢？</h4><h5 id="原因一：因为入射辐射率很难测量">原因一：因为入射辐射率很难测量</h5><p>测量**出射辐射率$L_{0}$**很简单，只要我在出射方向上放一个下面的仪器，对准该点就可以了</p><img src="/images/测量辐射率.png" class="lazyload" data-srcset="/images/测量辐射率.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="测量辐射率" style="zoom: 33%;" /><p>测量<strong>入射辐射率</strong>很麻烦，需要要求光源很小，没有其他光的干扰，所以实际测量的时候不可行，于是不使用，最后BRDF就是出射辐照度/入射辐射率，这两个</p><p>而测量<strong>辐照度$E_{i}$<strong>只需要一个面积较小的平面，接收半球方向的</strong>光通量$\Phi $</strong>，$E=\Phi /S $</p><img src="/images/测量辐照度.png" class="lazyload" data-srcset="/images/测量辐照度.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="测量辐照度" style="zoom:50%;" /><h5 id="原因二：数学">原因二：数学</h5><p>如果是辐射率/辐射率，当出射立体角$\omega_{o}$趋近为0时，两者比值为0（上面是无穷小），没有意义<br>$$<br>\lim_{\omega_{o} \rightarrow 0} \frac{dL_{o}}{L_{i}} =0<br>$$<br>但辐射率/辐照度不等于零，因为上面下面都有无穷小，所以是不定式/等价无穷小，有意义<br>$$<br>\lim_{\omega_{o} \rightarrow 0} \frac{dL_{o}}{dE_{i}} \neq 0<br>$$</p><h3 id="什么是万向节死锁">什么是万向节死锁</h3><p>Gimbal Lock （万向节死锁，或叫 环向锁节）</p><p>在传统的欧拉坐标系，相机可以沿着xyz三个方向旋转，这三个轴有旋转的先后顺序，可以理解为父母层级关系，父轴旋转时子轴也会跟着旋转</p><ul><li>Y轴<ul><li>X轴<ul><li>Z轴</li></ul></li></ul></li></ul><p>相邻两个轴始终保持垂直，但有的时候，第一个轴会和第三个轴重合，于是你就会失去一个自由度，你无法朝向某一个方向旋转了，如果要旋转，就需要同时旋转两个轴，这个旋转很不流畅，会出现抽搐，被称为<strong>万向节死锁</strong></p><p>可以通过引入四元数解决</p><img src="/images/万向节锁.png" class="lazyload" data-srcset="/images/万向节锁.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="万向节锁" style="zoom:50%;" /><h3 id="有什么常见的遮挡算法">有什么常见的遮挡算法</h3><ul><li>画家算法<ul><li>后画覆盖新画</li><li>这是剔除的核心，下面几个都是对其的加速和优化</li></ul></li><li>沃诺克算法（Warnock）<ul><li>不停地四分屏幕<ul><li>当前子空间没有多边形：完成！</li><li>当前子空间只有一个多边形：画！</li><li>当前子空间有简单的前后关系：画前面的！</li><li>当前子空间只有一个像素那么大了：画离该像素点距离最近的多边形！</li><li>否则，继续递归细分</li></ul></li></ul></li><li>BSP-Tree（二维空间分割树）<ul><li>不停地二分空间，在每一个只有简单前后关系的子空间里使用画家算法</li></ul></li><li>Z-Buffer<ul><li>写入颜色时也写入Z值，绘制时根据Z值判断是否覆盖</li><li>有overdraw，只能处理不透明物体，多使用了一个Z-Buffer</li></ul></li></ul><h3 id="如何判断点在三角形内">如何判断点在三角形内</h3><h4 id="同侧法">同侧法</h4><p>若点P在三角形ABC内部，则</p><ul><li>点P和点A在直线BC同侧</li><li>点P和点B在直线AC同侧</li><li>点P和点C在直线AB同侧</li></ul><p>判断是否同侧都方法是叉积同号</p><h4 id="叉积法">叉积法</h4><p>PA、PB、PC两两叉积，如果三者同号则为内部</p><h4 id="重心公式">重心公式</h4><p>平面内两个不平行的非零向量可以表示任何向量<br>$$<br>\overrightarrow{AP} =u\overrightarrow{AB} +v\overrightarrow{AC}<br>$$<br>两边点积<br>$$<br>\overrightarrow{AP}\cdot \overrightarrow{AC}  =u\overrightarrow{AB}\cdot \overrightarrow{AC} +v\overrightarrow{AC}\cdot \overrightarrow{AC}<br>$$</p><p>$$<br>\overrightarrow{AP}\cdot \overrightarrow{AB}  =u\overrightarrow{AB}\cdot \overrightarrow{AB} +v\overrightarrow{AC}\cdot \overrightarrow{AB}<br>$$</p><p>两个变量两个公式，可以求出u和v</p><h3 id="什么是MIS">什么是MIS</h3><p>多重重要性采样（multiple importance sampling，MIS），在光追中，当光源和物体表面材质都接近$\delta$分布时，无论在光源上采样还是按BSDF采样都会带来很高的方差，使用MIS可以提高效果</p><p>思路就是结合不同种采用方法，分布采用被积函数的不同部分，讲这些部分结合起来，以达到最优效果</p><h4 id="什么是德尔塔分布">什么是德尔塔分布</h4><p>$\delta$函数（狄拉克函数）：除了零点以外的点都等于零，但在其整一个定义域内的积分为1的函数（这种函数本身并不存在）</p><p>$\delta$分布：符合$\delta$函数的分布</p><h3 id="已知UV和深度如何重建世界坐标">已知UV和深度如何重建世界坐标</h3><h4 id="使用逆矩阵">使用逆矩阵</h4><p>用uv和深度重建NDC坐标，乘以VP矩阵的逆矩阵以重建世界坐标</p><h4 id="线性深度">线性深度</h4><h5 id="正交投影">正交投影</h5><p>uvz线性映射回视锥长方体</p><h5 id="透视投影">透视投影</h5><p>通过z确定投影面大小，然后uv线性映射</p><h3 id="草地弯曲是怎么实现的">草地弯曲是怎么实现的</h3><p>顶点偏移？</p><h3 id="离角色很近的树叶如何保持性能">离角色很近的树叶如何保持性能</h3><h3 id="是不是每一次draw-call都需要重新传一次顶点数据">是不是每一次draw call都需要重新传一次顶点数据</h3><h3 id="贴花">贴花</h3><p>前向：绘制几何体</p><p>延迟：Gbuffer中绘制</p><h3 id="SSR会丢失信息，可以怎么处理">SSR会丢失信息，可以怎么处理</h3><p>用cubemap补一下？</p><h3 id="为什么有法线贴图还需要顶点法线信息">为什么有法线贴图还需要顶点法线信息</h3><p>为了构建TBN矩阵</p><p>在片元着色器中采集切线空间法线贴图信息，然后使用TBN矩阵恢复成世界空间法线，那么TBN是怎么来的呢？</p><pre class="language-c#" data-language="c#"><code class="language-c#">half3x3 tangentToWorld &#x3D; half3x3(i.tangentWS.xyz, bitangent.xyz, i.normalWS.xyz);</code></pre><p>是使用顶点着色器传入的世界空间切线、次切线、法线构建的</p><h3 id="Forward">Forward+</h3><p>和传统的前向渲染比添加了一个光源剔除阶段</p><p>着色分三个阶段：</p><ol><li>depth prepass（可选）</li><li>Light culling</li><li>shading</li></ol><p>将光源信息存储在一个线性布局的缓冲区中，方便查找</p><p>light culling阶段和延迟渲染中光照累计很相似，对于每一个像素，先找其所在的tile，求能照射到这个tile的光源列表，然后进行着色</p><p>理论上对每一个像素找灯光是效果最好的，现在这种找tile很显然是会计算一些多余的灯光，但是大幅减少了查找灯光的计算量，在查找和着色间寻找一个平衡</p><h3 id="移动端GPU渲染架构">移动端GPU渲染架构</h3><h4 id="IMR">IMR</h4><p>Immediate Mode Rending，即时模式渲染，按drawcall顺序绘制</p><img src="/images/IMR.png" class="lazyload" data-srcset="/images/IMR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMR" style="zoom:50%;" /><h4 id="TBR">TBR</h4><p>Tile Base Rendering</p><p>将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上，然后FS读信息，渲染每一个tile</p><img src="/images/TBR.png" class="lazyload" data-srcset="/images/TBR.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TBR" style="zoom:50%;" /><p>作用：<strong>省带宽</strong>，每次传一个小tile，对带宽的压力会比IMR小很多（IMR一次传一整张屏幕）</p><h4 id="TBDR">TBDR</h4><p>Tile Base Deferred Rendering</p><p>上面我们在FS对每一个tile做渲染时，完全可以记录哪些灯光会影响这个tile，使用这些光做计算</p><p>思路</p><p>TBR省带宽了，但是没减少overdraw，而TBDR处理了剔除问题，降低了overdraw</p><h4 id="TBR的其他应用">TBR的其他应用</h4><ul><li><p>MSAA：MSAA是对一个像素多采几个点，原本采样很费，因为要加载卸载贴图</p><ul><li>但是由于TBR每一个tile都是片上的，相当于省了加载卸载，性能好很多</li><li>只不过虽然采样变便宜了，采样结果一多，就要处理更多的采样数据，所以也不能无限制的使用</li><li>此外这会让多边形覆盖更多的像素</li></ul><p>如图，只有一个采样点时（红点），红圈所在的像素不会被算进去，但MSAA时就会被算进去</p><img src="/images/TBR的MSAA.png" class="lazyload" data-srcset="/images/TBR的MSAA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TBR的MSAA" style="zoom:50%;" /></li></ul><h3 id="视差贴图">视差贴图</h3><p>视差贴图（Parallax Mapping）效果类似法线贴图，其原理是对纹理采样uv做偏移，不修改顶点信息</p><img src="/images/视差贴图.jpeg" class="lazyload" data-srcset="/images/视差贴图.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="视差贴图" style="zoom: 33%;" /><p>原本平坦的表面，如果变成如图的凹凸形状，原本视线会与平面在B处相交，现在则在A处相交，我们采集$A’$点的信息</p><p>从B到$A’$做了什么呢？本质就是采样点从B点出发，沿着<strong>视线在平面的投影</strong>做了一次偏移，偏移的长度可以通过三角形相似求得</p><pre class="language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F;输入B的uv，得到A‘的uvfloat2 ParallaxMapping(float2 texCoords,float3 viewDir)&#123;     float height &#x3D; texture(depthMap, texCoords).r;        float2 p &#x3D; viewDir.xy &#x2F; viewDir.z * (height * height_scale);    return texCoords - p;    &#125;</code></pre><p>如果按深度步进，通过从上到下找第一个深度小于A的平面，来求$A’$的位置，就是陡峭视差映射(Steep Parallax Mapping)的思想</p><h3 id="virtual-texture">virtual texture</h3><p>根据是否实时生成（合并）virtual texture，该技术分为VT和RVT，该技术主要用于大世界地形上</p><p>在说VT前，要先谈texture splatting。大世界的地表纹理通常是使用多张纹理混合而成的（比如沙子、草、岩石、雪），而混合这些贴图的技术称为<strong>texture splatting</strong></p><p>该技术很简单，比如要混合四张图，那么生成一个新的RGBA贴图，在某一点的混合图为</p><pre class="language-c#" data-language="c#"><code class="language-c#">blenderTex &#x3D; Texture1 * map.r + Texture2 * map.g + Texture3 * map.b + Texture4 * map.a;&#x2F;&#x2F;其中 map.r + map.g + map.b + map.a 恒等于1</code></pre><img src="/images/texture splatting.png" class="lazyload" data-srcset="/images/texture splatting.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="texture splatting"  /><p>我们发现这种混合技术要频繁采样，混合四张图，要采9张图（四个材质图，四个法线图，一个splat图），而我们知道采一张大图会比采多个小图性能高很多，那么我们能不能把这九张小图拼成一张大图呢？这就是VT</p><p>但我们没必要一次把这九张完整的图合并，这也存在浪费，那么我们只需要合并需要被采样的图</p><p>我们把原图做预处理，分割成一个个小tile，并维护一个映射表，当我们要采样某个范围内的贴图时，先根据映射表找到所有相关的tile（回传给CPU，让CPU去加载tile），再把tile合并</p><h3 id="帕尼尼投影">帕尼尼投影</h3><p>一种屏幕后效，画面中心凸起，镜头左右两边在垂直方向上保留画面原样</p><p><img src="/images/%E5%B8%95%E5%B0%BC%E5%B0%BC%E6%8A%95%E5%BD%B1.jpeg" class="lazyload" data-srcset="/images/%E5%B8%95%E5%B0%BC%E5%B0%BC%E6%8A%95%E5%BD%B1.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="帕尼尼投影"></p><h3 id="SSBO">SSBO</h3><p>Shader Storage Buffer Object，该对象可以在不同shader间共享数据，功能类似UBO（Uniform Buffer Object）</p><p>两者（SSBO和UBO）区别</p><ul><li>SSBO更大</li><li>SSBO的大小可以在运行时确定</li><li>UBO在显卡的常量区（CMEM），SSBO在全局区（SMEM）</li><li>SSBO更灵活，能支持更多种的数据类型</li></ul><h3 id="计算任意多边形面积">计算任意多边形面积</h3><h4 id="凸多边形">凸多边形</h4><p>一多边形某个点为顶点，将多边形划分为多个三角形，计算每个三角形的面积（可以用向量叉积），再加起来</p><h4 id="凹多边形">凹多边形</h4><p>向量的叉积是有方向的<br>$$<br>S_{OAB}=0.5*(\overrightarrow{OA} \times \overrightarrow{OB})<br>$$</p><p>$$<br>S_{ABCDE}=S_{OBC}+S_{OCD}+S_{ODE}+S_{OEA}+S_{OAB}<br>$$</p><p><img src="/images/%E5%87%B9%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" class="lazyload" data-srcset="/images/%E5%87%B9%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="凹多边形面积"></p><h3 id="OBB包围盒">OBB包围盒</h3><p>常见的包围盒有AABB和OBB，AABB是轴向的，生成简单，但当物体旋转时效果并不好，OBB是有向的，沿着物体的主成分方向生成最小的一个矩形包围盒，可以随物体旋转</p><p><img src="/images/OBB%E4%B8%8EAABB.jpeg" class="lazyload" data-srcset="/images/OBB%E4%B8%8EAABB.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="OBB与AABB"></p><p>OBB2D的生成思路是：通过主成分分析（PCA）获得特征向量，作为OBB的主轴，然后将所有点包含</p><h4 id="主成分分析">主成分分析</h4><p>主成分分析是一种通过正交变换，将一组可能相关的变量集合变换成一组线性不相关的变量集合，即主成分</p><p>简单来说就是根据所有顶点生成协方差矩阵，对其对角化</p><h3 id="BS变形器">BS变形器</h3><p>blendshape</p><p>将一个mesh变化为另一个mesh（顶点数不变）的规则，就是一个BS，其最重要的功能是做表情</p><h3 id="什么是灭点">什么是灭点</h3><p>在透视投影中，不平行于投影平面的平行线会聚集到一点，改点就是灭点</p><h4 id="用途">用途</h4><p>在制作屏幕后效时（比如雨水），在相机的双锥体上渲染（而不是直接对屏幕四边形），可以得到一种雨水向远处收拢的感觉</p><img src="/images/灭点.jpg" class="lazyload" data-srcset="/images/灭点.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="灭点" style="zoom:67%;" /><h3 id="选人界面的打光与镜头">选人界面的打光与镜头</h3><ul><li><p>打光</p><ul><li><p>环境光：用HDRI贴图提供</p></li><li><p>直接光：打在人物正面斜上方，提供主要亮度，开启阴影</p></li><li><p>虚拟光：用于模拟反光板的提供的光源，亮度较弱，方向和相机一个位置（卡渲中常用，可以减弱光照对比，减弱阴影问题）</p></li></ul></li><li><p>镜头</p><ul><li><p>使用长焦镜头，也就是提高FOV，这样可以减少面部崎变，让人显得更瘦（反其道而行之，就是大头猪鼻特效）</p></li><li><p>开启景深</p><ul><li>深度景深：没法处理半透明物体，人物头发也会会出问题（因为深度变化太小）</li><li>Circle Blur：效果更好，美颜相机大多使用这个，原理就是把人抠出来，把人以外的背景模糊</li></ul></li></ul></li></ul><h3 id="眼球渲染的要点">眼球渲染的要点</h3><ul><li><p>眼白</p><ul><li>血丝<ul><li>可以直接画在贴图上</li></ul></li><li>次表面散射<ul><li>将散射函数预积分到LUT图上</li></ul></li></ul></li><li><p>眼睛</p><ul><li>镜面反射<ul><li>颗粒状眼白法线，来表现眼白的粘液</li></ul></li><li>AO<ul><li>在眼球外层做一个用来遮蔽的半透明模型</li></ul></li></ul></li><li><p>虹膜</p><ul><li>缩放<ul><li>uv采样缩放</li></ul></li><li>视差</li><li>焦散（猫的眼睛发亮）<ul><li>双层法线，圆滑的法线计算高光，平整的法线计算漫反射</li></ul></li><li>虹膜对光线的吸收（眼珠旁边有黑圈）<ul><li>根据uv画圆</li></ul></li><li>瞳孔收缩</li></ul></li><li><p>泪腺</p></li></ul><h3 id="移动端Deferred">移动端Deferred</h3><p>移动端延迟与GPU架构强相关</p><ul><li><p>iOS：one pass deferred</p></li><li><p>Adreno：frameBuffer fetch deferred</p><ul><li>提前绑定（开辟）好MRT，使用时RT不动，Pass动</li></ul></li><li><p>Mali：pixel loacl storage deferred</p><ul><li>将GBuffer存在on-clip mem上，于是就减少了IO消耗</li></ul></li></ul><h4 id="移动端SubPass">移动端SubPass</h4><p>Unity移动端使用Metal和Vulkan API时，都可以使用SubPass，但略有不同</p><p>在同一个RenderPass的不同SubPass间切换，是不会带来带宽消耗的</p><ul><li>Metal<ul><li>支持FrameBufferFetch，即可以在一个SubPass中对RT读写</li><li>不支持在Tile上读取深度</li></ul></li><li>Vulakn<ul><li>不支持FrameBufferFetch</li><li>支持在Tile读深度（mali设备读浮点纹理比读tile的深度更高效）</li></ul></li></ul><p>由于Metal不支持读深度，而mali Vulkan读深度效率比读RT差，所以Metal和Vulkan都在GBuffer Pass时额外生成一张深度RT，在LightingPass里用</p><h3 id="角色灯光术语">角色灯光术语</h3><h4 id="光比">光比</h4><p>指物体受光面亮度与阴影面亮度的比值，比值越大，明暗对比越强</p><p>常出现在黑暗空间爆炸光效照亮角色</p><h4 id="二值化光">二值化光</h4><p>照明时，灯光颜色在固定好的暗部颜色和亮部颜色之间插值</p><h3 id="抗锯齿">抗锯齿</h3><p>抗锯齿有两大类，时间层面和空间层面，但本质都是增加采样点数</p><ul><li>空域抗锯齿<ul><li>MSAA（MultiSampling Anti-Aliasing）：一个像素采多个点<ul><li>On-Clip MSAA</li></ul></li><li>FXAA（Fast Approximately -Aliasing）：卷积模糊</li><li>SMAA（Enhanced Subpixel Morphological）：边缘检测–矢量化–像素混合</li></ul></li><li>时域抗锯齿<ul><li>TAA（Temporal Antialiasing），一帧采一下，几帧后就等于采了很多点<br><img src="/images/TAA.png" class="lazyload" data-srcset="/images/TAA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TAA"></li></ul></li></ul><h3 id="svoGI">svoGI</h3><p>Sparse Voxel Octree（稀疏体素八叉树） GI，是VXGI的进阶版本</p><h3 id="无偏渲染">无偏渲染</h3><h3 id="SST">SST</h3><p>Sparse Shadow Tree，一种大范围阴影渲染方案</p><p><a href="https://www.activision.com/cdn/research/SparseShadowTree.pdf">论文地址</a></p><h3 id="ShadowCache">ShadowCache</h3><p>对静态物体和动态物体使用两套CSM，一套只绘制动态物体，每帧刷新，一套只绘制静态物体，低频刷新</p><p>低频刷新的CSM被称为ShadowCache</p><h3 id="TressFX">TressFX</h3><p>一种实时毛发渲染系统</p><h3 id="XGen">XGen</h3><p>一个maya的头发制作工具</p><p><a href="https://knowledge.autodesk.com/zh-hans/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/CHS/Maya-CharEffEnvBuild/files/GUID-C0470142-600B-4615-8110-EC779934DF5F-htm.html">maya文档</a></p><h3 id="Vulkan的基本概念">Vulkan的基本概念</h3><p>Vulkan对象主要分为三个部分，每个部分都有一个主对象</p><h4 id="Instance">Instance</h4><p>第一个Vulkan对象，用于连接应用程序和Vulkan运行时</p><h4 id="PhysicalDevice">PhysicalDevice</h4><p>显卡</p><ul><li>可以枚举图形队列</li><li>可以枚举内存堆和内存类型</li></ul><h4 id="Device">Device</h4><p>逻辑设备</p><ul><li>Queue：用于向GPU传递命令（类比SRP的上下文）</li><li>CommandPool：用于创建CommandBuffer</li><li>CommandBuffer：命令缓冲区，可以通过<code>vkQueueSubmit</code>提交到Queue中</li><li>Sampler：一组采样器状态，用于设置滤波模式、寻址模式等</li><li>Buffer&amp;Image：资源，渲染时不会直接使用</li><li>BufferView&amp;ImageView：对资源的解释（Buffer&amp;Image中，我们所需要的部分），渲染时直接使用（类比SRP的RT）</li><li>SurfaceKHR：控制屏幕窗口，与平台相关</li><li>SwapchainKHR：交换链，内含一组图片，用于实现显示交换<ul><li>立即渲染</li><li>双缓冲</li><li>多重缓冲</li></ul></li><li>Descriptor：描述符，用于访问资源（顶点信息，缓冲区，图像，采样器）<ul><li>DescriptorSet</li><li>DescriptorSetLayout</li><li>DescriptorPool</li></ul></li><li>FrameBuffer：ImageView的集合（RT、MRT）<ul><li>Attachment：附件（类比SRP的RenderTarget）<ul><li>Attachment初始化：Load Action</li><li>Attachment写回内存：Save Action</li></ul></li></ul></li><li>RenderPass：一次渲染流水线的执行，将信息输出到FBO的Attachments中<ul><li>SubPass：渲染的中间Pass，他们的目标不是FBO，而是一些临时的目标</li></ul></li><li>Pipeline：管线<ul><li>ComputePipeline</li><li>GraphicsPipeline<ul><li>PipelineLayout</li><li>ShaderModule：使用SPIR-V进行着色器编译</li><li>PipelineCache</li></ul></li></ul></li><li>Query：查询，用于得到某指令的执行情况</li><li>Fence&amp;Semaphore<ul><li>Fence：栅栏，用于CPU和GPU同步</li><li>Semaphore：信号量：用于GPU内部的同步（对客户端黑盒）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收</title>
      <link href="/2023/01/31/GC/"/>
      <url>/2023/01/31/GC/</url>
      
        <content type="html"><![CDATA[<h1>垃圾回收</h1><h3 id="前言">前言</h3><p>《垃圾回收的算法与实现》读书笔记，其中的代码大多为伪代码</p><h3 id="一：概念">一：概念</h3><p>GC，Garbage Collection，垃圾回收</p><p>功能</p><ul><li>找到内存中的垃圾</li><li>回收垃圾</li></ul><h4 id="为什么需要GC">为什么需要GC</h4><p>如果没有GC，程序员需要手动进行内存管理，开发麻烦，容易引发内存泄漏、野指针，而且因此导致的BUG很难被定位，修复麻烦</p><p>如果有GC，就可以避免这些问题</p><h4 id="GC的种类">GC的种类</h4><ul><li>保守式GC：不能识别指针和非指针时，一律视为非指针</li><li>准确式GC</li></ul><h4 id="GC的算法">GC的算法</h4><ul><li>标记清除法：标记活动对象，其他的都回收</li><li>引用计数法：回收引用值为0的对象</li><li>GC复制法：复制活动对象，其他的都回收</li></ul><h4 id="GC的选取">GC的选取</h4><ul><li>最大暂停时间短：游戏</li><li>整体处理时间短：音频编码</li></ul><h4 id="对象">对象</h4><p>这里的对象并不是OOP里的Object，而是<strong>被应用程序使用的数据的集合</strong>，对象由<strong>头</strong>和<strong>域</strong>构成</p><ul><li><p>头（header）：包含对象的大小和种类</p></li><li><p>域（field）：参考OOP里的成员</p></li></ul><p>对象分为活动对象和非活动对象，GC会保留活动对象，销毁非活动对象</p><h4 id="mutator">mutator</h4><p>可以简单理解为应用程序，在程序运行过程中，会分配/调用/改变对象（只能操作活动对象），伴随着mutator运行，会产生垃圾</p><h4 id="GC算法的评估标准">GC算法的评估标准</h4><ul><li>吞吐量（throughput）：单位时间的处理能力</li><li>最大暂停时间（在进行GC时，mutator会被暂停）</li><li>堆使用效率</li><li>访问局部性</li></ul><h3 id="二：标记清除法">二：标记清除法</h3><p><em>学这一节之前想想操作系统里文件系统</em></p><p>该算法分为两步</p><ol><li>标记阶段：将所有活动对象做上标记</li><li>清除阶段：将所有没被标记的对象回收</li></ol><h4 id="标记阶段">标记阶段</h4><ol><li>通过根，找到直接引用的对象，标记</li><li>递归标记所有能访问到的对象（常用深搜，因为内存使用量更少）</li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">void mark(obj)&#123;if(!obj.mark)         obj.mark &#x3D; true;for(child: obj.children)         mark(*child);&#125;</code></pre><h4 id="清除阶段">清除阶段</h4><p>遍历堆，回收所有没有被标记的对象，并将其放入空闲链表，以备分配</p><h4 id="分配策略">分配策略</h4><p>在创建新对象<code>obj</code>时，遍历空闲链表，寻找合适的块，这里使用First-fit算法（因为快）</p><ul><li>First-fit：找到第一个能放下<code>obj</code>的块</li><li>Best-fit：找到最小的能放下<code>obj</code>的块</li><li>Worst-fit：找到最大的能放下<code>obj</code>的块</li></ul><h4 id="合并策略">合并策略</h4><p>分配和回收会导致大量小的分块，于是需要合并，在这里直接遍历堆，将连续的空闲块合并</p><h4 id="评价">评价</h4><p>优点</p><ul><li>实现简单</li><li>与保守式GC兼容（因为对象不会被移动）</li></ul><p>缺点</p><ul><li>碎片化，导致空间浪费，访问性能降低</li><li>不支持<strong>写时复制</strong>（比如UNIX中的<code>fork()</code>）</li></ul><h4 id="优化方案">优化方案</h4><h5 id="分级空闲链表">分级空闲链表</h5><p>使用多个空闲链表，分别只连接不同大小的分块，分配时先找所对应的区间，可以提高性能</p><h5 id="BiBOP（Big-Bag-Of-Pages）">BiBOP（Big Bag Of Pages）</h5><p>将大小相近的对象整理成固定大小的块进行管理</p><ul><li>碎片化的原因之一是杂乱散布的大小各异的对象，如果将堆固定分割，就可以减缓碎片化</li></ul><h5 id="位图标记">位图标记</h5><p>不直接堆对象进行标记，而是记录对象的标志位，存储在一个表格中</p><ul><li>与写时复制技术兼容（因为不会修改对象本身，可以复用）</li><li>清除标志位更高效（只需要把表中要清除的对象的标志位改成一个特殊值）</li></ul><h5 id="延迟标记清除法">延迟标记清除法</h5><ul><li>分配时，先调用清除，如果能清出足够的空间来分配，则直接分配，否则进行普通的标记操作</li><li>清除时，同样是First-fit遍历堆，但遍历的起点是上次开始的地点的右侧</li><li>延迟的内核是不主动清除，而是等到要分配时再清除</li></ul><h3 id="三：引用计数法">三：引用计数法</h3><p><em>学这一节前，想想智能指针</em></p><p>引用计数法中，对象会记录自己被引用次数，主要分为两个阶段</p><ol><li>创建新对象：分配内存，将对象引用次数设为1</li><li>更新指针：先增后减计数器值，若引用次数为0则回收</li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;更新指针ptr，让其指向objvoid update_ptr(ptr, obj)&#123;inc_ref_cnt(obj);&#x2F;&#x2F;obj要被ptr引用了，所以obj计数值++    dec_ref_cnt(*ptr);&#x2F;&#x2F;ptr之前引用的东西不再被引用    *ptr &#x3D; obj;&#125;void dec_ref_cnt(obj)&#123;    obj.ref_cnt--;&#x2F;&#x2F;obj不再被引用，所以计数值--    if(obj.ref_cnt &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F;如果obj没人用了，obj就要被清除        for(child: obj.children)&#123;&#x2F;&#x2F;obj被清除了，那obj引用的对象，被引用次数要--            dec_ref_cnt(*child);        &#125;        reclaim(obj);&#x2F;&#x2F;执行回收    &#125;&#125;</code></pre><h4 id="评价-2">评价</h4><p>优点：</p><ul><li>对象变成垃圾时立刻被回收（延迟标记清除算法要等到分块用尽后才开始回收垃圾）</li><li>最大暂停时间短（只有在更新指针的时候才会打断mutator）</li><li>减少延根指针遍历所有子节点的次数（尤其在分布式系统中，效果显著）</li></ul><p>缺点</p><ul><li>频繁进行计数值的操作</li><li>计数器本身空间比较大（32位系统的计数器就要32位大小）</li><li><strong>循环引用无法回收</strong><ul><li>如果两个物体互相引用，并不和其他对象有联系，于是他们成为了一座“孤岛”，成为了事实意义上的垃圾，但是却无法被回收（因为只要被引用，就不算垃圾）</li></ul></li></ul><h4 id="优化方案-2">优化方案</h4><h5 id="延迟引用计数法">延迟引用计数法</h5><p>解决频繁操作</p><ul><li>使用ZCT表（Zero Count Table），记录所有执行<code>dec_ref_cnt</code>后计数值变成0的对象（也就是说计数值变成0，不会立刻被视为垃圾回收），当ZCT表满了以后，开始回收表中的对象</li><li>优点：延迟了根引用的计数（只有要回收时才会一起操作），降低了计数值的操作频率</li><li>缺点<ul><li>不再能即刻回收垃圾（你可以理解为以前有垃圾就仍，现在要先堆一波垃圾再扔）</li><li>最大暂停时间延长（<code>scan_zct()</code>要访问整个ZCT，这个过程muator是被中断的）</li></ul></li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">void dec_ref_cnt(obj)&#123;    obj.ref_cnt--;    if(obj.ref_cnt &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F;计数值变为0，可能会变成垃圾        if(is_full($zct))&#123;            scan_zct();&#x2F;&#x2F;如果zct表满了，就扫描zct，并回收        &#125;        push($zct, obj);&#x2F;&#x2F;将obj放入zct表    &#125;&#125;void scane_zct()&#123;    fot(r: $root)&#123;        (*r).ref_cnt++;&#x2F;&#x2F;根直接引用的对象的计数器++，直接引用计数时，根会极频繁改动    &#125;    for(obj: $zct)&#123;        if(obj.ref_cnt &#x3D;&#x3D; 0)&#123;            remove($zct, obj);            delete(obj);        &#125;    &#125;    fot(r: $root)&#123;        (*r).ref_cnt--;    &#125;&#125;</code></pre><h5 id="Sticky引用计数法">Sticky引用计数法</h5><p>解决空间浪费</p><p>32位电脑意味着可以有$2^{32}$个对象，这些对象可能都会引用<code>obj</code>，所以<code>obj</code>的计数位应当可以记录被引用$2^{32}$次，所以计数位要有32位</p><p>如果计数位太少，一些比较大的对象就无法正常表示（直接做饱和运算，汽车速度超过速度计的最大值会停在最大值处），一旦出现这种情况，我们可以</p><ul><li>什么都不做<ul><li>这会导致如果一个物体被引用的次数特别多，超出了目前表示的范围，即使他变成了垃圾也无法回收</li><li>但是，事实上绝大多数对象计数值一直在0和1间变化（生成后立刻回收），所以很少出现溢出</li><li>而且一个对象被频繁引用，说明他十分重要，十分重要的东西被回收的概率并不大</li><li>很多时候不需要保证内存永不泄露，只需要保证一段时间内不泄露就行，很多软件，用户不会一直开着的</li></ul></li><li>结合使用标记清除算法<ul><li>什么都不做，可能会导致内存耗尽，如果耗尽，那就用标记清除法清一次（相当于垃圾太多了，管不来了，就干脆来一次大扫除）</li></ul></li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;标记void mark()&#123;    for(r: $roots)&#123;        push(*r, $stack);&#x2F;&#x2F;将所有根直接引用对象入栈    &#125;    while(!$stack.empty())&#123;        obj &#x3D; pop($stack);        obj.ref_cnt++;        if(obj.ref_cnt &#x3D;&#x3D; 1)&#123;&#x2F;&#x2F;这说明obj只进栈一次            for(child: obj.children)&#123;                push(*child, $stack);            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F;清除void sweep()&#123;    index &#x3D; $heap_top;    while(index &lt; $heap_end)&#123;&#x2F;&#x2F;遍历整个堆        if(index.ref_cnt &#x3D;&#x3D; 0)&#123;            reclaim(index);&#x2F;&#x2F;回收计数值为0的对象        &#125;        index +&#x3D; index.size;    &#125;&#125;</code></pre><h5 id="一位引用计数法">一位引用计数法</h5><p>是Sticky的极端，计数位只有一位（两个tag，一个MULTIPLE，一个UNIQUE），而且将计数位放在指针上，而非放在对象上</p><p><img src="/images/%E4%B8%80%E4%BD%8D%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.png" class="lazyload" data-srcset="/images/%E4%B8%80%E4%BD%8D%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="一位引用计数"></p><pre class="language-c++" data-language="c++"><code class="language-c++">void copy_ptr(dest_ptr, src_ptr)&#123;    delete_ptr(dest_ptr);    *dest_ptr &#x3D; *src_ptr;    set_tag(dest_ptr, MULTIPLE);    if(src_ptr.tag &#x3D;&#x3D; UNIQUE)&#123;        set_tag(src_ptr, MULTIPLE);    &#125;&#125;void delete_ptr(ptr)&#123;    if(ptr.tag &#x3D;&#x3D; UNIQUE)        reclaim(*ptr);&#x2F;&#x2F;如果对象以前只被引用一次，那么这次就要被回收&#125;</code></pre><p>优点</p><ul><li>cache命中率高</li></ul><p>缺点</p><ul><li>同Sticky，而且更严重</li></ul><h5 id="部分标记清除法">部分标记清除法</h5><p>解决循环引用</p><p>只对可能会有循环引用的对象使用标记清除法，其他对象使用引用计数法</p><p>每个对象会有两个状态位（于是就有四个状态），分别为</p><ul><li>BLACK：绝对不是垃圾的对象（初始值）</li><li>WHILE：绝对是垃圾的对象</li><li>GRAY：搜索完毕的对象</li><li>HATCH：可能是循环垃圾的对象</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">void dec_ref_cnt(obj)&#123;    obj.ref_cnt--;    if(obj.ref_cnt &#x3D;&#x3D; 0)&#123;        delete(obj);    &#125;    else if(obj.color !&#x3D; HATCH)&#123;        obj.color &#x3D; HATCH;        queue.push(obj);    &#125;&#125;</code></pre><p>对放入队列的对象进行标记清除算法</p><pre class="language-c++" data-language="c++"><code class="language-c++">Object new_obj(size)&#123;    obj &#x3D; pickup_chunk(size);&#x2F;&#x2F;分配内存    if(obj !&#x3D; null)&#123;&#x2F;&#x2F;如果分配成功        obj.color &#x3D; BLACK;        obj.ref_cnt &#x3D; 1;        return obj;    &#125;    else if(!queue.empty())&#123;&#x2F;&#x2F;说明现在空间不足，要回收垃圾，先看是否存在HATCH物体        scan_hatch_queue();        return new_obj(size);&#x2F;&#x2F;回收queue内后重新尝试分配    &#125;    else&#123;        allocation_fall();    &#125;&#125;void scan_hatch_queue()&#123;&#x2F;&#x2F;循环扫描队列，直至队列为空    obj &#x3D; queue.pop();    if(obj.color &#x3D;&#x3D; HATCH)&#123;        paint_gray(obj);&#x2F;&#x2F;把obj和其孩子变为GRAY，孩子们引用值--        scan_gray(obj);&#x2F;&#x2F;引用值&gt;0涂黑，等于0涂白        collect_while(obj);    &#125;    else if(!queue.empty())&#123;        scane_hatch_queue();    &#125;&#125;void paint_gray(obj)&#123;    if(obj.color &#x3D;&#x3D; (BLACK | HATCH))&#123;        obj.color &#x3D; GRAY;        for(child: obj.children)&#123;            (*child).ref_cnt--;            paint_gray(*child);        &#125;    &#125;&#125;void scan_gray(obj)&#123;    if(obj.color &#x3D;&#x3D; GRAY)&#123;        if(obj.ref_cnt &gt; 0)&#123;            paint_black(obj);        &#125;        else&#123;            obj.color &#x3D; WHITE;            for(child: children(obj))&#123;                scan_gray(*child);            &#125;        &#125;    &#125;&#125;void paint_black(obj)&#123;     obj.color &#x3D; BLACK; for(child : children(obj))&#123;(*child).ref_cnt++if((*child).color !&#x3D; BLACK)&#123;paint_black(*child)                    &#125;               &#125;&#125;void collect_while()&#123;    if(obj.color &#x3D;&#x3D; WHILE)&#123;        obj.color &#x3D; BLACK;        for(child: obj.children)&#123;            collect_while(*child);        &#125;        reclaim(obj);    &#125;&#125;</code></pre><p>优点</p><ul><li>可以回收循环引用</li></ul><p>缺点</p><ul><li>一个对象要被查找三次，导致最大暂停时间+++</li></ul><h3 id="四：GC复制法">四：GC复制法</h3><p><em>想一下渲染中的双缓冲</em></p><p>先把整个空间分为等大的两部分，From和To，我们用From空间分配活动对象</p><p>GC时，把所有活动对象（递归）复制到其他空间（To空间），然后把原空间（From空间）所有对象回收，然后把空间互换</p><h4 id="评价-3">评价</h4><p>优点</p><ul><li>吞吐量大</li><li>分配速度快（Frist-fit）</li><li>不会发生碎片化（每次回收时，都会把所有对象重新排在From空间的开头，这个操作被称为<strong>压缩</strong>）</li><li>兼容缓存</li></ul><p>缺点</p><ul><li>堆效率低（因为二等分后，只能利用其中一半）</li><li>不兼容保守式GC</li><li>复制对象时要递归复制，会消耗栈，可能导致栈溢出</li></ul><h4 id="优化方案-3">优化方案</h4><h5 id="Cheney-GC复制法">Cheney GC复制法</h5><p>从递归复制改为迭代复制（基于队列的广度优先搜索）</p><p>下图搜索顺序：A BC DEFG HIJKLMNO</p><p>![Cheney GC](/images/Cheney GC.png)</p><p>优点</p><ul><li>从递归变成迭代，降低栈压力</li></ul><p>缺点</p><ul><li>不利于缓存（在上图，我们假设每个页最多存放三个块，我们发现有引用关系的对象很可能不在同一个块中）</li></ul><h5 id="近似深度优先搜索方法">近似深度优先搜索方法</h5><p>在页间做深度优先搜索，在页内做广度优先搜索</p><p>下图搜索顺序：ABC DHI EJK FLM GNO</p><p><img src="/images/%E8%BF%91%E4%BC%BC%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88.png" class="lazyload" data-srcset="/images/%E8%BF%91%E4%BC%BC%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="近似深度优先"></p><h5 id="多空间复制法">多空间复制法</h5><p>把空间分成十份，一个From，一个To，八个标记清除法</p><h3 id="五：标记压缩法">五：标记压缩法</h3><p>结合了标记清除法的标记+GC复制法的压缩</p><h4 id="Lisp2算法">Lisp2算法</h4><p><em>类比原地删除数组中某个元素</em></p><p>标记方法和标记清除法一样，标记后遍历堆，将所有活动对象压缩到左侧</p><p><img src="/images/Lisp2%E6%A0%87%E8%AE%B0.png" class="lazyload" data-srcset="/images/Lisp2%E6%A0%87%E8%AE%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Lisp2标记"></p><p><img src="/images/Lisp2%E5%8E%8B%E7%BC%A9.png" class="lazyload" data-srcset="/images/Lisp2%E5%8E%8B%E7%BC%A9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Lisp2压缩"></p><p><img src="/images/Lisp2%E7%BB%93%E6%9D%9F.png" class="lazyload" data-srcset="/images/Lisp2%E7%BB%93%E6%9D%9F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Lisp2结束"></p><p>优点</p><ul><li>比GC复制法堆效率高，比标记压缩法碎片少</li></ul><p>缺点</p><ul><li>三次遍历堆，效率过低</li></ul><h4 id="Two-Finger算法">Two-Finger算法</h4><p>这个算法优缺点很明显，所以先说优缺点，再谈实现</p><p>优点</p><ul><li>只需要两次遍历堆</li><li>不需要额外的forward指针（Lisp2的对号）</li></ul><p>缺点</p><ul><li>对象大小必须一致（可以与BiBOP结合使用）</li><li>压缩时破坏排序（一般有引用关系的对象会放在一起），于是不适合缓存</li></ul><p>在Lisp2算法中，可以说几乎每一个活动对象都需要移动，一般来说越靠近左边，移动的概率、距离越小，而越后面则越大（可以类比幽灵堵车）</p><p>我们能不能固定前面的对象，只移动后面的对象，从而实现压缩呢？（如果后面的对象和前面的对象大小一致，完全可以）</p><p><img src="/images/Two-Finger.png" class="lazyload" data-srcset="/images/Two-Finger.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Two-Finger"></p><h4 id="表格算法">表格算法</h4><p>算法分为三部：移动对象群，构建间隙表格，更新指针</p><ul><li>移动对象群（Lisp2一次移动一个对象，这个一次移动所有相邻对象）</li></ul><p><img src="/images/%E8%A1%A8%E6%A0%BC%E7%AE%97%E6%B3%95%E7%A7%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1%E7%BE%A4.png" class="lazyload" data-srcset="/images/%E8%A1%A8%E6%A0%BC%E7%AE%97%E6%B3%95%E7%A7%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1%E7%BE%A4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="表格算法移动对象群"></p><ul><li>构建间隙表格（设一个小格子尺寸为50）<ul><li>a到b：live在B开头，scan在D开头，于是将B的初始位置和B向左移动的距离$(100,100)$写到D处</li><li>b到c：<ul><li>先把间隙表格向后移动，移到FG之后，于是H处写入$(100,100)$</li><li>FG的初始位置和向左移动的距离为$(550,300)$，写入H之后（后是左边的G）</li></ul></li></ul></li></ul><p><img src="/images/%E6%9E%84%E5%BB%BA%E9%97%B4%E9%9A%99%E8%A1%A8%E6%A0%BC.png" class="lazyload" data-srcset="/images/%E6%9E%84%E5%BB%BA%E9%97%B4%E9%9A%99%E8%A1%A8%E6%A0%BC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="构建间隙表格"></p><ul><li>更新指针</li></ul><h4 id="ImmixGC算法">ImmixGC算法</h4><h3 id="六：保守式GC">六：保守式GC</h3><p>把疑似指针的一律视为指针</p><h4 id="不明确的根">不明确的根</h4><p>常见的根有</p><ul><li>寄存器</li><li>调用栈</li><li>全局变量空间</li></ul><p>在c++等语言里，<code>int</code>这种内置变量（非指针）和<code>void*</code>指针都存放在栈里，GC无法区分两者的区别，保守式GC就干脆不区分两者</p><p>存储着不确定对象的根，称为不明确的根，而基于这些根的GC算法，被称为保守式GC（ambiguous GC）</p><h4 id="检查内容">检查内容</h4><ul><li>是否<strong>位对齐</strong>（32位CPU，指针是4的倍数，64位CPU，指针是8的倍数）<ul><li>不对齐的一定是非指针</li></ul></li><li>是否指向堆内<ul><li>对象放在堆中，所以指针一定指向堆</li></ul></li><li>是否指向对象开头</li></ul><p>我们发现，有的时候我们会遇到一些格式与指针一致的非指针，我们称之为<strong>貌似指针的非指针（false pointer）</strong></p><p>在标记清除算法中，遇到这种貌似指针的非指针，会胡乱找到一个对象，我们不知道这个对象是活动对象还是非活动对象，所以<strong>一律视为活动对象</strong>，进行标记</p><p>注意：保守GC是只有当判断不出来到底是不是指针时才将其视为指针，而不是把所有对象都视为指针（迫不得已，凑合凑合用）</p><h4 id="评价-4">评价</h4><p>优点</p><ul><li>开发容易，程序员不需要意识到GC的存在</li></ul><p>缺点</p><ul><li>识别指针和非指针需要付出代价（检查内容）</li><li>将false pointer指向的错误对象视为活动对象，这些东西不会被用到，却进栈了</li><li>支持保守GC的算法不多</li></ul><h4 id="准确式GC">准确式GC</h4><p>正确的根（exact roots）可以精确地识别指针和非指针</p><p>基于正确的根的GC被称为<strong>准确式GC</strong></p><h5 id="构建正确的根的方法：打标签">构建正确的根的方法：打标签</h5><ul><li>32位CPU指针的值是4的倍数，那么其<strong>低2位</strong>一定是0</li><li>我们可以将所有非指针左移1位，然后将其<strong>低1位</strong>置为1</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;打标签int addTag(int a)&#123;    a &#x3D; a &lt;&lt; 1;&#x2F;&#x2F;小心溢出，如果会溢出，就用一个更大的数据结构a &#x3D; a|1;    return a;&#125;&#x2F;&#x2F;去标签（在使用时需要恢复成正常数值），而且使用完后还有再次打标签int getValue(int a)&#123;    a  &#x3D; a &gt;&gt; 1;    return a;&#125;</code></pre><p>除了打标签，还可以专门构建一个只存放指针的根，比如一些使用虚拟机（VM）的语言</p><h5 id="评价-5">评价</h5><p>优点</p><ul><li>不需要判断是否为指针，没有判断带来的性能代价</li><li>堆中只会存在指针，可以适用于一些移动对象的GC算法</li></ul><p>缺点</p><ul><li>构建准确的根需要性能成本</li><li>语言使用时更麻烦</li></ul><h4 id="间接引用">间接引用</h4><p>为什么保守式GC不能移动对象？因为一个false pointer可能是一个非指针，移动会导致问题</p><h5 id="句柄">句柄</h5><p>如图，即使我们移动了堆中的对象，也却不会改变根内的内容</p><img src="/images/句柄.jpeg" class="lazyload" data-srcset="/images/句柄.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="句柄" style="zoom:50%;" /><p>优点：</p><ul><li>可以使用复制算法</li></ul><p>缺点：</p><ul><li>访问一个对象需要访问两次内存</li></ul><h4 id="MostlyCopyingGC">MostlyCopyingGC</h4><p>保守式GC复制算法</p><h4 id="黑名单">黑名单</h4><p>有的false pointer即使是非指针，错把他当指针用也可以找到一个对象（尽管这个过程是未定义的），如果这个非指针可以做到这个事，拿我们就把这个非指针指向的地址存放到<strong>黑名单</strong>中</p><p>黑名单中存放的是地址，如果在这些地址中分配空间，可能会导致未定义事件</p><p>所以在这些地址上分配对象时要十分小心，比如只能分配小对象、只能分配没有子对象的小对象，因为这些对象比较小，即使变成垃圾，被错误识别了，危害也比较小</p><h3 id="七：分代垃圾回收">七：分代垃圾回收</h3><p>引入了年龄这一概念，优先回收那些容易成为垃圾的对象</p><h4 id="年龄">年龄</h4><p>我们在引用计数法中提到过，绝大多数的对象生成后立刻会被回收，而被引用次数多多对象很难变成垃圾</p><p>于是我们引入年龄这一概念，初始为0，每经历一次GC算法，如果没有被回收，则年龄+1</p><p>我们发现年龄越大，说明对象越重要，越不容易被回收，于是年龄越大，参与回收的频率就越低</p><h4 id="评价-6">评价</h4><p>优点</p><ul><li>提高吞吐量</li></ul><p>缺点</p><ul><li>很多对象出生立刻回收只是一个经验，不适合所有程序，一旦某程序对象比较“长寿”，会起反作用</li></ul><h3 id="八：增量式垃圾回收">八：增量式垃圾回收</h3><p><em>想一想单核CPU并行的本质，就是将线程切分，来回切换</em></p><p>通过逐步推进垃圾回收来控制最大暂停时间，不一次执行完GC，而是执行一会mutator，执行一会GC</p><img src="/images/增量式GC.jpeg" class="lazyload" data-srcset="/images/增量式GC.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="增量式GC" style="zoom:50%;" /><ul><li>三色标记法</li></ul><h4 id="评价-7">评价</h4><p>优点</p><ul><li>降低最大暂停时间</li></ul><p>缺点</p><ul><li>降低了吞吐量</li></ul><h3 id="九：RC-Immix算法">九：RC Immix算法</h3><p><em>这是一个2013年的算法，听懂掌声</em></p><p>将合并型引用计数法和Immix组合到一起，改善了引用计数法的吞吐量</p>]]></content>
      
      
      <categories>
          
          <category> engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微积分</title>
      <link href="/2023/01/31/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
      <url>/2023/01/31/%E5%BE%AE%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1>微积分</h1><h2 id="无穷级数">无穷级数</h2><p>从<strong>有限项之和</strong>拓展到<strong>无限项之和</strong></p><p>一根绳子，日取其半，万世不竭。但无论截取多少次，最后总长应该还是这跟绳子，即<br>$$<br>1=\frac{1}{2}+\frac{1}{2^2}+\frac{1}{2^3}+…+\frac{1}{2^n}+…<br>$$<br>另一个例子<br>$$<br>1+(-1)+1+(-1)+1+(-1)…<br>$$<br>等于多少呢？</p><p>到底是<br>$$<br>1+[(-1)+1]+[(-1)+1]…=1+0+0…<br>$$<br>还是<br>$$<br>(1-1)+(1-1)+…(1-1)+…=0+0+0…<br>$$<br>这里出现了矛盾，为此我们建立了无穷级数的概念</p><h3 id="常数项级数">常数项级数</h3><h4 id="常数项无穷级数">常数项无穷级数</h4><p>给定一个数列${u_n}$，由它构成的表达式<br>$$<br>u_1+u_2+…+u_n+…<br>$$<br>被称为<strong>常数项无穷级数</strong>，简称级数，其中$u_n$被称为该级数的通项</p><p>该级数的前n项和称为<strong>部分和</strong>，记为$s_n$</p><p>当n依次取1,2,3…时，部分和构成一个新数列${s_n}$，被称为<strong>部分和数列</strong></p><p>当n无限增大时，若部分和存在极限，即<br>$$<br>\lim_{n \rightarrow \infty}s_n=s<br>$$<br>则称该级数<strong>收敛</strong>，并称极限$s$为该级数的<strong>和</strong></p><p>若不存在极限，则称该级数<strong>发散</strong></p><h4 id="讨论级数收敛-发散">讨论级数收敛/发散</h4><ul><li>部分和公式好求，可以求公式，判断其有无极限</li><li>不好求，可以反证<ul><li>先假设收敛，然后化简公式，最后得出形如$s+x&gt;s$的结论，证否</li></ul></li></ul><p>$$<br>\lim_{n \rightarrow \infty}s_n=\lim_{n \rightarrow \infty}s_{2n}=s<br>$$</p><h4 id="余项">余项</h4><p>去掉级数A前n项，得到一级数<br>$$<br>u_{n+1}+u_{n+2}+…+u_{n+k}+…=\sum^{\infty}_{k=n+1}u_k<br>$$<br>称该级数为级数A的<strong>余项</strong></p><p>若级数A收敛，则余项的前m项之和$s_m’$满足<br>$$<br>s_m’=s-s_n<br>$$<br>一般，我们将n项后余项和记为$r_n$<br>$$<br>s=s_n+r_n<br>$$</p><h4 id="性质">性质</h4><ul><li><p>级数中去掉/加上有限个项，不改变级数的收敛性</p></li><li><p>若一级数收敛，则其通项<strong>乘</strong>以一个常数$k$，仍然收敛，且和为$ks$</p></li><li><p>若两级数收敛，则两通项<strong>相加或相减</strong>，对应的级数仍然收敛，且和为$s+\sigma$</p></li><li><p>若一级数收敛，在其中加任意个括号，仍然收敛</p></li><li><p>级数收敛的<strong>必要条件</strong>是通项在无穷大处有极限，且为0</p></li></ul><h4 id="柯西收敛准则">柯西收敛准则</h4><p>级数收敛的<strong>充要条件</strong></p><h3 id="正项级数">正项级数</h3><p>若级数中各项非负，则称该级数为<strong>正项级数</strong></p><ul><li>正项级数的<strong>部分和</strong>必然是递增的</li></ul><p>正项级数收敛的充要条件：其<strong>部分和数列</strong>有上界</p><h4 id="比较审敛法">比较审敛法</h4><p>对于两个正项级数A，B，其通项分别为$u_n,v_n$</p><ul><li>自某项起，$u_n\ge v_n$，若B发散，则A发散（大于发散则发散）</li><li>自某项起，$u_n\le v_n$，若B收敛，则A收敛（小于收敛则收敛）</li></ul><h5 id="比较审敛法的极限形式">比较审敛法的极限形式</h5><p>对于两个正项级数A，B，其通项分别为$u_n,v_n$，若<br>$$<br>\lim_{n \rightarrow \infty}\frac{u_n}{v_n}=\lambda<br>$$<br>有意义（极限存在或者为无穷大）</p><ul><li>$0&lt;\lambda&lt;\infty$：两级数收敛性相同</li><li>$lambda=0$：若B收敛，则A收敛（小于收敛则收敛）</li><li>$\lambda=\infty$：若B发散，则A发散（大于发散则发散）</li></ul><h4 id="比值审敛法">比值审敛法</h4><p>也称达朗贝尔判别法</p><p>对于一正向级数A，其通项为$u_n$，若<br>$$<br>\lim_{n \rightarrow \infty}\frac{u_{n+1}}{u_n}=\rho<br>$$<br>有意义</p><ul><li>$\rho &lt;1$：A收敛</li><li>$\rho &gt;1$：A发散</li><li>$\rho =1$：A可能收敛也可能发散</li></ul><h4 id="根值审敛法">根值审敛法</h4><p>也称柯西判别法</p><p>对于一正向级数A，其通项为$u_n$，若<br>$$<br>\lim_{n \rightarrow \infty}\sqrt[n]{u_n}=\rho<br>$$<br>有意义</p><ul><li>$\rho &lt;1$：A收敛</li><li>$\rho &gt;1$：A发散</li><li>$\rho =1$：A可能收敛也可能发散</li></ul><h4 id="积分审敛法">积分审敛法</h4><p>对于一正向级数A，其通项为$u_n$，若存在$[1, \infty)$上单调递减的非负连续函数$f(x)$，使得$u_n=f(n)$，则级数A与反常积分$\int^{\infty}_1 f(x)\mathrm{d}x$收敛性相同</p><ul><li>反常积分就是积分域包含无穷上/下限，或者被积函数有瑕点的积分<ul><li>瑕点：函数值区域无穷的点</li><li>奇点：函数值未定的点（比如间断点、无定义点）</li></ul></li></ul><h3 id="任意项级数">任意项级数</h3><h4 id="交错级数">交错级数</h4><p>形如<br>$$<br>u_1-u_2+u_3-u_4…(-1)^{n-1}u_n+…<br>$$<br>或者<br>$$<br>-u_1+u_2-u_3+u_4…(-1)^{n}u_n+…<br>$$<br>的级数，称为<strong>交错级数</strong></p><ul><li>其中$u_n &gt; 0$</li></ul><p><strong>交错级数审敛法</strong></p><p>若$u_n \ge u_{n+1}$，且$\lim_{n \rightarrow \infty}u_n=0$，则级数$\sum^{\infty}<em>{n=1}(-1)^{n-1}u_n$收敛，且其和$s \le u_1$，其余项$|r_n|\le u</em>{n+1}$</p><h4 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h4><p>对于一级数$A=\sum^{\infty}<em>{n=1}u_n$，其各项取绝对值，得到新正项级数$B=\sum^{\infty}</em>{n=1}|u_n|$</p><p>定理：若B收敛，则A收敛（所以这就是我们为什么要研究正项级数）</p><ul><li>若B收敛，A必收敛，此时称A为<strong>绝对收敛</strong></li><li>若B发散，而A却收敛，此时称A为<strong>条件收敛</strong></li></ul><h5 id="性质-2">性质</h5><ul><li>绝对级数的更序级数仍为绝对级数<ul><li>更序级数：对某级数的项进行重排后得到的新级数</li></ul></li><li>两个绝对级数的柯西乘积仍然绝对收敛，且其和为$s\times \sigma$<ul><li>柯西乘积：参考向量相乘，$(a_1, a_2)(b_1,b_2)=(a_1b_1,a_2b_2)$</li></ul></li></ul><h3 id="函数项级数">函数项级数</h3><p>前面讨论的常数项级数用于表示无穷多个<strong>数</strong>的和，当其收敛时，其和为<strong>一个常数</strong></p><p>而函数项级数用于表示无穷多个<strong>函数</strong>的和</p><p>设定义在集合$D\subseteq \mathbf{R}$的一系列函数（称为函数列）<br>$$<br>u_1(x),u_2(x),u_3(x)…u_n(x)…<br>$$<br>称<br>$$<br>\sum^{\infty}_{n=1}u_n(x)<br>$$<br>为<strong>函数项级数</strong>，$u_n(x)$为通项，前n项和称为部分和</p><h4 id="极限函数">极限函数</h4><ul><li><p>若对于某个点$x_0 \in D$，${ u_n(x_0)}$收敛，则称点$x_0$为该函数列的一个<strong>收敛点</strong></p></li><li><p>所有收敛点构成的集合称为<strong>收敛域</strong></p></li><li><p>若${ u_n(x)}$处处收敛（或逐点收敛），那么就形成了一个定义在D上的函数$f(x)$，D上每一个x都有该函数列一个极限值与之相对应，并称函数$f(x)$为该函数列的<strong>极限函数</strong></p></li></ul><p>$$<br>f(x)=\lim_{n \rightarrow \infty}f_n(x)<br>$$</p><h4 id="极限函数与函数项级数">极限函数与函数项级数</h4><ul><li><p>若点$x_0 \in D$是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的<strong>收敛点</strong></p></li><li><p>若点$x_0 \in D$不是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的<strong>发散点</strong></p></li><li><p>收敛点的集合称为该级数的<strong>收敛域</strong></p></li><li><p>若级数在D上处处收敛，于是形成了一个定义在D上的<strong>和函数</strong>$s(x)$</p></li></ul><p>$$<br>s(x)=\lim_{n \rightarrow \infty}s_n(x)<br>$$</p><h4 id="收敛性">收敛性</h4><p>略</p><h3 id="幂级数">幂级数</h3><p>幂级数是一种特殊的，也是最常用的函数项级数</p><p>我们把形如<br>$$<br>a_0(x-x_0)^0+a_1(x-x_0)^1+a_2(x-x_0)^2+…a_n(x-x_0)^n+…<br>$$<br>的函数项级数称为$x-x_0$的<strong>幂级数</strong></p><p>其中$x_0$是一个常数，$a_0,a_1,…a_n,…$是<strong>幂级数的系数</strong></p><ul><li>对任意幂级数总有，当$x=0$时，幂级数收敛，即0是收敛点</li></ul><h4 id="阿贝尔定理">阿贝尔定理</h4><ul><li>若$x=x_0 \ne 0$且幂级数收敛，则当$|x|&lt;|x_0|$时，幂级数绝对收敛</li><li>若$x=x_0 \ne 0$且幂级数发撒，则当$|x|&gt;|x_0|$时，幂级数发散</li></ul><h4 id="收敛半径">收敛半径</h4><p>幂级数$\sum^{\infty}_{n=1}a_nx^n$的收敛域K是以原点为中心的一个区间，在区间内绝对收敛，在区间外发散，区间界可能收敛也可能发散，于是我们称这个收敛域的半径R为<strong>收敛半径</strong></p><p>对于某个幂级数，若$a_n \ne 0$，且<br>$$<br>\lim_{n \rightarrow \infty}|\frac{a_{n+1}}{a_n}|=\rho<br>$$</p><ul><li>若$0&lt;\rho &lt;\infty$，收敛半径$R=\frac{1}{\rho}$</li><li>若$\rho =0$，收敛半径$R=\infty$</li><li>若$\rho =\infty$，收敛半径$R=0$</li></ul><h4 id="运算">运算</h4><p>对于两个幂级数A、B，他们的收敛半径分别为$R_1$、$R_2$</p><p>$R=\min(R_1, R_2)$，则在$(-R, R)$上</p><ul><li>幂级数乘以一个常数仍然收敛</li><li>A和B的线性组合仍然收敛</li><li>A和B的乘积仍然收敛</li></ul><h4 id="和函数的性质">和函数的性质</h4><p>在收敛区间内，和函数$s(x)$满足</p><ul><li>连续性</li><li>可微性</li></ul><p>$$<br>s’(x)=\sum^{\infty}_{n=1}na_nx^{n-1}<br>$$</p><ul><li>可积性</li></ul><p>$$<br>\int^x_0s(t)\mathrm{d}t=\sum^{\infty}_{n=0}\frac{a_n}{n+1}x^{n+1}<br>$$</p><h3 id="函数展开为幂级数">函数展开为幂级数</h3><p>在前面几节，我们讨论了函数项级数（尤其是幂级数）在收敛区间内可以得到一个和函数</p><p>那么，能不能给定一个（和）函数，将其展开为幂级数呢？</p><p>幂级数可以视为多项式的推广，那么我们能不能用多项式来逼近（和）函数呢？</p><h4 id="泰勒级数">泰勒级数</h4><p>若$f(x)$在区间$(x_0-R, x_0+R)$能展开成幂级数，$f(x)$在$x=x_0$处有任意阶导数，那么幂级数有且仅有一个展开形式，且幂级数的系数为<br>$$<br>a_n=\frac{1}{n!}f^{(n)}(x_0)<br>$$</p><ul><li>n取0，1，2…</li></ul><p>我们称这个幂级数为函数$f(x)$在$x_0$处的<strong>泰勒级数</strong>，记作<br>$$<br>f(x)\sim f(x_0)+\frac{f’(x_0)}{1!}(x-x_0)+\frac{f’'(x_0)}{2!}(x-x_0)^2+…+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+…<br>$$</p><h4 id="展开条件">展开条件</h4><p>若$f(x)$在区间$(x_0-R, x_0+R)$处有任意阶导数，那么$f(x)$在该区间内能展开称泰勒级数的<strong>充要条件</strong>为<br>$$<br>\lim _{n \rightarrow \infty}R_n(x)=0<br>$$</p><ul><li>$R_n(x)$：n以后的余项</li></ul><p>推论</p><p>若存在一个常数$M&gt;0$，使得任意x属于区间$(x_0-R, x_0+R)$，都有当n趋近于无穷时，余项的绝对值小于M，则函数可以在该区间展开成泰勒级数</p><h4 id="麦克劳林展开式">麦克劳林展开式</h4><p>泰勒公式的特例，$x_0=0$<br>$$<br>f(x)=f(0)+\frac{f’(0)}{1!}x+\frac{f’'(0)}{2!}x^2+…++\frac{f^{(n)}(0)}{n!}x^n+…<br>$$</p><h4 id="经典展开">经典展开</h4><p>$$<br>e^x=1+\frac{x}{1!}+\frac{x^2}{2!}+…+\frac{x^n}{n!}+…<br>$$</p><p>$$<br>\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-…+(-1)^{n-1}\frac{x^{2n-1}}{(2n-1)!}+…<br>$$</p><h3 id="傅里叶级数">傅里叶级数</h3><p>使用三角函数来拟合一个已知函数</p><h4 id="三角级数">三角级数</h4><p>一般来说，形如<br>$$<br>\frac{a_0}{2}+\sum^{\infty}_{n=1}(a_n\cos nx+b_n \sin nx)<br>$$<br>的级数被称为三角级数</p><h4 id="正交性">正交性</h4><p>函数系<br>$$<br>{1,\cos x, \sin x, \cos 2x, \sin 2x, …,\cos nx, \sin nx,…}<br>$$<br>被称为<strong>基本三角函数系</strong></p><p><strong>正交性</strong>：该函数系任意两个不同的函数的乘积，在区间$[-\pi,\pi]$上的积分等于0</p><h4 id="三角级数的系数">三角级数的系数</h4><p>$$<br>a_n=\frac{1}{\pi}\int^{\pi}_{-\pi}f(x)\cos nx \ \mathrm{d}x<br>$$</p><p>$$<br>b_n=\frac{1}{\pi}\int^{\pi}_{-\pi}f(x)\sin nx \ \mathrm{d}x<br>$$</p><p>这两个式子被称为欧拉-傅里叶公式，由这个公式确定的系数被称为<strong>傅里叶系数</strong></p><p>对任意在区间$[-\pi,\pi]$上可积函数$f(x)$都可以求出其傅里叶级数，但这个级数不一定收敛，即使收敛也不一定收敛于$f(x)$</p><p>于是我们需要知道什么时候$f(x)$可以被展开成收敛在$f(x)$的傅里叶级数</p><h4 id="收敛定理（狄里希利充分条件）">收敛定理（狄里希利充分条件）</h4><p>对于一个周期为$2\pi$的周期函数，如果它满足<strong>狄里希利条件</strong>：</p><ul><li><p>在一个周期内连续，或者只有有限个第一类间断点</p><ul><li>第一类间断点：左右极限都存在，但该点函数值或该点无定义</li></ul></li><li><p>在一个周期内之多有有限个严格极值点</p></li></ul><p>则$f(x)$的傅里叶级数收敛，且</p><ul><li>当$x$是$f(x)$的连续点时，级数收敛于$f(x)$</li><li>当$x$是$f(x)$的间断点时，级数收敛于$\frac{1}{2}[f(x-0)+f(x+0)]$</li></ul><h4 id="其他概念">其他概念</h4><ul><li>周期延拓</li><li>正弦级数（奇函数）</li><li>余弦级数（偶函数）</li><li>奇延拓</li><li>偶延拓</li></ul><h4 id="复数表示">复数表示</h4><p>欧拉公式<br>$$<br>\sin z=\frac{e^{iz}-e^{-iz}}{2i}<br>$$</p><p>$$<br>\cos z=\frac{e^{iz}+e^{-iz}}{2}<br>$$</p><p>记<br>$$<br>\frac{a_0}{2}=c_0<br>$$</p><p>$$<br>\frac{a_n-ib_n}{2}=c_n<br>$$</p><p>$$<br>\frac{a_n+ib_n}{2}=c_{-n}<br>$$</p><p>则傅里叶级数简化为<br>$$<br>\sum^{\infty}_{n=-\infty}c_ne^{i\frac{n\pi x}{l}}<br>$$</p><p>$$<br>c_n=\frac{1}{2l}\int^l_{-l}f(x)e^{-i\frac{n\pi x}{l}}\mathrm{d}x<br>$$</p><h5 id="例题">例题</h5><p>已知周期为2的电压信号函数<br>$$<br>u(t)=e^{-t}，t\in [0,2]<br>$$<br>将其展开为复数形式的傅里叶级数</p><p><img src="/images/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2.png" class="lazyload" data-srcset="/images/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="傅里叶变换"></p><h2 id="多元函数">多元函数</h2><h3 id="方向导数">方向导数</h3><p>设点$P_0(x_0,y_0)\in \mathbf{R}^2$，$l$是平面上的一非零向量，其单位向量为$e_i=\cos \alpha \mathbf {i}+\cos \beta \mathbf {j}$，函数$z=f(x,y)$在点$P_0$的某邻域内有定义，$P_0$为直线L上的一个定点（直线L平行于向量$l$），若极限<br>$$<br>\lim_{t\rightarrow 0}\frac{f(x_0+t\cos \alpha,y_0+t\cos \beta)-f(x_0,y_0)}{t}<br>$$<br>存在，则称此极限为函数$z=f(x,y)$在直线L上点$P_0$处，延方向$l$的<strong>方向导数</strong></p><h4 id="梯度">梯度</h4><p>方向导数刻画了函数在点$P_0$处沿着方向$l$的变化快慢程度，我们希望知道在该点，哪一个方向变化最快，于是引入了梯度</p><p>设函数$z=f(x,y)$在点$P_0(x_0,y_0)$处可偏导，则称向量<br>$$<br>f_x(x_0,y_0)\mathbf{i}+f_y(x_0, y_0)\mathbf{j}<br>$$<br>为函数$z=f(x,y)$在点$P_0(x_0,y_0)$处的<strong>梯度</strong>，记作$\mathbf{grad}f(x_0,y_0)$，或$\nabla f(x_0,y_0)$</p><ul><li>当方向为$(\frac{\partial z}{\partial x}|_P,\frac{\partial z}{\partial y}|_P)$时，变化速度最快</li></ul><h4 id="物理意义">物理意义</h4><ul><li>梯度方向=法线方向</li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>波动光学</title>
      <link href="/2023/01/31/%E6%B3%A2%E5%8A%A8%E5%85%89%E5%AD%A6/"/>
      <url>/2023/01/31/%E6%B3%A2%E5%8A%A8%E5%85%89%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1>三：电磁波</h1><h2 id="内容概述">内容概述</h2><ul><li>横波的性质（nature），强度（intensity），能量流动（energyflow）</li><li>偏振态（Polarization states），琼斯矩阵（Jones matrix/vector）</li><li>吸收（Absorption），色散（dispersion），折射率（refractive index）</li><li>微小粒子导致的散射（Scattering）</li></ul><h2 id="光的基本性质">光的基本性质</h2><ul><li>光是电磁波</li><li>可见光的波长在400nm~760nm</li><li>人眼对550nm的黄绿光最敏感</li><li>单色光（Monochromatic light），指仅有一种波长的光，仅存在于理论中</li></ul><h3 id="光速">光速</h3><p>光在真空（vacuum）中的速度（简称光速，用c表示）为<br>$$<br>c=\frac{1}{\sqrt{\varepsilon_0 \mu_0}}=2.997 924 58 \times10^8 m/ s<br>$$<br>光在介质（medium）中的速度（也叫做相速度，用v表示）为<br>$$<br>v=\frac{1}{\sqrt{\varepsilon_0 \varepsilon_r\mu_0\mu_r}}=\frac{c}{\sqrt{\varepsilon_r \mu_r}}<br>$$<br>很显然光在介质中的速度比在真空中慢，我们用折射率（Refractive index，用n表示）来描述这一性质<br>$$<br>n=\frac{c}{v}<br>$$<br>光穿过线性介质（linear medium）时，其频率不会发生改变</p><p>光的波长（用$\lambda$表示）<br>$$<br>\lambda=\frac{c}{v}<br>$$</p><h3 id="波粒二象性">波粒二象性</h3><h4 id="波">波</h4><p>如果光是波，那么光应该有波的性质：<br>$$<br>\mathbf{k}=\frac{2\pi}{\lambda}\hat{\mathbf{k}}<br>$$</p><p>$$<br>v=\frac{\lambda}{T}=\lambda \nu<br>$$</p><p>$$<br>\omega=2\pi \nu =\frac{2\pi}{T}=\frac{2\pi}{\lambda}v=kv=k_0c<br>$$</p><ul><li>波长（wavelength，用$\lambda$表示）</li><li>波向量（wave vector，用$\mathbf{k}$表示）</li><li>频率（frequency，用$\nu$表示）</li><li>周期（temporal period，用$T$表示）</li><li>角频率（angular frequency，用$\omega$表示）</li><li>速度（velocity，用$v$表示）</li></ul><h4 id="粒">粒</h4><p>如果光是粒子，那么光应该有粒子的性质：<br>$$<br>E=h\nu=\hbar \omega<br>$$</p><p>$$<br>\mathbf{p}=\hbar \mathbf{k}=\frac{h}{\lambda}\hat{\mathbf{k}}<br>$$</p><ul><li>能量（Energy，用$E$表示）</li><li>动量（Momentum，用$\mathbf{p}$表示）</li><li>普朗克常量（Plank constant，用$h$表示，$h=6.626\times 10^{-34}\mathrm{J}\cdot\mathrm{s}$</li><li>约化普朗克常量（用$\hbar$表示）</li></ul><h4 id="波粒二象性-2">波粒二象性</h4><p>光具有波粒二象性（Wave-particle duality），光在传播过程中体现出明显的波性，在光与物质交互（light-matter interaction）中粒性更明显</p><h4 id="光子与电子">光子与电子</h4><p>不同之处</p><table><thead><tr><th></th><th>电子</th><th>光子</th></tr></thead><tbody><tr><td>静止质量（Rest mass）</td><td>$m_0$</td><td>0</td></tr><tr><td>运动质量（Motion mass）</td><td>$m$</td><td>$hv/c^2$</td></tr><tr><td>运动速度（Motion velocity）</td><td>$&lt;c$</td><td>$c$</td></tr><tr><td>自旋（Spin）</td><td>1/2</td><td>1</td></tr><tr><td>分布定律</td><td>费力（Fermion）</td><td>玻色（Boson）</td></tr></tbody></table><p>相同之处</p><ul><li>满足波粒二象性</li></ul><h4 id="向量波与标量波">向量波与标量波</h4><p>向量波（Vector wave），波函数是向量的波，比如电磁波（EM wave）</p><p>标量波（Scalar wave），波函数是标量的波，比如声波（Acoustic wave）</p><p>光波（Lightwaves）是一种向量波，但为了方便，我们在讨论干涉衍射时，会认为光是标量波，仅仅在讨论偏振时，才认为光是向量波</p><h3 id="电磁波">电磁波</h3><h4 id="物理量">物理量</h4><ul><li>电场强度（用$\mathrm{E}$表示）：单位电荷在电场中受到的力</li><li>磁场强度（用$\mathrm{H}$表示）：通电导线周围有磁场，其强度与电流大小、距离远近有强度（但实际被后世推翻，无实际意义）</li><li>电场通量密度（用$\mathrm{D}$表示）：单位面积的电场通量</li><li>磁场通量/感应密度（用$\mathrm{B}$表示）：经过一个曲面的磁力线的数量</li></ul><h4 id="电磁学三定律">电磁学三定律</h4><p>库伦定律，真空中两个静止的点电荷间作用力满足<br>$$<br>F=k\frac{q_1q_2}{r^2}<br>$$</p><ul><li>静电力常量（$k=9.0\times 10^9 \mathrm{N} \cdot\mathrm{m^2}/\mathrm{C^2}$）</li></ul><p>安培环路定律（Ampère’s Circuital Law），也叫右手螺旋定则，载流导线能生磁</p><p>法拉第电磁感应定律（Faraday’s Induction Law），磁场变化能产生电场，感应电动势大小与磁通量变化率成正比，电场方向符合楞次定律（由于磁通量的改变而产生的感应电流，其方向为抗拒磁通量改变的方向）</p><h4 id="麦克斯韦方程">麦克斯韦方程</h4><p>真空中麦克斯韦方程：</p><p>法拉第<br>$$<br>\nabla \times \mathbf{E}=-\frac{\partial \mathbf{B}}{\partial t}<br>$$</p><p>安培<br>$$<br>\nabla \times \mathbf{B}=\mu_0 \varepsilon_0 \frac{\partial \mathbf{E}}{\partial t}<br>$$</p><ul><li>真空磁导率（也称为磁常数，用$\mu_0$表示，$\mu_0=4\pi \times 10^{-7}\mathrm{H}/\mathrm{m}$）</li><li>真空电容率（也称为电常数，用$\varepsilon_0$表示，$\varepsilon_0=8.854…\times10^{-12}\mathrm{F}/\mathrm{m}$）</li></ul><p>高斯电场<br>$$<br>\nabla \cdot \mathbf{E}=0<br>$$</p><p>高斯磁场<br>$$<br>\nabla \cdot \mathbf{B}=0<br>$$</p><p>自由空间的波动方程（wave equations，由麦克斯韦方程推出）：<br>$$<br>\nabla^2\mathbf{E}=\mu_0 \varepsilon_0 \frac{\partial^2 \mathbf{E}}{\partial t^2}<br>$$</p><p>$$<br>\nabla^2\mathbf{B}=\mu_0 \varepsilon_0 \frac{\partial^2 \mathbf{B}}{\partial t^2}<br>$$</p><h4 id="平面波">平面波</h4><p>三维的电磁波很难分析，我们可以分解变量，将其转化为两个垂直的平面波</p><p>平面波（Plane waves）：传播时波面在一个平面的电磁波</p><p>平面波的电场方向和磁场方向，与波矢方向垂直，如图，$\mathbf{k}$为波矢方向（推导过程略），从这里也能看出，平面波是横波，方向满足右手定则</p><p><img src="/images/%E5%B9%B3%E9%9D%A2%E6%B3%A2%E6%B3%A2%E7%9F%A2.png" class="lazyload" data-srcset="/images/%E5%B9%B3%E9%9D%A2%E6%B3%A2%E6%B3%A2%E7%9F%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="平面波波矢"></p><p>平面波的磁感应强度B和电场强度E的比值等于波速<br>$$<br>\frac{|E|}{|B|}=\sqrt{\frac{1}{\mu \varepsilon}}=v<br>$$<br>电场强度和磁场强度的关系为（注意，这里不是磁感应强度）<br>$$<br>\sqrt{\varepsilon_0 \varepsilon_r}|\mathrm{E}|=\sqrt{\mu_0\mu_r}|\mathrm{H}|<br>$$<br>自由空间阻抗（单位和电阻相同，用$Z_0$表示）<br>$$<br>Z_0=\sqrt{\frac{\mu_0}{\varepsilon_0}}=376.73\Omega<br>$$<br>波能传递能量，我们引入坡印廷向量（Poynting vector，用$\mathrm{S}$来表示）来描述能量流动，其方向为电磁能传递方向，大小为能流密度（单位面积的能量传输速率）<br>$$<br>\mathrm{S}=\mathrm{E}\times \mathrm{H}<br>$$<br>平面波$\mathrm{E}\times \mathrm{H} // \mathrm{k}$</p><h4 id="辐照度">辐照度</h4><p>电磁波的辐照度（Irradiance，用$\mathrm{I}$表示，也称为Intensity），是坡印廷向量在时间上的平均值<br>$$<br>\mathrm{I}=\left&lt; \mathrm{S} \right&gt;=\frac{nc\varepsilon_0}{2}\mathrm{E_0}^2<br>$$</p><ul><li>$c$是真空中光速</li><li>$\mathrm{E_0}$是电磁波电场强度的振幅（电场强度是一个三角周期函数）</li></ul><p>从这里可以看出，辐照度与$\mathrm{E_0}$的平方成正比</p><h2 id="偏振">偏振</h2><p>偏振（Polarization）：光矢量在垂直于传播方向的平面上的震动状态，我们这里提的是电场强度$\mathrm{E}$的震动</p><ul><li><p>根据是否发生偏振</p><ul><li>不偏振光（Unpolarizedlight）</li><li>完全偏振光（Completely polarized light）</li><li>部分偏振光（Partially polarized  light）</li></ul></li><li><p>根据向量$\mathrm{E}$的终点（endpoint）轨迹</p><ul><li>线偏振（Linearly polarized light）</li><li>圆偏振（Circularly polarized light）</li><li>椭圆偏振（Elliptically polarized light）</li></ul></li></ul><p>若光线沿着z轴传播，其方程满足<br>$$<br>(\frac{E_x}{E_{0x}})^2+(\frac{E_y}{E_{0y}})^2-2(\frac{E_x}{E_{0x}})(\frac{E_y}{E_{0y}})\cos \delta = \sin ^2 \delta<br>$$</p><h3 id="线偏振">线偏振</h3><p>当$\delta=2m\pi$时，方程变为<br>$$<br>(\frac{E_x}{E_{0x}})^2+(\frac{E_y}{E_{0y}})^2-2(\frac{E_x}{E_{0x}})(\frac{E_y}{E_{0y}}) = 0 \<br>(\frac{E_x}{E_{0x}}-\frac{E_y}{E_{0y}})^2=0<br>$$<br>于是得到线偏振的方程（一三象限）<br>$$<br>\frac{E_x}{E_{0x}}=\frac{E_y}{E_{0y}} \equiv \cot \alpha<br>$$<br><img src="/images/线偏振.png" class="lazyload" data-srcset="/images/线偏振.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="线偏振" style="zoom: 67%;" /></p><p>同理，当$\delta=2(m+1)\pi$时，方程等于（二四象限）<br>$$<br>\frac{E_x}{E_{0x}}=-\frac{E_y}{E_{0y}}<br>$$<br>用虚数将两个方程合并，得到<br>$$<br>\frac{E_x}{E_{y}}=\frac{E_{0x}}{E_{0y}}e^{\mathrm{i}m’\pi}<br>$$</p><ul><li>当$m’$为偶数（0 or even）时，一三象限</li><li>当$m’$为奇数（odd）时，二四象限</li></ul><h3 id="椭圆偏振与圆偏振">椭圆偏振与圆偏振</h3><p>当$\delta=(2m+1)\frac{\pi}{2}$时，方程变为<br>$$<br>(\frac{E_x}{E_{0x}})^2+(\frac{E_y}{E_{0y}})^2=1<br>$$<br>这是一个椭圆方程，我们称之为椭圆偏振</p><p>倘若$E_{0x}=E_{0y}=E_{0}$，方程退化为<br>$$<br>E_x^2+E_y^2=E_0^2<br>$$<br>我们称之为圆偏振</p><img src="/images/椭圆偏振.png" class="lazyload" data-srcset="/images/椭圆偏振.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="椭圆偏振" style="zoom:50%;" /><ul><li><p>当$\delta=\pi / 2$时，y轴驱动x轴移动，此时为顺时针，称为RCP</p></li><li><p>当$\delta=-\pi / 2$时，x轴驱动y轴移动，此时为逆时针，称为LCP</p></li></ul><p><img src="/images/RCP.png" class="lazyload" data-srcset="/images/RCP.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RCP"></p><h3 id="琼斯矢量">琼斯矢量</h3><p>将偏振光的状态以向量的形式写出，方便运算（只适合完全极化光）<br>$$<br>\mathrm{E}=\left[<br>\begin{array}{c}<br>E_x(t)\<br>E_y(t)\<br>\end{array}<br>\right]<br>$$<br>琼斯向量左乘一个2x2矩阵，可以得到一个新的琼斯向量，这个矩阵被称为琼斯矩阵</p><h3 id="偏振度">偏振度</h3><p>偏振度（Degree of polarization，用$P$表示）：用来衡量偏振程度的物理量<br>$$<br>P=\frac{I_p}{I_t}=\frac{I_p}{I_p+I_n}<br>$$</p><ul><li>$I_p$：完全偏振光部分的辐照度</li><li>$I_n$：不偏振光部分（自然光）的辐照度</li></ul><h2 id="吸收">吸收</h2><h3 id="兰伯特定律">兰伯特定律</h3><p>兰伯特定律（Lambert law）：光在气体介质中传播，光强（intensity）随着传播深度增加而递减，满足<br>$$<br>I=I_0 e^{-\alpha x}<br>$$</p><ul><li>吸收系数（用$\alpha$表示）</li><li>传播深度（用$x$表示）</li></ul><h3 id="贝尔定律">贝尔定律</h3><p>贝尔定律（Beer law）：光在溶剂中传播，光强满足<br>$$<br>I=I_0 e^{-ACL}<br>$$</p><ul><li>浓度（用$C$表示）</li><li>常数$A$，与溶质性质有关，与浓度无关</li></ul><p>该公式满足有两个条件</p><ul><li>溶液浓度不能过高，以免出现分子间作用力（这也能解释为什么常数$A$为什么和浓度无关，因为浓度一高，公式就不成立了）</li><li>光强不能过高</li></ul><h2 id="色散">色散</h2><p>色散（Dispersion）：光波的相速度随着频率的改变而改变的现象</p><p><img src="/images/%E8%89%B2%E6%95%A3.png" class="lazyload" data-srcset="/images/%E8%89%B2%E6%95%A3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="色散"></p><p>正常色散（Normal dispersion）：折射率随着波长的增加而减小</p><p>柯西公式：<br>$$<br>n=A+B/\lambda^2+C/\lambda^4<br>$$<br>反常色散（Anomalous dispersion）：折射率随着波长的增加而增加</p><p>反常色散通常发生在吸收带（absorption band）附近，反常色散并不是异常的，叫这个名字只是历史问题</p><h3 id="洛伦兹震荡模型">洛伦兹震荡模型</h3><p>洛伦兹震荡模型（Lorentz oscillator model）：在一个尺寸为$\Delta V$的空间内有一个电子（电荷量为$1.6\times10^{-19}C$），在光的电场作用下，让该电子相对于稳定位置偏离x</p><p>偏振度（单位体积电偶极矩的振幅，用$P$表示）写作<br>$$<br>P=\frac{1}{\Delta V}ex=n_0ex<br>$$</p><ul><li>电荷密度（density of charge，用$n_0$表示）</li><li>$x$是电子的运动方程，如下</li></ul><p>$$<br>x(\omega)=-\frac{eE(\omega)}{m_0}\frac{1}{\omega^2+\mathrm{i}\omega \gamma-\omega_0^2}<br>$$</p><p>将$x$带入，得到<br>$$<br>P=-\frac{n_0e^2}{m_0}\frac{1}{\omega^2+\mathrm{i}\omega \gamma-\omega_0^2}E(\omega)<br>\equiv \varepsilon_0 \chi(\omega)E(\omega)<br>$$<br>根据定义<br>$$<br>\varepsilon=\varepsilon_0[1+\chi(\omega)]<br>$$<br>带入得<br>$$<br>n^2=\varepsilon/\varepsilon_0=1-\frac{n_0e^2}{m_0}\frac{1}{\omega^2+\mathrm{i}\omega \gamma-\omega_0^2}<br>$$<br><img src="/images/洛伦兹模型.png" class="lazyload" data-srcset="/images/洛伦兹模型.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="洛伦兹模型" style="zoom:67%;" /></p><p>如图，洛伦兹模型解释了为什么在靠近吸收带时，会发生反常色散</p><h3 id="组速度">组速度</h3><p>在介质中不同波长的光速度不同，红光波长大，跑的更快</p><p>那么如果一个光，包含了多种波长的光，我们用组速度（Group velocity，用$v_g$表示）来描述其速度<br>$$<br>v_g=\frac{\mathrm{d}\omega}{\mathrm{d}k}<br>$$</p><h2 id="散射">散射</h2><h3 id="瑞丽散射">瑞丽散射</h3><p>瑞丽散射（Rayleigh scattering）：光在细小粒子间散射<br>$$<br>I_{scat}\propto 1/\lambda^4<br>$$</p><p>$$<br>I_{\theta}\propto I_{\pi/2}(1+\cos^2 \theta)<br>$$</p><h3 id="米氏散射">米氏散射</h3><p>米氏散射（Mie scattering）：光在大型粒子内部散射</p>]]></content>
      
      
      <categories>
          
          <category> optics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
