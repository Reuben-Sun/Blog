{"meta":{"title":"ReubenSun","subtitle":"","description":"Reuben的笔记博客","author":"Reuben Sun","url":"https://reubensun.com","root":"/"},"pages":[{"title":"所有分类","date":"2023-03-28T02:55:59.805Z","updated":"2023-03-28T02:55:59.805Z","comments":true,"path":"categories/index.html","permalink":"https://reubensun.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-03-28T02:55:59.805Z","updated":"2023-03-28T02:55:59.805Z","comments":true,"path":"tags/index.html","permalink":"https://reubensun.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Blender MMD Tools安装","slug":"dcc/BlenderMMD","date":"2023-03-28T10:01:25.000Z","updated":"2023-03-28T02:56:19.619Z","comments":true,"path":"dcc/BlenderMMD/","link":"","permalink":"https://reubensun.com/dcc/BlenderMMD/","excerpt":"","text":"Blender MMD Tools 尽管实际工作中不会使用MMD，甚至也很少使用Blender，但对于自学的同学来说，MMD可能是网上资源最丰富的模型资源，尤其是国内二次元手游厂商，十分乐于分享人物模型 安装 安装Blender 下载blender_mmd_tools插件，下载压缩包即可 安装插件 Edit &gt; Perferences &gt; Add-ons &gt; Install &gt; 选择第二步下载的压缩包 激活插件，找到倒入的插件，点亮左边的checkbox即可 当你看到如下内容，说明安装成功（这个小箭头确实不明显，容易找不到） 点击下图的Import即可导入模型和动画，在mmd面板可以导出mmd信息，使用blender的File可以导出obj、fbx等模型 资料 HDRIs：高清天空盒贴图、3D模型 Mixamo：人物模型、动画 模之屋：国产二游MMD模型 Quixel：高清材质扫描贴图 参考 Blender MMD Tool Wiki","categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"}]},{"title":"C与C++的DLL","slug":"program/C++DLL","date":"2023-03-08T15:01:25.000Z","updated":"2023-03-28T02:56:05.036Z","comments":true,"path":"program/C++DLL/","link":"","permalink":"https://reubensun.com/program/C++DLL/","excerpt":"","text":"C与C++的DLL 今天中午跟同事吃饭时，有人分享他在清理项目中的Warming，其中包括C++风格的DLL，我才知道，DLL建议写C风格的 根本原因是，C++功能复杂，更依赖Name Mangling，而三大编译器具体实现不尽相同，使得ABI不确定 ABI ABI（Application binary interface） API（Application Programming Interface） 当你在写代码时，经常会通过API访问库中的函数、数据结构。代码被编译后，生成大量二进制数据，ABI中包含了二进制的结构布局、访问方法，应用程序可以通过ABI访问库中的二进制数据 ABI是一个格式，代码编译出的ABI与编程语言、操作系统、编译器有关，通常是不确定的 ELF格式 ELF（Executable and Linkable Format），可执行可链接格式，是Unix系统ABI的文件格式 Name Mangling Name Mangling会对名字进行重新编码，以实现名字的唯一性 C++支持函数重载、类、命名空间、模版，一个类中可以有多个重名函数、重名成员变量，这些名称编译后本质是不同的二进制，因此要做更复杂的Name Mangling 很不幸的是，C++没有对Name Mangling做硬性规定，于是三大编译器g++、MSVC、clang的实现不同，相同的代码可能编出不同的ABI，当你使用跨编译器的dll时，很容易出现错误 C的DLL 和C++相比，C就简单得多 大多数语言都提供了一些简单的方法调用C的DLL，而且C++编译器也支持导出C语言的DLL 生成DLL CMakeList.txt SET(LIB_SRC ./Math.h ./Math.cpp) SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ../libMath) ADD_LIBRARY(MathDLL SHARED $&#123;LIB_SRC&#125;) INSTALL(TARGETS MathDLL) SET_TARGET_PROPERTIES(MathDLL PROPERTIES LINKER_LANGUAGE C RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125; LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125; OUTPUT_NAME \"MathDLL\" PREFIX \"\") Math.h #define DLL_EXPORT extern \"C\" __declspec(dllexport) DLL_EXPORT int MathAdd(int a, int b); Math.cpp #include \"Math.h\" int MathAdd(int a, int b)&#123; return a+b; &#125; 动态加载DLL #include &lt;iostream> #include &lt;Windows.h> typedef int (*pfnAdd)(int, int); int main() &#123; HINSTANCE handle = LoadLibrary(TEXT(\"../lib/libMath/MathDLL.dll\")); pfnAdd pAdd = (pfnAdd) GetProcAddress(handle, \"MathAdd\"); std::cout &lt;&lt; pAdd(1, 2) &lt;&lt; std::endl; FreeLibrary(handle); return 0; &#125; 参考 DLL written in C vs the same written in C++ What is an application binary interface (ABI)? 使用CMake生成动态链接库DLL","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://reubensun.com/tags/C/"}]},{"title":"算法：前缀和","slug":"program/前缀和","date":"2023-03-07T22:01:25.000Z","updated":"2023-03-28T02:56:05.038Z","comments":true,"path":"program/前缀和/","link":"","permalink":"https://reubensun.com/program/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"前缀和 本人没有算法基础，以下均为春招刷Leetcode的笔记，仅用于记录，侵权勿喷 前缀和本质是一种预积分手段，运行时只需要得到边界值，就能快速、无损地获得区间积分值，二维的前缀和SAT在图形学中也有重要的运用 注意数组越界，尤其是前缀乘 明确索引的含义，这关系着数组的长度是否需要+1 前缀和可以使用哈希表加速查找 除自身以外数组的乘积 leetcode 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 特点 使用左右两个前缀和 思路 最简单的方法自然是求所有数的总乘积，ans[i] = total / nums[i]，不过这道题让我们不要用除法（如果数中有0，这种做法也是错的） 我们从左做一次前缀乘，left[i]表示以0~i的前缀乘，从右开始做一次前缀乘，right[i]表示以i~n-1的前缀乘 ans[i]将数组切分为三个部分，他自己，左边和右边，左边等于0~i-1的总乘积，右边等于i+1～n-1的总乘积，左右相乘即可得到最终结果 对于边界做特殊处理 实现 vector&lt;int> productExceptSelf(vector&lt;int>&amp; nums) &#123; int n = nums.size(); vector&lt;int> left(n); left[0] = nums[0]; vector&lt;int> right(n); right[n-1] = nums[n-1]; // 求左右前缀和 for(int i = 1; i &lt; n; ++i)&#123; left[i] = left[i-1] * nums[i]; right[n-i-1] = right[n-i] * nums[n-i-1]; &#125; vector&lt;int> ans(n); // 边界处理 ans[0] = right[1]; ans[n-1] = left[n-2]; for(int i = 1; i &lt; n-1; ++i)&#123; ans[i] = left[i-1] * right[i+1]; &#125; return ans; &#125; 和为k的子数组 leetcode 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 -1000 &lt;= nums[i] &lt;= 1000 特点 数组有正有负，因此前缀和不递增 思路 固定右端点，向左找左端点，若存在和为k的连续子数组，我们能找到一个左端点，使得左右端点前缀和之差为k 由于数组中包含负数，因此左端点可能有多个 于是问题转化为从右端点出发，寻找值为ps[j] - k的左端点 当遍历完i后，当前右端点preSum[i]未来也可能是左端点，于是加入哈希表中 实现 int subarraySum(vector&lt;int>&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int> preSum(n+1, 0); unordered_map&lt;int, int> mp; // value：key出现过的次数 mp[0] = 1; for(int i = 0; i &lt; n; ++i)&#123; preSum[i+1] = preSum[i] + nums[i]; &#125; int ans = 0; for(int i = 1; i &lt;= n; ++i)&#123; ans += mp[preSum[i]-k]; ++mp[preSum[i]]; // 在遍历完i之前，我们还没遇到过i &#125; return ans; &#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://reubensun.com/tags/leetcode/"}]},{"title":"算法：区间重叠","slug":"program/区间重叠","date":"2023-03-07T22:01:25.000Z","updated":"2023-03-28T02:56:05.039Z","comments":true,"path":"program/区间重叠/","link":"","permalink":"https://reubensun.com/program/%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/","excerpt":"","text":"区间重叠 本人没有算法基础，以下均为春招刷Leetcode的笔记，仅用于记录，侵权勿喷 今天刷题时发现一类区间重叠题，思路很巧妙，理解后做起来非常简单 这类题的特点就是给你一组区间，求最多多少个区间重叠 会议室Ⅱ leetcode 给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间，返回 所需会议室的最小数量 输入：intervals &#x3D; [[0,30],[5,10],[15,20]] 输出：2 思路 我们将区间转化为两次操作，对于每一个区间，区间开始会申请一个会议室，区间结束会释放一个会议室 将操作按发生时间排序，依次执行，记录占用会议室的最大数量 实现 int minMeetingRooms(vector&lt;vector&lt;int>>&amp; intervals) &#123; vector&lt;vector&lt;int>> v; for(auto&amp; i : intervals)&#123; v.push_back(&#123;i[0], 1&#125;); // 区间开始申请一个会议室 v.push_back(&#123;i[1], -1&#125;); // 区间结束释放一个会议室 &#125; sort(v.begin(), v.end()); // 将操作按发生时刻排序，对于同时发生的操作，先释放再申请 /* sort(v.begin(), v.end(), [](const vector&lt;int>&amp; a, const vector&lt;int>&amp; b)->bool&#123; if(a[0] == b[0])&#123; return a[1] &lt; b[1]; &#125; return a[0] &lt; b[0]; &#125;); */ int ans = 0; int cur = 0; for(int i = 0; i &lt; v.size(); ++i)&#123; cur += v[i][1]; ans = max(ans, cur); &#125; return ans; &#125; 拼车 leetcode 车上最初有 capacity 个空座位。车只能向一个方向行驶（也就是说，不允许掉头或改变方向） 数组每一项包含三个数，上车人数，上车时刻，下车时刻 当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。 输入：trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 4 输出：false 思路 与上题基本相同，不过每次操作的数量改变了 实现 bool carPooling(vector&lt;vector&lt;int>>&amp; trips, int capacity) &#123; vector&lt;vector&lt;int>> v; for(auto&amp; t: trips)&#123; v.push_back(&#123;t[1], t[0]&#125;); v.push_back(&#123;t[2], -t[0]&#125;); &#125; sort(v.begin(), v.end()); int cur = 0; for(int i = 0; i &lt; v.size(); ++i)&#123; cur += v[i][1]; if(cur > capacity)&#123; return false; &#125; &#125; return true; &#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://reubensun.com/tags/leetcode/"}]},{"title":"Godot 4.0源码阅读","slug":"engine/Godot","date":"2023-03-05T23:01:25.000Z","updated":"2023-03-28T02:56:05.027Z","comments":true,"path":"engine/Godot/","link":"","permalink":"https://reubensun.com/engine/Godot/","excerpt":"","text":"Godot 4.0源码阅读 近期Godot 4.0发布了，更新了许多厉害的图形feature，引擎代码是开源的，而且代码量远比Unreal Engine小，于是准备看看，不定期更新 编译 Github Fork项目，项目地址 安装Python（我使用的是Anaconda3） 安装Scons（使用Python安装，我使用的是Anaconda） 拉取项目，进入项目根目录 运行代码，生成Visual Studio项目（不过我是用Rider打开的） scons p=windows vsproj-yes 编译（首次构建可能要二十分钟）","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"GC","slug":"GC","permalink":"https://reubensun.com/tags/GC/"}]},{"title":"Google C++代码规范","slug":"program/GoogleC++","date":"2023-03-05T19:01:25.000Z","updated":"2023-03-28T02:56:05.038Z","comments":true,"path":"program/GoogleC++/","link":"","permalink":"https://reubensun.com/program/GoogleC++/","excerpt":"","text":"Google C++ 代码规范 Google C++ Style Guide Google提出的一套代码规范，能提高代码的可读性，减少出错。建议配合Effective C++阅读 头文件 所有头文件都应该自给自足（self-contained） self-contained : compile on their own 确保你的header files包含了你需要的所有东西，而不是假设你#include进来的某个（些）headers帮你包含了你需要的东西。 A.h包含了B.h和C.h，而B.h也包含了C.h，那么在A.h中使用C.h时，会难以判断到底该用哪一个 #define 保护 每个头文件都要使用#pragma once保护 前置声明 我个人理解的前置声明，是指在一个.h文件中开头声明另一个.h文件中的类，以此来实现类似#include某个文件的某一部分 与之对应的是直接使用#include引入文件，但这样实际会增加编译工作量，降低编译速度，于是我们非必要不#include Google建议要避免使用前置声明，因为使用前置声明会影响类的修改，也容易产生错误 但使用前置声明可以提高编译速度，因此需要按情况选择 优点 节省编译时间，避免很多不必要的（因为头文件改动而导致的）重新编译 缺点 隐藏了依赖关系 头文件改动时会破坏后续，影响开发者改动API（比如当你要添加一个形参时） 但这个是不是可以通过宏的方法避免？#define Func Func 两个类互相引用 前置声明（Forward Declarations）基本仅用于两个类互相引用 // A.h #include \"B.h\" class A &#123; B b; //A中使用了B，因此 ... &#125; // B.h class A; class B &#123; A* a; ... &#125; 失去依赖关系 前置声明最大的问题是失去依赖关系 // B.h struct B &#123;&#125;; struct D : B &#123;&#125;; //这里的D继承自B #include \"b.h\" // 如果使用前置声明替换掉#include，就会出现错误 void f(B*); void f(void*); void test(D* x) &#123; f(x); &#125; // Calls f(B*) 内联函数 除非是极其高频调用，确定是性能瓶颈的地方，不然不用内联函数 不要内敛超过十行的函数 析构函数远比表面要长，因为他隐式调用着成员和基类的析构函数 #include路径 按照源码目录树结构排列，避免使用UNIX的快捷目录，比如.（当前目录）和..（上级目录） #include顺序 C头文件 C++头文件 第三方库头文件 本项目头文件 作用域 命名空间将全局作用域细分为独立具体的作用域，可以有效防止全局命名冲突 #include &quot;a.h&quot; namespace MyNamespace &#123; class MyClass &#123; ... &#125;; &#125; &#x2F;&#x2F;namespace MyNamespace 请在命名空间最后注释出命名空间的名字 不要污染命名空间 不要在std命名空间中声明任何东西 不要使用using namespace xxx 不要在头文件中使用命名空间别名，如namespace bbb = ::Foo::Bar::Baz 静态变量 不要在.h文件中声明静态变量，至少不能用全裸的静态变量 不要定义静态存储周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中静态变量的构造和析构顺序不确定，会导致bug（除非你使用constexpr） 原生数据类型（POD，Olain Old Data），如int、char、float，int*、int[]、结构体 在同一编译单元，静态初始化会优先于动态初始化，并按照声明顺序初始化，以逆序销毁 但是不同编译单元，初始化、销毁顺序是未定义行为 类 构造函数不要调用虚函数 在类被完全初始化前，这个类其实是基类+其他部分，此时调用虚函数不一定会指向子类的重载，可能会报错、出错 优点 不需要考虑类是否被完全初始化 初始化的对象可以为const类型 如果你想进行有意义的non-trivial初始化，可以使用明确的Init()方法，或者工厂模式 与之对应，析构函数要设为虚函数 不要隐式类型转换 不要使用隐式类型转换 隐式转换会降低代码可读性，由于是存在函数重载时，让人难以判断到底在用哪一个函数 隐式转化可能会导致类型不匹配的错误 使用explict关键词（常用于单参数构造函数和类型转化操作符），可以使当前类型只能被显示类型转换，如果使用隐式转化，会报错 class Foo &#123; explicit Foo(int x, int y); &#x2F;&#x2F;这个类型不能被隐式转化，调用Func(&#123;42, 3.14&#125;)会报错 ... &#125; void Func(Foo f); 拷贝和移动 如果你的类型需要拷贝和支持，就请实现它，否则禁用它（=delete） std::unique_ptr&lt;int&gt; 可移动，但是不能复制 可拷贝类型，可以使用相同类型的另一对象进行初始化，当前对象会得到相同的值，同时不改变源对象。 用户通过定义拷贝构造函数、拷贝赋值操作符实现 可移动对象，可以使用相同类型的临时对象进行初始化，当前对象会得到相同的值 用户通过定义移动构造函数、移动赋值操作符实现 不要为任何有可能有子类的类型提供拷贝和移动，可能会导致对象割裂 除了数据成员，其他一律用class C++的class和struct很像，大部分功能相同，不过 struct可以拥有成员变量，但不能拥有成员函数（你可以写非成员函数+引用） struct成员为public，而class可以拥有private成员 struct的继承方式为public，比class少（尽管全世界C++项目99%的继承都是public继承） struct与pairs、tuples struct的字段名更具可读性，当数据有意义时，尽量使用struct 不过pairs和tuples更适用于泛型编程 组合与继承 组合很好用，能用接口用接口，如果非要用继承，请public继承 对于虚函数进行重载时，用override、final标记，尽管这个关键字没有什么作用，但能提高代码可读性 全世界C++项目99%的继承都是public继承 public、protected、private继承你可以理解为设限 如果是public继承，那么子类访问父类成员的存取类型都不会超高public（废话），父类的public、protected、private成员，对于子类为public、protected、private 如果是protected继承，那么子类访问父类成员的存取类型都不会超高protected，父类的public、protected、private成员，对于子类为protected、protected、private 请不要使用多重继承，不过你能继承多个接口 关于接口 接口是用interface标记的类，只有纯虚数和静态函数，没有非静态成员 接口不能被直接实例化，也不需要定义构造函数 请为接口实现虚析构函数 请不要为其添加函数实现或非静态成员数据 操作符重载 尽量别重载 访问控制 类的数据成员应该为private，除非是一个常量 数据成员设为private，然后编写public的访问函数，不过感觉不如C#的属性优雅 声明顺序 随便找个.h文件，看看类的声明是怎么写的 相似的声明放在一起，并按以下顺序 类型及类型别名（typedef, using, enum ，嵌套的结构体和类） 静态常量 工厂函数 构造函数和赋值运算符 析构函数 其他函数 数据成员 先写public，再写protected、private 不要将大段的函数定义写在类定义中，建议.h声明，.cpp定义 函数 参数 见名知意，知行合一 看到函数名就能知道这是干什么的，比如Get、Set，如果一个函数是Get，那就做Get的事 优先使用返回值而非输出参数，这能提高可读性和性能 不要返回空指针（除非你是这样设计的） 输入参数、不需要改变的参数可以用const引用 输出参数、可以被修改的参数可以用指针 参数需要排序，输入先于输出，无默认值先于有默认值 void foo(const std::string&amp; in_str, std::string* out_str); 简短的函数 个人感觉完全没必要，尤其是对于C#、Java，40行好干什么 简短的函数能提高代码可读性，提高调试效率，在函数式编程很常用 函数重载 函数重载能够使同一作用域中，有一组相同函数名、不同参数列表的函数，常用于命名一组功能相似的函数 不过如果函数仅靠参数类型进行重载，就会涉及匹配、派生类之类的问题，让人感受困惑 如果要重载Append()，其实可以在函数名上添加类型信息，比如AppendInt()、AppendString() 缺省参数 写缺省不如写重载 缺省本质上就是一种函数重载，所有不适合使用重载的地方，都不适合使用缺省 由于缺省参数会干扰函数指针，因此一定不要在虚函数中使用缺省参数 函数返回值的后置写法 后置写法本身没问题，swift、js等语言都是这样写的，但是对于C++来说是一种“很新的东西”，容易让人感到困惑 C++11后，C++的函数可以使用后置返回类型，不过除了lambda表达式，一般不这样写 // 前置写法 int foo(int x); // 后置写法 auto foo(int x) -> int; // lambda只能后置写法 sort(vec.begin(), vec.end(), [](int a, int b) -> bool &#123; return a &lt; b; &#125;); 在泛型编程中，当返回类型依赖于模版参数时，也可以使用后置写法，能提高可读性 // 前置写法 template&lt;class T, class U> decltype(declval&lt;T&amp;>() + declval&lt;U&amp;>()) add(T t, U u); // 后置写法 template&lt;class T, class U> auto add(T t, U u) -> decltype(t + u); 所有权和智能指针 关于所有权和智能指针，可以参考垃圾回收中引用计数法 C++标准鼓励我们使用智能指针管理资源 对于一个动态的对象，我们更倾向于让其拥有单一、固定所有权（ownership），并使用指南指针做所有权转换 std::unique_ptr，独占资源 当指针离开作用域，资源就会被销毁 无法复制（copy），但能转移（move）所有权 std::shared_ptr，共享资源 当资源失去所有引用时，资源被销毁 可以复制，共享所有权（无需转移） 好处 有的对象甚至没法复制，只能转移 转移通常比复制更高效，尤其是一些const对象，转移比深拷贝高效得多 使用智能指针能提高可读性，也减少了内存泄漏 其他 右值引用 关于左右值，建议阅读C++11 只在定义移动构造函数和移动赋值操作时使用右值引用 推荐使用std::move，不要使用std::forward（除非你在模版编程） // copy void set(const string &amp; var1, const string &amp; var2)&#123; m_var1 = var1; m_var2 = var2; &#125; // move void set(string &amp;&amp; var1, string &amp;&amp; var2)&#123; m_var1 = std::move(var1); m_var2 = std::move(var2); &#125; // forward template&lt;typename T1, typename T2> void set(T1 &amp;&amp; var1, T2 &amp;&amp; var2)&#123; m_var1 = std::forward&lt;T1>(var1); m_var2 = std::forward&lt;T2>(var2); &#125; forward的作用是什么？ 如果不使用forward，我们需要同时定义copy和move函数，在处理左值时调用copy，处理右值调用move，这增加了代码量，如果使用forward，我们只需要写一份 但forward让一个函数能干两种事，这不符合“知行合一”，为了代码可读性，我们通常不会使用。如果我们明确这个函数要move，那就用move 友元 友元：在定义一个类时，可以将一些（定义在外部的）函数声明为友元，这些友元函数可以访问该类的private、protected成员 友元扩大了类的封装，在OOP中很忌讳，但只要合理，还是可以用的 原本是private的成员，对于友元类、函数，都是public的 友元类似一种许可，当一个类设置友元后，相当于给友元开了管理员权限，能随意访问原本受保护的成员 如果你要用，请写在同一个文件中 class Child&#123; public: Child() &#123; name = \"default name\"; &#125; string getName() &#123; return name; &#125; friend class Mother; // 母亲有权利修改孩子的名字，尽管setName是private的 private: string name; void setName(string nn) &#123; name = nn; &#125; &#125;; class Mother&#123; public: Child child; void renameChild(string nn)&#123; child.setName(nn); &#125; &#125;; int main()&#123; Mother mother; Child child; mother.child = child; // child.setName()的访问控制为private，你没法在这里调用 cout &lt;&lt; mother.child.getName() &lt;&lt; endl; // default name mother.renameChild(\"Tom\"); cout &lt;&lt; mother.child.getName() &lt;&lt; endl; // Tom return 0; &#125; 异常 谷歌不使用C++异常，让异常Let it crash。不过异常在C#、Java、Swift中很常用， 抛异常可能会导致一些未定义行为，比如不要在析构函数中使用异常 不使用异常，如果出错常用方法为： 直接abort() 吞异常，Let it crash RTTI 不使用运行时类型识别，不使用typeid和dynamic_cast 运行时类型识别会使代码难以维护，如果你需要用RTTI（除了单元测试），说明你的类设计的不好 类型转化 使用C++风格的类型转化（而非C风格的） double double_value; // C++ float f = static_cast&lt;float>(double_value); // C float f2 = (float)double_value; 使用static_cast做值转换、子类指针转父类指针 使用const_cast去掉const限定符 使用reinterpret_cast做指针和整型、指针和指针间的转换（仅在你会用时使用） 不使用dynamic_cast 严格别名 C++的reinterpret_cast不会编译为任何CPU指令，会编译为纯汇编，于是你可以像汇编一样操作指向内存的指针地址，破坏了C++对汇编对抽象 严格别名（strict aliasing）规定：只有同一种类型的指针，才可以出现别名，总之没事别做不相干类型的指针转化 float* f; int* i; // 编译器优化时会假定 f != i // 若你的代码让 f == i （比如使用reinterpret_cast），那就是未定义行为，违反严格别名规则 当你通过指针，将一个struct塞到一个buffer中，或者将一个buffer塞到struct中，在这个过程中，指针的类型发生转换，从buffer转化为struct typedef struct Msg &#123; int a; int b; &#125; Msg; int main() &#123; int x[2] = &#123;1, 2&#125;; int* p = x; Msg* msg = (Msg*)p; // Msg* msg = reinterpret_cast&lt;Msg*>(p); cout &lt;&lt; msg->a &lt;&lt; endl; // 1 cout &lt;&lt; msg->b &lt;&lt; endl; // 2 return 0; &#125; 上面这个过程干了什么？你知道这个buffer的内存地址、长度，你想直接用这些信息访问内存，这是对的，但是某些情况下这就是未定义行为 流 谷歌认为除了日志接口需要，不要使用流 说实话我感觉流挺方便的，只要能保持输出的一致性就行，而且C++的Stream类型安全，用起来十分方便，尤其是输出字符串和对象时 自增与自减 谷歌建议一律使用前置自增自减，尤其是迭代器 一般而言，使用前置自增++i能提高性能，后置会生成临时对象和拷贝复制 不过，如果自增自减后变量并没有被用到，仅仅是用于记录迭代次数，编译器会对后置自增自减进行优化，性能一样，而且后置更像自然语言，可读性更强 const 在任何能使用const的地方使用const或constexpr 整型 C++内置的整型只，只使用int 如果需要明确长度，那就用&lt;cstdint中的int16_t、int64_t 如果你不确定用何种大小的int，那么用最大的 可移植性 代码应该对32位和64位系统友好，在处理打印、比较、结构体对齐时要注意 不是所有人都在用64位系统（不过iOS这种封闭平台确实做到了完全禁用32位） 预处理宏 尽管在图形Shader中，用宏进行条件变异很常用，但这其实是因为GPU对分支的处理不好，因此我们通过编译多份代码来避免运行时使用分支。不过这对CPU代码纯属是提高包体，降低可读性，增加调试难度，不推荐使用 宏具有全局作用域，使你看到的和编译器看到的内容不同，尽量用内联、const进行替换 不要使用宏做条件编译 不要在.h文件中定义宏 使用完#define后要立刻#undef 不要使用展开后让C++构造不稳定的宏 #define max(a,b) (a > b ? a : b) int x = 5, y = 6; int n = max(++x, ++y); // 本质为 int n = (++x > ++y ? ++x : ++y)，和预期不一致 不要在宏后面写单行注释 不要用##处理函数、类、变量的名字，可读性很差 // 用##将两个宏拼起来，很trick的写法 #define CONS(a,b) int(a##e##b) cout &lt;&lt; CONS(2, 3) &lt;&lt; endl; // 输出2000，因为CONS宏将2和3拼成了2e3 nullptr 空指针用nullptr，数值用0（或者0.0），std::string用\\0 绝对不要用NULL sizeof sizeof用于获取类型的大小，不过不建议对类型使用，而是对varname使用 MyStruct data; memset(&amp;data, 0, sizeof(MyStruct)); // 对类型使用，不推荐 memset(&amp;data, 0, sizeof(data)); // 对varname使用，推荐 // 如果有人改动了data的类型，比如改成了MyStruct2，第二种方法不会出错 类型推断 函数模版参数类型推断 template&lt;typename T> void f(T t); f(0); // f&lt;int>(0) 类模版类型推断 Class Template Argument Deduction（CTAD） std::array a = &#123;1, 2, 3&#125;; // a is a std::array&lt;int, 3> auto变量类型推断 若一个变量被声明为auto，那么它的类型会自动匹配成初始化表达式的类型 auto a = 42; // a is an int auto&amp; b = a; // b is an int&amp; auto d &#123;42&#125;; // d is an int, not a std::initializer_list&lt;int> auto il = &#123;1,2,3,4&#125;; // il is a std::initializer_list&lt;int> 有的变量类型巨长（尤其是使用模版和命名空间时），而且一次初始化要写两遍，使用auto能提高可读性 仅在局部变量中使用auto，比如for循环 仅在一眼能看出类型的地方使用auto 不要列表初始化auto变量 for(auto&amp; i: list)&#123;...&#125; 函数返回值类型推断 不要用于函数返回值，除非你是lambda使用后置返回值 auto f() -> int &#123; return 1; &#125; 指定的初始化 C++20才加入的新东西，感觉大家的项目基本都没法用吧 可以方便的生成高可读性高聚合的初始化表达式，尤其对一些字段顺序不明显的结构 struct Point &#123; float x = 0.0; float y = 0.0; float z = 0.0; &#125;; Point p = &#123; .x = 1.0, .y = 2.0, // z will be 0.0 &#125;; Lambda表达式 将所有的捕获显示写出来 只有lambda声明周期很短时，才使用[&amp;] 使用[=]显式捕获 [=](int x) &#123; return x + n; &#125; // 默认捕获方式，不好 [n](int x) &#123; return x + n; &#125; // 显式捕获方式，好 [&amp;] &#123; foo.doSomething(); &#125; // 不好 [&amp;foo] &#123; foo.doSomething(); &#125; // 好 泛型编程 避免复杂的泛型编程，这东西可读性相当差，调试难度相当高 别名 别名（Aliases）能让复杂类型的名字变简单，尤其是那些带有命名空间的类型 typedef Foo Bar; // 传统方法 using Bar = Foo; // C++11后推荐的用法 不要在公共区域使用别名，除非你写对其写详细注释 不要在公共区域引入命名空间别名 命名规范 命名规范因项目而异，只要保持一致性即可，谷歌的命名规范我个人不习惯，可能我C#、Swift写的比较多，感觉好奇怪 通用规范 命名别嫌长，要见名知意 你看看人家Java的方法名长度 不要用汉语拼音 你要记住，英语是表音文字，因此可以靠读音/26个字母排列明确意义，而汉字是象形文字，形状才能明确意义，只靠汉语拼音无法明确区分同音字词。 而且汉语拼音是新中国扫盲、普及普通话的工具，不仅外国人看不懂，甚至一些说方言的人也看不懂 慎用缩写 日本人用假名翻译“龙”，还省去了几个词，结果/ˈdræɡən/硬是读成了“多拉贡” 注释 见名知意，自文档的代码确实好，但有时你还是需要写注释，以提高可读性 每个文件开头写入版权公告（不要轻易删除原作者的信息） 代码段行前注释，描述类行后注释，行后注释要对齐 假设读代码的人水平比你高，有些过于明显的API解释，不要写（不会有人给i++写注释吧） 标点、换行（对于python，yml很重要）建议依赖IDE，统一即可 写TODO（比如Xcode就支持TODO:和MARK:，很多IDE都能检查） 如果一个接口被弃用，可以写弃用注释DEPRECATED 格式 个人建议格式依赖IDE，如果你有自己的坚持，那么先配置IDE 一行不能太长，不然别人要缩放屏幕或者拖动水平滚动条，#include语句除外 使用UTF-8编码（GB-2312的中文注释用UTF-8打开就是乱码） 只使用空格而非制表符，IDE都支持将制表符替换为空格，建议一个制表符=4个空格 返回类型，函数名，前几个参数都放在头一行 空行不要超过两行","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://reubensun.com/tags/C/"}]},{"title":"光学复习","slug":"optics/光学复习","date":"2023-03-03T15:01:25.000Z","updated":"2023-03-28T02:56:19.631Z","comments":true,"path":"optics/光学复习/","link":"","permalink":"https://reubensun.com/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"光学复习 复习重点 [x] 相速度 [x] 偏振态 [x] 费马原理 [x] 横向放大率 [x] 薄透镜成像 [ ] 透镜组成像（做图法） [ ] 反射过程中的相移 [ ] 布鲁斯特角 [ ] 反射光与折射光的偏振态 [x] 全反射 [x] 相干条件 [x] 杨氏双缝干涉 [x] 时间、空间相干性 [x] 等倾干涉 [x] 等厚干涉 [ ] 迈克尔逊干涉仪 [ ] 多光束干涉 [x] 增反膜与增透膜 [x] 惠更斯-菲涅尔原理 [x] 衍射的分类 [ ] 衍射与傅立叶变换 [ ] 单缝衍射 [x] 圆孔衍射 [ ] Airy斑 [ ] 瑞丽判据 [ ] 多缝衍射 [x] 光栅方程 [ ] Abbe成像原理 [ ] 最小分辨距离、角度 [x] 光栅 [x] 双折射 [x] 惠更斯作图法 [ ] 波片 [x] 光偏振态的改变与检测 [x] 黑体辐射与光量子 作业解析 3.32 一个4.0 v白炽手电筒灯泡消耗0.25 A，将约1.0%的耗散功率转化为光(λ≈550 nm)。如果梁的截面积是10平方厘米，近似圆柱形 (a)每秒发射多少光子?(b)每米光束中有多少光子?©光束离开手电筒时的通量密度是多少? a 根据功率和光的能量公式 $$ P=UI $$ $$ n\\hslash c/\\lambda=0.01P $$ 求出n b 每米光子数=光子总数/长度 $$ nt=ct $$ $$ c=3.0\\times 10^8 $$ c $$ 密度=0.01P/S $$ 8.4 描述下列光的偏振态 根据xy的振幅和相位判断偏振态 $$ \\delta=(E_x/E_y)\\Delta \\varphi $$ ab $$ E_x/E_y=-1 $$ $$ phase(E_x)=phase(E_y) $$ 偏振方向为 $$ -\\pi/4 $$ c $$ E_x/E_y=1 $$ $$ phase(E_x)=phase(E_y)+\\pi/4 $$ 偏振方向为 $$ \\pi/4 $$ d $$ E_x/E_y=1 $$ $$ phase(E_x)=phase(E_y)-\\pi/2 $$ 偏振方向为 $$ -\\pi/2 $$ 记偏振态的技巧 $\\delta = 0$时，是一个左下到右上的线偏振，随着$\\delta$增大，偏振的形状呈正弦形状，左顺右逆 7.36 证明组速度可以写成 $$ v_g=\\frac{c}{n}+\\frac{\\lambda c}{n^2}\\frac{\\mathrm{d}n}{\\mathrm{d}\\lambda} $$ 证明 5.5 考试例题 求反射光偏振 根据shell公式求折射角 $$ 1 \\times \\sin \\theta = n\\sin \\gamma $$ $$ \\gamma = 18.7^{\\circ} $$ 根据菲涅尔公式求出反射光ps偏振比 $$ r_p=\\frac{\\tan (\\alpha - \\gamma)}{\\tan (\\alpha + \\gamma)}=0.176 $$ $$ r_s=-\\frac{\\sin (\\alpha - \\gamma)}{\\sin (\\alpha + \\gamma)}=-0.261 $$ 得到反射光ps分量 $$ E_p=r_pE_0\\cos 45^\\circ $$ $$ E_s=r_sE_0\\sin 45^\\circ $$ 求反射光的偏振和入射面的夹角$\\theta’$ $$ \\theta’=\\arctan|\\frac{r_s}{r_p}|=\\arctan 1.483=56^\\circ $$ 由于入射角小于布鲁斯特角 $$ \\alpha_B = \\arctan n=57.3^\\circ $$ 所以ps都有相位移，合成后仍在13象限","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：光源","slug":"optics/光源","date":"2023-03-03T10:01:30.000Z","updated":"2023-03-28T02:56:19.631Z","comments":true,"path":"optics/光源/","link":"","permalink":"https://reubensun.com/optics/%E5%85%89%E6%BA%90/","excerpt":"","text":"十一：光源 内容概述 黑体辐射 光电效应 波粒二象性 黑体辐射 室温下的铁是黑灰色，高温下是暗红色，极高温下是橙色 任何温度大于绝对零度的物体，都会发出热辐射（Thermal radiation），这是由带电粒子随机运动产生的 处于平衡状态的物体，能量吸收率等于释放率，高吸收伴随着高释放 基尔霍夫辐射定律 将一个物体置于一个等温真空室中，物体会吸收真空室中的热辐射，达到相同的温度（无论物体和环境的材质） 处于热平衡的物体满足 $$ R/\\alpha=I $$ $R$，Radiation，物体的辐射率 $I$：Irradiance，真空室的辐照度 $\\alpha$：吸收率 基尔霍夫辐射定律：在热平衡状态下，光谱辐照度和光谱吸收系数之间的比值仅与辐射波长和温度有关，与辐射物体本身的性质无关。 $$ f(\\lambda, T)=\\frac{r(\\lambda, T)}{\\alpha(\\lambda, T)} $$ 联系两个方程可得：好的吸收器是好的发光器（A good absorber is a good emitter） 黑体 黑体：在任何温度和波长下，吸收率$\\alpha$都为1的材质 $$ \\alpha \\equiv 1 $$ 黑体辐射实验 光电效应 光量子假说 爱因斯坦提出光量子假说，成功解释了光电效应的实验现象 康普顿散射 1923年，康普顿发现，当x射线穿过石墨和金属等材料时，除了波长不变的散射外，还存在散射光子，随着散射角的增大，其波长也会变大。 波粒二象性 激光 原子能级跃迁，从高能态到低能态，会发射激光 激光（Laser，Light Amplification by Stimulated Emission of Radiation）","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：各项异性","slug":"optics/各向异性","date":"2023-03-02T10:01:30.000Z","updated":"2023-03-28T02:56:19.632Z","comments":true,"path":"optics/各向异性/","link":"","permalink":"https://reubensun.com/optics/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7/","excerpt":"","text":"十：各向异性 内容概述 光在各向异性的介质中的传播 偏振 双折射晶体 透过双折射晶体（比如方解石晶体），在某些角度只有一个像，在某些角度会有两个像 双折射 现象：一束光经过晶体后被分为了两束光 我们称之为o光和e光 o光：按折射定律传播的光 e光：不按折射定律传播的光 光轴：光束沿着光轴传播时，o光和e光不分开（这个方向两个折射率是相同的） 主截面：界面法线和光轴构成的平面 主平面：晶体内光线和光轴构成的平面 o光和e光都是线偏振光，o光的振动方向与主平面垂直，e光的振动方向与主平面平行 单轴晶体：只有一个光轴的晶体，比如方解石、石英 双轴晶体：有两个光轴方向的晶体，比如云母、蓝宝石、硫磺 o光和e光的光速不同，波面形状也不同 o光沿各个方向的传播速度相同，于是波面是一个球 e光沿着不同方向传播速度不同，我们特别的选取垂直于光轴的面作为e光的波面，这个波面是一个椭圆 这两个椭圆是相切的，但大小不确定 若o光比e光大，那么是正晶体 若o光比e光小，那么是负晶体 惠更斯作图法 偏振态：我们在光线上各距离绘制短线和圆点，用来表示偏振 短线表示偏振沿着纸面 点表示偏振垂直纸面 自然光横线和点的数量应该一样多 绘制折射光 过A点做边缘光线的垂线AB，垂足为B 我们能求出光线的传播时间$t=\\overline{BB’}/c $ 以A为圆心，做一个半径为$\\mathrm{v}_o t$的圆，这是o光波面 以A为中心，做一个半轴为$\\mathrm{v}_o t 和 \\mathrm{v}_e t$的椭圆，椭圆要和圆在光轴处相切 从B’出发做圆和椭圆的切线，切点为$A’_o,A’_e$ o光折射光为$AA’_o$ e光折射光为$AA’_e$ 光的偏振 由于晶体可以分离o光和e光，因此可以做成偏振器 光的偏振状态 回忆一下 光有五种偏振状态 自然光 部分偏振光 线偏振光 圆偏振光 椭圆偏振光 光偏振状态的检验：将光通过检偏器，旋转检偏器，通过光强的变化判断 无变化：自然光、圆偏振光 有变化但没有消光：部分偏振光、椭圆偏振光 有变化且有消光，线偏振光 仅通过检偏，只能简单分出三类光，无法更近一步区分偏振态，而使用晶体可以明确知道偏振态 马吕斯定律：线偏振光经过检偏器，光强满足 $$ I=I_0\\cos^2\\varphi $$ 布鲁斯特定律：光线以大于布鲁斯特角入射，反射光是线偏振光 $$ \\tan i_B=\\frac{n_2}{n_1} $$ 光在晶体中的传播 洛匈棱镜 由两块冰洲石构成 左侧光轴平行纸平面和入射光，光线进入时不会发生双折射 右侧光轴垂直纸平面，光线进入后o光变e光，e光变o光 沃拉斯顿棱镜 光线进入左侧，o光和e光方向不变，速度改变，e光会比o光快 尼科尔棱镜 偏振光的获取和检验 核心思想为垂直振动和合成，任何一个偏振态，都是两个垂直振动的合成 所有偏振态都是由两垂直的线偏振光合成，两者的相位差$\\delta$将决定合成的是何种偏振光 $\\lambda/4$波晶片能带来$\\pi/2$的相位差 光通过晶体时，o光和e光可能方向不变，相位差改变，通过调整两者间相位差，就能得到圆偏振、椭圆偏振 求出射光偏振态 出射光相位差=入射光相位差+波晶片相位差 偏振光检验 使用偏振片将五种偏振光变为三组 对于自然光和圆偏振光那一组 光线继续通过$\\lambda/4$波晶片，如果变为线偏振光，则为圆偏振光 对于部分偏振光和椭圆偏振光那一组 将偏振片旋转至光强最强处 将$\\lambda/4$波晶片光轴旋转至与偏振片透振方向平行 去除偏振片，光线继续通过$\\lambda/4$波晶片 此时o光和e光与椭圆主轴一致，若变为线偏振光，则为椭圆偏振光 左右旋检验 一个圆偏振片，通过$\\lambda/4$波晶片，再通过透振方向为斜对角线的偏振片 旋转偏振片，若发现有消光位置，则停止旋转（圆偏振通过波晶片变线偏振，透过偏振片会有消光），此时透振方向和线偏振光偏振方向垂直 若透振方向为一三象限，入射光为右旋 若透振方向为二四象限，入射光为左旋","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：傅立叶变化光学","slug":"optics/傅立叶变化光学","date":"2023-03-02T10:01:25.000Z","updated":"2023-03-28T02:56:19.630Z","comments":true,"path":"optics/傅立叶变化光学/","link":"","permalink":"https://reubensun.com/optics/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E5%8C%96%E5%85%89%E5%AD%A6/","excerpt":"","text":"八：傅立叶变换光学 内容概述 衍射系统的屏函数 夫朗禾费衍射的傅立叶频谱分析 阿贝成像原理和相衬显微镜 变换光学 前面几章，我们使用波的叠加来分析描述干涉衍射，而傅立叶变化光学中，我们使用光场变换的观点来看待干涉衍射 傅立叶光学的本质就是将复杂的光学现象切分为多个不同频率、不同取向的正弦光栅之和 傅立叶展开的本质是将复杂的函数切分为多个三角函数之和 屏函数 衍射屏左侧的空间叫照明空间，其中的场被称为入射场$\\tilde{U}_1$ 衍射屏右侧的空间叫衍射空间，其中的场被称为衍射场$\\tilde{U}_2$ 接收屏处的场叫接收场$\\tilde{U}$ 使用屏函数$\\tilde{t}$来描述衍射屏对入射光的波前的改变 $$ \\tilde{t}(x,y)=\\frac{\\tilde{U}_1}{\\tilde{U}_2}=t(x,y)\\exp [i\\varphi_t(x,y)] $$ $t(x,y)$是屏函数的模，若模为固定值，则该衍射屏为相位型。比如透镜、棱镜 $\\varphi_t$是屏函数的相位，若相位为固定值，则该衍射屏为振幅型。比如单孔、圆孔 相因子判断法 正弦光栅衍射 正弦光栅从数学上，就是傅立叶级数的基函数 光栅 光栅：具有周期性的空间结构或光学性能的衍射屏统称为光栅 光栅的种类： 透射光栅、反射光栅 平面光栅、凹面光栅 黑白光栅、正弦光栅 一维、二维、三维光栅 阿贝成像原理 衍射屏的屏函数可以展开为傅立叶级数 相衬显微镜 显微镜看的切片都很薄，对光的吸收很小，如果不染色，很难引起透射光振幅的变化，因此显微镜是相位型的 如果我们想要显微镜看东西更清楚，可以通过增加相位移的方式增大图像的反衬度（衬比度）","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：衍射","slug":"optics/衍射","date":"2023-02-25T10:10:25.000Z","updated":"2023-03-28T02:56:19.634Z","comments":true,"path":"optics/衍射/","link":"","permalink":"https://reubensun.com/optics/%E8%A1%8D%E5%B0%84/","excerpt":"","text":"七：衍射 内容概述 衍射（Diffraction），光在传播途中偏移直线传播，强度重新分布的过程 惠更斯-菲涅尔原理 定量分析衍射 统一衍射和直线传播 衍射 衍射是光在传播途中偏移直线传播，强度重新分布的过程 物体遮挡光线，就会产生阴影 在几何光学中，平行光只会被完全遮挡/完全不遮挡，因此阴影应该是清晰的 但现实中的平行光阴影是软阴影，其实就是发生了衍射 点、面光源的软阴影是由于光源由尺寸 一组平行的波阵面通过小孔，会变成圆形 波长越长，越容易观测到衍射 小孔尺寸在波长的1000倍左右时衍射现象不明显 小孔尺寸在波长的10倍左右时衍射十分明显 小孔尺寸和波场相近时会发生散射 衍射的分类 菲尼尔衍射（近场衍射）：光源和接收屏距离有限 夫朗禾费衍射（远场衍射）：光源和接收屏距离无限（也就是入射光是平行光） 夫朗禾费衍射需要用透镜将平行光汇聚 光栅衍射 多光束干涉和单缝衍射的混合 多光束干涉决定明条纹位置 $$ d\\sin \\theta=k\\lambda $$ 缺级 $$ k=\\frac{d}{a}k’ $$ 干涉与衍射的关系 相同： 干涉和衍射都是相干叠加 不同： 干涉是离散点光源叠加求和，衍射是连续次波源叠加积分 干涉满足几何光学规律，衍射不满足几何光学规律 惠更斯-菲涅尔原理 惠更斯 惠更斯：波阵面上每一个点，本质上是一个球面次级小波的发射源，下一个波阵面实际上是这些球面的包络线（envelope） 理论的作用 根据这个理论，给定一个波阵面，我们可以画出下一个波阵面 解释了光在各向同性介质中的传播原理 解释了反射和折射公式 局限性 无法区分光沿直线传播和发生衍射的条件 无法定量分析衍射强度 根据该理论，应该会有反转波 菲涅尔 菲涅尔修正了惠更斯的理论 波阵面上每一个（无阻塞）点都是球面波的发射源，频率与主波相同 不在波阵面上的点，都是由小波相干叠加得到的 衍射是无数干涉的叠加 倾斜因子 惠更斯的理论会应该会存在向后的波，菲涅尔引入了倾斜因子（Tilt factor） $$ F(\\theta_0, \\theta)=\\frac{1}{2}(\\cos\\theta_0+\\cos \\theta) $$ 倾斜因子的引入使得向后的波强度为0，自然就不会出现反转波 不过倾斜因子的引入是纯经验，这也是菲涅尔理论的局限性 基尔霍夫积分定律 基尔霍夫在倾斜因子的基础上添加了一个常数K，提供了一个$-\\pi/2$的相位差 $$ K=\\frac{e^{-i\\pi/2}}{\\lambda} $$ 于是衍射积分公式转化为： 巴俾涅原理 两个互补的衍射屏叠加，效果等同于自由传播 半波带法 下图为单缝夫朗禾费衍射，计算方法为半波带法 波带数 $$ \\frac{a \\sin \\theta}{\\lambda/2} $$ a是衍射屏孔径 暗纹位置（暗纹准确，明纹不准确） $$ a \\sin \\theta = \\pm k \\lambda $$ 中央明纹宽度 $$ \\Delta x_0=2f\\frac{\\lambda}{a} $$ 衍射图样 单缝衍射 圆孔衍射 圆孔衍射：亮暗相间的同心圆环，中心可能是暗也可能是亮的 中心强度与孔径明暗，与屏幕距离不敏感 Airy斑：中心圆斑 瑞丽判据：如果一个物点的Airy斑的边缘在另一个Airy斑中心上，那么这两个物点恰好可分辨 圆屏衍射 圆屏衍射：亮暗相间的同心圆环，但中心总是一个亮点 亮点与物体大小、屏幕距离都无关，这个亮点我们称为柏松亮斑 一个圆球的影子，中心居然会有一个亮点，衍射，很神奇吧 光栅衍射 菲涅尔波带片 根据菲尼尔衍射原理，将偶数个半波带遮挡住，就能得到菲涅尔波带片（就是对一个平整的圆形玻璃，将其表面部分图黑一个个同心圆环） 若一个波带片有20个半波带，遮挡偶数个半波带，轴上中心点的光强为 $$ A’=A_1+A_2+A_3+A_4+A_{19}\\approx 10A_1=20A_0 $$ $$ I’=A’^2=400A_0^2=400I $$ 我们发现中心点的光强变强，因此菲涅尔波带片相当于透镜，可以汇聚光强 涂黑半径 $$ \\rho_K=\\sqrt{k}\\rho_1 $$ k取1,2,3… 成像公式 $$ \\frac{1}{R}+\\frac{1}{b}=\\frac{1}{f} $$ R：点光源到波带片的距离 b：波带片到汇聚点到距离 波带片与透镜 相同 都能汇聚能量 不同 透镜只有一个汇聚点，波带片有多个实汇聚点和虚汇聚点 透镜满足等光程性，波带片相邻波带片间有一个波长的光程差 波带片面积大、轻便、可折叠","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：干涉","slug":"optics/干涉","date":"2023-02-25T10:01:25.000Z","updated":"2023-03-28T02:56:19.633Z","comments":true,"path":"optics/干涉/","link":"","permalink":"https://reubensun.com/optics/%E5%B9%B2%E6%B6%89/","excerpt":"","text":"六：干涉 内容概述 干涉（Interference），光的叠加不满足线性叠加，证明了光的波性 干涉条件 干涉方法与装置 干涉仪 干涉 干涉让光学从线性光学变成非线性光学 线性光学 在几何光学中，我们认为光是独立传播的 光是一种横波，光在介质中传播会引起介质粒子振动，若独立传播成立，那么两束光的交叉区域，粒子的振动是两个振动的叠加，这就是叠加原理 光的叠加实际上是介质的性质（因为描述的是介质粒子振动的叠加） 线性介质：在该介质中，波满足叠加原理 非线性介质：在该介质中，波不满足叠加原理 违反叠加原理的介质是非线性介质，现象是非线性现象，学科是非线性光学 此外，叠加原理只有在低强度光下才成立，因此激光发明后，非线性光学才蓬勃发展 复振幅叠加法 求解相干光强有三种方法，实际分析时通常使用复振幅法 三角函数法：波可以由三角函数表示，对三角函数做恒等变化，即可求相干光强 矢量图解法 复振幅法 首先将三角函数表示为复振幅 $$ \\tilde{\\mathbf{E}_i}=\\mathbf{A}_i e^{i\\varphi i} $$ 复振幅的叠加 $$ \\tilde{\\mathbf{E}}=\\sum{i=1}^n\\tilde{\\mathbf{E}_i} $$ 合光强 $$ I = \\tilde{\\mathbf{E}}\\cdot \\tilde{\\mathbf{E}}^* $$ 相干叠加 现在有两个相同频率（frequency）相同偏振（polarization）的光波，下面是他们电场强度随时间的变化（用复数表示三角函数） $$ \\mathbf{E_1}=\\mathbf{A_1} e^{i(kr_1-\\omega t+\\varphi _{01})} $$ $$ \\mathbf{E_2}=\\mathbf{A_2} e^{i(kr_2-\\omega t+\\varphi _{02})} $$ 他们相交于点P，根据叠加原理，P点点电场强度为 $$ \\mathbf{E}=\\mathbf{E_1}+\\mathbf{E_2}=[\\mathbf{A_1}e^{i(kr_1+\\varphi_{01})} + \\mathbf{A_2}e^{i(kr_2+\\varphi_{02})}]e^{-i\\omega t} $$ 显然，振幅为 $$ \\tilde{\\mathbf{E}}=\\mathbf{A_1}e^{i(kr_1+\\varphi_{01})} + \\mathbf{A_2}e^{i(kr_2+\\varphi_{02})} $$ 由于光过于高频，我们没法实时进行光电场强度的检测，于是我们使用光强（intensity，$I$）来进行推导 $$ I \\propto \\tilde{\\mathbf{E}}\\cdot \\tilde{\\mathbf{E}}^*=\\mathbf{A_1}^2+\\mathbf{A_2}^2+2\\mathbf{A_1A_2}\\cos(kr_1-kr_2+\\varphi_{01}-\\varphi_{02}) $$ $$ I = I_1+ I_2 + 2\\sqrt{I_1I_2}\\cos \\delta $$ $$ \\delta=kr_1-kr_2+\\varphi_{01}-\\varphi_{02} $$ 我们发现，两个光波进行叠加，光强不只是简单叠加，还有一个尾巴，这个尾巴就是干涉 干涉：因波的叠加引起强度重新分布的现象 并且我们发现： 干涉强度与时间无关，与空间位置有关，且保持不变 当$\\delta=2m\\pi$，干涉强度最大，我们称之为构造干涉（constructive interference） $$ I=(\\mathbf{A_1}+\\mathbf{A_2})^2 $$ 当$\\delta=(2m+1)\\pi$，干涉强度最小，我们称之为相消干涉（destructive interference） $$ I=(\\mathbf{A_1}-\\mathbf{A_2})^2 $$ 非相干叠加 一般而言，两个光频率和偏振不一样，经过推导 $$ I_{12}=2\\mathbf{A_1}\\cdot \\mathbf{A_2} \\cos [(\\omega_2 - \\omega_1)t + \\theta_1 - \\theta_2] $$ 我们到处干涉强度为0的条件 两个光频率不同，$\\cos[…]$的均值为0 两个光光矢量垂直，$\\mathbf{A_1}\\cdot \\mathbf{A_2}=0$ 两个光夹角（相位差）迅速且无序变化，$\\cos[…]$的均值为0 干涉条件 因此我们总结出发生干涉的条件 频率相同 相同的平行分量 固定的相位差 如果不满足干涉条件，那么平均下来 $$ I=I_1+I_2 $$ 杨氏干涉 普通光源：普通光源的发光单位为原子、分子，不同原子间的发光是独立的，他们的频率、偏振、相位都是不同的，因此他们的光是不会发生干涉的 有干涉条件我们可以得出两种获得干涉光的方法： 分波前法（杨氏干涉） 分振幅法（薄膜等厚干涉） 使用杨氏干涉实验、菲涅尔双棱镜、劳埃德镜可以将普通光源变成干涉光 杨氏干涉，两束光的出相相同，因此干涉光的相位差只取决于光程差 $$ \\Delta \\varphi= \\frac{2\\pi }{\\lambda}\\Delta OPL=k\\delta $$ k：波数，$k=\\frac{2\\pi}{\\lambda}$ $\\delta$：光程差 衬比度 衬比度，也可以叫做可见度 干涉条纹的衬比度（constrast）定义为 $$ \\gamma = \\frac{I_\\max-I_\\min}{I_\\max + I_\\min} $$ 用于描述条纹的反差程度，当可见性为1时最清晰，当为0时完全不可分辨 杨氏双缝干涉实验 杨氏实验是通过两个点波光源进行干涉实验的典型 如果光是一种波，那么光在传播过程中应该会有波前（传播最靠前的波阵面），提取一个波前，并将其分为两部分，就能得到两个相干光 现在有一个非常窄的单色光源，经过两个带缝平面，会生成两个相干光，进而发生衍射现象，在平面留下明暗条纹 $$ I=A^2=4I_1\\cos^2\\frac{\\pi \\Delta}{\\lambda} $$ 若$\\Delta=m\\lambda, I=I_{max}=4I_1$，呈现亮条纹 若$\\Delta=(2m-1)\\lambda/2, I=I_{min}=0$，呈现暗条纹 杨氏干涉实验的衬比度为 $$ \\gamma = \\frac{2(A_1/A_2)}{1+(A_1/A_2)^2} $$ 当间距不大时，角度比较小，缝间距是相同的，间距为 $$ \\Delta x=\\frac{D}{d}\\lambda $$ 判断一点的暗亮 看上图 在杨氏干涉实验中，给定$d,D,x$，判断点在明条纹中还是暗条纹中 核心思想就是：判断光程差是半波长的偶数倍还是奇数倍，偶数为明条纹，基数为暗条纹 以P点为圆心，$S_1P$为半径画一个圆，圆和$S_2P$相交于点$S’$，那么$S_2S’$就是光程差 不过$S_2S’$很难求，于是我们进行近似，我们从$S_1$出发做$S_2P$的垂线，垂足可以近似为点$S’$ 我们知道斜边长度为d，只要知道$\\angle S_2S_1S’$，就能求出光程差 不过$\\angle S_2S_1S’$还是太难求了，我们用角$\\theta$来近似 $\\sin \\theta \\approx \\tan \\theta = x/D$ 有了光程差，就能知道这是几个波长，是明是暗 可见条纹的最大级数 $$ j_\\max= d/\\lambda $$ 求P点光强 $$ I=A_1^2+A_2^2+2A_1A_2\\cos \\Delta\\varphi $$ $$ \\Delta \\varphi = k \\cdot \\delta $$ 干涉条纹的移动 我们不仅观测到明暗条纹，还观测到条纹的移动和变化 移动光源，对于屏幕上一点，求多少个条纹经过该点 对于屏幕上点P，经过点P的条纹数取决于两条相干光线的光程差（OPL） 当光程差增减一个$\\lambda$时，就会经过一条条纹 移动光源，对于特定的一个条纹，求其移动了多长距离 杨氏双缝中 $$ \\delta x = -\\frac{D}{R}\\delta s $$ 其他干涉仪器 本质都是杨氏双缝干涉，条纹间距都满足 $$ \\Delta x=\\frac{D}{d}\\lambda $$ 这些干涉仪器相比起杨氏干涉，不使用狭缝过滤光，因此光线强度更高 菲涅尔双平面镜 劳埃德镜 菲涅尔双棱镜 彩色光杨氏双缝 如果传入的是白光，条纹将为彩色 时空相干性 现实中的普通光源的发光单元为原子、分子，靠自发辐射发光（激光光源靠受激辐射），这是一个随机过程，产生的光是随机、无规律、不相干的。看起来我们无法用普通光源做干涉实验，但实际上杨氏双缝是可以使用普通光源的，因为杨氏双缝中两个光都是由同一束光分割而成的 尽管普通光源的相位随机，但是杨氏双缝两束光的相位差与原光源相位无关，仅与空间位置有关 不过，光源的尺寸和光谱尺寸仍然会对杨氏干涉产生影响 在杨氏干涉中，我们使用了很窄的单色光源，然而现实中光源总是有尺寸，其颜色也不是单色而是光谱中一小段 空间相干性：光源尺寸对干涉强度的影响 时间相干性：光谱尺寸对干涉强度的影响（也就是说光不是真的纯色） 空间相干性 任何光源都有一定的宽度，我们将其视为多个不相干的点光源排布，屏幕上的总强度为各个光源的干涉条纹的线性叠加 我们发现沿着x轴方向的长度会让条纹模糊 沿着y轴方向的长度会让亮纹和亮纹重叠，于是条纹更清晰 我们在做杨氏双缝时常常使用平行于y轴方向的光 时间相干性 现实中光不是纯色光，光的波长不同，干涉条纹长度不同，于是不同波长的干涉条纹就会发生重叠，进而降低条纹的衬比度 薄膜干涉 薄膜（film）一种透明介质，将空间划分三个折射率不同的区域，其中中间的区域不能过厚 薄膜干涉（Thin film interference）：光在薄膜表面发生反射和折射，下表面的反射光和上表面的折射光发生干涉 比如彩色太阳眼镜和阳光下的七彩肥皂泡 光线在射向薄膜后会发生反射和透射，透射光可能会再次反射透射，返回薄膜表面，进而和入射光相遇，发生干涉 等厚干涉：发散的入射光（点光）和透射光干涉，干涉发生在薄膜表面 等倾干涉：平行的透射光干涉，干涉发生在无穷远，需要用透镜汇聚，形状为同心条纹 特别注意！等厚和等倾是指的条纹间距，而不是薄膜形状，等厚的条纹需要上下不平行的薄膜 等厚度干涉 等厚干涉发生在薄膜表面 厚度不均匀的薄膜发生的干涉，入射光为平行光，决定条纹间距的是因厚度不均带来的光程差 $$ \\delta = 2nh\\sqrt{n^2-n_0^2\\sin^2 i_1} +\\lambda/2 $$ $i$是折射角 常见的等厚干涉有 劈尖：光线垂直入射 角度越大，条纹数量越多 折射率越大，条纹间距越大 牛顿环 增透膜与高反膜 汽油膜，肥皂泡，昆虫翅膀 厚度均匀的薄膜发生的干涉，入射光为平行光，各个方向的干涉增强被分离出去 增透膜 n2的反射光被干涉相消，根据能量守恒，透射光会更多 折射率 $$ n=\\sqrt{n_1n_2} $$ $$ n_1 &lt; n &lt; n_2 $$ 厚度 $$ h=\\frac{\\lambda_0}{4n} $$ 增反膜 反射被干涉增强，透射光会减少 折射率 $$ n &gt; n_1 且 n &gt; n_2 $$ 厚度 $$ h=\\frac{\\lambda_0}{4n} $$ 等倾斜角干涉 等倾干涉发生在无穷远处 上下表面平行的薄膜发生的干涉，入射光为点光源 $$ \\delta = 2nh\\cos i_2 $$ 半波损失 波从光疏射向光密，在反射过程中会产生$\\pi$个相位跃变，我们称之为半波损失 由于半波损失的存在，薄膜干涉明暗条纹的产生条件实际上与杨氏双缝相反 $$ \\delta = 2nh\\cos i_2 + \\lambda/2 $$ 等倾图样 内高外低，内疏外密 干涉仪 多光束干涉 $$ \\Delta L=2nh\\cos i $$ 光在介质内不断反射折射，新的反射折射光强度成等比数列 迈克耳孙干涉仪 使用分振幅法将两个相互垂直的平面镜等效为空气薄膜，空气薄膜可以等倾，也可以等厚 法布里-珀罗干涉仪 由两个梯形透镜组成，用于生成等倾干涉条纹","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"提问的智慧","slug":"program/AskQuestion","date":"2023-02-18T10:01:25.000Z","updated":"2023-03-28T02:56:05.036Z","comments":true,"path":"program/AskQuestion/","link":"","permalink":"https://reubensun.com/program/AskQuestion/","excerpt":"","text":"提问的智慧 提问的方式，可能会很大程度影响你是否能得到有用的回答 树立好的形象 当你想问问题，一定要树立你的形象：我已经做了努力，我不是一个不劳而获且浪费别人时间的提问者 你可以做的努力有 网上搜素 查看文档、手册、issuse 看看源码 自己先做试验 问题不要带有错误的预设 草率的发问只会得到草率的回答，如果你的预设错了，下面的尝试和思考都是无用功 很多民科认为自己推翻了相对论、微积分，很有可能是使用了一个错误的预设 not even wrong Q：你是哪个省的 Right：四川省 Wrong：西藏省 Not even wrong：妈妈生的 不要明知故问 特别要批评哪些为了“耍存在感”而明知自问，列举了一大串知识试图诱导他人的思路，然后在最后向别人进行提问 不要认为自己够格得到回答 如果你没有为这个问题付费，那你不要期待自己一定能得到好的回答，你需要通过靠提出有内涵的、有趣的、有思维激励作用的问题挣得回答 选择正确的提问地点 不要在主题不和的论坛贴出你的问题 比如在NS吧问原神好不好玩，在A9问XGPU是否值得购买 不要在进阶的论坛中问低级问题，反之亦然 比如你认为火箭燃料应该用水洗煤，在太空应该用铅笔替代 不要在不同的论坛反复问同一件事 这让人感觉你在大喊大叫 不要向陌生人发私人邮件 你没有付费，别人就没有必要回答，更不要说私聊对方让他“加班” 可以试一试在Stack Overflow问程序相关的问题 向一个群体提问，而非个人 个人没有义务回答你的问题 向群体问一个好问题能对整个群体有益，你的提问可以被后来者看到 向群体问问题能减轻某个个人的压力 描述问题 使用有意义的标题 使用目标-差异做标题 X.org 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形 言之有物 低声下气不如清晰地说明情况 不要使用 大佬，求救 在线等，很急 我是一个菜鸡，呜呜呜 有人能帮帮我吗 如果你真的很菜，你可以去一些更入门的论坛去搜寻答案（菜的远远不止你一个人，因此你遇到的问题很可能其他人也会遇到） 不要擅自声称找到bug 如果你没有非常明确的根据，不要擅自声称找到了bug（很可能是因为你不会用导致的） 如果你对该软件还没有足够的了解，就声称自己遇到的困难是bug，这可能会惹恼软件作者 即使真的有bug，你最好要写的像是你做错了什么，给开发者一个台阶下，他可能反过来给你说抱歉 不要进行猜测 如果你的猜测有效，那还用向别人求助吗？ 你认为问题是怎么来的并不重要，重要地是描述问题本身，你的错误推测甚至可能会影响回答者的思路 蠢问题 我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下… 按时间顺序描述问题症状 描述目标而非过程 蠢问题 我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？ 聪明问题 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。 问题解决后 问题解决后你应该感谢帮助你的人 将标题修改为已解决，并在最后补充说明，你是如何解决问题的 参考 How to Ask Question","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://reubensun.com/tags/PM/"}]},{"title":"Dynamic Occlusion with SDF","slug":"graphics/DOSDF","date":"2023-02-13T10:01:25.000Z","updated":"2023-03-28T02:56:19.622Z","comments":true,"path":"graphics/DOSDF/","link":"","permalink":"https://reubensun.com/graphics/DOSDF/","excerpt":"","text":"Dynamic Occlusion with SDF 2015年SIGGRAPH，epic提出一种基于SDF的occlusion算法 问题 需要找到一种比较好的动态物体occlusion算法，应满足 软（soft）、准确（accurate）、不连续（incoherent） 能用于阴影、天空、反射球 现存的动态oc技术都有局限性 shadowmap：连续 SSAO：丢失边界和被撤档区域的信息 Voxel cone tracing：耗费大，处于性能考虑没法使用过高精度 预计算的体积AO：自阴影分辨率低，难以避免被多个物体过度遮挡 SDF SDF SDF（Signed Distance Field）有很多用处，比如体积建模，比如加速射线检测 float sdf(float3 pos, args...)&#123; if(pos 在模型表面)&#123; return 0; &#125; else if(pos 在模型外)&#123; return pos距离模型表面最近的距离; &#125; else&#123; return -pos距离模型表面最近的距离; &#125; &#125; SDF体积建模 // 以原点为球心的球 float sdfSphere(float3 pos, float r)&#123; return length(pos) - r; &#125; // 以原点为中心的长方形 float sdfBox(float3 pos, float3 box)&#123; float3 q = abs(pos) - box; return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0); &#125; SDF射线检测","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"GI","slug":"GI","permalink":"https://reubensun.com/tags/GI/"},{"name":"SIGGRAPH","slug":"SIGGRAPH","permalink":"https://reubensun.com/tags/SIGGRAPH/"}]},{"title":"SSSR","slug":"graphics/SSSR","date":"2023-02-10T01:16:25.000Z","updated":"2023-03-28T02:56:19.624Z","comments":true,"path":"graphics/SSSR/","link":"","permalink":"https://reubensun.com/graphics/SSSR/","excerpt":"","text":"Stochastic Screen Space Reflections 2015年SIGRAPH，EA提出了SSSR，用于《镜之边缘》中镜面反射 需求有 支持清晰（sharp）和模糊（blurry）反射 邻接性，越近反射越清晰（contact hardening） 高光拉伸 逐像素的粗糙度和法线 相关工作 mirror-only SSR 我们先回顾传统的SSR 从屏幕像素开始RayMarching（需要View空间的世界坐标和法线） 根据深度可以很轻松找到第一个落点，根据法线很容易求出反射光线的角度 使用简单的线性步进，求反射光线的命中点 反射光线向前步进一段距离，到达C点 通过三角形边角性质，可以求出C点距离镜头的距离，这其实就是View空间的深度 若C点距离镜头的距离小于等于深度，则说明命中 将命中位置进行透视投影，使用上一帧的渲染结果作为反射颜色 glossy SSR 模糊滤波 杀戮尖塔提供了一种glossy SSR，就是对反射像素做一次卷积模糊，但这种模糊是一视同仁的模糊，没有实现越近越清晰 重要性采样 相对于普通的SSR，这里根据法线求反射光线方向时，加入一些随机偏差，反射光线形成了一个锥形，进而实现了模糊的SSR 当物体离反射面比较近时，根据正弦定理，滤波的像素数量更少，于是清晰度更高 但是在光线数量比较少的情况下，会有大量噪点，效果很差 作者的算法 将屏幕划分为Tile，进行一次低分辨率的光线步进，评估Tile的重要性，需要多少射线 根据材质粗糙度判断使用何种的RayMarching 昂贵的射线：借助Hi-Z的精确tracing，能得到准确的命中点 用于smooth表面 便宜的射线：简单的线性步进 用于粗糙表面（反正会做严重的滤波，不需要高精度） 使用BRDF重要性采样决定射线方向 使用邻居的采样信息进行模糊 TAA Tile评估 对于每一个Tile以1/8分辨率发射射线 判断射线（的反射光线）是否击中 若所有光线都没命中，则跳过这个Tile的步进 根据命中的比例和命中信息的差异，判断这个Tile中的像素需要多少个光线 Hi-Z tracing 详情可以去看《GPU Pro 5》 Hi-Z使用四叉树组织屏幕深度，将层次关系存储在MipMap层级中，用于加速反射光线的求交 Hi-Z的构建时，对屏幕尺寸的深度进行滤波，每次保存2x2像素中最浅的像素，也就是说最高级别的Hi-Z存储着整张图中最浅的深度 用C点表示光线在步进过程中的头坐标，我们射线求交的原理就是判断C点距离相机的距离和该点深度图的深度关系，相交处必然是一侧比C点深，一侧比C点浅 此外还有几条经验： 从相机出发的射线，落点位置是View空间该方向最浅的位置 从相机出发的射线，与落点位置的法线夹角应该大于$45^{\\circ}$ 若夹角小于$45^{\\circ}$，那么反射信息来自相机身后的内容，屏幕空间没有这些信息（可以用Cubemap补充信息） 若夹角大于$45^{\\circ}$，那么我们基本可以认为，反射光线在步进过程中，深度在不断变深 我们实际寻找的是，光线在步进过程中，比C点要深的最浅位置（更深，但只能深一点点） 由于起初我们位于最浅的位置，而步进的光线越来越深，因此第一个min-Z小于C点深度的位置，就是交点位置，我们只需要一直向右，不用回头 这样得到的Mip等级比较高，我们通过降低Mip等级，每次取比C深中最浅的那一个，直到Mip为0 算法复杂度为$O(\\log n)$ 重要性采样 重要性采样是蒙特卡洛积分中用于减少方差的算法，详情可以去看PBRT 简单来说就是我们有一个积分，我们不得不实时求这个积分，于是我们将这个积分很多项分离出去，最后变成了 复杂离散项 x 一段简单函数的积分 蒙特卡洛积分 这是一个三角形，如果我们想求三角形的面积，可以对三角形的高度函数做积分 第一种切分方法：均匀切分，三角形被分为等宽的长方形，每个长方形长$\\Delta x$，高$\\sqrt{1-x^2}$ $$ S=\\sum _{i=0}^N \\Delta x \\times h_i $$ 第二种切分方法：重要性切分，左侧长方形更窄，右侧更宽 $$ S=\\sum _{i=0}^N x_i \\times h_i $$ 三角形切被分为一个个长方形，长方形的面积代表贡献。很显然，左侧的长方形高度越高，相同宽度面积越大，贡献越多。也就是说，相同的x轴变化，左侧部分对积分的影响越明显，越高频 能看出（在同等误差下）重要性采样所需要的采样次数比均匀采样要小 重要性采样的思想就是，在高频处我们进行更多次的采样，低频处进行更少的采样，最后根据权重合并，就能在采样次数比较少的情况下，得到最精确的积分值 高度函数$h_i$就是采样值 宽度函数$x_i$就是重要性权重 面积$S$就是在当前概率分布下的采样期望 概率密度函数 详情可以去看概率论 在上一步，我们将连续函数的积分，转化为离散的采样值 x 重要性权重，然后我们发现，这个重要性权重怎么求？ 还是上面的三角形，我们发现横坐标可以取[0, r]中任意值（r为三角形边长） 因此具体到某个点（随机变量），被取到的概率为$\\frac{\\mathrm{d}x}{r}$（这里其实不怎么精确，概率论中点取到的概率为0，这里实际上是一段很小的区域被取到的概率） 对于一个区域[a, b]，我们进行积分，得到随机变量取到该区域的概率P $$ P(a &lt; X \\le b)=F(b)-F(a)=\\int_a^b \\frac{1}{r}\\mathrm{d}x=\\frac{b-a}{r} $$ 分布函数：$F(x)$ 概率密度函数：$1/r$，我们用$p(x)$表示 概率：$P(a &lt; X \\le b)$ 哦，现在我们知道了这个重要性权重有多大了 $$ x_i=\\Delta x/P=1/p(x) $$ 进而我们可以写出这个三角形面积的期望 $$ S=\\sum _{i=0}^N x_i \\times h_i=\\lim {N \\rightarrow \\infty}\\frac{1}{N}\\sum{k=1}^{N}\\frac{f(x_k)}{p(x)} $$ 不过，值得注意的是，我们上面使用的PDF是均匀的，其实并能很好地加速收敛，实际会使用一个和原函数形状类似的PDF来加速收敛（PDF的选择不会影响最终结果，但是会影响收敛速度） BRDF生成射线方向 BRDF，双向反射分布函数，用于描述光线进出材质后能量的变化 我们在实现BRDF时，通常会实现以下接口 eval：给定入射光方向和视线方向，求BRDF值 sample：生成射线方向 pdf：返回sample生成的射线的PDF 我们以最简单的phong着色为例 在RTOW中，我们朝着随机半球方向生成向量，该向量就是新射线的方向，同时求出该方向的PDF 我个人理解，射线方向是随机生成的，每个方向出现的可能性相同，但是他们的PDF不同，你可以理解为重要性采样求三角形面积时，每个大长方形是由内部多个（数量相同）等高的小长方形拼成的，但是小长方形的宽度不一致，1/PDF就是小长方形的宽度。越重要的地方，长方形宽度越小，越密集，于是实现了重要性采样 virtual bool scatter( const ray&amp; r_in, const hit_record&amp; rec, color&amp; alb, ray&amp; scattered, double&amp; pdf) const override &#123; auto scatter_direction = rec.normal + random_unit_vector(); // Catch degenerate scatter direction if (scatter_direction.near_zero()) scatter_direction = rec.normal; scattered = ray(rec.p, unit_vector(scatter_direction), r_in.time()); alb = albedo->value(rec.u, rec.v, rec.p); pdf = dot(rec.normal, scattered.direction()) / pi; return true; &#125; 上面生成新射线方向时，使用法线+球面向量，最后的形状就类似下图红色 还清除了朝下（射向材质内部的）的射线 随机数 作者使用了Halton Sequences生成随机数，并引入了截断，角度有最大值，这样能减弱BRDF的长尾巴（Tail）对结果的影响（这些尾巴会带来很多噪点） float2 u = halton(sampleIdx); u.x = lerp(u.x, 1.0, bias); importanceSample(u); 过滤重要性采样 一种基于预计算的光追，我们假设射线是圆锥形，我们可以根据MipMap层级得到滤波结果 复用邻居光线 复用 上面提到glossy ssr会导致严重的噪点问题，即使使用重要性采样，每个像素仍需要大量光线才能得到低噪点的结果 我们注意到，相邻像素，他们的位置相近，可见性应该也是接近的，那么邻居像素朝某方向发射的光线，其实也可以被当前像素复用 当然直接做模糊（比如用高斯滤波）会导致很多光斑，经过很多数学推导和近似后，给出了以下公式 result = 0.0; weightSum = 0.0; for(auto&amp; pixel : neighborhood)&#123; weight = localBRDF(pixel.hit) / pixel.hitPDF; result += color(pixel.hit) * weight; weightSum += weight; &#125; result /= weightSum; 稀疏 受邻居光线的启发，我们完全没必要每个像素都做射线，只需要在低分辨率下某些点做多次射线，其邻居使用这个射线结果就可以 TAA 我们不仅在空间上做射线的复用，也可以在时间上及逆行复用 参考 SSR","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"GI","slug":"GI","permalink":"https://reubensun.com/tags/GI/"},{"name":"SIGGRAPH","slug":"SIGGRAPH","permalink":"https://reubensun.com/tags/SIGGRAPH/"},{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"Probe-based Lighting in Unity Enemies","slug":"graphics/UnityEnemies","date":"2023-02-10T01:16:25.000Z","updated":"2023-03-28T02:56:19.626Z","comments":true,"path":"graphics/UnityEnemies/","link":"","permalink":"https://reubensun.com/graphics/UnityEnemies/","excerpt":"","text":"Probe-based Lighting in Unity Enemies 2022年SIGGRAPH，Unity发布了一个数字人项目，在头发、眼球、GI方面效果非常好，我们来分析一下他的Probe-based GI 论文地址 感觉原理上就是在Volume GI的基础上，存了遮罩信息用于偏移采样点，使用紧凑哈希提高了空间利用率，感觉手游大世界完全可以上这个 不用Lightmap 难以处理复杂的集合体，难以处理LOD 烘焙速度慢，严重制约开发效率 无法处理动态物体，无法提供统一的光照 无法处理人物 Worse directional quality Adaptive Probe Volumes 将空间划分为相同大小的cell，将cell作为分块烘焙、分块加载的最小单位 cell被细分为brick，在几何体密集的地方，brick越细分 细分 可以参考Lumen中Build Voxel Faces，本质就是推箱子 细分的原理是使用Raycast判断一个区域有没有物体（命中点），我们使用SDF加速射线检测 我们将一个cell划分为4x4的brick，这样就有16条起始边界，这些边界构成了一个正方形 每一条边界向内发射一条长度为一的射线（使用SDF加速），若没有命中，则向内移动一格 直到所有边界都命中后，我们得到右图所示的brick 数据结构 感觉很类似与VolumeGI，由索引buffer和3DTexture组成，通过紧凑哈希来降低存储 An indirection buffer存储了cell信息，cell索引→SH指针 Spherical Harmonics Pool中存储SH信息，SH指针→SH系数 采样 采样流程：World Position → Cell Indirection → Per-Cell Brick Indirection→ Brick UVW →Trilinear Sample SH Data 基于着色点posWS生成cellPos 加载cell信息 找到该着色点位于cell中哪一个brick（brick的最低层级可能是由相机距着色点距离决定的） int localBrickIndex = floor(residualPosWS / (_MinBrickSize * pow(3, minFoundBrickLevel))); //若minFoundBrickLevel=1，那么cell被细分为3x3个brick localBrickIndex -= validArea.min; 加载brick信息 通过brick信息+offset采样3DTexture 接缝 我们根据场景几何体密度构建空间八叉树，对于稀疏空间使用精度更低的高Subdiv Level存储Probe信息，在Level交界处有时会有明显的接缝问题 解决方法：采样时加入抖动 黑斑 当我们做Probe摆放时，由于按网格和brick摆放，经常会出现Probe放在墙内的情况，这会导致墙面、地板发黑 Unity的做法是一种辐照度驱动的摆放，通过判断Probe位置处四周backface比例，来判断这个Probe的有效性 对于有效性低/无效的Probe，Unity给出的解决方案就是，让墙内的Probe变亮 Post-Bake 烘焙后遍历Probe，找到在墙内的无效Probe 搜索其邻居Probe，使用其中有效Probe进行加权插值，权重是距离的平方反比 于是墙内的Probe就成功变亮了 Pre-Bake 参考《The lighting technology of Detroit Become Human》 使用Post-Bake后，确实黑斑少了，但是我们发现墙体出现了漏光，为此我们加入了Virtual Offset（bake阶段的offset），在烘焙时，将Probe移至墙外，最后再将墙外烘焙的信息写入墙内Probe中，于是既没有破坏网格结构，也实现了墙内Probe变亮 漏光 我感觉防漏光的本质就是让墙体“变厚”，无论是摆放层面上的遮光板，烘焙时期的Virtual Offset，还是是采样层面的偏移 传统的Probe采样，薄墙体由于使用了墙壁另一面的Probe信息发生漏光。为了避免漏光，采样时通常对采样位置进行偏移（Biases） Normal Bias，采样点沿着法线方向偏移 这样做实际上让物体沿着法线方向变大了 偏移的过多/过少，都会影响效果 难以调优 View Bias，采样点朝着相机方向偏移 依赖于相机 难以调优 Validity Based Weighting 而Unity使用了Validity Based Weighting技术来减弱漏光，本质还是对采样点进行偏移 原理上是通过标记遮罩得出偏移方向，使得偏移方向基于辐照度，而非模型法线、视线， 每一个Probe存储者8bit的遮罩，用于记录其八个方向（2x2x2）的邻居是否有效 若某个邻居无效，则推动采样点远离那个邻居（计算偏移的方向和大小） 但我们现在其实只得到了偏移的方向，不知道偏移的距离 遮光板 美术可以手动摆放一个遮光板，使得某些位置上的Probe失效 这确实让房顶下面不再漏光，但是这让房顶上面的物体过黑了 Unity的做法是对遮光板内Probe的邻居进行判断 若邻居Probe都不在室内（Occluding objects），那么不会使用遮光板，使用原本的数据 若邻居有在室内的，室内物体用到该Probe时才会变黑 场景管理 将球偕信息编码在3DTexture中比较好做Streaming","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"GI","slug":"GI","permalink":"https://reubensun.com/tags/GI/"},{"name":"SIGGRAPH","slug":"SIGGRAPH","permalink":"https://reubensun.com/tags/SIGGRAPH/"},{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"Metal：TBDR","slug":"graphics/TiledDeferred","date":"2023-02-08T14:33:25.000Z","updated":"2023-03-28T02:56:19.626Z","comments":true,"path":"graphics/TiledDeferred/","link":"","permalink":"https://reubensun.com/graphics/TiledDeferred/","excerpt":"","text":"Tile Base Deferred Rendering 基于Apple M1和Metal图形库 移动端GPU渲染架构 IMR（Immediate Mode Rending），即时模式渲染，按drawcall顺序绘制 TBR（Tile Base Rendering） 将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上 FS读信息，渲染每一个tile 当FS将所有的tile渲染完毕后，将完成的frame信息写入System Memory中 TBR相较于IMR能省带宽，而移动端的性能瓶颈在于带宽 值的注意的是，TBR产生带宽优势的核心是片上存储，而非Tile 我个人感觉为什么要使用Tile，可能是因为移动端GPU规模太小，难以放下整张RT。毕竟理论上使用一张大RT的采样成本更低，比如将一组TextureArray转化为VSM，能很明显提高滤波速度 我在实际测试中发现当你隐式使用TBR时也会自动切分Tile，手动指定Tile尺寸反而增大了带宽和GPU时间（我也不清楚为什么，希望有人能给我解释一些） On-Chip Memory 片上存储（on-chip memory），是集成在GPU上的存储空间 GPU中有多种存储数据的结构，访问速度从快到慢排依次是 Register Memory（RMEM） 访问极快，不需要消耗时钟周期（除非发生了冲突或者先写后读） 只对负责对其进行读写的线程可见 Shared Memory（SMEM） 对处于同一个block所有的线程都是可见的，所以常用与数据交换 Constant Memory（CMEM） 用于存储常量数据 Texture Memory（TMEM） 用于存储常量数据 Local Memory（LMEM）和Global Memory（GMEM） LMEM只是对GMEM的一个抽象，两者存取速度上一样的 只对负责对其进行读写的线程可见 一般用来存储automatic变量 automatic变量是一种大尺寸的数据结构/数组 有缓存机制（类比cache） 其中RMEM与SMEM是集成在GPU芯片上的，其他的则是存储在显存中的（你可以类比寄存器，cache和内存） Metal使用On-Chip Mem Metal使用On-Chip Mem最大的变化就是，你不再需要在RenderPass中读取上一个Pass的贴图，传递给下一个Pass，Shader的输入值可以直接替换为上一个Pass的输出结果，并直接使用 上一个Pass的结果你也可以通过imageblock&lt;GBufferOut&gt; img_blk_gBuffer访问 -fragment float4 fragment_deferredSun(VertexOut in [[stage_in]], +fragment float4 fragment_tiled_deferredSun(VertexOut in [[stage_in]], constant Params &amp;params [[buffer(ParamsBuffer)]], constant Light *lights [[buffer(LightBuffer)]], - texture2d&lt;float> albedoTexture [[texture(BaseColor)]], - texture2d&lt;float> normalTexture [[texture(NormalTexture)]], - texture2d&lt;float> positionTexture [[texture(NormalTexture + 1)]]) + GBufferOut gBuffer) &#123; uint2 coord = uint2(in.position.xy); - float4 albedo = albedoTexture.read(coord); + float4 albedo = gBuffer.albedo; - float3 normal = normalTexture.read(coord).xyz; + float3 normal = gBuffer.normal.xyz; - float3 position = positionTexture.read(coord).xyz; + float3 position = gBuffer.position.xyz; Material material &#123; .baseColor = albedo.xyz, .specularColor = float3(0), .shininess = 500 &#125;; float3 color = phongLighting(normal, position, params, lights, material); color *= albedo.a; return float4(color, 1); &#125; Single RednerPass 类比Vulkan的SubPass 传统的延迟渲染，是一个多Pass渲染。GBufferPass生成MRT，传递给LightingPass着色输出，这个过程中会有大量的贴图IO带宽 TBDR（Tile Base Deferred Rendering）利用了Metal图形库Single RenderPass的特性 在一个Single Pass中有多个小Pass，小Pass共享一组片上存储 一个Pass运行后，会在片上生成一些临时贴图，其他Pass可以直接访问这些贴图 TBDR是Apple芯片的功能，对于安卓GPU Adreno：frameBuffer fetch deferred，提前绑定（开辟）好MRT，使用时RT不动，Pass动 Mali：pixel loacl storage deferred，将GBuffer存在on-clip mem上，于是就减少了IO消耗 drawable 当我们使用MTKView呈现渲染结果时，需要指定currentDrawable unc draw(cullingResult: CullingResult, in view: MTKView) &#123; guard let commandBuffer = RHI.commandQueue.makeCommandBuffer(), let descriptor = view.currentRenderPassDescriptor else &#123; return &#125; updateUniforms(cullingResult: cullingResult) updateParams(cullingResult: cullingResult, options: options) // 阴影投射 shadowRenderPass.draw(commandBuffer: commandBuffer, cullingResult: cullingResult, uniforms: uniforms, params: params, options: options) // TBDR tiledDeferredRenderPass.skyboxCube = cullingResult.skybox tiledDeferredRenderPass.shadowTexture = shadowRenderPass.shadowTexture tiledDeferredRenderPass.descriptor = descriptor tiledDeferredRenderPass.draw(commandBuffer: commandBuffer, cullingResult: cullingResult, uniforms: uniforms, params: params, options: options) // Post-Process postProcessRenderPass.drawableTexture = view.currentDrawable?.texture postProcessRenderPass.preTexture = tiledDeferredRenderPass.finalTexture postProcessRenderPass.draw(commandBuffer: commandBuffer, cullingResult: cullingResult, uniforms: uniforms, params: params, options: options) guard let drawable = view.currentDrawable else &#123; return &#125; commandBuffer.present(drawable) commandBuffer.commit() &#125; 我们在TBDR时，将GBuffer和Depth设为.messoryless，并不保存，这些RT将放置在Color1～4中 albedoTexture = Self.makeTexture( size: size, pixelFormat: .bgra8Unorm, label: \"Albedo Texture\", storageMode: .memoryless) ... for (index, texture) in textures.enumerated() &#123; let attachment = descriptor.colorAttachments[RenderTarget0.index + index] attachment?.texture = texture attachment?.loadAction = .clear attachment?.storeAction = .dontCare attachment?.clearColor = MTLClearColor(red: 0.73, green: 0.92, blue: 1, alpha: 1) &#125; GBuffer Pass不输出Color0，Light Pass输出Color0，保存后传递给Post-Process Pass 其实你也可以直接将Light Pass的Color0设置为view.currentDrawable?.texture，这样Light Pass的结果会直接呈现在View上 之前在这一步卡了很久，如果你不显式保存Color0，那么最后一个Pass的Color0就会成为drawable 但如果你将Color0保存，你会发现屏幕变品红色，没有报错，截帧会崩溃，其实就是你保存Color0后没有显式指定view.currentDrawable?.texture = Color0，View没有东西可以显示 参考 WWDC 2020 Metal by Tutorials","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Metal","slug":"Metal","permalink":"https://reubensun.com/tags/Metal/"},{"name":"Deferred Render","slug":"Deferred-Render","permalink":"https://reubensun.com/tags/Deferred-Render/"}]},{"title":"SPH：入门","slug":"graphics/SPH","date":"2023-02-02T22:16:25.000Z","updated":"2023-03-28T02:56:19.624Z","comments":true,"path":"graphics/SPH/","link":"","permalink":"https://reubensun.com/graphics/SPH/","excerpt":"","text":"SPH入门 SPH（Smoothed Particle Hydrodynamics）光滑粒子流体力学 A mesh-free method for the discretization of functions and partial differential operators SPH是一种基于拉格朗日视角的算法，是一种空间离散化的算法，常用于连续介质的数值模拟 材质导数的坐标 拉格朗日坐标：视角随着介质移动而移动（粒子模拟） 欧拉坐标：视角是固定的，检测穿过视角的介质流速（网格模拟） SPH进行简单流体模拟，简单来说就是 介质离散化，使用多个质点来表示流体（离散化） 对于每一个粒子，找到它附近的粒子（临域搜索） 计算密度（质量密度估计） 计算压强（控制方程，如理想气体状态方程+动量守恒），压强差、粘滞力等 更新运动状态 水体渲染（Marching Cube） 离散化 狄拉克函数 狄拉克$\\delta$函数，这是一个广义函数，其在整个定义域中积分值都集中在原点 $$ \\delta (\\mathbf{r})= \\begin{cases} \\infty &amp; |\\mathbf{r}|=0 \\\\ 0 &amp; otherwise \\end{cases} $$ 该函数仅在积分中有意义，可以通过高斯钟形函数（正态分布）逼近 在物理学中我们常用质点表示物体，但是因此使得密度函数失去了意义（因为质点没有空间），此时密度函数就塌缩成了狄拉克函数 空间中任何标量场函数，都可以用狄拉克函数表示： $$ A(\\mathbf{x})=(A*\\delta)(\\mathbf{x})=\\int A(\\mathbf{x}‘)\\delta (\\mathbf{x}-\\mathbf{x}’)dv’ $$ $dv’$是$\\mathbf{x}'$对应的体积积分变量 $A(\\mathbf{x}): \\mathbb{R}^d \\rightarrow \\mathbb{R}$，d是维度，意思就是这是一个空间函数 $\\mathbb{R}$是实数集 $\\mathbb{R}^+$是正实数集（不含0） $\\mathbb{R}^d$是d维实数集 光滑核函数 我们有了狄拉克函数，想要把连续函数来离散表示 核函数（kernel functions，smoothing kernels）是一种随着距离而衰减的函数，与高斯函数要在整个作用域积分不同，核函数是有最大影响半径的，最大影响半径用$h$表示 核函数满足 归一化 狄拉克条件 非负性 对称性 有界性 一个经典的核函数是三次样条器（cubic spline kernel） 其中$q=\\frac{1}{h}||\\mathbf{r}||$ 离散化 有个数学大佬告诉我，这里就是“在某个i点处求所有其他j点按核函数加权的平均值，只不过离散化的时候划成了区块赋予了密度和体积” 换句话说，这其实就是一次卷积（数学家真是不讲人话） 参考上面那张核函数的图，离散化就是对于$i$点，我们求该点附近场密度函数值和核函数（一堆$j$点）的加权平均值 在数学上，$\\langle A(x)\\rangle $表示平均值 质量密度估计 粒子不需要携带质量密度函数，对于空间中任意位置的点，都可以通过离散化求出该点密度 对于$\\mathbf{x}_i$位置处的点，其密度为： $$ \\rho_{i} =\\sum_{j} m_{j}W_{ij} $$ 不过在流体边界，这样求密度会导致数据偏小，需要做边界处理 下图绿色点临域完整，得到正确的密度，而红色点只能得到一个较小的密度 微分算子的离散化 上面我们已经实现场函数的离散化，实现了质量密度估计。但除此之外，还有一些空间微分算子（导数）值得离散化 $$ \\nabla A_{i}\\approx \\sum_{j} A_{j}\\frac{m_{j}}{\\rho_{j} } \\nabla W_{ij} $$ 关于拉普拉斯算符，可以去看Nabla算子，简单来说这东西是将标量场转化为向量场，一阶算符就是梯度，二阶是散度，用于得到数据变化最快的方向。文中也实现了拉普拉斯算符的离散化 文章介绍了两种最常用的梯度的近似方法，并给了适用范围 差分公式（Difference Formula）：用于近似速度的散度 对称公式（Symmetric Formula）：用于近似力、脉冲的梯度 差分公式 在高中学微积分时，我们用两个相邻的点组成的线来逼近切线，以此引入了极限、导数的概念。在实际应用中，这两个点不可能无穷近，于是存在误差 使用差分表示导数（导数就是），我们只能把$h$取到一个很小的值，而不是无穷小，因此这个导数是有误差的 $$ f’(x)=\\lim_{h \\rightarrow0}\\frac{f(x+h/2)-f(x-h/2)}{h} $$ 我们需要衡量这个误差的大小，于是我们将$f(x\\pm h/2)$泰勒展开后带入上式，得到 $$ f’(x)=\\lim_{h \\rightarrow0}\\frac{f’(x)h+O(h^3)}{h}=f’(x)+O(h^2) $$ 误差大小为$O(h^2)$ 经计算，二阶导数的误差也是$O(h^2)$ 对称公式 临域搜索 这里介绍最简单的，不做空间优化的临域搜索，进阶内容可以看临域搜索 由于核函数存在作用范围，我们在积分时，只需要遍历核半径内其他粒子的信息。这样相较于nxn的全遍历，能大幅减少计算，为此我们需要构建临域表 网格化 临域搜索是一种基于网格（grid）构建粒子拓扑关系的算法，找到该粒子所在位置和其相邻位置有哪些粒子 我们将整个（粒子作用的）场景均匀切分为一个个三维网格，每个网格为立方体，边长等于核半径$\\hslash $， 每个网格拥有一个坐标$(i,j,k)$，用于表示网格在场景中的位置 对于任意一个粒子，其核函数的作用范围是一个球，临域搜索就是计算球内有哪些粒子 空间网格化 遍历粒子，记录每个网格中有多少个粒子，有哪些粒子 遍历粒子，建立临域表 求该粒子的核函数球位于哪些网格中 遍历那些网格，取出网格中所有粒子，计算距离 将距离小于核半径的粒子id存储在临域表中 数据结构 名称 Key Value _neighbourList id.x * maximumParticlesPerCell * 8 + _neighbourTracker[id.x]++ 临居的id _neighbourTracker id.x 当前粒子有多少个临居 _hashGrid hashCellIdx * maximumParticlesPerCell + previousCount id.x _hashGridTracker hashCellIdx 该网格中的粒子数 id.x：当前粒子id hashCellIdx：网格坐标的Hash值 maximumParticlesPerCell：每个网格的的粒子最大数量（提前留好空） previousCount：空里有几个粒子 球作用于哪些网格 我们发现核函数球最少位于8个网格中（一个2x2x2的立方体），最多位于27个网格中（一个3x3x3的立方体），我们只需要找出核函数球位于哪些网格中，就能减少很多便利 在这里，我们只使用8个网格作为临域（舍弃那些不重要的网格），很显然，球心向哪个方向靠，我们就使用哪8个网格 找到球心所在网格坐标，构建临域坐标表，临域坐标初始均设为球心位置 判断中心网格的中心坐标与球心的坐标位置关系 存储临域Hash Key void GetNearbyKeys(int3 originIndex, float3 position, out int nearbyKeys[8]) &#123; int3 nearbyBucketIndices[8]; for (int i = 0; i &lt; 8; i++) &#123; nearbyBucketIndices[i] = originIndex; &#125; if ((originIndex.x + 0.5f) * CellSize &lt;= position.x) &#123; nearbyBucketIndices[4].x += 1; nearbyBucketIndices[5].x += 1; nearbyBucketIndices[6].x += 1; nearbyBucketIndices[7].x += 1; &#125; else &#123; nearbyBucketIndices[4].x -= 1; nearbyBucketIndices[5].x -= 1; nearbyBucketIndices[6].x -= 1; nearbyBucketIndices[7].x -= 1; &#125; if ((originIndex.y + 0.5f) * CellSize &lt;= position.y) &#123; nearbyBucketIndices[2].y += 1; nearbyBucketIndices[3].y += 1; nearbyBucketIndices[6].y += 1; nearbyBucketIndices[7].y += 1; &#125; else &#123; nearbyBucketIndices[2].y -= 1; nearbyBucketIndices[3].y -= 1; nearbyBucketIndices[6].y -= 1; nearbyBucketIndices[7].y -= 1; &#125; if ((originIndex.z + 0.5f) * CellSize &lt;= position.z) &#123; nearbyBucketIndices[1].z += 1; nearbyBucketIndices[3].z += 1; nearbyBucketIndices[5].z += 1; nearbyBucketIndices[7].z += 1; &#125; else &#123; nearbyBucketIndices[1].z -= 1; nearbyBucketIndices[3].z -= 1; nearbyBucketIndices[5].z -= 1; nearbyBucketIndices[7].z -= 1; &#125; for (int j = 0; j &lt; 8; j++) &#123; int3 nbcellIndex = nearbyBucketIndices[j]; if (nbcellIndex.x &lt; 0 || nbcellIndex.x >= Dimensions || nbcellIndex.y &lt; 0 || nbcellIndex.y >= Dimensions || nbcellIndex.z &lt; 0 || nbcellIndex.z >= Dimensions) &#123; nearbyKeys[j] = -1; //出界了 &#125; else &#123; nearbyKeys[j] = Hash(nearbyBucketIndices[j]); &#125; &#125; &#125; //将三维坐标转化为一维hash key int Hash(int3 cell) &#123; return cell.x + Dimensions * (cell.y + Dimensions * cell.z); &#125; 构建临域表 [numthreads(100, 1, 1)] void BuildNeighbourList(uint3 id : SV_DispatchThreadID) &#123; _neighbourTracker[id.x] = 0; const int3 cell = GetCell(_particles[id.x].position); int cells[8]; GetNearbyKeys(cell, _particles[id.x].position, cells); for (uint j = 0; j &lt; 8; j++) &#123; if (cells[j] == -1) continue; // Grid does not contain cell. const uint numberOfParticlesInCell = min(_hashGridTracker[cells[j]], maximumParticlesPerCell); ; for (uint index = 0; index &lt; numberOfParticlesInCell; index++) &#123; const uint potentialNeighbour = _hashGrid[cells[j] * maximumParticlesPerCell + index]; if (potentialNeighbour == id.x) continue; const float3 v = _particles[potentialNeighbour].position - _particles[id.x].position; if (dot(v, v) &lt; radius2) // Use squared length (= dot) instead of length for performance. &#123; _neighbourList[id.x * maximumParticlesPerCell * 8 + _neighbourTracker[id.x]++] = potentialNeighbour; &#125; &#125; &#125; &#125; 控制方程 尽管物体在微观层面（比如原子）是离散的，但在宏观层面上，流体、固体表现为连续介质 continuum, a region of continuously distributed mass 根据定义，一个连续介质可以被切分为多个小的连续介质（类比实数的稠密性，任意两个实数间总存在第三个实数），而不影响其性质 材料粒子（material particle）：a portion of matter contained in an infinitesimal volume 连续性方程 连续性方程描述了物体的密度与时间的关系 $$ \\frac{D\\rho}{Dt}=-\\rho(\\nabla \\cdot \\mathbf{v}) $$ 随体导数 随体导数（material derivative）：$\\frac{D(\\cdot)}{Dt}$ 随体导数描述了材质点的场量随着时间的变化率 在制作不可压缩的介质中，必须始终保持 $$ \\frac{D\\rho}{Dt}=0 $$ 随体导数与坐标系有关，常见的坐标系有：拉格朗日坐标系和欧拉坐标系 线性动量守恒定律 高中物理就学过的碰撞时动量守恒，力作用在物体上，会改变物体的动量 将运动公式（equation of motion）用积分的形式写出来就是 $$ \\rho \\frac{D^2\\mathbf{x}}{Dt^2}=\\nabla \\cdot \\mathbf{T}+\\mathbf{f}_{ext} $$ $\\mathbf{T}$：应力张量（stress tensor） $\\mathbf{f}_{ext}$：体积力（body forces），穿越空间作用在所有流体元上的非接触力，例如重力、惯性力、电磁力 理解应力张量 对于材质内部一个微小平面，这个平面会受材质中其他点的作用力，这个力可能不与平面垂直。其中垂直于平面的力叫正向应力，平行于平面的力叫剪应力 矢量是一种一维张量，由大小和一个方向组成。然而对于应力，我们没法使用矢量进行表示，于是改用二维张量来表示，一个方向是应力的指向，一个方向是应力所在的平面方向 对于材质内一个点，它可能处于无数个平面中，我们需要用一种平面无关的方式来表示其受力状态。在三维空间中，我们选择了三组正交基底$(\\mathbf{e}_1,\\mathbf{e}_2,\\mathbf{e}_3)$构建坐标系，应用中给定一个方向$\\mathbf{e}$，就能求出该方向的应力矢量 其中$\\mathbf{T}$为应力矢量，$\\sigma $为柯西应力张量（一个3x3的矩阵） $\\sigma_{xy}$的意思是，处于yz平面，指向y方向 柯西应力张量只适用于材料微小变形的情况 Navier-Stokes方程 一个经典的不可压缩流体的张力表示方法 $$ \\mathbf{T}=-p+\\mu (\\nabla \\mathbf{v}+\\nabla \\mathbf{v}^T) $$ $p$：压强 $\\mu$：粘度（viscosity ） 我们将该液体的应力张量公式带入牛顿运动公式，得到速度的公式 $$ \\rho \\frac{D\\mathbf{v}}{Dt}=-\\nabla p + \\mu \\nabla^2 \\mathbf{v}+\\mathbf{f}_{ext} $$ 压强可以由密度表示，根据理想气体压强公式，我们得知压强与密度呈线性关系，于是我们取一个静止状态下的密度$\\rho_0$，通过与当前状态密度做差值，就能得出压强 理想气体压强公式，初中就学了，$pV=nRT$ $$ p=B((\\frac{\\rho}{\\rho_0})^{\\gamma}-1) $$ $B$：体积模量（bulk modulus） 弹力 拥有弹力的固体，应力张量来自于固体的形变，之后会展开讲 积分求解 混合初始边界值问题 我们上面给出了控制方程，但是想要求解运动问题，必须给定初始位置和速度（场） 一般而言，混合初始边界值问题（Mixed Initial-Boundary Value Problem）没有解析解，只有数值解 得嘞，这一节就这一句话，这一句话一个字都看不懂 混合边界 简单来说，就是要想求解运动问题，必须既要给初始位置，也要给初始速度（场） 边界条件也叫定解条件，是微分方程里的概念，给定初始值才能求控制方程、偏微分方程的解（比如带入解中的未知数） 放在物理学中叫临界条件，就是物体处于某两种状态间的交界处，比如冰水混合物 边界条件对于解决物理问题（比如求极值）十分重要 有三类边界条件 第一类边界条件（迪利克雷边界条件，Dirichlet boundary condition） 直接告诉你边界值，比如热传递中告诉你边界处温度 第二类边界（若依曼边界条件，Neumann boundary condition） 告诉你边界处的梯度，比如热传递中告诉你热流密度（温度的梯度） 混合边界条件 第一二类边界的混合，比如热对流微分公式，公式中既有温度，也有梯度，只有同时给出两者，才能求解 $$ q=h(T_0-T_a) $$ 解析解与数值解 解析解（analytic solution），形如一个函数，给定变量就能得出任意位置的解 数值解（numerical solution），这是一个数，是采用有限元、数值逼近、插值等方法得到的解 据说在数学家和物理学家眼里，解析解才是真正的解，更高贵，美丽 让我突然想到三体力魏成想要求出三体问题的解析解，结果最后发现这个问题只有数值解 算子分裂 就是使用分治的算法，将一个复杂的偏微分方程（PDE），分解为几个连续的子问题 在实践中证明，像这样每步操作依赖于上一步，一步一步操作，能提高系统的稳定性 时间积分 在实时渲染中，和精度相比，性能、稳定性和鲁棒性更重要 在GAMES201开篇讲弹簧质点模型时，关于质点的运动方程，给出了两种积分器：显式积分器和隐式积分器 显式积分器 从过去的状态得到现在的状态，表示简单容易实现 $$ \\mathbf{v}_{t+1}=\\mathbf{v}_t+\\Delta t \\frac{\\mathbf{f}_t}{m} $$ $$ \\mathbf{x}_{t+1}=\\mathbf{x}t+\\Delta t \\mathbf{v}{t+1} $$ 但是显式积分器有一个问题，就是容易爆炸，于是$\\Delta t$不能太大，应满足 $$ \\Delta t \\le c\\sqrt{\\frac{m}{k}} \\ \\ (c \\sim 1) $$ CFL条件 这是CFL条件（Courant–Friedrichs–Lewy condition），是某些偏微分方程的收敛条件，它决定了显式积分器中粒子在单位时间内走过的距离，必须小于粒子大小（或者说质点间的间距） $$ \\Delta t \\le \\lambda \\frac{\\tilde{h}}{|\\mathbf{v}^{\\max}|} $$ $\\tilde{h}$：粒子大小（质点间的间距） $\\lambda$：一个常量 $\\mathbf{v}^{\\max}$：粒子运动的最快速度 隐式积分器 现在的状态依赖于现在的状态（求$t+1$时刻的信息，结果需要$t+1$时刻的信息），难以实现，但鲁棒性强 $$ \\mathbf{v}_{t+1}=\\mathbf{v}t+\\Delta t \\mathbf{M}^{-1}\\mathbf{f}(\\mathbf{x}{t+1}) $$ $$ \\mathbf{x}_{t+1}=\\mathbf{x}t+\\Delta t \\mathbf{v}{t+1} $$ $\\mathbf{M}$：质量矩阵 Marching Cube 符号表 参考 Physics Simulation in Visual Computing GAMES201 MrKill的知乎 alen-cell","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"SPH","slug":"SPH","permalink":"https://reubensun.com/tags/SPH/"},{"name":"Physics","slug":"Physics","permalink":"https://reubensun.com/tags/Physics/"}]},{"title":"我是谁","slug":"我是谁","date":"2023-02-02T09:50:25.000Z","updated":"2023-03-28T02:56:05.039Z","comments":true,"path":"我是谁/","link":"","permalink":"https://reubensun.com/%E6%88%91%E6%98%AF%E8%B0%81/","excerpt":"","text":"一个渴望得到认同的怪兽 过去 感觉我做啥都三分钟热度，换了好多次道路 我从小就喜欢游戏，在小学的时候就在班级“发售”了一款桌游，赚了5块钱，最后被班主任没收了😂 初高中时特别喜欢科幻和物理，当时想着去做可控核聚变，认为这才是有意义有价值的工作，那时候我的梦想就是做一名学者 在高三时期学校给我们开大会，在讲华为被制裁、卡脖子，然后我就被忽悠着去报考计算机 刚上大学时想做嵌入式和芯片，但在一次大作业中用嵌入式+触摸屏做了一款游戏，那是一个打地鼠和五子棋结合的游戏，没有游戏引擎，没有图形API，画面绘制是靠着在屏幕上绘制点阵，属实是有些拙劣 这次经历让我又想做游戏了，于是我开始做游戏策划 最初的策划生涯还蛮顺利的，每天都在玩游戏做反拆，加了学校的游戏开发社团，做独立游戏，参加Gamejam。然后在腾讯策划公开课拿了金奖，又在字节朝夕光年Gamejam拿到了策划offer。但很快字节上海人事调整（裁员），我被毁了offer 只不过我当时才大二上学期，感觉挺无所谓的。不过在字节Gamejam中看到一个队伍做的平台跳跃，当跳跃时屏幕会有振动和RGB通道分离，我十分好奇这是什么原理，经社团学长介绍，这是shader 然后我开始搞图形了，自学shader三四个月，到了大二下学期我又拿到了字节朝夕光年的offer，只不过这次是TA，然后就在这边实习了十个月。只不过当我大三下学期快要秋招的时候，又遇到了人事调整，整个项目被砍了，mentor离职，于是没继续待 不过这次实习改变了我的技术栈，我现在在做引擎，只不过资质尚浅，能力不足 现在 引擎实在是太复杂了，我的编程能力也不是很强，图形知识大多都停留在应用层面（比如如何用Unity做手游图形效果），算法基础也不是很牢固，看到身边的大佬，感觉好卑微 但是我又是一个渴望得认同的怪兽，不积跬步无以至千里，于是就有了这个博客，用于记录那些想让别人看，但又不敢发知乎贻笑大方的内容 希望我能在引擎道路上坚持下去","categories":[],"tags":[]},{"title":"C++11特性","slug":"program/C++11","date":"2023-02-01T14:01:25.000Z","updated":"2023-03-28T02:56:05.036Z","comments":true,"path":"program/C++11/","link":"","permalink":"https://reubensun.com/program/C++11/","excerpt":"","text":"C++11特性 都什么年代了，还在整C++11？八股害人啊 一：C++11的“新”特性 nullptr 一个新关键字，用于表示指针指向no value，可以被自动转化为各种指针类型，但是不会被转化为整数 比NULL好，因为NULL的本质就是整数0 auto 通过auto声明变量、对象，可以自动推到其类型，在处理表达式时有奇效 auto l &#x3D; [](int x) -&gt; &#123;...&#125;; 一致性初始化 一致性初始化（Uniform Initiallization），简单来说就是可以用大括号来做初始化 int v[] &#123;1, 2, 3&#125;; vector&lt;int&gt; v2 &#123;1, 2, 3&#125;; complex&lt;double&gt; c&#123;4.0, 3.0&#125;; 但是这个操作不支持窄化（narrowing），即 int x &#x3D; 5.3; &#x2F;&#x2F;x &#x3D;&#x3D; 5 int y &#123;5.3&#125;; &#x2F;&#x2F;Error 新的for循环 for(auto&amp; item: lists)&#123;...&#125; for(int i : &#123;1, 2, 3, 4&#125;)&#123;...&#125; 左值右值 左值：占用一定内存，具有可辨认的地址的对象（表达式结束后仍然存在的持久对象），C++中绝大多数变量都是左值 int i &#x3D; 1; &#x2F;&#x2F; i 是左值 int *p &#x3D; &amp;i; &#x2F;&#x2F; i 的地址是可辨认的 i &#x3D; 2; &#x2F;&#x2F; i 在内存中的值可以改变 A a; &#x2F;&#x2F; 用户自定义类实例化的对象也是左值 右值：左值以外的所有对象（表达式结束后就消失的对象） int i = 2; // 2 是右值 int x = i + 2; // (i + 2) 是右值 A a = A(); // A() 是右值，是一个临时对象，在a构造完成后会被销毁 A&amp;&amp; a = A(); // a是一个右值引用，引用的就是A()所创建的对象，这个对象的生命周期和a一致 int i = sum(1, 2) // sum(1, 2) 是右值 不能对右值赋值 i + 2 &#x3D; 4; &#x2F;&#x2F; 错误，不能对右值赋值 不能对右值取地址 int *p &#x3D; &amp;(i + 2); &#x2F;&#x2F; 错误，不能对右值取地址 int square1(int&amp; a) &#123;return a * a;&#125; int square2(const int&amp; a) &#123;return a * a;&#125; ... int i &#x3D; 2; square1(i); &#x2F;&#x2F; 正确 square1(2); &#x2F;&#x2F; 错误，不能对右值取地址 square2(2); &#x2F;&#x2F; 正确 为什么可以const int &amp;a = 2;呢？可以视为一个例外，const引用 指向了一个 临时左值的引用，其值为2 转移语意 转移语意（move semantic），本质是所有权的转移，将即将销毁的对象转移给他人，避免非必要的拷贝和临时对象 比如一个函数定义为 void fun(const T&amp; v)&#123;...&#125; 当我们调用时 T t; fun(t); &#x2F;&#x2F;1 fun(t+1); &#x2F;&#x2F;2 我们发现，第一种调用时，直接传了引用，没有拷贝和临时变量，而第二种，实际上是 T temp &#x3D; t+1; &#x2F;&#x2F;T temp(t+1)或者 T temp.T(t+1) fun(temp); 总之是调用了拷贝构造函数和生成了临时变量，这不是我们想要的，于是引入了左右值和转移语意的概念，然后就诞生了一种新的调用方式： fun(std::move(t+1)); std::move的作用是将其参数t+1变成一个右值引用（rvalue reference），是一个T&amp;&amp;的类型 一旦一个类型被“标记”为右值，就意味着这是一个临时对象，你可以随意使用它的内容和资源 然后我们可以优化一下这个函数的定义 class T&#123; public: T (const T&amp; lvalue); &#x2F;&#x2F; 通过左值拷贝构造（根传统C++一样） T (T&amp;&amp; rvalue); &#x2F;&#x2F; 通过右值move构造 &#125; void fun(T&amp;&amp; v)&#123;...&#125; 右值被move以后，就变成有效但不确定的状态 字符串字面量 Raw String Literal 以R开头的字符串，可以换行，不需要转义，用于正则表示式有奇效 R&quot;(\\\\n)&quot;; &#x2F;&#x2F;等于 &quot;\\\\\\\\n&quot; Encoded String Literal 用于国际化 noexcept 让函数无法抛出异常，遇到未定义事件会直接abort noexcept后面可以跟一个bool条件，为true时就不抛异常 void fun() noexcept; void fun2(T&amp; x, T&amp; y) noexcept(noexcept(x.swap(y)))&#123; x.swap(y); &#x2F;&#x2F;这个函数意味着，只要xy交换不抛异常，那么下面这些函数体做任何事都不会抛异常 &#125; constexpr 用于让表达式核定与编译期，能助力TMP编程 constexpr int square(int x)&#123; return x*x; &#125; float a[square(9)]; &#x2F;&#x2F;以前的写法 template&lt;unsigned n&gt; struct Factorial &#123; enum &#123; value &#x3D; n * Factorial&lt;n-1&gt;::value &#125;; &#125;; &#x2F;&#x2F;C++11写法 template&lt;unsigned n&gt; struct Factorial &#123; constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;; &#125;; 新的模板 不定个数的参数 void f(int i)&#123; cout &lt;&lt; i &lt;&lt; endl; &#125; template &lt;typename T , typename... Types&gt; void f(const T&amp; first, const Types&amp;... args)&#123; cout &lt;&lt; first &lt;&lt; endl; f(args...); &#125; int main() &#123; f(1, 2, 3); return 0; &#125; 模板别名 template &lt;typename T&gt; using Vec &#x3D; std::vector&lt;T, MyAlloc&lt;T&gt;&gt;; Vec&lt;int&gt; coll; &#x2F;&#x2F;等价于std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll; Lambda 允许函数的定义式被用作一个参数、local对象 定义与调用 []&#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;; &#x2F;&#x2F;这是一个lambda表达式 []&#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;(); &#x2F;&#x2F;定义并直接调用表达式 auto l &#x3D; []&#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;; l(); &#x2F;&#x2F;调用表达式 含参 auto l2 &#x3D; [](const std::string&amp; s)&#123; cout &lt;&lt; s &lt;&lt; endl; &#125;; l(&quot;hello&quot;); 返回值 []() -&gt; int &#123; return 42; &#125; 外部作用域 分值传递和引用传递两种，值传递不能进行修改 int x &#x3D; 0; int y &#x3D; 42; auto l &#x3D; [x, &amp;y] &#123; cout &lt;&lt; x &lt;&lt; &quot;+&quot; &lt;&lt; y &lt;&lt; endl; ++y; &#125; l(); &#x2F;&#x2F;调用，注意xy不是参数，不需要写在括号里 mutable 这个关键词是const的反义词，意思是可变的，于是让值传递也可变 int x &#x3D; 0; auto l &#x3D; [x]() mutable &#123; cout &lt;&lt; x &lt;&lt; endl; x++; &#125; l(); decltype 自动推导表达式的类型，大号typeof const int &amp;i &#x3D; 1; int a &#x3D; 2; decltype(i) b &#x3D; 2; &#x2F;&#x2F; b是const int&amp; 推断返回类型 可以将返回类型的声明放在参数列之后 template &lt;typename T1, typename T2&gt; auto add(T1 x, T2 y) -&gt; decltype(x+y)&#123; return x + y; &#125; 带领域的枚举 二：一般概念 可被调用的对象 Callable Object，一种对象，可以通过某些方式调用其某些函数，它可以是 函数 指向成员函数的指针 函数对象 lambda表达式 三：通用工具 pair 本质是一个struct int add(pair&lt;int, int&gt; p)&#123; return p.first + p.second; &#125; int main() &#123; pair&lt;int, int&gt; p(42, 10); cout &lt;&lt; add(p); return 0; &#125; tuple 大号pair，可以有多个值 int f(tuple&lt;int, int, int&gt; t)&#123; return get&lt;0&gt;(t) + get&lt;1&gt;(t) + get&lt;2&gt;(t); &#125; int main() &#123; tuple&lt;int, int, int&gt; t(3, 5, 7); cout &lt;&lt; f(t); return 0; &#125; 智能指针 智能指针智能在，它能知道自己是不是指向某物的最后一个指针 shared_ptr：共享式拥有 多个指针可以指向一个资源，通过引用计数法GC 为了解决引用计数法的缺点（比如循环引用），提供weak_ptr等辅助类 unique_ptr：独占式拥有 同一时间只能有一个unique_ptr指向某个资源，可以进行拥有权的移交 极值 Numeric Limit 用于得到当前平台下，一些数值类型的长度（大小） Trait 是一种技术方案，用来为同一类数据提供统一的操作函数，核心就是使用另外的模版类type_traits存储不同数据类型的type，这样就可以兼容各种数据类型 外覆器 Reference Wrapper 允许函数模板可以操作引用，不需要写特化版本 具体有两个函数 ref：隐式转化为T&amp; cref：隐式转化为const T &amp; template &lt;typename T&gt; void fun(T v); int x; fun(std::ref(x)); &#x2F;&#x2F;此时T为int&amp; int x; fun(std::cref(x)); &#x2F;&#x2F;此时T为const int&amp; Function Type Wrapper 允许将可调用对象当作最高级对象（first-class object） vector&lt;function&lt;void(int, int)&gt;&gt; tasks; &#x2F;&#x2F;一个存储多个可调用对象的vector tasks.push_back(func); &#x2F;&#x2F;void func(int x, int y); tasks.push_back([] (int x, int y) &#123;...&#125;); &#x2F;&#x2F;添加一个lambda表达式 for(function&lt;void(int, int)&gt; f : tasks)&#123; f(36, 36); &#x2F;&#x2F;遍历所有的可调用对象，并调用 &#125; 辅助函数 min max swap operator == != &gt; &lt; &gt;= &lt;= 编译期分数运算 ratio&lt;5, 5&gt; one; cout &lt;&lt; one.num &lt;&lt; &quot;&#x2F;&quot; &lt;&lt; one.den &lt;&lt; endl; &#x2F;&#x2F; 1&#x2F;1 ratio&lt;5, 3&gt; two; cout &lt;&lt; two.num &lt;&lt; &quot;&#x2F;&quot; &lt;&lt; two.den &lt;&lt; endl; &#x2F;&#x2F; 5&#x2F;3 四：STL STL是C++标准库的核心，是一个泛型（generic）程序库，由三部分组成 容器（Container） 迭代器（Iterator） 算法（Algorithm） 容器 有序容器 顺序与插入顺序有关，与元素值无关，常常通过array、linked list实现 array vector deque list forward_list 关联式容器 在内部进行排序的集合，位置取决于value，常常通过二叉树实现 set multiset（mult的意思是元素可以重复） map multimap（mult的意思是key可以重复） 无序容器 元素位置无关紧要，重要的是元素是否在容器内，常常通过哈希表实现 unordered_set unordered_multiset unordered_map unordered_multmap 其他容器 string 寻常的数组（一种type，而非class） 迭代器 迭代器是一个可以遍历STL容器全部、部分元素的对象 操作 *：取元素 ++：迭代器前进至下一个元素 注意，++i比i++效率高一点点，因为后者要创建临时对象 ==、!=：判断两个迭代器是否指向同一个位置 =：赋值 种类 R/W 读写次数 跳转 举例 输入/输出迭代器 只读/只写 能且仅能读写一次 i++ istream_iterators、ostream_iterators 前向/双向迭代器 读写 能读写多次 i++ STL的set、map 随机访问迭代器 读写 能读写多次 i += n vector、deque、string、array 从上到下，迭代器能力越来越强（他们间有继承关系，前向 is a 输入） 算法 大多为非成员函数，思想是泛型编程（而不是OOP） 函数对象 一个行为像函数的对象，思想是泛型编程 class X&#123; public: int operator() (int a, int b) const; &#125;; ... X fo; fo(arg1, arg2); &#x2F;&#x2F;等同于fo.operator()(arg1, arg2); 函数对象是一个带状态的函数 函数对象有自己的类型 函数对象速度通常比普通函数快（编译期间有更好的优化）","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://reubensun.com/tags/C/"}]},{"title":"profile工具","slug":"graphics/profile工具","date":"2023-02-01T10:01:25.000Z","updated":"2023-03-28T02:56:19.623Z","comments":true,"path":"graphics/profile工具/","link":"","permalink":"https://reubensun.com/graphics/profile%E5%B7%A5%E5%85%B7/","excerpt":"","text":"Profile工具 工具手册 工具 优点 评价 Unity profiler 用起来最简单，可以网络远程测试 功能不是很全 Xcode 功能全，而且使用简单 只能iOS，而且iOS打包很折磨 RenderDoc 安卓利器 snapdragon 只能用于高通骁龙soc，使用时注意有无adb Nsight 贼难用（可能是Unity图形API的锅） PIX 调试DX12也就这个好使 Xcode 配置Xcode项目 Xcode想要截帧需要依赖Xcode源项目 签名配置（略，这玩意贼恶心，尤其是别人的项目） 配置截帧 Edit Scheme CaptureMetal API Validation 截帧 截帧信息分析 GPU时间（首页就有） 带宽 截帧分享 找到这个文件，分享给其他人 Nsight 连接Unity Editor 以管理员身份打开 配置 Application Executable：Unity.exe所在的绝对路径 Command Line Arguements：-projectPath ”项目根路径“ 项目根路径：文件夹内有Asset、Package的那个文件夹 启动 点击Launch Frame Debugger 注意，请将Unity和Unity Hub都关掉 注意 Unity HDRP使用了D3D11On12，在使用NSight时会报Warm，暂时先别管 Snapdragon 连接安卓APP Connect to a device 如果找不到设备，检查有无adb命令，或者直接用adb连接 Realtime看带宽 从左下角Process中挑 Trace Capture看GPU时间 RenderDoc 连接安卓APP 手机连接电脑，电脑打开RenderDoc Connect 打开Launch Application窗口 Program——Executable Path——选择要截帧的APP 连接Unity Editor 右键Scene，Load RenderDoc 按小相机截帧 PIX 权限配置 开启Window开发者模式 开启英伟达开发者模式（以管理员身法打开英伟达控制面板） 注意，更换模式时，请注意关闭、保存Unity（和显卡相关的软件会崩掉） 连接Unity Editor 以管理员身份打开PIX Attach Unity Editor（配置方式同NSight） 按GPU Capture截帧","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"TA","slug":"TA","permalink":"https://reubensun.com/tags/TA/"}]},{"title":"骨骼动画","slug":"graphics/骨骼动画","date":"2023-02-01T10:01:25.000Z","updated":"2023-03-28T02:56:19.627Z","comments":true,"path":"graphics/骨骼动画/","link":"","permalink":"https://reubensun.com/graphics/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/","excerpt":"","text":"骨骼动画 序列帧动画：记录动作的每一帧 非矢量动画：每一帧是固定不可复用的，新的一帧本质上是完全重画一次物体，没有发生形态上的改变 关键帧动画：记录动作的始末和轨迹曲线，运行时根据曲线进行插值（很显然，这是一种矢量动画） 每个关键帧被称为姿势 顶点动画 骨骼动画的本质是顶点动画 刚体动画：在渲染中网格不发生改变，刚体的变化矩阵发生改变 顶点动画：在渲染中网格顶点发生了直接的变化（位移旋转缩放） 骨骼动画：一种对顶点动画的压缩算法 流体动画 粒子动画 变形动画：常用于制作表情，捏脸 根据顶点动画的实现方式，分为CPU和GPU CPU动画 GPU动画 顶点位置改变时机 CPU应用阶段 GPU几何阶段 数据流 CPU传递给GPU的顶点数组发生改变 顶点着色器输出发生改变 骨骼动画 骨骼动画的模型整体不是刚体，同时为了避免旋转、移动时发生断裂，也不能将物体拆分为多个小刚体，因此只能选择顶点动画。 然而顶点动画带来的顶点移动，如果全部交由vertex着色器处理，过于昂贵，实时渲染不可接受 而且骨骼动画的顶点受更高层次的骨骼节点控制 同一根骨骼的顶点要保持相对位置不变 骨骼间顶点要进行平滑 顶点的大体形状受骨骼形状制约，顶点变化时要保持和骨骼的联系 实现 矩阵调色板蒙皮技术（Matrix Palette Skinning）： 骨骼为近似刚体，其变化矩阵按顺序存储在数组中（我们称这个数组为骨骼） 顶点缓冲中会存储其骨骼ID和权重信息（一个顶点通常会受1～4个骨骼影响，可以用两个Vector存储） 进行变化时，顶点可以根据骨骼ID和权重查询变化矩阵，并通过插值的方式实现顶点动画（我们称查询矩阵为蒙皮） CPU通过姿势间插值，以获得每一帧骨骼的位置及矩阵，GPU根据顶点信息查询矩阵进而实现运动 坐标系 骨骼树 三维骨骼本质上是一系列Bone组成的树状结构 在骨骼动画中，我们更关心骨骼的相对位置，于是我们选择本地坐标系（A物体的本地坐标就是以A物体中心为原点，相对于中心的偏移），并让坐标系层次嵌套 比如大臂移动时也会带动小臂移动，我们就把小臂的本地坐标系定义在大臂的本地坐标系之下，我们称大臂是小臂的父物体，小臂是大臂的子物体。而小臂在大臂的本地坐标系的坐标被称为局部坐标系（可以参考Unity的GO组织） 顺着嵌套关系向根部搜索，就可以获得物体的世界坐标系 下图为树节点的数据结构 本地坐标系就是object space transform 在播放动画时，会从空间树的根节点（一般为盆骨节点或者root节点）开始向下递归变化，以保证父物体的local transform总是先于子物体刷新 &#x2F;&#x2F;对关键帧进行插值 public OnAnimated(CoordinateTreeNode Key0, CoordinateTreeNode Key1, float t) &#123; Position &#x3D; Vector3.Lerp(Key0.Position, Key1.Position, t); Rotation &#x3D; Quaternion.Lerp(Key0.Rotation, Key2.Rotation, t); Scale &#x3D; Vector3.Lerp(Key0.Scale, Key1.Scale, t); localTransform &#x3D; new TransformMatrix(Position, Rotation, Scale); combinedTransform &#x3D; parent.localTransform * this.localTransform; &#125; 骨骼 盆骨：选盆骨作为根节点（或者是空根节点的第一也是唯一的子节点），是因为盆骨在运动时相对匀速，且位置居中，可以避免骨骼树过深 脊椎骨：模拟躯干运动，一般有2～3块 捻度骨骼：Twist Bone，生物学中像小臂这类骨骼不是一块骨骼，而是两条并排的骨骼，以此实现肘关节不动而手掌可以旋转 坐标变化 位移矩阵 缩放矩阵 旋转矩阵 齐次坐标 仿射变换：缩放–旋转–平移 列矩阵左乘 手性变换：只需要对所有的矩阵任选一维进行取反即可（哪个维度不重要，只要统一即可） 旋转 骨骼动画是矢量动画，是关键帧动画，因此会用到大量的插值，这决定了旋转的表达必须便于插值 三维空间中的点可以由三个正交向量插值表示，根据嵌套关系，一个物体发生旋转，其实就是其基向量相对于父节点基向量发生改变 双向量法 既然旋转可以由基向量的朝向表示，那么我们就直接基向量表示旋转吧！ 正好三个基向量正交，而且对长度不敏感，那么我们还可以将三个向量压缩为两个向量 更进一步，这些向量都在球面上，那么用球坐标系替代直角坐标系 问题： 需要时刻保证两个向量垂直 不好插值 欧拉角 在航空业应用广泛，本质是一种过程量，描述了从初始位置沿着xyz轴旋转指定角度的过程，使用时需要明确旋转顺序（即顺规） 直角坐标系 欧拉角 前进方向 Z Roll 桶滚角 上方向 Y Yaw 偏航角 右方向 X Pitch 俯仰角 问题： 没有统一标准，而欧拉角强依赖于顺规 某些情况下会有两个轴平行，以至于失去一个自由度，导致万向节死锁 不能线性插值 轴角与四元数 轴角（x, y, z, w）指沿着轴（x, y, z）旋转w度，也可以压缩为三维向量（wx’, wy’, wz’），轴角可以通过对轴向量和旋转角度分别插值对方法进行插值 四元数是一种超复数，可以用来表示旋转 四元数的可视化_哔哩哔哩_bilibili 蒙皮解算 Mesh中的顶点缓存中会存储骨架、骨骼索引，骨骼权重，将用于蒙皮解算","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"TA","slug":"TA","permalink":"https://reubensun.com/tags/TA/"}]},{"title":"Pro-TBB","slug":"math/Pro-TBB","date":"2023-02-01T10:01:25.000Z","updated":"2023-03-28T02:56:19.628Z","comments":true,"path":"math/Pro-TBB/","link":"","permalink":"https://reubensun.com/math/Pro-TBB/","excerpt":"","text":"Pro TBB 在摩尔定律逐渐失效的今日，CPU主频和单核性能提升越来越不明显，为了得到跟高的性能，我们走向了并行计算的道路 概念 并发和并行 并发（Concurrent）：happening during the same time span，处理器在两件事间快速切换，宏观上看，就像是同时发生的（下图AB） 并行（Parallel）：happening at the same time，多个处理器一起做事（下图CD） TBB基础 TBB（Threading Building Blocks）是一个非常流行的C++并行编程（parallel programming）方案 使用Task而非Thread Thread与硬件相关，直接编写难以跨平台，而且线程间通信过于频繁，过于繁琐 TBB使用Task编程，运行时会将程序映射到硬件上（该方法对嵌套并行的支持很不错） TBB任务调度使用工作窃取，当一个任务队列执行完毕后，核心会去其他任务队列中窃取任务，于是可以提高核心的利用率 TBB实现了可组合性（Composability） 简单来说就是支持for循环 方便移植（portable） Mac上安装使用TBB 安装tbb $brew install tbb 链接tbb #寻找tbb包 find_package(TBB REQUIRED) ... #链接 target_link_libraries(TimeStudy TBB::tbb) 引用头文件 #include&lt;tbb&#x2F;tbb.h&gt; 在Ubuntu上安装TBB $sudo apt-get install libtbb-dev 调用函数 template&lt;typename Func0, [...,] typename FuncN&gt; void parallel_invoke(const Func0&amp; f0, [...,] const FuncN&amp; fN); 一个简单的TBB示例，并行输出两行字符串 通过tbb::parallel_invoke实现任务、函数粒度的并行 #include &lt;iostream&gt; #include &lt;tbb&#x2F;tbb.h&gt; int main() &#123; tbb::parallel_invoke( []()&#123;std::cout &lt;&lt; &quot;TBB!&quot; &lt;&lt; std::endl;&#125;, []()&#123;std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;&#125; ); return 0; &#125; 我们这里使用lambda表达式创建了匿名（anonymous）函数，可以大幅简化TBB编写 快排示例 传统快排算法（升序） 在数列中取一个数作为基准数 比基准小的放在基准左边，大的放在右边 对左右两边分别快排，直到只剩一个数（左右重合） 能看出，这个算法采用了分治的思想，很适合并行 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;tbb&#x2F;tbb.h&gt; using QV &#x3D; std::vector&lt;int&gt;; &#x2F;&#x2F;传统快排 void quickSort(QV::iterator left, QV::iterator right)&#123; if(left &gt;&#x3D; right)&#123; return; &#125; int pivot_value &#x3D; *left; QV::iterator i &#x3D; left, j &#x3D; right - 1; while(i !&#x3D; j)&#123; while(i !&#x3D; j &amp;&amp; pivot_value &lt; *j) --j; &#x2F;&#x2F;从右向左找，直到找到一个比基准小的 while(i !&#x3D; j &amp;&amp; pivot_value &gt;&#x3D; *i) ++i; &#x2F;&#x2F;从左往右找，直到找到一个比基准大的 std::iter_swap(i, j); &#125; std::iter_swap(left, i); quickSort(left, i); quickSort(j+1, right); &#125; &#x2F;&#x2F;并行快排 void parallelQuicksort(QV::iterator left, QV::iterator right)&#123; if(left &gt;&#x3D; right)&#123; return; &#125; int pivot_value &#x3D; *left; QV::iterator i &#x3D; left, j &#x3D; right - 1; while (i !&#x3D; j) &#123; while (i !&#x3D; j &amp;&amp; pivot_value &lt; *j) --j; while (i !&#x3D; j &amp;&amp; pivot_value &gt;&#x3D; *i) ++i; std::iter_swap(i, j); &#125; std::iter_swap(left, i); &#x2F;&#x2F; recursive call tbb::parallel_invoke( &#x2F;&#x2F;lambda表达式[&#x3D;]表示传入当前函数所有的成员 [&#x3D;]() &#123; parallelQuicksort(left, i); &#125;, [&#x3D;]() &#123; parallelQuicksort(i + 1, right); &#125; ); &#125; &#x2F;&#x2F;使用cutoff void parallelCutoffQuicksort(QV::iterator left, QV::iterator right)&#123; const int cutoff &#x3D; 100; if (right - left &lt; cutoff) &#123; quickSort(right, left); &#125; else &#123; int pivot_value &#x3D; *left; QV::iterator i &#x3D; left, j &#x3D; right - 1; while (i !&#x3D; j) &#123; while (i !&#x3D; j &amp;&amp; pivot_value &lt; *j) --j; while (i !&#x3D; j &amp;&amp; pivot_value &gt;&#x3D; *i) ++i; std::iter_swap(i, j); &#125; std::iter_swap(left, i); &#x2F;&#x2F; recursive call tbb::parallel_invoke( [&#x3D;]() &#123; parallelQuicksort(left, i); &#125;, [&#x3D;]() &#123; parallelQuicksort(i + 1, right); &#125; ); &#125; &#125; int main() &#123; std::vector&lt;int&gt; nums; for(int i &#x3D; 0; i &lt; 5000; ++i)&#123; nums.push_back(rand() % 5000); &#125; &#x2F;&#x2F;warmup tbb::parallel_for(0, 10, [](int) &#123; tbb::tick_count t0 &#x3D; tbb::tick_count::now(); while ((tbb::tick_count::now() - t0).seconds() &lt; 0.01); &#125;); std::vector&lt;int&gt; nums2 &#x3D; nums; tbb::tick_count t0 &#x3D; tbb::tick_count::now(); quickSort(nums.begin(), nums.end()); std::cout &lt;&lt; &quot;Normal Time&#x3D;&quot; &lt;&lt; (tbb::tick_count::now() - t0).seconds() &lt;&lt; std::endl; tbb::tick_count t1 &#x3D; tbb::tick_count::now(); parallelQuicksort(nums2.begin(), nums2.end()); std::cout &lt;&lt; &quot;Parallel Time&#x3D;&quot; &lt;&lt; (tbb::tick_count::now() - t1).seconds() &lt;&lt; std::endl; return 0; &#125; 最后结果，当数组比较大的时候，并行快排速度会更快一点 Normal Time&#x3D;0.0023285 Parallel Time&#x3D;0.00110846 此外tbb进行任务分配也会有开销，因此我们往往将大任务分成若干个小任务后，让小任务串型执行，上文中的cutoff就是起到这个作用，这样往往能得到更高的性能 时刻查询 &#x2F;&#x2F;t0时刻 tbb::tick_count t0 &#x3D; tbb::tick_count::now(); ... &#x2F;&#x2F;当前时刻-t0时刻&#x3D;经过了多长时间段（并转化为秒） std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; (tbb::tick_count::now() - t0).seconds() &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl; 并行开发中动态内存管理十分复杂、危险（内存泄漏），这里推荐使用C++11的智能指针（自带GC） Flow Graph 将函数执行制作成Graph，实现消息驱动的并行（有些类似FrameGraph） void fig1_10(const std::vector&lt;ImagePtr&gt;&amp; image_vector)&#123; const double tint_array[] &#x3D; &#123;0.75, 0, 0&#125;; tbb::flow::graph g; int i &#x3D; 0; &#x2F;&#x2F;注意，source_node已经失效 tbb::flow::input_node&lt;ImagePtr&gt; src(g, [&amp;i, &amp;image_vector](tbb::flow_control &amp;fc) -&gt; ImagePtr &#123; if(i &lt; image_vector.size())&#123; return image_vector[i++]; &#125; else&#123; fc.stop(); return &#123;&#125;; &#125; &#125;); tbb::flow::function_node&lt;ImagePtr, ImagePtr&gt; gamma(g, tbb::flow::unlimited, [] (ImagePtr img) -&gt; ImagePtr&#123; return applyGamma(img, 1.4); &#125; ); tbb::flow::function_node&lt;ImagePtr, ImagePtr&gt; tint(g, tbb::flow::unlimited, [tint_array] (ImagePtr img) -&gt; ImagePtr&#123; return applyTint(img, tint_array); &#125; ); tbb::flow::function_node&lt;ImagePtr&gt; write(g, tbb::flow::unlimited, [] (ImagePtr img)&#123; writeImage(img); &#125; ); tbb::flow::make_edge(src, gamma); tbb::flow::make_edge(gamma, tint); tbb::flow::make_edge(tint, write); src.activate(); g.wait_for_all(); &#125; 最后该程序会以流水线的形式执行，当第一张图片完成gamma矫正，去执行tint着色时，第二张图片开始执行gamma矫正（每张图片间互不影响） 相比于TimeStudy的串型执行，流水线执行效率会更快 循环 template&lt;typename Index, typename Func&gt; Func parallel_for(Index frist, Index last, [Index step,] const Func&amp; f); 上面的代码，我们将图片处理切分为几个小块，但小块内部仍然是单线程 我们注意到，在图片处理时，有一个很大的循环在遍历图片上的像素点，那么能不能并行做这件事？ 我们并行处理每一行 tbb::parallel_for(0, height, [&amp;in_rows, &amp;out_rows, width, gamma](int i)&#123; for(int j &#x3D; 0; j &lt; width; ++j)&#123; const ImageLib::Image::Pixel&amp; p &#x3D; in_rows[i][j]; double v &#x3D; 0.3 * p.bgra[2] + 0.59 * p.bgra[1] + 0.11 * p.bgra[0]; double res &#x3D; pow(v, gamma); if(res &gt; ImageLib::MAX_BGR_VALUE)&#123; res &#x3D; ImageLib::MAX_BGR_VALUE; &#125; out_rows[i][j] &#x3D; ImageLib::Image::Pixel(res, res, res); &#125; &#125; ); tbb::parallel_for(0, height, [&amp;in_rows, &amp;out_rows, width, tints](int i)&#123; for(int j &#x3D; 0; j &lt; width; ++j)&#123; const ImageLib::Image::Pixel&amp; p &#x3D; in_rows[i][j]; std::uint8_t b &#x3D; (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[0]) * tints[0]; std::uint8_t g &#x3D; (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[1]) * tints[1]; std::uint8_t r &#x3D; (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[2]) * tints[2]; out_rows[i][j] &#x3D; ImageLib::Image::Pixel( (b &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : b, (g &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : g, (r &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : r ); &#125; &#125; ); M1 Mac Xcode Clang至今不支持C++17的std::execution，对OpenMP的支持也相当差 归约 template&lt;typename Range, typename Value, typename Func, typename Reduction&gt; Value parallel_reduce(const Range&amp; range, const Value&amp; identity, const Func&amp; func, const Reduction&amp; reduction); 树形规约 求最大值 下面是一个vector求最大值的示例，实现机制就是将整个数组分成一个个小块（chunks），分别对小块求最值，然后将小块归约（reduce），最后求得最值（形成了一个树型结构） int pmax(const std::vector&lt;int&gt; &amp;arr)&#123; int max_value &#x3D; tbb::parallel_reduce( &#x2F;&#x2F;range，扫描范围 tbb::blocked_range&lt;int&gt;(0, arr.size()), &#x2F;&#x2F;identity，小块数据的初始值，这里赋值为int类型的最小值-2147483648 std::numeric_limits&lt;int&gt;::min(), &#x2F;&#x2F;func，每个小块的处理方式 [&amp;](const tbb::blocked_range&lt;int&gt; &amp;r, int init) -&gt; int&#123; for(int i &#x3D; r.begin(); i !&#x3D; r.end(); ++i)&#123; init &#x3D; std::max(init, arr[i]); &#125; return init; &#125;, &#x2F;&#x2F;reduction，小块间合并的处理方式 [](int x, int y) -&gt; int&#123; return std::max(x, y); &#125; ); return max_value; &#125; 下面这是一个求PI的示例 double calcPI(int degree)&#123; double dx &#x3D; 1.0 &#x2F; degree; double sum &#x3D; tbb::parallel_reduce( &#x2F;&#x2F;range，扫描范围 tbb::blocked_range&lt;int&gt;(0, degree), &#x2F;&#x2F;identity，小块数据的初始值，这里赋值为0 0.0, &#x2F;&#x2F;func，每个小块的处理方式 [&#x3D;](const tbb::blocked_range&lt;int&gt; &amp;r, double init) -&gt; double&#123; for(int i &#x3D; r.begin(); i !&#x3D; r.end(); ++i)&#123; double x &#x3D; (i + 0.5)*dx; double h &#x3D; std::sqrt(1 - x*x); &#x2F;&#x2F;勾股定理 init +&#x3D; h * dx; &#125; return init; &#125;, &#x2F;&#x2F;reduction，小块间合并的处理方式 [](double x, double y) -&gt; double&#123; return x+y; &#125; ); return 4 * sum; &#125; 扫描 template&lt;typename Range, typename Value, typename Scan, typename Combine&gt; Value parallel_scan(const Range&amp; range, const Value&amp; identity, const Scan&amp; scan, const Combine&amp; combine); 前缀和 前缀和在图形领域也有很大的用处 对于一个数组，我们将其分为三个小块ABC A.init&#x3D;0, B.init&#x3D;0 scan(A), scan(B) B.init &#x3D; A.ans C.init &#x3D; A.ans + B.ans scan(B), scan(C) 最后我们只用了串行2/3的扫描时间，但是多做了1/3的扫描工作，时间减少了，但是工作量变大了 int parallelPrefix(const std::vector&lt;int&gt; &amp;v, std::vector&lt;int&gt; &amp;psum)&#123; int N &#x3D; v.size(); psum[0] &#x3D; v[0]; int final_sum &#x3D; tbb::parallel_scan( &#x2F;&#x2F;range tbb::blocked_range&lt;int&gt;(1, N), &#x2F;&#x2F;identity (int)0, &#x2F;&#x2F;scan body [&amp;v, &amp;psum](const tbb::blocked_range&lt;int&gt; &amp;r, int sum, bool is_final_scan) -&gt; int&#123; for(int i &#x3D; r.begin(); i &lt; r.end(); ++i)&#123; sum +&#x3D; v[i]; if(is_final_scan)&#123; psum[i] &#x3D; sum; &#125; &#125; return sum; &#125;, &#x2F;&#x2F;combine body [](int x, int y)&#123; return x+y; &#125; ); return final_sum; &#125; 可见性 如图，等间距摆放一个个薄板（厚度忽略不计），从最右上角向左看，能看到哪些薄板？ 解题的本质就是比较夹角大小，只要夹角一直递增，就能看到 void visibility(const std::vector&lt;double&gt; &amp;heights, std::vector&lt;bool&gt; &amp; visible, double dx)&#123; const int N &#x3D; heights.size(); double max_angle &#x3D; std::atan2(dx, heights[0] - heights[1]); double final_max_angle &#x3D; tbb::parallel_scan( &#x2F;&#x2F;range tbb::blocked_range&lt;int&gt;(1, N), &#x2F;&#x2F;identity 0.0, &#x2F;&#x2F;scan body [&amp;heights, &amp;visible, dx](const tbb::blocked_range&lt;int&gt; &amp;r, double max_angle, bool is_final_scan) -&gt; double &#123; for(int i &#x3D; r.begin(); i !&#x3D; r.end(); ++i)&#123; double my_angle &#x3D; atan2(i * dx, heights[0] - heights[i]); if(my_angle &gt;&#x3D; max_angle)&#123; max_angle &#x3D; my_angle; &#125; else if(is_final_scan)&#123; visible[i] &#x3D; false; &#125; &#125; return max_angle; &#125;, &#x2F;&#x2F;combine body [](double a, double b)&#123; return std::max(a, b); &#125; ); &#125; parallel_for_each parallel_for在使用时必须指定range，但如果要处理的item数量不确定（比如在执行过程中修改itemList），那么就不能使用，这个时候我们可以使用parallel_for_each template &lt;typaname InputIterator, typename Body&gt; void parallel_for_each( InputIterator first, InputIterator last, Body body ); 下面是一个遍历树的示例，若一个节点的v.first为prime，将其v.second修改为true。我们不知道树有多大，于是采用递归遍历 void f(PrimesTreeElement::Ptr root)&#123; PrimesTreeElement::Ptr tree_arry[] &#x3D; &#123;root&#125;; &#x2F;&#x2F;tbb::parallel_do已经废弃 tbb::parallel_for_each( tree_array, [](PrimesTreeElement::Ptr e, &#x2F;&#x2F;tbb::parallel_do_feeder已被废弃 tbb::feeder&lt;PrimesTreeElement::Ptr&gt;&amp; feeder)&#123; if(e)&#123; if(isPrime(e-&gt;v.first)) e-&gt;v.second &#x3D; true; if(e-&gt;left) feeder.add(e-&gt;left); if(e-&gt;right) feeder.add(e-&gt;right); &#125; &#125; ); &#125; 前向替换 前向替换（Forward Substitution）是线性代数中一种求解线性方程组的方法 一般解线性方程组有两种方法： 直接法 高斯消元法 LU分解法 迭代法 高斯消元法：初中就学了，就是两个方程变化后相加减（也可以换元），消除变量，直到得到解。这个方法可以拓展到矩阵中，就是把线性方程转化为行阶梯矩阵（中间那个矩阵），然后简化为简化行阶梯矩阵（右边那个矩阵） $$ \\left[ \\begin{matrix} 2 &amp; 1 &amp; -1 &amp;|&amp; 8 \\\\ -3 &amp; -1 &amp; 2 &amp; | &amp; -11 \\\\ -2 &amp; 1 &amp; 2 &amp; | &amp; -3 \\end{matrix} \\right] =&gt; \\left[ \\begin{matrix} 2 &amp; 1 &amp; -1 &amp;|&amp; 8 \\\\ 0 &amp; 1/2 &amp; 1/2 &amp; | &amp; 1 \\\\ 0 &amp; 0 &amp; -1 &amp; | &amp; 1 \\end{matrix} \\right] =&gt; \\left[ \\begin{matrix} 1 &amp; 0 &amp; 0 &amp;|&amp; 2 \\\\ 0 &amp; 1 &amp; 0 &amp; | &amp; 3 \\\\ 0 &amp; 0 &amp; 1 &amp; | &amp; -1 \\end{matrix} \\right] $$ 前向替换法就是得到行阶梯矩阵后 能写出以下式子 $$ \\begin{cases} x_1 = b_1/a_{11} \\\\ x_2 = (b_2-a_{21}x_1)/a_{22} \\\\ \\ \\vdots \\\\ x_n = (b_n -a_{n1}x_1-a_{n2}x_2 - \\cdots -a_{nn-1}x_{n-1})/a_{nm} \\end{cases} $$ 于是我们只需要从第一个式子开始，逐步向下替换，就能求出方程的解 如果是下三角矩阵，那就是后向替换 &#x2F;&#x2F;a是一个下三角矩阵，x、b是向量 void serialFS(std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; a, std::vector&lt;double&gt;&amp; b) &#123; const int N &#x3D; x.size(); for (int i &#x3D; 0; i &lt; N; ++i) &#123; for (int j &#x3D; 0; j &lt; i; ++j) &#123; b[i] -&#x3D; a[j + i*N] * x[j]; &#125; x[i] &#x3D; b[i] &#x2F; a[i + i*N]; &#125; &#125; 加入分块和并行后： void parallelFS(std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b) &#123; const int N &#x3D; x.size(); const int block_size &#x3D; 512; const int num_blocks &#x3D; N &#x2F; block_size; &#x2F;&#x2F;tbb::atomic已经废弃 std::vector&lt;std::atomic&lt;char&gt;&gt; ref_count(num_blocks * num_blocks); for (int r &#x3D; 0; r &lt; num_blocks; ++r) &#123; for (int c &#x3D; 0; c &lt;&#x3D; r; ++c) &#123; if (r &#x3D;&#x3D; 0 &amp;&amp; c &#x3D;&#x3D; 0) ref_count[r * num_blocks + c] &#x3D; 0; else if (c &#x3D;&#x3D; 0 || r &#x3D;&#x3D; c) ref_count[r * num_blocks + c] &#x3D; 1; else ref_count[r * num_blocks + c] &#x3D; 2; &#125; &#125; using BlockIndex &#x3D; std::pair&lt;size_t, size_t&gt;; BlockIndex top_left(0, 0); &#x2F;&#x2F;tbb::parallel_do已经废弃 tbb::parallel_for_each(&amp;top_left, &amp;top_left + 1, [&amp;](const BlockIndex &amp;bi, tbb::feeder&lt;BlockIndex&gt; &amp;feeder) &#123; size_t r &#x3D; bi.first; size_t c &#x3D; bi.second; int i_start &#x3D; r * block_size, i_end &#x3D; i_start + block_size; int j_start &#x3D; c * block_size, j_max &#x3D; j_start + block_size - 1; for (int i &#x3D; i_start; i &lt; i_end; ++i) &#123; int j_end &#x3D; (i &lt;&#x3D; j_max) ? i : j_max + 1; for (int j &#x3D; j_start; j &lt; j_end; ++j) &#123; b[i] -&#x3D; a[j + i * N] * x[j]; &#125; if (j_end &#x3D;&#x3D; i) &#123; x[i] &#x3D; b[i] &#x2F; a[i + i * N]; &#125; &#125; &#x2F;&#x2F; add successor to right if ready if (c + 1 &lt;&#x3D; r &amp;&amp; --ref_count[r * num_blocks + c + 1] &#x3D;&#x3D; 0) &#123; feeder.add(BlockIndex(r, c + 1)); &#125; &#x2F;&#x2F; add succesor below if ready if (r + 1 &lt; (size_t) num_blocks &amp;&amp; --ref_count[(r + 1) * num_blocks + c] &#x3D;&#x3D; 0) &#123; feeder.add(BlockIndex(r + 1, c)); &#125; &#125; ); &#125; 流水线 void parallel_pipeline( size_t max_number_of_live_tokens, const filter&lt;void,void&gt;&amp; filter_chain ); template&lt;typename T, typename U, typename Func&gt; filter_t&lt;T, U&gt; make_filter(filter::mode mode, const Func&amp; f); 管线（pipeline）是过滤器（filters）的线性序列，物体（items）在通过过滤器时，会被处理 &#x2F;&#x2F;并行 将字符串中大写变小写 void fig_2_27(int num_tokens, std::ofstream &amp;caseBeforeFile, std::ofstream &amp;caseAfterFile) &#123; tbb::parallel_pipeline( &#x2F;&#x2F;tokens num_tokens, &#x2F;&#x2F;第一个filter，负责创建字符串 tbb::make_filter&lt;void, CaseStringPtr&gt;( &#x2F;&#x2F;tbb::filter::serial_in_order已经废弃 tbb::filter_mode::serial_in_order, &#x2F;&#x2F;filter body [&amp;](tbb::flow_control &amp;fc) -&gt; CaseStringPtr &#123; CaseStringPtr s_ptr &#x3D; getCaseString(caseBeforeFile); if (!s_ptr) fc.stop(); return s_ptr; &#125;) &amp; &#x2F;&#x2F; 链接 &#x2F;&#x2F;第二个filter，负责修改字符串 tbb::make_filter&lt;CaseStringPtr, CaseStringPtr&gt;( &#x2F;&#x2F;filter node tbb::filter_mode::parallel, &#x2F;&#x2F;filter body [](CaseStringPtr s_ptr) -&gt; CaseStringPtr &#123; std::transform(s_ptr-&gt;begin(), s_ptr-&gt;end(), s_ptr-&gt;begin(), [](char c) -&gt; char &#123; if (std::islower(c)) return std::toupper(c); else if (std::isupper(c)) return std::tolower(c); else return c; &#125;); return s_ptr; &#125;) &amp; &#x2F;&#x2F;链接 &#x2F;&#x2F;第三个filter，负责写字符串 tbb::make_filter&lt;CaseStringPtr, void&gt;( &#x2F;&#x2F;filter node tbb::filter_mode::serial_in_order, &#x2F;&#x2F;filter body [&amp;](CaseStringPtr s_ptr) -&gt; void &#123; writeCaseString(caseAfterFile, s_ptr); &#125;) ); &#125; Flow Graphs 并行编程另一个问题是混乱，传统并行编程为了避免程序混乱（messy），我们需要事无巨细地管理每一件事。但在上一节简单提到的Flow Graphs，提供了一个简单的管理方法 Flow Graphs允许我们用图（DAG）来描述程序，相比于parallel_do和parallel_pipeline，FlowGraphs自由度更高，推荐使用。 每个节点是一个并行函数，箭头代表数据的流向/消息传递，我们将这个图称为数据流向图（data flow graphs） 图也可以描述操作的前后顺序，进而可以构建一些传统方法难以表示的独立结构体，这种图被称为依赖图（dependency graphs） 预热 static void warmupTBB() &#123; &#x2F;&#x2F;tbb::task_scheduler_init::default_num_threads()已经弃用 tbb::parallel_for(0, tbb::this_task_arena::max_concurrency(), [](int) &#123; tbb::tick_count t0 &#x3D; tbb::tick_count::now(); while ((tbb::tick_count::now() - t0).seconds() &lt; 0.01); &#125;); &#125; 无论是web服务器、CPU/GPU并行计算，深度学习，都有warmup的概念 对于一个项目，如果采用冷启动的方式，从零瞬间增加计算量，可能会把系统压垮，于是我们可以使用warmup，逐步提高项目负荷。 数据流图 构建图对象 创建节点，填充节点信息 链接节点 发送消息 等待图完成 void graphSample()&#123; &#x2F;&#x2F;创建图对象 tbb::flow::graph g; &#x2F;&#x2F;创建节点 tbb::flow::function_node&lt;int, std::string&gt; my_first_node( g, tbb::flow::unlimited, [](const int &amp;in) -&gt; std::string&#123; std::cout &lt;&lt; &quot;first node received: &quot; &lt;&lt; in &lt;&lt; std::endl; return std::to_string(in); &#125; ); tbb::flow::function_node&lt;std::string&gt; my_second_node( g, tbb::flow::unlimited, [](const std::string &amp;in)&#123; std::cout &lt;&lt; &quot;second node received: &quot; &lt;&lt; in &lt;&lt; std::endl; &#125; ); &#x2F;&#x2F;链接 tbb::flow::make_edge(my_first_node, my_second_node); &#x2F;&#x2F;发送消息 my_first_node.try_put(10); &#x2F;&#x2F;等待图完成 g.wait_for_all(); &#125; 节点 Flow Graphs有三种节点 functional control flow buffering function_node template&lt;typename Body&gt; function_node(graph&amp; g, size_t concurrency, Body body); 函数节点，当消息传递到该节点，会被函数处理，并将输出值传递给后继者 &#x2F;&#x2F;输入一个int类型，输出一个std::string类型 tbb::flow::function_node&lt;int, std::string&gt; my_first_node( &#x2F;&#x2F;图对象 g, &#x2F;&#x2F;节点的并发限制，0是无限制(unlimited)，1是串行(serial) tbb::flow::unlimited, &#x2F;&#x2F;body [](const int &amp;in) -&gt; std::string&#123; std::cout &lt;&lt; &quot;first node received: &quot; &lt;&lt; in &lt;&lt; std::endl; return std::to_string(in); &#125; ); 函数节点可以从他所连接（edges）其他节点获取消息，也可以使用try_put手动向其传递消息 join_node template &lt;typename Body, typename... Bodies&gt; join_node(graph&amp;, Body, Bodies...)-&gt;join_node&lt;std::tuple&lt;std::decay_t&lt;input_t&lt;Body&gt;&gt;, std::decay_t&lt;input_t&lt;Bodies&gt;&gt;...&gt;, key_matching&lt;output_t&lt;Body&gt;&gt;&gt;; 流控制节点，当消息传递到该节点，会创建一个消息元组（tuple），然后将元组广播给所有后继者 &#x2F;&#x2F;my_node，输入int，输出std::string tbb::flow::function_node&lt;int, std::string&gt; my_node&#123;...&#125;; &#x2F;&#x2F;my_other_node，输入int，输出double tbb::flow::function_node&lt;int, double&gt; my_other_node&#123;...&#125;; &#x2F;&#x2F;join节点，这里的作用是将两个节点的输出整合，传递给my_final_node tbb::flow::join_node&lt;std::tuple&lt;std::string, double&gt;, tbb::flow::queueing&gt; my_join_node&#123;g&#125;; &#x2F;&#x2F;my_final_node，输入一个元组 tbb::flow::function_node&lt;std::tuple&lt;std::string, double&gt;, int&gt; my_final_node&#123;g, tbb::flow::unlimited, [](const std::tuple&lt;std::string, double&gt;&amp; in) -&gt; int &#123; std::cout &lt;&lt; &quot;final: &quot; &lt;&lt; std::get&lt;0&gt;(in) &lt;&lt; &quot; and &quot; &lt;&lt; std::get&lt;1&gt;(in) &lt;&lt; std::endl; return 0; &#125; &#125;; 有的时候，我们需要保证join_node的输入的对应的。比如我想将两张照片拼成一张，我开两个节点并行读项目，再用join_node整合后传入merge函数节点，然而在这个过程中，我必须保证传入的两个像素点在同一位置，为此，我们可以添加一个frameNumber做标记（tags） &#x2F;&#x2F;使用函数对象作为tags，可以用input_port&lt;i&gt;读出来 tbb::flow::join_node&lt;std::tuple&lt;Image, Image&gt;, tbb::flow::tag_matching &gt; join_images_node(g, [] (Image left) &#123; return left.frameNumber; &#125;, [] (Image right) &#123; return right.frameNumber; &#125; ); ... tbb::flow::make_edge(increase_left_node, tbb::flow::input_port&lt;0&gt;(join_images_node)); tbb::flow::make_edge(increase_right_node, tbb::flow::input_port&lt;1&gt;(join_images_node)); tbb::flow::make_edge(join_images_node, merge_images_node); 链接 template&lt;typename Message&gt; inline void make_edge( sender&lt;Message&gt; &amp;p, receiver&lt;Message&gt; &amp;s ); template&lt; typename MultiOutputNode, typename MultiInputNode &gt; inline void make_edge( MultiOutputNode&amp; output, MultiInputNode&amp; input ); 我们可以使用make_edge链接两个节点 &#x2F;&#x2F;这里的input_port是一种sender，跟节点差不多，都能互相链接 make_edge(my_node, tbb::flow::input_port&lt;0&gt;(my_join_node)); make_edge(my_other_node, tbb::flow::input_port&lt;1&gt;(my_join_node)); make_edge(my_join_node, my_final_node); 激活 为了激活图，我们需要向图中传递消息，除了前文的try_put，我们也可以使用input_port &#x2F;&#x2F;my_node是一个input_node my_node.activate(); &#x2F;&#x2F;将其设为活动状态，启用消息生成 等待 g.wait_for_all(); 性能限制 Flow Graphs是一个基于Task的并行框架，当消息到达一个节点时，根据节点的并发限制，创建Task。生成的Task会进一步映射为线程（跟上一节讲的循环、算法的机制一样） 真正限制Flow Graphs性能的有 串行节点（serial node） 工作线程数 任务复杂度 依赖图 很像RenderGraph 数据流向图 依赖图 Edges含义 表示数据流向 表示节点的先后顺序 信息传递方式 消息 shared memory 节点类型 function_node continue_node 节点的先后顺序，描述的是依赖关系，只有前面节点执行结束后，后面节点才能安全、正确地执行 依赖图不使用函数节点，而是继续节点continue_node，节点间的消息传递使用，当传入continue_node的消息（continue_msg）数量等于该节点需要的消息数量，节点内的函数会开始执行 continue_node只关心传入的消息数量，不关心消息源。这导致依赖图必须是非循环的（acyclic），因为一个物体循环发出两次消息，（在这里）等同于两个物体各发出一次消息 构建依赖图 创建图对象 创建节点 链接 发送信息 等待图完成 前向替换 之前我们使用parallel_for_each实现了一份前向替换，我们现在用依赖图再实现一次 经观察，我们发现辅对角线的块/迭代器是相互独立的，他们之间没有依赖关系（上图(b)，块BC间没有依赖，他们只需要在A之后执行就可以正确运算） 经观察，同时并行计算的最大块数为辅对角线的长度，也就是图中标注的 a set of independent blocks 经观察，上图(b)中每一个块需要接受两个msg，正好与block_sizes大小相等 using Node &#x3D; tbb::flow::continue_node&lt;tbb::flow::continue_msg&gt;; using NodePtr &#x3D; std::shared_ptr&lt;Node&gt;; NodePtr createNode(tbb::flow::graph &amp;g, int r, int c, int block_size, std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b); void addEdges(std::vector&lt;NodePtr&gt; &amp;nodes, int r, int c, int block_size, int num_blocks); void dependencyGraphFS(std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b)&#123; const int N &#x3D; x.size(); const int block_size &#x3D; 1024; const int num_blocks &#x3D; N &#x2F; block_size; &#x2F;&#x2F;创建num_blocks * num_blocks个节点，只不过我们只会用到下半部分 std::vector&lt;NodePtr&gt; nodes(num_blocks * num_blocks); &#x2F;&#x2F;创建图对象 tbb::flow::graph g; &#x2F;&#x2F;我们从最下面一行开始向上构建 for(int r &#x3D; num_blocks-1; r &gt;&#x3D; 0; --r)&#123; for(int c &#x3D; r; c &gt;&#x3D; 0; --c)&#123; &#x2F;&#x2F;创建图节点 nodes[r * num_blocks + c] &#x3D; createNode(g, r, c, block_size, x, a, b); &#x2F;&#x2F;链接 addEdges(nodes, r, c, block_size, num_blocks); &#125; &#125; &#x2F;&#x2F;传入消息 nodes[0]-&gt;try_put(tbb::flow::continue_msg()); &#x2F;&#x2F;等待完成 g.wait_for_all(); &#125; NodePtr createNode(tbb::flow::graph &amp;g, int r, int c, int block_size, std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b)&#123; const int N &#x3D; x.size(); return std::make_shared&lt;Node&gt;( g, [r, c, block_size, N, &amp;x, &amp;a, &amp;b](const tbb::flow::continue_msg &amp; msg)&#123; int i_start &#x3D; r * block_size, i_end &#x3D; i_start + block_size; int j_start &#x3D; c * block_size, j_max &#x3D; j_start + block_size -1; &#x2F;&#x2F;对于每个块，串行进行正向替换计算 for(int i &#x3D; i_start; i &lt; i_end; ++i)&#123; int j_end &#x3D; (i &lt;&#x3D; j_max) ? i : j_max+1; for(int j &#x3D; j_start; j &lt; j_end; ++j)&#123; b[i] -&#x3D; a[j + i*N] * x[j]; &#125; if(j_end &#x3D;&#x3D; i)&#123; x[i] &#x3D; b[i] &#x2F; a[i + i*N]; &#125; &#125; return msg; &#125; ); &#125; void addEdges(std::vector&lt;NodePtr&gt; &amp;nodes, int r, int c, int block_size, int num_blocks)&#123; NodePtr np &#x3D; nodes[r * num_blocks + c]; &#x2F;&#x2F;每个块链接自己的下面和右边，最下面和最右边不链接 if(c + 1 &lt; num_blocks &amp;&amp; r !&#x3D; c)&#123; tbb::flow::make_edge(*np, *nodes[r * num_blocks + c + 1]); &#125; if(r + 1 &lt; num_blocks)&#123; tbb::flow::make_edge(*np, *nodes[(r+1) * num_blocks + c]); &#125; &#125; PSTL parallel_sort 同步 在并行编程中，我们要极力避免同步（Synchronization）和互斥（exclusion），这会严重影响性能 但是很多情况下，我们不得不同步，书中称其为“必要之恶”（necessary evil） 写冲突 比如我们想要统计一张图中各种颜色出现的次数，如果是串行处理，我们就遍历每一个像素，用一个数组存储统计值 for(int i &#x3D; 0; i &lt; N; ++i)&#123; hist[image[i]]++; &#125; 但当我们想要并行处理遍历像素时，就会出现问题。如果两个线程同时读到了同一种颜色，于是都想执行hist[p]++，而如果该操作不支持原子（atomic）操作，就会出现写冲突 RMW 现代操作系统将很多操作设置为原子操作，该操作被视为一个完成的操作，不可分割，因此是线程安全的。比如对齐读（Aligned Read），对齐写（Aligned Write） 原子的本意就是不可分割的意思，当年化学家和物理学家认为原子是最小的粒子（尽管并非如此） Read-Modify-Write（RMW）设计原则，可以让复杂操作原子化，当多个线程想要对某个内存进行修改时，保证线程安全并只执行一次 windows原子操作的实现原理（_InterlockedIncrement） 读内存 计算得到新值 若内存位置仍然是原始值，则将新值写入该内存位置 若不是原始值，则在下一个循环周期中重新操作 锁 解决并行写冲突最简单的方法就是加锁，我们给对象加一个互斥锁（mutex），写之前上锁，写完解锁，其他线程无法操作锁住的对象。而上锁解锁操作中间的代码被称为临界区（critical section），是被锁保护的部分。 锁会影响性能 &#x2F;&#x2F;tbb::task_scheduler_init init&#123;nth&#125;已经弃用，用于设置最大线程数 tbb::global_control global_limit(tbb::global_control::max_allowed_parallelism, nth); using my_mutex_t&#x3D;tbb::spin_mutex; my_mutex_t my_mutex; std::vector&lt;int&gt; hist_p(num_bins); parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r) &#123; &#x2F;&#x2F;这种写法比my_lock.acquire(my_mutex)、my_lock.release()好 my_mutex_t::scoped_lock my_lock&#123;my_mutex&#125;; for (size_t i &#x3D; r.begin(); i &lt; r.end(); ++i) hist_p[image[i]]++; &#125;); 原子操作 锁过于消耗性能，原子操作效果会好一些，只不过这样还是比线性慢，而且不是真共享（Sharing） 什么是原子？原子的原意就是不可分割的基本粒子，我们在实现a++时，本质是分了三步 取a 加法运算 写a 由于并行计算，其他线程可能在你完整完成这三步期间进行操作，于是就会出现冲突。而原子操作就是将这三步视为一步，不可分割，在完整完成这三部之前，其他线程无权访问，等到操作结束 std::vector&lt;std::atomic&lt;int&gt;&gt; hist_p2(num_bins); parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r) &#123; for(size_t i &#x3D; r.begin(); i &lt; r.end(); ++i) &#123; hist_p2[image[i]]++; &#125; &#125; ); Thread Local Storage 一个较好的解决方案是私有化（Privatization）和归并（Reduction） 我感觉这个的设计理念就是：如果不得不同步，那就尽可能让更多更复杂的计算并行执行，最后对统一、规范、简单的数据进行同步 前面并行统计Image像素信息时，会出现多个线程写冲突。但如果让每个线程都有一个Image副本，线程对自己的副本进行操作（私有化），最后将这些副本进行归并。 私有化确实不会出现写冲突了，尽管归并仍然存在同步问题，但这个归并更简单，毕竟归并几个数，远远比处理几个线程冲突要简单，性能开销小 TBB提供了多种私有化+归并的的方案，其中归并模板（parallel_reduce）在TBB基础时就讲了 Thread Local Storage（TLS）：让每一个线程拥有一份副本，只不过存储开销过大，不宜过多使用 enumerable_thread_specific（ETS） combinable ETS tbb::enumerable_thread_specific&lt;T&gt;对象是一个大容器，容器内包含者每一个线程所对应的副本，我们可以使用迭代器进行访问 using vector_t &#x3D; std::vector&lt;int&gt;; using priv_h_t &#x3D; tbb::enumerable_thread_specific&lt;vector_t&gt;; priv_h_t priv_h&#123;num_bins&#125;; &#x2F;&#x2F;私有化 parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r) &#123; &#x2F;&#x2F;若该线程第一次使用local，那么会创建一个新的vector&lt;int&gt;，初始值为0 priv_h_t::reference my_hist &#x3D; priv_h.local(); for (size_t i &#x3D; r.begin(); i &lt; r.end(); ++i)&#123; &#x2F;&#x2F;my_hist是引用，实际上是在修改priv_h[xxx]，以此将数据传递到线程外 my_hist[image[i]]++; &#125; &#125;); &#x2F;&#x2F;归并 vector_t hist_p3(num_bins); for(auto i&#x3D;priv_h.begin(); i!&#x3D;priv_h.end(); ++i)&#123; for (int j&#x3D;0; j&lt;num_bins; ++j) &#123; hist_p3[j]+&#x3D;(*i)[j]; &#125; &#125; 使用STL算法替代循环，进行归并 &#x2F;&#x2F;我们可以使用transform替代循环遍历 for (auto&amp; i: priv_h) &#123; &#x2F;&#x2F; i traverses all private vectors std::transform(hist_p3.begin(), &#x2F;&#x2F; source 1 begin hist_p3.end(), &#x2F;&#x2F; source 1 end i.begin(), &#x2F;&#x2F; source 2 begin hist_p3.begin(), &#x2F;&#x2F; destination begin std::plus&lt;int&gt;() ); &#x2F;&#x2F; binary operation &#125; 由于归并过于常用，TBB也对归并做了封装 &#x2F;&#x2F;使用combine_each priv_h.combine_each([&amp;](vector_t i)&#123; std::transform(hist_p3.begin(), &#x2F;&#x2F; source 1 begin hist_p3.end(), &#x2F;&#x2F; source 1 end i.begin(), &#x2F;&#x2F; source 2 begin hist_p3.begin(), &#x2F;&#x2F; destination begin std::plus&lt;int&gt;() ); &#x2F;&#x2F; binary operation &#125;); &#x2F;&#x2F;或者使用combine vector_t hist_p &#x3D; priv_h.combine([](vector_t a, vector_t b) -&gt; vector_t &#123; std::transform(a.begin(), &#x2F;&#x2F; source 1 begin a.end(), &#x2F;&#x2F; source 1 end b.begin(), &#x2F;&#x2F; source 2 begin a.begin(), &#x2F;&#x2F; destination begin std::plus&lt;int&gt;() );&#x2F;&#x2F; binary operation return a; &#125;); combinable combinable&lt;T&gt;对象也是一个容器，每一个线程对应一个instance 但是与ETS不同，combinable&lt;T&gt;并不能使用迭代器访问，这样设计的目的是不向外暴露对象，这样归并结束后大容器和其中的数据都释放了，以此节省局部空间 &#x2F;&#x2F;combinable tbb::combinable&lt;vector_t&gt; priv_h2&#123;[num_bins]()&#123;return vector_t(num_bins);&#125;&#125;; &#x2F;&#x2F;私有化 parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r) &#123; vector_t&amp; my_hist &#x3D; priv_h2.local(); for (size_t i &#x3D; r.begin(); i &lt; r.end(); ++i) my_hist[image[i]]++; &#125;); &#x2F;&#x2F;归并 vector_t hist_p4(num_bins); priv_h2.combine_each([&amp;](vector_t i) &#123; &#x2F;&#x2F; for each priv histogram a std::transform(hist_p4.begin(), &#x2F;&#x2F; source 1 begin hist_p4.end(), &#x2F;&#x2F; source 1 end i.begin(), &#x2F;&#x2F; source 2 begin hist_p4.begin(), &#x2F;&#x2F; destination begin std::plus&lt;int&gt;() ); &#x2F;&#x2F; binary operation &#125;); 最终性能比较，能看出TLS能大幅提高性能 Serial: 0.399203 Parallel: 2.01466 Atomic: 0.500326 ETC: 0.0348115 combinable: 0.0339478 parallel_reduce 最简单的归并，还是给用tbb封装好的模板，该算法的本质是树形规约 &#x2F;&#x2F;parallel_reduce using image_iterator &#x3D; std::vector&lt;uint8_t&gt;::iterator; t0 &#x3D; tbb::tick_count::now(); vector_t hist_p5 &#x3D; parallel_reduce ( &#x2F;*range*&#x2F; tbb::blocked_range&lt;image_iterator&gt;&#123;image.begin(), image.end()&#125;, &#x2F;*identity*&#x2F; vector_t(num_bins), &#x2F;&#x2F; 1st Lambda: Parallel computation on private histograms [](const tbb::blocked_range&lt;image_iterator&gt;&amp; r, vector_t v) &#123; std::for_each(r.begin(), r.end(), [&amp;v](uint8_t i) &#123;v[i]++;&#125;); return v; &#125;, &#x2F;&#x2F; 2nd Lambda: Parallel reduction of the private histograms [num_bins](vector_t a, const vector_t &amp; b) -&gt; vector_t &#123; for(int i&#x3D;0; i&lt;num_bins; ++i) a[i] +&#x3D; b[i]; return a; &#125;); 并发容器 在上一节我们遇到了同步问题，处理同步会大幅降低性能，为此我们使用了TLS等方法实现了高效的显式同步，而这一节，我们将介绍TBB的核心，并发（Concurrent） TBB提供了一些高效、线程安全的并发容器，他们大多是使用细粒度的锁或者无锁设计 细粒度锁：指锁定真正需要锁定的地方（其实还是挺低效的），比如一个数组我们只锁我们需要的某一个元素，其他线程如果不访问我这个元素，就能正常并行 无锁：有的线程负责操作，有的线程负责纠错 TBB的并发容器并发性能很好，但串行性能不如STL 顺序表（Sequences） concurrent_vector 队列（Queues） concurrent_queue concurrent_bounded_queue concurrent_priority_queue 无序关联容器（Unordered associative containers） concurrent_hash_map map/multimap set/multiset 有序关联容器（Ordered associative containers） map/multimap set/multiset concurrent_hash_map template &lt;typename Key, typename T, typename HashCompare &#x3D; tbb_hash_compare&lt;Key&gt;, typename Allocator &#x3D; tbb_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt; class concurrent_hash_map &#123;..&#125; 这是一个字符串-Int的哈希表 &#x2F;&#x2F;HashCompare必须有hash函数和equal函数 struct MyHashCompare&#123; static size_t hash(const std::string&amp; s)&#123; size_t h &#x3D; 0; for(auto &amp;c : s)&#123; h &#x3D; (h*17)^c; &#125; return h; &#125; static bool equal(const std::string&amp; x, const std::string&amp; y)&#123; return x &#x3D;&#x3D; y; &#125; &#125;; &#x2F;&#x2F;hash map typedef tbb::concurrent_hash_map&lt;std::string, int, MyHashCompare&gt; StringTable; &#x2F;&#x2F;一个函数对象，用于记录table内元素数量 class Tally&#123; private: StringTable&amp; table; public: Tally(StringTable&amp; table_): table(table_) &#123;&#125; void operator() (const tbb::blocked_range&lt;std::string*&gt; range) const &#123; for(std::string* p &#x3D; range.begin(); p !&#x3D; range.end(); ++p)&#123; &#x2F;&#x2F;accessor类似于锁、智能智能，在accessor完成前，其他线程不能lookup这个key StringTable::accessor a; table.insert(a, *p); a-&gt;second +&#x3D; 1; &#125; &#125; &#125;; int main() &#123; StringTable table; tbb::parallel_for( tbb::blocked_range&lt;std::string*&gt;( Data, Data+N, 1000 ), Tally(table) ); for( StringTable::iterator i&#x3D;table.begin(); i!&#x3D;table.end(); ++i ) printf(&quot;%s %d\\n&quot;,i-&gt;first.c_str(),i-&gt;second); return 0; &#125; 内存分配 内存分配最重要的是正确，TBB提供了一套可拓展的内存分配 现代C++推荐使用智能指针进行内存管理，不推荐使用malloc和new。TBB完全适配所有版本的C++标准，也推荐使用智能指针进行内存分配 TBB动态内存分配的核心是线程内存池（memory pooling by threads），该内存池可以避免内存分配带来的性能下降，也不苛求“避免cache间不必要的数据移动” TBB还提供了可拓展的缓存对齐，比std::aligned_alloc使用更简单方便。只不过滥用缓存对齐可能会带了巨大的内存浪费 在并行编程中，内存分配的主要问题是：分配器的争用，缓存效果 分配器争用：C++内存分存储在两个位置，堆和栈。传统的非线程分配器只能在单个全局堆中分配和释放内存，这个过程配合锁以实现互斥，很低效 缓存效应：某些操作可能会把缓存中的数据移动到缓存的另一处，这是很无效的行为，要避免 缓存填充（对齐） 用于解决假共享（我们在同步那一节解决了真共享带来的问题） 基于局部性原则，当CPU查询某个数据时： 若cache中没有找到，就会去内存中寻找 找到后会将该数据写入cache（时间局部性，刚刚被引用过的一个内存位置容易再次被引用） 并将其相邻元素也写入cache（空间局部性，一个内存位置被引用，其相邻位置很可能马上被引用） 如上图，CPU访问a时，先去cache去找，如果cache中没有，就会去内存中寻找，找到后将a和相邻的b写入cache的同一行。但问题出现了，如果当前cache的其他行里，已经有b了呢？ 另一个线程也拥有一缓存行，里面存储了b，结果b却被移动到a那一行了，于是这个线程要访问b，又要去内存中找，增加了cache miss。此外多线程中，a那个线程多半是不会用到b的，于是平白做了cache位置的移动。 这个现象被称为假共享（false sharing），a和b并不是共享对象，但是由于他们靠的太近了，以至于在一个缓存行中，其中一个对象的更新，会强制另一个对象更新。 在多线程中，假共享可以通过缓存填充（cache padding）解决。缓存填充，就是在缓存中两个变量中间填充一些没有意义的数据，于是导致这两个变量不会处于同一个缓存行中，于是避免了假共享。 我们还是以统计图片像素为例，我们发现这种方法比直接用原子操作要快一些 struct bin&#123; std::atomic&lt;int&gt; count; &#x2F;&#x2F;4 bytes uint8_t padding[64 - sizeof(count)]; &#x2F;&#x2F;60 bytes &#125;; &#x2F;&#x2F;cache padding std::vector&lt;bin, tbb::cache_aligned_allocator&lt;bin&gt;&gt; hist_p6(num_bins); t0 &#x3D; tbb::tick_count::now(); parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r) &#123; for(size_t i &#x3D; r.begin(); i &lt; r.end(); ++i) &#123; hist_p6[image[i]].count++; &#125; &#125; ); 我们可以用C++特性来创建结构体： struct bin&#123; &#x2F;&#x2F;C++17后，可以用std::hardware_destructive_interference_size替代64 alignas(64) std::atomic&lt;int&gt; count; &#125;; 代理 TBB的TBBmalloc库使用代理方法，可以实现在不同操作系统，不改变代码，只需要配置一些动态库、代理库、环境变量，就可以实现全局替换new、malloc等分配函数，这对跨平台真的很重要 Task调度 Chapter10 资料 Pro TBB API Document 代码仓库","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://reubensun.com/tags/C/"},{"name":"并行计算","slug":"并行计算","permalink":"https://reubensun.com/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"}]},{"title":"CMake入门","slug":"program/CMake入门","date":"2023-02-01T10:01:25.000Z","updated":"2023-03-28T02:56:19.635Z","comments":true,"path":"program/CMake入门/","link":"","permalink":"https://reubensun.com/program/CMake%E5%85%A5%E9%97%A8/","excerpt":"","text":"CMake 快速入门 一个大项目（Project）内嵌多个子项目（SubProject） 一个子项目内有src、include、CMakeLists.txt，其中有一个子项目中有main.cpp 最外面的CMakeLists.txt，负责连接所有子项目： cmake_minimum_required(VERSION 3.20) project(Project) set(CMAKE_CXX_STANDARD 14) add_subdirectory(subProject1) add_subdirectory(subProject2) subProject1（main.cpp所在的子项目）下面的CMakeLists.txt： file(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp include/*.h) add_executable(subProject1 $&#123;srcs&#125;) target_include_directories(subProject1 PUBLIC include) target_link_libraries(subProject1 PUBLIC subProject2) subProject2下面的CMakeLists.txt： file(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp include/*.h) add_library(subProject2 STATIC $&#123;srcs&#125;) target_include_directories(subProject2 PUBLIC include) 生成sln项目 $cmake -G \"Visual Studio 16 2019\" 用vs打开sln项目能看到2+n个项目，其中 ALL_BUILD：编译该项目会编译整个工程 ZERO_CHECK：监视CMakeLists.txt的变化，一旦改变会告诉编译器重新构建工程 或者可以用make构建项目 $cmake -H. -Bbuild 一：CMake基础语法 CMakeLists.txt 我们将CMake指令放在CMakeLists.txt文件中 #设置CMake所需最低版本 cmake_minimum_required(VERSION 3.20) #设置项目名称为CMakeStudy，支持的语言为C++（CXX表示C++） project(CMakeStudy LANGUAGES CXX) #设置创建的新目标名称：一个名叫CMakeStudy的可执行文件 #这个可执行文件是通过编译和链接源文件main.cpp生成的 add_executable(CMakeStudy main.cpp) CMake语言不区分大小写，但参数区分大小写 CMake的缺省默认语言为C++ 构建 写好CMakeLists.txt文件后，在命令行中输入： $cmake -H. -Bbuild 这个命令会搜索当前目录下的根CMakeLists.txt文件，创建一个build目录，在其中生成所有的代码 然后再build目录中输入命令，以完成编译 $cmake --build . 一般我们不会在源码内部构建，因为这会污染源码的目录树 链接 如果项目中有多个文件，如 可以改目标生成 add_executable(hello main.cpp Message.cpp Message.h) 但是这种改法太麻烦了，每添加一个文件就要在后面添一端，最后这东西会特别长 我们可以把这个类编译成一个（静态）库，然后再将库链接到可执行文件中（你还记得c++编译器的编译步骤吗？） cmake_minimum_required(VERSION 3.20) project(CMakeStudy LANGUAGES CXX) #将两个文件编译成库 add_library(message STATIC Message.h Message.cpp) #目标不变 add_executable(hello main.cpp) #链接 target_link_libraries(hello message) 此外，我们能在buid目录中找到一个名为/形如libmessage.a的文件，这就是编译得到的静态库 add_library 生成一个名叫message的库 add_library(message STATIC Message.h Message.cpp) 第一个参数是目标名，后续可以使用该名来引用库 第二个参数是库的种类 STATIC：静态库 SHARED：动态库 OBJECT：对象库（将代码编译到可执行文件内部的静态库） MODULE：一种不会链接到项目中任何目标的动态共享对象（DSO），可以运行时动态加载 此外CMake还有一些不会出现在构建系统里的库 IMPORTED：项目外部的库，用于对现有依赖项进行构建，认为是不可变的 INTERFACE：也是项目之外的库，但是可变 ALIAS：对已有的库做别名 条件语句 在讲链接时，我们给出了两种编译方法，我们希望能在两种方式间切换 cmake_minimum_required(VERSION 3.20) project(CMakeStudy LANGUAGES CXX) #引入一个新变量USE_LIBRARY，设置为OFF set(USE_LIBRARY OFF) #打印信息 message(STATUS \"Compile sources into a library? $&#123;USE_LIBRARY&#125;\") set(BUILD_SHARED_LIBS OFF) #引入一个list变量: _sources，包含两个文件 list(APPEND _sources Message.h Message.cpp) #判断，若USE_LIBRARY为真，则编译成库 if(USE_LIBRARY) add_library(message $&#123;_sources&#125;) add_executable(hello main.cpp) target_link_libraries(hello message) else() add_executable(hello main.cpp $&#123;_sources&#125;) endif() 逻辑变量 true：1、ON、YES、true、Y、非零数 false：0、OFF、NO、false、N、IGNORE、NOTFOUND、空字符串、以-NOTFOUND为后缀 全局变量 CMake有一些全局变量，修改他们可以起到配置作用，这里设置的 set(BUILD_SHARED_LIBS OFF) 当设置为OFF时，可以使add_library不用传递第二个参数 变量名 含义 CMAKE_RUNTIME_OUTPUT_DIRECTORY .exe、.dll文件的输出路径 CMAKE_ARCHIVE_OUTPUT_DIRECTORY .a文件的输出路径 CMAKE_LIBRARY_OUTPUT_DIRECTORY .so文件的输出路径 CMAKE_CURRENT_SOURCE_DIR 当前CMakeLists.txt所在路径 PROJECT_NAME 项目名字 CMAKE_MODULE_PATH cmake模块所在路径 用户选项 在上面我们引入了一个条件语句，但是是硬编码的。我们希望用户可以控制USE_LIBRARY，于是可以使用option #set(USE_LIBRARY OFF) option(USE_LIBRARY \"Compile sources into a library\" OFF) 将上面下面的set替换为option，运行 $cmake -D USE_LIBRARY=ON 如果是Clion可以配置 构建类型 类型 有无优化 Debug 没有优化，带调试符号 Release 有优化，没有调试符号 RelWithDebInfo 有少量优化，带调试符号 MinSizeRel 不增加代码大小来优化 编译选项 cmake_minimum_required(VERSION 3.20) project(CMakeStudy LANGUAGES CXX) list(APPEND flags \"-fPIC\" \"-Wall\") if(NOT WIN32) list(APPEND flags \"-Wextra\" \"-Wpedantic\") endif() #添加一个库 add_library(message STATIC Message.h Message.cpp ) #为库设置编译选项 target_compile_options(message PRIVATE $&#123;flags&#125; ) #添加可执行目标 add_executable(hello main.cpp) #为可执行目标设置编译选项 target_compile_options(hello PRIVATE \"-fPIC\" ) #链接 target_link_libraries(hello message) 可见性 含义 PRIVATE 编译选项仅对目标生效，不会传递（hello链接了message，但不会接受message的编译选项） INTERFACE 编译选项对目标生效，并传递给相关目标 PUBLIC 编译选项对目标和使用它的目标生效 -Wall、-Wextra等是警告标志 循环 foreach(_source $&#123;sources_with_lower_optimization&#125;) get_source_file_property(_flags $&#123;_source&#125; COMPILE_FLAGS) message(STATUS \"Source $&#123;_source&#125; has the following extra COMPILE_FLAGS: $&#123;_flags&#125;\") endforeach() 命令 cmake中可以添加一些自定义命令，常用于实现编译前文件拷贝操作，比如将第三方.dll文件复制到可执行文件到项目根路径 add_custom_command(TARGET $&#123;PROJECT_NAME&#125; POST_BUILD COMMAND $&#123;CMAKE_COMMAND&#125; -E copy “$&#123;xxx.dll&#125;” $&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;> ) 命令执行时机： POST_BUILD：生成目标文件后 PRE_BUILD：编译前 PRE_LINK：链接前 执行的命令是Linux Command，比如copy $&#123;source&#125; $&#123;target&#125;，echo $&#123;output_string&#125; 搜索 我们不可能将每一个文件都以单文件的形式写进CMakeLists.txt中，于是我们需要按照某种规则搜索所有的文件 file(GLOB_RECURSE SRC_FILES_H \"$&#123;SOURCE_DIR&#125;/*.h\") file(GLOB_RECURSE SRC_FILES_CPP \"$&#123;SOURCE_DIR&#125;/*.cpp\") set(ALL_FILES $&#123;SRC_FILES_H&#125; $&#123;SRC_FILES_CPP&#125;) 排除SRC中部分文件 list(FILTER SRC EXCLUDE REGEX \"/ui/*\") list(FILTER SRC EXCLUDE REGEX \"/core/+\") 二：环境检查 检查平台 我们要处理如下的C++源码（hello-world.cpp） std::string say_hello() &#123; #ifdef IS_WINDOWS return std::string(&quot;Hello from Windows!&quot;); #elif IS_LINUX return std::string(&quot;Hello from Linux!&quot;); #elif IS_MACOS return std::string(&quot;Hello from macOS!&quot;); #else return std::string(&quot;Hello from an unknown system!&quot;); #endif &#125; CMake可以加入 #查询操作系统 if(CMAKE_SYSTEM_NAME STREQUAL \"Linux\") #设置宏 target_compile_definitions(hello-world PUBLIC \"IS_LINUX\") endif() if(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\") target_compile_definitions(hello-world PUBLIC \"IS_MACOS\") endif() if(CMAKE_SYSTEM_NAME STREQUAL \"Windows\") target_compile_definitions(hello-world PUBLIC \"IS_WINDOWS\") endif() 检查编译器 if(CMAKE_CXX_COMPILER_ID MATCHES Intel) ... endif() if(CMAKE_CXX_COMPILER_ID MATCHES GNU) ... ... 检查处理器架构 if(CMAKE_SIZEOF_VOID_P EQUAL 8) #64bits else() #32bits endlf() 三：链接外部库 语法 find_package #查找名为OpenCV的包，如果没找到就报错 find_package(OpenCV REQUIRED) 该函数的本质就是去（先去标准路径）寻找一个包名-config.cmake文件 在mac，找OpenCV找的可能就是 &#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;OpenCV&#x2F;OpenCVConfig.cmake 如果你安装的位置不是标准路径，你可以 在build时手动指定-xxx_DIR=&quot;aaa/lib/cmake/xxx&quot; 只有第一次指定，只要不删掉build目录，就不需要重新指定 可以在CMakeLists.txt最开头写set(xx_DIR &quot;aaa/lib/cmake/xxx&quot;)、 可以给xxx_DIR设置环境变量 链接静态库 在项目根目录新建lib文件夹 将要链接的静态库（test_library.a）复制到lib文件夹中 找包 find_library(TEXT_LIBRARY test_library lib) 链接 target_link_libraries(testapp LINK_PUBLIC &amp;&#123;TEST_LIBRARY&#125;) 链接动态库 常用库 Eigen Eigen是一个纯头文件实现的线性代数库，在mac上可以使用brew安装 安装（记住eigen的版本） $brew install eigen 将Eigen链接到系统文件夹（brew一般会自动链接） $brew link --overwrite eigen 链接 #寻找Eigen包，并附带包版本 find_package(Eigen3 3.4 REQUIRED CONFIG) #若找到，则打印信息 if (TARGET Eigen3::Eigen) message(STATUS \"Eigen3 $&#123;EIGEN3_VERSION_STRING&#125; found in $&#123;EIGEN3_INCLUDE_DIR&#125;\") endif () #目标 add_executable(path-info main.cpp) #链接 target_link_libraries(path-info PUBLIC Eigen3::Eigen ) #include &lt;iostream&gt; #include &lt;Eigen&#x2F;Dense&gt; int main(int argc, char **argv)&#123; int dim &#x3D; std::atoi(argv[1]); Eigen::MatrixXd A &#x3D; Eigen::MatrixXd::Random(dim, dim); std::cout &lt;&lt; A; return 0; &#125; brew的用法 这里提一嘴Homebrew，这是一个mac上非常好用的包管理器，可以非常“优雅”地安装软件 brew会把软件安装在/usr/local/Cellar目录 安装目录软链接到/usr/local/opt bin目录执行文件链接到/usr/local/bin中（opt也有可能在根目录） 常用命令 $ brew -v # 安装完成后可以查看版本 $ brew --help # 简洁命令帮助 $ man brew # 完整命令帮助 $ brew search git # 搜索软件包 $ brew info git # 查看软件包信息 $ brew home git # 访问软件包官方站(用浏览器打开) $ brew install git # 安装软件包(这里是示例安装Git版本控制) $ brew uninstall git # 卸载软件包 $ brew list # 显示已经安装的所有软件包 $ brew list --versions # 查看你安装过的包列表（包括版本号） $ brew update # 同步远程最新更新情况，对本机已经安装并有更新的软件用*标明 $ brew outdated # 查看已安装的哪些软件包需要更新 $ brew upgrade git # 更新单个软件包 $ brew deps php # 显示包依赖 $ brew cleanup # 清理所有已安装软件包的历史老版本 $ brew cleanup git # 清理单个已安装软件包的历史版本 $ brew cleanup -n # 查看哪些软件包要被清除 四：项目 模块 我们可以将一个大的CMake源码分成一个个模块，将这些模块放在cmake文件夹里，后缀为.cmake 如下的项目结构 . ├── cmake │ └── colors.cmake └── CMakeLists.txt cmake/colors.cmake文件内包含了一个色彩输出的定义 macro(define_colors) if(WIN32) # has no effect on WIN32 set(ColourReset \"\") set(ColourBold \"\") set(Red \"\") set(Green \"\") set(Yellow \"\") set(Blue \"\") ... else() string(ASCII 27 Esc) set(ColourReset \"$&#123;Esc&#125;[m\") set(ColourBold \"$&#123;Esc&#125;[1m\") set(Red \"$&#123;Esc&#125;[31m\") set(Green \"$&#123;Esc&#125;[32m\") set(Yellow \"$&#123;Esc&#125;[33m\") set(Blue \"$&#123;Esc&#125;[34m\") ... endif() endmacro() 在CMakeLists.txt引用 #将/cmake目录添加到路径列表 list(APPEND CMAKE_MODULE_PATH \"$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake\") #引入colors.cmake include(colors) #使用定义 define_colors() 函数 function(函数名 参数1 参数2) ... endfunction() 参考资料 Clion CMake CMake菜谱 小鹏老师","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://reubensun.com/tags/C/"},{"name":"CMake","slug":"CMake","permalink":"https://reubensun.com/tags/CMake/"}]},{"title":"WPF中的C#","slug":"program/Csharpe","date":"2023-02-01T10:01:25.000Z","updated":"2023-03-28T02:56:19.636Z","comments":true,"path":"program/Csharpe/","link":"","permalink":"https://reubensun.com/program/Csharpe/","excerpt":"","text":"WPF中的C# 一、C#语法 委托 C#的委托类似于C++的函数指针，C#中，将参数a,b委托给了对象adder的Add方法，委托本质上是一种支持()运算符的对象。既然是对象，就可以有自己的成员和状态 delegate int Fun(int a, int b); class Adder&#123; private int c &#x3D; 0; public Adder(int c)&#123; this.c &#x3D; c; &#125; public int Add(int a, int b)&#123; return a+b+c; &#125; &#125; &#x2F;&#x2F;Main()&#123;... Adder adder &#x3D; new Adder(1); Fun f &#x3D; adder.Add; f(2,3); &#x2F;&#x2F;return 6 C#委托支持匿名委托和lambda表达式 delegate int Fun(int a, int b); &#x2F;&#x2F;Main()&#123;... Fun f &#x3D; delegate(int a, int b)&#123; cout &lt;&lt; a+b &lt;&lt; endl; &#125;; Fun f2 &#x3D; (int a, int b)&#x3D;&gt;&#123; cout &lt;&lt; a+b &lt;&lt; endl; &#125;; C++的函数指针 C/C++的函数指针是一个指向函数入口的指针，不具有对象的性质，只能指向非成员函数 typedef int(*Func)(int a, int b); int Add(int a, int b)&#123; return a+b; &#125; int main(int argc, char **argv)&#123; Func func &#x3D; Add; std::cout &lt;&lt; func(1,2); &#x2F;&#x2F;cout 3 return 0; &#125; 当然，如果加上类型限制符，还是可以指向成员函数的 class Multiple&#123; public: int Mul(int a, int b)&#123; return a * b; &#125; &#125;; typedef int(Multiple::*Fm)(int a, int b); int main(int argc, char **argv)&#123; Multiple multiple; Fm f &#x3D; &amp;Multiple::Mul; std::cout &lt;&lt; (multiple.*f)(3,4); return 0; &#125; 如果想让C++对委托具有对象的性质，我们可以重载()操作符 class Adder&#123; public: Adder(int c)&#123; this-&gt;c &#x3D; c; &#125; int operator()(int a, int b)&#123; return a+b+c; &#125; private: int c; &#125;; int main(int argc, char **argv)&#123; Adder adder(1); std::cout &lt;&lt; adder(2, 3); return 0; &#125; Action泛型委托 C#一种无返回值的泛型委托 public delegate void Action&lt;in T&gt;(T obj); 无参数Action xxx = 函数 public class Name &#123; public string InstanceName&#123; private set; get; &#125; public Name(string name) &#123; InstanceName &#x3D; name; &#125; public void DisplayName() &#123; Console.WriteLine($&quot;I&#39;m &#123;InstanceName&#125;&quot;); &#125; &#125; public static void Main(string[] args) &#123; Name testName &#x3D; new Name(&quot;Tim&quot;); Action showName &#x3D; testName.DisplayName; showName(); &#125; 有参数Action&lt;参数类型&gt; xxx = 函数 public class Name &#123; public string InstanceName&#123; private set; get; &#125; public Name(string name) &#123; InstanceName &#x3D; name; &#125; public void DisplayName(string str) &#123; Console.WriteLine($&quot;I&#39;m &#123;InstanceName&#125;, &#123;str&#125;&quot;); &#125; &#125; public static void Main(string[] args) &#123; Name testName &#x3D; new Name(&quot;Tim&quot;); Action&lt;string&gt; showName &#x3D; testName.DisplayName; showName(&quot;HHH&quot;); &#125; Func泛型委托 C#一种有返回值的泛型委托 public delegate TResult Func&lt;out TResult&gt;(); public class Adder &#123; private int c; public Adder(int c) &#123; this.c &#x3D; c; &#125; public int Add(int a, int b) &#123; return a + b + c; &#125; &#125; public static void Main(string[] args) &#123; Adder adder &#x3D; new Adder(1); &#x2F;&#x2F;第一个参数是返回值类型，后面的参数是输入参数类型 Func&lt;int, int, int&gt; method &#x3D; adder.Add; &#x2F;&#x2F;使用时不需要写返回值参数 Console.WriteLine(method(2, 3)); &#125; 事件 这里的事件指CLR事件模型，详细内容见下文 委托：把工作委托给了某个函数，可以直接调用 事件：订阅者侦听发行者，发行者可以通过回调函数间接让订阅者干事（而且订阅者具体干什么，要看订阅者心情，发行者无权过问） &#x2F;&#x2F;事件参数 public class MyEventArgs: EventArgs &#123; public string Args &#123; private set; get; &#125; public MyEventArgs(string args) &#123; Args &#x3D; args; &#125; &#125; &#x2F;&#x2F;事件发行者 public class EventSource &#123; MyEventArgs eventArgs; public string Name; public EventSource(string args) &#123; eventArgs &#x3D; new MyEventArgs(args); &#125; public delegate void handlerEvent(Object sender, MyEventArgs args); public event handlerEvent m_handler_event; public void Handler() &#123; m_handler_event?.Invoke(this, eventArgs); &#x2F;&#x2F;也可以写成 m_handler_event(this, eventArgs); &#125; &#125; &#x2F;&#x2F;事件订阅者 class MainClass &#123; public static void Main(string[] args) &#123; EventSource source &#x3D; new EventSource(&quot;Event had been raised!&quot;); source.Name &#x3D; &quot;Tim&quot;; source.m_handler_event +&#x3D; new EventSource.handlerEvent(writeHello); &#x2F;&#x2F;也可以写成 source.m_handler_event +&#x3D; writeHello; source.Handler(); &#x2F;&#x2F;输出：Hello Tim, Event had been raised! &#125; static void writeHello(Object sender, MyEventArgs args) &#123; EventSource source &#x3D; sender as EventSource; Console.WriteLine($&quot;Hello &#123;source.Name&#125;, &#123;args.Args&#125;&quot;); &#125; &#125; 最初我很好奇，我们注册了一个处理函数，source.m_handler_event += writeHello，但是好像没看到怎么传参进去。 其实是因为C#的委托本质是一个支持()运算符的对象，所有处理函数形式上跟委托一致，参数是委托对象的成员变量 一个事件可以注册多个处理函数，于是事件也称为多重委托 二、Binding 逻辑层与UI层 程序 = 数据 + 算法 三层结构：存储、逻辑、展示（UI） 逻辑层可以访问UI层的数据，但展示层不能访问逻辑层，UI层能显示信息，靠的是绑定逻辑层数据 this.textBoxName.SetBinding(TextBox.TextProperty, new Binding(&quot;Name&quot;) &#123; Source &#x3D; stu &#x3D; new Student() &#125;); UI层不仅可以绑定逻辑层数据，也可以绑定UI层数据 &#x2F;&#x2F;为 Text属性设置 Binding为 slider1的... &lt;TextBox x:Name&#x3D;&quot;textBox2&quot; Text&#x3D;&quot;&#123;Binding Value, ElementName&#x3D;slider1&#125;&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; 在XAML中加入 xmlns:local&#x3D;&quot;clr-namespace:BindingStudy&quot; 即可在XAML中使用BindingStudy命名空间里C#定义的类 绑定的实现 绑定实现的机制：源对象的属性（Property）发生改变时，会Invoke一个事件，Binding负责侦听这个事件 class Student : INotifyPropertyChanged &#123; public event PropertyChangedEventHandler PropertyChanged; private string name; public string Name &#123; get &#123; return name; &#125; set &#123; name &#x3D; value; if(this.PropertyChanged !&#x3D; null) &#123; this.PropertyChanged.Invoke(this, new PropertyChangedEventArgs(&quot;Name&quot;)); &#125; &#125; &#125; &#125; Path 源对象往往会有多个属性，我们可以使用Path，设置绑定那些属性，而且Path支持多级路径（简单说就是一直点下去）和索引器（Indexer） &lt;TextBox x:Name&#x3D;&quot;textBoxName&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; &lt;TextBox x:Name&#x3D;&quot;textBox1&quot; Text&#x3D;&quot;&#123;Binding Path&#x3D;Text.Length, ElementName&#x3D;textBoxName, Mode&#x3D;OneWay&#125;&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; &lt;TextBox x:Name&#x3D;&quot;textBox2&quot; Text&#x3D;&quot;&#123;Binding Path&#x3D;Text.[3], ElementName&#x3D;textBoxName, Mode&#x3D;OneWay&#125;&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; 此外Path也支持多级斜线（也是可以一直斜线下去，其中&quot;/&quot;就是自身） this.textBoxName.SetBinding(TextBox.TextProperty, new Binding(&quot;&#x2F;Length&quot;) &#123; Source &#x3D; stringList &#125;); 当源数据本身就是数据（比如int、string类型），我们可以不写Path，或者将Path省略为&quot;.&quot; this.textBlock1.SetBinding(TextBlock.TextProperty, new Binding(&quot;.&quot;) &#123; Source &#x3D; str &#125;); 集合 &lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt; &lt;TextBlock Text&#x3D;&quot;Student ID:&quot; FontWeight&#x3D;&quot;Bold&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; &lt;TextBox x:Name&#x3D;&quot;textBoxId&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; &lt;TextBlock Text&#x3D;&quot;Student List:&quot; FontWeight&#x3D;&quot;Bold&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; &lt;ListBox x:Name&#x3D;&quot;listBoxStudents&quot; Height&#x3D;&quot;110&quot; Margin&#x3D;&quot;5&quot;&gt; &lt;ListBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation&#x3D;&quot;Horizontal&quot;&gt; &lt;TextBlock Text&#x3D;&quot;&#123;Binding Path&#x3D;Id&#125;&quot; Width&#x3D;&quot;30&quot;&#x2F;&gt; &lt;TextBlock Text&#x3D;&quot;&#123;Binding Path&#x3D;Name&#125;&quot; Width&#x3D;&quot;60&quot;&#x2F;&gt; &lt;TextBlock Text&#x3D;&quot;&#123;Binding Path&#x3D;Age&#125;&quot; Width&#x3D;&quot;30&quot;&#x2F;&gt; &lt;&#x2F;StackPanel&gt; &lt;&#x2F;DataTemplate&gt; &lt;&#x2F;ListBox.ItemTemplate&gt; &lt;&#x2F;ListBox&gt; &lt;&#x2F;StackPanel&gt; public MainWindow() &#123; InitializeComponent(); List&lt;Student&gt; stuList &#x3D; new List&lt;Student&gt;() &#123; new Student()&#123;Id&#x3D;0, Name&#x3D;&quot;赵&quot;, Age&#x3D;21&#125;, new Student()&#123;Id&#x3D;1, Name&#x3D;&quot;钱&quot;, Age&#x3D;22&#125;, new Student()&#123;Id&#x3D;2, Name&#x3D;&quot;孙&quot;, Age&#x3D;11&#125;, new Student()&#123;Id&#x3D;3, Name&#x3D;&quot;李&quot;, Age&#x3D;50&#125;, new Student()&#123;Id&#x3D;4, Name&#x3D;&quot;周&quot;, Age&#x3D;44&#125;, &#125;; this.listBoxStudents.ItemsSource &#x3D; stuList; &#x2F;&#x2F;this.listBoxStudents.DisplayMemberPath &#x3D; &quot;Name&quot;; Binding binding &#x3D; new Binding(&quot;SelectedItem.Id&quot;) &#123; Source &#x3D; this.listBoxStudents &#125;; this.textBoxId.SetBinding(TextBox.TextProperty, binding); &#125; XML SOAP（Simple Object Access Protocel，简单对象访问协议）：一种基于XML的数据交换协议 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot; ?&gt; &lt;StudentList&gt; &lt;Student Id&#x3D;&quot;0&quot;&gt; &lt;Name&gt;赵&lt;&#x2F;Name&gt; &lt;&#x2F;Student&gt; &lt;Student Id&#x3D;&quot;1&quot;&gt; &lt;Name&gt;钱&lt;&#x2F;Name&gt; &lt;&#x2F;Student&gt; &lt;Student Id&#x3D;&quot;2&quot;&gt; &lt;Name&gt;孙&lt;&#x2F;Name&gt; &lt;&#x2F;Student&gt; &lt;Student Id&#x3D;&quot;3&quot;&gt; &lt;Name&gt;李&lt;&#x2F;Name&gt; &lt;&#x2F;Student&gt; &lt;Student Id&#x3D;&quot;4&quot;&gt; &lt;Name&gt;周&lt;&#x2F;Name&gt; &lt;&#x2F;Student&gt; &lt;&#x2F;StudentList&gt; &lt;ListView x:Name&#x3D;&quot;listViewStudents&quot; Height&#x3D;&quot;130&quot; Margin&#x3D;&quot;5&quot;&gt; &lt;ListView.View&gt; &lt;GridView&gt; &lt;GridViewColumn Header&#x3D;&quot;Id&quot; Width&#x3D;&quot;80&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding XPath&#x3D;@Id&#125;&quot;&#x2F;&gt; &lt;GridViewColumn Header&#x3D;&quot;Name&quot; Width&#x3D;&quot;120&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding XPath&#x3D;Name&#125;&quot;&#x2F;&gt; &lt;&#x2F;GridView&gt; &lt;&#x2F;ListView.View&gt; &lt;&#x2F;ListView&gt; &lt;Button Content&#x3D;&quot;Load Click&quot; Click&#x3D;&quot;Button_Click&quot; Height&#x3D;&quot;25&quot; Margin&#x3D;&quot;5,0&quot;&#x2F;&gt; private void Button_Click(object sender, RoutedEventArgs e) &#123; XmlDataProvider xdp &#x3D; new XmlDataProvider(); xdp.Source &#x3D; new Uri(@&quot;D:\\code\\BindingStudy\\BindingStudy\\RawData.xml&quot;); xdp.XPath &#x3D; @&quot;&#x2F;StudentList&#x2F;Student&quot;; this.listViewStudents.DataContext &#x3D; xdp; this.listViewStudents.SetBinding(ListView.ItemsSourceProperty, new Binding()); &#125; LINQ LINQ（Language-Integrated Query，语言集成查询）：一种对象查询机制，查询的结果为IEnumerable类型 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot; ?&gt; &lt;StudentList&gt; &lt;Class&gt; &lt;Student Id&#x3D;&quot;0&quot; Name&#x3D;&quot;Tim&quot; Age&#x3D;&quot;29&quot;&#x2F;&gt; &lt;Student Id&#x3D;&quot;1&quot; Name&#x3D;&quot;Tom&quot; Age&#x3D;&quot;20&quot;&#x2F;&gt; &lt;Student Id&#x3D;&quot;2&quot; Name&#x3D;&quot;Mess&quot; Age&#x3D;&quot;9&quot;&#x2F;&gt; &lt;&#x2F;Class&gt; &lt;Class&gt; &lt;Student Id&#x3D;&quot;3&quot; Name&#x3D;&quot;Tony&quot; Age&#x3D;&quot;2&quot;&#x2F;&gt; &lt;Student Id&#x3D;&quot;4&quot; Name&#x3D;&quot;Viv&quot; Age&#x3D;&quot;23&quot;&#x2F;&gt; &lt;Student Id&#x3D;&quot;5&quot; Name&#x3D;&quot;Oio&quot; Age&#x3D;&quot;88&quot;&#x2F;&gt; &lt;&#x2F;Class&gt; &lt;&#x2F;StudentList&gt; &lt;ListView x:Name&#x3D;&quot;listViewStudents&quot; Height&#x3D;&quot;130&quot; Margin&#x3D;&quot;5&quot;&gt; &lt;ListView.View&gt; &lt;GridView&gt; &lt;GridViewColumn Header&#x3D;&quot;Id&quot; Width&#x3D;&quot;80&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding Id&#125;&quot;&#x2F;&gt; &lt;GridViewColumn Header&#x3D;&quot;Name&quot; Width&#x3D;&quot;120&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding Name&#125;&quot;&#x2F;&gt; &lt;GridViewColumn Header&#x3D;&quot;Age&quot; Width&#x3D;&quot;80&quot; DisplayMemberBinding&#x3D;&quot;&#123;Binding Age&#125;&quot;&#x2F;&gt; &lt;&#x2F;GridView&gt; &lt;&#x2F;ListView.View&gt; &lt;&#x2F;ListView&gt; private void Button_Click(object sender, RoutedEventArgs e) &#123; XDocument doc &#x3D; XDocument.Load(@&quot;D:\\code\\BindingStudy\\BindingStudy\\RawData.xml&quot;); this.listViewStudents.ItemsSource &#x3D; from element in doc.Descendants(&quot;Student&quot;) where element.Attribute(&quot;Name&quot;).Value.StartsWith(&quot;T&quot;) select new Student() &#123; Id &#x3D; int.Parse(element.Attribute(&quot;Id&quot;).Value), Name &#x3D; element.Attribute(&quot;Name&quot;).Value, Age &#x3D; int.Parse(element.Attribute(&quot;Age&quot;).Value) &#125;; &#125; class Student &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; &#125; 校验 “你永远不能相信来自前端的数据” 我们认为Source的数据一定是正确的，但Target的数据是有可能出现问题的 public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); Binding binding &#x3D; new Binding(&quot;Value&quot;) &#123; Source &#x3D; this.slider1 &#125;; binding.UpdateSourceTrigger &#x3D; UpdateSourceTrigger.PropertyChanged; &#x2F;&#x2F;当源数据改变时进行校验 RangeValidationRule rvr &#x3D; new RangeValidationRule(); rvr.ValidatesOnTargetUpdated &#x3D; true; &#x2F;&#x2F;当Target数据改变时进行校验 binding.ValidationRules.Add(rvr); binding.NotifyOnValidationError &#x3D; true; this.textBox1.SetBinding(TextBox.TextProperty, binding); this.textBox1.AddHandler(Validation.ErrorEvent, new RoutedEventHandler(this.ValidationError)); &#125; &#x2F;&#x2F;若校验失败，将失败信息添加到 ToolTip上 void ValidationError(object sender, RoutedEventArgs e) &#123; if(Validation.GetErrors(this.textBox1).Count &gt; 0) &#123; this.textBox1.ToolTip &#x3D; Validation.GetErrors(this.textBox1)[0].ErrorContent.ToString(); &#125; else &#123; this.textBox1.ToolTip &#x3D; null; &#125; &#125; &#125; &lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt; &lt;TextBox x:Name&#x3D;&quot;textBox1&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; &lt;Slider x:Name&#x3D;&quot;slider1&quot; Minimum&#x3D;&quot;-10&quot; Maximum&#x3D;&quot;110&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; &lt;&#x2F;StackPanel&gt; class RangeValidationRule : ValidationRule &#123; &#x2F;&#x2F;对数据范围进行校验，仅当在[0,100]时校验通过，校验失败时返回信息 public override ValidationResult Validate(object value, CultureInfo cultureInfo) &#123; double d &#x3D; 0; if(double.TryParse(value.ToString(), out d)) &#123; if(d &gt;&#x3D; 0 &amp;&amp; d &lt;&#x3D; 100) &#123; return new ValidationResult(true, null); &#125; &#125; return new ValidationResult(false, &quot;Validation Failed!!!&quot;); &#125; &#125; 数据转换 Slider的Value是double类型，TextBox的Text是string类型，但是Binding后数据往来自如，是因为数据转化机制 class ClassAToClassBConverter : IValueConverter &#123; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; ... &#125; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) &#123; ... &#125; &#125; &lt;Window x:Class&#x3D;&quot;BindingStudy.MainWindow&quot; ... &lt;Window.Resources&gt; &lt;local:ClassAToClassBConverter x:Key&#x3D;&quot;atb&quot;&#x2F;&gt; &lt;&#x2F;Window.Resources&gt; &lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt; ... &lt;..&#x2F;..&#x2F;images Width&#x3D;&quot;20&quot; Height&#x3D;&quot;20&quot; Source&#x3D;&quot;&#123;Binding Path&#x3D;A, Converter&#x3D;&#123;StaticResource atb&#125;&#125;&quot;&#x2F;&gt; &lt;&#x2F;StackPanel&gt; &lt;&#x2F;Window&gt; 三、属性 英语中的属性 Property是物体自带的属性 Attribute是物体的描述属性 张三是中国人，身上有一百块钱。中国人是张三的Attribute, 100块钱是张三的property C#中的属性 将字段设为private，使用一对非private的方法来包装它，以实现高内聚 C#中提供语法糖，将Get和Set合并为了属性（Property），这种属性也被称为CLR（Common Language Runtime）属性 class Student &#123; private string name; public string Name &#123; get; set; &#125; &#125; 此外反编译后发现，属性的本质是两个函数，并不会增加字段数量（不额外占内存） 依赖属性 （WPF属性加强版） 依赖属性（Dependency Property）可以自己没有值，通过Binding从数据源获得值 拥有依赖属性的对象被称为依赖对象 传统开发中，对象所占用的内存在进行实例化时就确定（分配）了，而依赖属性可以允许对象不分配部分空间 class Student : DependencyObject &#123; &#x2F;&#x2F;依赖对象的 CLR封装 public string Name &#123; get &#123; return (string)GetValue(NameProperty); &#125; set &#123; SetValue(NameProperty, value); &#125; &#125; &#x2F;&#x2F;依赖对象 public static readonly DependencyProperty NameProperty &#x3D; DependencyProperty.Register(&quot;Name&quot;, typeof(string), typeof(Student)); &#x2F;&#x2F;Binding封装 public BindingExpressionBase SetBinding(DependencyProperty dp, BindingBase binding) &#123; return BindingOperations.SetBinding(this, dp, binding); &#125; &#125; “Name”：指明使用哪一个 CLR属性作为这个依赖属性的包装器 (Wrapper) typeof(string)：指明此依赖属性用来储存什么类型的值 typeof(Student))：指明此依赖属性要注册关联到谁身上 &lt;StackPanel x:Name&#x3D;&quot;stackPanel&quot; Background&#x3D;&quot;LightBlue&quot;&gt; &lt;TextBox x:Name&#x3D;&quot;textBox1&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; &lt;TextBox x:Name&#x3D;&quot;textBox2&quot; BorderBrush&#x3D;&quot;Black&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt; &lt;&#x2F;StackPanel&gt; public partial class MainWindow : Window &#123; Student stu; public MainWindow() &#123; InitializeComponent(); stu &#x3D; new Student(); stu.SetBinding(Student.NameProperty, new Binding(&quot;Text&quot;) &#123; Source &#x3D; textBox1 &#125;); textBox2.SetBinding(TextBox.TextProperty, new Binding(&quot;Name&quot;) &#123; Source &#x3D; stu &#125;); &#125; &#125; 我们还发现，依赖对象并没有实现INotifyPropertyChanged接口，但是当期值发生改变时，与之相关的Binding对象依然可以得到通知，于是依赖对象是天生的合格源数据 在VS中，输入propdp并按两次tab，就能得到一个依赖属性模板 依赖属性的注册 前文我们获得依赖对象的实例时，是通过DependencyProperty.Register注册得到： 创建DependencyProperty实例，并使用其CLR属性名的哈希异或宿主类型的哈希，得到key（通过其他算法，保证唯一） 将key和实例存储到一张全局的HashTable上 GlobalIndex &#x3D; CLR属性名的HaseCode XOR 宿主类型HashCode 于是运行时只要知道CLR属性名和宿主，就能找到依赖对象实例 依赖属性的读写 依赖属性对象的作用是检索真正的属性值，而非存储属性值 每个DependencyObject实例都自带一个数组，当某个依赖属性的值要被读取时，算法会在这个数组中检索。而用于检索的键值，实际上就是依赖属性的GlobalIndex 也就是说，这个被static readonly修饰的属性，它的作用是一个“标记”，当你需要找某个东西时，就来这里拼一个id，用id查数组 附加属性 附加属性（Attached Properties）：一个属性本不属于某个对象，但由于某种需求后来附加上。换句话说，将对象放入一个特定环境后，才会具有出来的属性 举个例子，比如Human这个类，它可以有很多很多种属性，现在我们想在里面加入一个新的需求，如果我们直接改动这个类，过于繁琐。而如果提前留好空，那么有时候又会空间浪费 附加属性的作用就是让宿主和属性解耦，让宿主的设计更为灵活 四、事件 消息 事件的前身是消息（Message），Windows系统就是一个消息驱动的操作系统，后来微软为了降低开发难度，将消息系统封装为了事件模型 CLR事件模型 CLR事件模型由三部分组成 事件的拥有者：即消息的发送者 事件的响应者：即消息的接收者，它可以使用事件处理器（Event Handler）对事件做相应 事件的订阅关系：事件的拥有者可以随时激发事件，但只有关注（订阅）了这个事件的响应者会对此产生反应 事件本质上就是一个使用event关键字修饰的委托（Delegate）类型成员变量，事件处理器是一个函数 A订阅了B，实际上就是让B.Event和A.EventHandler关联起来 事件激发就是B.Event被调用 举例 Windows Form按按钮 事件的拥有者 button 事件 button.Click 事件的响应者 窗体 事件处理器 this.button_Click() 订阅关系 this.button.Click += new System.EventHandler(this.button_Click) 路由事件 （WPF事件加强版） 路由事件没有显示订阅关系 事件拥有者只负责激发事件，至于谁会倾听，他并不知道 事件响应者装有事件倾听器，若有事件传递于此，可以决定事件是否可以继续传递 如果事件不归他管，那就踢给下一个人，继续传播 若事件归他管，那就进行处理，并判断是否还需要传给下一个人 public abstract class ButtonBase : ContentControl, ICommandSource &#123; &#x2F;&#x2F;声明并注册路由事件 public static readonly RoutedEvent ClickEvent &#x3D; EventManager.RegisterRoutedEvent(&quot;Click&quot;, RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(ButtonBase)); &#x2F;&#x2F;为路由事件添加 CLR事件包装器 public event RoutedEventHandler Click &#123; add &#123; this.AddHandler(ClickEvent, value); &#125; remove &#123; this.RemoveHandler(ClickEvent, value); &#125; &#125; &#x2F;&#x2F;激活路由事件的方法 protected virtual void OnClick() &#123; RoutedEventArgs newEvent &#x3D; new RoutedEventArgs(ButtonBase.ClickEvent, this); this.RaiseEvent(newEvent); &#125; &#125; WPF路由事件有三种策略 Bubble：冒泡式，激发者向其上级一层一层路由，直到到根，路径是确定且唯一 Tunnel：隧道式，激发者向其下级一层一层路由，路径有很多，但朝向响应者移动，就像形成一个隧道 Direct：直达式，类似CLR事件，直接向响应者发送事件 五、命令 事件不具有约束力，事件接收者使用自己的行为响应事件 命令具有约束力，当命令到达某个组件时，会主动调用组件的某个方法 命令系统 命令（Command）：实现ICommand接口 命令源（Command Source）：实现ICommandSource接口 命令目标（Command Target）：实现IInputElement接口 命令关联（Command Binding）","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://reubensun.com/tags/C/"},{"name":"Windows","slug":"Windows","permalink":"https://reubensun.com/tags/Windows/"}]},{"title":"Maya插件开发","slug":"dcc/maya插件","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.620Z","comments":true,"path":"dcc/maya插件/","link":"","permalink":"https://reubensun.com/dcc/maya%E6%8F%92%E4%BB%B6/","excerpt":"","text":"Maya maya，老东西，行业标准，真难用（不是） 腾讯巨神级TA、碧血红天的blog、Pycharm环境搭建 创建一个python工具 Python插件和Unity Editor那种工具不太一样，这个其实本质就是一个嵌入式的脚本，通过命令调用maya指令，就算有UI也是现绘制的，也不需要什么项目结构，就一个py文件 创建一个python文件 import maya.cmds as cmds def createWindow(): if cmds.window('mywindow', exists=True): cmds.deleteUI('mywindow') windowvar = cmds.window('mywindow') cmds.columnLayout() checkButton = cmds.button(l='Test', command='testFunc()') cmds.showWindow('mywindow') def testFunc(): print \"Hello\" createWindow() 添加到工具栏 当你的代码完成后，可以将其固定到工具架上 怎么写 这应该是很多人写maya插件最大的疑惑，我的建议是先学美术，开着脚本编辑器，按照美术流程走一遍，你会发现你每一次操作，脚本编辑器都会输出一个指令，这个应该能让你深受启发 如果你的脚本编辑器没有显示，那么在脚本编辑器中设置显示二者 常用API import maya.cmds as cmds #这是一个将MEL指令用python封装的库，适合面向过程编程 import maya.OpenMaya as om #拥有cmd没有的功能，运行效率更高 删除：cmds.delete(p) 选中：p = cmds.ls('Name') 创建 Cube：pCube = cmds.polyCube(w=10, h=10, d=10, name='myCube') 移动（到指定位置） 平移：cmds.move(0, 10, 0, pCube) 缩放：cmds.scale(2, 2, 2, pCube) 旋转：cmds.rotate(45, 45, 0, pCube) 选择（得到的是对象数组） 当前选择：list = cmds.ls(selection=True) 读参数 位置：cmds.getAttr('%s.translate ' % (p)) 位置（某一维）：y = cmds.getAttr('%s.translateY ' % (p)) 写参数 位置（某一维）：cmds.setAttr('%s.translateX' % (p), 10) 想知道maya物体的参数，可以通过表达式编辑器查看（窗口-动画编辑器-表达式编辑器） 得到顶点数据 def printVertexPos(): selectObjectList = cmds.ls(selection=True) VertexArray = cmds.ls('&#123;&#125;.vtx[:]'.format(selectObjectList[0]), fl = True) for v in VertexArray: print cmds.xform(v, query = True, translation = True, worldSpace = True) 工具实例 平滑法线 平滑法线 模型展2UV #创建一个名称为sph的多边形 def createFunc(): cmds.polySphere(n='sph') #删除除了map1以外所有的uvmap def deleteUVs(): au = cmds.polyUVSet(query=True, allUVSets=True) for j in range(len(au)-1): cmds.polyUVSet(delete=True, uvSet=au[j+1]) #自动展选中物体的2UV，并命名为map2 def pickUV2(): list = cmds.ls(dag=1, selection=True) au = cmds.polyUVSet(query=True, allUVSets=True) if(len(au) == 1): cmds.polyAutoProjection(list[1] + '.f[*]', cm = 1, uvs= 'map2') else: print \"map2 has been exited\" 动画clip #输出选中的动画片段的开始帧和结束帧 def printClip(): list = cmds.ls(selection=True) for p in list: start = cmds.getAttr('%s.clipStart ' % (p)) end = cmds.getAttr('%s.clipStart ' % (p)) + cmds.getAttr('%s.clipDuration ' % (p)) print start print end 打开文件 def openFile(): path = 'C:/Users/Admin/Desktop/多边形.fbx' cmds.file(path, i=True) 开关UV编辑器 def openUVPanel(): if cmds.window('polyTexturePlacementPanel1Window', ex=1): cmds.deleteUI('polyTexturePlacementPanel1Window') mel.eval('toggleUVToolkit;') else: mel.eval('texturePanelShow;')","categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"}]},{"title":"垃圾回收","slug":"engine/GC","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.620Z","comments":true,"path":"engine/GC/","link":"","permalink":"https://reubensun.com/engine/GC/","excerpt":"","text":"垃圾回收 前言 《垃圾回收的算法与实现》读书笔记，其中的代码大多为伪代码 一：概念 GC，Garbage Collection，垃圾回收 功能 找到内存中的垃圾 回收垃圾 为什么需要GC 如果没有GC，程序员需要手动进行内存管理，开发麻烦，容易引发内存泄漏、野指针，而且因此导致的BUG很难被定位，修复麻烦 如果有GC，就可以避免这些问题 GC的种类 保守式GC：不能识别指针和非指针时，一律视为非指针 准确式GC GC的算法 标记清除法：标记活动对象，其他的都回收 引用计数法：回收引用值为0的对象 GC复制法：复制活动对象，其他的都回收 GC的选取 最大暂停时间短：游戏 整体处理时间短：音频编码 对象 这里的对象并不是OOP里的Object，而是被应用程序使用的数据的集合，对象由头和域构成 头（header）：包含对象的大小和种类 域（field）：参考OOP里的成员 对象分为活动对象和非活动对象，GC会保留活动对象，销毁非活动对象 mutator 可以简单理解为应用程序，在程序运行过程中，会分配/调用/改变对象（只能操作活动对象），伴随着mutator运行，会产生垃圾 GC算法的评估标准 吞吐量（throughput）：单位时间的处理能力 最大暂停时间（在进行GC时，mutator会被暂停） 堆使用效率 访问局部性 二：标记清除法 学这一节之前想想操作系统里文件系统 该算法分为两步 标记阶段：将所有活动对象做上标记 清除阶段：将所有没被标记的对象回收 标记阶段 通过根，找到直接引用的对象，标记 递归标记所有能访问到的对象（常用深搜，因为内存使用量更少） void mark(obj)&#123; if(!obj.mark) obj.mark &#x3D; true; for(child: obj.children) mark(*child); &#125; 清除阶段 遍历堆，回收所有没有被标记的对象，并将其放入空闲链表，以备分配 分配策略 在创建新对象obj时，遍历空闲链表，寻找合适的块，这里使用First-fit算法（因为快） First-fit：找到第一个能放下obj的块 Best-fit：找到最小的能放下obj的块 Worst-fit：找到最大的能放下obj的块 合并策略 分配和回收会导致大量小的分块，于是需要合并，在这里直接遍历堆，将连续的空闲块合并 评价 优点 实现简单 与保守式GC兼容（因为对象不会被移动） 缺点 碎片化，导致空间浪费，访问性能降低 不支持写时复制（比如UNIX中的fork()） 优化方案 分级空闲链表 使用多个空闲链表，分别只连接不同大小的分块，分配时先找所对应的区间，可以提高性能 BiBOP（Big Bag Of Pages） 将大小相近的对象整理成固定大小的块进行管理 碎片化的原因之一是杂乱散布的大小各异的对象，如果将堆固定分割，就可以减缓碎片化 位图标记 不直接堆对象进行标记，而是记录对象的标志位，存储在一个表格中 与写时复制技术兼容（因为不会修改对象本身，可以复用） 清除标志位更高效（只需要把表中要清除的对象的标志位改成一个特殊值） 延迟标记清除法 分配时，先调用清除，如果能清出足够的空间来分配，则直接分配，否则进行普通的标记操作 清除时，同样是First-fit遍历堆，但遍历的起点是上次开始的地点的右侧 延迟的内核是不主动清除，而是等到要分配时再清除 三：引用计数法 学这一节前，想想智能指针 引用计数法中，对象会记录自己被引用次数，主要分为两个阶段 创建新对象：分配内存，将对象引用次数设为1 更新指针：先增后减计数器值，若引用次数为0则回收 &#x2F;&#x2F;更新指针ptr，让其指向obj void update_ptr(ptr, obj)&#123; inc_ref_cnt(obj); &#x2F;&#x2F;obj要被ptr引用了，所以obj计数值++ dec_ref_cnt(*ptr); &#x2F;&#x2F;ptr之前引用的东西不再被引用 *ptr &#x3D; obj; &#125; void dec_ref_cnt(obj)&#123; obj.ref_cnt--; &#x2F;&#x2F;obj不再被引用，所以计数值-- if(obj.ref_cnt &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;如果obj没人用了，obj就要被清除 for(child: obj.children)&#123; &#x2F;&#x2F;obj被清除了，那obj引用的对象，被引用次数要-- dec_ref_cnt(*child); &#125; reclaim(obj); &#x2F;&#x2F;执行回收 &#125; &#125; 评价 优点： 对象变成垃圾时立刻被回收（延迟标记清除算法要等到分块用尽后才开始回收垃圾） 最大暂停时间短（只有在更新指针的时候才会打断mutator） 减少延根指针遍历所有子节点的次数（尤其在分布式系统中，效果显著） 缺点 频繁进行计数值的操作 计数器本身空间比较大（32位系统的计数器就要32位大小） 循环引用无法回收 如果两个物体互相引用，并不和其他对象有联系，于是他们成为了一座“孤岛”，成为了事实意义上的垃圾，但是却无法被回收（因为只要被引用，就不算垃圾） 优化方案 延迟引用计数法 解决频繁操作 使用ZCT表（Zero Count Table），记录所有执行dec_ref_cnt后计数值变成0的对象（也就是说计数值变成0，不会立刻被视为垃圾回收），当ZCT表满了以后，开始回收表中的对象 优点：延迟了根引用的计数（只有要回收时才会一起操作），降低了计数值的操作频率 缺点 不再能即刻回收垃圾（你可以理解为以前有垃圾就仍，现在要先堆一波垃圾再扔） 最大暂停时间延长（scan_zct()要访问整个ZCT，这个过程muator是被中断的） void dec_ref_cnt(obj)&#123; obj.ref_cnt--; if(obj.ref_cnt &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;计数值变为0，可能会变成垃圾 if(is_full($zct))&#123; scan_zct(); &#x2F;&#x2F;如果zct表满了，就扫描zct，并回收 &#125; push($zct, obj); &#x2F;&#x2F;将obj放入zct表 &#125; &#125; void scane_zct()&#123; fot(r: $root)&#123; (*r).ref_cnt++; &#x2F;&#x2F;根直接引用的对象的计数器++，直接引用计数时，根会极频繁改动 &#125; for(obj: $zct)&#123; if(obj.ref_cnt &#x3D;&#x3D; 0)&#123; remove($zct, obj); delete(obj); &#125; &#125; fot(r: $root)&#123; (*r).ref_cnt--; &#125; &#125; Sticky引用计数法 解决空间浪费 32位电脑意味着可以有$2^{32}$个对象，这些对象可能都会引用obj，所以obj的计数位应当可以记录被引用$2^{32}$次，所以计数位要有32位 如果计数位太少，一些比较大的对象就无法正常表示（直接做饱和运算，汽车速度超过速度计的最大值会停在最大值处），一旦出现这种情况，我们可以 什么都不做 这会导致如果一个物体被引用的次数特别多，超出了目前表示的范围，即使他变成了垃圾也无法回收 但是，事实上绝大多数对象计数值一直在0和1间变化（生成后立刻回收），所以很少出现溢出 而且一个对象被频繁引用，说明他十分重要，十分重要的东西被回收的概率并不大 很多时候不需要保证内存永不泄露，只需要保证一段时间内不泄露就行，很多软件，用户不会一直开着的 结合使用标记清除算法 什么都不做，可能会导致内存耗尽，如果耗尽，那就用标记清除法清一次（相当于垃圾太多了，管不来了，就干脆来一次大扫除） &#x2F;&#x2F;标记 void mark()&#123; for(r: $roots)&#123; push(*r, $stack); &#x2F;&#x2F;将所有根直接引用对象入栈 &#125; while(!$stack.empty())&#123; obj &#x3D; pop($stack); obj.ref_cnt++; if(obj.ref_cnt &#x3D;&#x3D; 1)&#123; &#x2F;&#x2F;这说明obj只进栈一次 for(child: obj.children)&#123; push(*child, $stack); &#125; &#125; &#125; &#125; &#x2F;&#x2F;清除 void sweep()&#123; index &#x3D; $heap_top; while(index &lt; $heap_end)&#123; &#x2F;&#x2F;遍历整个堆 if(index.ref_cnt &#x3D;&#x3D; 0)&#123; reclaim(index); &#x2F;&#x2F;回收计数值为0的对象 &#125; index +&#x3D; index.size; &#125; &#125; 一位引用计数法 是Sticky的极端，计数位只有一位（两个tag，一个MULTIPLE，一个UNIQUE），而且将计数位放在指针上，而非放在对象上 void copy_ptr(dest_ptr, src_ptr)&#123; delete_ptr(dest_ptr); *dest_ptr &#x3D; *src_ptr; set_tag(dest_ptr, MULTIPLE); if(src_ptr.tag &#x3D;&#x3D; UNIQUE)&#123; set_tag(src_ptr, MULTIPLE); &#125; &#125; void delete_ptr(ptr)&#123; if(ptr.tag &#x3D;&#x3D; UNIQUE) reclaim(*ptr); &#x2F;&#x2F;如果对象以前只被引用一次，那么这次就要被回收 &#125; 优点 cache命中率高 缺点 同Sticky，而且更严重 部分标记清除法 解决循环引用 只对可能会有循环引用的对象使用标记清除法，其他对象使用引用计数法 每个对象会有两个状态位（于是就有四个状态），分别为 BLACK：绝对不是垃圾的对象（初始值） WHILE：绝对是垃圾的对象 GRAY：搜索完毕的对象 HATCH：可能是循环垃圾的对象 void dec_ref_cnt(obj)&#123; obj.ref_cnt--; if(obj.ref_cnt &#x3D;&#x3D; 0)&#123; delete(obj); &#125; else if(obj.color !&#x3D; HATCH)&#123; obj.color &#x3D; HATCH; queue.push(obj); &#125; &#125; 对放入队列的对象进行标记清除算法 Object new_obj(size)&#123; obj &#x3D; pickup_chunk(size); &#x2F;&#x2F;分配内存 if(obj !&#x3D; null)&#123; &#x2F;&#x2F;如果分配成功 obj.color &#x3D; BLACK; obj.ref_cnt &#x3D; 1; return obj; &#125; else if(!queue.empty())&#123; &#x2F;&#x2F;说明现在空间不足，要回收垃圾，先看是否存在HATCH物体 scan_hatch_queue(); return new_obj(size); &#x2F;&#x2F;回收queue内后重新尝试分配 &#125; else&#123; allocation_fall(); &#125; &#125; void scan_hatch_queue()&#123; &#x2F;&#x2F;循环扫描队列，直至队列为空 obj &#x3D; queue.pop(); if(obj.color &#x3D;&#x3D; HATCH)&#123; paint_gray(obj); &#x2F;&#x2F;把obj和其孩子变为GRAY，孩子们引用值-- scan_gray(obj); &#x2F;&#x2F;引用值&gt;0涂黑，等于0涂白 collect_while(obj); &#125; else if(!queue.empty())&#123; scane_hatch_queue(); &#125; &#125; void paint_gray(obj)&#123; if(obj.color &#x3D;&#x3D; (BLACK | HATCH))&#123; obj.color &#x3D; GRAY; for(child: obj.children)&#123; (*child).ref_cnt--; paint_gray(*child); &#125; &#125; &#125; void scan_gray(obj)&#123; if(obj.color &#x3D;&#x3D; GRAY)&#123; if(obj.ref_cnt &gt; 0)&#123; paint_black(obj); &#125; else&#123; obj.color &#x3D; WHITE; for(child: children(obj))&#123; scan_gray(*child); &#125; &#125; &#125; &#125; void paint_black(obj)&#123; obj.color &#x3D; BLACK; for(child : children(obj))&#123; (*child).ref_cnt++ if((*child).color !&#x3D; BLACK)&#123; paint_black(*child) &#125; &#125; &#125; void collect_while()&#123; if(obj.color &#x3D;&#x3D; WHILE)&#123; obj.color &#x3D; BLACK; for(child: obj.children)&#123; collect_while(*child); &#125; reclaim(obj); &#125; &#125; 优点 可以回收循环引用 缺点 一个对象要被查找三次，导致最大暂停时间+++ 四：GC复制法 想一下渲染中的双缓冲 先把整个空间分为等大的两部分，From和To，我们用From空间分配活动对象 GC时，把所有活动对象（递归）复制到其他空间（To空间），然后把原空间（From空间）所有对象回收，然后把空间互换 评价 优点 吞吐量大 分配速度快（Frist-fit） 不会发生碎片化（每次回收时，都会把所有对象重新排在From空间的开头，这个操作被称为压缩） 兼容缓存 缺点 堆效率低（因为二等分后，只能利用其中一半） 不兼容保守式GC 复制对象时要递归复制，会消耗栈，可能导致栈溢出 优化方案 Cheney GC复制法 从递归复制改为迭代复制（基于队列的广度优先搜索） 下图搜索顺序：A BC DEFG HIJKLMNO ![Cheney GC](/images/Cheney GC.png) 优点 从递归变成迭代，降低栈压力 缺点 不利于缓存（在上图，我们假设每个页最多存放三个块，我们发现有引用关系的对象很可能不在同一个块中） 近似深度优先搜索方法 在页间做深度优先搜索，在页内做广度优先搜索 下图搜索顺序：ABC DHI EJK FLM GNO 多空间复制法 把空间分成十份，一个From，一个To，八个标记清除法 五：标记压缩法 结合了标记清除法的标记+GC复制法的压缩 Lisp2算法 类比原地删除数组中某个元素 标记方法和标记清除法一样，标记后遍历堆，将所有活动对象压缩到左侧 优点 比GC复制法堆效率高，比标记压缩法碎片少 缺点 三次遍历堆，效率过低 Two-Finger算法 这个算法优缺点很明显，所以先说优缺点，再谈实现 优点 只需要两次遍历堆 不需要额外的forward指针（Lisp2的对号） 缺点 对象大小必须一致（可以与BiBOP结合使用） 压缩时破坏排序（一般有引用关系的对象会放在一起），于是不适合缓存 在Lisp2算法中，可以说几乎每一个活动对象都需要移动，一般来说越靠近左边，移动的概率、距离越小，而越后面则越大（可以类比幽灵堵车） 我们能不能固定前面的对象，只移动后面的对象，从而实现压缩呢？（如果后面的对象和前面的对象大小一致，完全可以） 表格算法 算法分为三部：移动对象群，构建间隙表格，更新指针 移动对象群（Lisp2一次移动一个对象，这个一次移动所有相邻对象） 构建间隙表格（设一个小格子尺寸为50） a到b：live在B开头，scan在D开头，于是将B的初始位置和B向左移动的距离$(100,100)$写到D处 b到c： 先把间隙表格向后移动，移到FG之后，于是H处写入$(100,100)$ FG的初始位置和向左移动的距离为$(550,300)$，写入H之后（后是左边的G） 更新指针 ImmixGC算法 六：保守式GC 把疑似指针的一律视为指针 不明确的根 常见的根有 寄存器 调用栈 全局变量空间 在c++等语言里，int这种内置变量（非指针）和void*指针都存放在栈里，GC无法区分两者的区别，保守式GC就干脆不区分两者 存储着不确定对象的根，称为不明确的根，而基于这些根的GC算法，被称为保守式GC（ambiguous GC） 检查内容 是否位对齐（32位CPU，指针是4的倍数，64位CPU，指针是8的倍数） 不对齐的一定是非指针 是否指向堆内 对象放在堆中，所以指针一定指向堆 是否指向对象开头 我们发现，有的时候我们会遇到一些格式与指针一致的非指针，我们称之为貌似指针的非指针（false pointer） 在标记清除算法中，遇到这种貌似指针的非指针，会胡乱找到一个对象，我们不知道这个对象是活动对象还是非活动对象，所以一律视为活动对象，进行标记 注意：保守GC是只有当判断不出来到底是不是指针时才将其视为指针，而不是把所有对象都视为指针（迫不得已，凑合凑合用） 评价 优点 开发容易，程序员不需要意识到GC的存在 缺点 识别指针和非指针需要付出代价（检查内容） 将false pointer指向的错误对象视为活动对象，这些东西不会被用到，却进栈了 支持保守GC的算法不多 准确式GC 正确的根（exact roots）可以精确地识别指针和非指针 基于正确的根的GC被称为准确式GC 构建正确的根的方法：打标签 32位CPU指针的值是4的倍数，那么其低2位一定是0 我们可以将所有非指针左移1位，然后将其低1位置为1 &#x2F;&#x2F;打标签 int addTag(int a)&#123; a &#x3D; a &lt;&lt; 1; &#x2F;&#x2F;小心溢出，如果会溢出，就用一个更大的数据结构 a &#x3D; a|1; return a; &#125; &#x2F;&#x2F;去标签（在使用时需要恢复成正常数值），而且使用完后还有再次打标签 int getValue(int a)&#123; a &#x3D; a &gt;&gt; 1; return a; &#125; 除了打标签，还可以专门构建一个只存放指针的根，比如一些使用虚拟机（VM）的语言 评价 优点 不需要判断是否为指针，没有判断带来的性能代价 堆中只会存在指针，可以适用于一些移动对象的GC算法 缺点 构建准确的根需要性能成本 语言使用时更麻烦 间接引用 为什么保守式GC不能移动对象？因为一个false pointer可能是一个非指针，移动会导致问题 句柄 如图，即使我们移动了堆中的对象，也却不会改变根内的内容 优点： 可以使用复制算法 缺点： 访问一个对象需要访问两次内存 MostlyCopyingGC 保守式GC复制算法 黑名单 有的false pointer即使是非指针，错把他当指针用也可以找到一个对象（尽管这个过程是未定义的），如果这个非指针可以做到这个事，拿我们就把这个非指针指向的地址存放到黑名单中 黑名单中存放的是地址，如果在这些地址中分配空间，可能会导致未定义事件 所以在这些地址上分配对象时要十分小心，比如只能分配小对象、只能分配没有子对象的小对象，因为这些对象比较小，即使变成垃圾，被错误识别了，危害也比较小 七：分代垃圾回收 引入了年龄这一概念，优先回收那些容易成为垃圾的对象 年龄 我们在引用计数法中提到过，绝大多数的对象生成后立刻会被回收，而被引用次数多多对象很难变成垃圾 于是我们引入年龄这一概念，初始为0，每经历一次GC算法，如果没有被回收，则年龄+1 我们发现年龄越大，说明对象越重要，越不容易被回收，于是年龄越大，参与回收的频率就越低 评价 优点 提高吞吐量 缺点 很多对象出生立刻回收只是一个经验，不适合所有程序，一旦某程序对象比较“长寿”，会起反作用 八：增量式垃圾回收 想一想单核CPU并行的本质，就是将线程切分，来回切换 通过逐步推进垃圾回收来控制最大暂停时间，不一次执行完GC，而是执行一会mutator，执行一会GC 三色标记法 评价 优点 降低最大暂停时间 缺点 降低了吞吐量 九：RC Immix算法 这是一个2013年的算法，听懂掌声 将合并型引用计数法和Immix组合到一起，改善了引用计数法的吞吐量","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"GC","slug":"GC","permalink":"https://reubensun.com/tags/GC/"}]},{"title":"大象无形UE笔记","slug":"engine/大象无形UE笔记","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.621Z","comments":true,"path":"engine/大象无形UE笔记/","link":"","permalink":"https://reubensun.com/engine/%E5%A4%A7%E8%B1%A1%E6%97%A0%E5%BD%A2UE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"UE学习笔记 基类 UObject 一切对象的基类。UE为UObject类提供了 垃圾回收GC 被UProperty标记的变量会自动进行生命周期管理 非UObject可以使用C++标准推荐的智能指针 引用计数 反射 序列化 资源的存储与加载 自动检测默认变量的更改 自动变量初始化 与Editor的交互 运行时类型识别 UE禁用了C++的dynamic_cast，你可以使用Cast&lt;&gt;替代 网络复制 反射 反射分为静态反射和动态反射，C++没有该机制（尽管C++可以在编译时进行类型推导，但远不如Java那种Class对象的机制好用），于是UE自己做了一套 功能 运行时知道类、函数的所有相关信息（属性表，函数表），进而实现可视化编程（蓝图，面板） 通过函数名/类名+连续数据块访问对应函数/类 反射说白了就是将类、函数的信息（用哈希表）存储，运行时根据函数名、类名（key）查找信息，UE的反射是通过UBT和UHT实现的 通过宏标记C++代码 UHT生成.generated.h和.generated.cpp文件 引擎初始化时注册反射信息 Actor 一切实体的基类。能够被挂载组件（U） Component 基类：UActorComponent Component是一种属性+行为的集合 通讯 Actor之间要进行通讯，Unity可以通过获得GO引用、获得GO的组件的方式进行通讯 UE Actor的通讯方式有 获取引用 Cast 接口 事件 Pawn 英语意思为棋子，指可以被操控的兵卒（可以被玩家操控，也可以被AI操控） Charactor 继承自Pawn，是一个更复杂的可操控角色，该角色的特点是有一种特殊的组件，Charactor Movement Controller 控制器，负责控制Pawn、Charactor的行为 命名原则 通过类的前缀来区分类的类型 前缀 意义 F 纯C++类，通常为功能类 U 继承自UObject，但不继承自Actor A 继承自Actor S Slate控件 H HitResult相关类 T 模版类 E 枚举类 对象 创建对象 F类，使用new U类，使用NewObject A类，使用SpawnActor new FClass(); NewObject&lt;UxxxClass&gt;(); GetWorld()-&gt;SpawnActor&lt;AxxxClass&gt;(); UObject 生命周期 创建 内存分配，返回一个分配好尺寸但没有初始化的指针（你steam下游戏也是先清出一片区域，再正式下载） 对象构建 创建FObjectInitializer 将FObjectInitializer作为参数传递给函数指针ClassConstructor，得到对象 反序列化 获取类信息GetClass 判断类信息是否载入，若没有载入则进行预载 载入名字、Outer、类信息（类信息保存在ObjClass对象中，感觉和Java的类对象机制很接近） 载入脚本成员变量信息 反序列化的规则： 只反序列化UPROPERTY标记，且不等于默认值的数据 先创建出对象，再反序列化（还原数据） 对象具有所属关系 若一个对象所有信息和原始对象相同，尽管他们在内存的位置不同（指针值不同），该对象就是原始对象 释放消亡 UObject无法手动释放，但是可以被请求，将其标记后等待引擎将其释放 GC分为两步，析构、回收 蓝图 UPROPERTY：注册成员变量到蓝图 UFUNCTION：注册函数到蓝图 引擎基础功能 正则表达式 #include &quot;Regex.h&quot; ... FString TextStr(&quot;This is a string&quot;); FRegexPattern TestPattern(TEXT(&quot;C.+H&quot;)); FRegexMatcher TestMatcher(TestPattern, TextStr); if(TestMatcher.FindNext())&#123; UE_LOG(MyLog, Warning, TEXT(&quot;找到匹配内容 %d -%d&quot;), TestMatcher.GetMatchBeginning(), TestMatcher.GetMatchEnding()); &#125; 路径 &#x2F;&#x2F;获取xxx目录路径 FString FPaths::xxxDir(); &#x2F;&#x2F;判断文件是否存在 bool FPaths::FileExists(const FString&amp; InPath); &#x2F;&#x2F;相对路径转化为绝对路径 FString ConvertRelativePathToFull(const FString&amp; BasePath, FString&amp;&amp; InPath)； XML &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?> &lt;note name=\"Ami\" age=\"100\"> &lt;from>John&lt;/from> &lt;list> &lt;line>Hello&lt;/line> &lt;line>world&lt;/line> &lt;/list> &lt;/note> 使用FXmlFile或者FastXML操作xml文件 FString xmlFilePath &#x3D; TEXT(&quot;xxx&#x2F;Test.xml&quot;); FXmlFile* xml &#x3D; new FXmlFile(); xml-&gt;LoadFile(xmlFilePath); FXmlNode* RootNode &#x3D; xml-&gt;GetRootNode(); FString from_content &#x3D; RootNode-&gt;FindChildNode(&quot;from&quot;)-&gt;GetContent(); FString note_name &#x3D; RootNode-&gt;GetAttribute(&quot;name&quot;); TArray&lt;FXmlNode*&gt; list_node &#x3D; RootNode-&gt;FindChildNode(&quot;list&quot;)-&gt;GetChildrenNodes(); JSON FString JsonStr &#x3D; &quot;[&#123;\\&quot;author\\&quot;: \\&quot;Tim\\&quot;&#125;, &#123;\\&quot;age\\&quot;: \\&quot;100\\&quot;&#125;]&quot;; TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParsed; TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader &#x3D; TJsonReaderFactory&lt;TCHAR&gt;::Create(JsonStr); bool BFlag &#x3D; FJsonSerializer::Deserialize(JsonReader, JsonParsed); &#123; FString FStringAutor &#x3D; JsonParsed[0]-&gt;AsObject()-&gt;GetStringField(&quot;autor&quot;); &#125; 文件 FPlatformFileManager::Get()-&gt;GetPlatformFile(); GConfig &#x2F;&#x2F;写配置 GConfig-&gt;SetString(TEXT(&quot;Section&quot;), TEXT(&quot;Key&quot;), TEXT(&quot;Value&quot;), FPaths::xxxDir()&#x2F;&quot;Config.ini&quot;); &#x2F;&#x2F;读配置 FString Result; GConfig-&gt;GetString(TEXT(&quot;Section&quot;), TEXT(&quot;Key&quot;), Result, FPaths::xxxDir()&#x2F;&quot;Config.ini&quot;); UE_LOG UE_LOG(log分类，log类型，log内容)； 字符串 能否修改 大小写敏感 语意 FName 无法修改 不敏感 名字，在整个字符串表只出现一次 FText 无法修改 敏感 被显示的字符串 FString 能够修改 敏感 普通字符串 图片 ../../imagesrWrapper 模块 模块 模块就像Unity的Package，用于整理文件结构，便于编译 一个模块包含 Public文件夹 .h文件 Private文件夹 .cpp文件 模块名.build.cs文件（继承自ModuleRules类） UBT Unreal Build Tool.cs中有Main函数，主要做三个功能 收集信息：环境变量、目录信息等 确定生成的目标类型 生成构建 UHT Unreal Header Tool，一个基于引擎代码，但不需要引擎完全启动，编译后得到一个.exe文件的程序 引擎核心 UE Begin Play 内存分配 提供了多套内存分配器，其中包含TBB（TBB的内存分配一大特点就是可以通过代理的方式全局替换new、malloc等操作符），TBB见《高性能C+++》笔记，那边有详细介绍 TBB内存分配主要包括 LTS，线程内存池，每个线程会独立拥有一个局部的内存池，互不影响，但最后需要归约 缓存对齐，通过在变量间填充大量无效信息，使得不同变量处于不同缓存行中，于是避免了假共享问题 引擎初始化 PreInit 接收cmd命令，判断启动模式 初始化游戏主线程（将当前线程当作主线程） 初始化随机数 初始化TaskGraph系统，设置线程数量，启动线程池 调用LoadCoreModules，启动CoreUObject模块 启动引擎、渲染、动画蓝图、Slate、贴图压缩、地形模块 Init 各个模块初始化，并执行所有PostEngineInit函数 进入主循环 主循环 UE是一个多线程引擎，将游戏逻辑、渲染、声音、IO等系统分离 主线程是游戏逻辑线程，内含一个while循环，循环内有一个Trick，可以类比Unity的Update 渲染线程数游戏逻辑线程的从属，接收来自主线程的命令，进行渲染绘制。渲染线程比逻辑线程慢一帧 并发并行 线程 并行 并发 Task Graph UE最强大的多线程框架，将任务抽象为Task UE内部使用了TBB，感觉这部分内容和TBB基本一致 详情见FBaseGraphTask、FTaskThreadBase FRunnableThread+FRunnable 详情见QueuedThreadPoolWrapper.h，并不是很好用 渲染 渲染线程 UE的游戏线程和渲染线程分离（事实上现在基本所有引擎都这样），渲染线程是游戏线程的“附庸” 在引擎Init时，会调用StartRenderingThread函数，启动渲染线程 该函数主要做： 创建渲染线程 从TaskGraph中取任务 注册渲染线程 注册Trick 运行 渲染线程的主要执行内容在RenderingThreadMain中，游戏线程可以通过EQUEUE_Render_COMMAND等宏命令向渲染线程的TaskMap中添加渲染任务，渲染线程提取这些命令后将其添加到RHICommandList中，最后传递到GPU中 RHI RHI（Render Hardware Interface），对图形库的一种封装，以供上层使用 UE5中含义 FRenderResource 渲染线程中的资源，如贴图、顶点buffer、顶点id FRHIResource GPU侧的资源，如Texture2D、3D、Cube DynamicRHI 所有图形API适配器的基类 RHI RHIContext RHI命令上下文 RHICommandList RHI指令队列 FRHICommandListExecutor 将RHI指令翻译为图形API 多线程 DX11 DX11尝试从硬件层面解决多线程渲染，提供了两种设备上下文：即时上下文（Immediate Context）和延迟上下文（Deferred Context） 延迟上下文多线程并行，最后将生成的CommandList归约到即时上下文中，由即时上下文Execute 对于某些支持硬件级加速的驱动，延迟上下文可以将CommandList也直接提交给图形驱动 DX11的多线程，感觉就是一种简单的异步，仅仅是加速了指令录制，减少了等待 DX12 取消了DX11的渲染上下文，不再使用DrawCall，而是直接使用CommandList来调用图形驱动 DX12渲染线程并行进行指令录制，生成一些命令列表（CommandList） 然后将这些命令列表提交给命令队列（CommandQueue）中 命令队列根据指令类型，将指令放入不同的GPU引擎中 命令队列有三种：复制队列（Copy Queue）、计算队列（Compute Queue）、3D队列 GPU引擎有三种：复制引擎、计算引擎、3D引擎 命令队列和GPU引擎都可以并行执行 渲染管线 物理 UE5使用Chaos替代PhysX作为新的物理引擎 Chaos PhysX 基于位置（PBD） 基于速度 支持大世界坐标（LWC） 不支持 支持网络同步 不支持 异步 UE5可以启用异步物理模拟，物理线程会作为单独的线程运行（类似渲染线程） 由于是独立线程，物理模拟可以以固定的间隔运行，既可以提高精确度，也方便C/S网络同步 但开启异步后物理线程无法即时获取游戏线程的输入，有可能影响游戏逻辑 功能 布料 破坏 载具 场 PBD 论文 大世界 World partition","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unreal","slug":"Unreal","permalink":"https://reubensun.com/tags/Unreal/"}]},{"title":"DX12龙书（一）","slug":"graphics/DX12笔记1","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.623Z","comments":true,"path":"graphics/DX12笔记1/","link":"","permalink":"https://reubensun.com/graphics/DX12%E7%AC%94%E8%AE%B01/","excerpt":"","text":"DX12 环境搭建 Windows 10/11系统 安装PIX 安装Visual Studio 2019 Windows应用程序 Windows应用程序使用事件驱动（详情可以去看WPF） Windows应用程序的入口点是WinMain函数 int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) &#123; LearnDX::D3D12HelloWindow sample(1280, 720, L&quot;D3D12 Hello Window&quot;); return LearnDX::Win32Application::Run(&amp;sample, hInstance, nCmdShow); &#125; 主程序会创建一个窗口，并进入消息循环，检索处理操作系统发来的消息，并对其进行相应 message 发送时机 WM_CHAR 键盘输入一个字符 WM_COMMAND 使用菜单栏、控件 WM_CREATE 创建一个窗口 WM_DESTROY 一个窗口被摧毁 WM_LBUTTONDOWN 按下鼠标左键 WM_LBUTTONUP 鼠标左键被释放 WM_MOUSEMOVE 鼠标指针被移动 WM_PAINT 一个窗口需要重新粉刷 WM_QUIT 应用程序即将终止，WinMain返回 WM_SIZE 调整窗口大小 当接收到WM_QUIT消息时（比如用户关闭窗口），会退出消息循环，应用程序即将结束，WinMain函数返回 COM 为什么要使用COM 我们在编写C++时，经常会生成dll文件，这是一种动态库，保存了许多通用的数据和函数，运行时软件可以通过函数指针的方式导出dll的函数，从而实现运行时动态链接 当我们在同一操作系统、同一编译器环境写构建C++项目，可以复用这个dll文件。然而当你使用其他语言时，如果这个语言读不懂dll的二进制，不知道如何与之沟通，这个语言就不能使用这个dll文件。 或者另一种情况，当你更新了这个dll文件，而应用还在用老办法调用dll，很有可能也会出错 为了解决上述问题，微软提出了组件对象模型（Component Object Model，COM），一套软件组件的二进制接口，可以实现跨编程语言的进程间通信、创建动态对象，在二进制层面打破了代码依赖 COM的优点 软件（apps）使用抽象接口访问服务器（servers，这里指dll文件），可以使用接口指针调用COM类的成员函数 软件无需知道COM的内部实现，COM对象的创建与释放由COM自行完成 COM可能同时被多个软件使用，使用引用计数法进行GC 每个COM类都有独一无二的ID，因此内存中可以同时加载多个拥有相同接口的COM类，软件可以自行选择使用哪一个COM类 COM规定了一种特殊的layout，可以被任何支持COM的语言所解析（但可惜的是，支持COM的语言并不多，因此你还是只能用C++去写DX） COM实际上是由指针和函数表组成（就像C++的虚函数） COM的实现 COM中所有接口都继承于IUnknown，该接口提供了三个操作 AddRef：增加引用计数的次数，每次拷贝接口指针时都会执行 Release：减少引用计数的次数，当次数为0，释放对象 QueryInterface：返回指向该对象的指针 不过显式控制COM对象的引用过于困难，C++推荐使用智能指针 DXGI DirectX Graphics Infrastructure (DXGI)，负责管理一些low-level的任务，比如如何将frame呈现在显示器上，gamma矫正，屏幕刷新，交换链等 依赖 VS添加DX12依赖 打开VS--项目--属性--配置属性--链接器--输入--附加依赖项 cmake添加依赖 cmake_minimum_required(VERSION 3.20) project(DXEngine) set(CMAKE_CXX_STANDARD 17) file(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp src/*.h) add_executable(DXEngine WIN32 $&#123;srcs&#125;) target_include_directories(DXEngine PUBLIC include) # 比较重要的是d3d12.lib dxgi.lib target_link_libraries(DXEngine PRIVATE d3d12.lib dxgi.lib dxguid.lib uuid.lib kernel32.lib user32.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib runtimeobject.lib ) 批注 VS提供了一套批注系统，SAL（Source code annotation language） 字符串 Windows的字符串是一大噩梦 代码的字符编码主要有两种，ASCII和UNICODE，Windows内部使用了utf-16存储字符串，并支持两种API，用以支持ASCII和UNICODE，他们分布以A和W结尾 为了支持两种API，于是推出了一种新的字符类型宽字符：wchat_t，微软将其重命名为WCHAR 宽字符在使用时要在前面加L，比如L'a' 微软又将字符串进行重命名，提出了窄字符串STR和宽字符串WSTR，并给出了他们的指针LPSTR和LPWSTR LPSTR &#x3D; const char* LPWSTR &#x3D; const wchar_t* 如果你用VS开发，可以设置整个项目使用UNICODE，但我不建议这样做 强烈推荐当你要使用字符串函数时，明确使用后缀是A还是W，并且要注意你WindowProc的类型（是使用DefWindowProcW还是DefWindowProcA） d3dx12.h 这是一个.h文件，内含许多DX开发常用函数，将该文件复制到项目中 这个文件中使用了大量Windows SDK，因此你最好用VS2019的Toolchains（Clion的用户使用内置的MinGW可能会报一堆错） 至于为什么要求是VS2019，是因为这个文件与Windows10 SDK版本强相关，VS2019的SDK直接就是对应版本，2017需要手动下载，2015直接没法用 详情 创建第一个窗体 这个窗体啥也没有，就输出一个蓝色屏幕，下面是创建这个窗体的过程 WindowProc是一个回调函数，用于处理传给窗口的消息 OnInt()是D3D12HelloWindow的生命周期函数，包含两个部分，加载管线和加载资源 描述符堆（Descriptor Heap），用于CPU向GPU传递资源（比如数组、贴图），告诉GPU去哪里访问这些资源 描述资源的类型、维度、GPU虚拟地址、硬件信息 我们将描述符绑定在slots上，GPU可以通过访问slots上的描述符找到资源 栅栏（Fence），可以将其插入命令队列以实现同步 DX12支持多线程渲染，命令队列和命令列表的关系如下 硬件架构 CPU Cache占绝大部分面积 ALU、控制单元少，但复杂强大 GPU 计算核心占绝大部分面积 计算核心数量极多，个头小，可编程，支持并行 渲染管线 输入汇编器 输入汇编器（Input Assembler） 输入：顶点索引和顶点缓冲 行为：组装成图元 输出：传给顶点着色器 网格（Mesh）是由图元（通常为三角形）组成的几何体 顶点缓冲区（vertex buffers）存储了顶点相关的数据 输入布局（Input layout）描述了顶点缓冲区的布局，为顶点属性指定语意，使得输入汇编器能读懂顶点缓冲区 索引缓冲（index buffers）内含顶点索引，通过指向顶点缓冲区来组成图元 原始拓扑（Primitive topologies），描述了图元间的连接、邻接关系 特别的，Triangle Strip的三个顶点满足公式 $$ \\Delta_i={i, i+(1+i%2), i+(2-i%2)} $$ 光栅器 光栅器（Rasterizer），发生在片元着色器之前 输入：NDC空间的2D图元 行为： 剔除：裁剪掉视口外的图元，剔除背面（可选） 画线：获得图元所覆盖的像素区域 插值：根据重心坐标和顶点属性进行插值 输出：传给片元着色器 资源管理 内存 GPU可以访问四种内存 专用视频内存（Dedicated video memory）：我们分配GPU资源最常用的地方 专用系统内存（Dedicated system memory）：GPU内部专用内存，应用程序不能使用 共享系统内存（Shared system memory）：CPU可见的显存，常用于CPU向GPU传递数据 CPU系统内存（CPU system memory）：CPU可以任意访问，但GPU要通过PCI-e总线访问，速度极慢 视图和描述符 视图=描述符≈资源指针 简称 全称 意义 CBV Constant buffer view 描述常量缓冲区 UAV Unordered access view 常用于多线程读写 SRV Shader resource view 描述只读纹理和缓冲区 Samplers 采样器 RTV Render Target View 描述渲染目标 DSV Depth Stencil View 描述深度缓冲区 IBV Index Buffer View 描述顶点索引缓冲区 VBV Vertex Buffer View 描述顶点缓冲区 SOV Stream Output View 描述流输出缓冲区 资源状态 资源的多线程读写是冲突的，于是要通过资源状态实现互斥 GPU使用转化资源的状态来指定资源的预期用途，比如要读一张贴图，该贴图必须处于读取状态 DX12使用ResourceBarrier管理资源状态 根签名 在HLSL中，我们可以声明一个变量 Texture2D g_texture : register(t0); 该变量的类型是SRV，绑定到t的第0槽 t：SRV s：Samplers u：UAV b：CBV 管道状态 管道状态（pipeline state object ，PSO）定义了渲染管线的每个阶段的行为，PSO创建后不可变 Bundles 捆绑包（Bundles），用于将少量命令组合在一起，方便使用 Bundles只能提交给CommandList，不能直接提交给命令队列 常量缓冲区 就是CBuffer，是一种访问延迟更低，适合CPU高频更新的缓冲区 在着色器程序执行期间，常量缓冲区不会发送改变 常量缓冲区需要256字节对齐，一般使用4KB或者64KB（关于为什么要对齐、什么是假引用、缓存行，可以去看《高性能C++》笔记）","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"DX12","slug":"DX12","permalink":"https://reubensun.com/tags/DX12/"}]},{"title":"TA面试题","slug":"graphics/TA面试题","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.625Z","comments":true,"path":"graphics/TA面试题/","link":"","permalink":"https://reubensun.com/graphics/TA%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"TA面试题 这里面不少答案都是我自己凭感觉答的，不保真 什么是渲染管线 渲染管线是通过安排CPU发出Draw Call的内容以及顺序，指导GPU进行一系列操作，并协同将开发者期待的图像渲染在屏幕上 剔除 渲染 后处理 什么是Draw Call Draw Call是CPU为GPU准备渲染数据，并指令GPU进行一次渲染的操作，是重量级的 什么是Batching 将多个简单、使用同一材质的物体合并渲染的方式叫Batching batch是批的意思 渲染管线的渲染流程 延迟着色阶段（光栅化）Deferred Shading (rasterization) 直接阴影阶段（光线追踪或光栅化）Direct shadows (ray trace or rasterization) 光照阶段（计算着色器+光线追踪）Lighting (compute + ray trace) 反射阶段（光线追踪或计算着色器）Reflections(ray trace or compute) 全局光照阶段（计算着色器+光线追踪）Global Illumination (compute and ray trace) 环境光遮蔽阶段（光线追踪或计算着色器） Ambient occlusion (ray trace or compute) 透明与半透明渲染阶段（光线追踪+计算着色器）Transparency &amp; Translucency (ray trace and compute) 后处理阶段（计算着色器）Post processing (compute) 渲染流水线的基本流程 渲染就是从一个三维场景出发，获得一个二维图像的过程。分为四个过程，应用阶段、几何阶段、光栅化阶段、像素处理阶段，其中几何阶段光栅化阶段主要在GPU中进行。 几何阶段分为五个步骤：顶点着色器、曲面细分着色器、几何着色器、裁剪、屏幕映射 光栅化阶段分为四个步骤：三角形设置、三角形遍历、片元着色器、逐片元操作 什么是顶点着色器 输入值是CPU通过Draw Call发出的顶点数组（没有索引） 输出值是齐次裁剪空间坐标（如果不使用细分着色器和几何着色器） 什么是细分着色器 在显卡中**视口变换器(Viewport Transform)**中实现 将复杂的曲面转化为简单的点、线、三角形，可以增加网格细度，并在细分后的顶点上生成插值属性 如果使用了曲面细分着色器，顶点着色器就不会处理空间变化（如果没有顶点动画的需求，顶点着色器只负责传递数据），而是交给曲面着色器和几何着色器 在不改变网格外形的情况下，对网格进行平滑操作 什么是几何着色器 在视口变换器中实现，输出值是齐次裁剪空间 能改变顶点数量 能按索引访问顶点 什么是网格着色器 新一代三合一着色器，用于整合顶点、细分、几何着色器 可以实现无矩式渲染 屏幕映射 输入齐次裁剪空间 （通过透视除法）转化到归一化设备坐标(NDC)，最后输出屏幕空间坐标 什么是渲染路径 渲染路径是一系列对光照和着色(尤其是光照)的控制选项的集合 主流引擎支持前向渲染，延迟渲染，和自定义渲染 前向渲染 批次数=相机数x对象数x（除了主有向平行光外的逐片元光照数+1） 随着片元光照数量增多，性能大幅下降 延迟渲染 类似一种后处理 批次数=相机数x（网格数+逐片元光照数） 将几何通路和光照渲染通路分开，几何通道结果输送到G-Buffer中，然后对每个像素只进行一次光照计算 自定义渲染 屏幕后处理、天空盒、透明物体 延迟渲染 为什么延迟渲染不支持透明度混合 因为半透明网格在G-Buffer中会被其他片元覆盖 为什么延迟渲染不支持真的对抗锯齿 因为G-Buffer需要的带宽远远大于帧缓冲，在多重抗锯齿下难以满足负载 前向渲染 前向渲染的渲染通路（Pass）有两种，分布是基本通路（forwardbase）和附加通路（forwardadd） forwardbase 对所有的默认的有向平行光源及其产生的阴影进行逐片元计算，同时对其它基于顶点的和基于球谐光照的光源，以及物体的自发光、统一环境光和光照贴图进行计算 只对一个有效灯光执行一次，所以只会执行一次 forwardadd 对剩下的使用逐片元光照的光源进行光照计算 必须和forwardbase一同使用，不然会被忽略掉 对forwardbase外所有有效灯光都执行一次，所以会执行多次 向量 向量点乘叉乘的几何意义 点乘是投影，叉乘是法向量（方向符合右手定则，沿大拇指方向） 向量点乘叉乘的数学意义 $\\mathbf{a} =\\left( x_{1},y_{1},z_{1}\\right) $ $\\mathbf{b} =\\left( x_{2},y_{2},z_{2}\\right) $ $\\mathbf{a} \\cdot \\mathbf{b} =|\\mathbf{a} ||\\mathbf{b} |\\cos \\theta =x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}$ 求向量$\\mathbf{a}$关于向量$\\mathbf{b}$的对称向量$\\mathbf{c}$ $\\mathbf{a} \\cdot \\mathbf{b}=\\mathbf{c} \\cdot \\mathbf{b}$ $|\\mathbf{a} |=|\\mathbf{c} |$ 求点M关于直线l的对称点N M和N的中点在直线上 $\\overrightarrow{MN} $与直线垂直 欧拉角是什么？有何优缺点 欧拉角是一个直观利用三维向量表达旋转的方法 优点：占用的空间小，不会遇到非法输入 缺点：没有统一标准、不能跨平台；三个分量可能不正交，可能有无法表示的角度；不能插值运算 图形渲染用到哪些空间 顶点着色器：模型空间–M–世界空间–V–观察空间–P–齐次裁剪空间----屏幕空间 什么是模版测试 将屏幕的部分像素通过一个通道盖住，在渲染时剔除通道上不满足条件的值 如何渲染半透明物体 透明度测试 透明度混合 如何优化着色器代码 复杂计算放在顶点着色器中 简化等式，比如说：p = sqrt(2*(X+1))可以改写成1.414*sqrt(X+1)等 尽量使用内建函数 重复度低的操作可以交给CPU 使用顺序结构代替分支 丢弃片元时直接将alpha设为0 纹理图尽量使用2的n次方大小 将许多小纹理拼成一个大纹理 近点采样能满足要求就不要使用线性采样 如何判断多边形是凸多边形 角度法：内角是否小于180° 凸包法：如果凸包和原始多边形点数一样多，那么就是凸多边形 顶点凹凸性：本质上还是角度法，就是相邻顶点组成向量叉乘 相交测试 见图形学笔记 法线贴图 纹理就是贴图 法线纹理用RGB三个通道分布存储法向量在XYZ轴上分量大小 由于法线贴图大部分文素的方向都是朝向法线方向，于是法线贴图大多是蓝色的 如何渲染阴影 体积阴影法 深度阴影法 什么是HDR 高动态范围，一种颜色缓冲技术，使用更高的精度来表示亮度，能更真实的反应光照 HDR通过色调映射转到LDR 什么是伽马矫正 早期摄像机通过伽马加码，将实际亮度存储为更亮的值，显示时通过该骂解码获得正确的功率 什么是色调映射 就是利用显示器有限的亮度范围来近似实现HDR，就是将亮度映射到[0,1]的范围内，并压缩到8位的渲染目标上 什么是PBR 基于物理的渲染 正交投影和透视投影的区别 都是源于对针孔摄像机对数学建模 视锥形状不一样 什么是齐次坐标 为了实现仿射变换，将三维顶点引入四维空间，这个空间叫做齐次坐标空间 旋转平移矩阵 见图形学笔记 高光模型 漫反射模型 Lambert模型：反射光强度和 表面法线和光源的夹角的 余弦值成正比 半Lambert模型：光照有一个保底值，于是没有黑面 Minnaert模型：用于模拟丝绒 Oren-Nayar模型：风之旅人的沙子 高光反射模型 Phong模型：纯几何的经验模型，就是在Lambert漫反射上加了一点高光，强度与 视角方向和反射光方向的夹角的 余弦值成正比 Blinn-Phong模型：Phong的改进，不计算反射光，而是计算视角方向和光源方向的角平分矢量h，用h替代反射方向计算高光 Schlick模型：对BP模型的优化，简化一些运算，能获得更类似于油漆的效果 基于物理的模型 Cook-Torrance模型 什么是光栅化 是渲染流水线的一个重要阶段 三角形设置和三角形遍历可以合成光栅化，计算三角网格，并进行线性插值 阴影，软阴影 什么是抗锯齿 锯齿是走样的一种，指在渲染三角形、线的时候，像素要么存在，要么不存在，于是出现锯齿现象 SSAA，超级采样抗锯齿，翻倍渲染向下采样 MSAA，多重采样抗锯齿，每个像素内有多个采样点，渲染时以点数加权获得（性能好，不支持延迟渲染） FXAA/TXAA，放弃精度，让边缘模糊 延时渲染 场景中有大量实时光源时，前向渲染效率会下降，使用两个Pass，一个不计算光照，只计算片元是否可见 不支持抗锯齿，不能处理透明物体 故障检测 后处理 亮度饱和度对比度 边缘检测 高斯模糊 动态模糊 Bloom效果 贴图技术 贴图就是纹理 BRDF 双向反射分布函数 作品集里实现原理 ezy-slice原理：网格中存储了顶点数据、三角形数据、法线数据，使用MeshFilter获得sharemesh（mesh是新网格，sharemesh是原始网格） 物体的节点和三角形被分为三个部分（上下和切割面），相交处的三角形做分割操作，然后让原始网格不可见 如何区分位置和方向 齐次坐标，w==0就是位置，w==1就是方向 SSAO SS（Screen Space），都是后处理 SSGI屏幕空间全局光照 SSAO屏幕空间环境光遮蔽，对屏幕空间上每一个片元，在其法线范围的半球体中进行采样，采样点在深度纹理采样，从而判断该点是否被遮蔽 一般来说使用SSAO后还要在进行一次模糊，还需要进行时域平滑来避免闪动 SSR SSR屏幕空间反射，在相机中发射出n条光线，然后根据物体的法向量和摄像机的射线方向计算出这条光线的反射方向。再对他进行raymarch（光线步进）计算。 动态模糊 种类 相机动态模糊 对象动态模糊 原理 保存多帧数据进行混合 速度映射图，图中存储了每一个像素的速度，沿着这个速度采集像素，进行加权混合，得到模糊效果 线框 方法1:深度偏移（这玩意不是线框，是描边） 使用两个Pass渲染，一个正常渲染，一个在深度偏移的情况下渲染一遍线 两个Pass有性能损失 深度偏移是为了防止线条被遮挡，这会导致多边形和线框在相同位置的片元的深度值不一样 方法2:几何着色器（这才是线框） 几何着色器可以使用索引数组访问顶点的拓扑结构 线框渲染可以使用几何着色器访问三角形，并计算每个顶点到对边的垂线长度，于是通过插值获得三角形中每个点到三角形三个边的最短距离 我们知道在光栅化阶段要插值上色，那么我们可以在插值的时候进行判断，当垂线距离符合条件时（离三角形边特别近）就染上线框的颜色 片元着色器和像素着色器的区别 在大部分情况下没有区别 在极个别情况下（大概是OpenGL那边）我门认为如果片元着色器中的输入数据是恰好覆盖屏幕的四边形时，这个片元着色器被称为像素着色器 SDF 距离函数 shadertoy的本质就是通过编写（2D）距离函数来绘制物体 为什么shader中少用分支和循环 因为在gpu中，分支的实现原理是两个分支都执行，然后丢弃不需要的分支，这个增长是指数级的（2^n^） 什么是Cubemap 立方体纹理，是实现环境映射的一种方法 什么是光照探针 是一组封装后的Cubemap，在烘培或预计算时，对空间中的一些采样点（光照探针）采集Cubemap，在运行环境渲染运动物体时，CPU会从离物体最近的光照探针中获取Cubemap，按照距离进行插值。 这个过程实现了CPU和GPU的解耦，CPU只需要维护一组固定的光照探针组，GPU只需要处理与这个物体相关的临近Cubemap 通过光照探针获取环境景象需要对场景进行六次渲染（毕竟有六个面） 什么是球偕函数 将真实环境中连续的光照方程进行离散化，通过球形坐标系分解简化反射方程，通过球偕变换获得球偕系数，在运行时根据球偕系数重建方程 采样-分解-变换-重构 参数和分量 参数是黑盒，分量是白盒（你可以理解的是，别人在unity面板上拖动的属性多半是参数，一种东西的组成是分量，比如颜色可能就有由高光、漫反射等分量） 为什么次表面散射用漫反射做高斯模糊 因为lambert的光照强度与入射光线和法线夹角有关，而折射和反射的比例也与这个夹角有关（菲涅尔） 折射光是次表面散射的入射光，折射的光越强，散射的光也会越强 什么是光线步进 光线步进（raymarching）：从摄像机位置向屏幕每一个像素点发射一条光线，光线按照一定步长前进，并检测当前光线是否位于物体表面，据此调整光线前进幅度，直到抵达物体表面，再按照一般光线追踪的方法计算颜色值。 什么是MC算法 **步进立方体算法（Marching Cube）**是一种在密度场中采样来生成多边形的算法，在生成多边形之后再依照多边形渲染的过程进行正常的渲染。 相比射线扫描算法，步进立方体算法可以生成并保存多边形，所以在密度场的修改频率不高的情况下，使用步进立方体算法可以节省很多不必要的性能消耗。 核心：确定等值面 什么是屏幕空间阴影纹理 对于多光源的情况，每个光源都可以产生一个深度阴影纹理。在着色器中对这些深度阴影纹理逐个进行处理，可以得到若干个屏幕空间的阴影纹理，将这些屏幕空间下的阴影纹理混合就可得到一个总的屏幕空间阴影纹理，它表示了在屏幕空间中某个片元接受到的来自所有光源产生的阴影强度的总和 什么是URP unity内的**渲染管线（Render pipelines）**包括 内置渲染管线（Build-in） 可编程渲染管线（Scriptable Render Pipeline，SRP） 高清渲染管线（High Definition Render Pipeline，HDRP） 通用渲染管线（Universal Render Pipeline，URP） 什么是滤波模式 纹素坐标是整数值，但UV坐标不是，所以要有一种方法由UV坐标获得纹素值 最近相邻滤波(Nearest neighbor filtering，或者Point sampling) UV坐标 x 纹理大小，然后四舍五入取最近的纹素 有明显的像素块 双线性滤波(Bilinear filtering，或者liner filtering) 根据一个坐标到其附近最近的四个像素点的距离进行加权平均，得到一个混合的颜色 三线性滤波(Trilinear filtering) 在相邻的两个Mipmap层次上分别进行双线性滤波，再对得到的两个值进行线性插值 当距离非常大或非常小的时候，三线性滤波会退化为双线性滤波 各项异性滤波(Anisotropic filtering) 当一个目标表面和透视摄像机之间的角度较大时，纹理的填充面积实际上并不是正方形，这引入了模糊和闪烁等瑕疵 需要在一个非正方形区域内采样和混合 有的使用长方形，有的使用梯形 什么是纹理映射 就是将三维的空间坐标点转化为二维的纹理坐标点 步骤： 投影映射 变换函数 纹理采样 纹理转换 什么是纹理压缩 这是一种有损压缩，对于一张原始纹理，会创建两张小纹理A和B，同时还有一个矩阵M，M的行列和原始纹理的长宽一致，里面的值类似于调色板中的索引，实现纹理A和纹理B的混合 GPU的寻址方式 集成显卡 对集成显卡来说，GPU使用CPU专门划分出来的一份内存空间**UMA（Unified Memory Architecture，一致性储存架构）**作为显存，GPU和CPU使用不同的虚拟地址对UMA中同一个物理地址进行寻址，两者共享总线。 在渲染时，CPU将顶点数据存储到主存中，然后GPU通过**GART(Graphic Address Remapping Table，显存地址重定位表)**访问UMA 独立显卡 独立显卡中CPU和显卡的沟通是使用异步的**DMA(Direct Memory Access，内存直接访问)**实现的。 CPU将DMA命令从内存中读取，并写入DMA控制器 DMA控制器直接操控内存总线，在不依赖CPU的情况下将数据传输给显卡驱动 显卡驱动给DMA控制器发送信息（握手） DMA占用内存总线，向内存请求地址，向显卡发送信号 显卡接受信号后将数据传输到内存，并清除DMA请求信号 沟通结束，触发一次CPU中断 CPU和GPU分支预测方式有何差别 CPU CPU在流水线中进行分支预测 静态分支预测 动态分支预测 协同分支预测 GPU 将两个结果都运行一次，然后丢弃不需要的分支，这样会严重影响性能（指数级），这个现象被称为线路分歧 纹理数据在GPU中是如何排列的 纹理存储器中的数据以一维/二维/三维数组的形式存储在显存中，可以通过缓存加速访问 在kernel中访问纹理存储器的操作称为纹理拾取(texture fetching) 将显存中的数据与纹理参照系关联的操作，称为将数据与纹理绑定(texture binding) shader中的变量类型（OpenGL） uniform 在顶点着色器和片元着色器中的声明方式完全一样，可以视为被双方共享的全局变量 attribute 只能在顶点着色器中使用的变量，一般用于存储顶点的位置、法线、uv、颜色信息 varying 顶点着色器和片元着色器之间做数据传输用的变量，必须保证在两者中声明保持一致 如何保证顶点着色器传入片元着色器的数据一致性 varying变量声明一致？ 矩阵乘法 两条直线的交点就是C的位置 x左乘A x右乘A 直线扫描转化法 数值微分法DDA 思想：步进和通过舍入选择像素 $P_{0}(0,0)$到$P_{1}(5,2)$ k=0.4 $i$ $x_{i}=x_{i-1}+1$ $y_{i}=y_{i-1}+k$ $round(y_{i})$ 坐标 0 0 0 0 (0,0) 1 1 0+0.4=0.4 0 (1.0) 2 2 0.4+0.4=0.8 1 (2,1) 3 3 0.8+0.4=1.2 1 (3,1) 4 4 1.2+0.4=1.6 2 (4,2) 5 5 1.6+0.4=2.0 2 (5,2) 中点画线法 相比于DDA算法，省去了浮点数运算 直线方程$F(x,y)=Ax+By+C=0$，若$F(x,y)&gt;0$则位于直线上方，若$&lt;0$则位于直线下方，若$=0$则在点上 使用步进思想，根据中点误差项判断是向右移动还是向右上移动（如果0&lt;k&lt;1) 直线已经经过点$P$，下一步经过了点$P_{u}$和$P_{d}$，他们的中点是M，我们将M带入直线方程，通过判断大小来决定是不是 为了进一步降低消耗，使用步进，每一次就将点$P(x_{i}+1,y_{i}+0.5)$带入直线方程$Ax+By+C=0$ d&lt;0就取右边的点，$d_{i+1}=d_{i}+A+B$ d&gt;0就取右上的点，$d_{i+1}=d_{i}+A$ 只不过我们只关心符号，所以可以用2d代替d d&lt;0就取右边的点，$d_{i+1}=d_{i}+2A+2B$ d&gt;0就取右上的点，$d_{i+1}=d_{i}+2A$ Bresenham画线法 本质上和中点画线一样 $d_{i}&lt;0$就取右边的点，$d_{i+1}=d_{i}+2\\Delta y$ $d_{i}\\geqslant 0$就取右上的点，$d_{i+1}=d_{i}+2\\Delta y-2\\Delta x$ $d_{1}=2\\Delta y-\\Delta x$ $P_{0}(0,0)$到$P_{1}(5,2)$ k=0.4 $\\Delta y=2$ $\\Delta x=5$ $i$ $d_{i}$ $x_{i}$ $y_{i}$ 坐标 0 0 0 0 (0,0) 1 $d_{1}=2\\Delta y-\\Delta x=-1&lt;0$ 1 0 (1.0) 2 $d_{2}=d_{1}+2\\Delta y=3&gt;0$ 2 1 (2,1) 3 $d_{3}=d_{2}+2\\Delta y-2\\Delta x=-3&lt;0$ 3 1 (3,1) 4 $d_{4}=d_{3}+2\\Delta y=1&gt;0$ 4 2 (4,2) 5 $d_{5}=d_{4}+2\\Delta y-2\\Delta x=-5&lt;0$ 5 2 (5,2) 构建贝塞尔曲线 一阶 两个点$P_{0},P_{1}$ 直接坐标线形插值 $B_{1}(t)=(1-t)P_{0}+tP_{1}$ 二阶 三个点$P_{0},P_{1},P_{2}$ 先求$P_{0}P_{1}$和$P_{1}P_{2}$的一阶贝塞尔，然后再对两个一阶进行线性插值 n阶 $$ B_{i,n}\\left( t\\right) =\\frac{n!}{i!\\left( n-i\\right) !} t^{i}\\left( 1-t\\right)^{n-i} $$ $i$是第几项，从0开始 $n$是控制点总数 线段的裁剪 Cohen-Sutherland 尽量避免求交运算 编码，把空间分为九个部分，其中中间部分是屏幕，其outcode编码为 判断时，两个端点的outcode值为$o_{1}和o_{2}$ 若$o_{1}=o_{2}=0（其实是0000）$：说明两个点都在屏幕中间 若$o_{1}\\neq 0,o_{2}=0（12顺序可以颠倒）$：说明一个在屏幕内，一个在屏幕外，而非零端点的编码说明了线段与裁剪窗口哪一个边（或者两个边）相交，需要计算交点 若$o_{1}&amp;o_{2}\\neq 0$：说明两个点在裁剪窗口的同一侧，可以直接丢弃 若$o_{1}&amp;o_{2}= 0$：需要计算交点 Liang-Barsky 窗口$Wx_{l}=0,Wx_{r}=4,Wy_{b}=0,Wy_{t}=3$ 直线： $$ \\begin{cases}x=-2+u\\left( 7+2\\right) &amp;\\ y=6+u(-2-6)&amp;\\end{cases} $$ $$ \\begin{cases}u_{1}=2/9&amp;\\ u_{2}=2/3&amp;\\ u_{3}=3/4&amp;\\ u_{4}=3/8&amp;\\end{cases} $$ $u_{max}=\\max(0,2/9,3/8)=3/8$ $u_{min}=\\min(1,2/3,3/4=2/3)$ 所以保留$u_{2}u_{4}$，其中$u_{2}=(4,2/3)\\ u_{4}=(11/8,3)$ Early-z 在vertex后，fragment前做一次深度测试，如果失败，则不进行fragment（如果成功，还是要在fragment中做ZTest），这样可以大幅提高性能 开启AlphaTest需要关闭Early-Z，因为AlphaTest通过会写入深度值，而新写入的深度值无法通过Early-Z，于是本该输出的颜色被剔除了（现在硬件做了优化，可以更智能的自动开关Early-Z） 什么是球面度 球面度sr是立体角的国际单位（平面角的单位是角度/弧度），可以理解为三维的弧度 弧度 在一个圆上切一个扇形，弧长等于$r$所对应的角为1弧度 一个完整的圆的弧度为$2\\pi$ 球面度 在一个球上切一个“锥形”，锥形的底面积等于$r^2$所对应的角为1球面度 一个完整的球的球面度为$4\\pi$ 为什么BRDF 函数的单位是 1/sr BRDF，双向反射分布函数，是材质表面某一点出射**辐射率（Radiance）和入射辐照度（Irradiance）**的比值 $$ BRDF=\\frac{dL\\left( \\omega_{o} \\right) }{dE\\left( \\omega_{i} \\right) } $$ 辐射率$L$：每单位面积每单位**投影固体角（projected solid angle）**上的能量 辐照度$E$：每单位面积上的能量 为什么BRDF不直接用出射辐射率/入射辐射率呢？ 原因一：因为入射辐射率很难测量 测量**出射辐射率$L_{0}$**很简单，只要我在出射方向上放一个下面的仪器，对准该点就可以了 测量入射辐射率很麻烦，需要要求光源很小，没有其他光的干扰，所以实际测量的时候不可行，于是不使用，最后BRDF就是出射辐照度/入射辐射率，这两个 而测量辐照度$E_{i}$只需要一个面积较小的平面，接收半球方向的光通量$\\Phi $，$E=\\Phi /S $ 原因二：数学 如果是辐射率/辐射率，当出射立体角$\\omega_{o}$趋近为0时，两者比值为0（上面是无穷小），没有意义 $$ \\lim_{\\omega_{o} \\rightarrow 0} \\frac{dL_{o}}{L_{i}} =0 $$ 但辐射率/辐照度不等于零，因为上面下面都有无穷小，所以是不定式/等价无穷小，有意义 $$ \\lim_{\\omega_{o} \\rightarrow 0} \\frac{dL_{o}}{dE_{i}} \\neq 0 $$ 什么是万向节死锁 Gimbal Lock （万向节死锁，或叫 环向锁节） 在传统的欧拉坐标系，相机可以沿着xyz三个方向旋转，这三个轴有旋转的先后顺序，可以理解为父母层级关系，父轴旋转时子轴也会跟着旋转 Y轴 X轴 Z轴 相邻两个轴始终保持垂直，但有的时候，第一个轴会和第三个轴重合，于是你就会失去一个自由度，你无法朝向某一个方向旋转了，如果要旋转，就需要同时旋转两个轴，这个旋转很不流畅，会出现抽搐，被称为万向节死锁 可以通过引入四元数解决 有什么常见的遮挡算法 画家算法 后画覆盖新画 这是剔除的核心，下面几个都是对其的加速和优化 沃诺克算法（Warnock） 不停地四分屏幕 当前子空间没有多边形：完成！ 当前子空间只有一个多边形：画！ 当前子空间有简单的前后关系：画前面的！ 当前子空间只有一个像素那么大了：画离该像素点距离最近的多边形！ 否则，继续递归细分 BSP-Tree（二维空间分割树） 不停地二分空间，在每一个只有简单前后关系的子空间里使用画家算法 Z-Buffer 写入颜色时也写入Z值，绘制时根据Z值判断是否覆盖 有overdraw，只能处理不透明物体，多使用了一个Z-Buffer 如何判断点在三角形内 同侧法 若点P在三角形ABC内部，则 点P和点A在直线BC同侧 点P和点B在直线AC同侧 点P和点C在直线AB同侧 判断是否同侧都方法是叉积同号 叉积法 PA、PB、PC两两叉积，如果三者同号则为内部 重心公式 平面内两个不平行的非零向量可以表示任何向量 $$ \\overrightarrow{AP} =u\\overrightarrow{AB} +v\\overrightarrow{AC} $$ 两边点积 $$ \\overrightarrow{AP}\\cdot \\overrightarrow{AC} =u\\overrightarrow{AB}\\cdot \\overrightarrow{AC} +v\\overrightarrow{AC}\\cdot \\overrightarrow{AC} $$ $$ \\overrightarrow{AP}\\cdot \\overrightarrow{AB} =u\\overrightarrow{AB}\\cdot \\overrightarrow{AB} +v\\overrightarrow{AC}\\cdot \\overrightarrow{AB} $$ 两个变量两个公式，可以求出u和v 什么是MIS 多重重要性采样（multiple importance sampling，MIS），在光追中，当光源和物体表面材质都接近$\\delta$分布时，无论在光源上采样还是按BSDF采样都会带来很高的方差，使用MIS可以提高效果 思路就是结合不同种采用方法，分布采用被积函数的不同部分，讲这些部分结合起来，以达到最优效果 什么是德尔塔分布 $\\delta$函数（狄拉克函数）：除了零点以外的点都等于零，但在其整一个定义域内的积分为1的函数（这种函数本身并不存在） $\\delta$分布：符合$\\delta$函数的分布 已知UV和深度如何重建世界坐标 使用逆矩阵 用uv和深度重建NDC坐标，乘以VP矩阵的逆矩阵以重建世界坐标 线性深度 正交投影 uvz线性映射回视锥长方体 透视投影 通过z确定投影面大小，然后uv线性映射 草地弯曲是怎么实现的 顶点偏移？ 离角色很近的树叶如何保持性能 是不是每一次draw call都需要重新传一次顶点数据 贴花 前向：绘制几何体 延迟：Gbuffer中绘制 SSR会丢失信息，可以怎么处理 用cubemap补一下？ 为什么有法线贴图还需要顶点法线信息 为了构建TBN矩阵 在片元着色器中采集切线空间法线贴图信息，然后使用TBN矩阵恢复成世界空间法线，那么TBN是怎么来的呢？ half3x3 tangentToWorld &#x3D; half3x3(i.tangentWS.xyz, bitangent.xyz, i.normalWS.xyz); 是使用顶点着色器传入的世界空间切线、次切线、法线构建的 Forward+ 和传统的前向渲染比添加了一个光源剔除阶段 着色分三个阶段： depth prepass（可选） Light culling shading 将光源信息存储在一个线性布局的缓冲区中，方便查找 light culling阶段和延迟渲染中光照累计很相似，对于每一个像素，先找其所在的tile，求能照射到这个tile的光源列表，然后进行着色 理论上对每一个像素找灯光是效果最好的，现在这种找tile很显然是会计算一些多余的灯光，但是大幅减少了查找灯光的计算量，在查找和着色间寻找一个平衡 移动端GPU渲染架构 IMR Immediate Mode Rending，即时模式渲染，按drawcall顺序绘制 TBR Tile Base Rendering 将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上，然后FS读信息，渲染每一个tile 作用：省带宽，每次传一个小tile，对带宽的压力会比IMR小很多（IMR一次传一整张屏幕） TBDR Tile Base Deferred Rendering 上面我们在FS对每一个tile做渲染时，完全可以记录哪些灯光会影响这个tile，使用这些光做计算 思路 TBR省带宽了，但是没减少overdraw，而TBDR处理了剔除问题，降低了overdraw TBR的其他应用 MSAA：MSAA是对一个像素多采几个点，原本采样很费，因为要加载卸载贴图 但是由于TBR每一个tile都是片上的，相当于省了加载卸载，性能好很多 只不过虽然采样变便宜了，采样结果一多，就要处理更多的采样数据，所以也不能无限制的使用 此外这会让多边形覆盖更多的像素 如图，只有一个采样点时（红点），红圈所在的像素不会被算进去，但MSAA时就会被算进去 视差贴图 视差贴图（Parallax Mapping）效果类似法线贴图，其原理是对纹理采样uv做偏移，不修改顶点信息 原本平坦的表面，如果变成如图的凹凸形状，原本视线会与平面在B处相交，现在则在A处相交，我们采集$A’$点的信息 从B到$A’$做了什么呢？本质就是采样点从B点出发，沿着视线在平面的投影做了一次偏移，偏移的长度可以通过三角形相似求得 &#x2F;&#x2F;输入B的uv，得到A‘的uv float2 ParallaxMapping(float2 texCoords,float3 viewDir) &#123; float height &#x3D; texture(depthMap, texCoords).r; float2 p &#x3D; viewDir.xy &#x2F; viewDir.z * (height * height_scale); return texCoords - p; &#125; 如果按深度步进，通过从上到下找第一个深度小于A的平面，来求$A’$的位置，就是陡峭视差映射(Steep Parallax Mapping)的思想 virtual texture 根据是否实时生成（合并）virtual texture，该技术分为VT和RVT，该技术主要用于大世界地形上 在说VT前，要先谈texture splatting。大世界的地表纹理通常是使用多张纹理混合而成的（比如沙子、草、岩石、雪），而混合这些贴图的技术称为texture splatting 该技术很简单，比如要混合四张图，那么生成一个新的RGBA贴图，在某一点的混合图为 blenderTex &#x3D; Texture1 * map.r + Texture2 * map.g + Texture3 * map.b + Texture4 * map.a; &#x2F;&#x2F;其中 map.r + map.g + map.b + map.a 恒等于1 我们发现这种混合技术要频繁采样，混合四张图，要采9张图（四个材质图，四个法线图，一个splat图），而我们知道采一张大图会比采多个小图性能高很多，那么我们能不能把这九张小图拼成一张大图呢？这就是VT 但我们没必要一次把这九张完整的图合并，这也存在浪费，那么我们只需要合并需要被采样的图 我们把原图做预处理，分割成一个个小tile，并维护一个映射表，当我们要采样某个范围内的贴图时，先根据映射表找到所有相关的tile（回传给CPU，让CPU去加载tile），再把tile合并 帕尼尼投影 一种屏幕后效，画面中心凸起，镜头左右两边在垂直方向上保留画面原样 SSBO Shader Storage Buffer Object，该对象可以在不同shader间共享数据，功能类似UBO（Uniform Buffer Object） 两者（SSBO和UBO）区别 SSBO更大 SSBO的大小可以在运行时确定 UBO在显卡的常量区（CMEM），SSBO在全局区（SMEM） SSBO更灵活，能支持更多种的数据类型 计算任意多边形面积 凸多边形 一多边形某个点为顶点，将多边形划分为多个三角形，计算每个三角形的面积（可以用向量叉积），再加起来 凹多边形 向量的叉积是有方向的 $$ S_{OAB}=0.5*(\\overrightarrow{OA} \\times \\overrightarrow{OB}) $$ $$ S_{ABCDE}=S_{OBC}+S_{OCD}+S_{ODE}+S_{OEA}+S_{OAB} $$ OBB包围盒 常见的包围盒有AABB和OBB，AABB是轴向的，生成简单，但当物体旋转时效果并不好，OBB是有向的，沿着物体的主成分方向生成最小的一个矩形包围盒，可以随物体旋转 OBB2D的生成思路是：通过主成分分析（PCA）获得特征向量，作为OBB的主轴，然后将所有点包含 主成分分析 主成分分析是一种通过正交变换，将一组可能相关的变量集合变换成一组线性不相关的变量集合，即主成分 简单来说就是根据所有顶点生成协方差矩阵，对其对角化 BS变形器 blendshape 将一个mesh变化为另一个mesh（顶点数不变）的规则，就是一个BS，其最重要的功能是做表情 什么是灭点 在透视投影中，不平行于投影平面的平行线会聚集到一点，改点就是灭点 用途 在制作屏幕后效时（比如雨水），在相机的双锥体上渲染（而不是直接对屏幕四边形），可以得到一种雨水向远处收拢的感觉 选人界面的打光与镜头 打光 环境光：用HDRI贴图提供 直接光：打在人物正面斜上方，提供主要亮度，开启阴影 虚拟光：用于模拟反光板的提供的光源，亮度较弱，方向和相机一个位置（卡渲中常用，可以减弱光照对比，减弱阴影问题） 镜头 使用长焦镜头，也就是提高FOV，这样可以减少面部崎变，让人显得更瘦（反其道而行之，就是大头猪鼻特效） 开启景深 深度景深：没法处理半透明物体，人物头发也会会出问题（因为深度变化太小） Circle Blur：效果更好，美颜相机大多使用这个，原理就是把人抠出来，把人以外的背景模糊 眼球渲染的要点 眼白 血丝 可以直接画在贴图上 次表面散射 将散射函数预积分到LUT图上 眼睛 镜面反射 颗粒状眼白法线，来表现眼白的粘液 AO 在眼球外层做一个用来遮蔽的半透明模型 虹膜 缩放 uv采样缩放 视差 焦散（猫的眼睛发亮） 双层法线，圆滑的法线计算高光，平整的法线计算漫反射 虹膜对光线的吸收（眼珠旁边有黑圈） 根据uv画圆 瞳孔收缩 泪腺 移动端Deferred 移动端延迟与GPU架构强相关 iOS：one pass deferred Adreno：frameBuffer fetch deferred 提前绑定（开辟）好MRT，使用时RT不动，Pass动 Mali：pixel loacl storage deferred 将GBuffer存在on-clip mem上，于是就减少了IO消耗 移动端SubPass Unity移动端使用Metal和Vulkan API时，都可以使用SubPass，但略有不同 在同一个RenderPass的不同SubPass间切换，是不会带来带宽消耗的 Metal 支持FrameBufferFetch，即可以在一个SubPass中对RT读写 不支持在Tile上读取深度 Vulakn 不支持FrameBufferFetch 支持在Tile读深度（mali设备读浮点纹理比读tile的深度更高效） 由于Metal不支持读深度，而mali Vulkan读深度效率比读RT差，所以Metal和Vulkan都在GBuffer Pass时额外生成一张深度RT，在LightingPass里用 角色灯光术语 光比 指物体受光面亮度与阴影面亮度的比值，比值越大，明暗对比越强 常出现在黑暗空间爆炸光效照亮角色 二值化光 照明时，灯光颜色在固定好的暗部颜色和亮部颜色之间插值 抗锯齿 抗锯齿有两大类，时间层面和空间层面，但本质都是增加采样点数 空域抗锯齿 MSAA（MultiSampling Anti-Aliasing）：一个像素采多个点 On-Clip MSAA FXAA（Fast Approximately -Aliasing）：卷积模糊 SMAA（Enhanced Subpixel Morphological）：边缘检测–矢量化–像素混合 时域抗锯齿 TAA（Temporal Antialiasing），一帧采一下，几帧后就等于采了很多点 svoGI Sparse Voxel Octree（稀疏体素八叉树） GI，是VXGI的进阶版本 无偏渲染 SST Sparse Shadow Tree，一种大范围阴影渲染方案 论文地址 ShadowCache 对静态物体和动态物体使用两套CSM，一套只绘制动态物体，每帧刷新，一套只绘制静态物体，低频刷新 低频刷新的CSM被称为ShadowCache TressFX 一种实时毛发渲染系统 XGen 一个maya的头发制作工具 maya文档 Vulkan的基本概念 Vulkan对象主要分为三个部分，每个部分都有一个主对象 Instance 第一个Vulkan对象，用于连接应用程序和Vulkan运行时 PhysicalDevice 显卡 可以枚举图形队列 可以枚举内存堆和内存类型 Device 逻辑设备 Queue：用于向GPU传递命令（类比SRP的上下文） CommandPool：用于创建CommandBuffer CommandBuffer：命令缓冲区，可以通过vkQueueSubmit提交到Queue中 Sampler：一组采样器状态，用于设置滤波模式、寻址模式等 Buffer&amp;Image：资源，渲染时不会直接使用 BufferView&amp;ImageView：对资源的解释（Buffer&amp;Image中，我们所需要的部分），渲染时直接使用（类比SRP的RT） SurfaceKHR：控制屏幕窗口，与平台相关 SwapchainKHR：交换链，内含一组图片，用于实现显示交换 立即渲染 双缓冲 多重缓冲 Descriptor：描述符，用于访问资源（顶点信息，缓冲区，图像，采样器） DescriptorSet DescriptorSetLayout DescriptorPool FrameBuffer：ImageView的集合（RT、MRT） Attachment：附件（类比SRP的RenderTarget） Attachment初始化：Load Action Attachment写回内存：Save Action RenderPass：一次渲染流水线的执行，将信息输出到FBO的Attachments中 SubPass：渲染的中间Pass，他们的目标不是FBO，而是一些临时的目标 Pipeline：管线 ComputePipeline GraphicsPipeline PipelineLayout ShaderModule：使用SPIR-V进行着色器编译 PipelineCache Query：查询，用于得到某指令的执行情况 Fence&amp;Semaphore Fence：栅栏，用于CPU和GPU同步 Semaphore：信号量：用于GPU内部的同步（对客户端黑盒）","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"TA","slug":"TA","permalink":"https://reubensun.com/tags/TA/"}]},{"title":"ddx与ddy","slug":"graphics/ddx与ddy","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.621Z","comments":true,"path":"graphics/ddx与ddy/","link":"","permalink":"https://reubensun.com/graphics/ddx%E4%B8%8Eddy/","excerpt":"","text":"ddx与ddy 在OpenGL中叫dFdx和dFdy，在HLSL中叫ddx和ddy HLSL deriv_rtx ddx和ddy是一个求偏导的过程，依赖于硬件光栅化，只能用于fragment着色器，意思为计算blocks内相邻片元间value的变化（value可以是任意参数，比如uv、color、position、normal），注意不要在分支中使用偏导 $$ \\mathrm{ddx}=\\frac{\\mathrm{p}(x+1,y)-\\mathrm{p}(x,y)}{1} $$ 三角形光栅化时，fragment着色器一次处理2x2个像素，其中左上角的像素$(x,y)$始终为偶数坐标 如果一个几何体不够大，使用抗锯齿算法后渲染分辨率仍然比2x2要小，那么这个几何体在光栅化前就会被剔除，以此不必担心像素不够的情况 mipmap（UV） 使用mipmap会增加贴图存储，但是能提高性能和效果，在对mipmap贴图进行采样时，我们可以手动指定采样层级 我们需要一种方法能求mipmap层级（如果层级不对，会导致纹素比异常，产生摩尔纹等） ddx和ddy一个应用是求贴图mipmap层级 float mip_map_level(in vec2 texture_coordinate) &#123; vec2 dx_vtc = dFdx(texture_coordinate); vec2 dy_vtc = dFdy(texture_coordinate); float delta_max_sqr = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc)); return 0.5 * log2(delta_max_sqr); &#125; 在OpenGL4.x提供了mipmap函数textureQueryLod() 面法线（坐标） 我们在fragment着色器中对世界坐标做ddx和ddy，就能得到三角面上两个向量（这俩向量还是垂直的），而平面上两个非平行向量就能确定一个平面，他们的叉积就是面法线（注意手系和法线正负） vec3 faceNormal = normalize( cross(dFdx(pos), dFdy(pos)) ); 该技术常用于平面着色（Flat Shading），让物体有一种低面感，法线没有插值，是ground着色、phong着色以前的东西（老古董前的老古董） 高度图（法线） 与面法线原理类似，给定一张单通道的灰度图当作高度图，通过ddx、ddy就能得到高度的变化，进而得到法线的变化 fixed h = tex2D(_HightMap, i.uv).r; float offsetU = -ddx(h); float offsetV = ddy(h); float3 n = normalize(i.normal.xyz + float3(offsetU, offsetV, 0) * _Intensity);","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"shader","slug":"shader","permalink":"https://reubensun.com/tags/shader/"}]},{"title":"Nabla算子","slug":"math/Nabla算子","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.627Z","comments":true,"path":"math/Nabla算子/","link":"","permalink":"https://reubensun.com/math/Nabla%E7%AE%97%E5%AD%90/","excerpt":"","text":"Nabla算子 参考 $\\nabla$：Nabla算子，将数量场变成向量场 当其作用于函数，如$\\nabla F(x)$，意思为求该函数梯度 当其点乘函数，如$\\nabla \\cdot F(x)$，意思为求该函数的散度 当其叉乘（三维）函数，如$\\nabla \\times F(x)$，意思为求该函数的旋度 函数可视化 对于函数$f(x,y)=x^2+y^2$，我们有两种可视化方法，第一种叫做图像： $$ {(\\vec{x}, f(\\vec{x}))|\\vec{x} \\in D} $$ 第二种叫做等值面: $$ {\\vec{x}|f(\\vec{x})=c} $$ 等值面只需要二维空间就能表示三维数据 梯度 Nabla算子其实是一个向量： $$ \\nabla =\\left[ \\frac{\\partial }{\\partial x_1}, \\frac{\\partial }{\\partial x_2 },\\cdots,\\frac{\\partial }{\\partial x_n } \\right]^{T} $$ Nabla算子作用于函数（标量场），可以将标量场转化为向量场，我们称该向量场为梯度 $$ \\nabla f= \\left[ \\begin{array}{c} \\frac{\\partial f}{\\partial x_1}\\\\ \\frac{\\partial f}{\\partial x_2}\\\\ \\vdots\\\\ \\frac{\\partial f}{\\partial x_n}\\\\ \\end{array} \\right] $$ 梯度垂直于等值面，意义为变化最快的方向（图中黄色箭头） 散度 我们知道向量和向量间可以进行点乘，其结果为一个标量，那么Nabla算子和向量相乘，我们称所得到的标量为散度 $$ \\vec{f}=\\left[ \\begin{array}{c} f_1\\\\ f_2\\\\ \\vdots\\\\ f_n\\\\ \\end{array} \\right] $$ $$ \\nabla \\cdot \\vec{f}=\\frac{\\partial f_1}{\\partial x_1}+\\frac{\\partial f_2}{\\partial x_2}+\\cdots +\\frac{\\partial f_n}{\\partial x_n} $$ 上图的白色箭头表示一个向量，我们发现这些箭头都是在朝外扩散，而散度就是用来衡量箭头向外扩散的程度 散度的物理意义是通量的局部描述。我们在图上画一个圈，我们发现会有向量进入这个圈，也有向量离开这个圈，那么进出之合，我们就称之为通量（比如磁通量），我们将通量除以圈的面积，就得到了通量的体密度。若这个圆取无穷小，那么体密度的极限值就是该点的散度 是不是突然很好理解麦克斯韦方程中$\\nabla \\cdot \\mathbf{E}=0$的原因了？ 其实这个公式就是高斯公式 旋度 向量不仅可以点乘，其实也可以叉乘，两个三维向量叉乘，能得到一个3x3的行列式。最后得到一个矩阵，我们称为旋度 旋度的物理意义就是环量的面密度。现在有一个在旋转的场，我们在场上画一个圈，场在这个圈内会做功，这个功就是环量，我们求出单位面积上环量，这个极限值描述了漩涡的强度。旋度就是旋转最快的方向 梯度的散度 nabla算子和自己做内积，于是会得到一个数量场，意义为求梯度的散度 这个操作为$\\nabla\\cdot \\nabla$，也可以写作$\\nabla^2、\\nabla^T \\nabla$，但为了避免歧义，我们引入了一个新的符号，拉普拉斯算子 $$ \\Delta=\\nabla \\cdot\\nabla $$","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"},{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"复变函数","slug":"math/复变函数","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.628Z","comments":true,"path":"math/复变函数/","link":"","permalink":"https://reubensun.com/math/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/","excerpt":"","text":"复变函数 复变函数 复数 复数可以表示为实数和纯虚数的和 代数式： $$ z=x+\\mathrm{i}y $$ x：实部，记为Re z y：虚部，记为Im z 复平面： 极坐标下 $$ \\begin{cases} \\rho=\\sqrt{x^2+y^2} \\ \\varphi=\\arctan (y/x) \\end{cases} $$ $$ \\begin{cases} x=\\rho \\cos \\varphi \\ y=\\rho \\sin \\varphi \\end{cases} $$ 于是复数可以表示为三角式 $$ z=\\rho (\\cos \\varphi+ \\mathrm{i}\\sin \\varphi )=\\rho e^{\\mathrm{i}\\varphi} $$ $\\rho$：模，记为$|z|$ $\\varphi$：辐角，记为Arg z 复数的辐角有无穷多个，彼此间差$2k\\pi$，于是我们约定在$[0,2\\pi)$的辐角为主辐角 复数零的辐角没有意义 复数的运算 加减（满足交换律、结合律） $$ z_1\\pm z_2=(x_1 \\pm x_2)+\\mathrm{i}(y_1\\pm y_2) $$ 乘（满足交换律、结合律、分配律） $$ z_1z_2=(x_1x_2-y_1y_2)+\\mathrm{i}(x_1y_2-x_2y_1) $$ $$ z_1z_2=\\rho_1 \\rho_2 e^{\\mathrm{i}(\\varphi_1+\\varphi_2)} $$ 除（是乘的逆运算） $$ \\frac{z_1}{z_2}=\\frac{x_1x_2+y_1y_2}{x_2^2+y_2^2}+\\mathrm{i}\\frac{x_2y_1+x_1y_2}{x_2^2+y_2^2} $$ $$ \\frac{z_1}{z_2}=\\frac{\\rho_1}{\\rho_2} e^{\\mathrm{i}(\\varphi_1-\\varphi_2)} $$ n次幂 $$ z^n=\\rho^n e^{\\mathrm{i}n\\varphi} $$ n次根式 $$ \\sqrt[n]{z}=\\sqrt[n]{\\rho}\\ e^{\\mathrm{i}\\frac{\\varphi}{n}} $$ 复变函数 $$ \\omega=f(z) $$ z为$\\omega$的宗量，$z\\in E$ 区域 在解析函数论中，函数的定义域不是一般的点集，而是满足一定条件的点击，称为区域，用B表示 邻域：以复数$z_0$为圆心，画一个半径为任意小正实数的圆，圆内所有点被称为$z_0$的邻域 内点：若某点及其邻域都属于点集E，那么该点是点集E的内点 外点：若某点及其邻域都不属于点集E，那么该点是点集E的外点 边界点：若某点及其邻域既有属于点集E的点，也有不属于的点，那么该点是点集E的边界点 边界线：全体边界点构成边界线 区域是满足以下两条件的点集 全由内点组成 具有连通性，点集内任意两点都联通，且路径上的点都在该点集 闭区域：区域+边境线组成的点集 连续 $$ 当z\\rightarrow z_0时，f(z)\\rightarrow f(z_0) $$ 导数 实变数$\\Delta x$只能沿着实轴趋近0，但复变数$\\Delta z$可以沿着复平面上任意一曲线逼近0 若极限 $$ \\lim _{\\Delta z \\rightarrow 0}\\frac{f(z+\\Delta z)-f(z)}{\\Delta z} $$ 存在，且与$\\Delta z \\rightarrow 0$的方式无关，则称函数$\\omega=f(z)$在$z$点可导（也称单演），这个极限被称为函数在该点的导数（也叫微商） 若$\\Delta z$沿着平行于实轴方向逼近0，$\\Delta y \\equiv 0,\\Delta z=\\Delta x \\rightarrow 0$ $$ \\lim _{\\Delta z \\rightarrow 0}\\frac{\\Delta\\omega}{\\Delta z}=\\frac{\\partial v}{\\partial x}+\\mathrm{i}\\frac{\\partial u}{\\partial x} $$ 若$\\Delta z$沿着平行于虚轴方向逼近0，$\\Delta x \\equiv 0,\\Delta z=\\mathrm{i}\\Delta y \\rightarrow 0$ $$ \\lim _{\\Delta z \\rightarrow 0}\\frac{\\Delta\\omega}{\\Delta z}=\\frac{\\partial v}{\\partial y}-\\mathrm{i}\\frac{\\partial u}{\\partial y} $$ 要想让在该点可导，这两个极限必须同时存在且相等，于是 $$ \\begin{cases} \\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\ \\frac{\\partial v}{\\partial x}=-\\frac{\\partial u}{\\partial y} \\end{cases} $$ 这个方程被称为柯西-黎曼方程，或者柯西-黎曼条件（C-R条件），这个方程是复变函数可导的必要条件 充要条件为：函数的偏导存在且连续，且满足C-R条件 解析函数 若函数$f(z)$在点$z_0$及其邻域上处处可导，则称$f(z)$在$z_0$点解析 若$f(z)$在区域B上处处解析，那么称$f(z)$是区域B上的解析函数 解析函数是一类具有特殊性质的复变函数 正交性 若函数$f(z)=u+\\mathrm{i}v$在区域B上解析，则 $$ u(x,y)=C_1,v(x,y)=C_2 $$ 是B上的两组正交曲线族，即梯度$\\nabla u$（其直角坐标分量为$\\frac{\\partial u}{\\partial x}$和$\\frac{\\partial u}{\\partial y}$）与梯度$\\nabla v$（其直角坐标分量为$\\frac{\\partial v}{\\partial x}$和$\\frac{\\partial v}{\\partial y}$）正交 调和函数 若函数$f(z)=u+\\mathrm{i}v$在区域B上解析，则$u,v$均为B上的调和函数 若函数$H(x,y)$存在二阶连续偏导数，且满足拉普拉斯方程$\\nabla^2H=0$，则该函数为调和函数 应用 给定一个二元的调和函数，将其看作某个解析函数的实部，利用C-R条件求出对应的虚部，于是就构建了一个解析函数 曲线积分法 凑全微分显式法 不定积分法 多值函数 根式函数、对数函数就是一种多值函数 黎曼面 傅里叶变换 傅里叶级数 我们已经学过，周期函数可以唯一展开为以三角函数为基本函数族的级数 这些三角函数满足任意两个函数的乘积在一个周期内的积分为0，即正交性 利用三角函数的正交性，我们求出展开系数，这个系数被称为傅里叶系数 这个三角函数族是完备的 完备的充要条件：任意一平方可积函数的傅里叶级数均值收敛于它本身 傅里叶级数收敛定理 若一周期函数$f(x)$满足狄里希利条件，则函数的傅里叶级数收敛（也就是函数可以用傅里叶级数表示），且收敛值为 当$x$是$f(x)$的连续点时，级数收敛于$f(x)$ 当$x$是$f(x)$的间断点时，级数收敛于$\\frac{1}{2}[f(x-0)+f(x+0)]$ 傅里叶级数的复数表示 $$ \\sum^{\\infty}_{n=-\\infty}c_ne^{\\mathrm{i}\\frac{n\\pi x}{l}} $$ $$ c_n=\\frac{1}{2l}\\int^l_{-l}f(x)e^{-\\mathrm{i}\\frac{n\\pi x}{l}}\\mathrm{d}x $$ 傅里叶积分 一般来说非周期函数不能展开为傅里叶级数，但是如果我们将这个函数视为周期趋近于无穷的函数 $$ f(x)=\\int_0^{\\infty}A(\\omega)\\cos \\omega \\mathrm{d}\\omega+\\int_0^{\\infty}B(\\omega)\\sin \\omega \\mathrm{d}\\omega $$ 其中 $$ A(\\omega)=\\frac{1}{\\pi}\\int^{\\infty}_{-\\infty}f(\\xi)\\cos \\omega\\xi\\mathrm{d}\\xi $$ $$ B(\\omega)=\\frac{1}{\\pi}\\int^{\\infty}_{-\\infty}f(\\xi)\\sin \\omega\\xi\\mathrm{d}\\xi $$ 上面的公式是傅里叶积分，这两个参数函数称为傅里叶变换式 傅里叶积分定理 若函数$f(x)$在区间$(-\\infty,\\infty)$满足 $f(x)$在任意一有限区间内满足狄里希利条件 在$(-\\infty,\\infty)$绝对可积（即$\\int^{\\infty}_{-\\infty}|f(x)|\\mathrm{d}x$收敛） 则$f(x)$可以用傅里叶积分表示，且积分值为$\\frac{1}{2}[f(x-0)+f(x+0)]$ 傅里叶积分的复数表示 $$ f(x)=\\int^{\\infty}{-\\infty}F(\\omega)e^{\\mathrm{i}\\omega x}\\mathrm{d}\\omega =\\frac{1}{\\sqrt{2\\pi}}\\int^{\\infty}{-\\infty}F(\\omega)e^{\\mathrm{i}\\omega x}\\mathrm{d}\\omega $$ $$ F(\\omega)= \\begin{cases} \\frac{1}{2}[A(\\omega)-\\mathrm{i}B(\\omega)] &amp; (\\omega\\ge 0) \\ \\frac{1}{2}[A(|\\omega|)+\\mathrm{i}B(|\\omega|)] &amp; (\\omega&lt; 0) \\end{cases} $$ $$ F(\\omega)=\\frac{1}{\\sqrt{2\\pi}}\\int^{\\infty}_{-\\infty}f(x)[e^{\\mathrm{i}\\omega x}]^{*}\\mathrm{d}\\omega $$ 这里的$[]^*$是复数的共轭的意思，实际上就是直接给虚部加一个符号 我们称$f(x)$为原函数，$F(\\omega)$为像函数 例题 求矩阵脉冲函数$f(t)=h \\ rect (t/2T)$的傅里叶变换 $$ \\mathscr F[h \\ rect (t/2T)] =\\frac{1}{\\sqrt{2\\pi}}\\int^{\\infty}{-\\infty}h \\ rect (t/2T)e^{-\\mathrm{i}\\omega t}\\mathrm{d}t \\ =\\frac{h}{2\\pi}\\int^{T}{-T}e^{-\\mathrm{i}\\omega t}\\mathrm{d}t \\ =-\\frac{h}{2\\pi \\mathrm{i}\\omega}e^{-\\mathrm{i}\\omega t}|^{T}_{-T} \\ =\\frac{h}{\\pi}\\frac{\\sin \\omega T}{\\omega} $$ 傅里叶变化的基本性质 导数定理 $$ \\mathscr F[f’(x)]=\\mathrm{i}\\omega F(\\omega) $$ 积分定理 $$ \\mathscr F[\\int^{(x)}f(\\xi)\\mathrm{d}\\xi]=\\frac{1}{\\mathrm{i}\\omega} F(\\omega) $$ 相似性定理 $$ \\mathscr F[f(ax)]=\\frac{1}{a} F(\\frac{\\omega}{a}) $$ 延迟定理 $$ \\mathscr F[f(x-x_0)]=e^{-\\mathrm{i}\\omega x_0} F(\\omega) $$ 位移定理 $$ \\mathscr F[e^{\\mathrm{i}\\omega_0 x} f(x)]=f(\\omega-\\omega_0) $$ 卷积定理 $$ \\mathscr F[f_1(x)*f_2(x)]=2\\pi F_1(\\omega)F_2(\\omega) $$ 拉普拉斯变换 拉普拉斯变换 傅里叶积分和傅里叶变换存在的条件是原函数在任意一有限区间满足狄里希利条件，且在$(-\\infty,\\infty)$上绝对可积，这实际上是一个相当苛刻的条件，导致很多常见函数都不满足 而拉普拉斯变换是一种条件更宽泛的变换 拉普拉斯变换常用于初始值问题，即知道某个物理量在初始时刻$t=0$的值$f(0)$，求一段时刻后的情况$f(t)$ 我们置$f(t)=0$，构造一个函数$g(t)$，使得 $$ g(t)=e^{-\\sigma t}f(t) $$ 其中$e^{-\\sigma t}$为收敛因子，正实数$\\sigma$取特别大，以保证$g(t)$在$(-\\infty,\\infty)$绝对可积 于是我们对$g(t)$进行傅里叶变换，得到 $$ G(\\omega)=\\frac{1}{2\\pi}\\int^{\\infty}{0}f(t)e^{-(\\sigma +\\mathrm{i}\\omega )t}\\mathrm{d}t $$ 令$p=\\sigma +\\mathrm{i}\\omega$，$G(\\omega)=\\overline{f}(p)/2\\pi$，则 $$ \\mathscr L[f(t)]=\\overline{f}(p)=\\int^{\\infty}{0}f(t)e^{-pt}\\mathrm{d}t $$ 我们称这个积分为拉普拉斯积分，而函数$\\overline{f}(p)$为$f(t)$的拉普拉斯变换函数，这个变化过程称为拉普拉斯变换，$e^{pt}$称为核 变换条件 在$[0,\\infty)$的任意有限区间上，除了有限个第一类间断点外，函数及其导数是处处连续的 存在常数$M&gt;0$，$\\sigma \\ge0$，使得对任意$t\\in [0,\\infty)$有 $$ |f(t)|&lt;Me^{\\sigma t} $$ 其中$\\sigma$的下界称为收敛横标，记为$\\sigma_0$ 在实际应用中，大部分函数都满足这个条件 性质 $\\overline{f}(p)$是$Re p=\\sigma &gt; \\sigma_0$的半平面上的解析函数 当$|p|\\rightarrow \\infty$，且$|Arg p|\\le \\frac{\\pi}{2}-\\varepsilon(\\varepsilon &gt; 0)$，$\\overline{f}(p)$存在且满足 $$ \\lim_{p\\rightarrow \\infty}\\overline{f}(p)=0 $$ 线性定理 导数定理 积分定理 相似性定理 位移定理 延迟定理 卷积定理 拉普拉斯变换的反演 由像函数转化为原函数的步骤称为反演 有理分式反演法 查表法 黎曼-梅林反演公式","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"微积分","slug":"math/微积分","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:05.032Z","comments":true,"path":"math/微积分/","link":"","permalink":"https://reubensun.com/math/%E5%BE%AE%E7%A7%AF%E5%88%86/","excerpt":"","text":"微积分 无穷级数 从有限项之和拓展到无限项之和 一根绳子，日取其半，万世不竭。但无论截取多少次，最后总长应该还是这跟绳子，即 $$ 1=\\frac{1}{2}+\\frac{1}{2^2}+\\frac{1}{2^3}+…+\\frac{1}{2^n}+… $$ 另一个例子 $$ 1+(-1)+1+(-1)+1+(-1)… $$ 等于多少呢？ 到底是 $$ 1+[(-1)+1]+[(-1)+1]…=1+0+0… $$ 还是 $$ (1-1)+(1-1)+…(1-1)+…=0+0+0… $$ 这里出现了矛盾，为此我们建立了无穷级数的概念 常数项级数 常数项无穷级数 给定一个数列${u_n}$，由它构成的表达式 $$ u_1+u_2+…+u_n+… $$ 被称为常数项无穷级数，简称级数，其中$u_n$被称为该级数的通项 该级数的前n项和称为部分和，记为$s_n$ 当n依次取1,2,3…时，部分和构成一个新数列${s_n}$，被称为部分和数列 当n无限增大时，若部分和存在极限，即 $$ \\lim_{n \\rightarrow \\infty}s_n=s $$ 则称该级数收敛，并称极限$s$为该级数的和 若不存在极限，则称该级数发散 讨论级数收敛/发散 部分和公式好求，可以求公式，判断其有无极限 不好求，可以反证 先假设收敛，然后化简公式，最后得出形如$s+x&gt;s$的结论，证否 $$ \\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s $$ 余项 去掉级数A前n项，得到一级数 $$ u_{n+1}+u_{n+2}+…+u_{n+k}+…=\\sum^{\\infty}_{k=n+1}u_k $$ 称该级数为级数A的余项 若级数A收敛，则余项的前m项之和$s_m’$满足 $$ s_m’=s-s_n $$ 一般，我们将n项后余项和记为$r_n$ $$ s=s_n+r_n $$ 性质 级数中去掉/加上有限个项，不改变级数的收敛性 若一级数收敛，则其通项乘以一个常数$k$，仍然收敛，且和为$ks$ 若两级数收敛，则两通项相加或相减，对应的级数仍然收敛，且和为$s+\\sigma$ 若一级数收敛，在其中加任意个括号，仍然收敛 级数收敛的必要条件是通项在无穷大处有极限，且为0 柯西收敛准则 级数收敛的充要条件 正项级数 若级数中各项非负，则称该级数为正项级数 正项级数的部分和必然是递增的 正项级数收敛的充要条件：其部分和数列有上界 比较审敛法 对于两个正项级数A，B，其通项分别为$u_n,v_n$ 自某项起，$u_n\\ge v_n$，若B发散，则A发散（大于发散则发散） 自某项起，$u_n\\le v_n$，若B收敛，则A收敛（小于收敛则收敛） 比较审敛法的极限形式 对于两个正项级数A，B，其通项分别为$u_n,v_n$，若 $$ \\lim_{n \\rightarrow \\infty}\\frac{u_n}{v_n}=\\lambda $$ 有意义（极限存在或者为无穷大） $0&lt;\\lambda&lt;\\infty$：两级数收敛性相同 $lambda=0$：若B收敛，则A收敛（小于收敛则收敛） $\\lambda=\\infty$：若B发散，则A发散（大于发散则发散） 比值审敛法 也称达朗贝尔判别法 对于一正向级数A，其通项为$u_n$，若 $$ \\lim_{n \\rightarrow \\infty}\\frac{u_{n+1}}{u_n}=\\rho $$ 有意义 $\\rho &lt;1$：A收敛 $\\rho &gt;1$：A发散 $\\rho =1$：A可能收敛也可能发散 根值审敛法 也称柯西判别法 对于一正向级数A，其通项为$u_n$，若 $$ \\lim_{n \\rightarrow \\infty}\\sqrt[n]{u_n}=\\rho $$ 有意义 $\\rho &lt;1$：A收敛 $\\rho &gt;1$：A发散 $\\rho =1$：A可能收敛也可能发散 积分审敛法 对于一正向级数A，其通项为$u_n$，若存在$[1, \\infty)$上单调递减的非负连续函数$f(x)$，使得$u_n=f(n)$，则级数A与反常积分$\\int^{\\infty}_1 f(x)\\mathrm{d}x$收敛性相同 反常积分就是积分域包含无穷上/下限，或者被积函数有瑕点的积分 瑕点：函数值区域无穷的点 奇点：函数值未定的点（比如间断点、无定义点） 任意项级数 交错级数 形如 $$ u_1-u_2+u_3-u_4…(-1)^{n-1}u_n+… $$ 或者 $$ -u_1+u_2-u_3+u_4…(-1)^{n}u_n+… $$ 的级数，称为交错级数 其中$u_n &gt; 0$ 交错级数审敛法 若$u_n \\ge u_{n+1}$ ，且$\\lim_{n \\rightarrow \\infty}u_n=0$ 则级数 $\\sum^{\\infty}_{n=1}(-1)^{n-1}u_n$ 收敛 且其和 $s \\le u_1$ ，其余项 $|r_n|\\le u_{n+1}$ 绝对收敛与条件收敛 对于一级数$A=\\sum^{\\infty}_{n=1}u_n$，其各项取绝对值 得到新正项级数$B=\\sum^{\\infty}_{n=1}|u_n|$ 定理：若B收敛，则A收敛（所以这就是我们为什么要研究正项级数） 若B收敛，A必收敛，此时称A为绝对收敛 若B发散，而A却收敛，此时称A为条件收敛 性质 绝对级数的更序级数仍为绝对级数 更序级数：对某级数的项进行重排后得到的新级数 两个绝对级数的柯西乘积仍然绝对收敛，且其和为$s\\times \\sigma$ 柯西乘积：参考向量相乘，$(a_1, a_2)(b_1,b_2)=(a_1b_1,a_2b_2)$ 函数项级数 前面讨论的常数项级数用于表示无穷多个数的和，当其收敛时，其和为一个常数 而函数项级数用于表示无穷多个函数的和 设定义在集合$D\\subseteq \\mathbf{R}$的一系列函数（称为函数列） $$ u_1(x),u_2(x),u_3(x)…u_n(x)… $$ 称 $$ \\sum^{\\infty}_{n=1}u_n(x) $$ 为函数项级数，$u_n(x)$为通项，前n项和称为部分和 极限函数 若对于某个点$x_0 \\in D$，${ u_n(x_0)}$收敛，则称点$x_0$为该函数列的一个收敛点 所有收敛点构成的集合称为收敛域 若${ u_n(x)}$处处收敛（或逐点收敛），那么就形成了一个定义在D上的函数$f(x)$，D上每一个x都有该函数列一个极限值与之相对应，并称函数$f(x)$为该函数列的极限函数 $$ f(x)=\\lim_{n \\rightarrow \\infty}f_n(x) $$ 极限函数与函数项级数 若点$x_0 \\in D$是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的收敛点 若点$x_0 \\in D$不是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的发散点 收敛点的集合称为该级数的收敛域 若级数在D上处处收敛，于是形成了一个定义在D上的和函数$s(x)$ $$ s(x)=\\lim_{n \\rightarrow \\infty}s_n(x) $$ 收敛性 略 幂级数 幂级数是一种特殊的，也是最常用的函数项级数 我们把形如 $$ a_0(x-x_0)^0+a_1(x-x_0)^1+a_2(x-x_0)^2+…a_n(x-x_0)^n+… $$ 的函数项级数称为$x-x_0$的幂级数 其中$x_0$是一个常数，$a_0,a_1,…a_n,…$是幂级数的系数 对任意幂级数总有，当$x=0$时，幂级数收敛，即0是收敛点 阿贝尔定理 若$x=x_0 \\ne 0$且幂级数收敛，则当$|x|&lt;|x_0|$时，幂级数绝对收敛 若$x=x_0 \\ne 0$且幂级数发撒，则当$|x|&gt;|x_0|$时，幂级数发散 收敛半径 幂级数$\\sum^{\\infty}_{n=1}a_nx^n$的收敛域K是以原点为中心的一个区间，在区间内绝对收敛，在区间外发散，区间界可能收敛也可能发散，于是我们称这个收敛域的半径R为收敛半径 对于某个幂级数，若$a_n \\ne 0$，且 $$ \\lim_{n \\rightarrow \\infty}|\\frac{a_{n+1}}{a_n}|=\\rho $$ 若$0&lt;\\rho &lt;\\infty$，收敛半径$R=\\frac{1}{\\rho}$ 若$\\rho =0$，收敛半径$R=\\infty$ 若$\\rho =\\infty$，收敛半径$R=0$ 运算 对于两个幂级数A、B，他们的收敛半径分别为$R_1$、$R_2$ $R=\\min(R_1, R_2)$，则在$(-R, R)$上 幂级数乘以一个常数仍然收敛 A和B的线性组合仍然收敛 A和B的乘积仍然收敛 和函数的性质 在收敛区间内，和函数$s(x)$满足 连续性 可微性 $$ s’(x)=\\sum^{\\infty}_{n=1}na_nx^{n-1} $$ 可积性 $$ \\int^x_0s(t)\\mathrm{d}t=\\sum^{\\infty}_{n=0}\\frac{a_n}{n+1}x^{n+1} $$ 函数展开为幂级数 在前面几节，我们讨论了函数项级数（尤其是幂级数）在收敛区间内可以得到一个和函数 那么，能不能给定一个（和）函数，将其展开为幂级数呢？ 幂级数可以视为多项式的推广，那么我们能不能用多项式来逼近（和）函数呢？ 泰勒级数 若$f(x)$在区间$(x_0-R, x_0+R)$能展开成幂级数，$f(x)$在$x=x_0$处有任意阶导数，那么幂级数有且仅有一个展开形式，且幂级数的系数为 $$ a_n=\\frac{1}{n!}f^{(n)}(x_0) $$ n取0，1，2… 我们称这个幂级数为函数$f(x)$在$x_0$处的泰勒级数，记作 $$ f(x)\\sim f(x_0)+\\frac{f’(x_0)}{1!}(x-x_0)+\\frac{f’'(x_0)}{2!}(x-x_0)^2+…+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+… $$ 展开条件 若$f(x)$在区间$(x_0-R, x_0+R)$处有任意阶导数，那么$f(x)$在该区间内能展开称泰勒级数的充要条件为 $$ \\lim _{n \\rightarrow \\infty}R_n(x)=0 $$ $R_n(x)$：n以后的余项 推论 若存在一个常数$M&gt;0$，使得任意x属于区间$(x_0-R, x_0+R)$，都有当n趋近于无穷时，余项的绝对值小于M，则函数可以在该区间展开成泰勒级数 麦克劳林展开式 泰勒公式的特例，$x_0=0$ $$ f(x)=f(0)+\\frac{f’(0)}{1!}x+\\frac{f’'(0)}{2!}x^2+…++\\frac{f^{(n)}(0)}{n!}x^n+… $$ 经典展开 $$ e^x=1+\\frac{x}{1!}+\\frac{x^2}{2!}+…+\\frac{x^n}{n!}+… $$ $$ \\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-…+(-1)^{n-1}\\frac{x^{2n-1}}{(2n-1)!}+… $$ 傅里叶级数 使用三角函数来拟合一个已知函数 三角级数 一般来说，形如 $$ \\frac{a_0}{2}+\\sum^{\\infty}_{n=1}(a_n\\cos nx+b_n \\sin nx) $$ 的级数被称为三角级数 正交性 函数系 $$ {1,\\cos x, \\sin x, \\cos 2x, \\sin 2x, …,\\cos nx, \\sin nx,…} $$ 被称为基本三角函数系 正交性：该函数系任意两个不同的函数的乘积，在区间$[-\\pi,\\pi]$上的积分等于0 三角级数的系数 $$ a_n=\\frac{1}{\\pi}\\int^{\\pi}_{-\\pi}f(x)\\cos nx \\ \\mathrm{d}x $$ $$ b_n=\\frac{1}{\\pi}\\int^{\\pi}_{-\\pi}f(x)\\sin nx \\ \\mathrm{d}x $$ 这两个式子被称为欧拉-傅里叶公式，由这个公式确定的系数被称为傅里叶系数 对任意在区间$[-\\pi,\\pi]$上可积函数$f(x)$都可以求出其傅里叶级数，但这个级数不一定收敛，即使收敛也不一定收敛于$f(x)$ 于是我们需要知道什么时候$f(x)$可以被展开成收敛在$f(x)$的傅里叶级数 收敛定理（狄里希利充分条件） 对于一个周期为$2\\pi$的周期函数，如果它满足狄里希利条件： 在一个周期内连续，或者只有有限个第一类间断点 第一类间断点：左右极限都存在，但该点函数值或该点无定义 在一个周期内之多有有限个严格极值点 则$f(x)$的傅里叶级数收敛，且 当$x$是$f(x)$的连续点时，级数收敛于$f(x)$ 当$x$是$f(x)$的间断点时，级数收敛于$\\frac{1}{2}[f(x-0)+f(x+0)]$ 其他概念 周期延拓 正弦级数（奇函数） 余弦级数（偶函数） 奇延拓 偶延拓 复数表示 欧拉公式 $$ \\sin z=\\frac{e^{iz}-e^{-iz}}{2i} $$ $$ \\cos z=\\frac{e^{iz}+e^{-iz}}{2} $$ 记 $$ \\frac{a_0}{2}=c_0 $$ $$ \\frac{a_n-ib_n}{2}=c_n $$ $$ \\frac{a_n+ib_n}{2}=c_{-n} $$ 则傅里叶级数简化为 $$ \\sum^{\\infty}_{n=-\\infty}c_ne^{i\\frac{n\\pi x}{l}} $$ $$ c_n=\\frac{1}{2l}\\int^l_{-l}f(x)e^{-i\\frac{n\\pi x}{l}}\\mathrm{d}x $$ 多元函数 方向导数 设点$P_0(x_0,y_0)\\in \\mathbf{R}^2$，$l$是平面上的一非零向量，其单位向量为$e_i=\\cos \\alpha \\mathbf {i}+\\cos \\beta \\mathbf {j}$，函数$z=f(x,y)$在点$P_0$的某邻域内有定义，$P_0$为直线L上的一个定点（直线L平行于向量$l$），若极限 $$ \\lim_{t\\rightarrow 0}\\frac{f(x_0+t\\cos \\alpha,y_0+t\\cos \\beta)-f(x_0,y_0)}{t} $$ 存在，则称此极限为函数$z=f(x,y)$在直线L上点$P_0$处，延方向$l$的方向导数 梯度 方向导数刻画了函数在点$P_0$处沿着方向$l$的变化快慢程度，我们希望知道在该点，哪一个方向变化最快，于是引入了梯度 设函数$z=f(x,y)$在点$P_0(x_0,y_0)$处可偏导，则称向量 $$ f_x(x_0,y_0)\\mathbf{i}+f_y(x_0, y_0)\\mathbf{j} $$ 为函数$z=f(x,y)$在点$P_0(x_0,y_0)$处的梯度，记作$\\mathbf{grad}f(x_0,y_0)$，或$\\nabla f(x_0,y_0)$ 当方向为$(\\frac{\\partial z}{\\partial x}|_P,\\frac{\\partial z}{\\partial y}|_P)$时，变化速度最快 物理意义 梯度方向=法线方向","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"概率论","slug":"math/概率论","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:05.032Z","comments":true,"path":"math/概率论/","link":"","permalink":"https://reubensun.com/math/%E6%A6%82%E7%8E%87%E8%AE%BA/","excerpt":"","text":"概率论 一：随机事件与概率 事件 事件的概念 样本空间$\\Omega$ 其单元素子集：基本事件 其最大子集：必然事件 最小子集：即空集$\\empty$，不可能事件 事件域$F$ 事件的关系 包含 $A\\subset B$：A被包含在B、B包含A、A发生时B一定发生 相等 $A=B$：A等于B，两事件是同一个集合、描述的是同一件事 互不相容 A和B不能同时发生 事件的运算 基本运算 并 $A \\cup B$：A和B至少有一个会发生 交 $A \\cap B$：A和B同时发生 差 $A-B$：A发生，但B不发生 对立 $\\overline{A}$：即$\\Omega - A$ 运算性质 交换律 结合律 分配律 对偶律（德摩根公式） $\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}$：并的对立等于对立的交 $\\overline{A \\cap B} = \\overline{A} \\cup \\overline{B}$：交的对立等于对立的并 概率 公理化表示 设$\\Omega$为一个样本空间，$F$为$\\Omega$的某些子集组成的一个事件域，对任意事件$A \\in F$，有一个定义在$F$上的实值函数$P(A)$，满足： 非负 $P(A) \\ge 0$ 正则 $P(\\Omega) = 1$ 可列可加 若$A_1,A_2,A_3,…A_n$互不相容，则和的概率等于概率的和 则称$P(A)$为事件$A$的概率，$(\\Omega, F, P)$为概率空间 排列 n中取r，考虑顺序 $$ P^r_n = \\frac{n!}{(n-r)!} $$ 全排列 $$ P_n = n! $$ 注意，这里的P是方案数的意思 组合 n中取r，不考虑顺序 $$ C^r_n=\\binom{n}{r}=\\binom{n}{n-r}=\\frac{n!}{r!(n-r)!} $$ 并规定 $$ C^0_n=1 $$ 频率 $n(A)$：频数，n次重复实验中事件A出现的次数 $f_n(A)$：频率=频数/n 我们认为频率的稳定值就是概率 古典概率 通过样本数进行估计 $$ P(A)=\\frac{事件A所含样本数}{\\Omega 所含样本总数} $$ 几何概率 通过面积、体积进行估计 $$ P(A)=\\frac{S_A}{S_{\\Omega}} $$ 蒙特卡洛方法 概率的性质 $P(\\Omega)=1$ $P(\\empty)=0$ 有限可加性：和的概率等于概率之和 $P(\\overline{A}) = 1-P(A)$ 若$A\\sub B$ $P(B-A) = P(B)-P(A) =P(B) - P(AB)$ $P(B) \\ge P(A)$ $P(A\\cup B)=P(A)+P(B)-P(AB)$ 条件概率 条件概率：在B发生的情况下，A发生的概率 $$ P(A|B) = \\frac{P(AB)}{P(B)} $$ 乘法公式 $$ P(A_1…A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1…A_n-1) $$ 全概率公式 $$ P(A) = \\sum^{n}_{i=1}P(B_i)P(A|B_i) $$ $$ P(A)=P(B)P(A|B)+P(\\overline{B})P(A|\\overline{B}) $$ 贝叶斯公式（用于计算后验概率） $$ P(B|A)=\\frac{P(B)P(A|B)}{P(B)P(A|B)+P(\\overline{B})P(A|\\overline{B})} $$ 独立性 若$P(AB)=P(A)P(B)$，则称AB两事件相互独立 独立重复试验 二：随机变量及其分布 随机变量 定义在样本空间$\\Omega$上的实值函数$X=X(\\omega)$称为随机变量，$\\omega$是样本点 当$\\omega$变化时，$X$会变化，这东西更像一个函数，不要被“变量”给迷惑了 随机事件 随机事件是随机变量的集合 若$B$是某些实数组成的集合，$B\\sub R$，则${X \\in B}$表示随机事件： $$ {\\omega:X(\\omega) \\in B} \\sub \\Omega $$ 特别的，${X \\in B}$可以写成类似${X \\le a }$、${ a &lt; X &lt; b}$ 分布列 $$ p(x_i) = P(X=x_i) $$ X 0 1 2 3 P 1/2 1/4 1/8 1/8 分布函数 设$X$是一个连续随机变量，对于任意实数$x$，称 $$ F(x) = P(X \\le x) $$ 为随机变量$X$的分布函数，并称$X$服从$F(x)$，记为$X \\sim F(x) $ $F(x)$定义域$(-\\infty， \\infty)$，值域$[0, 1]$ $F(x)$满足 单调非减 有界 右连续，即$F(x_0+0)=F(x_0)$ 概率密度函数 设随机变量$X$的分布函数为$F(x)$，如果存在实数轴上一个非负可积函数$p(x)$，使得对任意实数$x$有 $$ F(x) = \\int^x_{-\\infty}p(t)\\mathrm{d}t $$ 则称$p(x)$为$X$的概率密度函数 在$F(x)$可导的点上，$F’(x)=p(x)$ 非负性 正则性 期望 离散 对于离散随机变量$X$，其分布列为$p(x_i), i=1,2,3…n,…$ 若级数不收敛，即 $$ \\sum^n_{i=1}|x_i|p(x_i) &lt; \\infty $$ 则称 $$ E(X) = \\sum^{\\infty}_{i = 1}x_i p(x_i) $$ 为随机变量$X$、或者该分布的数学期望 连续 设连续随机变量$X$的概率密度函数为$p(x)$ 若 $$ \\int^{\\infty}{-\\infty}|x|p(x)\\mathrm{d}x &lt; \\infty $$ 则称 $$ E(X) = \\int^{\\infty}{-\\infty}xp(x)\\mathrm{d}x $$ 为$X$的数学期望 数学期望的物理解释是重心 性质 $$ E[g(X)]=\\sum_{i}g(x_i)p(x_i) $$ $$ E©=c $$ $$ E(aX)=aE(X) $$ $$ E[g_1(X) + g_2(X)]=E[g_1(X)]+E[g_2(X)] $$ 方差 $$ Var(X)=E(X-E(X))^2 $$ 标准差 $$ \\sigma(X) = \\sqrt{Var(X)} $$ 性质 $$ Var(X)=E(X^2)-[E(X)]^2 $$ $$ Var© = 0 $$ $$ Var(aX+b)=a^2Var(X) $$ 切比雪夫不等式 出现大偏差的概率的上下界，与方差呈正比 $$ P(|X-E(X)| \\ge \\epsilon) \\le \\frac{Var(X)}{\\epsilon^2} $$ 若方差为0，则 $$ P(X=E(X))=1 $$ 常见分布 离散 二项分布 两点分布 泊松分布 超几何分布 连续 正态分布 均匀分布 指数分布 伽马分布 贝塔分布 三：多维随机变量及其分布 多维随机变量 如果$X_1(\\omega),X_2(\\omega),X_3(\\omega)…X_n(\\omega)$是定义在同一样本空间$\\Omega = {\\omega}$上的n个随机变量，则称 $$ X(\\omega)=(X_1(\\omega),X_2(\\omega),X_3(\\omega)…X_n(\\omega)) $$ 为N维随机变量 必须为同一样本空间 N个小孩中，身高是一个随机变量，体重也是一个随机变量，（身高，体重）是一个二维随机变量 联合分布函数 $$ F(x_1, x_2,…,x_n)=P(X_1\\le x_1, X_2 \\le x_2, …, X_n \\le x_n) $$ 为n维随机变量$(X_1, X_2, …,X_n)$的联合分布函数 独立性 若 $$ F(x_1, x_2,…,x_n)=\\prod^n_{i=1}F_i(x_i) $$ 则称$X_1, X_2, …,X_n$相互独立（充要条件） 简单说，独立的随机变量，联合概率密度可以直接相乘 期望 $$ E(Z)=\\sum_i \\sum_j g(x_i, y_j)P(X=x_i, Y=y_j) $$ $$ E(Z)=\\int^{\\infty}{-\\infty} \\int^{\\infty}{-\\infty} g(x,y)p(x,y)\\mathrm{d}x\\mathrm{d}y $$ 重期望公式 $$ E(X)=E(E(X|Y)) $$ 四：大数定律与中心极限定理 收敛性 依概率收敛：大数定律 按分布收敛：中心极限定理 依概率收敛 有的随机变量X的概率非常难求，如果可以找到一个简单的随机变量Y的分布来拟合X，可以大幅简化计算 设${X_n}$为以随机变量序列，$X$为一随机变量，对任意$\\varepsilon &gt; 0$，有 $$ P(|X_n - X| \\ge \\varepsilon)\\rightarrow 0 \\ \\ (n\\rightarrow \\infty) $$ 则称序列${X_n}$依概率收敛于X，记作$X_n \\xrightarrow{P} X$ 简单来说，就是概率集中在某个X处 弱收敛 若 $$ \\lim_{n \\rightarrow \\infty}F_n(x)=F(x) $$ 则称${F_n(x)}$弱收敛于$F(x)$，记作$F_n(x) \\xrightarrow{W} F(x)$ 也称序列${X_n}$按分布收敛于X，记作$X_n \\xrightarrow{L} X$ 依概率收敛比按分布收敛，收敛性更强 特征函数 设X是一个随机变量，称 $$ \\varphi(t)=E(e^{itX}) $$ 为X的特征函数 任一随机变量的特征函数总是存在 大数定理 伯努利大数定理 $$ \\lim_{n \\rightarrow \\infty}P(|\\frac{S_n}{n} - p| &lt; \\varepsilon)=1 $$ 意义为：随着n次数的增多，频率会越来越接近概率（随机变量序列的算数平均 依概率收敛到 其均值的算数平均） 中心极限定理 在某些情况下，随机变量和 的分布函数收敛于正态分布","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"球函数","slug":"math/球函数","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.629Z","comments":true,"path":"math/球函数/","link":"","permalink":"https://reubensun.com/math/%E7%90%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"球函数 三大偏微分方程 拉普拉斯方程（椭圆） 热方程（抛物线） 波方程（双曲线） 常微分方程 含有未知函数的导数（含高阶导数）或微分的等式，称为微分方程 若未知函数是一元函数，则该函数为常微分方程 若导数的阶数为1，那么称为一阶微分方程 球坐标系 讨论常微分方程时，边界是记为重要的，而当边界是球形时，球坐标系会更好用 直角坐标系上点$P(x,y,z)$，也可以用三个有次序的数$(r,\\theta,\\varphi)$表示 $$ \\begin{cases} x=r \\sin \\theta \\cos \\varphi \\ y=r \\sin \\theta \\sin \\varphi \\ z=r\\cos \\theta \\end{cases} $$ $$ \\begin{cases} r=\\sqrt{x^2+y^2+z^2} \\ \\theta=\\arccos \\frac{z}{r} \\ \\varphi=\\arctan \\frac{y}{x} \\end{cases} $$ 拉普拉斯方程 拉普拉斯算符 多元函数用梯度表示不同方向函数值变化的速度，拉普拉斯算符$\\nabla$就是对多元函数求梯度 对梯度再次做拉普拉斯算符$\\nabla ^2$，就是求梯度的散度 在直角坐标系下，二阶拉普拉斯算符为 $$ \\nabla^2=\\frac{\\partial ^2}{\\partial x^2}+\\frac{\\partial ^2}{\\partial y^2}+\\frac{\\partial ^2}{\\partial z^2} $$ 在球坐标下，二阶拉普拉斯算法为（将xyz带入，化简得到） $$ \\nabla^2=\\frac{1}{r^2}\\frac{\\partial}{\\partial r}(r^2\\frac{\\partial}{\\partial r}) +\\frac{1}{r^2\\sin \\theta }\\frac{\\partial}{\\partial \\theta}(\\sin \\theta \\frac{\\partial}{\\partial \\theta}) +\\frac{1}{r^2\\sin^2 \\theta }\\frac{\\partial^2}{\\partial \\varphi^2} $$ 拉普拉斯方程 拉普拉斯方程$\\nabla^2 u=0$，表示的物理含义是：在各个方向上（比如二维直角坐标系，就是x和y方向）加速度合为0 这意味着什么？一个不与外界进行能量交换的系统，其拉普拉斯方程为0 一个不受外力的系统，其整体加速度为0 一个不与外界传热的系统，其整体能量传播为0 一个理想的简谐振动 闭合磁场、电场 我们称拉普拉斯方程为0的函数叫做Harmonic 球坐标系下的拉普拉斯方程 函数$u(r,\\theta,\\varphi)$的拉普拉斯方程为 $$ \\nabla^2u=\\frac{1}{r^2}\\frac{\\partial}{\\partial r}(r^2\\frac{\\partial u}{\\partial r}) +\\frac{1}{r^2\\sin \\theta }\\frac{\\partial}{\\partial \\theta}(\\sin \\theta \\frac{\\partial u}{\\partial \\theta}) +\\frac{1}{r^2\\sin^2 \\theta }\\frac{\\partial^2 u}{\\partial \\varphi^2}=0 $$ 我们将距离和方向分离，得到 $$ u(r,\\theta,\\varphi)=R®Y(\\theta,\\varphi) $$ $R®$表示距离 $Y(\\theta,\\varphi)$表示方向，被称为球函数 带入可得 $$ \\frac{Y}{r^2}\\frac{\\mathrm{d}}{\\mathrm{d} r}(r^2\\frac{\\mathrm{d} R}{\\mathrm{d} r}) +\\frac{R}{r^2\\sin \\theta }\\frac{\\partial}{\\partial \\theta}(\\sin \\theta \\frac{\\partial Y}{\\partial \\theta}) +\\frac{R}{r^2\\sin^2 \\theta }\\frac{\\partial^2 Y}{\\partial \\varphi^2}=0 $$ 移项、化简可得 $$ \\frac{1}{R}\\frac{\\mathrm{d}}{\\mathrm{d} r}(r^2\\frac{\\mathrm{d} R}{\\mathrm{d} r}) =-\\frac{1}{\\sin \\theta Y}\\frac{\\partial}{\\partial \\theta}(\\sin \\theta \\frac{\\partial Y}{\\partial \\theta}) -\\frac{1}{Y}\\frac{1}{\\sin^2 \\theta }\\frac{\\partial^2 Y}{\\partial \\varphi^2} $$ 我们发现，这个方程左边是与$R$有关的函数，右边是与$\\theta,\\varphi$有关的函数，显然两者不可能相等，除非他们同时等于一个常数 我们令这个常数为$l(l+1)$，于是得到两个方程 $$ \\frac{\\mathrm{d}}{\\mathrm{d} r}(r^2\\frac{\\mathrm{d} R}{\\mathrm{d} r})-l(l+1)R=0 $$ $$ \\frac{1}{\\sin \\theta }\\frac{\\partial}{\\partial \\theta}(\\sin \\theta \\frac{\\partial Y}{\\partial \\theta}) +\\frac{1}{\\sin^2 \\theta }\\frac{\\partial^2 Y}{\\partial \\varphi^2} +l(l+1)Y=0 $$ 第二个方程叫做球函数方程 如果我们进一步分离变量，令 $$ Y(\\theta,\\varphi)=\\Theta(\\theta)\\Phi(\\varphi) $$ 带入球函数方程，化简得到两个常微分方程 $$ \\Phi’'+\\lambda \\Phi=0 $$ $$ \\sin \\theta \\frac{\\mathrm{d}}{\\mathrm{d} \\theta}(\\sin \\theta \\frac{\\mathrm{d \\Theta}}{\\mathrm{d} \\theta})+[l(l+1)\\sin^2\\theta-\\lambda]\\Theta=0 $$ 连带勒让德方程 上一步我们得到了两个常微分方程，第一个方程和自然周期条件构成本征值问题，在经过很多步的推导化简（感觉这些内容对我来说有些超纲），可以把第二个式子改写为 $$ (1-x^2)\\frac{\\mathrm{d}^2\\Theta}{\\mathrm{d}x^2}-2x\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}x}+[l(l+1)-\\frac{m^2}{1-x^2}]\\Theta=0 $$ 这个式子被称为$l$阶连带勒让德方程 这个式子的解，即函数$\\Theta$的表达式为连带勒让德函数 级数解法 用球坐标系对拉普拉斯方程进行分离变数，得到了连带勒让德方程等特殊的函数方程，这些方程大多都是线性二阶常微分方程，很难用常规办法解，但可以用级数解法解出 常点与奇点 对于一个复变函数的线性二阶常微分方程 $$ \\frac{\\mathrm{d}^2w}{\\mathrm{d}z^2}+p(z)\\frac{\\mathrm{d}w}{\\mathrm{d}z}+q(z)w=0 $$ 若系数函数$p(z)$、$q(z)$在点$z_0$的邻域中是解析的，则点$z_0$叫做该方程的常点，若点$z_0$是奇点，则点$z_0$叫做该方程的奇点","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"线性代数","slug":"math/线性代数","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.630Z","comments":true,"path":"math/线性代数/","link":"","permalink":"https://reubensun.com/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","excerpt":"","text":"线性代数 一：线性方程组 概念 线性方程 线性方程组 系数 解：一组能让方程左右相等的数 解集：方程组的所有解的集合 等价：若两个线性方程组拥有相同解集，则两者等价 相容：方程组有一个或无穷多个解 不相容：方程组无解 矩阵 方程组 $$ \\begin{gathered} x_1-2x_2+x_3=0 \\\\ 2x_2-8x_3=8 \\\\ 5x_1-5x_3=10 \\end{gathered} $$ 的系数矩阵为 $$ \\left[ \\begin{matrix}1&amp;-2&amp;1\\\\ 0&amp;2&amp;-8\\\\ 5&amp;0&amp;-5\\end{matrix} \\right] $$ 增广矩阵为 $$ \\left[ \\begin{matrix}1&amp;-2&amp;1&amp;0\\\\ 0&amp;2&amp;-8&amp;8\\\\ 5&amp;0&amp;-5&amp;10\\end{matrix} \\right] $$ 这个增广矩阵，3行4列，是一个3x4的矩阵 我们对增广矩阵进行多次矩阵运算，于是得到 $$ \\left[ \\begin{matrix}1&amp;0&amp;0&amp;1\\\\ 0&amp;1&amp;0&amp;0\\\\ 0&amp;0&amp;1&amp;-1\\end{matrix} \\right] $$ 于是原方程有且仅有一个解$(1,0,-1)$ 初等行变换 也就是行简化 倍加：a=a+nb，把某行加上某一行的倍数 对换：swap(a,b)，把某两行对换 倍乘：a *= n (n!=0)，把某行所有元素乘以一个非零的数 阶梯矩阵 形如 $$ \\left[ \\begin{matrix}x&amp;&amp;&amp;\\\\ 0&amp;x&amp;&amp;\\\\ 0&amp;0&amp;x&amp;\\end{matrix} \\right] $$ 的矩阵，被称为阶梯形 $x$为先导元素，非零 若先导元素均为1，而且该列只有先导元素非零，则矩阵被称为简化阶梯形 $x$所在的位置被称为主元位置，拥有主元的列被称为主元列 $*$取任意值 行简化 任何非零矩阵都可以行简化为阶梯形矩阵 简化阶梯形具有唯一性 线性方程的解 对增广矩阵运用行简化，得到一个简化阶梯形 $$ \\left[ \\begin{matrix}1&amp;0&amp;-5&amp;1\\\\ 0&amp;1&amp;1&amp;4\\\\ 0&amp;0&amp;0&amp;0\\end{matrix} \\right] $$ 对应的线性方程组为 $$ \\begin{gathered} x_1-5x_3=1 \\\\ x_2+x_3=4 \\\\ 0=0 \\end{gathered} $$ 其中$x_1,x_2$为基本变量，$x_3$为自由变量 于是可以得到线性方程组的通解 $$ \\begin{cases} x_1=1+5x_3&amp;\\\\ x_2=4-x_3&amp;\\\\ x_3是自由变量 \\end{cases} $$ 向量方程 向量 n维向量可以写成nx1列矩阵的形式 $$ \\mu=\\begin{bmatrix} 1\\\\ 1\\\\ \\vdots \\\\ 1 \\end{bmatrix} $$ 所有元素为0的向量称为零向量 当且仅当两个向量对应元素全相等时，两向量相等 为了方便书写，我们会将n维向量横着写（注意！用的是括号，并且相邻元素间用逗号隔开） $$ (1,1,…,1) $$ 向量方程 向量方程： $$ x_1\\mathbf{a_1}+x_2\\mathbf{a_2}+…+x_n\\mathbf{a_n}=\\mathbf{b} $$ 的解，等同于增广矩阵为 $$ \\begin{bmatrix}\\mathbf{a_1}&amp;\\mathbf{a_2}&amp;…&amp;\\mathbf{a_n}\\end{bmatrix} $$ 的线性方程组的解 $Span{\\nu}$ $Span{\\nu_1,\\nu_2,…,\\nu_n }$ 矩阵运算 $$ A\\mathbf{x}= \\begin{bmatrix}\\mathbf{a_1}&amp;\\mathbf{a_2}&amp;…&amp;\\mathbf{a_n}\\end{bmatrix} \\begin{bmatrix}x_1\\\\ x_2\\\\ \\vdots \\\\ x_n\\end{bmatrix} =x_1\\mathbf{a_1}+x_2\\mathbf{a_2} + …+x_n\\mathbf{a_n} $$ 当且仅当左边的列数等于右边的行数，才可以运算（横乘竖） 矩阵方程 $$ A\\mathbf{x}=\\mathbf{b} $$ 齐次线性方程组 若线性方程的常数项为0，则称该线性方程为齐次的，可以写成 $$ A\\mathbf{x}=\\mathbf{0} $$ 的形式 齐次线性方程必有一个平凡解，即$\\mathbf{x}=\\mathbf{0}$ 齐次线性方程有非平凡解，当且仅当方程组至少有一个自由变量 要判断$A\\mathbf{x}=\\mathbf{0}$有无非平凡解 写出方程组的增广矩阵$[A, \\mathbf{0}]$ 将矩阵化简为简化阶梯形 若存在某一行全为0（该行对应的变量就是自由变量），则有非平凡解 哪些不全为0的行所对应的变量称为基本变量 线性无关 若线性方程仅有平凡解，则该组向量（矩阵各列）线性无关 矩阵 要判断某个矩阵各列是否线性无关： 写出矩阵的增广矩阵$[A, \\mathbf{0}]$ 对矩阵进行行简化 若矩阵没有自由变量，则说明各列线性无关 向量的集合 一个向量的集合线性无关的条件：当且仅当向量不是零向量 两个向量的集合线性相关的条件：当且仅当某个（非零）向量是另一个（非零）向量的倍数 多个向量的集合线性相关的条件：当且仅当至少有一个向量是其他向量的线性组合 若一个向量组中向量个数多于每个向量的元素个数，那么这个向量组线性相关（充分条件） 能看出，两个向量属于多个向量 线性变换 变换 $$ A\\mathbf{x}=\\mathbf{b} $$ 一个n维向量左乘一个m行n列的矩阵，会得到一个m维的向量 我们称$\\mathrm{R}^n \\rightarrow \\mathrm{R}^m$这个过程为一个变换，也可以叫做函数、映射 变化的规则为$T$，$\\mathrm{R}^n$被称为$T$的定义域，$\\mathrm{R}^m$被称为$T$的余定义域 对于$\\mathrm{R}^n$中的一个向量$x$，其在$\\mathrm{R}^m$中的向量$T(x)$被称为$x$的像，所有的像的集合被称为值域 线性变换 若定义域中的一切向量满足 $T(\\mathbf{u}+\\mathbf{v})=T(\\mathbf{u})+T(\\mathbf{v}) $ $T(c\\mathbf{u})=cT(\\mathbf{u})$ 则称该变换为线性变换 线性变换的性质： $T(\\mathbf{0})=\\mathbf{0}$ $T(c\\mathbf{u}+d\\mathbf{v})=cT(\\mathbf{u})+dT(\\mathbf{v}) $ 若n等于m，$T(\\mathbf{x})=r \\ \\mathbf{x}$ 若r &gt; 1，则称为拉伸变换 若0 &lt; r &lt; 1，则称为压缩变化 变化矩阵 二维空间的变化矩阵为，$(x_1, y_1)$为变化后单位正方形右下角的位置，$(x_2, y_2)$为变化后单位正方形左上角的位置 $$ \\left[ \\begin{matrix}x_1&amp;x_2\\\\ y_1&amp;y_2\\end{matrix} \\right] $$ 二：矩阵代数 矩阵 对于一个mxn的矩阵，也就是m行n列的矩阵，我们可以写作 $$ A=[\\mathbf{a}_1 \\ \\mathbf{a}_2\\ \\cdots \\mathbf{a}_n] $$ 其中 矩阵A的对角元素为$a_{11}, a_{22}, \\cdots$，他们组成了矩阵A的主对角线 对角矩阵：非对角线元素全为0的矩阵 零矩阵：元素全为0的矩阵，根据其尺寸，可以写为$\\mathbf{0}_{m \\times n}$ 矩阵运算 矩阵相等：维数相同且对应元素均相同 矩阵相加：维数相同的矩阵才能相加，结果为对应元素相加 矩阵标量乘：矩阵所有元素乘一个标量","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"光学：几何光学","slug":"optics/几何光学","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.631Z","comments":true,"path":"optics/几何光学/","link":"","permalink":"https://reubensun.com/optics/%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6/","excerpt":"","text":"四：几何光学 几何光学，也被称为射线光学（Ray optics），忽略光的波动性，以几何方法来研究光在均匀介质中的传播 基本定律 几何光学包含两个部分，一个是光学三定律，定性描述了几何光学中光的传递，一个是费马原理，定量计算了光的传播（通常为光学元件间近轴传播） 光学三定律 光在均匀介质中沿直线传播 光的反射、折射定律 反射角等于入射角 入射角与折射角的正弦值之比等于折射率之比（Snell定律） 光独立传播，光路可逆 Shell定律 $$ n_i\\sin \\theta_i= n_t \\sin \\theta_t $$ 反射光线是最短路径（亚历山大） 光程 由于光在介质中移动速度不同，为了方便描述光在介质中移动某段距离要花费的时间，我们引入了光程长度。于是我们在计算时就可以认为光速永远不变，只是光的传播距离与现实距离不同 光程长度（Optical path length，OPL）：光在介质中传播长度与介质的折射率的乘积 $$ [l]=ns $$ 光程描述的是：光在该介质中移动真实距离所花费的时间，如果在真空中能运动多远的距离 费马原理 开创了以“路径积分，变分原理“来描述物理规律的思维方式 费马原理（也叫最短时间原则）： 光在两点间的传播路径是最短路径（最短路径可以由多条，但是其光程相同） 两点间的光程恒定（光程函数的导数为0） 费马原理可以推导出光学三定律 在均匀介质中折射率为常数，光在两点间的传播路径为最短距离，又由于两点间直线距离最短，因此光沿着直线传播 由于反射点、折射点都在交线OO‘上，因此他们在同一平面内（在交线上距离最短） 由于两点间直线最短，沿着反射轴做反射光线的对称直线，发现当反射角等于入射角时，入射光线和对称光线为一条直线 用折射率和三角形长度表示折射光线的光程，该光程应该是最小值，因而导数为0，求导化简得出Shell公式 透镜成像 根据费马原理，两点间光沿着光程最短的路径传播，这说明凸透镜成像中每一条光线的光程都相等 实际上，凹透镜散射光光线的反向延长线与入射光组成的总光程也是根根相等的 等光程 等光程：如果一个光学器械每条光线都是等光程的（比如透镜），我们称之为等光程，他们可以严格成像 不等光程的器械不能成像，近似光程的器械能成模糊的像 费马原理的应用 反曲椭球面生成平行光：从椭球面焦点发生灯光，会生成平行光，由于平型光不会汇聚，因此他们的光程为无穷大 光在椭球面内反射：在椭球面内，两个焦点间光程为恒定值（毕竟椭圆上的点到两个焦点距离的和为焦距） 双曲透镜将平行光汇聚到一点 半球面反射 成像 光学系统（Optical system）：一个包含一个或多个光学元器件的系统 物体空间（Object space）：入射光线所在的区域 图像空间（…/…/images space）：出射光线所在的区域 理想光学系统（ideal optical system）：物体能被完美地成像，比如平面镜反射 共轭点（conjugate points）：物体点和图像点组成共轭点 对于一个理想光线系统，每对共轭点的光程（后面以OPL指代）均相同 实像：物体发出的光经过反射、折射后，汇聚成新的像，被称为实像（比如凸透镜） 虚像：物体发出的光经过反射、折射后，变成了发散光线，将其反向延长得到的像，被称为虚像（比如凹透镜、平面镜） 单心性 从一点发射光源，经过光学系统后，仍然汇聚为一点，那么这个光学系统满足单心性 平面镜反射满足单心性，折射不满足 不满足单心性，物像和图像不共轭，不能完美成像 全反射 当光从光密射入光疏，且角度大于某个值后，只发生反射，不发生折射 光导纤维 不过光疏介质介质中并没有没有透射波，但这些透射波与界面平行，且振幅在垂直界面方向按指数衰减，于是很快就没了，这个波被称为隐失波 人眼为什么能看到虚像 人为什么能看到东西？是因为物体经过眼睛，在视网膜上成了像，在这里，眼睛是成像系统 我们在讨论实像虚像时，提到的光学系统那些透镜们，于是虚像的全称应该是“某物体在xxx光学系统的虚像”，人眼并不是看到了“某物体在xxx光学系统的虚像”，而是在该处，经由人眼，看到了一个实像 理想光学系统 共轭性：物像种每个点、线、面都能在图像上找到对应的点、线、面 等光程 棱镜成像 球面成像 尽管球面不是一个很好的光学器械，但比较好加工（其实现在加工技术已经很好了，很多人的眼镜都是非球面的），于是球面成像是几何光学很重要的一块 光轴：若一个光学系统由球面组成，各球心的连线在一条直线上，该光学系统被称为共轴球面系统，这条直线被称为光轴 球差 我们上面提到球面不是一个很好的光学器械，因为透镜成像有球差 透镜成像，靠近光轴的光会被汇聚在靠后的位置，远离光轴的光会被汇聚在靠前的位置，也就是透射光经过球面成像后不再汇聚为一点，单心性被破坏 近轴条件 由于球差的存在，我们假设光只在近轴处传播，于是“消除”了球差 近轴条件（paraxial condition）：入射角与光轴（optical axis）的夹角（用$u$表示）小于等于$5^{\\circ}$ 此时，三角函数可以近似 $$ \\cos u \\approx 1 \\ \\sin u \\approx u \\ \\tan u \\approx \\sin u $$ 消球差平面（Aplanatic Surface）：允许所有光线在两点之间以相等的OPL传播的表面 符号法则 简单来说，若左侧的光射向一个左凸的球面在右侧汇聚，距离都是正的 设入射光从左向右 若入射点在顶点（球面和光轴的交点）左侧，那么入射点到顶点的距离为正，反之为负 若汇聚点在顶点右侧，那么汇聚点到顶点的距离为正，反之为负 若球心在顶点左侧，则半径为负，反之为正 绘图标准 基准点：球面顶点(单球面系统)、焦点 基准线：光轴、各折射点的法线 长度量：由指定原点量起顺光线传播方向为正，反之为负。 高度量：垂直向上为正，反之为负。 角度量规定：以锐角衡量，以主光轴顺时针转到光线为正。 规定：图上只标绝对值。 球面反射 Reflection at spherical surfaces $$ \\frac{1}{-s}+\\frac{1}{-s’}=-\\frac{2}{r} $$ 光轴（QA这条线） 焦点（image focus，图中$\\mathrm{F’}$）：平行于光轴的光线打到球面上，会汇集到一点，这个个点被称为焦点 物体焦距（Object focal length，用$f$表示） 图像焦距（…/…/images focal length，用$f’$表示） 在球面反射，物体焦距和图像焦距是相等的 $$ f= \\lim_{s’ \\rightarrow \\infty}s \\ f’= \\lim_{s \\rightarrow \\infty}s’ \\ \\frac{1}{s}+\\frac{1}{s’}=\\frac{1}{f} $$ 球面折射 Refraction at spherical surfaces $$ \\frac{n_1}{-s}+\\frac{n_2}{s’}=\\frac{n_2-n_1}{r} \\equiv \\Phi $$ 光焦度（用$\\Phi$表示）：用与描述光线系统对光线的曲折能力 高斯透镜公式（Gaussian Lens Formula） $$ \\frac{f}{s}+\\frac{f’}{s’}=1 $$ 牛顿透镜公式（Newton form of Lens Formula） $$ x_0x_i=ff’ $$ 离轴点成像 Imaging for off-axis points 就是y比较大，导致不能使用三角函数近似 薄透镜成像 透镜：由两个同轴折射球组成的镜子，根据球心位置，分为凸透镜（convex lens）和凹透镜（concave lens） 薄透镜（Thin lens）：中心半径和曲率厚度可以忽略不记的透镜 光轴（Optic axis）：连接两个曲面中心的轴 光学中心（Optic center）：两个球面的基准点（vertex）视为重合，重合点就是光学中心 凸透镜分为双凸、平凸、弯凸三种 凹透镜分为双凹、平凹、弯凹三种 透镜公式 $$ \\frac{n_1}{-s_1}+\\frac{n_2}{s_2’}=\\frac{n_0-n_1}{r_1}+\\frac{n_2-n_0}{r_2}\\equiv \\Phi $$ 焦平面 焦平面（Focal plane）：垂直于光轴且经过焦点的平面 前焦平面（front focal plane）：光射入透镜的面 后焦平面（back focal plane）：光从透镜射出的面 透镜使得光的落点与入射角有关，且满足 $$ y=f \\cdot \\tan\\theta \\approx f\\cdot \\theta $$ 用透镜成像等于两倍的傅里叶变换 光阑 光阑（stop）：限制（limit）成像光束的器件，比如透镜（lens）、光圈（aperture）、窗口片（the frame of windows） 光圈 光圈（aperture stop，下图DD’）：用于限制光线宽度的期间 Field stop：用于限制成像区域和方位 景深 景深（Depth of field/focus）：聚焦深度，入射点P在光轴方向移动，移动距离$\\Delta x$在景深范围内，图像是清晰的 能看出图中$P_1$过早聚焦，$P_2$过晚聚焦，他们相对于$P$，都显得比较模糊 在物体空间的最大$\\Delta x$被称为Depth of field 在图像空间的最大$\\Delta x$被称为Depth of focus 相对孔径 相对孔径（Relative aperture）：光圈的直径（用$D$表示）和焦距（focal length，用$f$表示）的比值 $D/f$越大，说明光学系统收集光的能力越强 f-number 相对孔径的倒数，意义为焦距是直径的多少倍 比如一个光学系统，焦距160nm，光圈直径20nm，那么它的f-number等于160/20=8，记作$f/8$","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：反射和折射","slug":"optics/反射和折射","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.632Z","comments":true,"path":"optics/反射和折射/","link":"","permalink":"https://reubensun.com/optics/%E5%8F%8D%E5%B0%84%E5%92%8C%E6%8A%98%E5%B0%84/","excerpt":"","text":"五：反射与折射 内容概述 光在单层各项同性表面的反射与折射 菲涅尔方程 全内反射 相位突变，布鲁斯特角 菲涅尔方程 菲涅尔方程 各项同性介质（Isotropic medium）：折射率处处相同的材质 光密介质：折射率高的介质（这是一个相对概念） 光疏介质：折射率低的介质（这是一个相对概念） 在几何光学中的那些反射方程，只能得到入射光、反射光、折射光间的方向关系 而菲涅尔方程（Fresnel Equations）可以求出反射光、折射光的振幅、相位、偏振 菲涅尔方程的边界条件表明：磁场和电场在边界处连续，也就是入射光的电场磁场=反射光+折射光的电场磁场 我们将入射光的电场分为两个部分，方向满足右手正交系 平行（parallel）于平面的电场$E_p$ 垂直（senkrecht）与平面向外的电场$E_s$ 经过复杂的推导，我们能得到 $$ r_p=\\frac{E_{1p}’}{E_{1p}}=\\frac{\\tan(\\mathrm{i_1}-\\mathrm{i_2})}{\\tan(\\mathrm{i_1}+\\mathrm{i_2})} \\\\ r_s=\\frac{E_{1s}’}{E_{1s}}=-\\frac{\\sin(\\mathrm{i_1}-\\mathrm{i_2})}{\\sin(\\mathrm{i_1}+\\mathrm{i_2})} \\\\ t_p=\\frac{E_{2p}}{E_{1p}}=\\frac{2\\cos \\mathrm{i_1}\\sin \\mathrm{i_2}}{\\sin(\\mathrm{i_1}+\\mathrm{i_2}) \\cos (\\mathrm{i_1}-\\mathrm{i_2})} \\\\ t_s=\\frac{E_{2s}}{E_{1s}}=\\frac{2\\cos \\mathrm{i_1}\\sin \\mathrm{i_2}}{\\sin(\\mathrm{i_1}+\\mathrm{i_2})} $$ $r$：反射光 $t$：折射光（透射光，Transmission） 于是我们能得出几个结论 反射光、折射光与入射角、折射率有关 $p$与$s$是独立的 菲涅尔方程的含义 外反射 外反射（External reflection）：从折射率低射向折射率高，比如从空气射向玻璃 我们发现，随着入射角的增加 折射一直是正数，并且两个方向没有明显差异 $r_s$一直是负数，而$r_p$先正后负 布鲁斯特角（Brewster’s angle，图中$i_B$），在此处$r_p$发生了一个$180^{\\circ}$的相变 当入射角为$90^{\\circ}$时，也就是掠射角（grazing angles），我们发现此时完全不发生折射，只发生反射 对于一个湿表面，远看发现很亮，近看却发现变暗了 远看水面，大部分光来自反射，于是波光粼粼；近看水面，折射部分加强，于是清澈见底 让入射角为$0^{\\circ}$，也就是垂直入射时，$r_p$完全反向反射回来，折射很微弱 内反射 内反射（Internal reflection）：从折射率高射向折射率低，比如从玻璃射向空气 $t_p=t_s$，两者没有相位差 当$i=i_c$，此时$r_p=r_s=1$，我们称之为全内反射（Total Internal Reflection，TIR），$i_c$被称为临界角（critical angle） 相位移 相位移（Phase shift） 从低折射率到高折射率，会有一次$\\pi$相位移 从高折射率到低折射率，没有相位移 薄膜相位移：光线在薄膜内发生多次反射，可能会附加一段相位移 简化菲涅尔方程 反射比（Reflectance，用$R$表示）：反射光占入射光的能量 折射比（Transmittance，用$T$表示）：透射光（折射光）占入射光的能量 能流（Energy flow）：单位时间内通过单位横截面积的能量 能流 = 辐照度 x 横截面积 $$ R=r^2 $$ $$ T=\\frac{n_2\\cos i_2}{n_1\\cos i_1}t^2 $$ 根据能量守恒定律（Energy conservation law）：$R+T=1$ 当垂直入射时，带入菲涅尔方程，得到 $$ \\begin{cases} r_p=\\frac{n_2-n_1}{n_2+n_1} \\\\ r_s=-r_p \\\\ t_p=\\frac{2n_1}{n_1+n_2} \\\\ t_s=t_p \\end{cases} $$ 于是得到 $$ R_p=R_s=\\left( \\frac{n_2-n_1}{n_2+n_1}\\right)^2 $$ $$ T_p=T_s=\\frac{4n_1n_2}{(n_1+n_2)^2} $$ 对于空气（$n_1=1$）和玻璃（$n_2=1.5$），$R=0.04，T=0.96$ 这也是为什么图形学中取 0.04为F0的基准值 为什么晚上室内玻璃像镜子一样？ 晚上的玻璃，$R\\approx 0.08$，室内的光线大部分都会反射回来，而室外的光线只有很少才会透射进来，看到的光绝大多数都来自室内的反射光，因此像镜子一样 此外，夜晚室内光线本身也比室外光线强 为什么白天从黑暗的房间看外面看，看的很清楚，而从室外向里看，却看不清？ 单透玻璃的原理是什么？ 金属 金属（电介质）表面存在大量自由电荷，在外部电场的作用下，自由电子在固体表面（相对固定的金属阳离子）间不断弹跳 德鲁德模型 德鲁德模型（Drude model）是一种描述金属表面自由电子运动的模型（很复杂，看一下，图一乐） $$ P=-nex $$ $$ m\\frac{\\partial^2 x}{\\partial t^2}+m \\gamma \\frac{\\partial x}{\\partial t}=eEe^{-\\mathrm{i}\\omega t} $$ 偏振度（用$P$表示，在电磁波那一章在介绍洛伦兹震荡时有一个极其类似的公式） 阻尼率（damping rate，用$\\gamma$表示） 电荷密度（density of electron，用$n$表示） 这个推导很复杂，又涉及复变函数之类的，直接给结论：当平面波垂直射向金属时，$R \\approx 1$ 布鲁斯特角 布鲁斯特角（Brewster’s angle），在外反射那一节提到过，当$i_1=i_B,r_p=0$ 一个应用是测量不透明介质的折射率 $$ \\tan i_B=\\frac{n_2}{n_1} $$ 另一个一个应用是制作偏振器，激光经过偏振器后，射出的光线是线偏振的 自然光（非偏振光）的反射光、折射光是偏振光，但如果给镜头安装偏振器，并适当旋转偏振片，使偏振片的透振方向与反射光的透振方向垂直，此时$i_1=i_B,r_p=0$，不发生反射，只发生透射，于是会看得更清晰 偏振 线偏振光的反射、折射光仍为线偏振光，但其光矢量方向会发生改变（上为入射光，下为反射光） 圆偏振/椭圆偏振光的反射折射光一般为椭圆偏振光 全内反射 从折射率高射向折射率低，当入射角满足$i_1 \\ge i_c$时，就会发生全内反射（Total internal reflection） 此时$R\\equiv 1$，也就是所有能量都被反射，不发生透射，于是低折射率那一侧看不到任何光，物体变黑了，这个现象就是全内反射 全内反射的应用：棱镜（Prisms）、光纤 隐失波 隐失波（Evanescent wave） ：光从光密介质入射光疏介质时，如果发生全内反射，光疏介质那一侧产生的电磁波 隐失波的振幅随着穿透深度（Depth of penetration）的增加而呈现指数衰减，随切线方向而改变相位，因此是一种表面波 $$ d=\\frac{\\lambda_2}{2\\pi \\Omega} $$ 穿透深度：与分界面的垂直深度，用$d$表示 $\\sqrt{1-\\sin ^2 i_2} \\equiv \\mathrm{i}\\Omega$ 隐失波沿着z轴衰减，沿着x轴传播 $$ E_2=E_{02}e^{-z/d}e^{\\mathrm{i}(k_xx-\\omega t)} $$ 隐失波不是横波 隐失波的一个应用是制作分光镜，如果只有一个棱镜（下图黑色三角形），会发生全内反射，光线全部反射 如果将两个棱镜靠近，通过控制两者间空气的间隙，在隐失波的作用下，能实现分光 其他应用： 光子隧穿 近场扫描显微镜 指纹检测","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：波动光学","slug":"optics/波动光学","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.633Z","comments":true,"path":"optics/波动光学/","link":"","permalink":"https://reubensun.com/optics/%E6%B3%A2%E5%8A%A8%E5%85%89%E5%AD%A6/","excerpt":"","text":"二：波动光学 内容概述 简谐波（simple harmonic waves） 傅里叶变换（Fourier Transform） 波的物理量 数学基础 常用函数 三角函数 欧拉公式 $$ e^{\\mathrm{i}x}=\\cos x + \\mathrm{i}\\sin x $$ 三角函数的复数表示 $$ \\sin z=\\frac{e^{\\mathrm{i}z}-e^{-\\mathrm{i}z}}{2\\mathrm{i}} $$ $$ \\cos z=\\frac{e^{\\mathrm{i}z}+e^{-\\mathrm{i}z}}{2} $$ $\\delta$函数 德尔塔函数，冲击函数 整体积分为1，除了0点以外，其他点函数值都为0 $$ \\delta(x)=0,(x\\ne0) $$ $$ \\int^{\\infty}_{-\\infty}\\delta(x)dx=1 $$ 高斯函数 概率论里的正态分布 $$ f(x)=ae^{-(x-b)^2/2c^2} $$ a&gt;0 洛伦兹函数 概率论里的柯西分布 $$ f(x)=\\frac{A}{B^2+x^2} $$ 矩形脉冲函数 $$ f(t)=E[u(t+\\frac{\\tau}{2})-u(t-\\frac{\\tau}{2})] $$ 波的数学表示 定态波：空间中各点均为同频率的简谐振荡，各点振幅不随时间改变 震荡（Vibration）：物理量围绕其平衡位置进行周期性变化 简谐震荡（Harmonic vibration）：物理量随着时间以三角函数的形式进行震荡 $$ U(t)=A\\cos(\\omega t+\\varphi_0) $$ 振幅（amplitude，用$A$表示） 角频率（angular frequency，用$\\omega$表示） $$ \\omega=\\frac{2\\pi}{T} $$ 相位（phase，用$\\varphi$表示） 初相（initial phase，用$\\varphi_0$表示） 波（waves）：震荡在空间中的传播 简谐波（simple harmonic waves）：进行简谐震荡的波 单色平面波可以视为简谐波 波阵面（wave surface）：波在介质中传播，经过相同时间所到达的各点所连成的线/面 波前（wave front）：最前面的波阵面 相速度（phase velocity，用$v_p$表示）：波传递的速度 $$ v_p=\\frac{\\omega}{k} $$ 傅立叶变换 将一个满足条件的函数，转化为三角函数（或他们积分）的线性组合 $$ \\hat{f}=&lt;f,E_k&gt;=\\int f(x)e^{-2\\pi i k\\cdot x}\\mathrm{d}x $$ 其傅里叶级数为 $$ \\sum\\hat{f}(k)E_k $$","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：电磁波","slug":"optics/电磁波","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.634Z","comments":true,"path":"optics/电磁波/","link":"","permalink":"https://reubensun.com/optics/%E7%94%B5%E7%A3%81%E6%B3%A2/","excerpt":"","text":"三：电磁波 内容概述 横波的性质（nature），强度（intensity），能量流动（energyflow） 偏振态（Polarization states），琼斯矩阵（Jones matrix/vector） 吸收（Absorption），色散（dispersion），折射率（refractive index） 微小粒子导致的散射（Scattering） 波 构成波的条件： 波源 介质 能量来源 波的性质： 时间周期性 空间周期性 能量传播 波的分类 标量波 矢量波 光的基本性质 光是电磁波 可见光的波长在400nm~760nm 在做干涉衍射计算时，经常去白光的平均波长550nm 人眼对550nm的黄绿光最敏感 单色光（Monochromatic light），指仅有一种波长的光，仅存在于理论中 光速 光在真空（vacuum）中的速度（简称光速，用c表示）为 $$ c=\\frac{1}{\\sqrt{\\varepsilon_0 \\mu_0}}=2.997 924 58 \\times10^8 m/ s $$ 光在介质（medium）中的速度（也叫做相速度，用v表示）为 $$ v=\\frac{1}{\\sqrt{\\varepsilon_0 \\varepsilon_r\\mu_0\\mu_r}}=\\frac{c}{\\sqrt{\\varepsilon_r \\mu_r}} $$ 很显然光在介质中的速度比在真空中慢，我们用折射率（Refractive index，用n表示）来描述这一性质 $$ n=\\frac{c}{v} $$ 光穿过线性介质（linear medium）时，其频率不会发生改变 光的波长（用$\\lambda$表示） $$ \\lambda=\\frac{c}{v} $$ 波粒二象性 波 如果光是波，那么光应该有波的性质： $$ \\mathbf{k}=\\frac{2\\pi}{\\lambda}\\hat{\\mathbf{k}} $$ $$ v=\\frac{\\lambda}{T}=\\lambda \\nu $$ $$ \\omega=2\\pi \\nu =\\frac{2\\pi}{T}=\\frac{2\\pi}{\\lambda}v=kv=k_0c $$ 波长（wavelength，用$\\lambda$表示） 波向量（wave vector，用$\\mathbf{k}$表示） 频率（frequency，用$\\nu$表示） 周期（temporal period，用$T$表示） 角频率（angular frequency，用$\\omega$表示） 速度（velocity，用$v$表示） 光是电磁波，其电矢量和磁矢量在做简谐振动，一般情况下，我们只讨论电场强度的变化 粒 如果光是粒子，那么光应该有粒子的性质： $$ E=h\\nu=\\hbar \\omega $$ $$ \\mathbf{p}=\\hbar \\mathbf{k}=\\frac{h}{\\lambda}\\hat{\\mathbf{k}} $$ 能量（Energy，用$E$表示） 动量（Momentum，用$\\mathbf{p}$表示） 普朗克常量（Plank constant，用$h$表示，$h=6.626\\times 10^{-34}\\mathrm{J}\\cdot\\mathrm{s}$ 约化普朗克常量（用$\\hbar$表示） 波粒二象性 光具有波粒二象性（Wave-particle duality），光在传播过程中体现出明显的波性，在光与物质交互（light-matter interaction）中粒性更明显 光子与电子 不同之处 电子 光子 静止质量（Rest mass） $m_0$ 0 运动质量（Motion mass） $m$ $hv/c^2$ 运动速度（Motion velocity） $&lt;c$ $c$ 自旋（Spin） 1/2 1 分布定律 费力（Fermion） 玻色（Boson） 相同之处 满足波粒二象性 向量波与标量波 向量波（Vector wave），波函数是向量的波，比如电磁波（EM wave） 标量波（Scalar wave），波函数是标量的波，比如声波（Acoustic wave） 光波（Lightwaves）是一种向量波，但为了方便，我们在讨论干涉衍射时，会认为光是标量波，仅仅在讨论偏振时，才认为光是向量波 电磁波 物理量 电场强度（用$\\mathrm{E}$表示）：单位电荷在电场中受到的力 磁场强度（用$\\mathrm{H}$表示）：通电导线周围有磁场，其强度与电流大小、距离远近有强度（但实际被后世推翻，无实际意义） 电场通量密度（用$\\mathrm{D}$表示）：单位面积的电场通量 磁场通量/感应密度（用$\\mathrm{B}$表示）：经过一个曲面的磁力线的数量 电磁学三定律 库伦定律，真空中两个静止的点电荷间作用力满足 $$ F=k\\frac{q_1q_2}{r^2} $$ 静电力常量（$k=9.0\\times 10^9 \\mathrm{N} \\cdot\\mathrm{m^2}/\\mathrm{C^2}$） 安培环路定律（Ampère’s Circuital Law），也叫右手螺旋定则，载流导线能生磁 法拉第电磁感应定律（Faraday’s Induction Law），磁场变化能产生电场，感应电动势大小与磁通量变化率成正比，电场方向符合楞次定律（由于磁通量的改变而产生的感应电流，其方向为抗拒磁通量改变的方向） 麦克斯韦方程 真空中麦克斯韦方程： 法拉第 $$ \\nabla \\times \\mathbf{E}=-\\frac{\\partial \\mathbf{B}}{\\partial t} $$ 安培 $$ \\nabla \\times \\mathbf{B}=\\mu_0 \\varepsilon_0 \\frac{\\partial \\mathbf{E}}{\\partial t} $$ 真空磁导率（也称为磁常数，用$\\mu_0$表示，$\\mu_0=4\\pi \\times 10^{-7}\\mathrm{H}/\\mathrm{m}$） 真空电容率（也称为电常数，用$\\varepsilon_0$表示，$\\varepsilon_0=8.854…\\times10^{-12}\\mathrm{F}/\\mathrm{m}$） 高斯电场 $$ \\nabla \\cdot \\mathbf{E}=0 $$ 高斯磁场 $$ \\nabla \\cdot \\mathbf{B}=0 $$ 自由空间的波动方程（wave equations，由麦克斯韦方程推出）： $$ \\nabla^2\\mathbf{E}=\\mu_0 \\varepsilon_0 \\frac{\\partial^2 \\mathbf{E}}{\\partial t^2} $$ $$ \\nabla^2\\mathbf{B}=\\mu_0 \\varepsilon_0 \\frac{\\partial^2 \\mathbf{B}}{\\partial t^2} $$ 平面波 三维的电磁波很难分析，我们可以分解变量，将其转化为两个垂直的平面波 平面波（Plane waves）：传播时波面在一个平面的电磁波 平面波的电场方向和磁场方向，与波矢方向垂直，如图，$\\mathbf{k}$为波矢方向（推导过程略），从这里也能看出，平面波是横波，方向满足右手定则 平面波的磁感应强度B和电场强度E的比值等于波速 $$ \\frac{|E|}{|B|}=\\sqrt{\\frac{1}{\\mu \\varepsilon}}=v $$ 电场强度和磁场强度的关系为（注意，这里不是磁感应强度） $$ \\sqrt{\\varepsilon_0 \\varepsilon_r}|\\mathrm{E}|=\\sqrt{\\mu_0\\mu_r}|\\mathrm{H}| $$ 自由空间阻抗（单位和电阻相同，用$Z_0$表示） $$ Z_0=\\sqrt{\\frac{\\mu_0}{\\varepsilon_0}}=376.73\\Omega $$ 波能传递能量，我们引入坡印廷向量（Poynting vector，用$\\mathrm{S}$来表示）来描述能量流动，其方向为电磁能传递方向，大小为能流密度（单位面积的能量传输速率） $$ \\mathrm{S}=\\mathrm{E}\\times \\mathrm{H} $$ 平面波$\\mathrm{E}\\times \\mathrm{H} // \\mathrm{k}$ 傍轴条件 当$\\rho \\ll z，r \\approx z$ 远场条件 辐照度 电磁波的辐照度（Irradiance，用$\\mathrm{I}$表示，也称为Intensity），是坡印廷向量在时间上的平均值 $$ \\mathrm{I}=\\left&lt; \\mathrm{S} \\right&gt;=\\frac{nc\\varepsilon_0}{2}\\mathrm{E_0}^2 $$ $c$是真空中光速 $\\mathrm{E_0}$是电磁波电场强度的振幅（电场强度是一个三角周期函数） 从这里可以看出，辐照度与$\\mathrm{E_0}$的平方成正比 偏振 偏振（Polarization）：光矢量在垂直于传播方向的平面上的震动状态，我们这里提的是电场强度$\\mathrm{E}$的震动 根据是否发生偏振 不偏振光（Unpolarizedlight） 完全偏振光（Completely polarized light） 部分偏振光（Partially polarized light） 根据向量$\\mathrm{E}$的终点（endpoint）轨迹 线偏振（Linearly polarized light） 圆偏振（Circularly polarized light） 椭圆偏振（Elliptically polarized light） 若光线沿着z轴传播，其方程满足 $$ (\\frac{E_x}{E_{0x}})^2+(\\frac{E_y}{E_{0y}})^2-2(\\frac{E_x}{E_{0x}})(\\frac{E_y}{E_{0y}})\\cos \\delta = \\sin ^2 \\delta $$ 线偏振 当$\\delta=2m\\pi$时，方程变为 $$ (\\frac{E_x}{E_{0x}})^2+(\\frac{E_y}{E_{0y}})^2-2(\\frac{E_x}{E_{0x}})(\\frac{E_y}{E_{0y}}) = 0 \\ (\\frac{E_x}{E_{0x}}-\\frac{E_y}{E_{0y}})^2=0 $$ 于是得到线偏振的方程（一三象限） $$ \\frac{E_x}{E_{0x}}=\\frac{E_y}{E_{0y}} \\equiv \\cot \\alpha $$ 同理，当$\\delta=2(m+1)\\pi$时，方程等于（二四象限） $$ \\frac{E_x}{E_{0x}}=-\\frac{E_y}{E_{0y}} $$ 用虚数将两个方程合并，得到 $$ \\frac{E_x}{E_{y}}=\\frac{E_{0x}}{E_{0y}}e^{\\mathrm{i}m’\\pi} $$ 当$m’$为偶数（0 or even）时，一三象限 当$m’$为奇数（odd）时，二四象限 椭圆偏振与圆偏振 当$\\delta=(2m+1)\\frac{\\pi}{2}$时，方程变为 $$ (\\frac{E_x}{E_{0x}})^2+(\\frac{E_y}{E_{0y}})^2=1 $$ 这是一个椭圆方程，我们称之为椭圆偏振 倘若$E_{0x}=E_{0y}=E_{0}$，方程退化为 $$ E_x^2+E_y^2=E_0^2 $$ 我们称之为圆偏振 当$\\delta=\\pi / 2$时，y轴驱动x轴移动，此时为顺时针，称为RCP 当$\\delta=-\\pi / 2$时，x轴驱动y轴移动，此时为逆时针，称为LCP 琼斯矢量 将偏振光的状态以向量的形式写出，方便运算（只适合完全极化光） $$ \\mathrm{E}=\\left[ \\begin{array}{c} E_x(t)\\ E_y(t)\\ \\end{array} \\right] $$ 琼斯向量左乘一个2x2矩阵，可以得到一个新的琼斯向量，这个矩阵被称为琼斯矩阵 偏振度 偏振度（Degree of polarization，用$P$表示）：用来衡量偏振程度的物理量 $$ P=\\frac{I_p}{I_t}=\\frac{I_p}{I_p+I_n} $$ $I_p$：完全偏振光部分的辐照度 $I_n$：不偏振光部分（自然光）的辐照度 吸收 兰伯特定律 兰伯特定律（Lambert law）：光在气体介质中传播，光强（intensity）随着传播深度增加而递减，满足 $$ I=I_0 e^{-\\alpha x} $$ 吸收系数（用$\\alpha$表示） 传播深度（用$x$表示） 贝尔定律 贝尔定律（Beer law）：光在溶剂中传播，光强满足 $$ I=I_0 e^{-ACL} $$ 浓度（用$C$表示） 常数$A$，与溶质性质有关，与浓度无关 该公式满足有两个条件 溶液浓度不能过高，以免出现分子间作用力（这也能解释为什么常数$A$为什么和浓度无关，因为浓度一高，公式就不成立了） 光强不能过高 色散 色散（Dispersion）：光波的相速度随着频率的改变而改变的现象 正常色散（Normal dispersion）：折射率随着波长的增加而减小 柯西公式： $$ n=A+B/\\lambda^2+C/\\lambda^4 $$ 反常色散（Anomalous dispersion）：折射率随着波长的增加而增加 反常色散通常发生在吸收带（absorption band）附近，反常色散并不是异常的，叫这个名字只是历史问题 洛伦兹震荡模型 洛伦兹震荡模型（Lorentz oscillator model）：在一个尺寸为$\\Delta V$的空间内有一个电子（电荷量为$1.6\\times10^{-19}C$），在光的电场作用下，让该电子相对于稳定位置偏离x 偏振度（单位体积电偶极矩的振幅，用$P$表示）写作 $$ P=\\frac{1}{\\Delta V}ex=n_0ex $$ 电荷密度（density of charge，用$n_0$表示） $x$是电子的运动方程，如下 $$ x(\\omega)=-\\frac{eE(\\omega)}{m_0}\\frac{1}{\\omega^2+\\mathrm{i}\\omega \\gamma-\\omega_0^2} $$ 将$x$带入，得到 $$ P=-\\frac{n_0e^2}{m_0}\\frac{1}{\\omega^2+\\mathrm{i}\\omega \\gamma-\\omega_0^2}E(\\omega) \\equiv \\varepsilon_0 \\chi(\\omega)E(\\omega) $$ 根据定义 $$ \\varepsilon=\\varepsilon_0[1+\\chi(\\omega)] $$ 带入得 $$ n^2=\\varepsilon/\\varepsilon_0=1-\\frac{n_0e^2}{m_0}\\frac{1}{\\omega^2+\\mathrm{i}\\omega \\gamma-\\omega_0^2} $$ 如图，洛伦兹模型解释了为什么在靠近吸收带时，会发生反常色散 组速度 在介质中不同波长的光速度不同，红光波长大，跑的更快 那么如果一个光，包含了多种波长的光，我们用组速度（Group velocity，用$v_g$表示）来描述其速度 $$ v_g=\\frac{\\mathrm{d}\\omega}{\\mathrm{d}k} $$ 散射 一般我们在讨论光在介质中传播，认为是没有损失的，但实际上光在介质中传播是存在吸收的 吸收：光强度随着穿进介质深度而减弱的现象 原因： 光能转化为其他能，比如热量、化学能、电能 发生散射，光向四面八方传播（丁达尔效应） 瑞丽散射 瑞丽散射（Rayleigh scattering）：光在细小粒子间散射 $$ I_{scat}\\propto 1/\\lambda^4 $$ $$ I_{\\theta}\\propto I_{\\pi/2}(1+\\cos^2 \\theta) $$ 米氏散射 米氏散射（Mie scattering）：光在大型粒子内部散射","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"Effective C++","slug":"program/Effective C++","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:05.038Z","comments":true,"path":"program/Effective C++/","link":"","permalink":"https://reubensun.com/program/Effective%20C++/","excerpt":"","text":"Effective C++ 一：C++基础 C++很成熟，很NB C++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming） 其核心是四个部分 C 区块block 语句statements 预处理器preprocessor 内置数据类型 数组arrays 指针pointers Object-Orientend C++ 类classes（构造函数，析构函数） 封装encapsulation 继承inheritance 多态polymorphism 虚函数virtual（动态绑定） Template C++ STL 替换#define 使用编译器替代预处理器 尽量使用const、enum定义常量，使用inlines定义函数宏 const #define PI 3.1415926 因为#define不是语言的一部分，在编译器开始工作前，PI就会被处理掉，所以一旦报错，你无法追踪到PI，只能看到3.1415926，这会浪费你的时间 应该改为 const double Pi 3.1415926; 值得注意的事 定义常量指针指向char*-based字符串 const char* const authorName = \"Reuben\"; 作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员 class GemePlayer&#123; private: static const int NumTurns = 5; //这只是一个声明式 int scores[NumTurns]; &#125;; const int GamePlayer::NumTurns; //这是定义式，因为在声明时已经赋值，所以这里就不赋值了 C++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式 从这里可以看出，const可以封装，而#define不行 enum class GemePlayer&#123; private: enum &#123; NumTurns = 5 &#125;; int scores[NumTurns]; &#125;; const指针 const在星号左边，被指物是常量 char greeting[] = \"Hello\"; const char* p = greeting; const在星号右边，指针本身是常量 char greeting[] = \"Hello\"; char* const p = greeting; const在星号两边，被指物和指针都是常量 char greeting[] = \"Hello\"; const char* const p = greeting; 确认对象在使用前已经被初始化 C++初始化顺序 基类比子类先初始化 成员变量根据其声明次序初始化 二：构造/析构/赋值 空类的默认函数 一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数 一个类，如果没有构造函数，也会自动声明一个default构造函数 这些函数都是public且inline的 禁用自动生成的函数 如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的） 你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名） class HomeForSale&#123; private: HomeForSale(const HomeForSale&amp;); HomeForSale&amp; operator=(const HomeForSale&amp;); &#125;; 可以制作一个不可被copy的类，让子类继承 class Uncopyable&#123; protected: Uncopyable()&#123;&#125; ~Uncopyable()&#123;&#125; private: Uncopyable(const Uncopyable&amp;); Uncopyable&amp; operator=(const Uncopyable&amp;); &#125;; class HomeForSale: private Uncopyable&#123; ... &#125;; 为多态基类声明virtual析构函数 一定要有一个virtual析构函数 如果这个类要成为一个基类，那么一定要有一个virtual析构函数 在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错 class TimeKeeper&#123; public: ... &#125;; class AtomicClock: public TimeKeeper &#123;...&#125;; class WaterClock: public TimeKeeper &#123;...&#125;; TimeKeeper* ptk = getTimeKeeper(); //创建一个动态分配对象 ... delete ptk; //释放对象，避免资源泄漏 上面这个过程的问题其实出在getTimeKeeper()指向一个派生类（derived class）对象（比如AtomicClock），而这个对象却要经由一个基类（base class）指针删除（比如TimeKeeper*） 如果这个基类的析构函数不是virtual的，就会出现问题： 如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象 解决方法就是给基类一个virtual析构函数 class TimeKeeper&#123; public: TimeKeeper(); virtual ~TimeKeeper(); ... &#125;; 最好不要有virtual析构函数 如果这个类不可能成为基类，那么最好不要有virtual析构函数 为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由vptr（virtual table pointer）指针携带，这个指针指向一个由函数指针构成的数组，称为vtbl（virtual table），每一个带有virtual函数的类都有一个属于自己的vtbl 这个vtbl会增大对象的体积，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍 这个vtbl会让代码失去兼容性，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性 请不要继承没有virtual析构函数的类 比如string、vector、list、set等等 而且 C++没有像 Java的final classes或者C#的sealed classes的禁止派生机制 不要在析构函数里抛出异常 当一个vector v容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为 有两个不怎么好的解决方法 遇到异常，直接std::abort()，即遇到异常，宁愿直接强制停止程序，也不要让异常传播 遇到异常，把异常记录下来，另程序继续运转，即吞下异常 这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好 比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容 class DBConnevtion&#123; public: ... static DBConnevtion create(); void close(); &#125;; class DBConn&#123; public: ... void close() //封装给客户用的,关闭连接的函数 &#123; db.close(); closed = true; &#125; ~DBConn()&#123; if(!closed)&#123; try&#123; db.close(); &#125; catch(...)&#123; ... //强制关闭程序或者吞下异常 &#125; &#125; &#125; private: DBConnection db; bool closed; &#125;; 不要在构造和析构过程中调用virtual函数 在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果 可以简单理解为在C++中，基类构造期间，vritual函数不是vritual函数 因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数 同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的 令operator=返回一个对*this的引用 连续赋值 x = y = z = 15; //其实就等于x = (y = (z = 15))； 为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参 class Widget&#123; public: Widget&amp; operator=(const Widget&amp; rhs) &#123; ... return *this; &#125; Widget&amp; operator+=(const Widget&amp; rhs)&#123; ... return *this; &#125; &#125;; xxxxxxxxxx #添加要提交的内容$git add 文件名/文件夹名#提交所有内容（不包含忽略文件），并设置提交信息为“这是一段话”$git commit -a -m 这是一段话bash 如果对象自己赋给自己，我们称之为自我赋值 w = w; a[i] = a[j]; //当i=j时，自我赋值 *px = *py; //px和py指向同一个物体时，自我赋值 在赋值操作中： 我们会先另左边的操作数先释放掉当前使用的数据 令其使用右操作数的副本 最后返回左操作数 class Widget&#123; ... private: Bitmap *pb; &#125;; //!!!这个不安全 Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; delete pb; pb = new Bitmap(*rhs.pb); return *this; &#125; 如果自我赋值，即rhs和pb指向同一个对象，那么delete pb后，这个对象就已经被销毁了，下面使用的*rhs就是一个已经被删除的对象 解决方法1：延后delete Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this; &#125; 解决方法2：使用copy and swap技术 Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Widget temp(rhs); swap(temp); //令*this与temp交换 return *this; &#125; 复制对象的一切 如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错 派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的） 所以copy函数需要 复制所有local变量 调用所有基类中的适当的copy函数 三：资源管理 让对象管理资源 将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源 申请资源后立即将其放进对象中，资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII） 在对象的析构函数中释放资源 C++的auto_ptr是一个类指针（pointer-like）对象，也就是智能指针，其析构函数会自动delete掉其所指向的对象 注意： 不要让多个auto_ptr指向同一个对象，因为一个对象被多次删除就会导致“未定义行为” auto_ptr如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权 **RCSP（引用计数型智能指针）**也是一种智能指针（比如tr1::shared_ptr），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源 小心copy行为 大多数RAII对象的copy函数： 禁止复制 采用引用计数法（RCSP） 复制底部资源（深拷贝） 转移底层资源所有权（auto_ptr） 在资源管理类中提供对原始资源的访问 有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件） new与delete一个数组 一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？ 如果new了一个数组，就delete一个数组 string* ptr1 = new string[100]; delete [] ptr1; 如果new了一个对象，就delete一个对象 string* ptr2 = new string; delete ptr2; 很多时候很难确定当前这个对象是数组还是一个对象 typedef string AddressLines[4]; string* pal = new AddressLines; delete [] pal; 最简单的方法是不用数组，使用STL里的容器，如vector&lt;string&gt; 以独立语句将newed对象置入智能指针 C++中调用一个函数，会先计算每一个传递进去的实参 如果按下面的写法，将newed对象置入智能指针中 分配函数(shared_ptr&lt;Widget>(new Widget), 资源访问); //不要这样写 需要执行一下函数 调用“资源访问”函数（A） 执行new Widget（B） 调用shared_ptr构造函数（C） 然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行） 如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏 所以简单的方法是分离语句 shared_ptr&lt;Widget> pw(new Widget); 分配函数(pw, 资源访问); 四：设计与声明 让接口容易被正确使用 客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记） 限制参数传递 这是一个日期类 class Date&#123; public: Date(int month, int day, int year); ... &#125;; ... Date d(4, 20, 2022); 客户很有可能填错顺序，也有可能填入一个无效的参数 可以使用外覆类型（wrapper types），当然做出类会更好 struct Day&#123; explict Day(int d) : val(d) &#123;&#125; int val; &#125;; struct Month&#123; explict Month(int m) : val(m) &#123;&#125; int val; &#125;; struct Year&#123; explict Year(int y) : val(y) &#123;&#125; int val; &#125;; class Date&#123; public: Date(const Mouth&amp; month, const Day&amp; day, const Year&amp; year); ... &#125;; ... Date d(Month(4), Day(20), Year(2022)); 一致性 自定义的行为要与内置类型的行为一致，比如你不能把operator*重载成operator+ 或则像STL中，容器的接口都很一致，比如size、push_back等等 设计class犹如设计type 对象要如何创建和销毁 对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作） 对象如果被值传递，意味着什么（深浅拷贝） 约束成员变量的合法值 是否可以/需要被继承 能否类型转换，如何类型转换 支持何种操作符 成员变量的访问修饰 成员函数的访问修饰 未声明接口（undecided interface） 是否需要定义模版 真的需要一个新类吗？ 多用引用传递 C++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些很大的自定义类型来说性能非常糟糕 使用const引用传递会好很多 不会创建新的对象 不会改变原有对象 可以避免对象切割问题 对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了 只不过引用传递是大多是通过指针实现的，在处理一些简单的内置类型时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递 必须返回对象时，不要返回引用 如果必须返回对象，请不要返回引用（比如operator*，operator==），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个右值的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用 将成员变量隐藏 成员变量应该为private，而不是public 客户只能通过成员函数访问变量，于是可以统一接口（全都是函数） 分离读写权限（这一点C#做的更好？） 封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问） 便于对成员变量进行约束（更不容易出现异常值） protected并不比public更具有封装性 使用非成员函数 C#，java选手可以略过 C++标准库就是这样写的 这里有一个类，其中有多个成员函数 class WebBrowser&#123; public: void doA(); void doB(); void doC(); ... &#125;; 现在需要令一个函数做ABC三件事，有两种写法 成员函数 class WebBrowser&#123; public: ... void doEverything()&#123; doA(); doB(); doC(); &#125; ... &#125;; 非成员函数 void doEverything(WebBrowser&amp; wb)&#123; wb.doA(); wb.doB(); wb.doC(); &#125; 令人意外的是，第二种方法（使用非成员函数）更好 什么是封装 一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强 为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物 为什么第二种比第一种封装性更强 因为第一种给用户两种调用方法，一个是调用成员函数doEverything()，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性 注意第一种方法中，doEverything()和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利 那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的静态成员（static member）函数即可 或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用） namespace WebBrowserStuff&#123; class WebBrowser&#123;...&#125;; void doEverything(WebBrowser&amp; wb)&#123;...&#125; &#125; 可拓展性更强 客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的） 可拆分 用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割） 如果所有参数都需要进行类型转换，使用非成员函数 令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时 比如一个有理数乘法 class Rational&#123; public: //这个类没有自定义的explict构造函数 const Rational opertaor* (const Rational&amp; rhs) const; ... &#125;; Rational oneEighth(1,8); Rational oneHalf(1,2); Rational result = oneHalf * oneEighth; //成功 result = result * oneEighth; //成功 result = oneHalf * 2; //成功，等价于 result = oneHalf.operator*(2) result = 2 * oneHalf; //失败，等价于 result = 2.operator*(oneHalf) result = oneHalf * 2;为什么成功，因为这里发生了一次隐式转换，将2转化为了一个Rational类型 在编译器中可能等价于 const Rational temp(2); result = oneHalf * temp; 如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将2转化为一个Rational类型 result = 2 * oneHalf; 为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时2就是一个int类型，没有我们所自定义的operator*函数，自然会失败 可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换） const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); &#125; 此外要极力避免使用友元（friend）函数 成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数 写一个不抛异常的swap函数 swap函数原本是STL的一部分，后来称为了异常安全性编程的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要 std是一个很特殊的命名空间，客户可以全特化（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定 全特化：针对某个类做模板函数的特例，如对std::swap做一个针对Widget的特化 class WidgetImpl&#123;...&#125;; //这个类的对象中存储着真正的数据 class Widget&#123; public: Widget&amp; operator=(const Widget&amp; rhs)&#123; ... *pImpl = *(rhs.pImpl); ... &#125; ... void swap(Widget&amp; other)&#123; //这个函数决对不可抛异常 using std::swap; swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针 &#125; ... private: WidgetImple* pImpl; //这个类有一个指向资源对象的指针 &#125;; namespace std&#123; template&lt;> void swap&lt;Widget>(Widget&amp; a, Widget&amp; b)&#123; //这个可以抛异常 a.swap(b); &#125; &#125; 此外，C++的STL容器就是上面这种写法，提供了public swap成员函数和std::swap的特化版本 五：实现（Implementations） 随意定义变量可能会导致性能降低 过度使用转型（casts）可能会导致性能降低，难以维护，可读性低 返回对象的内部数据的handles，可能会破坏封装 未考虑异常可能会导致资源泄露和数据败坏 过度使用inline可能会导致包体膨胀 过度耦合（coupling）可能会增加构建时间（build times） 尽量延后变量定义式的出现时间 避免未曾使用的变量 如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过 此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、 避免无意义的默认构造函数 如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好 循环 此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？ 循环内 for(int i = 0; i &lt; n; i++)&#123; Widget w(...); ... &#125; n个构造函数+n个析构函数 如果Widget是一个很敏感的类，这样会让其作用域更小，更容易理解和维护 循环外 Widget w; for(int i = 0; i &lt; n; i++)&#123; w = ...; ... &#125; 一个构造函数+一个析构函数+n个赋值操作 如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候） 少做转型 C++是强类型语言，设计目标应该是保证类型错误绝不发生，然而类型转换破坏了类型系统 Java、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险 C++的类型转化 旧式转换 (T)expression T(expression) 新式转换 const_cast&lt;T&gt;(expression) 用于将对象的常量性转除（cast away the constness） 比如将const转化为non-const dynamic_cast&lt;T&gt;(expression) 用来安全向下转型 无法由旧式语句执行 耗费巨大 reinterpret_cast&lt;T&gt;(expression) 用于低级转型，实际操作取决于编译器，不可移植 极其少用 static_cast&lt;T&gt;(expression) 用于强迫隐式转换（implicit conversions） 比如non-const转化为const，int转化为double，void*转化为typed，基类指针转化为派生类指针 避免C++类型转换出问题的核心是避免使用基类的接口处理派生类 一个对象多个地址 C++很神奇，如果一个基类指针指向一个派生类对象，如 Dervied d; Base* b &#x3D; &amp;d; 这可能会导致两个指针值不一样，即这个对象有两个地址，一个Derivied*指针一个Base*指针，这派生类指针上往往会有一个偏移量（offset），通过这个偏移量，可以通过派生类指针找到基类指针 上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以请不要假定对象在C++中如何布局，更不应该基于这个假设对对象进行类型转换 如果你想让当前对象调用基类的函数，如果对*this做强制转化，转换为基类，*this其实是先前产生的*this对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题 class SpecialWindow: public Window&#123; public: virtual void onResize()&#123; //static_cast&lt;Window>(*this).onResize(); //这样不好 Window::onResize(); //请用这种方式调用基类的onResize函数（作用到当前对象上） ... &#125; &#125; dynamic_cast 这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象 什么时候使用这个东西？当你想在一个你认为是派生类对象的对象上执行派生类的操作函数，但你手里却只有一个指向基类的引用/指针时 解决方法： 使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器 在基类中提供virtual函数 避免返回指向对象内部成分的handles 前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便 但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的 class Point&#123; public: ... void setX(int val); ... &#125;; struct RectData&#123; Point ulhc; //upper left hand corner Point lrhc; //lower right hand corner &#125;; class Rectangle&#123; public: ... Point&amp; upperLeft() const &#123; return pData->ulhc; &#125; //这样返回了引用，非常不好 ... private: std::tr1::shared_ptr&lt;RectData> pData; &#125;; ... rec.upperLeft().setX(50); //rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改 upperLeft函数本来只是为了提供给客户获得（get）Rectangle的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了Rectangle本身，而且还是一个内部数据RectData 为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器） 解决方法很简单，只要让handles不可以被修改，就可以了 class Rectangle&#123; public: ... const Point&amp; upperLeft() const &#123; return pData->ulhc; &#125; ... &#125;; 但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致dangling handles（空悬的号码牌），比如返回了一个对local变量的引用，依然特别危险 当然，有的时候不得不返回handles，比如operator[] 异常安全性很重要 **异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件： 不泄漏任何资源 不允许数据败坏 不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂 三个保证： 基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏 强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过copy-and-swap实现） 不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现） 异常安全码必须提供上述三种保障之一，如果不能保障，则不具备异常安全性 了解inline函数 内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化 缺点也很明显，会让包体变大，会导致换页行为（paging），会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数 内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联 降低文件间的编译依存 如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译 为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用） 这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类 话说应该不会有人不知道implementation是实现的意思吧 class PersonImpl; //pimpl写法，这是Person类的前置声明 class Data; //Data的前置声明 class Address; //Address的前置声明 class Persion&#123; //像这样使用pimpl的类，往往被称为Handle classes public: ... std::string name() const; ... private: std::tr1::shared_ptr&lt;PersonImpl> pImpl; &#125;; 在这种设计下，Person就与Data、Address以及Persons的实现分离了，改动这些类也不会导致使用Person的客户重新编译，客户无法看到Person的实现细节，真正实现接口与实现分离 这个操作的本质是用声明的依赖性替换定义的依赖性 此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明 此外还有另一种制作Handle class的方法，就是令Person成为一个特殊的抽象基类，称为Interface class，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数） class Person&#123; //Interface class public: virtual ~Person(); virtual std::string name() const = 0; ... &#125;; class Person&#123; //具现化 public: static std::tr1::shared_ptr&lt;Person> create(const std::string&amp; name...); ... &#125;; ... //使用 std::tr1::shared_ptr&lt;Person> pp(Person::create(name...)); std::cout &lt;&lt; pp->name(); class RealPerson: public Person&#123; public: RealPerson(const std::string&amp; name, ...): theName(name), ...&#123;&#125; virtual ~RealPerson() &#123;&#125; std::string name() const; ... private: std::string theName; &#125;; std::string ReakPerson::name()&#123;...&#125; std::tr1::shared_ptr&lt;Person> Person::create(const std::string&amp; name, ...)&#123; retrun std::tr1::shared_ptr&lt;Person>(new RealPerson(name, ...)); &#125; 六：继承与面向对象 is-a：是一个 has-a：有一个 is-implemented-in-terms-of：根据xx实现出 public继承是is-a关系 class Student: public Person&#123;...&#125;; //Student is a Person 每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化 public继承下，可以把子类当父类用，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用 这就出现了一个问题，子类一定要is a父类，不然会出现问题 错误的继承： 企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？ 正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？ 避免遮掩父类成员 int x; void Fun()&#123; double x; ... &#125; 由于作用域的名称遮掩规则，函数内部的local变量x覆盖了全局变量x 子类名称会遮掩父类名称，在public继承下是错误的 在OOP中，如果子类重载了父类的non-virtual函数，就意味着子类使用同名函数遮掩了父类函数，就意味着这个父类函数没有被子类继承！，那么在这种情况下，继承就不是is-a关系了 在public继承下，子类继承了父类的一切 class Base&#123; public: virtual void f1() = 0; virtual void f1(int); void f2(); void f2(double); ... private: int x; &#125;; class Derived: public Base&#123; public: virtual void f1(); void f2(); &#125;; ... Derived d; int x; d.f1(); //正确，调用Derived::f1 d.f1(x); //错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int) d.f2(); //正确，调用Derived::f2 d.f2(x); //错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double) 将被遮掩的名称重见天日 解决起来很简单，只需要让父类的函数在子类作用域内可见，可以使用using关键字 class Derived: public Base&#123; public: using Base::f1; using Base::f2; virtual void f1(); void f2(); &#125;; ... Derived d; int x; d.f1(); //正确，调用Derived::f1 d.f1(x); //正确，调用Base::f1 d.f2(); //正确，调用Derived::f2 d.f2(x); //正确，调用Base::f2 如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以使用转交函数，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中 class Derived: private Base&#123; public: virtual void f1()&#123; Base::f1(); //inline转交函数 &#125; ... &#125;; ... Derived d; int x; d.f1(); //正确，调用Derived::f1 d.f1(x); //错误，因为Derived::f1遮掩了Base::f1 区分接口继承和实现继承 public继承分为两个部分 函数接口继承 函数实现继承 接口继承 实现继承 纯虚函数 具体指定 不继承 非纯虚函数 具体指定 继承一份缺省实现 non-virtual函数 具体指定 继承一份强制实现 考虑使用virtual以外的选择 基于NVI的Template Method模式 Non-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数 class GameCharacter&#123; public： int healthValue() const &#123; ... int retVal = doHealthValue(); ... return retVal; &#125; private： virtual int doHealthValue() const &#123; ... &#125; &#125;; 其中healthValue()被称为virtual函数的外覆器（wrapper） 基于函数指针的Strategy模式 class GameCharacter; int defaultHealthCalc(const GameCharacter&amp; gc); class GameCharacter&#123; public: typedef int (*HealthCalcFunc)(const GameCharacter&amp;); explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125; int healthValue() const &#123; return healthFunc(*this); &#125; ... private: HealthCalcFunc healthFunc; &#125;; 在这种模式下，defaultHealthCalc函数不再是GameCharacter体系内的成员函数，通过修改函数指针，就可以让GameCharacter使用不同种类的计算函数，弹性更强，而且可以在运行时变更 此外defaultHealthCalc函数不需要/不能访问GameCharacter内的non-public部分， 基于tr1::function的Strategy模式 上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如tr1::function对象 class GameCharacter; int defaultHealthCalc(const GameCharacter&amp; gc); class GameCharacter&#123; public: typedef std::tr1::function&lt;int (const GameCharacter&amp;)> HealthCalcFunc; explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125; int healthValue() const &#123; return healthFunc(*this); &#125; ... private: HealthCalcFunc healthFunc; &#125;; 古典的Strategy模式 class GameCharacter; class HealthCalcFunc&#123; public: ... virtual int calc(const GameCharacter&amp; gc) const&#123;...&#125; ... &#125;; HealthCalcFunc defaultHealthCalc; class GameCharacter&#123; public: explicit GameCharacter(HealthCalcFunc* phcf = &amp;defaultHealthCalc): pHealthFunc(phcf)&#123;&#125; int healthValue() const &#123; return phealthFunc->calc(*this); &#125; ... private: HealthCalcFunc* pHealthFunc; &#125;; 绝不重新定义继承而来的non-virtual函数 静态绑定（staticcally bound）：non-virtual就是这种 动态绑定（dynamically bound）：virtual就是这种 class B&#123; public: void f(); ... &#125;; class D: public B&#123; public: void f(); ... &#125;; ... D x; B* pB = &amp;x; D* pD = &amp;x; pB->f(); //调用B::f pD->f(); //调用D::f 绝对不重新定义继承而来的缺省参数值 virtual函数是动态绑定的，缺省参数值是静态绑定的 class Cricle: public Shape&#123;...&#125;; ... Shape* p1; //p1的静态类型是Shape*，没有动态类型 Shape* p2 = new Circle; //p2的静态类型是Shape*，动态类型是Circle* 静态类型 指针的类型就是静态类型 动态类型 所指向的对象的类型是动态类型 动态类型可以通过赋值等操作改变 virtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载 但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数 has-a和根据xx实现出 一个类中有多个小类，这种关系被称为复合（composition），其中这些小类被称为合成成分物（composed object） 在应用域，复合意味着has-a 人有名字（也不尽然） 在实现域，复合意味着is-implemented-in-terms-of 队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现） 少用private继承 经典 C++糟粕，请问 C#有这个吗？ 本质上是一种is-implemented-in-terms-of关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术 private继承，编译器无法自动将子类对象转化为父类对象 private继承，父类中所有属性变成private类型（比如父类中的public、protected类型） 尽量使用复合来替代pirvate继承，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数 此外private继承的对象有可能比复合的对象要小 少用多重继承 经典 C++糟粕，请问 C#有这个吗？ 可能会导致歧义 当然你可以在调用函数的时候指出是来自哪一个基类 可能会导致菱形继承 菱形继承可能会导致变量重复 七：模版与泛型 模板（templates）是泛型编程（generic programming）的基础 模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译 评价 优点： 模板编程能够实现非常灵活且类型安全的接口 极好的性能（更小的文件、更短的运行期，更少的内存需求） 可以将一些运行时才能侦测到的错误，在编译期找出来 缺点： 难以编程和维护 编译报错信息难以理解 难以重构 编译时间大幅变长 因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释 隐式接口和编译期多态 OOP中经常使用显式接口和运行时多态 泛型编程更多使用隐式接口和编译期多态 template&lt;typename T&gt; void doProcessing(T&amp; w) &#123; if(w.size() &gt; 10 &amp;&amp; w !&#x3D; someNastyWidget)&#123; T temp(w) temp.normalize(); temp.swap(w); &#125; &#125; 从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组隐式接口 所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功 这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是编译期多态 Traits 一种约定俗成的技术方案，为同一类数据提供统一的操作函数 比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。 enum Type&#123; TYPE_1; TYPE_2; &#125;; class FOO&#123; Type type &#x3D; Type::TYPE_1; &#125;; class Bar&#123; Type type &#x3D; Type::TYPE_2; &#125;; &#x2F;&#x2F;统一的模板函数 template&lt;typename T&gt; void decode(const T&amp; data, char* buf)&#123; if(T::type &#x3D;&#x3D; Type::TYPE_1)&#123; ... &#125; else if(T::type &#x3D;&#x3D; Type::TYPE_2)&#123; ... &#125; &#125; 但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术 enum Type&#123; TYPE_1; TYPE_2; &#125;; class FOO&#123; Type type &#x3D; Type::TYPE_1; &#125;; class Bar&#123; Type type &#x3D; Type::TYPE_2; &#125;; template&lt;typename T&gt; struct type_traits&#123; Type type &#x3D; T::type; &#125; &#x2F;&#x2F;为内置数据类型特化为独有的 type_traits template&lt;typename int&gt; struct type_traits&#123; Type type &#x3D; Type::TYPE_1; &#125; &#x2F;&#x2F;统一的模板函数 template&lt;typename T&gt; void decode(const T&amp; data, char* buf)&#123; if(type_traits&lt;T&gt;::type &#x3D;&#x3D; Type::TYPE_1)&#123; ... &#125; else if(type_traits&lt;T&gt;::type &#x3D;&#x3D; Type::TYPE_2)&#123; ... &#125; &#125; 该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因 模板元编程 TMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化 如果一门语言具备以下功能，则称为图灵完全 数值运算和符号运算 判断 递归 数值运算+递归 &#x2F;&#x2F;一个TMP计算阶乘，而且阶乘的技术发生在编译期 template&lt;unsigned n&gt; struct Factorial &#123; enum &#123; value &#x3D; n * Factorial&lt;n-1&gt;::value &#125;; &#125;; template&lt;&gt; struct Factorial&lt;0&gt; &#123; enum &#123; value &#x3D; 1 &#125;; &#125;; int main() &#123; std::cout &lt;&lt; Factorial&lt;5&gt;::value; &#125; C++11TMP这种函数式编程得到了加强，上文也可以这样写 template&lt;unsigned n&gt; struct Factorial &#123; constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;; &#125;; template&lt;&gt; struct Factorial&lt;0&gt; &#123; constexpr static auto value &#x3D; 1; &#125;; 判断 template&lt;bool Value&gt; struct if_constexpr &#123; constexpr static auto value &#x3D; 1; &#125;; template&lt;&gt; struct if_constexpr&lt;false&gt; &#123; constexpr static auto value &#x3D; 2; &#125;; int main() &#123; std::cout &lt;&lt; if_constexpr&lt;true&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; if_constexpr&lt;false&gt;::value &lt;&lt; std::endl; &#125; typedef 在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名 下面是一个函数指针的示例 void add(int x, int y) &#123; std::cout &lt;&lt; &quot;x+y&#x3D;&quot; &lt;&lt; x + y &lt;&lt; std::endl; &#125; void dec(int x, int y) &#123; std::cout &lt;&lt; &quot;x-y&#x3D;&quot; &lt;&lt; x - y &lt;&lt; std::endl; &#125; void mul(int x, int y) &#123; std::cout &lt;&lt; &quot;x*y&#x3D;&quot; &lt;&lt; x*y &lt;&lt; std::endl; &#125; void (*op[3])(int, int) &#x3D; &#123; add, dec, mul &#125;; int main() &#123; for (int i &#x3D; 0; i &lt; 3; ++i) &#123; （*op[i])(4, 3); &#125; &#125; 如果使用typedef typedef void (*Func[3])(int, int); Func f &#x3D; &#123; add, dec, mul &#125;; int main() &#123; for (int i &#x3D; 0; i &lt; 3; ++i) &#123; f[i](4, 3); &#125; &#125; 八：定制new和delete Java和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目 new-handler 当operator new无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即new-handler 使用set_new_handler来指定new-handler void outOfMem()&#123; std::cerr &lt;&lt; \"内存不足\\n\"; std::abort(); &#125; int main()&#123; std::set_new_handler(outOfMem); //该函数的参数是一个函数指针 int* array = new int[10000000L]; ... &#125; 当operator new无法满足内存申请时，会不断调用new-handler函数，直到找到足够的内存，所以new-handler函数应该满足 让更多的内存可被使用 实现方法是程序开始时就分配一大块内存，每次调用new-handler时就释放一点点 安装另一个new-handler 如果现在这个new-handler无法获取更多内存，需要知道哪一个new-handler具备增大内存的实力，然后使用set_new_handler来替换自己 卸除new-handler 通过set_new_handler赋值null，将new-handler卸载，使得在内存分配不足时，会抛异常 抛出bad_alloc异常 这种异常不会被operator new捕获，会被传播至内存索求处 不反回 调用abort或者exit class NewHandlerHolder&#123; public: explicit NewHandlerHolder(std::new_handler nh): handler(nh) &#123;&#125; //获取当前的new_handler ~NewHandlerHolder() &#123; std::set_new_handler(handler); &#125; private: std::new_handler handler; //用于记录当前的new_handler &#125;; void* Widget::operator new(std::size_t size) throw(std::bad_alloc)&#123; NewHandlerHolder h(std::set_new_handler(currentHandler)); //安装Widget的new-handler return ::operator new(size); //分配对象或者抛异常 &#125; //离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值 void outOfMem(); Widget::set_new_handler(outOfMem); Widget* pwl = new Widget; //内存不足时会调用outOfMem mixin风格的写法 template&lt;typename T> class NewHandlerSupport&#123; public: static std::new_handler_set set_new_handler(std::new_handler p) throw(); static void* operator new(std::size_t size) throw(std::bad_alloc); ... private: static std::new_handler currentHandler; &#125;; template&lt;typename T> std::new_handler NewHandlerSupport&lt;T>::set_new_handler(std::new_handler p) throw()&#123; std::new_handler oldHandler = currentHandler; currentHandler = p; return oldHandler; &#125; template&lt;typename T> void* NewHandlerSupport&lt;T>::operator new(std::size_t size) throw(std::bad_alloc)&#123; NewHandlerHolder h(std::set_new_handler(currentHandler)); return ::operator new(size); &#125; class Widget: public NewHandlerSupport&lt;Widget>&#123; ... &#125;; 像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为怪异的循环模版模式（curiously recurring template pattern，CRTP） 替换new和delete的时机 C++中所有的news返回的指针都必须要地址对齐，int要4对齐，double要8对齐 写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换 编写new和delete的规则 如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则 new 应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用new-handler 有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请） new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理比正确大小更大的（错误）申请 delete 收到null指针时不做任何事 处理比正确大小更大的（错误）申请 编写new时也要写对应的delete Widget* pw = new Widget; 在这里调用了两个函数，一个时用以分配内存的operator new，一个是Widget的构造函数 如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的 运行时系统会调用operator new所对应的operator delete来释放地址，对于拥有正常签名式的new和delete来说不成问题 void* operator new(std::size_t) throw(std::bad_alloc); //普通的new void operator delete(void* rawMemory) throw(); //global中的普通的new void operator delete(void* rawMemory, std::size_t size) throw(); //class中的new 但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题 void* operator new(std::size_t, void* pMemory) throw(); //placement new，比普通new多带一个参数 Widget* pw = new (std::cerr) Widget; //调用operator new，并以cerr作为其实参 当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的operator new时如何运作的，所以运行时系统会去寻找参数个数与类型都与operator new相同的某个operator delete void operator delete(void*, std::ostream&amp;) throw(); //palcement delete class Widget&#123; public: static void* operator new(std::size_t size, std::ostream&amp; logStream) throw(std::bad_alloc); static void operator delete(void* pMemory) throw(); static void operator delete(void* pMemoty, std::ostream&amp; logStream) throw(); ... &#125;; 如果此时调用delete pw，只会调用普通的delete，因为只有在构造时发生异常时，运行时系统才会调用placement delete 最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete 九：杂项 不要忽视编译器警告 很多人忽视警告，毕竟一个问题如果真的很严重，应该报错 比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为 class B&#123; public: virtual void f() const; &#125;; class D: public B&#123; virtual void f(); &#125;; 报警告 warning: D::f() hides virtual B::f() 原本的目的是为了在D中重新定义virtual函数f()，但由于B中f()是const，在D中不是，此时B中的f()并没有在D中重新被声明，而是被整个遮掩了 去熟悉标准程序库 尤其是TR1 C++98有什么 STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器 Iostream 国际化支持 数值处理，包括复数（complex）和纯数值数组（valarray） 异常阶层体系 C89标准程序库 TR1有什么（全在std::tr1中） 智能指针tr1::shared_ptr和tr1::weak_ptr tr1::function tr1::bind 和（彼此无关的独立组件） 哈希表 正则表达式 Tuple变量组 tr1::array tr1::mem_fn tr1::reference_wrapper 随机数生成工具 数学特殊函数 C99兼容 和（基于template） Type traits tr1::result_of 熟悉Boost","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://reubensun.com/tags/C/"}]},{"title":"Ubuntu入门","slug":"program/Ubuntu入门","date":"2023-01-31T10:01:25.000Z","updated":"2023-03-28T02:56:19.637Z","comments":true,"path":"program/Ubuntu入门/","link":"","permalink":"https://reubensun.com/program/Ubuntu%E5%85%A5%E9%97%A8/","excerpt":"","text":"Ubuntu入门 虽说是Ubuntu，实际上是WSL2 你可以使用neofetch查看系统信息 环境搭建 VS Code 在Windows系统中安装VS Code，并选择添加PATH 在WSL中如果要打开当前目录，直接输入 $code . 推荐安装VS Code的WSL插件 使用快捷键CTRL+SHIFT+P，打开命令面板，键入WSL，进行一些设置 Git 使用Git前需要先配置git config，可以输命令，也可以无脑用vscode改.gitconfig文件 $git config --global user.name \"Your Name\" $git config --global user.email \"youremail@domain.com\" 常用命令 命令 意义 ls -a 查看当前目录内容 cd 路径名 路径跳转 clear 清空窗口 find 文件名 找出当前文件夹内符合条件的文件 支持正则 whoami 查看当前用户身份 pwd 查看当前工作目录 cat test.txt 查看文件内容 cat &gt; new.txt 新建文件 cat file1 file2 &gt; file 合并文件 mkdir 文件夹名 创建文件夹 -p可以创建多级文件夹 cp src dst 复制文件 kill 进程名 杀死进程 unzip 解压zip文件 需要先安装unzip rm test.txt 删除文件 -r递归删文件夹 -f强删 文件访问 Windows访问Linux文件，路径为\\\\wsl$\\Ubuntu-20.04\\home\\username Linux访问Windows文件，路径为/mnt/c/Users/username apt-get Linux内置的包管理器，可以非常优雅地安装管理各种包、软件 安装 #安装git $sudo apt-get install git #安装tbb $sudo apt-get install libtbb-dev 查看所有已安装软件 #查看所有已安装软件（这个信息量巨大，而且有重复信息，不简易使用） $sudo apt-cache search all #查看所有已安装软件（去重） $sudo apt-cache search all | wc #查看所有名字中带gcc的软件 $sudo apt-cache search all | grep gcc E: Unable to locate package 如果遇到这个报错，可以执行一次更新 $sudo apt-get update C++安装清单 包名 描述 g++ C++编译器 libtbb-dev tbb并行库 cmake 项目构建 git 版本管理 gfortran fortran编译器 liblapack-dev、liblapacke-dev BLAS和LAPACK线代库 gdb 调试器 Git使用 拉取项目 项目拉取有两种常见方法 ssh：需要配置SSH Key，只能拉自己的项目，但不提交时不需要账号密码 https：非常方便，只需要git clone，而且可以拉别人的项目，但提交时需要输入账号密码 其实你也可以在输入一次密码后输入 $git config --global credential.helper store 我们这里说的密码是token，可以去Github生成token 提交 #添加要提交的内容 $git add 文件名/文件夹名 #提交所有内容（不包含忽略文件），并设置提交信息为“这是一段话” $git commit -a -m 这是一段话","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://reubensun.com/tags/Linux/"}]}],"categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"},{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"},{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"},{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"},{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"},{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"},{"name":"C++","slug":"C","permalink":"https://reubensun.com/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://reubensun.com/tags/leetcode/"},{"name":"GC","slug":"GC","permalink":"https://reubensun.com/tags/GC/"},{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"},{"name":"PM","slug":"PM","permalink":"https://reubensun.com/tags/PM/"},{"name":"GI","slug":"GI","permalink":"https://reubensun.com/tags/GI/"},{"name":"SIGGRAPH","slug":"SIGGRAPH","permalink":"https://reubensun.com/tags/SIGGRAPH/"},{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"},{"name":"Metal","slug":"Metal","permalink":"https://reubensun.com/tags/Metal/"},{"name":"Deferred Render","slug":"Deferred-Render","permalink":"https://reubensun.com/tags/Deferred-Render/"},{"name":"SPH","slug":"SPH","permalink":"https://reubensun.com/tags/SPH/"},{"name":"Physics","slug":"Physics","permalink":"https://reubensun.com/tags/Physics/"},{"name":"TA","slug":"TA","permalink":"https://reubensun.com/tags/TA/"},{"name":"并行计算","slug":"并行计算","permalink":"https://reubensun.com/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"name":"CMake","slug":"CMake","permalink":"https://reubensun.com/tags/CMake/"},{"name":"C#","slug":"C","permalink":"https://reubensun.com/tags/C/"},{"name":"Windows","slug":"Windows","permalink":"https://reubensun.com/tags/Windows/"},{"name":"Unreal","slug":"Unreal","permalink":"https://reubensun.com/tags/Unreal/"},{"name":"DX12","slug":"DX12","permalink":"https://reubensun.com/tags/DX12/"},{"name":"shader","slug":"shader","permalink":"https://reubensun.com/tags/shader/"},{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"Linux","slug":"Linux","permalink":"https://reubensun.com/tags/Linux/"}]}