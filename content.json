{"meta":{"title":"ReubenSun","subtitle":"","description":"Reuben的笔记博客","author":"Reuben Sun","url":"https://reubensun.com","root":"/"},"pages":[{"title":"所有分类","date":"2025-03-18T07:16:37.541Z","updated":"2025-03-18T07:16:37.541Z","comments":true,"path":"categories/index.html","permalink":"https://reubensun.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-03-18T07:16:37.541Z","updated":"2025-03-18T07:16:37.541Z","comments":true,"path":"tags/index.html","permalink":"https://reubensun.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"痛苦装库记录","slug":"program/InstallPackage","date":"2025-02-19T10:01:25.000Z","updated":"2025-03-18T07:16:42.967Z","comments":true,"path":"program/InstallPackage/","permalink":"https://reubensun.com/program/InstallPackage/","excerpt":"","text":"痛苦装库记录 感觉下别人的开源代码，并尝试跑通，真的非常痛苦，尤其是一些库死活安装不成功，感觉在浪费生命，于此记录一下 torchsparse 这是一个一个用于处理稀疏张量的PyTorch扩展库，通常用于3D点云处理和相关任务，torchsparse 我一直安装不成功，因为缺少了文件： /data/torchsparse/torchsparse/backend/hashmap/hashmap_cpu.hpp:7:10: fatal error: google/dense_hash_map: No such file or directory 7 | #include &lt;google/dense_hash_map&gt; 解决方法： conda install google-sparsehash -c biocondaexport PATH=/home/sunzheng/miniconda3/envs/&#123;name&#125;/include:$PATH flash_attn flash-attention 去github release中找对应的whl文件 wget https://github.com/Dao-AILab/flash-attention/releases/download/v2.7.3/flash_attn-2.7.3+cu11torch2.1cxx11abiFALSE-cp310-cp310-linux_x86_64.whlpip install flash_attn-2.7.3+cu11torch2.1cxx11abiFALSE-cp310-cp310-linux_x86_64.whl cu11：表示cuda11.x版本（cu12表示cuda12.x版本） torch2.1 cxx11 abiFALSE cp310：cpython版本，与python版本一致","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://reubensun.com/tags/Linux/"}]},{"title":"AI 常用术语","slug":"ai/AI常用术语","date":"2025-02-05T18:30:25.000Z","updated":"2025-03-18T07:16:48.448Z","comments":true,"path":"ai/AI常用术语/","permalink":"https://reubensun.com/ai/AI%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD/","excerpt":"","text":"AI 常用术语 记录一些AI常用术语 机器学习 任务 回归（Regression）：预测连续型变量的值，如股票预测 分类（Classification）：预测离散型变量的类别，如图像分类 聚类（Clustering）：将数据划分为不同的组别，使得组内的相似性最大化，组间的相似性最小化，例如客户细分、图像分割 降维（Dimensionality Reduction）：减少数据的维度，同时保留数据中的重要信息，例如主成分分析（PCA） 异常检测 序列预测 推荐系统 强化学习 生成模型 最大似然估计（Maximum Likelihood Estimation，MLE） SOTA State of the Art 表示在某个特定领域中的最好成果、最佳实践 良定义 Well-Defined 一个定义要满足：明确性、一致性、完备性、无歧义性 明确性：明确指出所定义对象的范围和特征 一致性：定义不能自相矛盾 完备性：定义要包含足够的信息，使得人们可以通过定义判断一个对象是否属于定义的范围 无歧义性：定义要避免使用含糊不清、多义词 代价函数 Focal Loss F0 Loss 一种用于解决类别不平衡问题的损失函数，通过引入动态缩放因子，降低易区分样本的权重，将模型的注意力集中在难区分样本上 梯度下降 学习率 分类 Softmax 与之对应的是Hardmax，我们在四个（不同的）数据中找最大值，结果是一个1，三个0。而Softmax会给四个浮点数，max的数对应的值最大，但不为1，其他数小，但不为0 监督学习 Supervised Learning 从一组标记好的输入和期望出发，得到一个 $x\\rightarrow y$ 的映射，目的是泛化知识，输入未标记的数据也能得到标记 由于需要提供正确答案，导致标注量和成本很大 分类问题 回归问题 偏好学习 Preference Learning 模型不是直接预测一个目标值（如在回归问题中）或一个类别标签（如在分类问题中），而是预测一个偏好顺序或者选择。这种偏好可以是全序的（例如，对一组电影进行排名），也可以是部分的（例如，只确定哪部电影比另一部更受欢迎，而不是对所有电影进行排名）。 无监督学习 Unsupervised Learning 输入没有标签，系统会从数据中特征提取，从而可以将数据进行聚类、分类 聚类 MAE Masked Autoencoders 以一定比例mask掉图片中一些像素块、文本中一些内容，让模型去预测mask的部分。 自监督学习 Self-Supervised Learning 对比学习：一种自监督学习方法，让相似的数据在嵌入空间中更近，不相似的更远，会有数据增强、映射、对比损失等过程，在多模态中很常用 强化学习 Reinforcement Learning, RL 比如我们要设计一个自动驾驶的汽车，这个车我们称之为智能体，学习驾驶是一种行为，车当前的速度、位置等数字向量是车的当前状态，刹车、加速、转向是车的动作，根据当前状态决定动作是车的策略，如果这个策略好，应当给与奖励，这种反馈机制被称为奖励，汽车不能控制的其他事物被称为环境 强化学习最初没有系统的先验知识，而是进行探索和收集反馈，不断调整自己的动作，最终得到目标 详情请看强化学习 策略梯度算法 参考 我们希望能够得到最大化的奖励期望，于是对上面的期望$\\bar{R}{\\theta}$做梯度下降 生成模型 无条件生成（Unconditional Generation），如无条件生成蝴蝶图片 条件生成（Conditional Generation），如T2I 常见的生成模型有 VAE GAN AR Diffusion VAE Variational Autoencoder 变分自编码器，在自编码器的基础上显性对$z$的分布$p(z)$进行建模，使得潜在空间（latent space）符合高斯分布，在潜在空间按高斯分布采样，再用decoder解码，就能生成数据 AE 自编码器AE是一种高级的PCA（主成分分析），由encoder和deocder组成，encoder可以将数据降维到潜在空间，decoder可以将潜在空间的数据还原为原始数据 AE不能用作生成模型，因为没有针对$z$的分布进行训练，在整个值域中有效的$z$非常少，随机采样到的基本都是无意义的$z$ Conditional VAE 我们在VAE的值域中采样，总是能得到有用的$z$，但是我们不知道到底是哪一种$z$ 做法是引入标注$Y$，原本对$p_0(X)、p(z)$建模，现在改为对$p_0(X|Y)、p(z|y_i)$建模 VQVAE 潜在空间是一组整数，常用于数据降维，也不能用作生成模型 GAN Generative Adversarial Network 由生成器（Generator）和判别器（Discriminator）组成 生成器负责从噪声中生成与真实数据尽可能相似的数据，判别器负责区分真实数据还是生成的数据 自回归模型 Autoregressive Model, AR 利用时间序列自身的过去值来预测未来值，可以通过逐步生成数据的每一部分来构建整个数据样本 扩散模型 Diffusion Models 一种深度生成模型，能基于一个噪声和一组参数，生成数据，包含前向加噪和反向去噪两个步骤 前向加噪会逐步在原始数据中添加高斯噪声（马尔可夫链），直到数据被破坏，失去可辨别性 $$ x_t = x_{t-1} + \\sqrt{1-\\beta_t} \\cdot \\epsilon_t $$ $\\epsilon$：噪声样本 $\\beta$：噪声强度 反向去噪是训练一个神经网络，能使用噪声样本来还原原始数据，去噪声过程也是逐层进行的 $$ \\widetilde{x} = x_T - \\sum^{T}_{t=1}\\alpha_t \\cdot \\epsilon_t $$ $x_T$：前向扩散结束时的完全噪声样本 LDM latent diffusion model 在潜在空间进行扩散过程，大幅降低计算成本 召回率 Recall 样本中的正例有多少被预测正确了 $$ \\text{Recall} = \\frac{\\text{TP}}{\\text{TP} + \\text{FN}} $$ TP（True Positive）：预测为正例且实际为正例的数量。 FN（False Negative）：预测为负例但实际为正例的数量 精确率 Precision 预测为正的样本中有多少是真正的正样本 $$ \\text{Precision} = \\frac{\\text{TP}}{\\text{TP} + \\text{FP}} $$ FP（False Positive）：预测为正例但实际为负例的数量。 决策树模型 MCTS Monte Carlo Tree Search 蒙特卡洛树搜索，一种得到最优决策的方法，通过大量的随机模拟（构建搜索树），来评估每个节点的价值 消融实验 Ablation Study 用于确定一个条件或参数对结果的影响程度，通过去除或修改模型的某种组成，观察其对模型性能的影响，进而分析这些组成对整体的贡献 神经网络 参考 https://www.asimovinstitute.org/neural-network-zoo/ 前向传播 激活函数 由于”线性函数的线性函数，还是一个线性函数“，而对神经元进行加权求和是一个线性操作，为了让模型能表示一些非线性的东西，我们需要激活函数 $$ a=f(z) $$ $f$：激活函数，任意一个非线性函数，常见为ReLU、Sigmoid $z$：上一神经元的加权求和结果 MLP Multilayer Perceptron 多层感知器，一种最简单的前馈神经网络 前馈（Feedforward）是一种控制机制，通过在系统受到干扰之前就采取行动来预测和补偿干扰的影响，具有预测性 前馈的反义词是反馈，在生物学中很常见 CNN Convolutional Neural Network，卷积神经网络 由卷积层、全连接层、池化层等部分组成 CNN模型结构中，卷积带来了局部性，使用相同卷积核带来了平移等变性，这些性质被称为先验知识（prior knowledge） 全连接层 该层每个神经元，都与上一层所有神经元相连。参数量会非常巨大，mxn 卷积层 卷积层=局部连接+空间权重共享 局部连接：卷积层的每个神经元只与输入数据的局部区域相连，而不是与整个输入数据相连（相邻像素相关性通常比远距离的像素大） 空间权重共享：使用相同的卷积权重在不同位置提取相同特征（图像的底层特征，如边缘，通常与具体位置无关） 池化层 使用一个滑动窗口在神经元间操作，如求最大值（最大池化），求平均值（平均池化） 池化层的目的是降采样，生成一个尺寸更小的特征图 池化层可以实现局部不变性：窗口内发生微小抖动，但仍旧可以得到相同/相似的特征表示 RNN Recurrent Neural Network，循环神经网络，参考Understanding-LSTMs $$ y_t=f(y_{t-1}, x_t) $$ 能够处理序列变化的数据（能够理解同一数据在不同上下文中含义不同） 由于RNN依赖先前的输出结果（RNN不是前馈的），因此对GPU并不友好 LSTM 长短期记忆，比RNN在长序列中表现更好 RNN的一个问题是，他无法从先前的关键词中有选择地提取重要信息 图中$\\sigma$表示数据转为0或1 RNN的一大问题是顺序执行，节点的输入是上一节点的输出，有依赖关系 Transformer Transformer一种基于Attention的神经网络架构，放弃了顺序循环，完全通过注意力机制（Attention）来建立输入和输出的依赖关系，具有更强的并行性 Attention结构 左侧是encoder，右侧是decoder，两者可以单独使用，也可以一起使用 Attention的参数不在于依赖关系，而与QKV有关 Query：查询 Key：键 Value：值 Attention的机制是求输入的Query和Key，计算Q和K的相似性程度（越接近点积越接近1，越正交点积越接近0），使用相似性权重对Value做加权求和 # 求QKVquery = attn.to_q(hidden_states)key = attn.to_k(hidden_states)value = attn.to_v(hidden_states)# 计算QK相似性attention_probs = attn.get_attention_scores(query, key, attention_mask)# 与V加权求和hidden_states = torch.bmm(attention_probs, value) encoder 如bert encoder输入文本，将其转化为embeding或feature（每个单词变成一组数字），具有双向性 双向性：指生成某个单词的embeding时，会同时受到前后单词的影响 tokenizer可以实现将一句话分离为一组单词 decoder 如gpt-2，目前最流行的就是decoder-only decoder通常具有encoder相同的能力，但是性能较弱，同样可以输入文本输出embeding，但是单向的 单向：decoder在生成单词embeding时，只会受前面的单词的影响 decoder通常是自回归的，常用于给定先前序列，生成新的内容（causal language modeling） encoder-decoder 如T5 将两者合并得到encoder-decoder，可以用于seq2seq（Sequence-to-Sequence） encoder将序列输入转为一个固定长度的上下文向量（embedding） embedding和单词输入到decoder，生成一个新单词WORD_1 将新单词WORD_1拼接到第一个单词后面，自回归调用decoder，生成下一次单词WORD_2 循环直到decoder输出出结束符号 Self-Attention 自注意力 Self-Attention是一种Attention，Self-Attention是计算单一序列内部每个元素和其他元素的关联程度，QKV均来自目标序列 由于递归能力更强，参数少，被广泛使用 Cross-Attention 交叉注意力 Cross-Attention也是一种Attention，输入两个不同的序列，Q来自Source序列，KV来自Target序列，可以建立序列间的联系 在SD画图中，使用Cross-Attention建立文本和latent区域的联系，实现文本修改图像中某一区域 Causal-Attention 因果注意力 Causal-Attention也是一种Attention，通过掩盖（Mask）未来的位置，使得模型生成时只关注过去的信息。通过因果注意力，使得Transformer具有自回归属性（Autoregressive） FeedForward 前馈层，接受Attention的输出，添加非线性变换 处理序列的优势 参考Civ的回答 - 知乎 Transformer由于使用了Attention，在处理序列数据时具有优势，下图为RNN、CNN、Attention表示序列模型示意。 三行绿色节点表示这些模型都是三层结构，都是从下向上依次执行 横着向右表示时间步骤 箭头表示相关联（并不代表可训练参数） RNN CNN Attention 上下文长度 full limited full 是否前馈 不前馈 前馈 前馈 问题 优化不行 卷积核太小 没问题 如果我们想要模型理解“小明在星期天要去露营，他准备叫上小红”，那么模型需要理解“他”指的是“小明”，那么模型的上下文需要同时看到“小明”和“他” CNN使用一个滑动窗口在文本中卷积，如果我们的滑动窗口比较小，那么一个窗口中就无法同时包含“小明”和“他”，为此我们需要对窗口的信息再次卷积，即增加CNN的深度，不断加深使得“小明”和“他”的距离越来越近，最后能被一个滑动窗口捕捉到 RNN使用上一步的输出结果，先前的输入都会被汇总到一起，理论上“小明”对应的信息是可以传播打”他“这一步的，但实践中RNN训练极易导致梯度爆炸，一般最多只能处理二十个词 而注意力机制允许每个神经元在任何时间点，看先前所有步骤中的任意节点，计算一个新单词时，同时用到了先前所有词 应用 GPT Generative Pre-trained Transformer 一个语言模型，输入句子前缀，预测下一个单词 Diffusion Transformer DiT VIT Vision Transformer 基于Transformer的计算机视觉技术，将大模型NLP和CV整合在一起 深度学习 “深度学习是一种表示学习”——何凯明 LeNet 开创了卷积层、池化层、全连接层，并使用反向传播端到端训练整个架构，参考CNN。但受困于算力和数据集过少没有得到重视 端到端 end to end AI系统直接从输入数据中学习，并产生期望的输出，无需人为分解中间步骤 流程简单，但非常黑盒，不可解释，会发生灾难性遗忘 AlexNet 论文地址 使用了更大的数据集（ImageNet）和更大模型 结构 一共八层 稀疏激活 Sparse Activation 稀疏激活是指在神经网络中，大部分神经元的输出为0（或接近0），只有少量神经元输出非零值 使用稀疏激活可以提高计算效率，加速收敛，降低损失 通常通过使用特定的激活函数（activation function）实现，比如ReLU（Rectified Linear Unit） $$ f(x)=\\max(0, x) $$ 多GPU训练 单个GPU的显存太小，无法放下训练数据，由于当时显卡具有交火功能，可以直接从另一张卡中读写数据，于是作者将模型平分放在两张卡上 为了减少GPU间通信，模型被设计为好几层，只有在某些层（C3）两张卡才会进行数据通信，其他层的输入只使用当前GPU中上一层的输出，大幅减少了通信次数 LRN Local Response Normalization 对模型的输出进行归一化，以提高模型泛化的能力 重叠池化 Overlapping Pooling 重叠池化的池化窗口在特征图上滑动时存在重叠部分。通过增加特征冗余性、减少空间信息损失、增强特征不变性、提高尺度不变性和降低特征维度等方式，有助于防止模型在训练过程中发生过拟合现象 数据增强 Data Augmentation 在不实质增加数据的情况下，扩展训练数据的方法 对图片旋转、缩放、裁剪、通道变换 对文本替换、插入、删除、同义替换 对语音添加噪声、改变语速、改变音调 dropout 对神经元的输出结果进行随机丢弃（以概率$\\mathbf{p}$置零） dropout很显然会影响神经元输出的均值，毕竟白白多出了这么多0，从x降到(1-p)x model.eval()后，模型将不会dropout，为了实现训练和推理的一致性，模型所有神经元都会输出，但是每个输出都会乘以(1-p)，以保证绝对值均值一致 Visualizing ConvNet 对神经网络进行可视化，发现神经网络可以学习数据的高级表示。并发现模型是可迁移的，可以在大数据集中预训练出能力，再在小数据集中fine-tune 迁移学习 模型能够学习大数据集中数据的抽象表示，这种表示在其他类似的小数据集中也有意义，于是我们可以在大数据集中做预训练，在其他数据集中做fine-tune One-Shot Learning、few-shot learning是一种特殊的迁移学习，仅使用一个（或很少的）样本进行学习，使得模型可以识别新的类型。在人脸识别、物品检测、音频克隆中很常用 VGGNet 论文地址 作者成功构建出一个非常深的卷积神经网络，并得到了更低的错误率和更强的泛化能力 为了构建一个很深的神经网络，作者 使用了非常小的卷积核 参数随机初始化 数据增强，比如随机裁剪、多尺度训练（放缩） 多GPU并行训练，将图像切分放入GPU中求梯度，将所有GPU中的梯度做均值，作为最终梯度 GoogLeNet 启发了标准化模块 normalization modules 对输入数据减去期望，再除以标准差，以实现归一化。 对归一化的结果引入一个线性变化，以提高自由度 ResNet 论文地址 实现训练更深（上千层）的模型，减轻了退化现象 退化现象 先前的工作表明，模型越深越好，但实践中深到一定程度，会出现退化（degradation）现象：即随着网络深度的提升，准确性会饱和。 作者认为，如果解决一个任务最适合用K层网络，那么即使我们训练了一个比K深的网络，只要K之后的网络做恒等映射（Identity Mapping），直接返回输入的值，就能取得和K层网络相同的效果。因此，理论上比K深的模型效果不应比K层差，但实验结果是某个任务56层确实比20层差 于是作者认为，模型在试图用多个非线性层混合输出一个恒等映射（比如对一个数据先平方再开方之类的吗？），我们应该直接给模型一个恒等映射的能力 残差学习框架 作者引入了残差学习框架，来解决退化问题 残差网络的核心，是在非线性层基础上加了一个x，从 $$ y = F(x) $$ 变成（当然，新训练出的F(x)和之前是不同的） $$ y = F(x)+x $$ 使用了这种操作（快捷连接）的网络都可以称作残差神经网络 理论上（万能近似定律），无论是$y=F(x)$还是$y=F(x)+x$，喂入足够的数据，都能拟合出所需的函数，区别是这两个模型的训练难度可能有所差异 通过观察可知，这一层模型是有可能被训练为$y=x$，也就是$F(x)$的输出恒为0，此时实现了恒等映射 维度映射 残差网络中输入和输出的维度应该是相同的，但实践中经常需要改变输出输出的通道数，可以用一个线性投影来匹配维度 $$ y=F(x, {W_i})+W_sx $$ zero-padding shortcuts：通过在输入中填充0来增加维度 projection shortcuts：通过1x1的卷积线性增加或减少维度 作者发现投影效果比零填充要好，但也没有好太多，于是不是必须的 网络架构 和VGGNet很类似，使用3x3的滤波器进行卷积 当输出的维度减半时，滤波核的数量就跟着翻倍，以维持复杂度 每两层网络添加一个快捷连接，以实现残差网络 大语言模型 指令微调 指令对齐 有监督微调 Supervised Fine-Tuning, SFT 对标记数据进行微调，以实现将预训练的大模型调整为特定的任务，可以利用到预训练模型的通用特征，不需要从头开始训练模型，节省大量资源 微调的数据量并不大，对模型的改动非常小，效果主要是激发，学知识还是要预训练 参数高效微调 PETF LoRA Low-Rank Adaptation，参考 是一种用于大型语言模型微调的优化技术，旨在减少模型的参数量和计算量，同时保持模型的性能。很多人为SD画图训练了很多LoRA，只要少量图就能让模型学会生成新的画风 核心思想是在模型的特定层中引入低秩矩阵，来近似模型的权重更新 大模型的参数空间特别特别巨大，这些空间的大小超越了实际解决这个问题所需的维度，这个现象叫做过参数化，这意味着参数空间有压缩的空间，这就是LoRA的核心 秩 分为行秩和列秩，意思是矩阵中线性无关的行/列的数量 在机器学习中，我们使用一个矩阵表示一个全连接层，这个矩阵具有很多参数，但是这些参数往往是过参数化的，可以通过计算秩来降维 可以使用主成分分析（PCA）或奇异值分解（SVD）的方式，对矩阵进行很好的降维 RLHF Reinforcement learning from human feedback 人类反馈强化学习 应用 Alignment 对齐，引导AI行为，使其符合设计者的利益和目的，一个已对齐的AI会朝着预期方向发展 vLLM 一个LLM推理框架，性能和吞吐量会更强，兼容多种开源模型 提示学习 Prompt Learning 将任务转化为一个语言模型的预测问题，通过调整提示的格式和内容，使模型能够更准确地理解任务要求并生成相应的答案 你可以把很多奇怪的任务比如用矩阵控制人物表情转为训练一个模型输出字符串，再将这个字符串转回矩阵 适配器学习 Adapter Learning 在一个预训练模型的某一层中插入一个轻量级的适配器模块 RAG Retrieval Augmented Generation 检索增强生成 Llama_index 模型结构 MoE 混合专家模式，Mixture of Experts 通过动态选择专门的子模型或“专家”来处理输入的不同部分，每个专家专注于特定任务 Switch Transformer o 这里的o是Omnipotence的缩写，意思是全能，表示这个大模型是一个通用的全功能大模型 EOS End of Sequence 用于标记序列的结束，使得模型能够识别序列的长度和边界，能让模型学会什么时候停止生成 RAS Repetition Aware Samping token factorization 将token分解为更多的因子 训练 并行 数据并行：数据分成多份，分给不同的GPU 模型并行：将模型的每一层切分到多个GPU中，需要在GPU间来回通信 流水线并行：将模型的不同层分配给不同GPU，但会出现“流水线空泡”（pipeline bubble） Megatron 英伟达的一个训练框架 Baseline 通常指一个基本的、简单的、表现较好的模型，作为参考点来评估其他新模型 Priors 先验知识，比如在模型设计、训练时引入的一些假设或约束 Condition 作为动词时，通常表示对数据进行预处理、归一化 涌现 当模型规模大到一定程度，会瞬间拥有某种能力，这些能力有可能超出了设计之初到预期，比如在准确率曲线上随着训练数据的提升呈阶梯状上升 退化 当模型在学习某一方面知识时，如果数据集中没能覆盖之前某些方面的知识，可能会失去之前已经拥有的能力 大模型训练时，如果使用了很糟糕的数据，或者反复训练某些数据，有可能会快速退化 如果每次训练的数据都能覆盖模型的每一个能力，就很难退化 困惑度 在模型训练时，会检查数据的质量，可以通过一个小模型去扫描数据，判断数据的困惑度。比如读WIKI的前几个字，让模型输出下一个字，查看正确率 freeze 在论文的流程图中，经常画一个雪花标志 在微调训练中冻结模型的大部分参数，只对一小部分参数进行微调，可以节省资源，也可以避免发生灾难性遗忘 MFU Model FLOPs Utilization 用于衡量模型训练中计算资源利用率的指标 $$ \\mathrm {MFU} = \\frac{模型一次迭代消耗的浮点运算次数 \\mathrm{FLOPs}}{\\mathrm{GPU}单卡算力 \\times 卡数 \\times 模型一次迭代的时间} $$ Scaling Laws Transformer语言模型的性能与规模强相关，而对形状依赖弱 模型参数数量N，数据集大小D，训练用的计算量C 扩大规模会提高模型性能：同时增大N和D，性能会提升，但固定一方同时增加另一方，收益会递减 大模型比小模型更好：大模型比小模型更具样本效率，能以更少的优化步骤达到相同的性能水平，并使用更少的数据点 Reasoning CoT Chain of Thought 思维链，将一个大问题拆分为多个小的子问题，逐步解决这些问题，模型的输入输出包含中间结果，模拟人类思考的过程 能提高数学问题、符号推理的求解能力 GRPO Group Relative Policy Optimization Reward Model 奖励模型 Pairwise Loss 配对损失，常用于排序学习和度量学习 排序学习是大模型常用的奖励模型（Reward Model），对于一个输入prompt，生成多个结果，人工对结果进行排序，得到样本对。再将这个样本对送入模型进行训练 由于绝对分数很难统一，ChatGPT在训练时，会给4个句子，让人工去给句子排序，机器用排序来计算loss PPO Proximal Policy Optimization, PPO 近端策略优化，是对策略梯度算法的改进 DPO Distributed Proximal Policy Optimization 对PPO的改进，能并行计算 ORPO KTO 面试题 大模型为什么能学会输出固定长度的token？ 大模型在输出token时，是有一个位置索引，可以驱动输出固定长度的任务 计算机视觉 Landmark 使用关键点、特征点来处理计算机视觉任务，比如人脸识别中使用眼睛、嘴巴、鼻子为关键点来检测追踪 Talking Head 一个CV任务，用于生成一个逼真的、会说话的人脸模型 SMPL Skinned Multi-Person Linear Model SMPL是一种用于描述人体形状（shape）和姿态（pose）的模型，shape是类似blendshape的channel，用于描述人的高矮胖瘦，pose是描述了定义好的关节节点（通常为24个）的旋转状态，使用轴角存储 SMPL可以转为.bvh，再转为.fbx，以导入游戏引擎中 RGB 数据集 指图片、视频、深度等数据，在CV领域用途很多 Inpaint 使用周围像素对图像进行修复/填充 逆渲染 正向渲染：从三维模型出发，得到二维图像的过程（也就是图形学的渲染） 逆向渲染：从二维图像出发，重建三维场景的过程 可微渲染 Reparameterizing Discontinuous Integrands for Differentiable Rendering 可微渲染（Differentiable Rendering）是一种实现逆向渲染的方法 从一个近似的三维场景出发渲染一张二维图片，求与Ground True的损失（loss），对三维场景的参数求偏导（Partial derivatives），即可使用梯度下降（Gradient descent）的方法得到和GT最相似的三维场景参数 问题： 传统的渲染器并不能对参数求偏导：搭建一个可微渲染器 很多参数不连续：对不连续的参数换元，并乘以一个平滑函数 NeRF 《NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis》 NeRF的任务是从一组已知的图片出发，得到其他视角下的图片 环绕物体拍摄一组2d的照片，在神经网络中构建一个5维的函数，输入为世界坐标$(x,y,z)$和视角$(\\theta,\\phi)$，输出为体密度和颜色 使用光线步进的方式进行体渲染 Gaussian Splatting 与NeRF类似，Gaussian Splatting也是从多个视角的图片出发，构建场景描述，通过高斯点染的方式，生成新视图 高斯点染的概念和光栅化很像，使用一个个椭球状的2D高斯函数为图元，将3D场景映射到2D图像上 未来帧预测 旨在基于已有的视频内容生成未来的帧序列，常用于自动驾驶、异常检测、视频压缩、视频编辑、动画制作 外观约束（Spatial Constraints）：基于像素强度和梯度等空间信息，确保未来帧与已有帧外观相似 动作约束（Temporal Constraints）：基于光流等运动信息，确保未来帧与已有帧连贯 长承预测 世界线 Worldline 一个物体在时空中运动轨迹，比如月球绕着地球转，轨迹是圆，如果加上时间轴，会变成螺旋线 视觉问答 Visual Question Answering，VQA MEMC 运动估计和运动补偿（Motion Estimation and Motion Compensation） 通过分析视频中的运动信息，估计物体的运动轨迹，并根据这些信息来合成新的帧，常用于视频插帧 Edge 对图像进行边缘描边，由于数据简单纬度低，更利于预测等操作 结构纹理分解 Structure-Texture Decomposition 将图像分解为两个部分：结构（物体的类别、位置和姿态）和纹理（纹理的粗糙度、方向性和频率） FACS Facial Action Coding System 光流 Optical Flow 光流是CV领域用于描述图像序列中像素运动的一种方法，通过计算连续两帧图像中像素点的位移来估计物体的运动 光流基于三个假设： 亮度恒定假设：物体运动中，其表面亮度不变（真的假的？） 小运动假设：相邻两帧物体的运动是微小的，于是第一帧大部分点都可以在第二帧中找到 空间一致性假设：相邻像素的运动是相似的，其光流向量应该相似 光流的工作核心是用一些算法得到像素的运动向量 PSNR Peak Signal-to-Noise Ratio 峰值信噪比，常用于评估参考图像和目标图像间的相似程度 mse = np.mean((image1 - image2) ** 2)max_pixel = np.max(image1)psnr = 10 * np.log10((max_pixel ** 2) / mse) NLP 自然语言处理 BPE Byte Pair Encoding，字节对编码 一种子词切分技术，通过将文本中的字符或字节对进行统计和合并，生成更小的子词单位，从而实现对文本的切分 构建词汇表 统计字符、字节的出现频率 按照频率从高到低合并为一个单独的字符，循环进行，直到没有字符对可以合并 得到最终的词汇表 ASR Automatic Speech Recognition，自动语音识别 将人类语言转化为文字，以便AI理解并处理人类语言 LID Language IDentification，语言识别，用于确定文本或语音所属语言类别的技术 EOS End of Sequence 用于标注序列的结束 SSM State Space Model 状态空间模型，是一种用于描述序列在各时间步的状态表示，并根据输入预测其下一个状态的模型，随着输入序列长度的增加，计算复杂度不会呈指数级增长 音频 Mel Spectrogram 梅尔频谱图是一种常用的标准的音频特征提取方法，可以用librosa将音频转化为mel谱图 RTF Real Time Factor，实时率 处理音频所需的时间 / 音频时长 如果实时率小于1，则可以通过串流的方式实时给用户 VAD Voice Activity Detection 语音活动检测（语音端点监测），可以从有噪音的语音中定位语音的开始和结束点、分离静音片段 TTS Text-to-Speech，文本转语音 Vocoder 声码器，将语音特征转化为声音的模型 3D NeRF Neural Radiance Field 3dgs 3D Gaussian Splatting 目标是通过一组从场景中拍摄的图片，得到场景的三维表示，并可以做到实时渲染 3dgs是一组在三维世界坐标上的高斯球，信息有世界坐标、协方差矩阵（旋转缩放）、体密度（透明度）、球谐（颜色） 3dgs可以很容易投影为2dgs，然后通过Alpha混合的方法进行渲染 MVS Multi-View Stereo 指从多视角图片重建三维场景的一类技术 SFM Structure from Motion 从无序的多视角图片重建三维场景和相机轨迹 colmap 一个开源项目，能将一组图片重建出点云和相机轨迹，进而被转为3dgs TrimGS 一个开源项目，能将3dgs转为三角Mesh","categories":[{"name":"ai","slug":"ai","permalink":"https://reubensun.com/categories/ai/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://reubensun.com/tags/AI/"}]},{"title":"Diffusion","slug":"ai/diffusion","date":"2025-01-17T14:45:25.000Z","updated":"2025-03-18T07:16:42.957Z","comments":true,"path":"ai/diffusion/","permalink":"https://reubensun.com/ai/diffusion/","excerpt":"","text":"Diffusion 扩散原理 生成模型的目标是：给定一组数据，构建一个分布，生成新的数据 一种思想是，从一个简单的分布开始（如果高斯分布），将其转化到目标分布 扩散模型正是这样的框架，将一个复杂抽样，转化为一系列简单抽样。其核心就是学习反转很多中间步骤会更简单 高斯扩散 Gaussian Diffusion 对于一个满足目标分布（尽管这个分布当下还是未知的）的随机变量$x_0$，我们为他添加一系列独立的高斯噪声。这个过程被称为前向扩散（forward process） $$ x_{t+1}=x_t + \\eta_t ,\\quad \\eta_t \\sim N(0, \\sigma^2) $$ 经过观察可知，在极高的步数下，$x_t$的边缘分布$p_t$极其接近高斯分布，我们将其近似为高斯分布，可以直接采样 我们将任务分解为一个个：给定边缘分布 $p_t$，生成分布 $p_{t-1}$。这被称为反向采样器（reverse sampler），如果我们有了反向采样器，我们就能从一个高斯噪声不断扩散出原始分布 $p_0$ DDPM 一个常用的构建反向采样器的方法是DDPM：在步数 $t$，输入一个满足 $p_t$的值 $z$，输出一个值，满足条件分布 $$ p(x_{t-1}|x_t=z) $$ 为每一个$x_t$都学习一个条件分布，这过于复杂了 我们假定，当每一步的噪声 $\\sigma$非常小时，每一步的条件分布都满足高斯分布，即 $$ p(x_{t-1}|x_t=z) \\approx N(x_{t-1};\\mu, \\sigma^2) $$ 将条件分布转化为高斯分布，我们相当于得到了分布的形状。只需要再获得分布的均值，就能得到整个分布 而我们可以使用神经网络和回归求这个均值 常用术语 Flow Matching SD3使用了Flow Matching替代DDPM 扩散模型是Flow Matching的一种特例 Flow Matching通过匹配模型向量场（Vector Field）和目标向量场来训练模型，训练后的向量场可以实现从简单分布转变为复杂目标分布 Flow（流）：一系列时间索引的向量场 cref Content Reference 允许用户上传一张或多张图片作为参考，以指导生成图像的具体内容或元素，控制内容迁移 SDXL 结构 SD1.5和SDXL都是UNet base model SDXL是一个二阶段级联扩散模型，包括Base模型和Refiner模型。prompt经过Base模型得到一个图像Latents，Refiner对Latents进行降噪和细节提升，最后再用VAE Decoder解码为图像 Base模型是一个画图模型，可以实现T2I、I2I、Inpaint UNet，在Encoder-Decoder结构的基础上，添加了Time Embedding、Cross Attention、Self-Attention VAE Encoder，图像2Latents Decoder，Latents2图像 两个CLIP Text Encoder 画图 T2I from diffusers import DiffusionPipelinepipe_id = &quot;stabilityai/stable-diffusion-xl-base-1.0&quot;pipe = DiffusionPipeline.from_pretrained(pipe_id, torch_dtype=torch.float16).to(&quot;cuda&quot;)prompt = &quot;a blue hair gril&quot;image = pipe(prompt, num_inference_steps=45, guidance_scale=7.5, height=1024, width=1024).images[0]image.save(&quot;output.jpg&quot;) T2I LoRA LoRA可以改变模型画风 from diffusers import DiffusionPipelinepipe_id = &quot;stabilityai/stable-diffusion-xl-base-1.0&quot;pipe = DiffusionPipeline.from_pretrained(pipe_id, torch_dtype=torch.float16).to(&quot;cuda&quot;)pipe.load_lora_weights(&quot;sd-gbf-lora&quot;)prompt = &quot;a blue hair gril&quot;lora_scale = 0.9image = pipe(prompt, num_inference_steps=45, guidance_scale=7.5, cross_attention_kwargs=&#123;&quot;scale&quot;: lora_scale&#125;, height=1024, width=1024).images[0]image.save(&quot;output.jpg&quot;) I2I LoRA 将图片转为LoRA画风 import torchfrom PIL import Imagefrom diffusers import StableDiffusionXLImg2ImgPipelinepipe_id = &quot;stabilityai/stable-diffusion-xl-base-1.0&quot;pipe = StableDiffusionXLImg2ImgPipeline.from_pretrained(pipe_id, torch_dtype=torch.float16).to(&quot;cuda&quot;)pipe.load_lora_weights(&quot;sd-gbf-lora&quot;)# 加载输入图像input_image_path = &quot;examples/lubi.jpg&quot; input_image = Image.open(input_image_path).convert(&quot;RGB&quot;)prompt = &quot;gbfhero&quot; negative_prompt = &quot;low quality, bad quality&quot; with torch.no_grad(): output_image = pipe( prompt=prompt, negative_prompt=negative_prompt, guidance_scale=7.5, cross_attention_kwargs=&#123;&quot;scale&quot;: 0.9&#125;, height=1024, width=1024, image=input_image, strength=0.5 # 控制生成图像与输入图像的相似程度，范围为0到1 ).images[0]output_image.save(f&quot;outputs/1.jpg&quot;) I2I LoRA Controlnet 直接使用I2I LoRA效果并不好，对原图的控制能力比较弱，可以配合使用Controlnet使用 import osimport cv2import torchimport numpy as npfrom PIL import Imagefrom diffusers import StableDiffusionXLControlNetImg2ImgPipeline, ControlNetModeloutput_folder = &quot;outputs&quot;os.makedirs(output_folder, exist_ok=True)# 加载模型和Controlnetpipe_id = &quot;stabilityai/stable-diffusion-xl-base-1.0&quot;controlnet_id = &quot;diffusers/controlnet-canny-sdxl-1.0&quot;controlnet = ControlNetModel.from_pretrained(controlnet_id, torch_dtype=torch.float16)pipe = StableDiffusionXLControlNetImg2ImgPipeline.from_pretrained(pipe_id, controlnet=controlnet, torch_dtype=torch.float16).to(&quot;cuda&quot;)pipe.load_lora_weights(&quot;sd-gbf-lora3&quot;)# 加载图片input_image_path = &quot;examples/leishen.jpeg&quot; input_image = Image.open(input_image_path).convert(&quot;RGB&quot;)np_image = np.array(input_image)# 生成 edgesnp_image = cv2.Canny(np_image, 100, 200)np_image = np_image[:, :, None]np_image = np.concatenate([np_image, np_image, np_image], axis=2)canny_image = Image.fromarray(np_image)canny_image.save(f&#x27;&#123;output_folder&#125;/tmp_edge.png&#x27;)prompt = &quot;gbfhero, clean background&quot;negative_prompt = &quot;low quality, bad quality&quot;lora_scale = 0.9image = pipe(prompt, negative_prompt=negative_prompt, guidance_scale=7.5, cross_attention_kwargs=&#123;&quot;scale&quot;: lora_scale&#125;, controlnet_conditioning_scale=0.5, image=input_image, strength=0.9, control_image=canny_image, height=1024, width=1024).images[0]image.save(f&quot;&#123;output_folder&#125;/5.jpg&quot;) SDXL LoRA训练 参考train_text_to_image_lora_sdxl.py 需要几百到几千张图片训练上千步，才能得到一个较好的LoRA Tensorboard Tensorboard是一个用于监控训练过程的UI pip install tensorboard 找到训练的log文件夹，找到一个形如events.out.tfevents.xxxx.xxx.xxx.x的文件，运行 tensorboard --logdir=log/xxxx --port=7861 会启动一个服务，访问这个链接就可以查看当前训练信息 from torch.utils.tensorboard import SummaryWritertrain_writer = SummaryWriter(log_dir=save_tensorboard_path)train_writer.add_scalar(&#x27;valid/mse_loss&#x27;, np.mean(valid_loss), train_step)train_writer.add_scalar(&#x27;train/mse_loss&#x27;, np.mean(loss_running[-args.log_interval*5:]), train_step)train_writer.add_scalar(&#x27;profile/io_time&#x27;, profile_times[&#x27;io&#x27;], train_step) accelerate huggingface推出的多机多卡训练框架，类似于tensorrun train.sh # 单机器多卡（4张GPU）export CUDA_VISIBLE_DEVICES=&#x27;0,1,2,3&#x27;export NCCL_IB_DISABLE=0export NCCL_P2P_DISABLE=0export NCCL_DEBUG=INFOexport NUM_PROCESSES=$&#123;MLP_WORKER_NUM&#125;export NPROC_PER_NODE=$&#123;MLP_WORKER_GPU&#125;accelerate launch \\ --config_file deepspeed.config \\ --multi_gpu \\ train.py deepspeed.config distributed_type: DEEPSPEEDfsdp_config: &#123;&#125;num_processes: 4num_machines: 1mixed_precision: &#x27;fp16&#x27;use_cpu: falsemachine_rank: 0main_training_function: main DreamBooth LoRA训练 更推荐用这个，DreamBooth使用了Rare-token Identifiers，会将instance prompt映射到更稀有的区域，比如在英语中插入一些字符，“A dog”变成“A[V] dog“，这样的prompt在tokenizer的位置会更稀有，不容易受到原本prompt训练的影响，更容易学到东西 参考train_dreambooth_lora_sdxl.py，使用3～5张图和一个相同的prompt，就能获得一个较好的效果 export MODEL_NAME=&quot;stabilityai/stable-diffusion-xl-base-1.0&quot;export INSTANCE_DIR=&quot;dog&quot;export OUTPUT_DIR=&quot;lora-trained-xl&quot;export VAE_PATH=&quot;madebyollin/sdxl-vae-fp16-fix&quot;accelerate launch \\ --mixed_precision=&quot;fp16&quot; \\ train.py \\ --pretrained_model_name_or_path=$MODEL_NAME \\ --instance_data_dir=$INSTANCE_DIR \\ --pretrained_vae_model_name_or_path=$VAE_PATH \\ --output_dir=$OUTPUT_DIR \\ --mixed_precision=&quot;fp16&quot; \\ --instance_prompt=&quot;a photo of sks dog&quot; \\ --resolution=1024 \\ --train_batch_size=1 \\ --gradient_accumulation_steps=4 \\ --learning_rate=1e-4 \\ --lr_scheduler=&quot;constant&quot; \\ --lr_warmup_steps=0 \\ --max_train_steps=500 \\ --validation_prompt=&quot;A photo of sks dog in a bucket&quot; \\ --validation_epochs=25 \\ --seed=&quot;0&quot; \\ INSTANCE_DIR：存放图片的文件夹路径，文件夹内只放图片即可 instance_prompt：对这些图片的主体描述 修复 train_dreambooth_lora_sdxl.py在fp16训练时有几处问题，比如修改log_validation函数中to.(device)的代码，当fp16时，不设置类型 if args.mixed_precision == &#x27;fp16&#x27;: pipeline = pipeline.to(accelerator.device)else: pipeline = pipeline.to(accelerator.device, dtype=torch_dtype) 还有Dataset中加载instance data文件夹时，加载了所有类型的文件，应该只加载图片类型 filenames = sorted(os.listdir(instance_data_root))filenames = list(filter(lambda file: file.endswith((&#x27;.jpeg&#x27;, &#x27;.png&#x27;, &#x27;jpg&#x27;)), filenames))filenames = [os.path.join(instance_data_root, name) for name in filenames]instance_images = [Image.open(path) for path in filenames] 删除 check_min_version(&quot;0.33.0.dev0&quot;) Flux Flux是目前最好的画图模型，不过生态还不太完备 Flux、SD3是DiT结构 画图 import osimport torchfrom diffusers import FluxPipelinepipe = FluxPipeline.from_pretrained(&quot;black-forest-labs/FLUX.1-dev&quot;, torch_dtype=torch.bfloat16).to(&quot;cuda&quot;)pipe.load_lora_weights(&quot;trained-flux-lora-gbf&quot;)prompt = &quot;gbfhero, a blue hair gril with a sword, gorgeous background, swimwear&quot;image = pipe( prompt, height=1024, width=1024, guidance_scale=3.5, num_inference_steps=50, max_sequence_length=512).images[0]os.makedirs(&quot;outputs&quot;, exist_ok=True)image.save(&quot;outputs/1.png&quot;) ControlNet LoRA from diffusers import FluxControlNetImg2ImgPipeline, FluxControlNetModelcontrolnet = FluxControlNetModel.from_pretrained(&quot;InstantX/FLUX.1-dev-Controlnet-Canny&quot;, torch_dtype=torch.bfloat16)pipe = FluxControlNetImg2ImgPipeline.from_pretrained(&quot;black-forest-labs/FLUX.1-dev&quot;, controlnet=controlnet, torch_dtype=torch.bfloat16).to(&quot;cuda&quot;)pipe.load_lora_weights(&quot;trained-flux-lora-gbf&quot;)...prompt = &quot;gbf hero&quot;image = pipe( prompt, guidance_scale=3.5, image=input_image, strength=0.99, control_image=canny_image, control_guidance_start=0.2, control_guidance_end=0.8, controlnet_conditioning_scale=1.0, height=1024, width=1024 ).images[0]image.save(f&quot;&#123;output_folder&#125;/c1.png&quot;) DreamBooth LoRA训练 Flux模型非常巨大，训练很容易超显存、内存 参考train_dreambooth_lora_flux.py export MODEL_NAME=&quot;black-forest-labs/FLUX.1-dev&quot;export INSTANCE_DIR=&quot;gbf&quot;export OUTPUT_DIR=&quot;trained-flux-lora&quot;accelerate launch \\ --mixed_precision=&quot;bf16&quot; \\ train.py \\ --pretrained_model_name_or_path=$MODEL_NAME \\ --instance_data_dir=$INSTANCE_DIR \\ --output_dir=$OUTPUT_DIR \\ --mixed_precision=&quot;bf16&quot; \\ --instance_prompt=&quot;gbf hero&quot; \\ --resolution=1024 \\ --train_batch_size=1 \\ --guidance_scale=1 \\ --gradient_accumulation_steps=4 \\ --optimizer=&quot;prodigy&quot; \\ --learning_rate=1. \\ --lr_scheduler=&quot;constant&quot; \\ --lr_warmup_steps=0 \\ --max_train_steps=500 \\ --validation_prompt=&quot;A photo of gbf hero&quot; \\ --validation_epochs=25 \\ --seed=&quot;0&quot; \\ 训练代码也有问题，使用bf16进行训练时，需要替换log_validation这行代码 # autocast_ctx = nullcontext()autocast_ctx = torch.autocast(accelerator.device.type)","categories":[{"name":"ai","slug":"ai","permalink":"https://reubensun.com/categories/ai/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"},{"name":"Diffusion","slug":"Diffusion","permalink":"https://reubensun.com/tags/Diffusion/"}]},{"title":"Unity Graph Editor","slug":"engine/UnityGraphEditor","date":"2024-11-08T14:01:25.000Z","updated":"2025-03-18T07:16:48.446Z","comments":true,"path":"engine/UnityGraphEditor/","permalink":"https://reubensun.com/engine/UnityGraphEditor/","excerpt":"","text":"Unity Graph Editor 今天跟群友聊天聊到Behavior Designer，这是一个Unity行为树的库，突然好奇如何自己在Unity绘制一个Graph Node Editor，简单做了下调研 Handles Handles的用法和GL很像，你也可以用GL.xxx实现下面的代码 Unity的Handles类本身就可以像OpenGL那样绘制2D Editor using System;using System.Collections;using System.Collections.Generic;using UnityEditor;using UnityEngine;public class DrawGraphWindow : EditorWindow&#123; private static DrawGraphWindow _window; private static float _minZoom = 0.4f; private static float _maxZoom = 7.0f; private static float _zoonSpeed = 0.1f; private Color bgColor = new Color(0.15f, 0.15f, 0.15f); private Color gridColor = new Color(0.85f, 0.85f, 0.85f); private Rect graphRect; private Vector2 drag; private Vector2 offset; private float zoom = 1.0f; private Vector2 dragStart; private float dragSpeed = 0.1f; [MenuItem(&quot;Tools/Draw&quot;)] public static void PopUp() &#123; _window = GetWindow&lt;DrawGraphWindow&gt;(&quot;Draw&quot;); _window.minSize = new Vector2(400, 300); _window.Show(); &#125; private void OnGUI() &#123; SetupSize(); ProcessEvents(Event.current); DrawBackground(); DrawGrid(10 * zoom, 0.2f); DrawGrid(50 * zoom, 0.4f); &#125; private void SetupSize() &#123; graphRect = new Rect(0, 0, position.width, position.height); &#125; private void ProcessEvents(Event e) &#123; if (e.type == EventType.MouseDown &amp;&amp; e.button == 1) &#123; dragStart = e.mousePosition; &#125; if (e.type == EventType.MouseDrag &amp;&amp; e.button == 1) &#123; drag = e.mousePosition - dragStart; dragStart = e.mousePosition; GUI.changed = true; &#125; if (e.type == EventType.ScrollWheel) &#123; zoom -= _zoonSpeed * e.delta.y; zoom = Mathf.Clamp(zoom, _minZoom, _maxZoom); e.Use(); &#125; &#125; private void DrawBackground() &#123; EditorGUI.DrawRect(graphRect, bgColor); &#125; private void DrawGrid(float gridSpacing, float gridOpacity) &#123; int widthDivs = Mathf.CeilToInt(position.width / gridSpacing); int heightDivs = Mathf.CeilToInt(position.height / gridSpacing); Handles.BeginGUI(); Handles.color = new Color(gridColor.r, gridColor.g, gridColor.b, gridOpacity); offset += drag * dragSpeed; Vector3 newOffset = new Vector3(offset.x % gridSpacing, offset.y % gridSpacing, 0); for (int i = 0; i &lt; widthDivs; i++) &#123; Handles.DrawLine(new Vector3(gridSpacing * i, -gridSpacing, 0) + newOffset, new Vector3(gridSpacing * i, position.height, 0f) + newOffset); &#125; for(int i = 0; i &lt; heightDivs; i++) &#123; Handles.DrawLine(new Vector3(-gridSpacing, gridSpacing * i, 0) + newOffset, new Vector3(position.width, gridSpacing * i, 0) + newOffset); &#125; Handles.color = Color.white; Handles.EndGUI(); &#125;&#125; 效果如下，按住鼠标右键可以拖拽，转动滚轮可以缩放 插件 自己重写一份图节点编辑器是非常费劲的，比如要处理反射等信息 你可以尝试使用FlowCanvas、xNode，或者ui toolkit 参考 UnityToolchainsTrick","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"},{"name":"Editor","slug":"Editor","permalink":"https://reubensun.com/tags/Editor/"}]},{"title":"UE5 学习笔记","slug":"engine/Note-of-UE","date":"2024-10-30T21:01:25.000Z","updated":"2025-03-18T07:16:42.958Z","comments":true,"path":"engine/Note-of-UE/","permalink":"https://reubensun.com/engine/Note-of-UE/","excerpt":"","text":"UE5 学习笔记 记录一下UE5 Gameplay开发中的一些小知识，不做过多的工程向记录 生命周期函数 PossessedBy PossessedBy函数是一个生命周期函数，当一个Pawn被一个新的Controller控制（接管）时触发，常用于多人游戏同步和初始化属性 网络同步 OnRep_PlayerState OnRep_PlayerState是一个回调函数，当服务器中PlayState发生修改时，会自动触发客户端中的该函数。用于从服务器向客户端同步信息 属性复制 服务器中维护了一个Actor列表，并定期更新客户端，以保证每个Actor的某些参数同步 Actor中用Replicated标注的参数，是需要同步的 同步的方式有两种： Property updates RPCs // Actor的参数配置bReplicates = true; // 启用网络同步NetUpdateFrequency = 10.0f; // 每秒更新10次 // 标注需要同步的参数，这是 Property updates 法UPROPERTY(Replicated) // 每次复制时触发int32 Health;","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unreal","slug":"Unreal","permalink":"https://reubensun.com/tags/Unreal/"}]},{"title":"微调大模型","slug":"ai/llama","date":"2024-10-30T15:40:25.000Z","updated":"2025-03-18T07:16:42.957Z","comments":true,"path":"ai/llama/","permalink":"https://reubensun.com/ai/llama/","excerpt":"","text":"微调大模型 直接推理 Llama3 import transformersimport torchmodel_id = &quot;meta-llama/Meta-Llama-3.1-8B-Instruct&quot;pipeline = transformers.pipeline( &quot;text-generation&quot;, model=model_id, model_kwargs=&#123;&quot;torch_dtype&quot;: torch.bfloat16&#125;, device_map=&quot;auto&quot;,)messages = [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a pirate chatbot who always responds in pirate speak!&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Do you know Genshin Impact?&quot;&#125;,]outputs = pipeline( messages, max_new_tokens=256,)print(outputs[0][&quot;generated_text&quot;][-1]) Qwen2.5 import torchfrom transformers import AutoModelForCausalLM, AutoTokenizermodel_name = &quot;Qwen/Qwen2.5-7B-Instruct&quot;model = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=torch.float16)tokenizer = AutoTokenizer.from_pretrained(model_name)prompt = &quot;给我简单介绍一下大语言模型&quot;messages = [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are Qwen, created by Alibaba Cloud. You are a helpful assistant.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;]text = tokenizer.apply_chat_template( messages, tokenize=False, add_generation_prompt=True)model_inputs = tokenizer([text], return_tensors=&quot;pt&quot;).to(model.device)generated_ids = model.generate( **model_inputs, max_new_tokens=512)generated_ids = [ output_ids[len(input_ids):] for input_ids, output_ids in zip(model_inputs.input_ids, generated_ids)]response = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]print(response) vllm部署 vllm serve Qwen/Qwen2.5-7B-Instruct --host 0.0.0.0 --port 7861 openai api from openai import OpenAIopenai_api_key = &quot;EMPTY&quot;openai_api_base = &quot;xxx/v1&quot;client = OpenAI( api_key=openai_api_key, base_url=openai_api_base,)chat_response = client.chat.completions.create( model=&quot;Qwen/Qwen2.5-7B-Instruct&quot;, messages=[ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are Qwen, created by Alibaba Cloud. You are a helpful assistant.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Tell me something about large language models.&quot;&#125;, ], temperature=0.7, top_p=0.8, max_tokens=512, extra_body=&#123; &quot;repetition_penalty&quot;: 1.05, &#125;, extra_headers=headers)print(&quot;Chat response:&quot;, chat_response) SFT 可以用于学习知识或能力 微调大模型有很多框架，Megatron很专业但门槛比较高，unsloth、LLaMA-Factory很玩具但比较适合新手 unsloth 这是一个模型sft框架，用起来很方便，但免费版只能单机单卡 参考Llama3.1_(8B) 训练结束后会在outputs文件夹中会保存一个checkpoint import torchfrom unsloth import FastLanguageModelfrom datasets import load_datasetfrom trl import SFTTrainerfrom transformers import TrainingArgumentsfrom unsloth import is_bfloat16_supportedmodel_id = &quot;xxx&quot;# 加载模型model, tokenizer = FastLanguageModel.from_pretrained(...)# 转为PEFT模型，准备训练LoRAmodel = FastLanguageModel.get_peft_model(...)# 将数据集转为alpaca格式alpaca_prompt = &quot;&quot;&quot;...&quot;&quot;&quot;EOS_TOKEN = tokenizer.eos_token # Must add EOS_TOKENdef formatting_prompts_func(examples): instructions = examples[&quot;instruction&quot;] inputs = examples[&quot;input&quot;] outputs = examples[&quot;output&quot;] texts = [] for instruction, input, output in zip(instructions, inputs, outputs): # Must add EOS_TOKEN, otherwise your generation will go on forever! text = alpaca_prompt.format(instruction, input, output) + EOS_TOKEN texts.append(text) return &#123; &quot;text&quot; : texts, &#125;pass# 加载数据集dataset = load_dataset(&quot;yahma/alpaca-cleaned&quot;, split = &quot;train&quot;)# 处理数据集dataset = dataset.map(formatting_prompts_func, batched = True,)# 配置训练参数training_args = TrainingArguments( per_device_train_batch_size = 2, gradient_accumulation_steps = 4, warmup_steps = 5, # num_train_epochs = 1, # Set this for 1 full training run. max_steps = 60, learning_rate = 2e-4, fp16 = not is_bfloat16_supported(), bf16 = is_bfloat16_supported(), logging_steps = 1, optim = &quot;adamw_8bit&quot;, weight_decay = 0.01, lr_scheduler_type = &quot;linear&quot;, seed = 3407, output_dir = &quot;outputs&quot;, report_to = &quot;none&quot;, # Use this for WandB etc)# 训练trainer = SFTTrainer( model = model, tokenizer = tokenizer, train_dataset = dataset, dataset_text_field = &quot;text&quot;, max_seq_length = max_seq_length, dataset_num_proc = 2, packing = False, # Can make training 5x faster for short sequences. args = training_args,)trainer_stats = trainer.train()# 保存LoRAmodel.save_pretrained(&quot;lora_model&quot;) tokenizer.save_pretrained(&quot;lora_model&quot;) 测试checkpoint # 使用本地模型model_id = &quot;outputs/checkpoint-60&quot;pipeline = transformers.pipeline( &quot;text-generation&quot;, model=model_id, model_kwargs=&#123;&quot;torch_dtype&quot;: torch.bfloat16&#125;, device_map=&quot;auto&quot;,)messages = [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;Give three tips for staying healthy&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Do you know Genshin Impact?&quot;&#125;,]outputs = pipeline( messages, max_new_tokens=256,)print(outputs[0][&quot;generated_text&quot;][-1]) 输出结果中很显然背了了很多医学知识 LLaMA-Factory 一个开源LLM sft框架，可以实现多机多卡，但感觉跟unsloth比更玩具了 安装 git clone --depth 1 https://github.com/hiyouga/LLaMA-Factory.gitcd LLaMA-Factorypip install -e &quot;.[torch,metrics]&quot; llamafactory-cli version sft accelerate launch --config_file deepspeed.config src/train.py llm_config.yaml # deepspeed.configcompute_environment: LOCAL_MACHINEdebug: falsedeepspeed_config: deepspeed_multinode_launcher: standard gradient_accumulation_steps: 8 offload_optimizer_device: none offload_param_device: none zero3_init_flag: false zero_stage: 3distributed_type: DEEPSPEEDdowncast_bf16: &#x27;no&#x27;enable_cpu_affinity: falsemachine_rank: 0main_process_ip: &#x27;100.96.220.190&#x27;main_process_port: 29500main_training_function: mainmixed_precision: fp16num_machines: 1num_processes: 8rdzv_backend: staticsame_network: truetpu_env: []tpu_use_cluster: falsetpu_use_sudo: falseuse_cpu: false # llm_config.yamlmodel_name_or_path: Qwen/Qwen2.5-7B-Instructstage: sftdo_train: truefinetuning_type: loralora_target: alldataset: alpaca_zh_demotemplate: qwencutoff_len: 1024max_samples: 1000overwrite_cache: truepreprocessing_num_workers: 16output_dir: saves/qwen-8b/lora/sftlogging_steps: 10save_steps: 500plot_loss: trueoverwrite_output_dir: trueper_device_train_batch_size: 1gradient_accumulation_steps: 8learning_rate: 1.0e-4num_train_epochs: 3.0lr_scheduler_type: cosinewarmup_ratio: 0.1bf16: trueddp_timeout: 180000000val_size: 0.1per_device_eval_batch_size: 1eval_strategy: stepseval_steps: 500 Reasoning deepseek爆火后最流行的模型结构，可以长思维链思考，用RL训练 unsloth unsloth提供了一种基于GRPO的训练方法 import torchimport refrom unsloth import FastLanguageModel, PatchFastRL, is_bfloat16_supportedfrom datasets import load_dataset, Datasetfrom trl import GRPOConfig, GRPOTrainer# 修改FastLanguageModel，使其支持GRPOPatchFastRL(&quot;GRPO&quot;, FastLanguageModel)# 加载模型model, tokenizer = FastLanguageModel.from_pretrained(...)# 转为PEFT来训LoRAmodel = FastLanguageModel.get_peft_model(...)# 加载数据集dataset = get_gsm8k_questions()# 训练配置training_args = GRPOConfig( use_vllm = True, # use vLLM for fast inference! learning_rate = 5e-6, adam_beta1 = 0.9, adam_beta2 = 0.99, weight_decay = 0.1, warmup_ratio = 0.1, lr_scheduler_type = &quot;cosine&quot;, optim = &quot;adamw_8bit&quot;, logging_steps = 1, bf16 = is_bfloat16_supported(), fp16 = not is_bfloat16_supported(), per_device_train_batch_size = 1, gradient_accumulation_steps = 1, # Increase to 4 for smoother training num_generations = 8, # Decrease if out of memory max_prompt_length = 256, max_completion_length = 200, # num_train_epochs = 1, # Set to 1 for a full training run max_steps = 250, save_steps = 250, max_grad_norm = 0.1, report_to = &quot;tensorboard&quot;, # Can use Weights &amp; Biases output_dir = &quot;outputs&quot;,)# 训练，reward_funcs是RL的奖励函数，这里是与text结构有关trainer = GRPOTrainer( model = model, processing_class = tokenizer, reward_funcs = [ xmlcount_reward_func, soft_format_reward_func, strict_format_reward_func, int_reward_func, correctness_reward_func, ], args = training_args, train_dataset = dataset)trainer.train()# 保存LoRAmodel.save_lora(&quot;grpo_saved_lora&quot;) 测试LoRA import torchfrom transformers import AutoModelForCausalLM, AutoTokenizerfrom peft import LoraConfigmodel_name = &quot;Qwen/Qwen2.5-3B-Instruct&quot;model = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=torch.float16)tokenizer = AutoTokenizer.from_pretrained(model_name)lora_config = LoraConfig( r=64, target_modules=[&quot;q_proj&quot;, &quot;k_proj&quot;, &quot;v_proj&quot;, &quot;o_proj&quot;, &quot;gate_proj&quot;, &quot;up_proj&quot;, &quot;down_proj&quot;], lora_alpha=64)model.add_adapter(lora_config, adapter_name=&quot;grpo_saved_lora&quot;)SYSTEM_PROMPT = &quot;&quot;&quot;Respond in the following format:&lt;reasoning&gt;...&lt;/reasoning&gt;&lt;answer&gt;...&lt;/answer&gt;&quot;&quot;&quot;prompt = &quot;How many r&#x27;s are in strawberry?&quot;messages = [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: SYSTEM_PROMPT&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;]text = tokenizer.apply_chat_template( messages, tokenize=False, add_generation_prompt=True)model_inputs = tokenizer([text], return_tensors=&quot;pt&quot;).to(model.device)generated_ids = model.generate( **model_inputs, max_new_tokens=512)generated_ids = [ output_ids[len(input_ids):] for input_ids, output_ids in zip(model_inputs.input_ids, generated_ids)]response = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]print(response)","categories":[{"name":"ai","slug":"ai","permalink":"https://reubensun.com/categories/ai/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"},{"name":"LLM","slug":"LLM","permalink":"https://reubensun.com/tags/LLM/"},{"name":"Llama","slug":"Llama","permalink":"https://reubensun.com/tags/Llama/"},{"name":"Qwen","slug":"Qwen","permalink":"https://reubensun.com/tags/Qwen/"}]},{"title":"WSL 深度学习环境搭建","slug":"ai/WSL","date":"2024-10-30T10:40:25.000Z","updated":"2025-03-18T07:16:42.957Z","comments":true,"path":"ai/WSL/","permalink":"https://reubensun.com/ai/WSL/","excerpt":"","text":"WSL 深度学习环境搭建 Win11，N卡 很多人只有一台Windows电脑，装双系统很麻烦，尤其是一个有N卡驱动的Linux，而WSL2环境搭建非常方便 之前有写过一篇Linux入门，但是内容记的太杂了，这里精简一下 安装WSL2 在Windows Terminal（如果没有，去微软的store中下载）中输入 wsl --install 默认会安装一个最新的Ubuntu 安装GCC 11 主要是为了对应cuda版本 sudo apt updatesudo apt install gcc-11 g++-11 设置gcc版本优先级 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 9sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 9 更新并保存环境变量 export PATH=/usr/bin:$PATHsource ~/.bashrc 测试gcc gcc --version 如果没成功，试着重启wsl 安装CUDA 11.8 这个方法需要能访问外网，这里安装的是CUDA 11.8，需要其他版本可以在英伟达官网找 寻找一个空间较大的目录（主要是怕你乱放），输入 wget https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_520.61.05_linux.run sudo sh cuda_11.8.0_520.61.05_linux.run 输入accept和按install后，会弹出提示，按照提示配置环境变量 如果配置不上，你可以每次启动时都ctrl+R搜索这个export命令，每次都配置一次nvcc export PATH=/usr/local/cuda-11.8/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-11.8/lib64:$LD_LIBRARY_PATH 安装Anaconda 官网下载 安装 bash Anaconda3-2024.10-1-Linux-x86_64.sh 安装时会询问保存路径，默认在用户目录，由于这个非常占空间，建议选一个空间大的地方 激活 source &lt;you anaconda path&gt;/bin/activate# source ~/anaconda3/bin/activate conda init 持久化 修改.bashrc，添加下面内容，启动bash时就自动激活conda了 __conda_setup=&quot;$(&#x27;/home/your_username/anaconda3/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)&quot;if [ $? -eq 0 ]; then eval &quot;$__conda_setup&quot;else if [ -f &quot;/home/your_username/anaconda3/etc/profile.d/conda.sh&quot; ]; then . &quot;/home/your_username/anaconda3/etc/profile.d/conda.sh&quot; else export PATH=&quot;/home/your_username/anaconda3/bin:$PATH&quot; fifiunset __conda_setupexport PATH=/usr/local/cuda-11.8/bin:$PATH 访问WSL端口 在wsl中搭建web服务，在windows中访问，不需要做什么代理映射，非常方便 在wsl中输入 hostname -I 即可得到WSL的IP地址 Gradio 编写一个Gradio demo，并架设在wsl的localhost:7861 import gradio as grwith gr.Blocks() as demo: gr.Markdown(&#x27;Hello, world!&#x27;)if __name__ == &#x27;__main__&#x27;: demo.launch(server_name=&#x27;0.0.0.0&#x27;, server_port=7861) 假设hostname -I获得的IP地址是172.23.105.49 在Windows浏览器中访问地址 172.23.105.49:7861 发现成功打开Gradio demo 安装Pytorch 创建一个conda环境（sd是环境的名称） conda create -n sd python=3.10 pip conda activate sd pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118 设置huggingface 用学校邮箱注册huggingface审批更快，申请大模型时最好不要选择China，有可能被拒绝，可以选新加坡 很多AI模型都架设在huggingface中，hf默认会把cache存储在~/.cache下，考虑到模型都非常巨大，一般都会放在其他地方 export HF_HOME=/data/hfsource ~/.bashrc 在第一次使用hf时，需要先登陆，你需要在hf网站中获得一个Access Tokens，并在python中执行 from huggingface_hub import loginlogin(token=&quot;hf_xxxx&quot;) SD3.5画图 尝试一下SD3.5画图，这是一个8B大模型 pip install -U diffusers import torchfrom diffusers import StableDiffusion3Pipelinepipe = StableDiffusion3Pipeline.from_pretrained(&quot;stabilityai/stable-diffusion-3.5-large&quot;, torch_dtype=torch.bfloat16)pipe = pipe.to(&quot;cuda&quot;)image = pipe( &quot;A capybara holding a sign that reads Hello World&quot;, num_inference_steps=28, guidance_scale=3.5,).images[0]image.save(&quot;capybara.png&quot;)","categories":[{"name":"ai","slug":"ai","permalink":"https://reubensun.com/categories/ai/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://reubensun.com/tags/Linux/"}]},{"title":"Unity 动画","slug":"engine/Unity动画","date":"2024-10-24T11:01:25.000Z","updated":"2025-03-18T07:16:48.446Z","comments":true,"path":"engine/Unity动画/","permalink":"https://reubensun.com/engine/Unity%E5%8A%A8%E7%94%BB/","excerpt":"","text":"Unity 动画 整理一下先前做动画的收获 骨骼动画 序列帧动画：记录动作的每一帧 非矢量动画：每一帧是固定不可复用的，新的一帧本质上是完全重画一次物体，没有发生形态上的改变 关键帧动画：记录动作的始末和轨迹曲线，运行时根据曲线进行插值（很显然，这是一种矢量动画） 每个关键帧被称为姿势 顶点动画 骨骼动画的本质是顶点动画 刚体动画：在渲染中网格不发生改变，刚体的变化矩阵发生改变 顶点动画：在渲染中网格顶点发生了直接的变化（位移旋转缩放） 骨骼动画：一种对顶点动画的压缩算法 流体动画 粒子动画 变形动画：常用于制作表情，捏脸 根据顶点动画的实现方式，分为CPU和GPU CPU动画 GPU动画 顶点位置改变时机 CPU应用阶段 GPU几何阶段 数据流 CPU传递给GPU的顶点数组发生改变 顶点着色器输出发生改变 骨骼动画 骨骼动画的模型整体不是刚体，同时为了避免旋转、移动时发生断裂，也不能将物体拆分为多个小刚体，因此只能选择顶点动画。 然而顶点动画带来的顶点移动，如果全部交由vertex着色器处理，过于昂贵，实时渲染不可接受 而且骨骼动画的顶点受更高层次的骨骼节点控制 同一根骨骼的顶点要保持相对位置不变 骨骼间顶点要进行平滑 顶点的大体形状受骨骼形状制约，顶点变化时要保持和骨骼的联系 实现 矩阵调色板蒙皮技术（Matrix Palette Skinning）： 骨骼为近似刚体，其变化矩阵按顺序存储在数组中（我们称这个数组为骨骼） 顶点缓冲中会存储其骨骼ID和权重信息（一个顶点通常会受1～4个骨骼影响，可以用两个Vector存储） 进行变化时，顶点可以根据骨骼ID和权重查询变化矩阵，并通过插值的方式实现顶点动画（我们称查询矩阵为蒙皮） CPU通过姿势间插值，以获得每一帧骨骼的位置及矩阵，GPU根据顶点信息查询矩阵进而实现运动 坐标系 骨骼树 三维骨骼本质上是一系列Bone组成的树状结构 在骨骼动画中，我们更关心骨骼的相对位置，于是我们选择本地坐标系（A物体的本地坐标就是以A物体中心为原点，相对于中心的偏移），并让坐标系层次嵌套 比如大臂移动时也会带动小臂移动，我们就把小臂的本地坐标系定义在大臂的本地坐标系之下，我们称大臂是小臂的父物体，小臂是大臂的子物体。而小臂在大臂的本地坐标系的坐标被称为局部坐标系（可以参考Unity的GO组织） 顺着嵌套关系向根部搜索，就可以获得物体的世界坐标系 下图为树节点的数据结构 本地坐标系就是object space transform 在播放动画时，会从空间树的根节点（一般为盆骨节点或者root节点）开始向下递归变化，以保证父物体的local transform总是先于子物体刷新 //对关键帧进行插值 public OnAnimated(CoordinateTreeNode Key0, CoordinateTreeNode Key1, float t)&#123; Position = Vector3.Lerp(Key0.Position, Key1.Position, t); Rotation = Quaternion.Lerp(Key0.Rotation, Key2.Rotation, t); Scale = Vector3.Lerp(Key0.Scale, Key1.Scale, t); localTransform = new TransformMatrix(Position, Rotation, Scale); combinedTransform = parent.localTransform * this.localTransform; &#125; 骨骼 盆骨：选盆骨作为根节点（或者是空根节点的第一也是唯一的子节点），是因为盆骨在运动时相对匀速，且位置居中，可以避免骨骼树过深 脊椎骨：模拟躯干运动，一般有2～3块 捻度骨骼：Twist Bone，生物学中像小臂这类骨骼不是一块骨骼，而是两条并排的骨骼，以此实现肘关节不动而手掌可以旋转 坐标变化 位移矩阵 缩放矩阵 旋转矩阵 齐次坐标 仿射变换：缩放–旋转–平移 列矩阵左乘 手性变换：只需要对所有的矩阵任选一维进行取反即可（哪个维度不重要，只要统一即可） 旋转 骨骼动画是矢量动画，是关键帧动画，因此会用到大量的插值，这决定了旋转的表达必须便于插值 三维空间中的点可以由三个正交向量插值表示，根据嵌套关系，一个物体发生旋转，其实就是其基向量相对于父节点基向量发生改变 双向量法 既然旋转可以由基向量的朝向表示，那么我们就直接基向量表示旋转吧！ 正好三个基向量正交，而且对长度不敏感，那么我们还可以将三个向量压缩为两个向量 更进一步，这些向量都在球面上，那么用球坐标系替代直角坐标系 问题： 需要时刻保证两个向量垂直 不好插值 欧拉角 在航空业应用广泛，本质是一种过程量，描述了从初始位置沿着xyz轴旋转指定角度的过程，使用时需要明确旋转顺序（即顺规） 直角坐标系 欧拉角 前进方向 Z Roll 桶滚角 上方向 Y Yaw 偏航角 右方向 X Pitch 俯仰角 问题： 没有统一标准，而欧拉角强依赖于顺规 某些情况下会有两个轴平行，以至于失去一个自由度，导致万向节死锁 不能线性插值 轴角与四元数 轴角（x, y, z, w）指沿着轴（x, y, z）旋转w度，也可以压缩为三维向量（wx’, wy’, wz’），轴角可以通过对轴向量和旋转角度分别插值对方法进行插值 四元数是一种超复数，可以用来表示旋转 四元数的可视化_哔哩哔哩_bilibili 蒙皮解算 Mesh中的顶点缓存中会存储骨架、骨骼索引，骨骼权重，运行时在顶点函数进行位置的偏移，效果表现为Mesh跟着骨架一起运动，而且在边缘处会进行变形（效果与权重分配有关），就像皮肤蒙在骨骼上一样，这个过程被称为蒙皮结算 Motion Matching 游戏中不止使用一个动画，于是动画系统不仅需要播放动画，还需要管理动画。最常见的管理方式是数据驱动，实现形式为图状态机，通过一些bool、float、trigger数据控制动画状态 但随着角色3C不断复杂，动画系统也越发复杂，状态机里塞进了海量动画节点，他们的状态难以维护，为此育碧提出了Motion Matching MM通过角色当前的姿势（Pose Channel）和行动轨迹（Trajectory Channel）在动画数据库中进行匹配，自动设置当前动画状态 Trajectory Channel通常是一个二维平面，通过人物移动速度，绘制一个移动轨迹，主要作用是跑步时转向会侧倾 Pose Channel是使用角色骨骼的几个节点，通常是两个脚的节点（当然你可以使用更多的节点，但随着节点数量的提升，匹配速度会更慢），主要作用是脚着地、手抓墙 骨骼动画播放 Unity Playable Script 动画播放 当我们在使用Unity Animator时，会发现我们必须要先将所需的动画片段放入Animation Controller中才能播放。如果我们想要一个Resources目录下的某个Clip，是做不到的 当游戏动画逻辑非常复杂时，状态机会非常复杂，几乎不可维护，于是很多公司会自己用Playable Script重写一份动画播放系统 Playable Script仍然是驱动Animator和Avatar的，所以角色身上仍需要Animator组件 直接播放一个动画片段 PlayableGraph playableGraph;AnimationClip idleClip;void Start()&#123; playableGraph = PlayableGraph.Create(); playableGraph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);&#125;void Update()&#123; if(xxx) &#123; AnimationPlayableUtilities.PlayClip(GetComponent&lt;Animator&gt;(), idleClip, out playableGraph); &#125;&#125;private void OnDisable()&#123; playableGraph.Destroy();&#125; 等效于 var output = AnimationPlayableOutput.Create(playableGraph, &quot;AnimationOutput&quot;, GetComponent&lt;Animator&gt;());var clip = AnimationClipPlayable.Create(playableGraph, idleClip);output.SetSourcePlayable(clip);playableGraph.Play(); 自行解算Humanoid 对于一个Humanoid骨骼的模型，我们可以直接遍历获得骨骼的Transform，对其进行修改 public Animator animator; // 遍历Humanoid所有的骨骼foreach (HumanBodyBones bone in System.Enum.GetValues(typeof(HumanBodyBones)))&#123; Transform boneTransform = anim.GetBoneTransform(bone); // 修改 boneTransform&#125; Rig 一种基于反向动力学的组件，可以覆盖动画，原理是为一个骨骼点绑定其几个父节点，并刷上相关权重，当骨骼点因为外力移动时，父节点会跟着一起运动，从而使得整体动画协调 常用于武器运动时手跟着一起动、脚着地时腿跟着一起动、头看向临近的人 参考 Blendshape动画 blendshape常用于实现表情动画、形变动画，相较于骨骼动画，十分昂贵 blendshape本质是在两个（或多个）顶点数量相同但位置不同的两个网格间插值出新网格 一个Mesh会有多个blendshape channel，每个channel都存了原始的mesh顶点buffer信息（主要是位置和法线），和目标mesh的顶点buffer信息，在解算时在两个mesh间线性插值。当有多个channel时，会按顺序依次插值 我们常用IClone和CC4制作bs模型 Unity播放bs 一个拥有bs channel的模型导入unity，会在SkinMeshRenderer上看到bs channel，直接修改这些channel就能实现动画播放 物理动画 大部分物理动画是通过解算一些物理观测点，再将这些点映射回（骨骼）动画中 Unity Magica Cloth 使用 Unity Magica Cloth插件一站式解决头发、衣服和胸部的物理模拟 Magica Cloth是Unity一个布料模拟插件，有两个版本，我使用的是基于Jobs的普通版本（2是基于DOTS的） 1. 添加预制体 在场景中拖入MagicaPhysicsManager.prefab 位置在Assets/MagicaCloth/Res/Prefab 2. 绘制骨架 使用Animation Rigging绘制骨架，方便后续配置布料 Animation Rigging – Bone Renderer Setup 3. 添加Magcia Bone Cloth Create Others – Magica Cloth – Magica Bone Cloth 将布料的根节点拖到Root List中，通常会有多个根节点 店家Start Point Selection开始调整节点 为节点刷颜色，红色只能旋转，绿色可以运动，根节点们都要为红色（你可以先点Fill将所以节点都设为绿色，然后切换到红色笔刷状态，按住鼠标左键在场景中将根节点都刷为红色） 完成后按End Point Selection保存 调整参数（也可以直接选择Preset） 点击最下方的Create，完成创建 4. 防穿模 在模型骨架下创建Magica Collider Unity Ragdoll Animator Ragdoll（布娃娃系统）是一种基于物理模拟角色动作的技术，通常是通过在角色关节和躯干上放置碰撞器和约束实现，可以参考动物派队、人类一败涂地的角色控制，该技术还常用于实现角色受击、尸体倒地等 我使用的是插件Ragdoll Animator 2，使用起来非常简单，而且可以做角色动画和物理的混合 人物模型初始化 导入一个模型，将其Rig设为Humanoid 将模型拖入场景，添加组件Ragdoll Animator 2 点击Try Auto-Find Requied Bones，人形模型可以自动初始化 参数调整 调整碰撞体的类型、大小（Construct–Colliders） 调整躯干重量、摆动范围（Construct–Physics） 调整肌肉力量、动画混合程度（Motion） 设置IK（在Extra–Utility–Kinematic Bone Selector） 动画压缩 用ALU和效果换存储和带宽，动画有很多关键帧和插值函数组成，Unity Editor下可以对动画Clip进行采样，生成更简化的关键帧，在运行时通过插值还原回动画信息","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"},{"name":"Animation","slug":"Animation","permalink":"https://reubensun.com/tags/Animation/"}]},{"title":"Unity URP卡通渲染","slug":"graphics/卡通渲染","date":"2024-10-22T10:30:25.000Z","updated":"2025-03-18T07:16:48.442Z","comments":true,"path":"graphics/卡通渲染/","permalink":"https://reubensun.com/graphics/%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93/","excerpt":"","text":"Unity URP卡通渲染包 最近工作之余抄了一个卡渲，结果越做感觉越没意思，主要是缺少一些美术资源，于是先pending，在此先记录一下 当前进度 代码已开源，仓库地址 设计理念 高复用，易拓展，低侵入 我遇到了什么问题 每次我要写Unity shader时，我都要不厌其烦地写 Shader GUI、Properties 定义贴图和采样器，定义全局变量 维护CBuffer，尤其是SRP batcher 几乎一模一样的Vertex函数 大量贴图采样，参数初始化 照抄的渲染方程和灯光Loop 我一直认为，大部分情况，都不应该写Shading Function，这些BRDF是渲染的基石，是必须要用有科学依据、有论文支撑、经过行业验证的方案，而每次都自行写渲染方程，很容易产生错误 此外为了实现材质的多光源，渲染方程中会有大量的灯光着色Loop，他们代码十分重复，如果直接展开在片源函数中，很容易漏维护（比如只更新了主方向光的代码，其他的都没管） 因此我认为，应当将渲染方程视为黑盒，用户在定义材质shader时只需要收集数据，传入方程 高可复用 类似URP的UniversalFragmentPBR，我定义了一个float4 ToonFragment(inputData, surfaceData, input.uv)函数，用户只需要修改传入函数的参数 修改分为两个部分，材质修改和渲染修改 新材质需求 材质修改是通过PreProcessMaterial，对传入函数的InputData和ToonSurfaceData进行修改，参考 在Standard的基础上，让石头顶部覆盖雪或草 // Feature+[Main(FeatureMode, _, off, off)] _FeatureGroup(&quot;Feature&quot;, float) = 0+[KWEnum(FeatureMode, SnowRock, _SNOWROCK, GrassRock, _GRASSROCK)] _EnumFeatureMode (&quot;Feature&quot;, float) = 0+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 0)] _CustomVector1 (&quot;Snow Color&quot;, Color) = (1,1,1,1)+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 0)] _CustomFloat1 (&quot;Snow Line (World)&quot;, Float) = 0.5+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 1)] _CustomVector2 (&quot;Grass Rock Color&quot;, Color) = (1,1,1,1)+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 1)] _CustomFloat2 (&quot;Grass Scale&quot;, Range(0,1)) = 0.9+[Tex(FeatureMode_GRASSROCK)] _CustomMap1(&quot;GrassMap&quot;, 2D) = &quot;white&quot; &#123;&#125;#pragma shader_feature_local _CELLSHADING _PBRSHADING _CUSTOMSHADING+#pragma shader_feature_local _SNOWROCK _GRASSROCK+#define _SnowLine _CustomFloat1+#define _SnowColor _CustomVector1+#define _GrassScale _CustomFloat2+#define _GrassColor _CustomVector2+#define _GrassMap _CustomMap1void PreProcessMaterial(inout InputData inputData, inout ToonSurfaceData surfaceData, float2 uv)&#123;+ #if _SNOWROCK+ float snowScale = saturate(inputData.positionWS.y - _SnowLine);+ surfaceData.albedo = lerp(surfaceData.albedo, _SnowColor.rgb, snowScale);+ #endif+ #if _GRASSROCK+ float3 grassColor = _GrassColor.rgb;+ grassColor *= SAMPLE_TEXTURE2D(_GrassMap, sampler_CustomMap1, uv).rgb;+ float3 upVector = float3(0, 1, 0);+ float NoU = dot(upVector, inputData.normalWS);+ float grassScale = saturate(NoU - _GrassScale);+ // surfaceData.albedo = lerp(surfaceData.albedo, grassColor, grassScale);+ if(NoU &gt; _GrassScale)+ &#123;+ surfaceData.albedo = grassColor;+ &#125;+ #endif&#125;float4 CustomFragment(InputData inputData, ToonSurfaceData toonSurfaceData, AdditionInputData additionInput)&#123; return 0;&#125;#include &quot;Packages/com.reubensun.toonurp/Shaders/ToonStandardForwardPass.hlsl&quot; 新着色需求 渲染修改是着色后对diffuse、specular进行一次modify，参考 让材质的diffuse根据菲涅尔差值，实现简单的丝袜，这里的modify将会直接乘到diffuse颜色上 +// Feature+[Main(FeatureMode, _, off, off)] _FeatureGroup(&quot;Feature&quot;, float) = 0+[KWEnum(FeatureMode, FresnelStocking, _FRESNEL_STOCKING)] _EnumFeatureMode (&quot;Feature&quot;, float) = 0+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 0)] _CustomFloat1 (&quot;Stockings Pow&quot;, Float) = 0.5+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 0)] _CustomVector1 (&quot;Color Inside&quot;, Color) = (1,1,1,1)+[Sub(FeatureMode)] [ShowIf(_EnumFeatureMode, Equal, 0)] _CustomVector2 (&quot;Color Outside&quot;, Color) = (1,1,1,1)#pragma shader_feature_local _CELLSHADING _PBRSHADING+#pragma shader_feature_local _FRESNEL_STOCKING+#define _StockingsPow _CustomFloat1+#define _StockingsColorInside _CustomVector1+#define _StockingsColorOutside _CustomVector2void PreProcessMaterial(inout InputData inputData, inout ToonSurfaceData surfaceData, float2 uv)&#123;+ #if _FRESNEL_STOCKING+ float NoV = max(dot(inputData.viewDirectionWS, inputData.normalWS), 0.001);+ float fresnelStockings = pow(NoV, _StockingsPow);+ float3 stockingsColor = lerp(_StockingsColorOutside.rgb, _StockingsColorInside.rgb, fresnelStockings);+ surfaceData.diffuseModify = stockingsColor;+ #endif&#125; 易拓展 必须承认，不同材质的ShadingMode不同，因此我们必须要支持自定义ShadingMode，于是我设计了一个CustomFragment函数，并定义了一个宏，当这个宏打开，就不走ToonFragment，而是CustomFragment，参考 // Lighting mode[Main(ShadingMode, _, off, off)] _ShadingModeGroup(&quot;ShadingMode&quot;, float) = 0+[KWEnum(ShadingMode, CelShading, _CELLSHADING, PBRShading, _PBRSHADING, CelHair, _CUSTOMSHADING)] _EnumShadingMode (&quot;Mode&quot;, float) = 2+#pragma shader_feature_local _CELLSHADING _PBRSHADING _CUSTOMSHADINGfloat4 CustomFragment(InputData inputData, ToonSurfaceData toonSurfaceData, AdditionInputData additionInput)&#123;+ ... return color;&#125;#include &quot;Packages/com.reubensun.toonurp/Shaders/ToonStandardForwardPass.hlsl&quot; 维护SRP batcher 为了让材质都支持SRP batcher，我们需要不同shader的CBuffer相同，但不同材质要很多不同的变量 为此我在CBuffer中提前定义了大量的float、vector、贴图，在使用时只需要先用#define对这个custom变量重命名，就能兼容SRP batcher，参考 低侵入 我看到很多卡通渲染包，他们都把URP完整复制一份，然后在其中进行少部分的修改，结果就是用户很难分清哪些是自定义的，当用户打算升级URP版本时，就会遇到很多问题 于是我把URP复制到另一个项目中，仅仅做必须在URP做的修改（比如加一个GT Tonemapping），其他的RenderFeature和Shader都在主项目中进行，于是主项目中几乎没有Unity URP自带的内容，十分简洁 功能实现 详情 为什么不想做了 TA届有句名言，工匠克算法 我感觉卡渲的效果太依赖模型、材质了，而我自己不能产出这些资源，游戏公司公开的mmd模型并不是他们实际使用的，很多feature所需的资产并没有公开，非常劝退 而且我感觉URP的设计没有想象中那么好，我想添加一个Tonemapping需要改URP源码，想自己实现阴影要注释掉很多东西，RenderGraph的API频繁改动，让人没有上的欲望","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"},{"name":"URP","slug":"URP","permalink":"https://reubensun.com/tags/URP/"}]},{"title":"Unity 性能优化","slug":"engine/Unity性能优化","date":"2024-10-09T16:24:25.000Z","updated":"2025-03-18T07:16:42.959Z","comments":true,"path":"engine/Unity性能优化/","permalink":"https://reubensun.com/engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"Unity 性能优化 Unity版本为2022.3.34，本文所有的测试均在Editor下进行 尽管我认为，性能远远没有实现重要，提前优化、过度优化、虚空优化，之会影响开发效率，不过还是记录一下我最近学到的一些关于Unity性能优化的小技巧 脚本优化 测试工具 public class CustomTimer: IDisposable&#123; private string _name; private int _count; private Stopwatch _stopwatch; public CustomTimer(string name, int count) &#123; _name = name; _count = count; if (_count &lt;= 0) &#123; _count = 1; &#125; _stopwatch = Stopwatch.StartNew(); &#125; public void Dispose() &#123; _stopwatch.Stop(); UnityEngine.Debug.Log($&quot;&#123;_name&#125; took &#123;_stopwatch.ElapsedMilliseconds&#125;ms for &#123;_count.ToString(&quot;N0&quot;)&#125; iterations, average time: &#123;_stopwatch.ElapsedMilliseconds / _count&#125;ms&quot;); &#125;&#125; GetComponent的方式 测试三种获得Component的方式 ComponentTest comp = null;using (new CustomTimer(&quot;GetComponent(string)&quot;, testCount))&#123; for(int i = 0; i &lt; testCount; i++) &#123; comp = (ComponentTest)GetComponent(&quot;ComponentTest&quot;); &#125;&#125;using (new CustomTimer(&quot;GetComponent&lt;&gt;&quot;, testCount))&#123; for(int i = 0; i &lt; testCount; i++) &#123; comp = GetComponent&lt;ComponentTest&gt;(); &#125;&#125;using (new CustomTimer(&quot;GetComponent(typeof(ComponentTest))&quot;, testCount))&#123; for(int i = 0; i &lt; testCount; i++) &#123; comp = (ComponentTest)GetComponent(typeof(ComponentTest)); &#125;&#125; 经测试，几乎无差别（貌似老版本会有区别，用string最慢） GetComponent(string) took 136ms for 1,000,000 iterations, average time: 0msGetComponent&lt;&gt; took 115ms for 1,000,000 iterations, average time: 0msGetComponent(typeof(ComponentTest)) took 177ms for 1,000,000 iterations, average time: 0ms 比较go是否为null int ans = 0;using (new CustomTimer(&quot;Empty&quot;, testCount))&#123; for(int i = 0; i &lt; testCount; i++) &#123; ans++; &#125;&#125;Debug.Log(ans);ans = 0;using (new CustomTimer(&quot;!=&quot;, testCount))&#123; for(int i = 0; i &lt; testCount; i++) &#123; if (go != null) &#123; ans++; &#125; &#125;&#125;Debug.Log(ans);ans = 0;using (new CustomTimer(&quot;ReferenceEquals&quot;, testCount))&#123; for(int i = 0; i &lt; testCount; i++) &#123; if(!System.Object.ReferenceEquals(go, null)) &#123; ans++; &#125; &#125;&#125;Debug.Log(ans); 经测试，直接比较是!= null更慢 Empty took 21ms for 100,000,000 iterations, average time: 0ms!= took 445ms for 100,000,000 iterations, average time: 0msReferenceEquals took 22ms for 100,000,000 iterations, average time: 0ms 检索Tag int ans = 0;using (new CustomTimer(&quot;string tag&quot;, testCount))&#123; for(int i = 0; i &lt; testCount; i++) &#123; if (go.tag == &quot;Player&quot;) &#123; ans++; &#125; &#125;&#125;Debug.Log(ans);ans = 0;using (new CustomTimer(&quot;CompareTag&quot;, testCount))&#123; for(int i = 0; i &lt; testCount; i++) &#123; if (go.CompareTag(&quot;Player&quot;)) &#123; ans++; &#125; &#125;&#125;Debug.Log(ans); 直接比较tag字符串更慢 string tag took 162ms for 1,000,000 iterations, average time: 0msCompareTag took 70ms for 1,000,000 iterations, average time: 0ms Update 停止远处GO的脚本update 分层update 序列化 重写序列化，只保留一些必须的参数，尽量存储简单的数据结构，反序列化时自行从Resources.LoadAsync()中加载出来 图形优化 SRP Bather","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"强化学习","slug":"ai/RL","date":"2024-10-07T20:20:25.000Z","updated":"2025-03-18T07:16:48.447Z","comments":true,"path":"ai/RL/","permalink":"https://reubensun.com/ai/RL/","excerpt":"","text":"强化学习 跟同事聊了一会强化学习做AI游戏，感觉难度很大很麻烦，遂断更 游戏的奖励频率过低，电子游戏很难像围棋那样计算每一步的收益，就像训狗一样，你让狗坐下给一次奖励，训练效果会很好，但让狗做非常多复杂的组合动作再给一次奖励，就很难训练 数据难以收集，AI玩游戏通常是现有一个游戏，再去做AI，这些AI公司一般都没有与游戏公司合作，于是难以拿到原始的状态同步信息，只能抓取屏幕提取参数，难以获得海量数据（比如你难以让几万台机器去玩CSGO来收集数据） 状态空间过于复杂，游戏中需要同步的数据非常大，随着状态空间的复杂化，训练所需的数据骤增，训练速度也减慢，而因为第二条，我们已经很难获得数据了，于是雪上加霜 没有优秀先例，研究员研究RL很久了，但是至今没有一个极具影响力的RL玩游戏，甚至一些RL大佬都唱衰强化学习，认为这没有用，因此这是一个风险巨大，前路坎坷的方向（当然如果成功了，收益也很高） 强化学习系统由四个部分组成： 策略，根据环境和状态决定动作，是一组概率，内容为当智能体状态为s时，采取特定动作a的概率 奖励，智能体试图实现的目标，往往配合折扣因子（Discount Factor）设计 价值函数 环境模型 不断进行着状态Obs—动作A—新状态和奖励的循环 马尔可夫决策 图形学的光追部分，也大量使用了概率论和马尔可夫决策 强化学习涉及序列决策，使用马尔可夫决策过程（Markov Decision Process，MDP）对问题进行建模 马尔可夫条件 未来与过去无关 给定当前状态和所有过去状态，其未来状态（的条件概率）仅与当前状态有关 满足马尔可夫独立性，意味着强化学习模型，不需要记住如何到达当前的状态，只需要根据当前状态就能决定需要做什么 蒙特卡洛：对大量模拟的结果取平均值，用来逼近期望 马尔可夫决策过程 通过引入额外的（可选的）动作，扩展马尔可夫决策链，是否使用这个动作会影响最终的累积回报G，通过比较这两个G，我们可以得到这个动作该不该做 回溯图 其实是一个树 表示从初始状态开始，深度优先搜索每一个可能性，将这个过程化成树 树的每一个叶子结点表示无法得到解返回（或提前返回）的状态，当遇到这种情况，将回溯到父节点，继续遍历 贝尔曼方程 贝尔曼最优方程 Gym Gym是一个被广泛使用的强化学习框架 CartPole CartPole是一个在小车上放置了一根竖直向上的细杆，控制小车在X轴上移动，使得细杆尽可能长时间维持竖直向上的任务 import gymimport imageio# 由于我是在无头环境执行，所以将渲染结果保存为视频env = gym.make(&#x27;CartPole-v1&#x27;, render_mode=&quot;rgb_array&quot;)writer = imageio.get_writer(&#x27;gym_video.mp4&#x27;, fps=30)obs, info = env.reset()print(&quot;Observation: &quot;, obs) # Observation: [-0.03702318 0.0486786 0.04819322 0.00019955]print(&quot;Action Space: &quot;, env.action_space.n) # Action Space: 2def policy(obs): return env.action_space.sample()for i in range(100): action = policy(obs) print(&quot;Action: &quot;, action) obs, reward, terminated, truncated, info = env.step(action) frame = env.render() writer.append_data(frame) if terminated or truncated: observation, info = env.reset()writer.close()env.close() 参考 gym doc","categories":[{"name":"ai","slug":"ai","permalink":"https://reubensun.com/categories/ai/"}],"tags":[{"name":"RL","slug":"RL","permalink":"https://reubensun.com/tags/RL/"}]},{"title":"Python numpy","slug":"program/numpy","date":"2024-09-27T13:01:25.000Z","updated":"2025-03-18T07:16:42.968Z","comments":true,"path":"program/numpy/","permalink":"https://reubensun.com/program/numpy/","excerpt":"","text":"Python numpy 我发现Python numpy的性能真的是特别强，甚至可以用来写ShaderToy Numpy画圆的性能对比 对一张512x512的图片，使用ShaderToy的方式画圆，性能居然能差50倍！ import numpy as npfrom PIL import Imageimport timedef save_image(data, out_path): data = data.astype(np.uint8) image = Image.fromarray(data, mode=&#x27;L&#x27;) image.save(out_path)def sdf_sphere(x, y, cx, cy, r): &quot;&quot;&quot;计算点 (x, y) 到中心为 (cx, cy) 且半径为 r 的圆的符号距离&quot;&quot;&quot; dx = x - cx dy = y - cy return np.sqrt(dx * dx + dy * dy) - rdef func1(input_image): &quot;&quot;&quot;For循环遍历每一个元素&quot;&quot;&quot; width = input_image.shape[0] height = input_image.shape[1] print(f&#x27;width: &#123;width&#125;, height: &#123;height&#125;&#x27;) for i in range(width): for j in range(height): u = i / width v = j / height if sdf_sphere(u, v, 0.5, 0.5, 0.2) &lt; 0.1: input_image[i, j] = 255 return input_imagedef func2(input_image): &quot;&quot;&quot;使用np向量操作&quot;&quot;&quot; width = input_image.shape[0] height = input_image.shape[1] u, v = np.meshgrid(np.linspace(0, 1, width), np.linspace(0, 1, height), indexing=&#x27;ij&#x27;) distances = sdf_sphere(u, v, 0.5, 0.5, 0.2) input_image[distances &lt; 0.1] = 255 return input_imageif __name__ == &quot;__main__&quot;: image1 = np.zeros((512, 512), dtype=np.float32) image2 = np.zeros((512, 512), dtype=np.float32) start_time = time.time() out1 = func1(image1) end_time = time.time() print(end_time - start_time) # 0.4647049903869629 start_time = time.time() out2 = func2(image2) end_time = time.time() print(end_time - start_time) # 0.00978851318359375 save_image(out1, &#x27;assets/temp/image.png&#x27;) save_image(out2, &#x27;assets/temp/image2.png&#x27;) 2D SDF 圆 def sdf_sphere(x, y, cx, cy, r): &quot;&quot;&quot;计算点 (x, y) 到中心为 (cx, cy) 且半径为 r 的圆的符号距离&quot;&quot;&quot; dx = x - cx dy = y - cy return np.sqrt(dx * dx + dy * dy) - r 正方形 def sdf_square(x, y, cx, cy, size): &quot;&quot;&quot;计算点 (x, y) 到中心为 (cx, cy) 且边长为 size 的正方形的符号距离&quot;&quot;&quot; dx = np.maximum(np.abs(x - cx) - size / 2, 0) dy = np.maximum(np.abs(y - cy) - size / 2, 0) return np.sqrt(dx * dx + dy * dy) 正方形线框 def sdf_square_frame(x, y, cx, cy, size): dx = np.abs(x - cx) - size / 2 dy = np.abs(y - cy) - size / 2 outside_distance = np.sqrt(np.maximum(dx, 0)**2 + np.maximum(dy, 0)**2) inside_distance = -np.minimum(np.maximum(dx, dy), 0) return outside_distance + inside_distance 常用Numpy函数 np.prod 返回输入数组中所有元素的乘积 arr = np.array([[1, 2], [3, 4]])result = np.prod(arr) # 24 = 1 * 2 * 3 *4# 根据轴result2 = np.prod(arr, axis=0) # [3, 8], 3 = 1 * 3, 8 = 2 * 4# 使用初始值result3 = np.prod(arr, initial=2) # 48 = 2 * 1 * 2 * 3 * 4 参考 sdf","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"}]},{"title":"PyBind11实现Python调用C++","slug":"program/pybind11","date":"2024-09-21T00:01:25.000Z","updated":"2025-03-18T07:16:42.968Z","comments":true,"path":"program/pybind11/","permalink":"https://reubensun.com/program/pybind11/","excerpt":"","text":"PyBind11实现Python调用C++ 我曾经写过一篇SWIG实现Python调用C++的文章，SWIG是一个非常好用的通用工具，可以实现很多语言间的互通，不过最近我发现一个专门为Python和C++设计的库，PyBind11，AI领域貌似更喜欢这个库 PyBind11是一个非常轻量的纯头文件库，可以看作对Boost.Python的简化模仿，这个库要求至少使用C++11、Python 3.6，使用条件相对苛刻，但说实话，对于新项目这个版本要求并不过分 PyBind11有很多优点，我个人比较喜欢将项目嵌入到CMake项目，并使用pip install进行安装 嵌入到CMake项目 1. submodule 首先将PyBind11库作为Submodule添加到项目根目录（你也可以放在其他地方）下的pybind11文件夹 git submodule add https://github.com/pybind/pybind11.git pybind11 2. setup.py 在项目根目录添加一个setup.py文件，便于pip安装 可以基于官方示例修改 3. CMakeList.txt cmake_minimum_required(VERSION 3.21)project(pycppstudy LANGUAGES CXX)set(CMAKE_CXX_STANDARD 11)add_subdirectory(pybind11)file(GLOB_RECURSE HEADERS src/*.h)file(GLOB_RECURSE SOURCES src/*.cpp)pybind11_add_module($&#123;PROJECT_NAME&#125; $&#123;HEADERS&#125; $&#123;SOURCES&#125;) 核心是通过pybind11_add_module创建库 4. 编写代码 引入pybind11头文件，并编写约定 #include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;int add(int i, int j) &#123; return i + j;&#125;// 约定PYBIND11_MODULE(pycppstudy, m) &#123; m.doc() = &quot;pybind11 pycppstudy plugin&quot;; m.def(&quot;add&quot;, &amp;add, &quot;A function that adds two numbers&quot;);&#125; 5. 安装包 在这个项目的外层，输入命令 pip install -e ./&lt;项目文件夹名&gt; 就会按照自定义的包 卸载包的方式是 pip uninstall &lt;包名&gt; 6. 使用 import pycppstudypycppstudy.add(1, 2) # 3","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"},{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"OpenAI API","slug":"ai/OpenAI","date":"2024-09-13T14:00:25.000Z","updated":"2025-03-18T07:16:42.957Z","comments":true,"path":"ai/OpenAI/","permalink":"https://reubensun.com/ai/OpenAI/","excerpt":"","text":"OpenAI API 我这里使用的Step开放平台，其API与OpenAI兼容 Python可以使用openai库轻松调用一些大模型服务，对Agent工程师来说非常有用 对话 from openai import OpenAI client = OpenAI(api_key=&quot;xxxxx&quot;, base_url=&quot;https://api.stepfun.com/v1&quot;) completion = client.chat.completions.create( model=&quot;step-1-8k&quot;, messages=[ &#123; &quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;你是由阶跃星辰提供的AI聊天助手，你擅长中文，英文，以及多种其他语言的对话。在保证用户数据安全的前提下，你能对用户的问题和请求，作出快速和精准的回答。同时，你的回答和建议应该拒绝黄赌毒，暴力恐怖主义的内容&quot;, &#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，请介绍一下阶跃星辰的人工智能!&quot;&#125;, ],) print(completion) 流式响应 from openai import OpenAIimport sys# api_key需要自己申请 client = OpenAI(api_key=&quot;xxxxx&quot;, base_url=&quot;https://api.stepfun.com/v1&quot;) completion = client.chat.completions.create( model=&quot;step-1-8k&quot;, stream = True, messages=[ &#123; &quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;你是由阶跃星辰提供的AI聊天助手，你擅长中文，英文，以及多种其他语言的对话。在保证用户数据安全的前提下，你能对用户的问题和请求，作出快速和精准的回答。同时，你的回答和建议应该拒绝黄赌毒，暴力恐怖主义的内容&quot;, &#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，请介绍一下阶跃星辰的人工智能!&quot;&#125;, ],)# 流式打印出来for chunk in completion: sys.stdout.write(chunk.choices[0].delta.content) sys.stdout.flush() 多轮对话 将先前双方的对话内容（包含system）塞入messages中，在末尾加入本次问题 传入history模型会利用kvcache加速，于是多轮的回答耗时不会显著提升（耗时会随着history增长而延长，但并不显著） 你可以一个滑动窗口截断history local_message = []local_message.append(&#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;xxxxx&quot;&#125;)if history is not None: for his in history: local_message.append(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: his[0]&#125;) local_message.append(&#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: his[1]&#125;)local_message.append(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;xxxxxx&quot;&#125;)completion = client.chat.completions.create( model=&quot;step-1-8k&quot;, messages=local_message)# 再将completion的输入和结果塞入history中","categories":[{"name":"ai","slug":"ai","permalink":"https://reubensun.com/categories/ai/"}],"tags":[{"name":"OpenAI","slug":"OpenAI","permalink":"https://reubensun.com/tags/OpenAI/"}]},{"title":"CRTP","slug":"program/CRTP","date":"2024-08-15T17:49:25.000Z","updated":"2025-03-18T07:16:42.966Z","comments":true,"path":"program/CRTP/","permalink":"https://reubensun.com/program/CRTP/","excerpt":"","text":"奇异递归模板模式 Curiously Recurring Template Pattern，CRTP 最近发现一个很优雅的写法，CRTP，利用了模版和继承的特性，实现了一种奇观的“自我认知”，可以省去写很多重复代码 C#实现一个单例 定义 using System.Collections;using System.Collections.Generic;using UnityEngine;public class Singleton&lt;T&gt; : MonoBehaviour where T : Component&#123; protected static T _instance; public static bool HasInstance =&gt; _instance != null; public static T Instance &#123; get &#123; if (_instance == null) &#123; _instance = FindObjectOfType&lt;T&gt; (); if (_instance == null) &#123; GameObject obj = new GameObject (); obj.name = typeof(T).Name + &quot;_AutoCreated&quot;; _instance = obj.AddComponent&lt;T&gt; (); &#125; &#125; return _instance; &#125; &#125; protected virtual void Awake () &#123; InitializeSingleton(); &#125; protected virtual void InitializeSingleton() &#123; if (!Application.isPlaying) &#123; return; &#125; _instance = this as T; &#125;&#125; 使用 public class GlobalTableManager : Singleton&lt;GlobalTableManager&gt;&#123;...&#125; C++实现一个单例 定义 #include &lt;iostream&gt;template &lt;typename T&gt;class Singleton &#123;protected: static T* instance; Singleton() &#123;&#125; // 构造函数私有，确保不能直接实例化public: static T* getInstance() &#123; if (!instance) &#123; instance = new T(); &#125; return instance; &#125; static void destroyInstance() &#123; delete instance; instance = nullptr; &#125;&#125;;template &lt;typename T&gt;T* Singleton&lt;T&gt;::instance = nullptr; 使用 class MySingleton : public Singleton&lt;MySingleton&gt; &#123;public: void print() &#123; std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; MySingleton::getInstance()-&gt;print(); return 0;&#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"},{"name":"Csharp","slug":"Csharp","permalink":"https://reubensun.com/tags/Csharp/"}]},{"title":"Unity Luban","slug":"engine/UnityLuban","date":"2024-08-10T00:01:25.000Z","updated":"2025-03-18T07:16:42.958Z","comments":true,"path":"engine/UnityLuban/","permalink":"https://reubensun.com/engine/UnityLuban/","excerpt":"","text":"Unity Luban表格工具 Luban是一个很好用的导表工具 Unity Luban由三部分组成： Unity Package，用于读取json 导表工具，点击一下.bat，就能将表格转为C#和json 生成的代码+ExternalTypeUtil，这部分将放在Unity Assets内 项目初始化 一：下载导表工具 参考Csharp Unity json，在Unity项目外某处新建一个文件夹，将表格和Tools放在其中，并创建一个gen.bat set LUBAN_DLL=.\\Tools\\Luban\\Luban.dllset CONF_ROOT=.\\DataTablesdotnet %LUBAN_DLL% ^ -t client ^ -c cs-simple-json ^ -d json ^ --conf %CONF_ROOT%\\luban.conf ^ -x outputCodeDir=..\\Assets\\Luban\\Gen ^ -x outputDataDir=..\\Assets\\Luban\\Jsonpause 二：安装Luban Unity Package 下载地址 下载后放入Packages文件夹中，在Project Setting中开启unsafe 三：生成 双击运行之前创建的gen.bat，就会在Assets对应的文件夹中生成json和相关代码 在再项目中添加文件ExternalTypeUtil.cs 四：使用 创建一个LoadByteBuf函数，用于找到json放置的位置，用new cfg.Tables(LoadByteBuf)加载表格 void Start()&#123; var tables = new cfg.Tables(LoadByteBuf); UnityEngine.Debug.LogFormat(&quot;item[1].name:&#123;0&#125;&quot;, tables.TbItem[1].Name); UnityEngine.Debug.Log(&quot;== load succ==&quot;);&#125;private static JSONNode LoadByteBuf(string file)&#123; return JSON.Parse(File.ReadAllText(Application.dataPath + &quot;/Luban/Json/&quot; + file + &quot;.json&quot;, System.Text.Encoding.UTF8));&#125; 创建自己的表格 按照表格规范创建一个自己的表格 在__tables__.xlsx中添加刚刚的表格","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"Unity UI 开发","slug":"engine/UnityUI开发","date":"2024-08-08T22:01:25.000Z","updated":"2025-03-18T07:16:48.446Z","comments":true,"path":"engine/UnityUI开发/","permalink":"https://reubensun.com/engine/UnityUI%E5%BC%80%E5%8F%91/","excerpt":"","text":"Unity UI 开发 使用中文字体 在使用Unity制作游戏时，想要UI（TMP）使用中文字体 下载一个字体文件.ttf 下载一个中文字符集.txt 分享一个字符集项目https://github.com/wy-luke/Unity-TextMeshPro-Chinese-Characters-Set.git Window–TextMeshPro–Font Asset Creator 富文本字体 Unity的Text支持富文本 比如让下面这段文字中colorfully变色 We are &lt;color=#ff0000ff&gt;colorfully&lt;/color&gt; amused 鼠标事件 为UI物体添加2D碰撞体后，可以在上面绑定脚本，添加生命周期函数，如OnMouseEnter，OnMouseExit","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"Gradio","slug":"program/Gradio","date":"2024-08-01T11:01:25.000Z","updated":"2025-03-18T07:16:42.967Z","comments":true,"path":"program/Gradio/","permalink":"https://reubensun.com/program/Gradio/","excerpt":"","text":"Gradio Gradio是一个基于Python的Web UI框架，常用于AI demo搭建，SD的webui就使用的Gradio Gradio采用函数式编程，由组件和函数组成，声明组件即可绘制UI，为组件绑定函数可以修改组件内容 可以在Gradio Playground中预览体验 基本语法 Blocks 我不太喜欢 Interface 相较于Interface，Blocks可以使用gr.Row()等排版方式，更灵活 Gradio可以渲染一个markdown、html文本，可以将一些大段文字写在资源里，运行时读资源文本 在某个层级声明一个组件（比如Button）就会渲染一个按钮，可以用循环等方式批量生成 组件可以绑定事件，事件由函数+输入+输出组成 import gradio as grimport shutilfrom pathlib import Pathimport zipfilewith gr.Blocks() as demo: # MARK! # 声明一个Markdown标题 gr.Markdown(&#x27;# Hello Title&#x27;) # 声明一个Upload button u = gr.UploadButton(&quot;Upload a file&quot;, file_count=&quot;single&quot;, file_types=[&quot;.zip&quot;]) # 下面的几个组件在一行 with gr.Row(): file_name_text = gr.Textbox(lines=1, label=&quot;File name&quot;) file_count_text = gr.Textbox(lines=1, label=&quot;File count&quot;) # 为Upload button绑定事件，输入是button本身，输出是两个Textbox u.upload(process_upload_file, inputs=u, outputs=[file_name_text, file_count_text])if __name__ == &quot;__main__&quot;: demo.launch(server_name=&quot;0.0.0.0&quot;, server_port=7860) # 端口，尤其是要将服务暴露出去时 demo.queue(concurrency_count=3) TabbedInterface 可以将多个Blocks和在一起，通过左上角的页签切换显示的Blocks，很适合多个平行功能的开发 with gr.Blocks() as demo: ...with gr.Blocks() as demo2: ...app = gr.TabbedInterface([demo, demo2], [&#x27;Demo Name&#x27;, &#x27;Demo2 Name&#x27;])app.launch(server_name=&quot;0.0.0.0&quot;, server_port=7861) 函数 我感觉gradio的函数写法很神奇，你在函数外只能声明组件，不能拿到组件的值，不能修改组件，想做1+1也要使用函数 为组件绑定函数时，inputs和outputs均为组件（或组件数组），但函数的输入和输出是组件的值，而非组件本身，比如你为一个函数绑定了输出为一个Textbox，你只需要返回一个字符串就行 # 这个函数的输入是一个upload button对应的内容def process_upload_file(file): upload_dir = Path(&quot;./uploads&quot;) upload_dir.mkdir(parents=True, exist_ok=True) # Create the directory if it doesn&#x27;t exist file_path = upload_dir / Path(file.name) shutil.copy(file, upload_dir) unzip_folder = upload_dir / Path(file).stem with zipfile.ZipFile(file_path, &#x27;r&#x27;) as zip_ref: zip_ref.extractall(unzip_folder) # 输出是两个字符串 return Path(file).stem, len(zip_ref.namelist()) 全局变量 在外部定义一个全局变量，在函数中可以访问 stop_animation = Falsedef play_animation(file_name, current_frame, file_count, frame_rate): global stop_animation stop_animation = False for i in range(int(current_frame), int(file_count)): if stop_animation: break time.sleep(1/float(frame_rate)) progress = (i+1)/int(file_count) with open(f&#x27;uploads/&#123;file_name&#125;/&#123;i&#125;.svg&#x27;, &#x27;r&#x27;) as f: svg_content = f.read() # 这里的yield是stream用法 yield svg_content, i, progressdef stop_animation(): global stop_animation # MARK! stop_animation = Truewith gr.Blocks() as demo: ... html = gr.HTML() with gr.Row(): btn = gr.Button(&quot;Start&quot;) stop_btn = gr.Button(&quot;Stop&quot;) btn.click(play_animation, inputs=[file_name_text, frame_index, file_count_text, frame_rate], outputs=[html, frame_index, sl]) stop_btn.click(stop_animation) 组件 示例 可以给一些输入组件提供示例，点一下自动填充 input_image = gr.Image(type=&quot;filepath&quot;)gr.Examples( examples=[ [osp.join(example_portrait_dir, &quot;hal.jpeg&quot;)], [osp.join(example_portrait_dir, &quot;s7.jpg&quot;)], ], inputs=[input_image], cache_examples=False,) 其他 网络连接bug https://github.com/gradio-app/gradio/issues/4332","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"},{"name":"Web","slug":"Web","permalink":"https://reubensun.com/tags/Web/"}]},{"title":"Linux下GCC降级","slug":"program/GCC降级","date":"2024-07-30T14:01:25.000Z","updated":"2025-03-18T07:16:42.966Z","comments":true,"path":"program/GCC降级/","permalink":"https://reubensun.com/program/GCC%E9%99%8D%E7%BA%A7/","excerpt":"","text":"Linux下GCC降级 CUDA版本需要和gcc版本对应，兼容性出奇地差，Ubuntu自带gcc，但是通常版本很高，于是需要对gcc进行降级 降级到gcc-7 安装gcc-7 sudo apt-get install gcc-7 g++-7 设置gcc版本优先级 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 9sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 1 查看gcc版本优先级 sudo update-alternatives --display gcc 设置g++版本优先级 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 9sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 1 查看g++版本优先级 sudo update-alternatives --display g++ 参考 https://blog.csdn.net/weixin_39529413/article/details/109098144","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://reubensun.com/tags/Linux/"},{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"Photoshop使用笔记","slug":"dcc/PS使用笔记","date":"2024-07-28T23:01:25.000Z","updated":"2025-03-18T07:16:48.447Z","comments":true,"path":"dcc/PS使用笔记/","permalink":"https://reubensun.com/dcc/PS%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Photoshop使用笔记 白天变黑夜 导入图片，解除图片锁定 右下角点击曲线 将曲线的右上角点向下移动，此时整个图片将会变黑 添加一个新图层，用画笔工具在图层中画白色内容 将新图层设为叠加，于是白色内容部分就会变亮","categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"}],"tags":[{"name":"PS","slug":"PS","permalink":"https://reubensun.com/tags/PS/"}]},{"title":"Unity自定义Package","slug":"engine/UnityPackage","date":"2024-07-17T12:01:25.000Z","updated":"2025-03-18T07:16:42.958Z","comments":true,"path":"engine/UnityPackage/","permalink":"https://reubensun.com/engine/UnityPackage/","excerpt":"","text":"Unity自定义Package 每一个Unity图形引擎中台，都应该学会自定义一个Unity Package，这样你的代码可以与项目解耦，也可以在多个项目间复用，通过版本控制可以提高维护性 版本管理 个人建议直接使用Git进行管理，创建一个Git仓库，使用时只需要在项目Packages文件夹下git clone package.json 在根目录下添加文件package.json，Unity将会将当前文件夹识别为一个Package &#123; &quot;name&quot;: &quot;com.reubensun.toonurp&quot;, &quot;description&quot;: &quot;A omnipotence rendering pipeline for Unity&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;unity&quot;: &quot;2022.3&quot;, &quot;displayName&quot;: &quot;Toon URP&quot;, &quot;dependencies&quot;: &#123; &quot;com.unity.mathematics&quot;: &quot;1.2.1&quot;, &quot;com.unity.burst&quot;: &quot;1.8.4&quot;, &quot;com.unity.render-pipelines.universal&quot;: &quot;14.0.10&quot; &#125;, &quot;author&quot;: &#123; &quot;name&quot;: &quot;Reuben Sun&quot;, &quot;url&quot;: &quot;https://github.com/Reuben-Sun/ToonURP&quot; &#125;, &quot;keywords&quot;: [ &quot;shaders&quot;, &quot;toon&quot; ], &quot;samples&quot;: [ &#123; &quot;displayName&quot;: &quot;ToonURP Package Samples&quot;, &quot;description&quot;: &quot;Collection of scenes showcasing different features of the Toon URP.&quot;, &quot;path&quot;: &quot;Samples&quot; &#125; ]&#125; name：包名称 description：在Package manager中包的描述 version：当前包的版本号 dependencies：对其他包的依赖（通常只写对Unity官方库的依赖） samples：添加后用户可以在Package manager中选择Import你包的Samples文件夹到Assets目录（你可以将你的Samples目录后面加入一个~，这样Unity就不会默认Import这个文件夹，便于精简包） 程序集定义 如果你的包有Editor和Runtime的代码，可以在这两个文件夹中添加程序集定义（Create–Assembly Definition） Runtime的程序集命名为xxx，Editor命名为xxx.Editor，设置他们的平台和程序集引用，Editor程序集要引用Runtime程序集 Changelog.md 在根目录添加CHANGELOG.md，并按 Keep a Changelog和 Semantic Versioning手动编写 LICENSE.md 在根目录添加LICENSE.md，并设定自己喜欢的开源协议 Documentation～ 在根目录添加Documentation～文件夹，并在其中添加一些.md文件，用于描述包中功能","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"基于Odin的Unity编辑器工具开发","slug":"engine/UnityOdin","date":"2024-06-11T14:01:25.000Z","updated":"2025-03-18T07:16:48.446Z","comments":true,"path":"engine/UnityOdin/","permalink":"https://reubensun.com/engine/UnityOdin/","excerpt":"","text":"基于Odin的Unity编辑器工具开发 Odin是一个非常好用的Unity Editor工具开发框架，非常简洁，不过会被打入游戏包体内部 Odin使用起来非常简单，使用一些Attribute就可以暴露参数、按钮、生命周期函数，于是这里没有Odin基础教程，大部分是我自己的理解 插件化示例 需求：插件化 这是一个使用C# Attribute自动注册窗口的示例，通过对类进行标注，就可以自动添加到MenuWindow上，不需要改动Menu代码 你可以将这些文件打包成程序集（DLL），选择性加载，以此实现插件化 Attribute Attribute是C#一个非常好用的功能，可以非常便捷地标注一个类 [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]public class PanelAttribute : Attribute&#123; public string Name &#123; get; &#125; public PanelAttribute(string name) &#123; Name = name; &#125;&#125; 通过添加新的Attribute类，可以分别添加到不同的Menu上 通过在Attribute中添加属性，可以存储更新信息，比如EditorIcon 具体的Panel [Panel(&quot;Ragdoll&quot;)]public class RagdollPanel&#123; [Title(&quot;Properties&quot;)] [ShowInInspector] public int AATime = 30;&#125; [Panel(&quot;Bake&quot;)]public class BakePanel&#123; [Title(&quot;Properties&quot;)] [ShowInInspector] public int test = 30;&#125; Menu Window 这里遍历的程序集中所有被PanelAttribute标注的类，创建出这些类的对象，并提取出Attribute内容 OdinMenuTree将以侧边栏+内容的形式展示所有的窗口 MenuItem用于在Editor顶部注册按钮，以便打开这个Menu public class MainMenu : OdinMenuEditorWindow&#123; protected override OdinMenuTree BuildMenuTree() &#123; var tree = new OdinMenuTree(); var pluginTypes = Assembly.GetExecutingAssembly().GetTypes() .Where(type =&gt; type.GetCustomAttributes(typeof(PanelAttribute), true).Length &gt; 0); foreach (var pluginType in pluginTypes) &#123; var attribute = (PanelAttribute)Attribute.GetCustomAttribute(pluginType, typeof(PanelAttribute)); var instance = Activator.CreateInstance(pluginType); tree.Add(attribute.Name, instance); &#125; return tree; &#125; [MenuItem(&quot;Tools/Baker Menu&quot;)] private static void OpenWindow() &#123; var window = GetWindow&lt;MainMenu&gt;(); window.position = GUIHelper.GetEditorWindowRect().AlignCenter(800, 600); &#125;&#125; 监听Http请求 需求：使用Http请求操控Editor [Panel(&quot;Web&quot;)]public class WebPanel&#123; private Thread workerThread; private bool stopFlag; // 用于停止工作线程 private HttpListener listener; [OnInspectorInit] void Start() &#123; Debug.Log(&quot;init&quot;); stopFlag = false; listener = new HttpListener(); listener.Prefixes.Add (&quot;http://localhost:7863/&quot;); listener.AuthenticationSchemes = AuthenticationSchemes.Anonymous; listener.Start (); workerThread = new Thread(DoWork); workerThread.Start(); &#125; [OnInspectorDispose] void End() &#123; Debug.Log(&quot;dispose&quot;); stopFlag = true; listener.Close(); &#125; private void DoWork() &#123; while (!stopFlag) &#123; // Debug.Log(&quot;working...&quot;); var result = listener.BeginGetContext(ListenerCallback, listener); Thread.Sleep(500); &#125; &#125; // 用于反序列化request中的json public class ActionInput &#123; public string Arg &#123; get; set; &#125; &#125; private void ListenerCallback(IAsyncResult result) &#123; var context = listener.EndGetContext (result); Debug.Log (&quot;Method: &quot; + context.Request.HttpMethod); string url = context.Request.Url.LocalPath.ToString(); Debug.Log (&quot;LocalUrl: &quot; + context.Request.Url.LocalPath); // 读请求中的json using (var reader = new StreamReader(context.Request.InputStream, context.Request.ContentEncoding)) &#123; string json = reader.ReadToEnd(); var data = JsonConvert.DeserializeObject&lt;ActionInput&gt;(json); Debug.Log(&quot;Data: &quot; + data.Arg); &#125; // 返回一个json if (url == &quot;/test&quot;) &#123; // 匿名类型（Anonymous Type） var ro = new &#123; message = &quot;This is the response.&quot;, timestamp = DateTime.Now &#125;; string jsonResponse = JsonConvert.SerializeObject(ro); byte[] buffer = System.Text.Encoding.UTF8.GetBytes(jsonResponse); context.Response.ContentType = &quot;application/json&quot;; context.Response.ContentLength64 = buffer.Length; context.Response.OutputStream.Write(buffer, 0, buffer.Length); &#125; context.Response.Close(); &#125;&#125; 请求测试 import requestsurl = &quot;http://localhost:7863/test&quot;data = &#123; &quot;Arg&quot;: &quot;这是一段测试文本&quot;,&#125;response = requests.post(url, json=data)if response.status_code == 200: print(response.json())else: print(&quot;Request failed with status code:&quot;, response.status_code) 输出 &#123;&#x27;message&#x27;: &#x27;This is the response.&#x27;, &#x27;timestamp&#x27;: &#x27;2024-06-17T14:43:25.1490146+08:00&#x27;&#125; 访问主线程 Web服务是跑在一个单独线程中，Unity Editor跑在主线程，于是Web服务无法调用很多API，可以使用delayCall EditorApplication.delayCall += () =&gt;&#123; EditorApplication.isPlaying = true;&#125;; 但是这个API还是有问题：Unity Editor在后台时，是不会刷新UI的，导致你必须点一下Editor窗口，或者一直保持在Editor窗口，才能正常运行 下面是另一个方法，我感觉更好 [Panel(&quot;Ragdoll&quot;)]public class RagdollPanel&#123; private static SynchronizationContext mainThreadContext; [OnInspectorInit] void Start() &#123; mainThreadContext = SynchronizationContext.Current; ... &#125; ... private void ListenerCallback(IAsyncResult result) &#123; mainThreadContext.Post(_ =&gt; &#123; EditorApplication.isPlaying = true; &#125;, null); &#125;&#125;","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"},{"name":"Editor","slug":"Editor","permalink":"https://reubensun.com/tags/Editor/"},{"name":"CSharp","slug":"CSharp","permalink":"https://reubensun.com/tags/CSharp/"}]},{"title":"Python 学习","slug":"program/python学习","date":"2024-05-24T13:01:25.000Z","updated":"2025-03-18T07:16:42.968Z","comments":true,"path":"program/python学习/","permalink":"https://reubensun.com/program/python%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Python 学习 很难绷，编程四五年，现在才学Python Python是一门很简单的语言，但很多语法跟C++、C#不一样，一眼看上去发现好多不认识的东西，在此记录一下 语法 循环 for i in range(5): print(i) # 0, 1, 2, 3, 4 循环指定范围 for i in range(1, 5): print(i) # 1, 2, 3, 4 循环指定步进步长 for i in range(0, 5, 2): print(i) # 0, 2, 4 索引 Python除了可以使用正向索引，还可以使用负向索引，表示为从最后一个元素开始倒着数，-1是最后一个元素 a = [0, 1, 2, 3, 4, 5]print(a[0]) # 0print(a[1]) # 1print(a[-1]) # 5print(a[-2]) # 4 这个功能常用于处理路径 file_path = &quot;datasets/xa/xaa/a.json&quot;file_name = file_path.split(&#x27;/&#x27;)[-1] # a.json 异常 try: if xxx: raise Exception(&quot;There is a error&quot;)except Exception as e: print(e) assert assert &lt;一个bool变量&gt; 若条件为真，程序继续进行 若条件为假，程序抛出AssertionError异常，可以加一个参数信息 assert &lt;一个bool变量&gt;, &lt;一个字符串参数&gt; 面向对象 创建一个类 class Student: def __init__(self, student_name): self.name = student_name def test(self): print(self.name) 魔法方法 python通关魔法方法（Magic Methods）为类提供一些机制，形如__xxx__的成员函数 对象创建和销毁 __new__：在对象创建之前调用，用于控制对象的创建过程。 __init__：在对象创建后调用，用于初始化对象的属性。 __del__：在对象被销毁时调用，用于清理资源。 字符串表示 __str__：返回对象的字符串表示，用于 print() 函数。 __repr__：返回对象的字符串表示，用于调试和开发。 序列操作 __len__：返回对象的长度，用于 len() 函数。 __getitem__：获取对象中指定键的值，用于索引操作。 __setitem__：设置对象中指定键的值，用于赋值操作。 __delitem__：删除对象中指定键的值，用于删除操作。 迭代器 __iter__：返回一个可迭代对象，用于 for 循环。 __next__：返回下一个迭代器对象，用于 next() 函数。 运算符重载 __add__：定义加法运算符。 __sub__：定义减法运算符。 __mul__：定义乘法运算符。 __div__：定义除法运算符。 __eq__：定义等于运算符。 __ne__：定义不等于运算符。 __lt__：定义小于运算符。 __le__：定义小于等于运算符。 __gt__：定义大于运算符。 __ge__：定义大于等于运算符。 属性访问 __getattr__：当访问不存在的属性时调用。 __getattribute__：拦截所有的属性访问。 __setattr__：拦截所有属性的赋值操作。 __delattr__：拦截所有属性的删除操作。 上下文管理 __enter__：在 with 语句开始时调用。 __exit__：在 with 语句结束时调用。 可调用对象 __call__：允许对象像函数一样被调用 容器 set # 创建一个setdataset = set()key = &#x27;1&#x27;# 添加一个元素dataset.add(key)# 判断元素是否在set中if key in dataset: print(key) # 将这个元素从set中移除 dataset.discard(key) list 切片 Python可以使用切片操作，从一个序列（如列表、元组或字符串）中获取一部分元素 numbers = [0, 1, 2, 3, 4, 5]print(numbers[:2]) # 输出：[0, 1]s = &quot;Hello&quot;print(s[:2]) # 输出：&#x27;He&#x27; 列表推导式 List Comprehension raw = [1, 2, 3, 4, 5]ans = [x-1 for x in raw] # ans = [0, 1, 2, 3, 4] import reinput = &quot;&lt;h1&gt;&lt;h3&gt;&lt;h5&gt;&lt;h7&gt;&quot;pattern = r&#x27;&lt;h(\\d+)&gt;&#x27;token_lst = [int(match) for match in re.findall(pattern, input)]# token_lst = [1, 3, 5, 7] dict 判断Dict中有无Key if &#x27;key_name&#x27; not in dic: xxx 关键词 with 很类似C#的using，用于打开文件，期间代码出现异常会正常关闭，加载的文件也会被关闭释放 with open(&#x27;file.txt&#x27;, &#x27;r&#x27;) as f: content = f.read() with open(&#x27;a.json&#x27;, &#x27;r&#x27;) as f: content = json.loads(f) with open(&#x27;a.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file: for line in file: print(line.strip()) 字符串 前缀 Python的字符串可以使用前缀表示某个格式和行为 原始字符串 转义字符将会被视为普通字符，常用于正则表达式和Windwos下文件路径 # 正则pattern = r&quot;\\d+&quot;# Windows路径path = r&quot;C:\\Users\\Admin\\Documents&quot; 格式化字符串 可以用&#123;&#125;来嵌入Python表达式 str1 = &#x27;Hello&#x27;str2 = f&#x27;str1: &#123;str1&#125;&#x27; # str1: Hello 字节字符串 s = b&quot;Hello, World!&quot; 匹配 endswith 可以用元组实现多种匹配 if str1.endswith((&#x27;.jpg&#x27;, &#x27;.png&#x27;)): ... 格式化数字 在按顺序输出文件名时，经常有格式化数字的需求 num = 12formatted_str = f&quot;&#123;num:04d&#125;&quot; # 0012f = 1.2222formatted_str_f = f&quot;&#123;f:.02f&#125;&quot; # 1.22 常用库 自定义文件 从自定义的python文件中import函数 # 当前python的同级目录下有一个utils.py文件，文件中定义了一个load_models函数from utils import load_models 也可以将当前文件添加到sys路径中 current_dir = os.path.dirname(os.path.abspath(__file__))sys.path.append(current_dir)from utils import load_models sys 传递参数，跟C++ main函数的argv意义相同 import sys# python a1 a2a1 = sys.argv[1] # a1a2 = sys.argv[2] # a2 os 遍历目录 访问文件夹下所有文件（递归遍历子文件夹） for dirpath, dirnames, filenames in os.walk(root_dir): for filename in filenames: file_path = os.path.join(dirpath, filename) # 打开 file_path 得到文件所在文件夹 不存在就创建文件夹 temp_folder = os.path.dirname(out_path)os.makedirs(temp_folder, exist_ok=True) unset http proxy os.environ.pop(&quot;http_proxy&quot;, None)os.environ.pop(&quot;https_proxy&quot;, None) 添加文件夹 可以import某个文件夹下的文件 libpath = os.path.abspath( os.path.join( os.path.dirname(os.path.abspath(__file__)), &quot;step_align&quot;, ))if os.path.exists(libpath): if libpath not in sys.path: sys.path.insert(0, libpath)from local_file import custom_class zipfile python可以在不解压文件的情况下读取文件内容 import zipfile# zipwith zipfile.ZipFile(f&#x27;&#123;file_name&#125;.zip&#x27;, &#x27;r&#x27;) as zip_ref: for name in zip_ref.namelist(): print(name) content = zip_ref.read(name).decode(&#x27;utf-8&#x27;) tarfile import tarfile# tarwith tarfile.open(f&#x27;&#123;file_name&#125;.tar&#x27;, &#x27;r&#x27;) as tar_ref: # 遍历包内所有文件 for member in tar_ref.getmembers(): # 压缩包中可能不是文件，而是文件夹 if member.isfile(): # 打印文件名 print(member.name) # 使用文件名直接读文件内容 content = tar_ref.extractfile(member).read().decode(&#x27;utf-8&#x27;) # 将文件解压到extract_dir文件夹下 tar_ref.extract(member, path=extract_dir) import tarfileimport shutil# 将target_folder整个压缩with tarfile.open(new_tar_path, &#x27;w&#x27;) as tar: for root, dirs, files in os.walk(target_folder): for file in files: file_path = os.path.join(root, file) tar.add(file_path, arcname=os.path.join(os.path.basename(root), file))# 删除target_foldershutil.rmtree(target_folder) 发起进程 import subprocessscript_path = &#x27;inference.py&#x27;arguments = [&#x27;-s&#x27;, &#x27;assets/examples/source/hal.jpeg&#x27;, &#x27;-d&#x27;, &#x27;assets/temp/sun.mp4&#x27;, &#x27;--flag_normalize_lip&#x27;]subprocess.call([&#x27;python&#x27;, script_path] + arguments) pkl 将参数存储为二进制 import pickledef read_pkl_file(file_path): with open(file_path, &#x27;rb&#x27;) as file: data = pickle.load(file) return data def write_pkl_file(file_path, data): with open(file_path, &#x27;wb&#x27;) as file: pickle.dump(data, file) random # 生成随机数ans = random.uniform(c_min, c_max)# 随机整数n = random.randint(1, 10)# 从数组中随机挑选500条不重复的select_list = random.sample(raw_list, 500) json # 读字符串为jsondata = json.loads(input_text)# 对象转为字符串json_str = json.dumps(data)# 从文件中加载jsonwith open(&#x27;xx.json&#x27;, &#x27;r&#x27;) as f: data = json.load(f)# 写json到文件with open(&#x27;xx.json&#x27;, &#x27;w&#x27;) as f: json.dump(data, f, ensure_ascii=False) moviepy moviepy是一个处理视频和音频的库 为视频配音 video = mp.VideoFileClip(&quot;1.mp4&quot;)audio = mp.AudioFileClip(&quot;2.mp3&quot;)video = video.set_audio(audio)video.write_videofile(&quot;3.mp4&quot;, codec=&quot;libx264&quot;, audio_codec=&quot;aac&quot;) opencv 查看视频帧率 pip install opencv-python import cv2# 打开视频文件video_path = &#x27;s18.mp4&#x27;cap = cv2.VideoCapture(video_path)# 获取视频的帧率fps = cap.get(cv2.CAP_PROP_FPS)print(f&#x27;视频的帧率为：&#123;fps&#125; FPS&#x27;)# 释放资源cap.release() plt 折线图 import matplotlib.pyplot as pltx = [1, 2, 3, 4, 5]y = [2, 3, 5, 7, 11]# 绘制折线图plt.plot(x, y, marker=&#x27;o&#x27;, linestyle=&#x27;-&#x27;, label=&#x27;line&#x27;)# 设置图表标题和刻度标签plt.title(&#x27;Graph&#x27;)plt.xlabel(&#x27;Frame&#x27;)plt.ylabel(&#x27;Value&#x27;)# 显示折线的名字# plt.legend() if enable_save: # 将图表保存为文件 plt.savefig(f&#x27;&#123;file_name&#125;.png&#x27;, dpi=300)# 显示图表（如果不是headless）plt.show() 散点图 value_x = []value_y = []plt.figure(figsize=(10, 10))# 绘制散点图plt.scatter(value_x, value_y)# 绘制文本plt.text(0, p5, f&#x27;P5: &#123;p5:.2f&#125;&#x27;, fontsize=20, verticalalignment=&#x27;bottom&#x27;, color=&#x27;r&#x27;, ha=&#x27;right&#x27;)# 绘制线plt.axhline(y=p5, color=&#x27;r&#x27;, linestyle=&#x27;--&#x27;)plt.xlabel(&#x27;x&#x27;)plt.ylabel(&#x27;y&#x27;)plt.title(&#x27;title&#x27;)# 布局风格plt.tight_layout()# 保存plt.savefig(&#x27;output.png&#x27;) 联合图表 import matplotlib.pyplot as plt# 创建一个2x2的联合图表fig, axes = plt.subplots(2, 2, figsize=(14, 10))axes[0, 0].scatter(xx, yy)axes[0, 0].set_xlabel(&#x27;x&#x27;)axes[0, 0].set_ylabel(&#x27;y&#x27;)axes[0, 0].set_title(&#x27;title 1&#x27;)axes[0, 1].scatter(xx, yy)axes[0, 1].set_xlabel(&#x27;x&#x27;)axes[0, 1].set_ylabel(&#x27;y&#x27;)axes[0, 1].set_title(&#x27;title 2&#x27;)axes[1, 0].scatter(xx, yy)axes[1, 0].set_xlabel(&#x27;x&#x27;)axes[1, 0].set_ylabel(&#x27;ye&#x27;)axes[1, 0].set_title(&#x27;title 3&#x27;)axes[1, 1].scatter(xx, yy)axes[1, 1].set_xlabel(&#x27;x&#x27;)axes[1, 1].set_ylabel(&#x27;y&#x27;)axes[1, 1].set_title(&#x27;title 4&#x27;)plt.tight_layout()plt.savefig(&#x27;output.png&#x27;) numpy 求百分位数 p5 = np.percentile(speed, 5)p50 = np.percentile(speed, 50)p95 = np.percentile(speed, 95) mask arr = np.array(rates)mask = arr &gt; 0.05count = mask.sum() # 统计数组rates中大于0.05的值的数量 ffmpeg 文件类型转换 import subprocessdef m4s_to_mp3(input_file, output_file): ffmpeg_command = [ &quot;ffmpeg&quot;, &quot;-i&quot;, input_file, &quot;-acodec&quot;, &quot;libmp3lame&quot;, &quot;-q:a&quot;, &quot;2&quot;, output_file ] subprocess.run(ffmpeg_command, check=True) m4s_to_mp3(&#x27;a.m4s&#x27;, &#x27;a.mp3&#x27;) 视频左右拼接 ffmpeg -i 101.mp4 -i o101.mp4 -filter_complex &quot;[0:v]pad=iw*2:ih[a];[a][1:v]overlay=w&quot; c101.mp4 tqdm 用于显示进度条 from tqdm import tqdmfor i in tqdm(range(100)): print(i) datasets Hugging face的数据类型 from datasets import Dataset, load_from_diskimport pandas as pd# 将jsonl保存为hf datasetsname = &#x27;combine&#x27;df = pd.read_json(f&quot;&#123;name&#125;.jsonl&quot;, lines=True)dataset = Dataset.from_pandas(df)dataset.save_to_disk(name)# 加载hf datasetsloaded_dataset = load_from_disk(name)print(len(loaded_dataset))print(loaded_dataset[0]) argparse 处理输入参数，自动转化为变量 import argparseparser = argparse.ArgumentParser()parser.add_argument(&#x27;--input_folder&#x27;, type=str, required=True, help=&#x27;The folder path to the dataset&#x27;)parser.add_argument(&#x27;--detail&#x27;, action=&#x27;store_true&#x27;, help=&#x27;Print detailed information&#x27;)parser.add_argument(&#x27;--max_steps&#x27;, type=int, default=2000000, help=&#x27;Max steps&#x27;)args = parser.parse_args()if args.detail: print(&#x27;The input folder is:&#x27;, args.input_folder) print(&#x27;The max steps is:&#x27;, args.max_steps)else: print(&#x27;The input folder is:&#x27;, args.input_folder) python parser_test.py --input_folder ./ --detail --max_steps 10 python parser_test.py --input_folder ./ --max_steps 10 imap 基于multiprocessing的并行处理代码 小技巧，如果我有一个巨大的dict，直接遍历处理会超内存，被Killed。可以将key转为哈希，根据dict的大小取哈希的前两三位，将dict摊开，再做处理 处理数组 import osimport ioimport jsonimport multiprocessingfrom tqdm import tqdm# 处理数组def process_item(item): index, name = item with open(f&#x27;hash_split/&#123;name&#125;&#x27;, &#x27;r&#x27;) as f: for line in f: info = json.loads(line.strip()) ... return item if __name__ == &quot;__main__&quot;: data = [] root_dir = &#x27;hash_split&#x27; # 这个文件存储了被哈希切分的jsonl们 for dirpath, dirnames, filenames in os.walk(root_dir): for filename in filenames: if filename.endswith(&#x27;.jsonl&#x27;): data.append(filename) # 并行处理 pool = multiprocessing.Pool(16) processed_data_iterator = tqdm(pool.imap(process_item, enumerate(data)), total=len(data)) processed_data = list(processed_data_iterator) pool.close() pool.join() 处理dict # 处理dictdef process_item(item): key, value = item ... return item if __name__ == &quot;__main__&quot;: data = &#123;&#125; # 并行处理 pool = multiprocessing.Pool(16) processed_data_iterator = tqdm(pool.imap(process_item, data.items()), total=len(data)) processed_data = list(processed_data_iterator) pool.close() pool.join() 带参数 import functoolsdef process_item(item, args): ... return item if __name__ == &quot;__main__&quot;: datas = [] pool = multiprocessing.Pool(16) partial_process_item = functools.partial(process_item, args=args) processed_data_iterator = tqdm(pool.imap(partial_process_item, datas), total=len(datas), desc=&quot;Process&quot;) result_list = list(processed_data_iterator) pool.close() pool.join() curl curl http://xxx/v1/api -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;text&quot;: [&quot;1&quot;, &quot;2&quot;]&#125;&#x27; 等价于 import requestsurl = &quot;http://xxx/v1/api&quot;headers = &#123; &quot;Content-Type&quot;: &quot;application/json&quot;&#125;data = &#123; &quot;text&quot;: [&quot;1&quot;, &quot;2&quot;]&#125;response = requests.post(url, headers=headers, json=data) torchaudio import torchaudio# 从路径加载音频waveform, sample_rate = torchaudio.load(file_path)# 获得音频时长，单位为秒duration = waveform.shape[1] / sample_rate warnings import warningswarnings.filterwarnings(&#x27;ignore&#x27;) dataclass 更方便定义一个数据类 from dataclasses import dataclass@dataclassclass ProcessConfig: batch_size = 32 save_folder = &quot;/tmp&quot; hashlib # 用md5生成字符串的16进制哈希hash_object = hashlib.new(&quot;md5&quot;)hash_object.update(lyrics.encode(&#x27;utf-8&#x27;))hex_hash = hash_object.hexdigest()print(hex_hash) datetime import timefrom datetime import datetime, timedeltacurrent_time = time.time()local_datetime = datetime.fromtimestamp(current_time)print(local_datetime) trimesh # 将GLB文件转为obj、mtl、贴图import trimeshmesh = trimesh.load(glb_path)# 检查是否为场景（多网格）if isinstance(mesh, trimesh.Scene): mesh = mesh.dump(concatenate=True)# 导出为 OBJmesh.export(obj_path) 如果没能导出图片，那么更新一下包 pip install --upgrade trimesh pillow imageio 其他操作 找到site-packages from distutils.sysconfig import get_python_libprint(get_python_lib()) pip requirements.txt 下载requirements.txt pip install -r requirements.txt 生成 pipreqs ./ --encoding=utf8 --force 可编辑模式 pip install -e /path/to/my_package 选择一个本地python包路径，使用-e的pip，这个包内容会被链接到python环境中，对包内容的更改会实时影响python环境里的包内容，便于bao 以包的形式运行 python3 -m &lt;package name&gt;.&lt;file name&gt; 等价于 cd &lt;package folder&gt;python3 &lt;file name&gt;.py 但这种调用方式可以用.和..，import包 bash export music_type=&quot;song&quot;export model_name=&quot;llama3.1&quot;export retry_count=5python3 call.py --music_type $music_type --model_name $model_name --retry_count $retry_count 调试 话说我发现一些同事居然在用IPython，感觉惊为天人（来自一个使用IDE人的震惊） from IPython import embedembed()","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"}]},{"title":"崩铁银河战士like同人游戏","slug":"game/崩铁银河战士like同人游戏","date":"2024-05-14T10:01:25.000Z","updated":"2025-03-18T07:16:42.959Z","comments":true,"path":"game/崩铁银河战士like同人游戏/","permalink":"https://reubensun.com/game/%E5%B4%A9%E9%93%81%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike%E5%90%8C%E4%BA%BA%E6%B8%B8%E6%88%8F/","excerpt":"","text":"崩铁银河战士like同人游戏 看到崩铁的萨姆第一眼，就感觉这个角色很帅，了解了剧情背景，感觉很适合做成银河战士类的游戏，定位是同人游戏，主要是为了讲故事，玩法基本“抄袭”银河战士 其实我感觉萨姆角色设计应该有参考银河战士 银河战士 星穹铁道 名字 萨姆斯 萨姆（流萤） 性别 女 女 任务 对抗寄生怪物 对抗繁育虫群 称号 银河战士 星核猎手 游戏背景 考虑到流萤还没正式上线，相关的文本很少，游戏剧情纯属我个人意淫，就当我是虚构史学派在构史吧 游戏时间是帝国和虫群还在战斗时，虫群袭击了养育间，为了抵抗虫群，研究员释放了尚未成熟的铁骑（也就是主角），主角此时缺少力量，但通过与虫群的厮杀，吸收了很多繁育的力量，最后冲出重围，消灭了虫群，存活下来 主旨就是求生，主角以错误的形式诞生，但是充满着对生命的渴望，她不想死，于是与虫群作战。在虫群作战中，看到到处的尸体与牺牲，深刻理解了飞萤扑火，向死而生。战斗结束后又了解自己天生患有失熵症，于是踏上了寻找生命意义的道路，为自己取名流萤 角色设计 玩家游玩的是萨姆，主要是想要体验战斗，爽，只会设计很少的能力锁，玩家的任务不是探索地宫，而是从地宫逃出，于是非必要不会回溯探索 能力 上勾拳，可以触发防反（玩过银河战士的应该都知道） 踢击，向前踢出一个较长的踢击，用于开门、破环墙壁（功能类似银河战士中开门打墙的导弹） 火焰踢击，补充能量后可以进行一次伤害巨大的踢击，能伤害到一些强大生物（参考银河战士生存恐惧中蓝色激光炮） 能量，将银河战士的电量和导弹合并，可以通过攻击敌人、安全屋补充 护盾，额外的护盾条，一段时间不受伤自动快速恢复 镭射，消耗能量的远距离光束攻击，有穿透能力 跳跃 原地起跳后左右移动能力很弱 跑跳后在空中可以进行翻滚，以跳的更远 空中转向会导致速度衰减 抓墙 主角可以单手抓住一个平台，再按跳跃会上平台 抓墙时可以发射镭射 冲刺，向前冲刺，有CD 地面上冲刺类似银河战士的瞬移，对boss战很有帮助 空中冲刺类似蔚蓝的二段跳 隐身，消耗能量短暂隐身，可以躲避一些怪物的视线 进阶能力 思考中 关卡设计 门 正常工作的门，靠近即可开门 一些毁坏的门，可以被踢击破坏 一些被虫群腐蚀的门，靠近就会关掉，需要隐身走过（这些门后面的房屋有虫子的核心，击破后腐蚀门就会变成普通的被毁坏的门 单向门 一些门是一次性的，走过后就会关闭，断我们后路 可破坏墙壁 一些由虫群尸体组成的墙壁，可以被踢击、镭射破坏 一些虫群的尸体组成的地板，踩上会直接破坏，但不能被踢击镭射破坏 一些坚固的虫群尸体组成的墙壁，需要用地面冲刺破坏 流程设计 像生存恐惧结尾逃出生天的流程，地宫是线性分层的，主角出生在最底层，想要到达地面 当主角击败一层boss时，这一层会坍塌、破坏、被岩浆淹没（总之几乎不能回到这一层） 开发日志 5.19 跳跃手感很难调整，而且不清楚改如何制作攻击动画，我希望攻击时人物会进行移动，我最初没有使用Apply Root Motion，现在看来是有问题的 有人建议我说，除了跑步这种Loop的动画外，其他动画都应该Apply Root Motion 我这个项目有一点很特殊，会有大量的跳跃，我感觉我的跳跃也应该是In Place Loop的 感觉要研究一下Blender 3D动画制作","categories":[{"name":"game","slug":"game","permalink":"https://reubensun.com/categories/game/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"Unity 加载文件","slug":"engine/Unity加载文件","date":"2024-05-11T16:01:25.000Z","updated":"2025-03-18T07:16:42.959Z","comments":true,"path":"engine/Unity加载文件/","permalink":"https://reubensun.com/engine/Unity%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/","excerpt":"","text":"Unity 加载文件 当我们在使用Unity制作一些程序时，往往需要从磁盘中运行时加载一些资产，而非提前放进Assets中，打进包体里 加载贴图 string rootPath = Path.GetDirectoryName(Path.GetDirectoryName(Application.dataPath));string uvPath = Path.Combine(rootPath, &quot;uv.png&quot;);if (File.Exists(uvPath))&#123; byte[] fileData = System.IO.File.ReadAllBytes(uvmapPath); Texture2D uvmap = new Texture2D(2048, 2048); uvmap.LoadImage(fileData); Shader.SetGlobalTexture(&quot;_GlobalTexture&quot;, uvmap);&#125; 加载动画 先给一个暴论，Unity运行时加载一个FBX动画，将其转换为Humanoid格式是不可能的，加载动画唯一可行的就是Legacy格式 这会带来几个问题： 不能使用Humanoid格式的动画，于是动画数据要和模型的骨骼匹配 不能使用Playable Script播放动画，必须用老旧的Animation模块 使用TriLib2库加载模型 List&lt;AnimationClip&gt; clips = new List&lt;AnimationClip&gt;();void Start()&#123; // load animation var options = AssetLoader.CreateDefaultLoaderOptions(); var context = AssetLoader.LoadModelFromFile(modelPath, OnLoad, null, null, null, null, options);&#125;void OnLoad(AssetLoaderContext context)&#123; // Get all animations var root = context.RootGameObject.GetComponent&lt;Animation&gt;(); if (root != null) &#123; var localClips = root.GetAllAnimationClips(); foreach (var clip in localClips) &#123; clips.Add(clip); &#125; &#125; context.RootGameObject.SetActive(false);&#125;void Update()&#123; // load is asyc, so need wait if (hadPlay) &#123; return; &#125; else if (clips.Count == 0) &#123; return; &#125; else &#123; hadPlay = true; Debug.Log(clips.Count); animationLength = Mathf.RoundToInt(clips[0].frameRate * clips[0].length); currentFrame = 0; // play animation var anim = GetComponent&lt;Animation&gt;(); anim.AddClip(clips[0], &quot;0&quot;); anim.clip = anim.GetClip(&quot;0&quot;); anim[&quot;0&quot;].time = 0; anim[&quot;0&quot;].speed = 1; anim.CrossFade(&quot;0&quot;); &#125;&#125; GLTF模型和动画是可以运行时导入的，但是GLTF的Humanoid和FBX Humanoid不兼容，且GLTF Humanoid转换时，必须原始骨架要符合规范，而FBX Humanoid可以映射MMD骨架，因此在Unity官方提供GLTF加载库前，我不建议在Unity使用GLTF","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"OBJ格式解析","slug":"dcc/OBJ格式解析","date":"2024-05-07T22:22:25.000Z","updated":"2025-03-18T07:16:42.957Z","comments":true,"path":"dcc/OBJ格式解析/","permalink":"https://reubensun.com/dcc/OBJ%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"","text":"OBJ 格式解析 OBJ是一种常用的文本格式（也可以是二进制）的三维模型格式，可读性很强 .OBJ 打开一个.obj文件，通常形如 mtllib sphere.mtlo Sphere v 0.5 0.5 -0.5...vt 0.0 1.0...vn 0.0 0.0 1.0...f 1/19/15 8/18/14 2/20/16... obj本身是一个巨大的字符串，由换行符\\n分割每一行，每一行都代表一组数组 组信息 行开头 含义 g 组名 o 物体（object）名称 s 平滑组 mg merging group // 关闭平滑组s off// 下面的f都属于平滑组1s 1f ...f ... 顶点数据 行开头 含义 格式 v 顶点坐标 Float3 vt 纹理坐标 Float2或Float3 vn 顶点法线 Float3 参数模型顶点数据 行开头 含义 格式 vp 参数空间顶点 Float3 cstype 曲线、曲面形式 deg bmat step 图元数据 行开头 含义 格式 f 四边面 v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3 v4/vt4/vn4 p 点 v1 v2 v3 l 线 v1/vt1 v2/vt2 curv 曲线 curv2 二维曲线 surf surface // f 有多种形式，如f 1 2 3f 1/1/1 2/2/2 3/3/3f 1//1 2//2 3// 3 渲染信息 行开头 含义 lod lod 使用材质名称 usemtl 引入一个材质库（很类似#include） mtllib // 在obj的开头通常会使用mtllib引入一个材质库mtllib sphere.mtl// 在一组f前使用usemtl表示使用这个材质usemtl yellows 1f ... 注意事项 观察可知，对于obj来说，一个三脚面，他们的顶点坐标、纹理坐标、顶点法线的index并不是共同的，比如1/19/15就表示组成这个三角形的第一个顶点，他的顶点坐标位于第1个v，纹理坐标位于第19个vt，顶点法线位于第15个vn 而且非常阴间的是，obj的索引是从1开始的，而非0，在导入到游戏引擎被图形API使用时，需要将f的索引都减一 .mtl mtl是常与obj一起使用的文件，用于描述材质，写过PBR的人很容易理解含义 newmtl yellowNs 225.000000Ka 1.000000 1.000000 1.000000Kd 0.800000 0.599518 0.000000Ks 0.500000 0.500000 0.500000Ke 0.000000 0.000000 0.000000Ni 1.450000d 1.000000illum 2map_Kd wmqjcfsg_2K_Albedo.jpgmap_roughness wmqjcfsg_2K_Roughness.jpgmap_metallic wmqjcfsg_2K_Displacement.jpgmap_ao wmqjcfsg_2K_AO.jpg 行开头 含义 格式 范围 Ns specular，越高高光越紧凑 Float 0~1000 Ka ambient，环境光反射率 Kd diffuse，漫反射颜色 Ks 高光颜色 Ke 自发光颜色 Ni 折射率（玻璃的折射率为1.5） illum 使用何种光照模型 d dissolve，不透明度，为1时完全不透明 Float 0~1 map_xxx xxx贴图 参考 Object Files MTL material format","categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"}],"tags":[{"name":"OBJ","slug":"OBJ","permalink":"https://reubensun.com/tags/OBJ/"}]},{"title":"ASP.Net最小Web API","slug":"program/ASPDoNet","date":"2024-04-24T18:27:25.000Z","updated":"2025-03-18T07:16:48.439Z","comments":true,"path":"program/ASPDoNet/","permalink":"https://reubensun.com/program/ASPDoNet/","excerpt":"","text":"ASP.Net最小Web API 最近需要搭建一个Windows Web服务器，处理一些很简单的访问请求，于是研究了一下ASP.Net的最小Web API 项目创建 打开VS2022，按照ASP.Net模块后，使用模板创建项目 程序运行 模板是一个预测（随机生成）未来五天天气的demo，可以用命令行启动程序 dotnet run --project=./项目名称 Mini API 模板项目内容非常少，只有一个C#文件 var builder = WebApplication.CreateBuilder(args);var app = builder.Build();// 创建一个Get接口，返回天气预测结果app.MapGet(&quot;/weatherforecast&quot;, () =&gt;&#123; var forecast = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast ( ... )) .ToArray(); return forecast;&#125;);app.Run();// record是C#的一个关键字，可以定义一个不可变的数据类型internal record WeatherForecast(DateOnly Date, int TemperatureC, string? Summary)&#123; public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);&#125; record可以用于快速定义一个类 // 两者等效record EditTodoItemRequest(int Id, TodoItemDTO Dto, TodoDb Db);class EditTodoItemRequest&#123; public int Id &#123; get; set; &#125; public TodoItemDTO Dto &#123; get; set; &#125; = default!; public TodoDb Db &#123; get; set; &#125; = default!;&#125; 添加一个新Get app.MapGet(&quot;/open/&#123;path&#125;&quot;, (string path) =&gt;&#123; try &#123; Process.Start(&quot;explorer.exe&quot;, path); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Can&#x27;t open folder: &#123;ex.Message&#125;&quot;); &#125;&#125;); http://localhost:xxxx/open/C%3A%5CUsers%5C28240%5Ccode 用文件浏览器打开本地的C:\\Users\\28240\\code路径 解析Request内容 app.MapGet(&quot;/do&quot;, (HttpRequest request) =&gt;&#123; var prop_a = request.Query[&quot;a&quot;]; var prop_b = request.Query[&quot;b&quot;]; var sessionid = request.Query[&quot;sessionid&quot;]; &#125;); http://localhost:xxxx/do?a=hello&amp;b=world&amp;sessionid=default 输入一个文件 app.MapPost(&quot;/do&quot;, (HttpRequest request) =&gt;&#123; var sourceFile = request.Form.Files[0]; // 将 http 请求的文件保存在本地 using (var st = new FileStream(localPath, FileMode.Create)) &#123; sourceFile.CopyTo(st); &#125; ...&#125;); 返回一个文件 app.MapPost(&quot;/download&quot;, (HttpRequest request) =&gt;&#123; return Results.File(System.IO.File.OpenRead(localVideoPath), &quot;video/mp4&quot;);&#125;); 用python下载这个文件 response = requests.post(url, headers=headers, files=&#123;&quot;file&quot;: file&#125;)if response.status_code == 200: print(&quot;Request successful!&quot;) with open(&#x27;received_file.mp4&#x27;, &#x27;wb&#x27;) as f: f.write(response.content) print(&quot;文件已保存为 &#x27;received_file.mp4&#x27;&quot;)else: print(&quot;Request failed with status code:&quot;, response.status_code) url转义规则 除了下面这些保留字外，用%&#123;两位十六进制&#125;进行转义 字符 转义形式 空格 %20 ! %21 * %2A ’ %27 ( %28 ) %29 ; %3B : %3A @ %40 &amp; %26 = %3D + %2B $ %24 , %2C / %2F ? %3F # %23 [ %5B ] %5D Web Socket 除了简单的Web API，我们有时也会用到Web Socket 服务端代码 // Program.csvar builder = WebApplication.CreateBuilder(args);builder.Services.AddControllers();var app = builder.Build();var webSocketOptions = new WebSocketOptions&#123; KeepAliveInterval = TimeSpan.FromMinutes(2)&#125;;app.UseWebSockets(webSocketOptions);app.MapControllers();app.Run(); namespace SocketDemo.Controllers&#123; public class xxxxController : ControllerBase &#123; [Route(&quot;/ws&quot;)] public async Task Get() &#123; if (HttpContext.WebSockets.IsWebSocketRequest) &#123; using var webSocket = await HttpContext.WebSockets.AcceptWebSocketAsync(); await Echo(webSocket); &#125; else &#123; HttpContext.Response.StatusCode = StatusCodes.Status400BadRequest; &#125; &#125; private static async Task Echo(WebSocket webSocket) &#123; Console.WriteLine(&quot;First Connect&quot;); var buffer = new byte[1024 * 4]; var receiveResult = await webSocket.ReceiveAsync( new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); while (!receiveResult.CloseStatus.HasValue) &#123; var segment = new ArraySegment&lt;byte&gt;(buffer, 0, receiveResult.Count); await webSocket.SendAsync( segment, receiveResult.MessageType, receiveResult.EndOfMessage, CancellationToken.None); Console.WriteLine($&quot;Send: &#123;Encoding.UTF8.GetString(segment.Array, segment.Offset, segment.Count)&#125;&quot;); receiveResult = await webSocket.ReceiveAsync( new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); &#125; await webSocket.CloseAsync( receiveResult.CloseStatus.Value, receiveResult.CloseStatusDescription, CancellationToken.None); &#125; &#125;&#125; 客户端代码 import asyncioimport websocketsasync def connect_to_server(): uri = &quot;wss://localhost:7167/ws&quot; # 替换成你的服务器地址 async with websockets.connect(uri) as websocket: print(f&quot;Connected to &#123;uri&#125;&quot;) try: while True: message = input(&quot;Enter message to send (or &#x27;exit&#x27; to quit): &quot;) if message.lower() == &quot;exit&quot;: break await websocket.send(message) print(f&quot;&gt; Sent: &#123;message&#125;&quot;) response = await websocket.recv() print(f&quot;&lt; Received: &#123;response&#125;&quot;) finally: await websocket.close() print(&quot;WebSocket connection closed&quot;)asyncio.run(connect_to_server()) 注：客户端连接websocket时，不使用http、https，而是ws、wss","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://reubensun.com/tags/CSharp/"},{"name":"Web","slug":"Web","permalink":"https://reubensun.com/tags/Web/"}]},{"title":"Unity Nova UI","slug":"engine/UnityNovaUI","date":"2024-04-16T17:58:25.000Z","updated":"2025-03-18T07:16:48.446Z","comments":true,"path":"engine/UnityNovaUI/","permalink":"https://reubensun.com/engine/UnityNovaUI/","excerpt":"","text":"Unity Nova UI 今天发现了一个特别好的Unity Game UI框架：Nova，挖个坑，打算学习一下","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"插值","slug":"math/插值","date":"2024-04-07T11:46:25.000Z","updated":"2025-03-18T07:16:48.441Z","comments":true,"path":"math/插值/","permalink":"https://reubensun.com/math/%E6%8F%92%E5%80%BC/","excerpt":"","text":"插值 线性插值 $$ \\mathrm{lerp}(p_0,p_1;t)=(1-t)p_0+tp_1 $$ Smoothstep Hermite 将一个数平滑映射到[0, 1] float v = smoothstep(0.0, 1.0, time);// 等同于 time * time * (3 - 2 * time) 球面插值 Slerp 在球面上线性插值 $$ \\mathrm{Slerp(p_0,p_1;t)}=\\frac{\\sin[(1-t)\\Omega]}{\\sin \\Omega}p_0+\\frac{\\sin [t\\Omega]}{\\sin \\Omega}p_1 $$ vec4 Slerp(vec4 p0, vec4 p1, float t)&#123; float dotp = dot(normalize(p0), normalize(p1)); if ((dotp &gt; 0.9999) || (dotp&lt;-0.9999)) &#123; if (t&lt;=0.5) return p0; return p1; &#125; float theta = acos(dotp * 3.14159/180.0); vec4 P = ((p0*sin((1-t)*theta) + p1*sin(t*theta)) / sin(theta)); P.w = 1; return P;&#125;void main()&#123; vec4 P = Slerp(gxl3d_Position, gxl3d_Attrib1, time); gl_Position = gxl3d_ModelViewProjectionMatrix * P; Vertex_Color = gxl3d_Attrib0;&#125; 参考 glsl-simple-morph-target-animation","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"Shader","slug":"Shader","permalink":"https://reubensun.com/tags/Shader/"}]},{"title":"Marching Cubes","slug":"graphics/MarchingCube","date":"2024-04-01T15:39:25.000Z","updated":"2025-03-18T07:16:48.444Z","comments":true,"path":"graphics/MarchingCube/","permalink":"https://reubensun.com/graphics/MarchingCube/","excerpt":"","text":"Marching Cubes Marching可以理解为一种循环 步进正方形（Marching Cubes）是一种非常常用的构建三角形网格的算法，在三维空间中均匀摆放正方形，循环遍历这些正方形，插值出三角形表面 Marching Cubes每个顶点有两个参数，顶点位置和权重（SDF） Unity显示三角形网格 注意！Unity拼装Mesh时，要先设置vertices，再设置triangles（尤其是在使用SetIndices接口，而非直接改mesh成员的方式），因为Unity在修改triangles时会对内部的信息做一次合法性检测，如果此时vertices是空的，就会报越界的错 // 构建一个Mesh，填充Vertex Buffer和Index BufferMesh constructMesh = new Mesh();constructMesh.vertices = verts; // 这里的vertices仅有positionOSconstructMesh.triangles = tris; // 一个int数组，每三个组成一个三角形，内容是vertices的索引，于是一般情形下远多于三倍的vertices数量constructMesh.RecalculateNormals(); // 重建法线（应该是对面法线求平均值）// 替换MeshFilter的sharedMeshmeshFilter.sharedMesh = constructMesh； Unity Compute Shader // 创建一个BufferComputeBuffer buffer = new ComputeBuffer(count, stride, type); stride是Buffer内每个元素的大小，注意CPU和Shader中定义要一致 type是Buffer的类型 AppendStructuredBuffer RWStructuredBuffer AppendStructuredBuffer 有些像一个总容量固定的vector，在使用时需要提前分配一个足够大的总容量 // 在CPU端设置有效容量_trianglesBuffer.SetCounterValue(0); // 在CPU端获取当前有效容量int ReadTriangleCount() &#123; int[] triCount = &#123; 0 &#125;; ComputeBuffer.CopyCount(_trianglesBuffer, _trianglesCountBuffer, 0); _trianglesCountBuffer.GetData(triCount); return triCount[0];&#125; AppendStructuredBuffer&lt;Triangle&gt; _Triangles;[numthreads(numThreads, numThreads, numThreads)]void March(uint3 id : SV_DispatchThreadID)&#123; // 在GPU端在Buffer尾部添加新元素 _Triangles.Append(tri);&#125; 构建Marching Cubes 构建一个立方体Grids 生成SDF 根据SDF获得CubeIndex 使用CubeIndex从LUT中读取边的数组 从相邻三个边插值出三角形三个点的顶点坐标 这里生成的vertex buffer数量和index buffer相同，是全展的，存在性能浪费 int edges[] = triTable[cubeIndex];for (int i = 0; edges[i] != -1; i += 3)&#123; // First edge lies between vertex e00 and vertex e01 int e00 = edgeConnections[edges[i]][0]; int e01 = edgeConnections[edges[i]][1]; // Second edge lies between vertex e10 and vertex e11 int e10 = edgeConnections[edges[i + 1]][0]; int e11 = edgeConnections[edges[i + 1]][1]; // Third edge lies between vertex e20 and vertex e21 int e20 = edgeConnections[edges[i + 2]][0]; int e21 = edgeConnections[edges[i + 2]][1]; Triangle tri; tri.a = interp(cornerOffsets[e00], cubeValues[e00], cornerOffsets[e01], cubeValues[e01]) + id; tri.b = interp(cornerOffsets[e10], cubeValues[e10], cornerOffsets[e11], cubeValues[e11]) + id; tri.c = interp(cornerOffsets[e20], cubeValues[e20], cornerOffsets[e21], cubeValues[e21]) + id; _Triangles.Append(tri);&#125; 参考 Marching Cubes","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"},{"name":"Model","slug":"Model","permalink":"https://reubensun.com/tags/Model/"}]},{"title":"KL散度","slug":"math/KL散度","date":"2024-03-31T14:07:25.000Z","updated":"2025-03-18T07:16:42.962Z","comments":true,"path":"math/KL散度/","permalink":"https://reubensun.com/math/KL%E6%95%A3%E5%BA%A6/","excerpt":"","text":"KL散度 在AI领域，我们经常需要衡量两个概率分布的相似度 KL散度 KL散度（Kullback-Leibler Divergence），也称为相对熵（Relative Entropy），用于衡量一个分布相对于另一个分布的相似性 假设现在有两个离散概率分布$P$和$Q$，他们的KL散度计算公式为： $$ D_{KL}(P||Q)=\\sum_{i}P(i)\\log \\left(\\frac{P(i)}{Q(i)} \\right) $$ 其中$P(i)$表示分布$P$在第$i$个事件的概率 特性： 非负性，KL散度通常大于等于0，当且仅当两个分布相同时等于0 不对称性，$D_{KL}(P||Q)$往往和$D_{KL}(Q||P)$不同 不满足三角不等式（即两边之和大于第三边） JSD Jensen-Shannon Divergence (JSD)也是一种衡量两个概率分布相似性的的指标，基于KL散度，但JSD具有对称性 JSD计算方式： 计算$P$和$Q$的平均分布 $$ M = (P+Q)/2 $$ 计算$D_{KL}(P||M)$和$D_{KL}(Q||M)$ JSD是两个散度的平均值 $$ JSD(P||Q)=\\frac{1}{2}(D_{KL}(P||M) + D_{KL}(Q||M)) $$ JSD的范围是[0, 1]，0表示两个分布完全重合，1表示两个分布完全没有重叠（差异最大）","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"PyTorch学习记录","slug":"ai/Pytorch","date":"2024-03-30T09:47:25.000Z","updated":"2025-03-18T07:16:42.957Z","comments":true,"path":"ai/Pytorch/","permalink":"https://reubensun.com/ai/Pytorch/","excerpt":"","text":"PyTorch学习记录 PyTorch是一个Python机器学习框架 张量 Tensors Tensors很像矩阵、向量，在PyTorch中使用Tensors编码输入和输出 构造 import torchimport numpy as np# 直接构造data = [[1, 2],[3, 4]]x_data = torch.tensor(data)# 使用numpy array转换np_array = np.array(data)x_np = torch.from_numpy(np_array)# 构造一个指定大小的Tensorsshape = (2,3,)rand_tensor = torch.rand(shape) # 生成一个2x3的Tensors，内容是随机ones_tensor = torch.ones(shape) # 生成一个2x3的Tensors，内容全为1zeros_tensor = torch.zeros(shape) # 生成一个2x3的Tensors，内容全为0 矩阵运算 # 矩阵乘法C = torch.matmul(A, B) 矩阵拼接 # 沿着纬度 dim 进行拼接tensor1 = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])tensor2 = torch.tensor([[13, 14, 15, 16], [17, 18, 19, 20], [21, 22, 23, 24]]) result1 = torch.cat([tensor1, tensor2], dim=0)# tensor([[ 1, 2, 3, 4],# [ 5, 6, 7, 8],# [ 9, 10, 11, 12],# [13, 14, 15, 16],# [17, 18, 19, 20],# [21, 22, 23, 24]])result2 = torch.cat([tensor1, tensor2], dim=1)# tensor([[ 1, 2, 3, 4, 13, 14, 15, 16],# [ 5, 6, 7, 8, 17, 18, 19, 20],# [ 9, 10, 11, 12, 21, 22, 23, 24]]) 保存和加载权重 torch.save(model, &#x27;model.pth&#x27;)model = torch.load(&#x27;model.pth&#x27;) nn Module 所有模型层的基类 # 继承 nn.Module，实现一个Attentionclass Attention(nn.Module): def __init__(self, embed_dim): super().__init__() self.embed_dim = embed_dim self.query = nn.Linear(embed_dim, embed_dim) self.key = nn.Linear(embed_dim, embed_dim) self.value = nn.Linear(embed_dim, embed_dim) def forward(self, query, key, value): # Implement attention mechanism pass Sequential # 将多层网络按顺序级联model = nn.Sequential( nn.Conv2d(1, 20, 5), nn.ReLU(), nn.Conv2d(20, 64, 5), nn.ReLU())# 等同于model2 = nn.Sequential()model2.add_module(&quot;conv1&quot;, nn.Conv2d(1, 20, 5))model2.add_module(&#x27;relu1&#x27;, nn.ReLU())model2.add_module(&#x27;conv2&#x27;, nn.Conv2d(20, 64, 5))model2.add_module(&#x27;relu2&#x27;, nn.ReLU()) Sequential有自动前向传播，模型层只要串在一起，就能自动处理forward，而ModuleList需要手动处理 ModuleList class Encoder(nn.Module): def __init__(self): self.down_blocks = nn.ModuleList([]) for i in xxx: down_block = ResnetDownsampleBlock2D(...) self.down_blocks.append(down_block) # nn.ModuleList需要自定处理前向传播，这里循环处理了sample，自由度更高，更适合复杂的库作者 def forward(self, sample: torch.Tensor) -&gt; torch.Tensor: def create_custom_forward(module): def custom_forward(*inputs): return module(*inputs) return custom_forward for down_block in self.down_blocks: sample = torch.utils.checkpoint.checkpoint( create_custom_forward(down_block), sample, use_reentrant=False ) return sample 全连接层 # 定义一个全连接层（线性层），将输入纬度映射到输出纬度query = nn.Linear(in_features, out_features) in_features输入纬度 out_features：输出纬度 Embedding 是一个查找表，将离散输入转为连续向量，常用于将单词转为向量 position_encoding = nn.Embedding(targets_length, d_model) 卷积层 # 定义一个二维卷积层conv = nn.Conv2d(in_channels=3, out_channels=64, kernel_size=3, stride=1) in_channels：输入信号的通道数，比如RGB就是3，灰度就是1 out_channels：输出的深度 kernel_size：卷积核大小 stride：卷积核移动的步长 padding_mode：边界填充规则，默认为zeros 逆卷积层 # 定义一个逆卷积层，用于放大特征图，实现上采样conv_transpose = nn.ConvTranspose2d(in_channels=1, out_channels=1, kernel_size=3, stride=2, padding=1) 激活函数 激活函数主要是为模型引入非线性，好的激活函数能加速训练、缓解梯度爆炸 激活函数 nn Sigmoid nn.Sigmoid() ReLU nn.ReLU() Sigmoid Linear Unit nn.SiLU() Softmax nn.Softmax(dim=None) Exponential Linear Unit nn.ELU() Dropout dropout = nn.Dropout(p=dropout_rate) transforms transforms.Compose：将多个数据变化操作串联 transforms.CenterCrop：中间裁剪 transforms.Resize：调整大小 transforms.ToTensor：图片数据转为tensor","categories":[{"name":"ai","slug":"ai","permalink":"https://reubensun.com/categories/ai/"}],"tags":[{"name":"Pytorch","slug":"Pytorch","permalink":"https://reubensun.com/tags/Pytorch/"},{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"}]},{"title":"三维模型的表示方法","slug":"graphics/模型表示","date":"2024-03-29T21:56:25.000Z","updated":"2025-03-18T07:16:48.442Z","comments":true,"path":"graphics/模型表示/","permalink":"https://reubensun.com/graphics/%E6%A8%A1%E5%9E%8B%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"三维模型的表示方法 常见的模型表示法有：多边形网格、点云、体素、参数模型、隐式表面 表示方式 Polygon mesh 一般特指三角形网格 三角形网格由两部分组成： 一个个离散的顶点 顶点间的拓扑关系 图形渲染中最常见的方法是光栅化和光追，都适用于三角形 方便进行深度测试、UV映射 方便进行模型细分和简化、布尔建模 美术行业长期使用该格式，存在很强的惯性 三角面与四角面 三角面 三角面具有稳定性，不容易发生形变和自交 比较适合光栅化和光追，渲染效率高，常用于游戏等实时渲染场景 任何多边形都可以被三角面表示 三角面便于计算法线 四角面 纹理映射效果更好，能够提供更均匀的纹理坐标分布 与建模软件适配更好，很容易实现稳定的细化、拖拽、简化 法线可能会有歧义（四点可能不共面，四点的顺序有两种可能） Voxel 与2D的像素类似，我们使用体素填充3D空间，就能表示一个三维模型 体素对空间的描述是均匀的，想要达到和三角网格相近的精度，需要占用更大的存储空间，这也意味着相同存储空间下体素的精度更差 下图左为2MB的三角网格，图右为13MB的SDF体素 SDF体素具有非常好的光追性能，很容易进行相交测试和求出光线移动的距离 体素可以进行离散化，就像Clipmap那样，大片连续的体素会被合成为一个大体素，以降低存储空间（但还是比三角网格空间大） 不过为了保持边缘柔顺，我们需要在边缘处保留大量细小的体素，这种边缘处理会影响光追性能，一个好的模型数据结构应该能够表示软硬边，而非专门浪费性能来实现光滑 我们仍需要使用贴图映射，体素颜色不能替代UV，体素UV可能会出现接缝问题 Point cloud 多边形网格某种程度上就是有拓扑关系的点云 点云记录了模型表面顶点的坐标 点云渲染会带来巨大的overdraw，为此我们需要进行填洞、做深度剔除，而填洞的难度很大 点云的一大优点是更适合通过扫描获得（三角形网格扫描容易出现破面） 点云的另一大优点是数据的顺序无关，我们可以任意调整顶点存储的顺序，但这其实也是一种缺点，我们不好比较两个点云的差异 Implicit field 使用一组连续函数的零水平集来表示3D模型 连续函数的零水平集：使函数值=0的输入取值的集合 SDF就是一种隐式场，通过定义一组距离值函数，将点的坐标带入函数可以求得点到物体表面的距离 可以快速进行碰撞检测、UV生成 但制作难度过高，难以表达所有的模型，对于复杂模型，计算复杂度过高 难以进行编辑、布尔操作、细分 评价指标 水密 Watertight 指一个三维模型的表面是无缝且封闭的，没有任何孔洞或缺口 流形 Manifold 每个顶点都恰好属于两个三角形（在边界上）或多个三角形（在内部）","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Model","slug":"Model","permalink":"https://reubensun.com/tags/Model/"}]},{"title":"贴图UV","slug":"graphics/贴图UV","date":"2024-03-29T21:55:25.000Z","updated":"2025-03-18T07:16:48.442Z","comments":true,"path":"graphics/贴图UV/","permalink":"https://reubensun.com/graphics/%E8%B4%B4%E5%9B%BEUV/","excerpt":"","text":"贴图UV 一个多边形Mesh中有Index Buffer和Vertex Buffer，其中Vertex Buffer上存储着顶点信息，包括顶点坐标、UV、法线、切线 最开始，我们只有顶点坐标，三角形的边向量叉积可以得到面法线，将面法线求和可以得到顶点法线，切线和次切线的方向就是沿着UV方向，那么问题来了，UV是怎么生成的？ UV的用用途 UV是贴图的颜色的索引，可以用来采样贴图，是一种高效的传递模型表面材质信息的方式 UV的分类 UV通常分为全展UV和重叠UV 重叠UV允许模型不同位置采样贴图的同一位置，于是更省空间（或者精度更好） 全展UV模型每一处UV都是不同的，可以用来采样Lightmap信息 UV的生成 我们这里说的都是多边形网格的UV，对于参数表面这类模型，是有天生的UV的 DCC工具允许美术像编辑顶点坐标那样编辑顶点UV，但在这之前，我们需要先将三维的顶点坐标投影（Projector）到二维的UV上 投影方式有球面（spherical）投影、圆柱（cylindrical）投影、平面（planar）投影 球面投影：模型顶点坐标和一个虚构的球心会形成一个向量，沿着这个向量将顶点坐标投影到球面上 圆柱投影：u的投影和球面相同，v是模型顶点到虚拟圆锥轴的距离 面投影：将模型顶点做正交投影 美术通常会将模型进行切分，在不同位置应用不同的投影方法 Corresponder 采样UV和贴图坐标有时范围是不同的（当你进行缩放采样时经常出现），于是我们需要处理边缘采样 有四种方法： 重复（wrap、repeat、tile） 镜像（mirror） 截断（clamp to edge） 边界（clamp to border）","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"UV","slug":"UV","permalink":"https://reubensun.com/tags/UV/"}]},{"title":"Unity保存RenderTarget","slug":"engine/Unity保存RT","date":"2024-03-29T16:01:25.000Z","updated":"2025-03-18T07:16:42.959Z","comments":true,"path":"engine/Unity保存RT/","permalink":"https://reubensun.com/engine/Unity%E4%BF%9D%E5%AD%98RT/","excerpt":"","text":"Unity保存RenderTarget 使用Unity产出一些美术资产时，经常需要保存某个RenderTarget，最近发现用ReadPixels进行保存时，精度很差，只有8 bits，最后成功搞定了保存32 bits RenderTarget的方法，在此记录一下 屏幕截图 如果想要保存当前屏幕的渲染结果，可以直接调用 ScreenCapture.CaptureScreenshot(pngPath); 保存相机的RT public Camera renderCamera;void saveColor()&#123; RenderTexture activeRenderTexture = RenderTexture.active; RenderTexture cameraRenderTexture = new RenderTexture(renderCamera.pixelWidth, renderCamera.pixelHeight, 24); renderCamera.targetTexture = cameraRenderTexture; renderCamera.Render(); RenderTexture.active = cameraRenderTexture; Texture2D cameraImage = new Texture2D(renderCamera.pixelWidth, renderCamera.pixelHeight, TextureFormat.RGBAFloat, false); cameraImage.ReadPixels(new Rect(0, 0, cameraRenderTexture.width, cameraRenderTexture.height), 0, 0); cameraImage.Apply(); Color[] colors = cameraImage.GetPixels(); byte[] cameraImageBytes = cameraImage.EncodeToTGA(); File.WriteAllBytes(Path.Combine(outputPath, &quot;cameraImage.tga&quot;), cameraImageBytes);&#125; 保存深度 public RenderTexture depthTarget;void Start()&#123; depthTarget = new RenderTexture(1024, 1024, 0, RenderTextureFormat.RHalf) &#123; autoGenerateMips = false, useMipMap = false, filterMode = FilterMode.Point &#125;; depthTarget.Create(); Camera.main.depthTextureMode |= DepthTextureMode.Depth;&#125;void SaveDepth()&#123; // 创建一个临时RT RenderTexture depthRT = RenderTexture.GetTemporary(Screen.width, Screen.height, 0, depthTarget.format); depthRT.filterMode = FilterMode.Point; // 将GPU的深度贴图Blit到临时RT上 Graphics.Blit(Shader.GetGlobalTexture(&quot;_CameraDepthTexture&quot;), depthRT); // 将临时RT的像素保存到Color数组 Texture2D depthTexture = new Texture2D(depthRT.width, depthRT.height, TextureFormat.RFloat, false); RenderTexture.active = depthRT; depthTexture.ReadPixels(new Rect(0, 0, depthRT.width, depthRT.height), 0, 0); depthTexture.Apply(); Color[] pixels = depthTexture.GetPixels(); RenderTexture.active = null; // 编码、写贴图 byte[] bytes = depthTexture.EncodeToPNG(); string filename = Path.Combine(outputPath, &quot;depth.png&quot;); File.WriteAllBytes(filename, bytes);&#125; 更高精度的RT 我发现在保存相机RT时，每个通道的精度仅仅是8 bits，将这些通道乘以255.0f，就非常接近整数了 这其实是因为cameraRenderTexture的默认格式是ARGB32，每个通道仅8 bits，我只需要在其创建时设置一个更高精度的格式，比如ARGBFloat，每个通道32 bits，精度就大大提高了 RenderTexture cameraRenderTexture = new RenderTexture(renderCamera.pixelWidth, renderCamera.pixelHeight, 24, +RenderTextureFormat.ARGBFloat);","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"C#读表格","slug":"program/CSharp表格","date":"2024-03-28T18:32:25.000Z","updated":"2025-03-18T07:16:42.966Z","comments":true,"path":"program/CSharp表格/","permalink":"https://reubensun.com/program/CSharp%E8%A1%A8%E6%A0%BC/","excerpt":"","text":"C#读表格 这里使用Open XML SDK读xml和xlsx表格 读XLSX 打开一个xlsx static bool readResourceXlsxTable(string xlsx_path, string prefix_path, Dictionary&lt;string, string&gt; id_to_texture_path)&#123; using (SpreadsheetDocument doc = SpreadsheetDocument.Open(xlsx_path, false)) &#123; OpenXmlElementList childs = doc.WorkbookPart.Workbook.Sheets.ChildElements; OpenXmlElement sheet_element = childs.GetItem(0); Sheet sheet = (Sheet)sheet_element; Worksheet worksheet = (doc.WorkbookPart.GetPartById(sheet.Id.Value) as WorksheetPart).Worksheet; IEnumerable&lt;Row&gt; rows = worksheet.GetFirstChild&lt;SheetData&gt;().Descendants&lt;Row&gt;(); SharedStringTablePart string_table_part = doc.WorkbookPart.SharedStringTablePart; int excel_row_count = rows.Count(); if (excel_row_count &gt; 0) &#123; List&lt;string&gt; string_table = new List&lt;string&gt;(); foreach (OpenXmlElement node in string_table_part.SharedStringTable.ChildElements) &#123; string_table.Add(node.InnerText); &#125; // MARK: 这里不是真正的row和column for (int row_index = 0; row_index &lt; excel_row_count; row_index++) &#123; var cells = rows.ElementAt(row_index).Descendants&lt;Cell&gt;().ToList(); for(int column_index = 0; column_index &lt; cells.Length; column_index++) &#123; Cell cell = cells.ElementAt(column_index); &#125; &#125; &#125; &#125; return true;&#125; 读单元格数据 值得注意的是，单元格数据是有类型的，尤其是字符串，有的是直接内嵌到cell.CellValue.InnerText中，有的是放在SharedStringTablePart中，单元格内只保留一个引用 于是我们需要先拿到共享字符串表的内容，然后用引用ID去得到真正的字符串 SharedStringTablePart string_table_part = doc.WorkbookPart.SharedStringTablePart;List&lt;string&gt; string_table = new List&lt;string&gt;();foreach (OpenXmlElement node in string_table_part.SharedStringTable.ChildElements)&#123; string_table.Add(node.InnerText);&#125; if (cell.DataType == CellValues.SharedString)&#123; text = string_table.ElementAt(Convert.ToInt32(cell.CellValue.InnerText));&#125;else&#123; text = cell.CellValue.InnerText;&#125; 单元格坐标 我们使用Excel打开一个表格，每个单元格是通过英文字母和数字拼成一个ID，这个是真正的坐标，存储在cell.CellReference中，我们上面的遍历，如果遇到空单元格，会出现问题（会认为空单元格不存在） 可以解析CellReference获得真正的坐标 static void GetRowAndColumn(string cellReference, out int row, out int column)&#123; row = 0; column = 0; string columnLetters = &quot;&quot;; // column index foreach (char c in cellReference) &#123; if (char.IsLetter(c)) &#123; columnLetters += c; &#125; else &#123; break; &#125; &#125; column = ColumnLettersToNumber(columnLetters); // row index int.TryParse(cellReference.Substring(columnLetters.Length), out row);&#125;static int ColumnLettersToNumber(string letters)&#123; int result = 0; foreach (char c in letters) &#123; result = result * 26 + (c - &#x27;A&#x27; + 1); &#125; return result;&#125; GetRowAndColumn(cell.CellReference, out int real_row, out int real_column); 读XML 这个也可以读XML 打开一个xml static bool readResourceXmlTable(string xml_path, string prefix_path, Dictionary&lt;string, string&gt; id_to_texture_path)&#123; XmlDocument xml_doc = new XmlDocument(); try &#123; xml_doc.Load(xml_path); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error: &#123;ex.Message&#125;&quot;); &#125; return true;&#125; 访问Sheet 用Excel打开一个表格，我们可以看到左下角有好多Sheet XmlNamespaceManager ns_manager = new XmlNamespaceManager(xml_doc.NameTable);ns_manager.AddNamespace(&quot;ss&quot;, &quot;urn:schemas-microsoft-com:office:spreadsheet&quot;);XmlNodeList work_sheet_nodes = xml_doc.SelectNodes(&quot;//ss:Worksheet&quot;, ns_manager);foreach (XmlNode work_sheet_node in work_sheet_nodes)&#123; XmlAttribute name_attribute = work_sheet_node.Attributes[&quot;ss:Name&quot;]; if (name_attribute != null) &#123; XmlNode table_node = work_sheet_node.SelectSingleNode(&quot;ss:Table&quot;, ns_manager); &#125;&#125; 访问行和列 XmlNode table_node = work_sheet_node.SelectSingleNode(&quot;ss:Table&quot;, ns_manager);XmlAttribute row_count_attribute = table_node.Attributes[&quot;ss:ExpandedRowCount&quot;];XmlNodeList row_nodes = table_node.SelectNodes(&quot;ss:Row&quot;, ns_manager);foreach (XmlNode row_node in row_nodes)&#123; XmlNodeList cell_nodes = row_node.SelectNodes(&quot;ss:Cell&quot;, ns_manager); foreach (XmlNode column_node in cell_nodes) &#123; &#125;&#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://reubensun.com/tags/CSharp/"}]},{"title":"Perforce入门","slug":"program/P4入门","date":"2024-03-21T10:01:25.000Z","updated":"2025-03-18T07:16:48.437Z","comments":true,"path":"program/P4入门/","permalink":"https://reubensun.com/program/P4%E5%85%A5%E9%97%A8/","excerpt":"","text":"Perforce入门 Perforce又称P4、P4V 为什么要用P4 游戏开发一定需要一个版本管理工具，除了保留编辑记录外，还可以保护资产，遇到一些严重崩溃可以回退，不然会出现引擎打不开了，蓝图数据全丢了，一天白干的情况 为什么不使用Git呢？因为Git对二进制支持很差，即使使用LFS，对于动辄几十G的项目也无能为力 而且P4与Git不同，Git是在状态间切换，一旦切分支、拉新，就要将所有文件更新到某个状态，而P4可以只更新某个文件 此外P4也有分支、合并等概念，对于代码的处理也是完全可以接受的，因为强推P4 个人P4环境搭建 指服务器和客户端都搭在本机，仅用作版本管理，不考虑协作 1. 下载P4D Download Helix Core (P4D) | Perforce 这是P4的服务器，一路继续就可以，记住服务器端口（默认是1666） 2. 下载P4V Download Helix Visual Client (P4V) | Perforce 这是P4客户端，一路继续 3. 创建用户 打开P4V后，会弹出一个连接选项 Server填P4D创建时的端口（这里就是1666），如果是远程服务器，就是远程的链接:端口 点击User右侧的New，创建用户 结束后按OK进行P4V 4. 创建Depot 此时我们是什么都没有的，所以要先创建一个Depot，这是类似仓库根节点的东西 点击Tools–Administration打开管理员面版 5. 创建Stream stream很类似于Git的分支，我们回到P4V的窗口，点击一个Depot后创建一个Stream Stream是可以衍生出其他子分支的 你可以在Stream Graph窗口查看Stream的关系，注意需要按一下Apply来刷新显示 Stream上的小显示器，就是当前Workspace所在的位置，你可以拖动显示器到其他Stream，以实现分支切换 6. 创建Workspace 前面的东西都还是在服务端的，Workspace才是本地的东西，对着一个Stream右键，New Workspace 在Advanced里有一些配置，比如文件换行符格式，建议都用Unix P4使用 拉新 Get Lastest 强制拉新 对着某个文件夹右键——Get Revison Checkout 俗称锁了，一般这些二进制文件会被设置为只读，被checkout后才可写 一些二进制文件，如果不Checkout，就不能修改 文件被checkout后，其他人也能看到这个文件被谁checkout，有的文件一旦被其他人checkout，就不能对其进行修改，于是经常遇到有人来找你解锁某个文件 收集修改 基本是最常用的功能，尤其是一个人用时 对着某个文件夹右键——Reconcile Offline Work 收集的修改会放在Pending中 回退 右键——Revert 提交修改 将Pending中某个修改提交，不要用default提交，注意写提交信息 暂存修改 将某个Pending的修改临时“回退”掉，不过这个回退其实会上传到服务器 这个功能最大的作用其实是私下传递资源，你可以把你的修改给其它他人，而不需要提交、污染主分支 其他人可以通过ID找到这个Shelve，按右键UnShelve就可以将这个Change应用到本地 解决冲突 P4 .Net API P4所有操作其实都是通过命令实现的，在Log窗口可以看到，使用C# Api可以模拟这些接口，实现一些工具 using Perforce.P4;namespace P4DoNetApi&#123; class P4Utils &#123; private string uri; private string user; private string workspace; private Repository repo; private Connection conn; public P4Utils(string uri, string user, string workspace) &#123; this.uri = uri; this.user = user; this.workspace = workspace; repo = new Repository(new Server(new ServerAddress(uri))); conn = repo.Connection; conn.UserName = user; conn.Client = new Client &#123; Name = workspace &#125;; conn.Connect(null); &#125; /// &lt;summary&gt; /// 获取当前workspace所有changelist描述 /// &lt;/summary&gt; /// &lt;returns&gt;描述名list&lt;/returns&gt; public List&lt;string&gt; getAllChangeListDescription() &#123; List&lt;string&gt; result = new List&lt;string&gt;(); // p4 changes -L -c &#123;workspace&#125; -m 10 -u &#123;user&#125; ChangesCmdOptions options = new ChangesCmdOptions(ChangesCmdFlags.LongDescription, workspace, 10, ChangeListStatus.None, user); IList&lt;Changelist&gt; changelists = repo.GetChangelists(options, null); foreach(var change in changelists) &#123; result.Add(change.Description); &#125; return result; &#125; public List&lt;string&gt; getAllFileDepotPathInChangeList(int changelistId) &#123; List&lt;string&gt; result = new List&lt;string&gt;(); Changelist changelist = repo.GetChangelist(changelistId); if(changelist != null) &#123; foreach(var fileMetaData in changelist.Files) &#123; result.Add(fileMetaData.DepotPath.Path); &#125; &#125; return result; &#125; &#125;&#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Perforce","slug":"Perforce","permalink":"https://reubensun.com/tags/Perforce/"}]},{"title":"HLSL 转 Metal","slug":"graphics/MetalShader","date":"2024-02-09T15:39:25.000Z","updated":"2025-03-18T07:16:42.960Z","comments":true,"path":"graphics/MetalShader/","permalink":"https://reubensun.com/graphics/MetalShader/","excerpt":"","text":"HLSL 转 Metal 为了方便游戏移植到iOS和Mac，苹果近年推出了一个Metal shader converter工具，这个工具可以搭配微软的DXC工具，实现HLSL转化为Metal 编写HLSL DXC将.hlsl转化为.dxil MSC将.dxil转化为.metallib 原生Metal 在了解HLSL转Metal之前，我们需要先知道原生Metal长什么样，我感觉和HLSL还是有不少区别的 桥接文件 首先Metal是有一个桥接的.h文件，这个文件连接了shader和程序（OC、Swift、C++），在这个文件中定义的枚举和结构，在两者中都可以使用 TODO：研究一下能不能使用enum class，这样写枚举污染命名空间 // Common.h#import &lt;simd/simd.h&gt;typedef enum &#123; VertexBuffer = 0, UVBuffer = 1, ColorBuffer = 2, TangentBuffer = 3, BitangentBuffer = 4, TerrainBuffer = 6, UniformsBuffer = 11, ParamsBuffer = 12, LightBuffer = 13, MaterialBuffer = 14, IdBuffer = 15&#125; BufferIndices; // 某个swift中，使得枚举可以直接转为Intextension BufferIndices &#123; var index: Int &#123; return Int(self.rawValue) &#125;&#125; 比如我在这个Common.h中定义了一个枚举，每个枚举值都有其对应的整数，我们可以在管线和shader都使用这个枚举 // 这是基于swift的管线代码，我们将UBO设置到UniformsBuffer.index的位置encoder.setVertexBytes( &amp;uniforms, length: MemoryLayout&lt;Uniforms&gt;.stride, index: UniformsBuffer.index) // 这是Metal shader，将ubo设置到UniformsBuffer所对应的位置vertex VertexOut vertex_main(VertexIn in [[stage_in]], constant Uniforms &amp;uniforms [[buffer(UniformsBuffer)]])&#123;&#125; HLSL 静态成员 HLSL可以在shader中创建并初始化一个静态成员，但是需要加static static const float3x2 _positions = &#123; -1.0f, -1.0f, 0.0f, 1.0f, 1.0f, -1.0f &#125;; Resource binding HLSL的资产绑定是基于寄存器的 符号 含义 示例 t SRV Texture2D _BaseMap : register(t1); s samplers SamplerState _BaseMap_ST : register(s1); u UAV b CBV cbuffer ubo : register(b0) &#123; UBO ubo; &#125; SPIR-V拓展 [[vk::push_constant]] HLSL中Push Constants其实也是一个cbuffer，只是不绑定任何寄存器，是一个$Global cbuffer，你可以直接 cbuffer Constants&#123; float4x4 g_WorldViewProj;&#125;; 用于标记常量数据，使得可以被vkCmdPushConstants推送 struct PushConstant&#123; float4x4 modelMatrix;&#125;;[[vk::push_constant]]PushConstant pushConstant; 环境搭建 DXC on Mac git clone git clone https://github.com/microsoft/DirectXShaderCompiler.git submodule init cd DirectXShaderCompilergit submodule initgit submodule update build（话说这一步还挺慢的，感觉我的M1该退役了） mkdir buildcd buildcmake .. -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release -C ../cmake/caches/PredefinedParams.cmake -DCMAKE_OSX_ARCHITECTURES=&quot;x86_64;arm64&quot;make -j8 我们会得到一大堆生成内容，我们只需要build/bin/dxc-3.7和build/lib/libdxcompiler.dylib 将build/bin/dxc-3.7拷贝到/usr/local/bin/ 将build/lib/libdxcompiler.dylib拷贝到/usr/local/lib 打开命令行，发现可以使用dxc命令了 dxc-3.7 -E MainVS -T vs_6_0 -Fo &quot;grass.v.dxil&quot; &quot;grass.hlsl&quot; MSC 下载MSC后，双击安装即可 安装完毕你可以在/usr/local/lib找到对应的库，如果你的程序需要运行时生成 Metal Shader，可以将这个库嵌入项目中 你可以使用命令行编译了 metal-shaderconverter grass.v.dxil -o ./grass.metallib 使用参数--output-reflection-file还可以生成反射信息 metal-shaderconverter triangle.v.dxil -o ./triangle.metallib --output-reflection-file a.json &#123; &quot;EntryPoint&quot;: &quot;MainVS&quot;, &quot;FunctionConstants&quot;: [], &quot;NeedsFunctionConstants&quot;: false, &quot;Resources&quot;: [], &quot;ShaderID&quot;: &quot;9969595390685293918&quot;, &quot;ShaderType&quot;: &quot;Vertex&quot;, &quot;TopLevelArgumentBuffer&quot;: [], &quot;instance_id_index&quot;: 2, &quot;max_primitives_per_mesh_threadgroup&quot;: 0, &quot;needs_draw_params&quot;: true, &quot;vertex_id_index&quot;: 1, &quot;vertex_inputs&quot;: [ &#123; &quot;columnCount&quot;: 4, &quot;elementType&quot;: &quot;Float&quot;, &quot;index&quot;: 0, &quot;name&quot;: &quot;position0&quot; &#125; ], &quot;vertex_output_size_in_bytes&quot;: 16, &quot;vertex_outputs&quot;: [ &#123; &quot;columnCount&quot;: 4, &quot;elementType&quot;: &quot;Float&quot;, &quot;index&quot;: 1, &quot;name&quot;: &quot;sv_position0&quot; &#125; ]&#125; SPIRV 除了官方的MSC，还可以使用SPIRV 我不太清楚MSC要如何加入调试信息，但SPIRV可以很容易加入 dxc-3.7 -E MainPS -spirv -Zi -Qembed_debug -O0 -T ps_6_0 -Fo &quot;triangle.frag.spirv&quot; &quot;triangle.hlsl&quot;spirv-cross --msl triangle.frag.spirv --output triangle.frag.metalxcrun -sdk macosx metal -c -frecord-sources triangle.frag.metal -o triangle.frag.airxcrun -sdk macosx metallib triangle.frag.air -o triangle.frag.metallib 通过安装Metal Developer Tools For Windows，可以在Window下使用metal和metallib工具 MSC 片元着色器 片元着色器比较好实现 struct v2f&#123; float4 position : SV_Position;&#125;;float4 MainPS( v2f vin ) : SV_Target&#123; return float4(1.0, 0.0, 0.0, 1.0);&#125; 使用DXC和MSC编译后，得到triangle.f.metallib，并放在路径Metal-Tutorial/triangle.p.metallib MTL::Library* lib = metalDevice-&gt;newLibrary(NS::String::string(&quot;Metal-Tutorial/triangle.p.metallib&quot;, NS::ASCIIStringEncoding), nullptr);MTL::Function* frag = lib-&gt;newFunction(NS::String::string(&quot;MainPS&quot;, NS::ASCIIStringEncoding));MTL::RenderPipelineDescriptor* renderPipelineDescriptor = MTL::RenderPipelineDescriptor::alloc()-&gt;init();renderPipelineDescriptor-&gt;setFragmentFunction(frag); 顶点着色器 metal有两种传入顶点信息的方式 vertex descriptor 一种是使用VertexDescriptor描述VertexBuffer，shader大概长这样 struct VertexIn &#123; float4 position [[attribute(Position)]]; float3 normal [[attribute(Normal)]]; float2 uv [[attribute(UV)]]; float3 color [[attribute(Color)]]; float3 tangent [[attribute(Tangent)]]; float3 bitangent [[attribute(Bitangent)]];&#125;;vertex VertexOut vertex_main(VertexIn in [[stage_in]])&#123;&#125; 用HLSL写大概是 PSInput VSMain(float4 position : POSITION, float4 uv : TEXCOORD)&#123;&#125; binding buffer 另一种是binding一个buffer和vertexID，类似于instance struct Vertex &#123; float3 position; float3 normal; float3 tangent; float3 bitangent; float2 textureCoordinate; int diffuseTextureIndex; int specularTextureIndex; int normalMapIndex; int emissiveMapIndex;&#125;;vertex OutData vertexShader( uint vertexID [[vertex_id]], constant Vertex* vertexData [[buffer(0)]])&#123;&#125; 用HLSL写，大概是 struct VertexData&#123; float4 position; float4 normal; float4 texcoord;&#125;;StructuredBuffer&lt;VertexData&gt; vertexData : register(t0, space0);v2f MainVS( uint vertexId : SV_VertexID, uint instanceId : SV_InstanceID )&#123; VertexData vd = vertexData[ vertexId ]; ...&#125;","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Metal","slug":"Metal","permalink":"https://reubensun.com/tags/Metal/"}]},{"title":"小引擎接入简单刚体物理系统","slug":"graphics/JoltPhysics","date":"2024-02-09T11:39:25.000Z","updated":"2025-03-18T07:16:42.960Z","comments":true,"path":"graphics/JoltPhysics/","permalink":"https://reubensun.com/graphics/JoltPhysics/","excerpt":"","text":"Jolt Physics 最近给小引擎接入了刚体物理系统，发现这个东西真的很简单，在此记录一下 关于物理系统 主流的物理系统接口都很相似，而且制作的非常完善，像刚体物理这种比较基础的模块，接起来十分简单 目前大多数物理引擎，还是在CPU多线程模拟，英伟达有一套基于GPU的，但没有开源 我接入的是Jolt Physics，是一个非常轻量级的物理系统 cmake 代码拉取 https://github.com/jrouwe/JoltPhysics.git 构建（动态库） if(NOT TARGET JoltPhysics) set(BUILD_SHARED_LIBS ON) add_subdirectory(JoltPhysics/Build) set_property(TARGET Jolt PROPERTY FOLDER &quot;ThirdParty&quot;)endif() 链接 target_link_libraries(Engine PUBLIC Jolt) 简单的刚体物理 初始化 JPH::RegisterDefaultAllocator();JPH::Trace = PhysicsManager::TraceImpl;JPH::AssertFailed = PhysicsManager::AssertFailedImpl;JPH::Factory::sInstance = new JPH::Factory();JPH::RegisterTypes();m_temp_allocator = new JPH::TempAllocatorImpl(10 * 1024 * 1024);m_job_system = new JPH::JobSystemThreadPool(m_max_job_count, m_max_barrier_count, m_max_concurrent_job_count);m_physics_system = new JPH::PhysicsSystem();m_physics_system-&gt;Init(m_max_body_count, m_max_body_count, m_max_body_pairs, m_max_contact_constraints, layer_interface, ob_layer_filter, oo_layer_filter); 添加监听 body_activation_listener = new MyBodyActivationListener();m_physics_system-&gt;SetBodyActivationListener(body_activation_listener);contact_listener = new MyContactListener();m_physics_system-&gt;SetContactListener(contact_listener); 设置重力方向（默认是y轴，我的小引擎是z轴朝上） JPH::Vec3 m_gravity&#123; 0.f, 0.f, -9.8f &#125;;m_physics_system-&gt;SetGravity(m_gravity); 监听 class MyContactListener : public JPH::ContactListener&#123;public: virtual JPH::ValidateResult OnContactValidate(const JPH::Body&amp; inBody1, const JPH::Body&amp; inBody2, JPH::RVec3Arg inBaseOffset, const JPH::CollideShapeResult&amp; inCollisionResult) override; virtual void OnContactAdded(const JPH::Body&amp; inBody1, const JPH::Body&amp; inBody2, const JPH::ContactManifold&amp; inManifold, JPH::ContactSettings&amp; ioSettings) override; virtual void OnContactPersisted(const JPH::Body&amp; inBody1, const JPH::Body&amp; inBody2, const JPH::ContactManifold&amp; inManifold, JPH::ContactSettings&amp; ioSettings) override; virtual void OnContactRemoved(const JPH::SubShapeIDPair&amp; inSubShapePair) override;&#125;;class MyBodyActivationListener : public JPH::BodyActivationListener&#123; virtual void OnBodyActivated(const JPH::BodyID&amp; inBodyID, uint64_t inBodyUserData) override; virtual void OnBodyDeactivated(const JPH::BodyID&amp; inBodyID, uint64_t inBodyUserData) override;&#125;; Interface 物理系统有一个粗粒度的碰撞检测和逐物体的精细检测 粗粒度的原理是根据坐标轴简单判断，叫BroadPhase namespace Layers&#123; static constexpr JPH::ObjectLayer NON_MOVING = 0; static constexpr JPH::ObjectLayer MOVING = 1; static constexpr JPH::ObjectLayer NUM_LAYERS = 2;&#125;;namespace BroadPhaseLayers&#123; static constexpr JPH::BroadPhaseLayer NON_MOVING(0); static constexpr JPH::BroadPhaseLayer MOVING(1); static constexpr unsigned int NUM_LAYERS(2);&#125;;// Broadphase use Axis testclass BPLayerInterfaceImpl final : public JPH::BroadPhaseLayerInterface&#123;public: BPLayerInterfaceImpl(); virtual unsigned int GetNumBroadPhaseLayers() const override; virtual JPH::BroadPhaseLayer GetBroadPhaseLayer(JPH::ObjectLayer inLayer) const override; virtual const char* GetBroadPhaseLayerName(JPH::BroadPhaseLayer inLayer) const override;private: JPH::BroadPhaseLayer m_object_to_broad_phase[Layers::NUM_LAYERS];&#125;;class ObjectVsBroadPhaseLayerFilterImpl : public JPH::ObjectVsBroadPhaseLayerFilter&#123;public: virtual bool ShouldCollide(JPH::ObjectLayer inLayer1, JPH::BroadPhaseLayer inLayer2) const override;&#125;;class ObjectLayerPairFilterImpl : public JPH::ObjectLayerPairFilter&#123;public: virtual bool ShouldCollide(JPH::ObjectLayer inObject1, JPH::ObjectLayer inObject2) const override;&#125;; 构建物理场景 添加静态的Box和动态的Sphere JPH::BodyInterface&amp; body_interface = m_physics_system-&gt;GetBodyInterface();for (uint32_t i = 0; i &lt; scene.go_id_list.size(); i++)&#123; uint32_t go_id = scene.go_id_list[i]; Bounding&amp; bounding = scene.bounding_list[i]; if (bounding.type == BoundingType::Box) &#123; JPH::BoxShapeSettings floor_shape_settings(JPH::Vec3(bounding.data[0], bounding.data[1], bounding.data[2])); JPH::ShapeSettings::ShapeResult floor_shape_result = floor_shape_settings.Create(); JPH::ShapeRefC floor_shape = floor_shape_result.Get(); JPH::BodyCreationSettings floor_settings(floor_shape, JPH::RVec3(bounding.position[0], bounding.position[1], bounding.position[2]), JPH::Quat::sIdentity(), JPH::EMotionType::Static, Layers::NON_MOVING); JPH::Body* box = body_interface.CreateBody(floor_settings); body_interface.AddBody(box-&gt;GetID(), JPH::EActivation::DontActivate); m_go_id_to_body_id[go_id] = box-&gt;GetID(); &#125; else if (bounding.type == BoundingType::Sphere) &#123; JPH::BodyCreationSettings sphere_settings(new JPH::SphereShape(bounding.data[0]), JPH::RVec3(bounding.position[0], bounding.position[1], bounding.position[2]), JPH::Quat::sIdentity(), JPH::EMotionType::Dynamic, Layers::MOVING); JPH::BodyID sphere_id = body_interface.CreateAndAddBody(sphere_settings, JPH::EActivation::Activate); m_go_id_to_body_id[go_id] = sphere_id; &#125;&#125;m_physics_system-&gt;OptimizeBroadPhase(); 模拟 void PhysicsManager::tick()&#123; float dt = Time::getInstance().getDeltaTime(); m_physics_system-&gt;Update(dt, 1, m_temp_allocator, m_job_system); // 用物理模拟的数据修改渲染场景信息 JPH::BodyInterface&amp; body_interface = m_physics_system-&gt;GetBodyInterface(); JPH::RVec3 position = body_interface.GetCenterOfMassPosition(m_go_id_to_body_id[1]); m_scene.mesh_transform_list[1].position = &#123; position.GetX(), position.GetY(), position.GetZ() &#125;;&#125;","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Physics","slug":"Physics","permalink":"https://reubensun.com/tags/Physics/"},{"name":"Jolt Physics","slug":"Jolt-Physics","permalink":"https://reubensun.com/tags/Jolt-Physics/"}]},{"title":"头发渲染学习","slug":"graphics/头发渲染学习","date":"2024-01-30T15:39:25.000Z","updated":"2025-03-18T07:16:48.442Z","comments":true,"path":"graphics/头发渲染学习/","permalink":"https://reubensun.com/graphics/%E5%A4%B4%E5%8F%91%E6%B8%B2%E6%9F%93%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"头发渲染学习 最近因为不了解头发渲染的流程，整了乌龙，把正确的结果当成错误了。于是打算学习一下头发渲染的流程 面片发是由大量非平面面片制作，他们的切线沿着头发丝的方向，渲染时开启双面绘制 渲染方程 传入切线 UE5在绘制头发时，向GBuffer的法线位写入的是Tangent WriteGBuffer( Samples_Tangent, // 写入切线而非法线 Samples_Specular, Samples_BaseColor, Samples_Roughnesss, Samples_LightChannelMask, Samples_Backlit, Samples_Depth, OutGBufferA, OutGBufferB, OutGBufferC, OutGBufferD, OutGBufferE, OutDepth); 美术在头发面片制作时，将切线沿着发丝方向，这些切线正好也是一根根发丝方向的切线，用于控制各项异性的高光 BSDF 如下图所示，毛发渲染通常由三部分组成： 反射（R，下图1） 传播-传播（TT，下图2） 传播-反射-传播（TRT，下图3） 参考 Physically-Accurate Fur Reflectance: Modeling, Measurement and Rendering 从理论到实现的头发渲染—基于UE4","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Hair","slug":"Hair","permalink":"https://reubensun.com/tags/Hair/"}]},{"title":"使用Rust与WebAssembly画三角形","slug":"program/Rust-WebAssembly","date":"2024-01-29T14:10:25.000Z","updated":"2025-03-18T07:16:48.437Z","comments":true,"path":"program/Rust-WebAssembly/","permalink":"https://reubensun.com/program/Rust-WebAssembly/","excerpt":"","text":"使用Rust与WASM画三角形 概念 WASM是一种二进制格式，我们可以将一些语言编译为这种格式，使得代码可以在浏览器中运行 与Typescript转JavaScript不同，WASM是一种编译好的二进制，性能会比那些“编一句运行一句的代码”性能好 WASM最初是为了C/C++设计的，但也很适合使用Rust，如果你是一个Rust信徒，这套逻辑很适合你 环境安装 Windows 11 + Winget winget install node.jswinget install rustup 下载wasm-pack：[链接](wasm-pack (rustwasm.github.io)) 项目初始化 npm init rust-webpacknpm installnpm start 此时会自动弹出一个网页，按F12可以发现，控制台输出了Hello World！ 绘制三角形 在static/index.html中添加一个canvas &lt;body&gt;+ &lt;canvas id=&quot;canvas&quot; tabindex=&quot;0&quot; height=&quot;600&quot; width=&quot;600&quot;&gt;+ Your browser does not support the canvas.+ &lt;/canvas&gt;&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 在Cargo.toml中添加web-sys依赖 [dependencies.web-sys]version = &quot;0.3.22&quot;-features = [&quot;console&quot;]+features = [&quot;console&quot;, &quot;Window&quot;, &quot;Document&quot;, &quot;HtmlCanvasElement&quot;, &quot;CanvasRenderingContext2d&quot;, &quot;Element&quot;] 在src/lib.rs中添加绘制命令 wasm_bindgen会export main_js，以便JavaScript调用 #[wasm_bindgen(start)]pub fn main_js() -&gt; Result&lt;(), JsValue&gt; &#123; // This provides better error messages in debug mode. // It&#x27;s disabled in release mode so it doesn&#x27;t bloat up the file size. #[cfg(debug_assertions)] console_error_panic_hook::set_once();+ let window = web_sys::window().unwrap();+ let document = window.document().unwrap();+ let canvas = document+ .get_element_by_id(&quot;canvas&quot;)+ .unwrap()+ .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()+ .unwrap();+ let context = canvas+ .get_context(&quot;2d&quot;)+ .unwrap()+ .unwrap()+ .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()+ .unwrap();+ context.move_to(300.0, 0.0); // top of triangle+ context.begin_path();+ context.line_to(0.0, 600.0); // bottom left of triangle+ context.line_to(600.0, 600.0); // bottom right of triangle+ context.line_to(300.0, 0.0); // back to top of triangle+ context.close_path();+ context.stroke();+ context.fill(); // Your code goes here! console::log_1(&amp;JsValue::from_str(&quot;Hello world!&quot;)); Ok(())&#125; 保存代码，即可触发热更（前端就是好啊） 绘制分形体 添加分形体代码 fn draw_triangle(context: &amp;web_sys::CanvasRenderingContext2d, points: [(f64, f64); 3]) &#123; let [top, left, right] = points; context.move_to(top.0, top.1); context.begin_path(); context.line_to(left.0, left.1); context.line_to(right.0, right.1); context.line_to(top.0, top.1); context.close_path(); context.stroke();&#125;fn midpoint(point_1: (f64, f64), point_2: (f64, f64)) -&gt; (f64, f64) &#123; ((point_1.0 + point_2.0) / 2.0, (point_1.1 + point_2.1) / 2.0)&#125;fn sierpinski(context: &amp;web_sys::CanvasRenderingContext2d, points: [(f64, f64); 3], depth: u8) &#123; draw_triangle(&amp;context, points); let depth = depth-1; let [top, left, right] = points; if depth &gt; 0 &#123; let left_middle = midpoint(top, left); let right_middle = midpoint(top, right); let bottom_middle = midpoint(left, right); sierpinski(&amp;context, [top, left_middle, right_middle], depth); sierpinski(&amp;context, [left_middle, left, bottom_middle], depth); sierpinski(&amp;context, [right_middle, bottom_middle, right], depth); &#125;&#125; 删去之前所有绘制内容，改为sierpinski #[wasm_bindgen(start)]pub fn main_js() -&gt; Result&lt;(), JsValue&gt; &#123; #[cfg(debug_assertions)] console_error_panic_hook::set_once(); let window = web_sys::window().unwrap(); let document = window.document().unwrap(); let canvas = document .get_element_by_id(&quot;canvas&quot;) .unwrap() .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;() .unwrap(); let context = canvas .get_context(&quot;2d&quot;) .unwrap() .unwrap() .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;() .unwrap(); sierpinski(&amp;context, [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)], 5); Ok(())&#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://reubensun.com/tags/Rust/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"https://reubensun.com/tags/WebAssembly/"}]},{"title":"C++20特性","slug":"program/C++20","date":"2024-01-26T00:10:25.000Z","updated":"2025-03-18T07:16:42.965Z","comments":true,"path":"program/C++20/","permalink":"https://reubensun.com/program/C++20/","excerpt":"","text":"C++20特性 现在是2023年，C++23都出来很久了（尽管很多编译器没有实现全功能），但还是有着大量C++11/17的老项目，出于人力和风险的考虑并没有上新标准，我作为一个C++菜鸡，也没想着去了解C++20都更新了什么，直到最近遇到了很多语言层面的问题，于是想着学习一下C++20特性 当然这里面不止C++20 语言特性 指定初始化 可以只初始化一部分，可以指定想要初始化的部分 struct Student&#123; int id = 0; std::string name;&#125;;Student s &#123; .name = &quot;Jack&quot; &#125;; Lambda [=]以前可以隐式获取this，现在需要改为[=, this] // C++20以前auto func = [](auto&amp;&amp; ...args)&#123; return foo(std::forward&lt;decltype(args)&gt;(args)...);&#125;// C++20以后auto func = []&lt;typename ...T&gt;(T&amp;&amp; ...args)&#123; return foo(std::forward(args)...);&#125; for循环支持初始化 auto getData()&#123; std::vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5&#125;; return a;&#125;int main() &#123; for(auto data = getData(); auto&amp; v: data) &#123; std::cout &lt;&lt; v &lt;&lt; std::endl; &#125; return 0;&#125; 指引switch编译优化 switch (value) &#123; case 1: break; [[likely]] case 2: break; [[unlikely]] case 3: break;&#125; 设计理念 由于宏有各种各样的坏处，C++20开始，打算逐渐废除宏。然而宏在C++程序中其实非常普遍，很多写法高度依赖于此，C++标准委员会给了很多功能用于绕过宏 std::source_location 用于传递函数调用者的信息，比调用者的函数名、文件名 这是传统的使用宏写Log的方法，宏在这里还拼接传递了__FUNCTION__和__VA_ARGS__，使得输出中自动包含了函数名，而不需要手动传入 #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;format&gt;class Logger final&#123;public: static Logger&amp; getInstance() &#123; static Logger instance; return instance; &#125; template&lt;typename... Args&gt; void log(Args&amp;&amp;... args) &#123; (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; &#125;&#125;;#define LOG(...) Logger::getInstance().log(std::format(&quot;[&#123;&#125;] &#123;&#125;&quot;, __FUNCTION__, std::format(__VA_ARGS__)))int main() &#123; LOG(&quot;Hello World!&quot;); // [main] Hello World! return 0;&#125; 这是C++20的写法，使用了std::source_location #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;format&gt;#include &lt;source_location&gt;#include &lt;string_view&gt;class Logger final&#123;public: static void log2(const std::string_view message, const std::source_location location = std::source_location::current()) &#123; std::cout &lt;&lt; &#x27;[&#x27; &lt;&lt; location.function_name() &lt;&lt; &quot;] &quot; &lt;&lt; message &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Logger::log2(&quot;Hello World!&quot;); // [int main()] Hello World! return 0;&#125; C++应用 预处理include 感觉不是很好用，建议不用 判断能不能include一个文件 // pch.h#pragma once#include &lt;iostream&gt; #if __has_include(&quot;pch.h&quot;)#include &quot;pch.h&quot;#define NUMBER 1#else#include &lt;iostream&gt;#define NUMBER 2#endifint main() &#123; std::cout &lt;&lt; NUMBER &lt;&lt; std::endl; return 0;&#125; Modules 模块 更高级的PCH，现阶段这东西大项目完全没法用 优点 没有头文件，以及相关的依赖问题 引入模块时不需要像头文件那样指定路径 编译速度非常快（C++引用头文件会巨幅降低编译速度，于是很多人喜欢在头文件中只放一个类指针，到用到里面内容的时候在引用头文件，这样会大幅提高编译速度） 显示指定导入导出 模块引入顺序无关 与现有的头文件兼容 未来也许会像Python那样提供pip和包管理器？ 缺点 除了最新的MSVC，其他编译器都没怎么实现这个功能 MSVC自己擅自主张，不按C++标准改了很多东西 IDE不支持全局modules的提示和跳转（VS2022在2023年10月支持了，clion至今还是垃圾） 需要反复引入std头文件（在C++23有快捷引入方式，但MSVC实现的很阴间） 对第三方库极度不友好 没有保存修改，IDE几乎没法解析，大多数情况IDE不给智能提示 和头文件、宏混用时容易报错 缺少std头文件时报错几乎无法阅读，大量匹配问题 cmake对其支持相当差 有的编译器无法将.cpp识别为modules？？？ import是局部的，每一个文件都需要反复import modules 一些静态变量、函数要到被用到时才会报错，build通过的代码不能保证能运行 用例 以MSVC的写法为例 // student.ixxexport module Student;import &lt;string&gt;;namespace Demo&#123; export class Student &#123; public: Student(); ~Student(); void display(); private: std::string m_name; &#125;&#125; // student.cppmimport Student; // MSVC擅自废弃了module Student的写法，很离谱import &lt;string&gt;; // 反复import std也阴间了，C++23赶快端上来吧import &lt;iostream&gt;; namespace Demo&#123; Student::Student()&#123; m_name = &quot;Hello world&quot;; &#125; Student::~Student()&#123;&#125; Student::display() &#123; std::cout &lt;&lt; m_name &lt;&lt; std::endl; &#125;&#125; 设计模式 记住单例就行 单例（Singleton） 也分懒汉式和饿汉式，最常用的设计模式，讲了很多次 class GameManager&#123;public: static GameManager* getInstance() &#123; if (m_instance == nullptr) &#123; m_instance = new GameManager(); &#125; return m_instance; &#125;private: static GameManager* m_instance; GameManager() &#123;&#125;;&#125;; 工厂（Factory） class Weapon&#123;public: Weapon(std::string name) : m_name(name) &#123;&#125;private: std::string m_name;&#125;;class WeaponFactory&#123;public: static Weapon* createWeapon(std::string name) &#123; return new Weapon(name); &#125;&#125;; 享元（Flyweight） 共享相似数据，对象仅拥有指向，下面的示例不同的享元类共用了工厂中的“颜色” // 抽象享元类class Shape &#123;public: virtual void draw(int x, int y) const = 0;&#125;;// 具体享元类 - 圆形class Circle : public Shape &#123;private: std::string color; // 内部状态public: Circle(const std::string&amp; color) : color(color) &#123;&#125; void draw(int x, int y) const override &#123; std::cout &lt;&lt; &quot;Draw a &quot; &lt;&lt; color &lt;&lt; &quot; circle at position (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; &#125;&#125;;// 具体享元类 - 矩形class Rectangle : public Shape &#123;private: std::string color; // 内部状态public: Rectangle(const std::string&amp; color) : color(color) &#123;&#125; void draw(int x, int y) const override &#123; std::cout &lt;&lt; &quot;Draw a &quot; &lt;&lt; color &lt;&lt; &quot; rectangle at position (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; &#125;&#125;;// 享元工厂class ShapeFactory &#123;private: std::unordered_map&lt;std::string, Shape*&gt; shapes; // 享元对象池public: Shape* getShape(const std::string&amp; color) &#123; if (shapes.find(color) == shapes.end()) &#123; // 如果池中没有该颜色的图形，创建并加入池中 if (color == &quot;Red&quot;) &#123; shapes[color] = new Circle(color); &#125; else if (color == &quot;Blue&quot;) &#123; shapes[color] = new Rectangle(color); &#125; &#125; return shapes[color]; &#125;&#125;;int main() &#123; ShapeFactory shapeFactory; // 在不同位置绘制相同颜色的圆形和矩形 Shape* redCircle = shapeFactory.getShape(&quot;Red&quot;); redCircle-&gt;draw(10, 10); Shape* blueRectangle = shapeFactory.getShape(&quot;Blue&quot;); blueRectangle-&gt;draw(20, 20); // 再次在不同位置绘制相同颜色的圆形 Shape* anotherRedCircle = shapeFactory.getShape(&quot;Red&quot;); anotherRedCircle-&gt;draw(30, 30); // 注意：虽然外部状态不同，但相同颜色的圆形共享内部状态，从而减少了对象的创建 // 这符合享元模式的思想，通过共享尽可能多的相似对象来减少内存或计算开销 return 0;&#125; 观察者（Observer） 状态机（State） 代理（Proxy） 装饰者（Decorator） 迭代器（Iterator） 适配器（Adapter) 命令（Command） 面向对象 模板元 除非是库代码，不然用模板元去优化业务代码，属实是往代码里下毒 更详细的信息可以看C++模板 Traits 为了减少相似代码，实现泛型，我们需要模板 对于一些特殊类型，我们往往需要特殊对待，于是需要模板特化 于是我们需要知道类型的特征，这就是Type Traits的作用 C++ STL中 Type Traits是一堆形如IsXxxx&lt;T&gt;::value的东西 原理 下面是boost库一些traits实现 创建一个默认的行为和一个特例，仅当模板类型是特例时，value才是true template&lt; typename T &gt;struct is_void &#123; static const bool value = false; &#125;;template&lt;&gt;struct is_void&lt; void &gt;&#123; const bool value = true; &#125;; template&lt; typename T &gt;struct is_pointer &#123; static const bool value = false; &#125;;template&lt; typename T &gt;struct is_pointer&lt; T* &gt;&#123; static const bool value = true; &#125;; 使用 auto ans = is_void&lt;T&gt;::value;auto ans2 = is_pointer&lt;T&gt;::value; std::true_type与std::false_type 下面是通过类型萃取，判断一个类中是否有某个成员函数 #include &lt;type_traits&gt;// 定义一个支持Check的类struct Check &#123; void Execute() &#123; std::cout &lt;&lt; &quot;Check::someFunction() called.&quot; &lt;&lt; std::endl; &#125;&#125;;// 定义一个不支持Check的类struct NoCheck &#123; // 没有someFunction成员函数&#125;;template &lt;typename T&gt;struct hasFunction_Execute &#123;private: template &lt;typename U&gt; static auto check(U* ptr) -&gt; decltype(std::declval&lt;U&gt;().Execute(), std::true_type&#123;&#125;); template &lt;typename U&gt; static std::false_type check(...);public: static constexpr bool value = decltype(check&lt;T&gt;(nullptr))::value;&#125;;int main() &#123; if (hasFunction_Execute&lt;Check&gt;::value) &#123; Check obj; obj.Execute(); &#125; // 测试NoCheck类 if (hasFunction_Execute&lt;NoCheck&gt;::value) &#123; // 不会执行到这里，因为NoCheck类没有someFunction成员函数 &#125;&#125; TMP template metaprogramming（TMP）：将其他程序的代码视为数据的编程技术 TMP通常意味着代码可以被其他程序读取、生成、分析、转化，甚至运行时修改 C++ TMP是一种用编译速度和存储空间换运行时速度的技术，将计算放在编译期，可以提高运行时性能 递归 C++ TMP很适合写递归，比如计算阶乘 constexpr unsigned long Factorial (unsigned long X)&#123; return (X == 0) ? 1 : X * Factorial(X - 1);&#125;int main()&#123; constexpr auto x = Factorial(4); std::cout &lt;&lt; x &lt;&lt; std::endl; // 24 return 0;&#125; 编译为汇编，发现程序并没有调用Factorial函数，而是直接找了一个立即数24 构造函数 constexpr也可以修饰构造函数，创建编译器常量，以提高性能 使用该功能需要构造函数体的简单性，比如不能有虚函数，不能使用动态内存分配，条件语句，成员必须使用常量表达式初始化，递归必须在编译器能中止 class MyClass &#123;public: constexpr MyClass(int x) : value(x) &#123;&#125; int getValue() const &#123; return value; &#125;private: int value;&#125;;int main()&#123; constexpr MyClass obj1(42); std::cout &lt;&lt; obj1.getValue() &lt;&lt; std::endl; return 0;&#125; 字符串 std::string_view 可以看作一个封装好的轻量级const std::string&amp;，只读、不拥有字符串所有权，性能很好，非常推荐使用 #include &lt;string_view&gt;void print_string_view(std::string_view str) &#123; std::cout &lt;&lt; str &lt;&lt; std::endl;&#125;int main() &#123; std::string_view str_view = &quot;Hello, World!&quot;; print_string_view(str_view); std::string str = &quot;Hello, World!&quot;; print_string_view(str); print_string_view(&quot;Hello, World!&quot;); // 字符串常量字面量是一个左值，生命周期和整个程序一致，所以可以放心传 return 0;&#125; STL 内存分配 &lt;memory&gt;库提供了两个基础函数，allocate()和deallocate() std::allocator&lt;int&gt; alloc;// 开辟一个长度为10个int的空间int* p = alloc.allocate(10);// 将数组第一个值构设为42std::allocator_traits&lt;std::allocator&lt;int&gt;&gt;::construct(alloc, p, 42);// 销毁这个数组alloc.deallocate(p, 10); concept 迭代器 C++迭代器已经是要被淘汰的概念了，但是新的C++标准仍然在对迭代器进行拓展 concept可以对迭代器进行约束（也就是提要求requires-expression） #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;concepts&gt;template &lt;typename Iter&gt;concept InputIterator = requires(Iter iter) &#123; &#123; iter++ &#125; -&gt; std::same_as&lt;Iter&gt;; // 要求自增 &#123; iter != iter &#125; -&gt; std::convertible_to&lt;bool&gt;; // 要求能比较不等 &#123; ++iter &#125; -&gt; std::same_as&lt;Iter&amp;&gt;; // 要求迭代器能前进&#125;;template &lt;InputIterator Iter&gt;void printElements(Iter begin, Iter end) &#123; while (begin != end) &#123; std::cout &lt;&lt; *begin &lt;&lt; &#x27; &#x27;; ++begin; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::vector&lt;int&gt; numbers = &#123; 1, 2, 3, 4, 5 &#125;; printElements(numbers.begin(), numbers.end()); // 若不满足会编译报错 return 0;&#125; 函数式编程 函数式编程将程序分解为函数（而非对象），使用表达式进行操作（而非语句） 函数式编程的核心是将一个大问题切成多个小问题 函数式编程更适合多线程 std::function 函数式编程将函数视为一等公民，常常将函数作为参数进行传递。不过一般公民通常需要有自己的成员和状态，函数指针无法满足我们的需求，重载类的()运算符有点太OOP了 C++提供了高阶函数： #include &lt;functional&gt;std::function&lt;int(int, int)&gt; get_multiplier()&#123; return [](int a, int b) &#123; return a * b; &#125;;&#125;std::function&lt;int(int)&gt; multiply(int a)&#123; return [a](int b) &#123; return a * b; &#125;;&#125;int main() &#123; auto mul = get_multiplier(); std::cout &lt;&lt; mul(10, 20) &lt;&lt; std::endl; std::cout &lt;&lt; multiply(10)(20) &lt;&lt; std::endl; auto mul3 = multiply(10); std::cout &lt;&lt; mul3(20) &lt;&lt; std::endl;&#125; Ranges 范围 感觉不同编译器对这个功能的支持差异好大 为std容器提供了简洁、强大、顺序可控的操作方式 引入view概念，运行创建一个惰性计算操作，不立即得到结果，提高内存利用率和性能 使用|和-&gt;操作符处理范围变量 // 查找array中偶数的数量std::array&lt;int, 5&gt; arr = &#123;1, 2, 3, 4, 5&#125;;auto res = std::count_if(arr.begin(), arr.end(), [](int x) &#123; return x % 2 == 0; &#125;); // 2 个偶数auto res2 = arr | std::views::filter([](int x) &#123; return x % 2 == 0; &#125;);for (auto i : res2) &#123; std::cout &lt;&lt; i &lt;&lt; std::endl; // 输出 2 4&#125; transform和filter返回的是一个range结构，而非容器 // 将vector中所有元素做平方，并去掉奇数项std::vector&lt;int&gt; data &#123; 0, 1, 2, 3, 4, 5 &#125;;auto square = [](int i) &#123; return i * i; &#125;;auto odd = [](int i)&#123; return i % 2 != 0; &#125;;auto result = data | std::views::transform(square) | std::views::filter(odd); // 1 9 25 // 将一个二维数组展成一维std::vector&lt;std::vector&lt;int&gt;&gt; v2 = &#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8, 9&#125;&#125;;auto result2 = v2 | std::views::join; // 创建一个从1开始递增的数组，并对其进行平方，取前十个数（最后实际也只会计算十个数）auto square = [](int i) &#123; return i * i; &#125;;auto res = std::views::iota(1) | std::views::transform(square)| std::views::take(10);for (auto i : res) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; // 1 4 9 16 25 36 49 64 81 100&#125; 纯函数 pure 纯函数：不改变程序状态的函数 纯函数给定输入，无论执行多少次，都返回相同的结果 传函数不访问全局变量，仅使用输入的参数 折叠 折叠：将一组数据整合为数量更少的数据的方式 #include &lt;numeric&gt;int main()&#123; std::vector&lt;int&gt; numbers = &#123; 1, 2, 3, 4, 5 &#125;; // 一个累乘的示例 int product = std::accumulate(numbers.begin(), numbers.end(), 1, std::multiplies&lt;int&gt;()); std::cout &lt;&lt; &quot;Product of elements: &quot; &lt;&lt; product &lt;&lt; std::endl;&#125; std::multiplies&lt;int&gt;()可以替换为lambda表达式 并发和多线程 感觉不如TBB std::thread thread构造时就会启动线程 #include &lt;thread&gt;void print_background()&#123; auto i&#123; 0 &#125;; while (true) &#123; std::cout &lt;&lt; &quot;Background: &quot; &lt;&lt; i++ &lt;&lt; std::endl; &#125;&#125;int main() &#123; std::thread background&#123;print_background&#125;; auto j&#123; 0 &#125;; while (j &lt; 1000) &#123; std::cout &lt;&lt; &quot;Main: &quot; &lt;&lt; j++ &lt;&lt; std::endl; &#125;&#125; join 等待线程停止 int main() &#123; std::thread tl &#123; [] &#123; std::cout &lt;&lt; &quot;A lambda passed to the thread&quot; &lt;&lt; std::endl; &#125; &#125;; tl.join(); // 等待 tl执行结束 std::cout &lt;&lt; &quot;Main thread&quot; &lt;&lt; std::endl;&#125; 线程结束后，与线程关联都是对象tl状态会被改变，此时调用tl.joinable()会返回false，你可以用joinable()来判断对象是否还在持有一个线程 detach 极其不推荐使用，多线程编程应该自行管理资源 分离线程，线程对象将放弃对线程资源的所有权，线程将独立运行，结束后自动释放所有分配的资源 tl.detach(); 传参 构造时传参，这下参数会被传递到新线程的内存空间中 注意，即使参数标为引用，也是复制 void foo(int a, int b) &#123;...&#125;void foo2(int, const int&amp; a) &#123;...&#125;int main() &#123; std::thread t1&#123; foo, 1, 2 &#125;; int n = 4; std::thread t2&#123; foo2, 3, n &#125;;&#125; 使用成员函数指针 成员函数指针也可以传给thread构造，自然也可以使用std::bind struct Utils&#123; void task_run(int)const;&#125;;Utils u;int n = 0;std::thread t&#123; &amp;Utils::task_run, &amp;u,n &#125;;std::thread t2&#123; std::bind(&amp;Utils::task_run, &amp;u ,n) &#125;;t.join(); 成员指针必须和对象一起使用，不可以转换到函数指针单独使用 std::this_thread 用于管理当前线程 get_id 打印当前线程id int main()&#123; std::thread t&#123; [] &#123; std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;; t.join(); return 0;&#125; sleep_for 休眠一段时间 #include &lt;thread&gt;#include &lt;iomanip&gt;int main()&#123; std::thread t&#123; [] &#123; // 打印休眠前时间戳 auto now = std::chrono::system_clock::now(); auto now_time = std::chrono::system_clock::to_time_t(now); std::cout &lt;&lt; &quot;Current time:\\t\\t&quot; &lt;&lt; std::put_time(std::localtime(&amp;now_time), &quot;%H:%M:%S&quot;) &lt;&lt; std::endl; // 休眠2秒 std::this_thread::sleep_for(std::chrono::seconds(2)); // 打印休眠后时间戳 now = std::chrono::system_clock::now(); now_time = std::chrono::system_clock::to_time_t(now); std::cout &lt;&lt; &quot;Current time:\\t\\t&quot; &lt;&lt; std::put_time(std::localtime(&amp;now_time), &quot;%H:%M:%S&quot;) &lt;&lt; std::endl; &#125; &#125;; t.join(); return 0;&#125; 使用using namespace std::chrono_literals，3s等同于std::chrono::seconds(3) sleep_until 休眠到具体某个时间戳 using namespace std::chrono_literals;int main()&#123; std::thread t&#123; [] &#123; // 打印休眠前时间戳 auto now = std::chrono::system_clock::now(); auto now_time = std::chrono::system_clock::to_time_t(now); std::cout &lt;&lt; &quot;Current time:\\t\\t&quot; &lt;&lt; std::put_time(std::localtime(&amp;now_time), &quot;%H:%M:%S&quot;) &lt;&lt; std::endl; // 休眠到3秒以后 auto wakeup_time = now + 3s; std::this_thread::sleep_until(wakeup_time); // 打印休眠后时间戳 now = std::chrono::system_clock::now(); now_time = std::chrono::system_clock::to_time_t(now); std::cout &lt;&lt; &quot;Current time:\\t\\t&quot; &lt;&lt; std::put_time(std::localtime(&amp;now_time), &quot;%H:%M:%S&quot;) &lt;&lt; std::endl; &#125; &#125;; t.join(); return 0;&#125; yield // 循环等待isDonewhile (!isDone())&#123; // 使用yield可以减少CPU浪费，不会一直在这里高频空转 std::this_thread::yield();&#125; std::jthread C++20提供的新线程库，可以完美替代std::thread std::jthread在线程运行结束后再进行析构，可以确保线程安全退出 对异常和中断的支持更好 RAII jthread与thread的一大不同：jthread在析构时会调用join() 主动停止 jthread可以主动请求某个线程结束，下面的代码在Main输出完毕后background也会停止输出 void print_background(std::stop_token stoken)&#123; auto i&#123; 0 &#125;; while (true) &#123; if (stoken.stop_requested()) &#123; return; &#125; std::cout &lt;&lt; &quot;Background: &quot; &lt;&lt; i++ &lt;&lt; std::endl; &#125;&#125;int main() &#123; std::jthread background&#123;print_background&#125;; std::stop_token stoken = background.get_stop_token(); auto jx&#123; 0 &#125;; while (jx &lt; 1000) &#123; std::cout &lt;&lt; &quot;Main: &quot; &lt;&lt; jx++ &lt;&lt; std::endl; &#125; background.request_stop(); // 请求结束&#125; 互斥信号量 多线程我们不可避免遇到线程竞争，尤其是读写 lock std::mutex locker;int global_value&#123; 0 &#125;;void inc()&#123; std::lock_guard g(locker); // 通过生命周期管理锁 global_value++; std::cout &lt;&lt; global_value &lt;&lt; std::endl;&#125;int main() &#123; std::thread t1&#123; inc &#125;; std::thread t2&#123; inc &#125;;&#125; try_lock lock会立刻上锁，我们也可以进行尝试上锁，若锁已经被其他线程锁住，当前线程会立刻返回，可以去做其他事，而不是阻塞在这里 std::mutex locker;void thread_function(int id) &#123; // 尝试加锁 if (locker.try_lock()) &#123; std::cout &lt;&lt; &quot;线程：&quot; &lt;&lt; id &lt;&lt; &quot; 获得锁&quot; &lt;&lt; std::endl; // 临界区代码 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟临界区操作 locker.unlock(); // 解锁 std::cout &lt;&lt; &quot;线程：&quot; &lt;&lt; id &lt;&lt; &quot; 释放锁&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;线程：&quot; &lt;&lt; id &lt;&lt; &quot; 获取锁失败 处理步骤&quot; &lt;&lt; std::endl; &#125;&#125; 保护 不要将受保护数据传递给外部（比如通过指针、引用），这样保护就失去意义了 死锁 多个互斥信号量可能会导致死锁 std::unique_lock 同步 future：在等待某一件事时做另一件事 std::future 与一个事件相关联 #include &lt;thread&gt;#include &lt;future&gt; int task(int n) &#123; std::cout &lt;&lt; &quot;异步任务 ID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &#x27;\\n&#x27;; return n * n;&#125;int main() &#123; std::future&lt;int&gt; f = std::async(task, 10); std::cout &lt;&lt; &quot;main: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; std::boolalpha &lt;&lt; f.valid() &lt;&lt; &#x27;\\n&#x27;; // true std::cout &lt;&lt; future.get() &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; std::boolalpha &lt;&lt; f.valid() &lt;&lt; &#x27;\\n&#x27;; // false&#125; std::shared_future 能关联多个事件 std::async deferred：惰性求值，不创建线程，等待调用wait、get再执行任务 async：在不同线程 void f()&#123;...&#125;// 这里的 auto 是 std::future&lt;void&gt;auto f1 = std::async(std::launch::deferred, f); // 此时f1并不会执行f1.wait(); // 主动让f1执行auto f2 = std::async(std::launch::async,f); // 立刻开一个线程执行f2 注意，std::future的析构会阻塞std::async，因此匿名Lambda并不能用了创建异步任务 std::async(std::launch::async, []&#123; f(); &#125;); // 临时量的析构函数等待 f()std::async(std::launch::async, []&#123; g(); &#125;); // f() 完成前不开始 协程 C++20引入了关键词co_await、co_yield、co_return，但是不能用，要到C++23以后才有相关的库 参考 C++11、14、17、20新增内容 《Expert C++》 CppReference","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"Vulkan学习笔记","slug":"graphics/Vulkan学习","date":"2024-01-23T09:37:25.000Z","updated":"2025-03-18T07:16:48.443Z","comments":true,"path":"graphics/Vulkan学习/","permalink":"https://reubensun.com/graphics/Vulkan%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Vulkan学习笔记 在过去，我以为Vulkan只有高端安卓才会用，相当复杂，没有下定决心去学。后来发现很多桌面和主机游戏也在用Vulkan，Vulkan真的很出色很重要，于是这几天开始看英伟达nvpro和Vulkan官方教程，打算自己敲一个小demo 我的Vulkan项目 最近搓了一个Vulkan项目，记录一下学习过程 Vulkan API Queue 参考 what-is-actually-a-queue-family-in-vulkan Queue是将命令提交到GPU的入口，Command buffer会被提交到Queue中按顺序执行 你可以使用多个线程分别提交命令到多个Queue中 提交到不同Queue的命令，其执行顺序不确定，但可以使用Semaphore进行同步 Vulkan的命令有： vkCmdDraw vkCmdDispatch：执行Compute Shader vkCmdCopy vkQueueBindSparse 通常一个Queue只能处理某几种命令 一个硬件往往只有有限个Queue Render Pass 画到哪 Vulkan相较于OpenGL、DX11/12，一大特点就是有Render Pass这个概念 Render Pass的作用是描述绘制的目标（attachments，很像RT），比如color，比如depth 比如一个Forward Pass，他的目标可能就是一张color和一张depth，一个Deferred Pass，他的目标可能是GBuffer（一组color）和一个depth VkAttachmentDescription 值得注意的参数 format：image view格式 samples：多采样次数 finalLayout：当renderpass绘制结束时，会将color转化为该格式 画向Swapchain Image，finalLayout配置为VK_IMAGE_LAYOUT_PRESENT_SRC_KHR 给其他pass的shader采样，设置为VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL Subpass 一个像素在绘制单元绘制后，通常需要被拷贝出去，形成一张完整的RT，然后再由另一个绘制单元绘制 Subpass的一大特点是一个像素被一个Subpass绘制后，并不会立刻被拷贝出去，而是继续被另一个Subpass绘制 优点： 减少了拷贝带来的带宽，减少延迟和发热，移动端延迟渲染常用该技术 像素间绘制彼此独立，不需要一整张RT绘制后再绘制下一张，提高并行效率，还能用来实现OIT和Zero Overdraw 缺点： 拿不到其他位置的RT的绘制内容，无法实现一些依赖RT的屏幕后效 Pipeline 怎么画 用于设置管线的状态 参数 主要作用 管线类型 图形管线还是计算管线 Shader Stage 指定绘制用的Shader Vertex Input 顶点缓冲的结构 Input Assembly 输入的结构，比如三角形的拓扑规则 Viewport &amp; Scissors Rasterizer 光栅化的规则，比如用线、用三角面绘制，是否背面剔除 Multisampling 多采样的规则 Depth Stencil 深度测试、模板测试的规则 Blending 颜色混合规则（半透明） Pipeline Layout 管线的结构，比如UBO binding规则 在Vulkan中，Render Pass是比Pipeline大的，这也很好理解，毕竟只要绘制目标没有改变，自然不需要改动Render Pass 而一个场景中有大量不同材质、Shader的对象，而且有的可能是线，有的是三角形，于是需要经常调整Pipeline，于是Vulkan的Pipeline就像Descriptor Set一样，可以随时改绑定的 Vulkan的Pipeline是很大的东西，实时创建大量开销过大，而大部分的Pipeline对象都很接近，可能就只有一小部分有差异。为了实现复用，Vulkan的Pipeline是可以动态修改、可以Cache、可以生成子类 Descriptor Set Layout Shader中的资源位置 Shader中会使用很多资源，比如UBO，比如贴图Sampler，需要指定绑定的位置 layout(binding = 0) uniform GlobalUBO &#123; mat4 modelMatrix; mat4 viewMatrix; mat4 projectionMatrix;&#125; ubo; layout(binding = 1) uniform sampler2D texSampler; Descriptor Set 资源 简单理解为Vulkan管线能理解、使用的资源，比如UBO，比如贴图Sampler 在绘制时，我们可以绑定一个Descriptor Sets，里面包含多个Descriptor Set，其结构是Layout决定的 通常我们为每一个材质实例创建一个Descriptor Set（一个UBO或者贴图可以Update到多个Descriptor Set上） 我们可以单独更新某一个Set VkDescriptorType 含义 类似DX12中的 VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE 读图片 SRV VK_DESCRIPTOR_TYPE_STORAGE_IMAGE 读写图片 UAV VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER 读图片，并包含各种采样配置 SRV + Sampler VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER 常量缓冲 UBO Image Texure Usage 图片的使用目的 VkImageUsageFlagBits 含义 VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT Color渲染目标 VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 深度缓冲、模板缓冲渲染目标 VK_IMAGE_USAGE_TRANSFER_SRC_BIT 图像拷贝的源 VK_IMAGE_USAGE_TRANSFER_DST_BIT 图形拷贝的目标 VK_IMAGE_USAGE_SAMPLED_BIT 可以被着色器读 VK_IMAGE_USAGE_STORAGE_BIT 可以被着色器写 Layout 图形在内存的布局和排列，会影响拷贝、渲染等行为的可用性 VkImageLayout 用途 VK_IMAGE_LAYOUT_UNDEFINED 图形初始化 VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL Color渲染目标 VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL 深度缓冲、模板缓冲渲染目标 VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL Shader可读的贴图 Image的Layout转化需要使用Pipeline Barrier Image View Fence 用于隔离不同帧 Semaphore 用于隔离渲染和呈现 Shader Vulkan使用SPIR-V作为着色语言，这是一种底层的二进制着色语言，可以使用glslang编译GLSL得到 # 将vert_shader.vert编译为vert_spv$glslangValidator -V vert_shader.vert# 将vert_shader.vert编译为test.spv$glslangValidator -V vert_shader.vert -o test.spv 可以使用spirv-dis查看一个spv文件的内容（如果编译时带有调试信息，可以看到源码） spirv-dis test.spv Vertex #version 450layout(binding = 0) uniform GlobalUBO &#123; mat4 modelMatrix; mat4 viewMatrix; mat4 projectionMatrix;&#125; ubo;layout(location = 0) in vec3 inPosition;layout(location = 1) in vec3 inColor;layout(location = 2) in vec2 inTexCoord;layout(location = 0) out vec3 fragColor;layout(location = 1) out vec2 uv0;void main() &#123; gl_Position = ubo.projectionMatrix * ubo.viewMatrix * ubo.modelMatrix * vec4(inPosition, 1.0); fragColor = inColor; uv0 = inTexCoord;&#125; Fragment #version 450layout(location = 0) in vec3 fragColor;layout(location = 1) in vec2 uv0;layout(location = 0) out vec4 outColor;layout(binding = 1) uniform sampler2D texSampler;void main() &#123; outColor = texture(texSampler, uv0);&#125; 集成到cmake 在VS文件夹中显示 Visual Studio安装glsl插件后，shader可以高亮和智能提示 file(GLOB_RECURSE HEADERS &quot;*.h&quot;)file(GLOB_RECURSE SOURCES &quot;*.cpp&quot;)set(SHADER_DIR &quot;../Shader/Source&quot;)file(GLOB VERT_SHADERS &quot;$&#123;SHADER_DIR&#125;/*.vert&quot;)file(GLOB FRAG_SHADERS &quot;$&#123;SHADER_DIR&#125;/*.frag&quot;)set(ALL_FILES $&#123;HEADERS&#125; $&#123;SOURCES&#125;)add_library(Engine STATIC $&#123;ALL_FILES&#125; $&#123;VERT_SHADERS&#125; $&#123;FRAG_SHADERS&#125;)target_include_directories(Engine PUBLIC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)source_group(TREE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; FILES $&#123;ALL_FILES&#125;)# 核心是这个source_group(&quot;Shaders&quot; FILES $&#123;VERT_SHADERS&#125; $&#123;FRAG_SHADERS&#125;) 项目构建时编译 # Compile shadersset(SPV_TARGET_DIR &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../Shader/SPV&quot;)foreach(SHADER_FILE $&#123;VERT_SHADERS&#125;) get_filename_component(FILE_NAME $&#123;SHADER_FILE&#125; NAME) string(REPLACE &quot;.&quot; &quot;_&quot; OUTPUT_STRING $&#123;FILE_NAME&#125;) message(&quot;Compile vert shader: $&#123;FILE_NAME&#125; =&gt; $&#123;OUTPUT_STRING&#125;.spv&quot;) add_custom_command(TARGET Engine POST_BUILD COMMAND glslangValidator -V -S vert $&#123;SHADER_FILE&#125; -o $&#123;SPV_TARGET_DIR&#125;/$&#123;OUTPUT_STRING&#125;.spv )endforeach()foreach(SHADER_FILE $&#123;FRAG_SHADERS&#125;) get_filename_component(FILE_NAME $&#123;SHADER_FILE&#125; NAME) string(REPLACE &quot;.&quot; &quot;_&quot; OUTPUT_STRING $&#123;FILE_NAME&#125;) message(&quot;Compile frag shader: $&#123;FILE_NAME&#125; =&gt; $&#123;OUTPUT_STRING&#125;.spv&quot;) add_custom_command(TARGET Engine POST_BUILD COMMAND glslangValidator -V -S frag $&#123;SHADER_FILE&#125; -o $&#123;SPV_TARGET_DIR&#125;/$&#123;OUTPUT_STRING&#125;.spv )endforeach() # Copy Shaderadd_custom_command(TARGET Client POST_BUILD COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_directory $&#123;CMAKE_SOURCE_DIR&#125;/Shader/SPV $&lt;TARGET_FILE_DIR:Client&gt;/Shaders) ImGui Vulkan ImGui本质是使用Vulkan API画平面，ImGui会帮你创建一个Pipeline，但是你需要自己准备Render Pass、Frame Buffer、Vulkan Context等内容 ImGui版本选择 ImGui不同分支功能不同，其中最多人使用的docking分支，这个分支下ImGui可以用来做Editor Vulkan初始化 核心是需要一个Render Pass，这个Render Pass需要有一个Color Attachment，我建议单独开一个pass ImGui初始化 可以认为这个过程是帮你创建以Render Pipeline ImGui::CreateContext();ImGuiIO&amp; io = ImGui::GetIO();(void)io;io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; setStyle();ImGui_ImplGlfw_InitForVulkan(rhi_context.m_window.getHandle(), true);ImGui_ImplVulkan_InitInfo init_info = &#123;&#125;;init_info.Instance = rhi_context.m_instance-&gt;getHandle();init_info.PhysicalDevice = rhi_context.m_device-&gt;getPhysicalDevice();init_info.Device = rhi_context.m_device-&gt;getLogicalDevice();init_info.QueueFamily = rhi_context.m_device-&gt;getGraphicsFamilyIndex();init_info.Queue = rhi_context.m_device-&gt;getGraphicsQueue();init_info.DescriptorPool = rhi_context.m_descriptor_pool-&gt;getHandle();init_info.MinImageCount = rhi_context.m_swapchain-&gt;getImageCount(); // 3init_info.ImageCount = rhi_context.m_swapchain-&gt;getImageCount(); // 3;ImGui_ImplVulkan_Init(&amp;init_info, render_pass.getHandle()); 绘制 需要传入一个command buffer ImGui_ImplVulkan_NewFrame();ImGui_ImplGlfw_NewFrame();ImGui::NewFrame();ImGui::DockSpaceOverViewport(nullptr, ImGuiDockNodeFlags_PassthruCentralNode);ImGui::Begin(&quot;Hierarchy&quot;);// draw somethingImGui::End();ImGui::Render();ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), cmd.getHandle(frame_index)); 销毁 ImGui_ImplVulkan_Shutdown();ImGui_ImplGlfw_Shutdown();ImGui::DestroyContext(); Vulkan拓展 可以通过函数指针的方式引入一些Vulkan拓展 Debug Label 在使用RenderDoc截帧时，我们可以看到一些绘制命令被分类命名，一些贴图也有调试名称 PFN_vkCmdBeginDebugUtilsLabelEXT vkCmdBeginDebugUtilsLabelEXT = nullptr;PFN_vkCmdEndDebugUtilsLabelEXT vkCmdEndDebugUtilsLabelEXT = nullptr;void RHIDevice::loadExtensionFunctions()&#123; vkCmdBeginDebugUtilsLabelEXT = reinterpret_cast&lt;PFN_vkCmdBeginDebugUtilsLabelEXT&gt;(vkGetInstanceProcAddr(m_instance.getHandle(), &quot;vkCmdBeginDebugUtilsLabelEXT&quot;)); vkCmdEndDebugUtilsLabelEXT = reinterpret_cast&lt;PFN_vkCmdEndDebugUtilsLabelEXT&gt;(vkGetInstanceProcAddr(m_instance.getHandle(), &quot;vkCmdEndDebugUtilsLabelEXT&quot;));&#125;void RHIDevice::beginDebugUtilsLabel(VkCommandBuffer cmd, const VkDebugUtilsLabelEXT&amp; label)&#123; vkCmdBeginDebugUtilsLabelEXT(cmd, &amp;label);&#125;void RHIDevice::endDebugUtilsLabel(VkCommandBuffer cmd)&#123; vkCmdEndDebugUtilsLabelEXT(cmd);&#125;","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://reubensun.com/tags/Vulkan/"}]},{"title":"C# Attribute用法","slug":"program/CSharpeAttribute","date":"2024-01-15T16:41:25.000Z","updated":"2025-03-18T07:16:42.966Z","comments":true,"path":"program/CSharpeAttribute/","permalink":"https://reubensun.com/program/CSharpeAttribute/","excerpt":"","text":"C# Attribute用法 内建功能 标记函数 比如标记函数已过时，再调用这个函数时会有绿色的波浪线，并提示你函数已过时 [Obsolete(&quot;This func is obsolete, use newFunc()&quot;)]public void OldFunc()&#123; // do something&#125; 数据验证 可以确保某个数据存在 public class UserModel&#123; [Required(ErrorMessage = &quot;Username is required.&quot;)] public string Username &#123; get; set; &#125; [Required(ErrorMessage = &quot;Password is required.&quot;)] public string Password &#123; get; set; &#125;&#125; // 创建一个对象，但是没有填充Required信息var invalidUser = new UserModel();var validationResults = new List&lt;System.ComponentModel.DataAnnotations.ValidationResult&gt;();bool isValid = Validator.TryValidateObject(invalidUser, new ValidationContext(invalidUser), validationResults, true);if (!isValid)&#123; string errorMessage = string.Empty; foreach (var validationResult in validationResults) &#123; errorMessage +=validationResult.ErrorMessage; &#125; // 输出 &quot;Username is required.Password is required.&quot; Console.WriteLine(errorMessage); &#125; 序列化与反序列化 WCF Windows Communication Foundation [DataContract]public class Person&#123; [DataMember] public string Name &#123; get; set; &#125; [DataMember] public int Age &#123; get; set; &#125;&#125; var person = new Person &#123; Name = &quot;John&quot;, Age = 20 &#125;;var serializer = new DataContractSerializer(typeof(Person));// 序列化using (var memoryStream = new MemoryStream())&#123; serializer.WriteObject(memoryStream, person); memoryStream.Position = 0; var serializedData = new StreamReader(memoryStream).ReadToEnd(); LabelText = serializedData;&#125;// 反序列化using (var reader = XmlReader.Create(new StringReader(LabelText)))&#123; var deserializedPerson = (Person)serializer.ReadObject(reader);&#125; 序列化的产物是一个xml： &lt;Person xmlns=&quot;http://schemas.datacontract.org/2004/07/AttributeStudy&quot; xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;&lt;Age&gt;20&lt;/Age&gt;&lt;Name&gt;John&lt;/Name&gt;&lt;/Person&gt; Serializable [Serializable]public class Person&#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125;&#125; Person person = new Person&#123; Name = &quot;John Doe&quot;, Age = 30&#125;;// 序列化 Person 对象到文件System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(Person));using (var stream = new System.IO.FileStream(&quot;F:\\\\person.xml&quot;, System.IO.FileMode.Create))&#123; serializer.Serialize(stream, person);&#125;// 反序列化从文件读取的数据using (var stream = new System.IO.FileStream(&quot;F:\\\\person.xml&quot;, System.IO.FileMode.Open))&#123; Person deserializedPerson = (Person)serializer.Deserialize(stream); Console.WriteLine($&quot;Name: &#123;deserializedPerson.Name&#125;, Age: &#123;deserializedPerson.Age&#125;&quot;);&#125; 序列化产物是一个xml &lt;Person xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;&lt;Name&gt;John Doe&lt;/Name&gt;&lt;Age&gt;30&lt;/Age&gt;&lt;/Person&gt; 引入DLL [DllImport(&quot;user32.dll&quot;)]public static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type);static void Main()&#123; MessageBox(IntPtr.Zero, &quot;Hello, World!&quot;, &quot;Message&quot;, 0);&#125; 自定义功能 插件 自定义属性 [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]public class PluginAttribute : Attribute&#123; public string Name &#123; get; &#125; public PluginAttribute(string name) &#123; Name = name; &#125;&#125; 自定义的属性都形如xxxAttribute，在使用时只需要[xxx(“…”)] 插件接口和插件实现 public interface IPlugin&#123; void Execute();&#125;[Plugin(&quot;MyPlugin&quot;)]public class MyPlugin : IPlugin&#123; public void Execute() &#123; Console.WriteLine(&quot;MyPlugin is executing.&quot;); &#125;&#125;[Plugin(&quot;MyPlugin2&quot;)]public class MyPlugin2 : IPlugin&#123; public void Execute() &#123; Console.WriteLine(&quot;MyPlugin2 is executing.&quot;); &#125;&#125; 找到所有插件，并执行所有插件 List&lt;IPlugin&gt; plugins = new List&lt;IPlugin&gt;();// 获取所有插件类型var pluginTypes = Assembly.GetExecutingAssembly().GetTypes().Where(type =&gt; type.GetCustomAttributes(typeof(PluginAttribute), true).Length &gt; 0);// 实例化插件foreach (var pluginType in pluginTypes)&#123; var pluginAttribute = (PluginAttribute)Attribute.GetCustomAttribute(pluginType, typeof(PluginAttribute)); var plugin = (IPlugin)Activator.CreateInstance(pluginType); Console.WriteLine($&quot;Loaded plugin: &#123;pluginAttribute.Name&#125;&quot;); plugins.Add(plugin);&#125;// 插件执行foreach (var plugin in plugins)&#123; plugin.Execute();&#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://reubensun.com/tags/CSharp/"}]},{"title":"CMake构建C#项目并使用DLL","slug":"program/CSharpCmakeDLL","date":"2024-01-04T18:41:25.000Z","updated":"2025-03-18T07:16:42.966Z","comments":true,"path":"program/CSharpCmakeDLL/","permalink":"https://reubensun.com/program/CSharpCmakeDLL/","excerpt":"","text":"CMake构建C#项目并使用DLL 项目路径 Windows cmd下使用tree /f即可生成文件路径 .│ CMakeLists.txt│ Main.cs│ p4api.net.dll│ p4bridge.dll cmake_minimum_required(VERSION 3.23)project(P4Test CSharp)set_property(GLOBAL PROPERTY VS_STARTUP_PROJECT P4Test)set(CMAKE_VS_EFFECTIVE_PLATFORMS x64) set(SOURCES $&#123;CMAKE_SOURCE_DIR&#125;/Main.cs )add_executable(P4Test $&#123;SOURCES&#125;)set_property(TARGET P4Test PROPERTY VS_DOTNET_TARGET_FRAMEWORK_VERSION &quot;v4.7.2&quot;)set_property(TARGET P4Test PROPERTY VS_DOTNET_REFERENCE_P4API &quot;$&#123;CMAKE_SOURCE_DIR&#125;/p4api.net.dll&quot;) add_custom_command( TARGET P4Test POST_BUILD COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_if_different $&#123;CMAKE_SOURCE_DIR&#125;/p4api.net.dll $&lt;TARGET_FILE_DIR:P4Test&gt;)add_custom_command( TARGET P4Test POST_BUILD COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_if_different $&#123;CMAKE_SOURCE_DIR&#125;/p4bridge.dll $&lt;TARGET_FILE_DIR:P4Test&gt;) using Perforce.P4;namespace P4DoNetApi&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Hello world&quot;); &#125; &#125;&#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://reubensun.com/tags/CSharp/"},{"name":"CMake","slug":"CMake","permalink":"https://reubensun.com/tags/CMake/"}]},{"title":"吸血鬼幸存者+战意","slug":"game/吸血鬼幸存者like","date":"2024-01-04T10:01:25.000Z","updated":"2025-03-18T07:16:48.445Z","comments":true,"path":"game/吸血鬼幸存者like/","permalink":"https://reubensun.com/game/%E5%90%B8%E8%A1%80%E9%AC%BC%E5%B9%B8%E5%AD%98%E8%80%85like/","excerpt":"","text":"吸血鬼幸存者+战意 灵感起源 最近在玩战意，感觉这游戏玩法设计的有问题 主打将军梦的游戏，一次却只能带十几个兵，而且ACT玩法会给人一种这些小兵是具体的个体，而非抽象的军团，玩家扮演的是一个个十夫长（一个武将能杀几十个小兵，但绝不可能杀一个军团，但游戏中经常出现一个太刀侠杀一堆弓箭手） 小兵AI非常蠢，缺乏操作性，胜利基本取决于双方兵种的养成强度，而非操作 特别缺统御值，一场游戏只能带很少的兵，很快就成光杆司令，变成垃圾时间 攻防战体验非常糟糕，攻守不应该是等人数公平对战，攻城人数应该比守方多五到十倍 守方获胜的方式是等时间耗尽，没法主动出击快速结束游戏 游戏开始时攻方要推攻城塔，守方要等攻方进来，开局充满了垃圾时间 战斗区域大多在城内巷战，而现实中攻破城门其实基本宣告守城失败，主要战斗应该是野战夺旗 城防和工事基本没有用，战斗的本质是战旗，敌我双方把兵放在一起，让他们互砍 没有感受到明显的兵种克制，就算有克制，起码要让玩家每种兵开局各解锁一套，战斗时可以随时切换，现在一次只能带一队，变成猜拳游戏，希望对方不使用克制自己的兵，不是我的兵不强，只是我开局首发错了 于是我打算从去年爆火的吸血鬼幸存者中吸取经验，做一个吸血鬼幸存者+战意的游戏 玩法 背景 你知道吗？拿破仑的法军都不带后勤的，敌人屯粮我屯枪，敌人就是我粮仓，去杀光烧光抢光吧，去征服整个大陆，你入关之后自有大儒辩经 玩家出生在一个大陆上，这个大陆有很多国家（城市）和城邦。玩家需要收割麦子（掠夺农民），去城邦雇佣军队，攻打城市，最后统一整个大陆吧 设计目标 体验一把中世纪掠夺者征服大陆，过足将军梦 玩家目标 收割麦子 —— 获得第一桶金 —— 去城邦购买军队 —— 控制军队攻打城市 —— 占领的城市会给玩家提供一次性的掠夺收入和持续的税收收入 —— 用收入去城邦买军队 —— 攻打其他城市 —— 统一整个大陆 —— 游戏结束 单局时长控制在二十分钟，玩家需要做的就是用鼠标左键控制主角移动，按按键指挥小兵 游戏开始 游戏开始时要选择地图和继承卡（如果没有可以不选择） 继承卡 类似于赛马娘 游戏结束时会进行结算，获得一张继承卡，如果游戏胜利会获得更多的继承属性 继承卡中有各种因子，因子有三种，红因子（某种兵战斗力提升），黄因子（某种兵购买折扣），蓝因子（某种固有技能） 因子的获取是概率的，取决于你这把的得分 比如你这把买了很多骑兵，那么游戏结束就更有概率获得骑兵黄因子 如果这把骑兵杀了很多敌人，那么容易获得骑兵红因子 如果骑兵强化了很多次（去城邦买强化），那么容易得到骑兵蓝因子 主角移动 TopDown俯视角游戏，主角始终保持在屏幕中间，通过鼠标左键点击移动 收割麦子 主角走到麦子上即可获取麦子（就像捡地上的金币），麦子会转化为金钱（虚拟物品，在左上角显示） 控兵 主角不能直接控制兵，只能给兵发命令（不能像RTS那样框选，只能发指令，大部分情况都是自动战斗，以降低操作复杂度） 主角最多有控制四队兵，用1234切换，右侧会有小兵的状态（类似于原神） 兵有四种，铁剑、弓箭手、枪兵、骑兵 兵有三种状态，自由攻击、跟随攻击、驻扎攻击 士兵在驻扎期间可以缓慢恢复生命，提高向前的防御力，但不能移动 驻扎有形状（类似于战意中的X键） 骑兵可以像笔一样画移动方向（有些像红警的路径） 城邦 类似于吸血鬼幸存者中的箱子，玩家在靠近城邦后会弹出三张卡，支付金钱可以获得卡片收益，比如获得某个军队，升级某个军队 敌方城市 初版认为城市的相同的 当玩家靠近敌方城市时，敌方城市会开始刷兵，刷兵强度与玩家已经占领的城市数量有关 城市有一层塔皮，可以被攻击打掉，打光后成为我方城市，第一次占领可以获得一笔掠夺收益 敌方城市会射箭（类似于moba游戏的防御塔） 我方城市 城市有塔皮，可以自动射箭攻击 塔皮被打光后会变回敌方城市 城市会为主角提供税金 敌兵 敌兵会攻击我方的小兵和主角 杀死敌兵后会获得金币 主角死亡 主角死亡游戏失败，开下一把吧 小兵 铁剑 均衡的小兵，最便宜 主打自由攻击 狂暴：提高攻击速度和移动速度 枪兵 相较于铁剑，攻击距离更长，攻击频率更慢，更贵 克制枪兵 驻扎时正面防御力提高，有圆形驻扎、方形驻扎、长条形驻扎 齐攻：将所有小兵的攻击CD清空，向前挥出一个次长而有力的攻击（相较于普攻） 骑士 最贵 可以画线指挥路径 克制铁剑，被枪兵克制 弓箭手 比铁剑贵 发射箭矢攻击最近的敌人 驻扎攻击时提高攻速","categories":[{"name":"game","slug":"game","permalink":"https://reubensun.com/categories/game/"}],"tags":[]},{"title":"编译与链接","slug":"program/编译与链接","date":"2023-12-27T17:49:25.000Z","updated":"2025-03-18T07:16:42.969Z","comments":true,"path":"program/编译与链接/","permalink":"https://reubensun.com/program/%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/","excerpt":"","text":"C/C++编译与链接 《程序员的自我修养：链接、装载与库》阅读笔记 编译 编译可以被分为四个步骤： 预编译（Prepressing） 编译（Compilation） 汇编（Assembly） 链接（Linking） 预编译 gcc -E hello.c -o hello.i cpp hello.c &gt; hello.i 移除并展开所有#define 处理所有条件预编译指令，如#ifdef 递归处理#include指令，将被包含的文件拷贝到该指令位置 删除所有的注释 添加行号和文件名标识，便于产生调试和报错的行号信息 保留#pragma指令 编译 gcc -S hello.i -o hello.s 词法分析：扫描器使用有限状态机将源代码的字符切分为一系列记号（Token） 语法分析：分析记号，得到语法树，树的节点是表达式 语义分析：分析所有的静态语义，为表达式标注类型 中间语言生成：优化一些代码，比如2+6优化成8 三地址码与P代码 目标代码的生成与优化 GCC可以将预编译和编译合成一个步骤 gcc -S hello.c -o hello.s cc1 hello.c 汇编 gcc -c hello.s -o hello.o as hello.s -o hello.o 链接 ld -static xxxx hello.o -xxxx 链接的本质是替换指令中（对函数和变量）的地址引用 地址和空间分配 符号决议 重定位 main.c文件调用了func.c文件中的函数foo()，所以需要知道foo()的确切地址。但C++不同模块是单独编译的，因此编译main.c时不知道foo()的地址 于是编译器先将foo()的地址搁置，在链接的时候再逐个修正，填入foo()真实的地址 这个地址修复的过程也叫做重定位（Relocation），每一个需要修正的地方叫重定位入口（Relocation Entry） 目标文件 编译器编译后生成的文件是目标文件（.obj和.o），结构跟可执行文件相同，只是还未链接 可执行文件、目标文件、动态库、静态库均采用相同的存储格式，在Windows下使用PE-COFF格式存储，在Linux下使用ELF格式存储 Windows：PE-COFF（Probable Executable-Common File Format） Linux：ELF（Executable Linkable Format） 目标文件格式 由四个部分组成： 文件头（File Header）：文件可否执行、是静态链接还是动态链接、链接入口、目标硬件、目标操作系统、段表（Section Table） 段表描述了文件中各个段的偏移位置和属性，用于找到代码段、数据段 代码段（.text section）：编译得到的执行语句 数据段（.data section）：已初始化的静态/全局变量 .bss section：为未初始化的静态/全局变量预留位置，没有内容 .rodata section：只读数据，比如用const修饰的变量、字符串常量 int global_inited_var = 84;int global_uninit_var;void func(int var)&#123; printf(&quot;%d\\n&quot;, var);&#125;int main(void)&#123; static int static_inited_var = 85; static int static_uninit_var; int local_inited_var = 1; int loacl_uninit_var; func(static_inited_var + static_uninit_var + local_inited_var + loacl_uninit_var); return 0;&#125; objdump -h hello.o 查看目标文件的结构 hello.o: file format elf64-x86-64Sections:Idx Name Size VMA LMA File off Algn 0 .text 00000064 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000008 0000000000000000 0000000000000000 000000a4 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000008 0000000000000000 0000000000000000 000000ac 2**2 ALLOC 3 .rodata 00000004 0000000000000000 0000000000000000 000000ac 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .comment 0000002c 0000000000000000 0000000000000000 000000b0 2**0 CONTENTS, READONLY 5 .note.GNU-stack 00000000 0000000000000000 0000000000000000 000000dc 2**0 CONTENTS, READONLY 6 .note.gnu.property 00000020 0000000000000000 0000000000000000 000000e0 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 7 .eh_frame 00000058 0000000000000000 0000000000000000 00000100 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA objdump -s -d hello.o 将段内容以十六进制的形式打印出来，并将指令段反汇编 hello.o: file format elf64-x86-64Contents of section .text: 0000 f30f1efa 554889e5 4883ec10 897dfc8b ....UH..H....&#125;.. 0010 45fc89c6 488d0500 00000048 89c7b800 E...H......H.... 0020 000000e8 00000000 90c9c3f3 0f1efa55 ...............U 0030 4889e548 83ec10c7 45f80100 00008b15 H..H....E....... 0040 00000000 8b050000 000001c2 8b45f801 .............E.. 0050 c28b45fc 01d089c7 e8000000 00b80000 ..E............. 0060 0000c9c3 ....Contents of section .data: 0000 54000000 55000000 T...U...Contents of section .rodata: 0000 25640a00 %d..Contents of section .comment: 0000 00474343 3a202855 62756e74 75203131 .GCC: (Ubuntu 11 0010 2e332e30 2d317562 756e7475 317e3232 .3.0-1ubuntu1~22 0020 2e303429 2031312e 332e3000 .04) 11.3.0.Contents of section .note.gnu.property: 0000 04000000 10000000 05000000 474e5500 ............GNU. 0010 020000c0 04000000 03000000 00000000 ................Contents of section .eh_frame: 0000 14000000 00000000 017a5200 01781001 .........zR..x.. 0010 1b0c0708 90010000 1c000000 1c000000 ................ 0020 00000000 2b000000 00450e10 8602430d ....+....E....C. 0030 06620c07 08000000 1c000000 3c000000 .b..........&lt;... 0040 00000000 39000000 00450e10 8602430d ....9....E....C. 0050 06700c07 08000000 .p......Disassembly of section .text:0000000000000000 &lt;func&gt;: 0: f3 0f 1e fa endbr64 4: 55 push %rbp 5: 48 89 e5 mov %rsp,%rbp 8: 48 83 ec 10 sub $0x10,%rsp c: 89 7d fc mov %edi,-0x4(%rbp) f: 8b 45 fc mov -0x4(%rbp),%eax 12: 89 c6 mov %eax,%esi 14: 48 8d 05 00 00 00 00 lea 0x0(%rip),%rax # 1b &lt;func+0x1b&gt; 1b: 48 89 c7 mov %rax,%rdi 1e: b8 00 00 00 00 mov $0x0,%eax 23: e8 00 00 00 00 call 28 &lt;func+0x28&gt; 28: 90 nop 29: c9 leave 2a: c3 ret000000000000002b &lt;main&gt;: 2b: f3 0f 1e fa endbr64 2f: 55 push %rbp 30: 48 89 e5 mov %rsp,%rbp 33: 48 83 ec 10 sub $0x10,%rsp 37: c7 45 f8 01 00 00 00 movl $0x1,-0x8(%rbp) 3e: 8b 15 00 00 00 00 mov 0x0(%rip),%edx # 44 &lt;main+0x19&gt; 44: 8b 05 00 00 00 00 mov 0x0(%rip),%eax # 4a &lt;main+0x1f&gt; 4a: 01 c2 add %eax,%edx 4c: 8b 45 f8 mov -0x8(%rbp),%eax 4f: 01 c2 add %eax,%edx 51: 8b 45 fc mov -0x4(%rbp),%eax 54: 01 d0 add %edx,%eax 56: 89 c7 mov %eax,%edi 58: e8 00 00 00 00 call 5d &lt;main+0x32&gt; 5d: b8 00 00 00 00 mov $0x0,%eax 62: c9 leave 63: c3 ret .data中54000000转化到十进制是84，55000000是85 大小端 注意十六进制的读法，0x54是最低位，后面三个0x00是更高的位，这种低位在前高位在后的字节序是小端序，有点反人类 为什么要区分代码块和数据块呢？ 程序被装载后，数据区域是可读写的，而代码区域是只读的，将段进行分离，可以防止潜在的错误修改 数据集中存储，可以利用局部性原理提高缓存利用率 当系统同时运行多个同一文件时，可以共享只读的指令和数据，能大幅节省空间 readelf -h hello.o 查看elf文件头的详细信息 ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&#x27;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x0 Start of program headers: 0 (bytes into file) Start of section headers: 1048 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 14 Section header string table index: 13 魔术（Magic）用于区分ELF文件类型（与Windows里用后缀名区分不同） 符号 符号表 如果目标文件B用到了目标文件A的函数foo()，我们称目标文件A定义（Define）了函数foo()，目标文件B引用（Reference）了函数foo() 我们称函数、变量为符号（Symbol），他们的名字被称为符号名（Symbol Name），符号名独一无二 编译过程中每个目标文件都有一个符号表，每个符号能找到一个对应的符号值，对于变量和函数，符号值就是他们的地址 符号值的类型有： 定义在本文件内的全局符号，比如global_inited_var，func 定义在其他文件内，但是被本文件引用的全局符号，叫外部符号（External Symbol），比如printf 段名，是段的起始地址 局部符号，比如static_inited_var 行号 readelf -s hello.o Name Mangling 为了防止符号名冲突，C语言会加上命名空间等方法修饰符号，C++会做符号改编（Name Mangling） 函数签名：由函数的名称、参数数量与类型、所在的类、所在的命名空间等组成 在C++进行编译链接时，会使用函数签名生成一个修饰后名称，使用这个修饰后名称作为符号名 C++允许使用函数重载，但是重载函数的参数不能完全相同 C++允许局部变量和全局变量重名，因为他们修饰后是两个不同的符号 C++的Name Mangling规则取决于编译器版本，没有统一和公开 extern “C” C++的符号十分复杂，C的符号兼容性会更好，于是我们可以使用extern &quot;C&quot;声明一个C符号，里面的符号不会被Name Mangling #ifdef __cplusplusextern &quot;C&quot; &#123;#endif int func(int); int var;#ifdef __cplusplus&#125;#endif 强弱符号 强符号：C++默认函数和初始化的全局变量为强符号，如果多个目标文件拥有相同名字的强符号，链接时会报符号重定义的错误 弱符号：C++未初始化的全局变量是弱符号 extern int ext; // 不是强、弱符号，因为是外部文件定义的变量int weak_var; // 弱符号，未初始化的全局变量int strong_var = 1; // 强符号，初始化的全局变量__attribute__((weak)) weak_var2; // 弱符号int main() // main是强符号，函数&#123; return 0;&#125; 规则： 不允许强符号重定义 弱符号会被强符号覆盖 若一个符号在所有文件中都是弱符号，则选择体积最大的符号去链接 强弱引用 强引用：在链接时，如果没有找到强引用的符号，会报符号未定义的错误 弱引用：在链接时，若符号未定义，会给一个默认值0 弱符号、弱引用对于库来说十分有用，可以被用户自己定义的强符号所覆盖，也可以使得程序功能被剪裁组合 静态链接 链接会将多个目标文件加工成一个可执行文件 段合并 相似段合并：将所有具有相同性质的段合并在一起，比如多个文件的.data段合在一个大的.data段中 两步链接 空间和地址分配 符号解析和重定位 C++链接步骤 重复代码消除，一个模板可能在多个编译单元中被实例化，且实例化成相同的代码，将这些重复代码消除可以提高缓存利用率和节约空间 函数级别链接（选择性开启）：每一个函数都单独存储在一个段中，链接时按需添加到目标文件，可以减少包体，但是会降低编译链接速度 程序入口 Linux下程序的入口是_start，这是Glibc库的一部分，会进行程序的初始化，比如全局函数的创建，然后再去main函数执行 ELF有.init和.fini两个段，在这两个段中的代码会在mian前后执行 ABI 两个代码想要链接，需要使用相同的目标文件格式。我们将符号修饰、变量内存布局、函数调用方法等和二进制可执行文件兼容性相关的内容称为ABI（Application Binary Interface） 对于C语言，通过下列内容判断二进制兼容性： 内置类型（int、char）的大小、字节序、对齐方式 组合类型（struct、array、union）的存储方式和内存分布 外部符号的解析方式，比如外部的func被解析为_func 函数调用方式，比如参数入栈顺序，返回值如何保持 堆栈分布方式 寄存器使用约定 对于C++还额外有： 继承相关的内存分布 指向成员函数的指针的内存分布，如何通过成员函数指针调用成员函数，如何传递this指针 如何调用虚函数，虚表的内容及分布 模板如何实例化 Name Mangling 全局对象的构造与析构 异常 RTTI inline C++的ABI不稳定，于是DLL建议使用C风格 装载 可执行文件要装载到内存中才能被CPU执行 动态装入：许多情况下程序所需要的内存远超物理内存，为此我们会将一部分数据存储在磁盘里，内存中只保留最常用的部分。目前最常用的方法是页映射 进程的创建 创建一个独立的虚拟内存空间 分配页目录 虚拟内存区域（VMA） 段（Segment） 读取可执行文件的头，建立虚拟空间和可执行文件的映射关系 当程序发生缺页时，需要知道当前所需的页在可执行文件的哪一位置，这个位置信息存储在映射关系中 这是装载最核心的步骤，于是很多可执行文件也叫映像文件（Image） CPU指令寄存器设置为可执行文件的入口，程序运行 页错误 当CPU开始执行一段指令时，发现所在地址的页面是一个空页面，这就是页错误 此时操作系统会去读映射关系，找到当前页所在的VMA，计算出该页在可执行文件的位置 去物理内存中读这个页，并建立虚拟页和物理页的映射关系 回到先前的地址，继续执行指令 VMA VMA除了可以映射段，还会映射堆（Stack）和栈（Heap） VMA类型 权限 能否执行 代码VMA 只读 可执行 数据VMA 读写 可执行 堆VMA 读写 可执行 栈VMA 读写 不可执行 段地址对齐 x86处理器默认页的大小为4096字节，于是物理地址和虚拟地址进行映射时，虚拟内存空间的大小应该为4096字节的整数倍 动态链接 静态链接浪费内存空间、磁盘空间、难以更新 动态链接将链接推迟到了运行（装载），能够实现库的复用，减少包体、提高缓存命中率 动态链接升级模块时，理论上只需要重新编译、替换动态库的模块，可以实现插件系统 Linux下动态库是动态共享对象（DSO），以.so结尾 Windows下动态库是动态链接库（DLL），以.dll结尾","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"map","slug":"program/map","date":"2023-12-13T15:41:25.000Z","updated":"2025-03-18T07:16:48.437Z","comments":true,"path":"program/map/","permalink":"https://reubensun.com/program/map/","excerpt":"","text":"map 突然发现一个华科大佬的博客，学习一波 map是一种映射结构，能够存取键值对（键是唯一的） map通常有两种实现方式：哈希表（std::unordered_map）、红黑树（std::map） 哈希表 哈希表的查找删除均为O(1) 哈希表是一种空间换时间的算法，现在我们要存储一组键值对，假设键的范围是0~99，那么我们就开辟一个大小为100的数组，数组中存储了指向值的指针，于是我们就可以通过Key去数组中找指针，再找到值 value = a[key]; 不过开辟大小为100的数组过于昂贵了，只开辟大小为10的数组，Key去找值时先取模，再去数组中找指针 value = a[key%10]; 不过这样也带来了一个问题，我们无法区分key==21和key==31，这种情况我们称之为哈希冲突，我们称21和31为同义词 解决哈希冲突的方式有： 开放地址法 拉链法 拉链法 Key取模后去数组中找指针，这个指针是一个链表的头，遍历链表，找到对应Key的value 这种方法非同义词间不会影响 point = a[key%10];while(point != nullptr)&#123; if(point-&gt;key != key) &#123; point = point-&gt;next; &#125; else &#123; break; &#125;&#125;value = point-&gt;value; 红黑树 红黑树的查找删除为O(logN)，但是空间效率更高 红黑树是一种自平衡的二叉搜索树，每个节点是黑色或红色 二叉搜索树 二叉搜索树（BST）：排序二叉树，任意一个根节点，其左子树Key均小于根，其右子树Key均大于根 BST的操作复杂度取决于树的高度，但某些情况下BST会退化为一条链 平衡二叉树 平衡二叉树（AVL）：左右子树的高度差不能大于1，操作过程中树一旦不稳定，就会进行旋转，以重新恢复平衡 红黑树 红黑树左右子树高度差不能超过一倍 所有null节点都认为是黑色。 一个红节点不能有红色孩子，即红色节点之间不能相邻。 红黑树中的节点到其任意叶子节点路径上的黑节点个数相同。 新插入的节点都是红色，在平衡过程中可能变色。 红黑树比平衡二叉树更容易保持平衡，于是效率更高 参考 辜飞俊的博客","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"BCN编码","slug":"graphics/BCN编码","date":"2023-11-29T15:39:25.000Z","updated":"2025-03-18T07:16:48.445Z","comments":true,"path":"graphics/BCN编码/","permalink":"https://reubensun.com/graphics/BCN%E7%BC%96%E7%A0%81/","excerpt":"","text":"BCN编码 之前在知乎看到有美术在吵PNG和TGA哪一个更好用，但实际上引擎里使用的贴图是需要经过编码处理为GPU友好的资源格式，比如Windows上常用BCN编码，iOS常用ASTC编码 BCN原理 By storing some colors in their original size, and other colors using an encoding scheme, you can dramatically reduce the amount of memory required to store the image BCN是指一系列使用Block Compression技术的格式，比如BC3、BC7，在过去也被称为DXT 4x4的未压缩贴图在内存中会被排成一个长度为16的数组，如果一个像素要1bytes，那么未压缩的容量为16bytes BCN Format 原始数据 编码精度需求 (单位bits) 推荐编码格式 每4x4像素大小 RGBA 5 : 6 : 5 : 0 或 5 : 6 : 5 : 1 BC1 8 RGBA 5 : 6 : 5 : 4 BC2 16 RGBA 5 : 6 : 5 : 8 BC3 16 单通道灰度 8 BC4 8 双通道 8 : 8 BC5 16 RGB HDR 16 : 16 : 16 BC6H 16 RGB(A) 4 : 4 : 4 : (0~8) 或 7 : 7 : 7 : (0~8) BC7 16 DX9：BC1~3 DX10：BC4~5 DX11：BC7，BC6H BC1 下面这些图左边这个n bytes是指每一行是n bytes 4x4的颜色被存储为两个color和16个index，每个index仅有两个比特位 color_0是这16个颜色中的最小值，color_1是最大值，我们先用这两个颜色生成两个中间值 color_2 = 2/3*color_0 + 1/3*color_1color_3 = 1/3*color_0 + 2/3*color_1 每个index只有两个比特位，只能存储四个信息，于是正好就可以存下这四个颜色的索引，对于每个像素，我们找到和他颜色最接近的color_x，并将他的index改为x color_0 = 00color_1 = 01color_2 = 10color_3 = 11 可以看出BC1的误差是相当大的，这个4x4个像素最后只有四种颜色 BC2 BC2的RGB通道算法和BC1完全一致，然后为每一个像素加一个Alpha通道，也就是说，BC2的Alpha是完全没有被压缩的 原理和BC1相同，都是用color_0和color_1生成四个颜色，每个index有两个位，存最相近的颜色的索引。唯一不同的是，BC2专门为每一个像素提供了一个 4位（0.5bytes）的Alpha通道 BC3 BC2是完全不做Alpha的压缩，于是在BC3开始对其进行压缩，体现了技术的进步？ BC3的RGB与BC1完全相同，Alpha使用类似思想进行压缩，将16个Alpha转化为两个alpha_x和16个index，两个alpha_x会插值出Alpha Table，16个像素各自去找最接近的Alpha，index记录他们的位数 为了精度，Alpha的位数是三个比特位，最多能表示八种Alpha，也就是说这16个像素最多会被分成八种Alpha alpha_0和alpha_1的大小对比提供了两个模式，使用第二个模式时可以直接得到0和255两个极值，而其他颜色还是在color间插值，效果会比所有颜色都直接在0和255两个极值间插8份更好，适用于颜色中存在极值的情况 if( alpha_0 &gt; alpha_1 )&#123; // 6 interpolated alpha values. alpha_2 = 6/7*alpha_0 + 1/7*alpha_1; // bit code 010 alpha_3 = 5/7*alpha_0 + 2/7*alpha_1; // bit code 011 alpha_4 = 4/7*alpha_0 + 3/7*alpha_1; // bit code 100 alpha_5 = 3/7*alpha_0 + 4/7*alpha_1; // bit code 101 alpha_6 = 2/7*alpha_0 + 5/7*alpha_1; // bit code 110 alpha_7 = 1/7*alpha_0 + 6/7*alpha_1; // bit code 111&#125;else&#123; // 4 interpolated alpha values. alpha_2 = 4/5*alpha_0 + 1/5*alpha_1; // bit code 010 alpha_3 = 3/5*alpha_0 + 2/5*alpha_1; // bit code 011 alpha_4 = 2/5*alpha_0 + 3/5*alpha_1; // bit code 100 alpha_5 = 1/5*alpha_0 + 4/5*alpha_1; // bit code 101 alpha_6 = 0; // bit code 110 alpha_7 = 255; // bit code 111&#125; BC4 BC4极少使用 与BC1那种将4x4的像素转化为四种颜色不同，BC4是在两个颜色间做线性插值，red_0和red_1是最大最小颜色，像素数据转化为一个权重值（是一个0到1的float），使用这个权重值对red_0和red_1做线性插值即可还原颜色 不过三个比特位存一个0~1的浮点，精度其实很也很差吧，和离散的比没啥区别？ BC4_UNORM和BC4_SNORM仍然是使用BC3的离散Table算法 BC5 BC4的进阶版，简单来说就是将两个BC4拼在了一起 BC5_UNORM和BC5_SNORM也就是把对应的BC4拼起来 法线贴图 值得一提的是，BC5常用于压缩法线贴图，因为法线贴图有两个性质 法线是归一化的$z=\\pm\\sqrt{1-x^2-y^2}$ 法线各通道间是独立的 BC1的方案将RGB三个通道进行杂糅，整体混合，这对于法线贴图来说是不可接受的，梯度太小，精度太差了，使用BC5存法线的两个通道，使用时再还原第三个通道，这些效果会更好 承上启下 DX11提供了两个新的编码格式BC6H和BC7，再研究他们之前，我们先细数BC1压缩算法的问题吧 信道不均，这很好理解，RGB通道分别被分了5 : 6 : 5位，这会导致三个通道全取最大值时会更偏绿（相较于三个通道相同尺寸） 精度太低，16个像素只能被转化位4种不同的颜色 三个通道耦合，且只使用两个颜色进行插值，这是一个线而非三角形 BC7 核心思想 存多个color，两个index 使用预计算的partition sets（调色盘） 如果16个方块使用两个颜色涂抹，那么一共只会有$2^{16}$个情况，我们将这些情况全部离线存储在本地，并称之为调色盘（partition sets），使用一个索引即可得到对应的调色盘，还原出当前情况。 事实上由于颜色是存在连续性的，于是并不会出现这么多情况，于是我们可以大幅简化，使得几百种调色盘就足够使用。 更进一步，我们可以在调色盘种类和颜色数量间做平衡，使用更多种类的颜色和更少的调色盘种类，得到更丰富的模式 BC7不同模式下总位数是确定的，于是color占的位数多了，调色盘占的位数就会变少 BC7有很多模式（mode），我们可以为每块（4x4）选择一种模式，模式存储在BC7的开头（上图00001和1） 在不同的模式下，color数量和精度会改变，color越少越低精度，调色盘的选择就越多，反之color数据越多，调色盘选择就越少 BC1是对两个color做个插值得到4个或者8个颜色，而BC7不做这个插值，需要多少颜色就存多少颜色，然后根据剩余的位数选择调色盘即可 ![partition sets](/images/partition sets.jpg) 能看出下图上面一排只存了两个颜色，但调色盘变化更多样，下面一排存了三个颜色，调色盘变化略显单调 BC6H 干翻了RGBM，是BCN中唯一一个支持HDR的格式 插值算法与BC7相同，用无符号整数来表示浮点数，将16位的数据的Sign位移除，加到Fraction位上，以提高float范围和精度 DDS 注意区分贴图Compress和zlib、lz4压缩 使用BCN编码格式的文件在Windows操作系统下后缀为.dds DDS文件：DDS Header + DX10 Header + Mip0 raw data + Mip1 raw data + … BCN是一种GPU友好型的数据格式，DDS文件大小仅与贴图大小、Mipmap数量、像素格式有关，一张1024x1024一级Mipmap一个像素4 bytes的贴图，无论其质量如何，其大小是确定的，都是1KB（Header） + 1024KB 尽管DDS比TGA小很多，但还是有进一步的压缩空间，UE使用Oodle进行BCN编码，通过设置RDO来影响数据的紧凑程度，经由lz4二压可以再降低10%~40%的包体大小 DDS Header struct PixelFormat&#123; uint32_t size; uint32_t flags; uint32_t fourCC; uint32_t RGBBitCount; uint32_t RBitMask; uint32_t GBitMask; uint32_t BBitMask; uint32_t ABitMask;&#125;;struct DDSHeader&#123; uint32_t Magic; // Must be DDS_MAGIC uint32_t size; uint32_t flags; uint32_t height; uint32_t width; uint32_t pitchOrLinearSize; uint32_t depth; uint32_t num_mips; uint32_t reserved1[11]; PixelFormat ddspf; uint32_t caps; uint32_t caps2; uint32_t caps3; uint32_t caps4; uint32_t reserved2;&#125;; DX10 Header 在DX9中BC叫DXT，DX10以后才改为BC struct DX10Header&#123; uint32_t dxgi_format; uint32_t resource_dimension; uint32_t misc_flag; // see D3D11_RESOURCE_MISC_FLAG uint32_t array_size; uint32_t misc_flag2;&#125;; dxgi format dxgi_format：DirectX Graphics Infrastructure，格式为DXGI_FORMAT_&#123;编码类型&#125;_&#123;规范类型&#125;，比如DXGI_FORMAT_BC1_UNORM、DXGI_FORMAT_R32_FLOAT 规范格式有： UNORM：Unsigned Normalized，无符号归一化 SNORM：Signed Normalized，有符号归一化 FLOAT：浮点数，动态范围更大，但储存空间更大 TYPELESS：没有具体的规范类型，用于运行时确定格式 UINT：无符号整数（不归一化） SINT：有符号整数（不归一化） BCN Compress 常见的BCN压缩工具有Texconv、NVTT、Oodle 这里面我感觉NVTT是优雅最方便的，很适合嵌入引擎或者小项目使用 Texconv有很浓厚的微软风格。。。 Oodle是商业软件，编码速度极慢，而且没有内置的Mipmap和贴图IO工具，他只会处理raw block data，说实话挺不方便的，而且网上资料特别少，用过的人也因为版权不敢去分享，传Github还会被删库，但是Oodle生成的dds二压后包体特别小，正式项目还是建议用Oodle 下面是NVTT读TGA生成BC7格式DDS的样例代码，可以说非常地干净清晰 #include &lt;nvtt.h&gt;int main() &#123; std::string raw_tga_path = &quot;D:\\\\art\\\\raw.tga&quot;; std::string output_dds_path = &quot;D:\\\\art\\\\out\\\\nvtt_out.dds&quot;; int mipmap_count = 3; nvtt::Surface image; image.load(raw_tga_path.c_str()); nvtt::Context context(true); nvtt::CompressionOptions compression_options; compression_options.setFormat(nvtt::Format_BC7); nvtt::OutputOptions output_options; output_options.setFileName(output_dds_path.c_str()); if (!context.outputHeader(image, mipmap_count, compression_options, output_options)) &#123; std::cerr &lt;&lt; &quot;Writing the DDS header failed!&quot;; return 1; &#125; // Compress and write the compressed data. for (int mipmap_index = 0; mipmap_index &lt; mipmap_count; mipmap_index++) &#123; if (!context.compress(image, 0 , mipmap_index, compression_options, output_options)) &#123; std::cerr &lt;&lt; &quot;Compressing and writing the DDS file failed!&quot;; return 1; &#125; if(mipmap_index == mipmap_count - 1) break; image.toLinearFromSrgb(); image.premultiplyAlpha(); image.buildNextMipmap(nvtt::MipmapFilter_Triangle); image.demultiplyAlpha(); image.toSrgb(); &#125;&#125; 参考 微软开源的贴图工具，包含Texconv 微软关于BCN的介绍 英伟达开源的贴图工具NVTT UE使用的商业贴图工具Oodle官网 BCN算法","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Texture","slug":"Texture","permalink":"https://reubensun.com/tags/Texture/"}]},{"title":"软光栅化遮挡剔除","slug":"graphics/软光栅化遮挡剔除","date":"2023-11-15T17:30:25.000Z","updated":"2025-03-18T07:16:42.962Z","comments":true,"path":"graphics/软光栅化遮挡剔除/","permalink":"https://reubensun.com/graphics/%E8%BD%AF%E5%85%89%E6%A0%85%E5%8C%96%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/","excerpt":"","text":"软光栅化遮挡剔除 DrawCall和着色十分昂贵，于是我们希望可以剔除掉那些看不见的物体，以提高性能。而简单的视锥剔除并不能剃干净场景的物体，于是需要遮挡剔除。 这篇文章是一个CPU端的遮挡剔除，需要离线制作Occlusion Mesh，但不依赖各种GPU Driven的技术 Intel认为，CPU端使用GPU生成的Depth buffer做剔除，如果你不提前开一个Depth Only Pass画深度，那就要用上一帧的深度，一般而言，根据连续性，用上一帧的深度也没什么问题。但实际上CPU和GPU的Tick频率可能不同，两者间可能会差好几帧，于是用复用上一帧的深度不靠谱。 那什么靠谱呢？在CPU端用软光栅画一个Depth buffer，保证一定是当帧剔除。 软光栅生成深度图 Tile Base的软光栅 若三角形横跨多个Tile，则在每个Tile组中都加入这个三角形 Tile间互相独立，并行软光栅 对于三角形内的像素，通过重心公式插值出深度 如果软光栅得到的深度比深度缓冲更接近观察者，写深度 剔除 1. 近裁剪平面裁剪 若近裁剪平面设为1，顶点的齐次坐标为w，若$0 &lt; w &lt; 1$，则裁剪通过 2. 视锥剔除 3. 深度测试 若一个物体、AABB有像素可见，那么整体都可见 如一个物体、AABB完全被遮挡，那就继续检测这个物体所有的像素，直到发现这个物体所有像素均被遮挡 优化 Tile Base 视锥剔除 SSE intrinsics TBB并行 遮挡物/被遮挡物大小阈值 参考 Intel Software Occlusion Culling","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Culling","slug":"Culling","permalink":"https://reubensun.com/tags/Culling/"}]},{"title":"grep搜索lib文件","slug":"program/grep","date":"2023-11-09T10:01:25.000Z","updated":"2025-03-18T07:16:42.968Z","comments":true,"path":"program/grep/","permalink":"https://reubensun.com/program/grep/","excerpt":"","text":"grep搜索lib grep 前几天写代码发现链接不到某个函数，同事说我肯定少链接了一个.lib文件，然我却不知道少链接了谁 同事交给我一个小技巧，lib文件本质是一个代码压缩包，是可以对里面的内容进行搜索的，在Linux（WSL）中进入存放.lib的库，输入命令 grep -r &lt;函数名&gt; . 就会匹配vkCmdBeginDebugUtilsLabelEXT这个函数在哪一个.lib中出现过 最后的输出是 grep: ./&lt;库名&gt;.lib: binary file matches 所以我少链接了这个.lib dumpbin 然后大佬说我在windows下打开一个.lib其实用VS自带的dumpbin更好 Visual Studio – 工具 – 命令行 – 开发者Powershell dumpbin /SYMBOLS .\\imgui.lib | findstr.exe &quot;ImGui_ImplVulkan_CreatePipeline&quot; 也可以输出到某个文件里 dumpbin /SYMBOLS .\\imgui.lib | findstr.exe &quot;ImGui_ImplVulkan_CreatePipeline&quot; &gt; E:\\a.txt","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://reubensun.com/tags/Linux/"},{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"雨雪图","slug":"graphics/雨雪图","date":"2023-11-06T16:29:25.000Z","updated":"2025-03-18T07:16:42.962Z","comments":true,"path":"graphics/雨雪图/","permalink":"https://reubensun.com/graphics/%E9%9B%A8%E9%9B%AA%E5%9B%BE/","excerpt":"","text":"雨雪图 现在游戏大多会有天气系统，尤其是雨天雪天 在雨天和雪天静态物上面要覆盖一层雪，可以参考Shadow Map的方法，从顶部向下绘制一张深度图（一般只收集静态物），运行时比较深度即可判断像素是否在最上面 值得注意的是玻璃等半透明物体按不透明的方式绘制深度图 参考 Water drop","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Effect","slug":"Effect","permalink":"https://reubensun.com/tags/Effect/"}]},{"title":"C++获取CPU型号","slug":"program/获取CPU型号","date":"2023-11-06T12:01:25.000Z","updated":"2025-03-18T07:16:42.969Z","comments":true,"path":"program/获取CPU型号/","permalink":"https://reubensun.com/program/%E8%8E%B7%E5%8F%96CPU%E5%9E%8B%E5%8F%B7/","excerpt":"","text":"C++获取CPU型号 不同CPU的指令集有所差异，尤其是在使用SIMD之类的feature时要十分注意，以MSVC获取CPU型号为例 核心是使用指令__cpuid，其实你也可以__asm &#123;&#125;自己写汇编 #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;intrin.h&gt;#include &lt;array&gt;#include &lt;vector&gt;int main() &#123; std::array&lt;int, 4&gt; regs; std::vector&lt;std::array&lt;int, 4&gt;&gt; data; std::string vendor_string; __cpuid(regs.data(), 0); for (int i = 0; i &lt;= regs[0]; ++i) &#123; __cpuidex(regs.data(), i, 0); data.push_back(regs); &#125; char vendor[0x20]; memset(vendor, 0, sizeof(vendor)); *reinterpret_cast&lt;int*&gt;(vendor) = data[0][1]; *reinterpret_cast&lt;int*&gt;(vendor + 4) = data[0][3]; *reinterpret_cast&lt;int*&gt;(vendor + 8) = data[0][2]; vendor_string = vendor; if (vendor_string == &quot;GenuineIntel&quot;) &#123; std::cout &lt;&lt; &quot;Intel&quot;; &#125; else if (vendor_string == &quot;AuthenticAMD&quot;) &#123; std::cout &lt;&lt; &quot;AMD&quot;; &#125; return 0;&#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"Clustered Shading","slug":"graphics/ClusteredShading","date":"2023-11-04T21:50:25.000Z","updated":"2025-03-18T07:16:48.444Z","comments":true,"path":"graphics/ClusteredShading/","permalink":"https://reubensun.com/graphics/ClusteredShading/","excerpt":"","text":"Clustered Shading 《Clustered Deferred and Forward Shading》阅读笔记 Cluster：组，簇，一堆物体的群集，将一个个零散的小物体整合为一个Cluster，可以加速剔除 Cluster的思路跟TBS思路很像，也是将view进行切分，但是每一个Cluster拥有一个固定的三维边界（坐标和法线），于是解决了Tiles退化的问题 光照计算时需要遍历物体和灯光，Clustered Shading的目的是剔除灯光 Tile base Shading 在讲Cluster前，先介绍什么是Tile base shading。TBS使用屏幕坐标将view切分为一个个小Tiles，单独绘制每一个Tiles，渲染结束后将所有Tiles合并呈现到屏幕上（得到framebuffer） 每一个Tiles会维护最小和最大深度，这两个深度和Tiles的屏幕UV就会组成一个粒度比较大的BV（Bound Volume），用于粗粒度的视锥剔除。在绘制每一个Tiles时，我只关注这个Tiles内的物体、灯光，不关心场景整体的复杂度，可以少遍历很多物体 此外这个Tiles之间是互相独立的，于是你可以自由控制他们的绘制顺序，比如如果某个像素上有两个半透明物体重叠，那么可以并行计算两个半透明物体的绘制结果，在最后一步混合时再手动排序 优点 由于每次只需要绘制一个小Tiles，于是大幅减小的最大带宽（变得细水长流） Tiles足够小，我们可以将Tiles放到片上缓存中，只需要调整着色器而无需移动资源位置（无需在显存和内存间传递，尤其是移动端这种共用全局内存的GPU），更进一步减少了带宽 问题 Tiles的BV是不确定的，通过屏幕UV采样深度得到的第三维边界是粗粒度的，不确定的。在某些极端相机视角下，min和max可能会差距很大，而内部的深度其实不连续（也就是最前面有个物体，最后面有个物体，结果得到了一个巨大的BV） 在这种情况下，BV就退化为一个平面，大幅降低了剔除效率 相关技术 Run length encoding RLE（Run length encoding）是一种压缩算法，该算法依赖了数据的连续性，将一个一维的有重复值的数据进行压缩，能大幅减少数据量 此外当我们要对一个一维数组排序时，也可以将数组先做RLE，对压缩后的数据进行排序，排序结束后再展开 很多渲染技术都利用了数据的连续性，比如AA Virtual Shadow Maps VSMs是一张巨大的贴图（16k x16k），将这张巨大的贴图切成一个个小的Pages，仅当屏幕中有像素需要某个Pages时，才分配加载这个Pages 于是出现了一个问题，要如何判定这个Pages被使用呢？ Clustered Deferred Shading 核心目标是剔除掉无用灯光 使用传统算法绘制GBuffer 分配Cluster（求切分后每一个Cluster的坐标） 找到唯一Cluster 分配灯光 着色 分配Cluster 根据连续性，若一个物体被某个灯光影响，其相邻的物体大概率也会被这个灯光影响 Cluster的本质就是将靠在一起的东西合并，光照计算时以Cluster为单位，而非Mesh/三角形。也就是说将这一组Mesh/三角形原子化（quantize）了 空间划分的方法有： 世界坐标Grid切分 数量过大，在远处存在浪费 NDC空间按z均匀切分 NDC非线性，近处Cluster过细，远处过粗 View空间，按指数间隔切分深度 最后作者选择了View空间按指数间隔切分深度，根据屏幕Tiles坐标$(i,j)$和深度等级$k$，每一个Cluster将拥有坐标$(i,j,k)$，他们在z轴方向上的距离间隔为$h_k$ k是可以通过相机近平面、相机视角、该点深度和屏幕Tiles坐标求得 找到唯一Cluster 对每一个Tiles下的所有Cluster内物体进行排序 分配灯光 计算每一个Cluster受哪些光影响 在TBS中，我们可以直接遍历测试每一个Tiles和光源是否有覆盖，但这对于Cluster来说有些暴力了 每一帧根据Z值顺序，将相邻的灯光（相邻32个灯）的BV合并，构建BVH（bounding volume hierarchy） 使用深度优先算法做Cluster和灯光BV的相交测试 英伟达GPU对32叉树更友好，而且32叉树深度更小，可以减少分支数 这相较于Tiles Base有个好处是，当灯光特别特别多，均匀遍布在每一级深度中时，靠前的物体不需要再与靠后的灯光进行测试、着色（这是Tiles Base这种由最浅到最深构建的大BV无法做到的），能提升部分性能 着色 用传统方案做着色计算 作者的数据 我眼花了吗？作者对海量灯光的定义也太大了吧，这是12年的论文吧，同屏百万光源？手游项目同屏也就三四个点光吧 在灯光数量较少时（比如同屏灯光少于1024个？？？），性能不如Tiles Base 在灯光特别多时（比如同屏灯光1048576个！！！），性能显著强于Tiles Base 一点点想法 延迟渲染光照计算次数 = 屏幕像素数 x 灯光数量，为了进一步提高着色效率，我们要剔掉一部分灯光 利用连续性原理，若一个像素被某个灯光影响，那么这个像素相邻的像素也可能被灯光影响，于是我们将view切分为一个个恰当尺寸的Cluster，每个Cluster只做一次灯光可见性测试，Cluster内部都使用相同的灯光list 与Tiles Base比，Cluster不仅对屏幕空间进行切分，还对深度进行切分，这使得被切分的空间复杂度是稳定的，和视角无关 不过Cluster与灯光测试比Tiles Base复杂了，而且Cluster的数据量更多，于是作者又基于深度构建了灯光的BVH，加速两个BV的测试 不过我们引入了两个3D场景描述结构，还使用了更复杂的相交测试方法，结果灯光较少时性能还更差了。。。移动端这两年苹果才刚开始大力推TBDR，感觉还是Tiles Base更有性价比 参考 Tailor Your Apps for Apple GPUs and Tile-Based Deferred Rendering","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Render","slug":"Render","permalink":"https://reubensun.com/tags/Render/"}]},{"title":"视锥剔除","slug":"graphics/视锥剔除","date":"2023-11-03T10:46:25.000Z","updated":"2025-03-18T07:16:48.442Z","comments":true,"path":"graphics/视锥剔除/","permalink":"https://reubensun.com/graphics/%E8%A7%86%E9%94%A5%E5%89%94%E9%99%A4/","excerpt":"","text":"视锥剔除 《Optimized View Frustum Culling Algorithms for Bounding Boxes》阅读笔记 剔除的目的是减少要绘制不可见的物体，视锥剔除（View Frustum Culling，VFC）是使用一个平头四棱锥和场景中物体做可见性测试，实现快速剔除 为了加速视锥和场景物体的相交测试速度，我们会使用Bounding Volume（比如AABB、OBB、Sphere）来代替物体进行测试 视锥剔除可以并行计算，也可以使用BSP-trees加速 基础数学知识 点与面 已知一个面的法线（已经归一化）为$\\mathbf{n}$，沿着法线方向平移面，直到原点在面上，这个过程的移动距离为$d$ 已知一个点的坐标$\\mathbf{x}$，$\\mathbf{x}$同时也是从原点指向这个点的向量，点到移动后的平面的距离是$\\mathbf{n}\\cdot\\mathbf{x}$ 所以，如果一个点在移动前的面上，那么应该满足 $$ \\mathbf{n}\\cdot\\mathbf{x}+d=0 $$ 通过这个公式，我们就可以快速判断点是否在平面上 线与面 一条线是两个点，如果两个点带入$\\mathbf{n}\\cdot\\mathbf{x}+d$的符号是相反的，说明两个点在面的两侧，说明线与面相交 AABB与面 AABB是轴向包围盒，根据面的法线方向，就能知道AABB哪一个对角线轴最垂直于这个面，判读那这个对角线和面的关系，就能得到AABB和面的关系 我们还可以将这个对角线放在LUT里，加速之后几帧的相交检测（毕竟帧是连续的，我们可能会高频做相同面和对角线的相交检测） AABB视锥剔除 投影空间简单比较 还有一种和上述不同的方案，即将视锥和AABB转化到相机的透视投影空间，此时视锥变成一个立方体，于是就可以判断投影后的AABB和一个长方形视锥的相交关系，这个计算十分简单只需要算6次比较 if (cube1_max[0] &lt; cube2_min[0] or cube1_min[0] &gt; cube2_max[0] or cube1_max[1] &lt; cube2_min[1] or cube1_min[1] &gt; cube2_max[1] or cube1_max[2] &lt; cube2_min[2] or cube1_min[2] &gt; cube2_max[2]): return Falseelse: return True 但这个方法缺点也很明显：需要做一个投影计算（很费） 世界空间六个面替代视锥 我们可以将视锥是为六个平面，做六个平面和AABB的相交测试，若发现在AABB在视锥平面外，说明未相交，不可见 bool testVisible(AABB aabb, Camera camera)&#123; vec3 center = aabb.bound.center; vec3 halfSize = abs(aabb.bound.max - aabb.bound.min) * 0.5; for(auto&amp; plane : camera.frustumPlanes) &#123; SideResult side = testSide(plane, center, halfSize); if(side == SideResult::OutSide) &#123; return false; &#125; &#125; return ture;&#125; 作者的方案 八分检测 如图，我们使用轴将视锥切成八份，每一份是一个octant，每个octant都分到了三个外平面（图中加粗部分），若一个物体在视锥内，则必须在每一个octant的三个外平面的内侧 对于一个AABB，他的中心点到corner的距离（其实就是半个主对角线长度）必须要小于视锥中心点到视锥平面的距离，也就是下图$d_2 \\le d_1$。 这个检测的消耗特别小，不过不够准（必要不充分） 视锥中心点到六个平面的距离可以在每一帧计算前全局做一次 标记视锥平面 如果一个物体在一个视锥平面内侧，说明这个物体的所有子物体都在这个视锥平面内侧，那么我后面对子物体进行视锥剔除时不需要再用这个平面进行计算了 在AABB上维护一个bitfield，记录这个物体是被六个平面中哪些平面裁掉的 连续性 TR：Translation and Rotation 帧是连续的，我们让AABB记录一个bitfield和一个buffer，bitfield记录这个物体是被哪些平面裁掉，buffer记录AABB距离六个平面的距离 如果一个物体在上一帧不可见，且视锥只移动了非常小的距离，那么这一帧这个物体大概率还是不可见 如果一个物体被视锥左平面剔除（可以复用“标记视锥平面”里的bitfield），那么视线向右转（不超过$180^{\\circ}$）时，这个物体依然会不可见 如果相机只做移动，那么视锥平面到所有BV的最短距离均变化相同的值$\\Delta d$（这个值可以全局只做一次），我们比较上一帧AABB到移动轴向两个平面的距离和$\\Delta d$，即可判读这个物体可见性是否变化 一点想法 一个基于连续性的剔除方法，能大幅减少剔除的次数和时间，只有第一帧在全场景遍历，后面都是增量改动。注意镜头快速移动时（比如setCameraPos）时主动重新全场景遍历一次吧 参考 UE5 View Frustum Document","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Culling","slug":"Culling","permalink":"https://reubensun.com/tags/Culling/"}]},{"title":"C++20下spdlog使用踩坑","slug":"program/LogSystem","date":"2023-10-29T23:25:25.000Z","updated":"2025-03-18T07:16:42.967Z","comments":true,"path":"program/LogSystem/","permalink":"https://reubensun.com/program/LogSystem/","excerpt":"","text":"C++20下spdlog使用踩坑 spdlog是一个开源的被广泛使用的C++log系统，于是我模仿Piccolo引擎写了一个Log系统，结果由于C++不允许连续进行两次及以上的用户自定义的隐式构造，使得spdlog的log函数无法正确推断匹配Args...，最后在公司C++高手的帮助下成功解决了问题，于是在此记录一下踩坑历程 最初的版本 我参考开源项目的实现，使用spdlog写了一个简易的LogManager，将其添加到一共全局变量中，通过宏将不同类型的LOG封装，还传递了函数Module #define LOG_HELPER(LOG_LEVEL, ...) \\ g_global_context.m_log_manager-&gt;log(LOG_LEVEL, &quot;[&quot; + std::string(__FUNCTION__) + &quot;] &quot; + __VA_ARGS__);#define LOG_DEBUG(...) LOG_HELPER(LogManager::LogLevel::Debug, __VA_ARGS__);#define LOG_INFO(...) LOG_HELPER(LogManager::LogLevel::Info, __VA_ARGS__);#define LOG_WARN(...) LOG_HELPER(LogManager::LogLevel::Warn, __VA_ARGS__);#define LOG_ERROR(...) LOG_HELPER(LogManager::LogLevel::Error, __VA_ARGS__);#define LOG_FATAL(...) LOG_HELPER(LogManager::LogLevel::Fatal, __VA_ARGS__); class LogManager final&#123;public: enum class LogLevel : uint8_t &#123; Debug, Info, Warn, Error, Fatal &#125;; LogManager(); ~LogManager(); template&lt;typename... Args&gt; void log(LogLevel level, Args&amp;&amp;... args) &#123; switch (level) &#123; case LogLevel::Debug: m_logger-&gt;debug(std::forward&lt;Args&gt;(args)...); break; case LogLevel::Info: m_logger-&gt;info(std::forward&lt;Args&gt;(args)...); break; case LogLevel::Warn: m_logger-&gt;warn(std::forward&lt;Args&gt;(args)...); break; case LogLevel::Error: m_logger-&gt;error(std::forward&lt;Args&gt;(args)...); break; case LogLevel::Fatal: m_logger-&gt;critical(std::forward&lt;Args&gt;(args)...); break; default: break; &#125; &#125; template&lt;typename... Args&gt; void fatalCallback(Args&amp;&amp;... args) &#123; const std::string format_str = std::format(std::forward&lt;Args&gt;(args)...); throw std::runtime_error(format_str); &#125;private: std::shared_ptr&lt;spdlog::logger&gt; m_logger;&#125;; 然而当我测试时，却出现了错误 LOG_INFO(&quot;Scene Tick&#123;&#125;&quot;, 1); error C7595: “fmt::v9::basic_format_string&lt;char,int&gt;::basic_format_string”: 对即时函数的调用不是常量表达式message : 因读取超过生命周期的变量而失败message : 请参见“&lt;args_0&gt;”的用法 fmt版本 我求助了公司的C++高手，高手给我改成了这样，他将参数中函数Module分离出来，并将其和表达式宏拼接 #define LOG_HELPER(LOG_LEVEL, MODULE, FMT_STRING, ...) \\ g_global_context.m_log_manager-&gt;log(LOG_LEVEL, MODULE##FMT_STRING, __VA_ARGS__); template&lt;typename... Args&gt;+void log(LogLevel level, const char* _module, Args&amp;&amp;... args)&#123; switch (level) &#123; case LogLevel::Debug:+ m_logger-&gt;debug(spdlog::fmt_runtime_string&lt;char&gt;&#123; _module &#125;, std::forward&lt;Args&gt;(args)...); break; ... &#125;&#125; 并让我这样调用函数 LOG_INFO(__FUNCTION__, &quot;xxx&#123;&#125;&quot;, 1); 结果我发现，在高手电脑上可以正确运行的代码，在我本地缺会丢失&quot;xxx1&quot;这一部分，经过一段时间的排查，发现是我们的编译器预编译指令处理方式有区别，于是我修改cmake，让编译器使用符合C++标准的行为 if(MSVC) target_compile_options(core PUBLIC &quot;/Zc:preprocessor&quot;)endif() 添加后&quot;xxx1&quot;确实成功出现了 我本以为问题就这样解决，但C++高数却让我再实现一个可以只传字符串的重载（调另一个log接口），因为现在这个Log没法传入下面这种纯字符串内容 LOG_INFO(__FUNCTION__, &quot;Hello world!&quot;); 我整个人傻眼了，心想spdlog这么厉害的库，肯定有很多人在C++20的环境下使用，怎么可能要这么丑陋的实现！ std::fotmat版本 然后我翻看spdlog的源码，发现他有两个log的实现 template &lt;typename T&gt;void debug(const T &amp;msg) &#123; log(level::debug, msg);&#125; template &lt;typename... Args&gt;void debug(format_string_t&lt;Args...&gt; fmt, Args &amp;&amp;...args) &#123; log(level::debug, fmt, std::forward&lt;Args&gt;(args)...);&#125; 然后我就发现，原来我们之前一直想匹配到下面这个接口，却由于C++20在预编译处理上的一些改动，使我的代码十分复杂丑陋，而且还使用了spdlog内部的类型，我挺反感这种用一些模块内部类型的操作，我感觉好的工具类应该能黑箱地用 看着看着，我恍然大悟，C++20提供了std::format函数，我可以自己format字符串，传给spdlog一个普通字符串就行了 #define LOG_HELPER(LOG_LEVEL, ...) \\ g_global_context.m_log_manager-&gt;log(LOG_LEVEL,&quot;[&quot; __FUNCTION__ &quot;] &quot; +std::format(__VA_ARGS__)); template&lt;typename... Args&gt;void log(LogLevel level, Args&amp;&amp;... args)&#123; switch (level) &#123; case LogLevel::Debug: m_logger-&gt;debug(std::forward&lt;Args&gt;(args)...); break; ... &#125;&#125; 感觉是时候深入学习C++20了","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"glTF入门","slug":"graphics/gltf入门","date":"2023-10-23T22:46:25.000Z","updated":"2025-03-18T07:16:48.442Z","comments":true,"path":"graphics/gltf入门/","permalink":"https://reubensun.com/graphics/gltf%E5%85%A5%E9%97%A8/","excerpt":"","text":"glTF入门 glTF介绍 DCC生成的模型往往不能直接被渲染引擎使用，比如包含冗余数据、缺失场景数据、缺少动画状态机、压缩率不足等。许多引擎拥有一个Asset Pipeline，负责将不同DCC导出的各类数据转化为引擎可以直接使用的资源文件，比如UE的Cooking操作 glTF是一种表示3D场景的模型格式，它的目标就是尽可能保留3D场景相关的数据（使用json描述场景），为渲染引擎提供无需解码的模型数据（使用二进制存储buffer和image） 文本类型 glTF有二进制（.glb）和ASCII文本格式（.gltf） 一般而言，文本格式的glTF并不包含二进制内容（buffer和image），而是仅有一个uri链接，指向真正存储这些二进制数据的文件，这些数据已经被处理成GPU便于访问的格式 &quot;buffer01&quot;: &#123; &quot;byteLength&quot;: 12352, &quot;type&quot;: &quot;arraybuffer&quot;, &quot;uri&quot;: &quot;buffer01.bin&quot;&#125; &quot;image01&quot;: &#123; &quot;uri&quot;: &quot;image01.png&quot;&#125; 正是因为glTF这种描述和存储分离的特点，我们可以用很小的文件就能得到场景的描述，当我们需要使用到某个buffer或image时再懒加载这个资源，于是很适合Web项目。现在很多基于WebGL的渲染器都使用glTF格式 值得注意的是，对于一些小模型，我们也可以将这些二进制嵌入到json中 &quot;buffers&quot; : [ &#123; &quot;uri&quot; : &quot;data:application/octet-stream;base64,AAABAAIAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAA=&quot;, &quot;byteLength&quot; : 44 &#125; ], json结构 scene scene是解析一个glTF的入口，一个glTF可以包含多个scene 一个scene中会有一个nodes，nodes是一个数组，指向多个node 一个node中会有mesh等元素 mesh 一个meshes包含多个primitives（图元），每个图元中有一个attributes（属性）和indices attributes中包含着模型的顶点数据（vertices），比如POSITION、NORMAL、TEXCOORD_0 &quot;meshes&quot; : [ &#123; &quot;primitives&quot; : [ &#123; &quot;attributes&quot; : &#123; &quot;POSITION&quot; : 1 &#125;, &quot;indices&quot; : 0 &#125; ] &#125; ], accessor accessor（访问器），这是对资源的一种抽象封装，它存储了bufferView的结构，以及访问方法 对于mesh、skin、animation等数据，我们要通过accessor来访问。accessor中有一个bufferView，bufferView又指向存储真正二进制数据的buffer &quot;accessors&quot; : [ &#123; &quot;bufferView&quot; : 0, &quot;byteOffset&quot; : 0, &quot;componentType&quot; : 5123, &quot;count&quot; : 3, &quot;type&quot; : &quot;SCALAR&quot;, &quot;max&quot; : [ 2 ], &quot;min&quot; : [ 0 ] &#125;, &#123; &quot;bufferView&quot; : 1, &quot;byteOffset&quot; : 0, &quot;componentType&quot; : 5126, &quot;count&quot; : 3, &quot;type&quot; : &quot;VEC3&quot;, &quot;max&quot; : [ 1.0, 1.0, 0.0 ], &quot;min&quot; : [ 0.0, 0.0, 0.0 ] &#125; ], buffer A buffer defines a block of raw, unstructured data with no inherent meaning 为了便于渲染API的使用，glTF里的buffer是单纯的二进制，因此在解析时一定要明确读取的步长、类型 bufferView A bufferView describes a “chunk” or a “slice” of the whole, raw buffer data bufferView将一个完整的巨大的二进制内容切割为一个个小片，可以实现一个buffer存储多种类型的数据，还可以实现字节对齐等功能 一个简单的读mesh示例 这里我使用tinygltf库来加载glTF，这是一个基于cmake的纯头文件库 举一个简单的glTF读取mesh的例子，仅读取index buffer和vertex buffer（只有POSITION和TEXCOORD_0） class GltfLoader&#123;public: GltfLoader(std::string model_path); ~GltfLoader(); std::vector&lt;Index&gt; loaded_index_buffer; std::vector&lt;Vertex&gt; loaded_vertex_buffer;private: tinygltf::Model m_gltf_model; tinygltf::TinyGLTF m_loader_context;&#125;; GltfLoader::GltfLoader(std::string model_path)&#123; std::string gltf_load_error; std::string gltf_load_warning; bool gltf_load_result = m_loader_context.LoadASCIIFromFile(&amp;m_gltf_model, &amp;gltf_load_error, &amp;gltf_load_warning, model_path); if (gltf_load_result) &#123; // load mesh for (auto&amp; mesh : m_gltf_model.meshes) &#123; for (auto&amp; primitive : mesh.primitives) &#123; // vertex int vertex_count = 0; std::vector&lt;Vertex&gt; local_vertex_buffer; // position if (primitive.attributes.find(&quot;POSITION&quot;) != primitive.attributes.end()) &#123; const int accessor_index = primitive.attributes.at(&quot;POSITION&quot;); const tinygltf::Accessor&amp; accessor = m_gltf_model.accessors[accessor_index]; const tinygltf::BufferView&amp; buffer_view = m_gltf_model.bufferViews[accessor.bufferView]; const tinygltf::Buffer&amp; buffer = m_gltf_model.buffers[buffer_view.buffer]; const float* data_ptr = reinterpret_cast&lt;const float*&gt;(&amp;buffer.data[buffer_view.byteOffset + accessor.byteOffset]); const int position_byte_stride = 3; vertex_count = accessor.count; for (int i = 0; i &lt; vertex_count; i++) &#123; Vertex local_vertex; local_vertex.pos = glm::vec3(data_ptr[i * position_byte_stride], data_ptr[i * position_byte_stride + 1], data_ptr[i * position_byte_stride + 2]); local_vertex_buffer.push_back(local_vertex); &#125; &#125; // uv if (primitive.attributes.find(&quot;TEXCOORD_0&quot;) != primitive.attributes.end()) &#123; const int accessor_index = primitive.attributes.at(&quot;TEXCOORD_0&quot;); const tinygltf::Accessor&amp; accessor = m_gltf_model.accessors[accessor_index]; const tinygltf::BufferView&amp; buffer_view = m_gltf_model.bufferViews[accessor.bufferView]; const tinygltf::Buffer&amp; buffer = m_gltf_model.buffers[buffer_view.buffer]; const float* data_ptr = reinterpret_cast&lt;const float*&gt;(&amp;buffer.data[buffer_view.byteOffset + accessor.byteOffset]); const int uv_byte_stride = accessor.ByteStride(buffer_view) ? (accessor.ByteStride(buffer_view) / sizeof(float)) : tinygltf::GetNumComponentsInType(TINYGLTF_TYPE_VEC2); for (int i = 0; i &lt; vertex_count; i++) &#123; local_vertex_buffer[i].texture_coord = glm::vec2(data_ptr[i * uv_byte_stride], data_ptr[i * uv_byte_stride + 1]); &#125; &#125; // append local vertex buffer to loaded vertex buffer for (int i = 0; i &lt; vertex_count; i++) &#123; loaded_vertex_buffer.push_back(local_vertex_buffer[i]); &#125; // index if (primitive.indices &gt;= 0) &#123; const tinygltf::Accessor&amp; accessor = m_gltf_model.accessors[primitive.indices]; const tinygltf::BufferView&amp; buffer_view = m_gltf_model.bufferViews[accessor.bufferView]; const tinygltf::Buffer&amp; buffer = m_gltf_model.buffers[buffer_view.buffer]; const void* dataPtr = &amp;(buffer.data[buffer_view.byteOffset + accessor.byteOffset]); const int elements_count = accessor.count; // MARK: the component type is very important, common is TINYGLTF_PARAMETER_TYPE_UNSIGNED_SHORT switch (accessor.componentType) &#123; case TINYGLTF_PARAMETER_TYPE_UNSIGNED_INT: &#123; const uint32_t* buf = static_cast&lt;const uint32_t*&gt;(dataPtr); for (int i = 0; i &lt; elements_count; i++) &#123; Index local_index; local_index.index = buf[i]; loaded_index_buffer.push_back(local_index); &#125; break; &#125; case TINYGLTF_PARAMETER_TYPE_UNSIGNED_SHORT: &#123; const uint16_t* buf = static_cast&lt;const uint16_t*&gt;(dataPtr); for (int i = 0; i &lt; elements_count; i++) &#123; Index local_index; local_index.index = buf[i]; loaded_index_buffer.push_back(local_index); &#125; break; &#125; case TINYGLTF_PARAMETER_TYPE_UNSIGNED_BYTE: &#123; const uint8_t* buf = static_cast&lt;const uint8_t*&gt;(dataPtr); for (int i = 0; i &lt; elements_count; i++) &#123; Index local_index; local_index.index = buf[i]; loaded_index_buffer.push_back(local_index); &#125; break; &#125; default: std::cerr &lt;&lt; &quot;Index component type &quot; &lt;&lt; accessor.componentType &lt;&lt; &quot; not supported!&quot; &lt;&lt; std::endl; return; &#125; &#125; &#125; &#125; // TODO: load children // TODO: load transform, material, texture, skin, skeleton, animtion, blendshape &#125;&#125; 参考 glTF Tutorials","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"glTF","slug":"glTF","permalink":"https://reubensun.com/tags/glTF/"}]},{"title":"无状态方法","slug":"program/无状态方法","date":"2023-10-23T17:01:25.000Z","updated":"2025-03-18T07:16:42.969Z","comments":true,"path":"program/无状态方法/","permalink":"https://reubensun.com/program/%E6%97%A0%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95/","excerpt":"","text":"无状态方法 线程安全 同事经常跟我强调线程安全的重要性，比如下面这段代码，id是一个静态成员变量，被所有Student类的对象共享，在多线程环境下可能会造成不确定行为 class Student&#123;private: static int id = 0;public: int getId() &#123; return id; &#125;&#125;int Student::id = 0; 我们可以加入一个锁以实现线程安全，std::lock_guard会通过其生命周期创建销毁锁 class Student&#123;private: static int id = 0; static std::mutex id_mutex;public: int getId() &#123; std::lock_guard&lt;std::mutex&gt; lock(id_mutex); return id; &#125;&#125;int Student::id = 0; 无状态方法 然后同事又跟我介绍了无状态方法（Stateless），即计算中不依赖先前的状态或上下文的方法。比如stl中大量的非成员函数，他们大多都是无状态方法 // 这种非成员函数是无状态的int adder(int a, int b)&#123; return a + b;&#125;int main(int argc, char **argv)&#123; std::cout &lt;&lt; adder(2, 3); return 0;&#125; // 通过重载()运算符来实现adderclass Adder&#123;public: Adder(int c)&#123; this-&gt;c = c; &#125; int operator()(int a, int b)&#123; return a+b+c; &#125;private: int c;&#125;;int main(int argc, char **argv)&#123; Adder adder(1); std::cout &lt;&lt; adder(2, 3); return 0;&#125; 一般而言，无状态方法只要输入是确定的，输出一般是可预料的（内部使用random相关函数的输出总体也是有期望的） 与无状态方法对应的是有状态方法（Stateful），比如一些读资源函数，我传入一个指针、Handle、索引，返回的结果取决于资源状态，输出的结果是不确定的。有状态方法一般要注意线程安全问题、空指针、索引越界等问题 // 不好的设计，因为getCurrentDateText的结果与format的状态有关// 尽管这样设计性能更好（不频繁创建新对象），一般也没人改formatpublic class Sample &#123; private static final DateFormat format = new SimpleDateFormat(&quot;yyyy.MM.dd&quot;); public String getCurrentDateText() &#123; return format.format(new Date()); &#125;&#125;// 无状态方法，线程安全public class Sample &#123; public String getCurrentDateText() &#123; return new SimpleDateFormat(&quot;yyyy.MM.dd&quot;).format(new Date()); &#125;&#125; 参考 无状态方法","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"内存分配","slug":"program/内存分配","date":"2023-09-14T14:36:25.000Z","updated":"2025-03-18T07:16:48.436Z","comments":true,"path":"program/内存分配/","permalink":"https://reubensun.com/program/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","excerpt":"","text":"内存分配 最近看了一些关于内存分配的分享，发现操作系统相关的知识都忘光了，于是打算借助Linux内核的内存分配机制，简单复习一下内存分配相关的理论知识 程序运行时不断进行内存的申请与释放，高效的分配方式不仅能提高内存的利用率，还能提高性能。 Linux内存分配原理 地址 程序需要装入内存才能运行，程序开始的位置相较于内存0地址会有一段偏移，这个偏移被称为物理地址。 在程序内部，以程序开头为0地址，向后偏移得到的地址称为逻辑地址。 分配 内存分配最大的问题是内存碎片问题，大的数据间总是残余一些小的空间，这些空间整体数量较多，但是单个空间较小，无法满足存入新的大数据，于是尽管我们还有大量空间没有被使用，但是无法分配给新的数据。 连续分配（将程序放在一起） 单一连续分配 系统区 用户区 固定分区分配 可变分区分配 首次适应 最后适应 最佳适应 最坏适应 不连续分配（将程序分散放置） 页式管理 段式管理 Intel CPU硬件支持段式管理和二层页式管理，Liunx主要使用二层页式管理。 页式管理 一本书有很多页，每一页都有页码，页码可以唯一标识一本书中的某一页，页式管理就是将数据分成一个个大小相等的页，每一页都有一个唯一的页码，通过页码可以找到对应的数据 页式管理是一种不连续分配技术，将数据的逻辑地址拆成一个个大小相等的页面。将内存也拆成一个个大小相等的页框（物理块），并为每个页框分配一个唯一的页框号。 程序被装入内存时，被拆成多个页，这些页会被放入内存中不连续的位置，通常只有最后一页会写不满，因此只会产生一个页内碎片。 上图中间的是页表，存储着页号和物理块的对应关系，以实现页间寻址。 页内的数据通过虚地址（页号+页内偏移量）来实现页内寻址。 为了提速，页表含有一个缓存机制。 我们上面的页表是连续分配的，而对于一个32位系统，他拥有一个大小为$2^{32}$的逻辑空间，会形成一个巨大的页表。为此我们将页表也进行拆分，离散存储在内存中，使用一个外层目录表来存储页表的地址。当我们需要某一个页数据时，通过外层目录找到对应页表的地址，将该部分页表装入内存，再通过页表找到对应的页数据。这个方案叫做二级页表。 常见内存分配器 Linux内核为不同场景设计了不同的分配器，比如Slab、TLSF、Buddy，内存分配器需要在分配性能和空间利用率间做出权衡。 我感觉这三个分配器并不是平级的关系，Buddy像是一个硬件级、操作系统级的分配器，进行页面级别的内存分配，他解决了程序要怎么分散放置在内存中。TLSF解决了如何具体分配一块指定大小的内存。Slab则为内存分配提供了缓存优化。 Buddy 以内存页（4kb）为单位分配内存，本质还是一种空闲链表法 Buddy系统将内存拆分为多个物理块，这些块的大小均为2的幂次方 Buddy分配器维护了一个空闲位图（也有用二叉树维护的），这个位图是一个数组，数组的每个元素是一个链表。链表中每一个元素均为$2^n$大小的空闲物理块，其中$n$为order的值。 当分配一个大小为k的内存时，分配器会找到比k大且order值最小的空闲块，如果这个最小的空闲块比k的两倍还大，那么将这个空闲块拆分为二，再次进行分配。 当释放一块内存时，将新的内存块放入对应链表中，若该链表中内存块过多，会进行合并操作 TLSF 用于分配介于512b和512kb的数据，实现可以参考tlsf TLSF（Two-Level Segregated Fit）的核心是使用两级链表。 第一级链表（下图f1）将空闲内存块大小根据二的幂次方进行分类（注意，这里表示的是内存的粗细粒度，而非要求内存块大小必须为二的幂次方），该行的内存块大小范围为$[2^i, 2^{i+1})$ 第二级链表（下图s1）按照间隔，将索引$[2^i, 2^{i+1})$进行分段，以加速查找。二级链表的值是一个链表，链表中的每个元素是一个空闲内存块，大小和索引值相同。 FL_bitmap和SL_bitmaps[]的每一个bit表示是否被使用。 当我们需要分配一个大小为89Bytes的内存时，这个数据范围在$[64, 128)$，我们通过FL_bitmap判断出第6行是有空闲块的。然后通过SL_bitmaps[6]判断出$[88, 96)$这个范围中有空闲块，最后分配出89Bytes大小的内存块 TLSF分配、释放、再分配复杂度均为稳定的O(1)，且适用于高负载和多线程环境。不过尽管操作复杂度都是常数级，但位图操作比较复杂，速度并不一定快 Slab 用于小于512b、频繁被销毁创建的数据， 上面的Buddy算法以页为单位进行分配，对于几字节的小文件，这十分浪费。Slab分配器用于在一个页框内分配小存储区，是对Buddy分配在小文件的补充。 Slab分配器是一种基于缓存的内存分配方法，对于一些高频使用的对象（比如进程描述符），将其放入Slab缓存中。 当需要创建一个对象时直接从缓存中拿去一份（所有权转移？）。当进程结束后，并不将对象所在的页框释放，而是重新放回Slab分配器中。 一个对象可以同时有着多个副本缓存，我们将同一个对象的所有缓存存入一个双向循环链表中，这个链表被称为“缓存链”。 通过着色技术提高缓存利用率。 缓存着色技术 缓存着色技术适用于组相联映射缓存 缓存的组织组织方式： 直接映射 组相连映射（set associative cache） 全相连映射（full associative cache） 直接映射：内存地址到缓存地址的映射是唯一的，通常为取模运算。这会导致相邻的内存会被映射到同一缓存地址，导致缓存冲突（conflict miss） 全相联映射：允许内存地址映射到任何缓存地址。但是为了检查特定地址是否在缓存中，需要整个便利。通常要实现一套LRU（最近最少使用）系统。全相联缓存硬件复杂，而且极其昂贵，一般都极其小。 组相联映射是对两者的折中，将整个缓存分成n个组，每个组中有m块。将内存做拆分，每个内存块有n行数据。内存中第i行的数据可以存在第i组缓存中，内存块和块之间共享m块缓存。当内存数据存入缓存时，通过取模运算得到组号，再便利组内数据，判断该数据是否已经在缓存中了。 然后我们发现，如果同时多个数据他们的组号相同，他们还是会被映射到同一个组内，一旦数量超过了m条，就会引发缓存冲突。 缓存着色技术将内存、程序、缓存进行分行并标色，对于一段程序，操作系统会尽量将程序的某一行放到对应颜色的内存行、缓存行中（红色的程序行放在红色的缓存行中）。 参考 《操作系统原理及应用（Linux）》王红 Building Night City: The Technology of ‘Cyberpunk 2077’ - GDC 2021 TLSF内存分配器 TLSF内存分配原理 组相联缓存机制","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://reubensun.com/tags/Linux/"}]},{"title":"C++函数调用","slug":"program/C++函数调用","date":"2023-08-14T10:32:25.000Z","updated":"2025-03-18T07:16:48.439Z","comments":true,"path":"program/C++函数调用/","permalink":"https://reubensun.com/program/C++%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/","excerpt":"","text":"C++函数调用 C++支持两种函数调用方式，__stdcall和__cdecl，两者对栈帧（stack frame）的处理方式不同，__stdcall是由被调用函数来清理栈帧，__cdecl是由调用函数来清理栈帧。一旦混用，容易引发错误 两者混用可能会导致栈帧没有被释放或者被连续释放两次 stack frame 栈帧用于维护函数调用的上下文信息，在函数调用时，会在栈上分配一块内存，用于存储函数的参数、返回值、局部变量、调用者的栈指针等，函数返回后，栈帧会被销毁 standard call __stdcall全称为standard call，是Pascal和Win32的默认调用方法，函数在调用时必须严格按照定义传递参数，参数从右向左入栈，在函数返回前执行出栈指令（retn x），清理栈帧 // windef.h#define CALLBACK __stdcall#define WINAPI __stdcall#define WINAPIV __cdecl#define APIENTRY WINAPI#define APIPRIVATE __stdcall#define PASCAL __stdcall#define cdecl _cdecl#ifndef CDECL#define CDECL _cdecl#endif extern &quot;C&quot; int __stdcall AddStdCall(int a, int b);int main() &#123; int result = AddStdCall(5, 3); // 使用stdcall调用 std::cout &lt;&lt; &quot;Result using stdcall: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125;int __stdcall AddStdCall(int a, int b) &#123; return a + b;&#125; C Declaration __cdecl全称为C Declaration，是C/C++的缺省调用方法，该方法最大的特点是允许传入可变参数，函数返回后由调用者执行出栈指令（ret），清理栈帧 extern &quot;C&quot; int __cdecl SubtractCDecl(int a, int b);int main() &#123; int result = SubtractCDecl(10, 4); // 使用cdecl调用 std::cout &lt;&lt; &quot;Result using cdecl: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125;int __cdecl SubtractCDecl(int a, int b) &#123; return a - b;&#125; extern的另一个作用是重新声明一个函数，如果我在另一个cpp中实现了一个函数/变量，却没有将对应的声明include到当前这个文件中，我可以使用extern重新声明这个函数，效果就跟include一样。思想和前向声明很像 封装 有的第三方库无可奈何地使用了__stdcall，而我们的项目使用的是__cdecl，这时候就需要对第三方库进行封装，以便能够正常调用 // 假设第三方库提供的接口声明为以下形式（使用 __stdcall 调用约定）extern &quot;C&quot; &#123; int __stdcall ThirdPartyFunction(int a, int b);&#125; // 封装类class ThirdPartyWrapper &#123;public: static int CallFunction(int a, int b) &#123; return ThirdPartyFunction(a, b); // 调用第三方库函数 &#125;&#125;;int main() &#123; int result = ThirdPartyWrapper::CallFunction(5, 3); std::cout &lt;&lt; &quot;Result using third-party wrapper: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; Windows函数调用约定 以MSVC x64调用约定为例 x64 ABI使用四寄存器fast-call调用约定，在函数调用时将函数的参数存储在指定的寄存器中，参数和这些寄存器有着严格的对应关系。 一个参数最多只能放在一个寄存器中 若一个参数的大小不是1、2、4、8字节，将会按引用传递 寄存器中整数右对齐，被调用方可以忽略寄存器中的高位数据，于是可以向下兼容（即1、2、4、8可以放进8字节的寄存器中） 为什么是8字节呢？因为8字节=64位，x64系统的寄存器大小为64位 整数参数使用RCX、RDX、R8、R9寄存器传递 func1(int a, int b, int c, int d, int e, int f);// a in RCX, b in RDX, c in R8, d in R9, f then e pushed on stack 浮点参数使用XMM0-XMM3寄存器传递 func2(float a, double b, float c, double d, float e, float f);// a in XMM0, b in XMM1, c in XMM2, d in XMM3, f then e pushed on stack 整数和浮点数混合 func3(int a, double b, int c, float d, int e, float f);// a in RCX, b in XMM1, c in R8, d in XMM3, f then e pushed on stack","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"文明6like","slug":"game/文明6like","date":"2023-07-16T10:01:25.000Z","updated":"2025-03-18T07:16:48.445Z","comments":true,"path":"game/文明6like/","permalink":"https://reubensun.com/game/%E6%96%87%E6%98%8E6like/","excerpt":"","text":"文明6like 4X游戏 文明6是一个经典的历史类4x游戏 explore（探索） expand（扩张） exploit（开发） exterminate（消灭） 文明6的体验 游戏体验 最近玩了几百小时的文明六，感觉意犹未尽，却又索然无味，想抽掉一些内容，自己做一个简易版的文明6，个人希望加强塔防、改良、贸易等元素，减少兵种操作、城市铺设。 我玩文明6，最让人兴奋的就是地块高额的产出（尤其是保护区单元格，太美丽了），我希望我的游戏也要着重地块产出和自肃 我玩文明6，最让人气愤的是AI起城墙，文明6的城墙等级几乎没用（历史上的城墙在不同时期有不同形态和意义），而城墙强度又过高（对远程和骑兵过于不友好），而且兵种和城墙间没有很好的联动，最近看了一些长城和棱堡的视频，感觉这谐内容很有意思 不过如果要做兵种和城墙这种微操，城市的数量不能太多，我打算将视角转化到城市，你拥有一个首都和少量卫星城市，从刀耕火种的营地，最后到世界级的城市 感受文化 参考棱堡为什么消失、 文明6有一个目的是让玩家体验各个文明的特色和历史进程。通过玩文明6，我知道了蒙古除了擅长骑射外，还拥有一支庞大的重骑兵“怯薛歹”；我知道了长城除了据马、传信等功能外，还能掌控海关，在互市中实现剪刀差；我知道了马镫的出现使得骑兵成为战场上的大杀器，铁才是重骑兵生产需要的战略资源；我知道了火枪时代曾经有着排队枪毙的线列步兵，这个兵种让战争彻底平民化、综合国力化；诸如此类，数不胜数 我想让玩家体验的，其实是城墙的发展史 远古城墙，是低矮的土墙，这些墙可以被人轻易翻过，但是无法让马越过，于是实现了拒马的作用 古典时期城墙变高，城墙上设有射击点，以增大攻城成本 尤其是长城这类城墙，在军事上可以限制骑兵，可以逼迫攻城方带大型器械（对于游牧民族是很困难的），可以给中央反应时间，可以限制敌人行军路径（一般从哪里破城，劫掠后就从哪里出去，毕竟劫掠时不可能带着攻城器械），可以作为高速公路实现运兵（不用爬山了）；在经济上可以避免游牧劫掠，互市实现剪刀差， 奥斯曼帝国时期，火药开始用于攻城，大炮对城墙的破坏力大大提高，此时（中世纪）城墙开始变矮变厚，此时城墙的拐角处往往会呈圆形突出，各个突出可以实现互相掩护，以降低射击死角 文艺复兴时期，弹道学被发明，为了减少守军的射击死角，射击坡和棱堡出现了，拥有更大的控制区和更小的射击死角（但棱堡有些贵了） 拿破仑时期发现城墙完全没有意义，因为法军会绕开坚城，直取首都，然后围点打援，于是在一战前，往往城市外面的山坡上设立一个个小的孤立要塞，敌人在攻城时这些要塞的大炮可以提供火力掩护，敌人在移动时也可以进行敌人探测和阻击，而且更便宜 南北战争时期，多边形城堡出现，除了射击坡外，一大特点是有地下隐藏火力点，敌人攻城时，除了受到正面的射击外，还会收到背后两侧的射击 我的游戏初设 游戏背景 有些类似动漫《异世界悠闲农家》 玩家是从异世界穿越而来的勇者，能力是建造者。玩家出生在森林/雪山/海岛，这里离人类社会很远，充满了强大的魔物，主角的人物就是在出生点附近生活，建立城市，吸纳难民，开辟和其他友好部落的商路，抵御魔物的一轮轮进攻 游戏目标 军事胜利：击败魔王（魔王会在最后一轮进攻时出现，只要抵御所有伦次的进攻即可，不过也可以在探明魔王城后主动进攻） 经济 地块 游戏采用类似文明6的俯视角六边形地图，地块上绘制有地形和产出，每回合会产出对应数值 地块的产出有： 粮食：1人口需要消耗1粮食，当粮食有剩余时，人口会缓慢增长 人口 游戏中的人口是纯概念，没有操作实体，可以锁在某个地块上 科技 军事 游戏中的军事单位有操作实体，类似于战旗游戏 军事单位有攻击力、生命值、移动力、等级经验等属性，攻击会消耗大量移动力，通常大部分单位一回合只能攻击一次 兵种设置 剑士，近战单位，标准攻击力，标准移动力，兵种相邻会加力 侦察兵，近战单位，拥有地图绘制能力，攻击力较弱，移动力较强，除非与敌人相邻，不然只能被其他侦察兵发现（类似于文明6中的潜艇） 弓箭手，远程单位，拥有攻击控制区，在控制区内的敌人会被减力减移动力，可以上城墙，攻击距离受地形影响 法师，远程攻城单位，拥有更强的攻击力，但无法移动攻击，能对城墙造成满额伤害 牧师，参考火焰纹章的治疗，消耗道具为一个单位回复生命值 骑士，高移动力的近战单位，与敌人剑士相邻时，会消除敌人相邻加力（冲散队形） 天使，参考火焰纹章的天马，高移动力无视地形的单位，拥有地图绘制功能，并拥有更大的攻击范围（攻击方式类似于文明6的轰炸机），若攻击目标处于地方弓箭手的控制区内，会受伤。具有抗魔性。价格更高 控制区 目前是引入火力压制和火力支援的概念 弓箭手周围区块会处于己方的控制区，使用计数法判定。每个我方弓箭手都会使得控制区内区块计数+1，每个敌方弓箭手会使计数-1 若计数为负数，则处于敌方区域，我方减力、减移动力 若为正数，则处于我方区域，敌方减力、减移动力 若为0，则双方无影响 视野 目的是让玩家使用侦察兵提前探路，避免陷入当前项羽进沼泽的窘境 起初世界全是战争迷雾，普通单位仅有一格的视野，普通单位不能走进未探索地区（也就是说，把一个普通单位放在迷雾区内，会只有周围一圈的视野，且无论移动力多少，一回合只能走一个，但同时能获得新的视野） 关于这个部分，我认为是结算依据是移动后周围六格是否有未探索的区域，若有，则失去所有移动力，刷新地图 侦察单位的视野等同于移动力 加力减力 城防 堡垒，城市外的防御塔，仅一格大小，可以驻扎一个单位，无法相邻建造，但可以用城墙相连 城墙 地堡，仅能被单侧攻击，却有三个攻击方向的建筑通常攻击方向朝向城市","categories":[{"name":"game","slug":"game","permalink":"https://reubensun.com/categories/game/"}],"tags":[]},{"title":"Git使用记录","slug":"program/Git入门","date":"2023-07-04T10:01:25.000Z","updated":"2025-03-18T07:16:42.966Z","comments":true,"path":"program/Git入门/","permalink":"https://reubensun.com/program/Git%E5%85%A5%E9%97%A8/","excerpt":"","text":"Git 使用记录 记录一下平时使用Git的记录 为什么使用Git 程序开发的第一步，就是做版本管理。频繁提交，可以便于环境恢复和Bug查找。分支开发，也能便于合作与多设备协同。配置Review规范，你还可以知道你的合作者在干什么，有效避免了因为开发者习惯能力差异导致的项目丑陋。配合CI的编译预检查，还能提高代码的稳健性。总之版本管理十分重要。 版本管理工具有很多，游戏开发由于拥有大量会频繁改动的二进制资源，于是常常使用SVN等工具，比如P4V。而引擎开发一般以代码为主，用Git管理，其中二进制文件（比如第三方库的超大号DLL）使用Git LFS管理 Cherry pick 常用于获取他人其他分支的某些改动，相较于Rebase，对于本地代码的破坏性更小，会保留commit信息 Cherry pick，摘樱桃，功能是将某个commit复制到当前分支 # Cherry pick 哈希值为8e8b...的commitgit cherry-pick 8e8bd4a89063535cb91de56a57e3a1683927a3b1# Cherry pick 哈希值从8e8b...到e652...的一系列连续的commitgit cherry-pick e65275b5b2b71153ff08e865cd825e27b5d247b5^..8e8bd4a89063535cb91de56a57e3a1683927a3b1 设置别名 有时很多很常用的命令你感觉太长了，于是可以使用别名 # 设置commit别名c，git c将等同于git commitgit config --global alias.c commit# 设置status别名sgit config --global alias.s status 补丁 常用于获取他人其他分支的某些改动，但并不会保存commit信息，你需要手动add、commit diff 差异，用于生成补丁文件（patch），补丁文件本身是个纯文本文件 # 比较branch1和2的最新提交间的差异，将差异保存在mypatch.patch文件中git diff branch1 branch2 &gt; mypatch.patch apply 应用，用于应用补丁文件（patch），若出现冲突，会生成拒绝（reject）文件，你可以手动处理掉这些reject文件 git apply xxx.ptach --reject 清理 手动进行垃圾回收，以释放本地存储空间 git prune 网络443 有的时候我们挂了梯子仍然连不上github服务器，报错 fatal: unable to access ‘https://github.com/Reuben-Sun/ToolEngine.git/’: Failed to connect to github.com port 443 after 21070 ms: Couldn’t connect to server 此时我们可以先查看自己梯子的端口号，然后找到.gitconfig文件，添加代理设置（我这里以端口号为7890为例） [user] email = xxx@xxx.com name = xxx[http] proxy = http://127.0.0.1:7890[https] proxy = http://127.0.0.1:7890 ignore 创建一个.gitignore文件，即可忽略部分文件，常用于ignore构建的二进制文件、临时文件、巨大的模型文件 # 忽略任何路径下的__pycache__文件夹**/__pycache__# 忽略build文件夹build# 忽略所有fbx后缀的文件*.fbx LFS 安装lfs sudo apt-get install git-lfs 启用lfs git lfs install track某种文件 git lfs track &quot;*.zip&quot;git lfs track &quot;*.mp4&quot;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://reubensun.com/tags/Git/"}]},{"title":"Unity ECS 入门","slug":"engine/UnityECS","date":"2023-07-03T23:01:25.000Z","updated":"2025-03-18T07:16:48.446Z","comments":true,"path":"engine/UnityECS/","permalink":"https://reubensun.com/engine/UnityECS/","excerpt":"","text":"Unity ECS 入门 曾经待的项目使用了Unity ECS 0.5，那时候功能很不完善，几乎所有功能都从头写了一遍。现在Unity ECS 1.0发布了，有点失望。看了一圈感觉系统复杂性提高了很多，而且不能保证系统的稳定性（尤其是有错的代码编译），非常不适合独立游戏制作 数据驱动 ECS的本质就是数据驱动的编程，随着守望先锋的爆火进入大家视野，结果现在守望2都凉了，Unity才把ECS端上来。。。 缓存友好 每一个程序员都应该知道的数字 截至2020年，电脑访问数据的速度为 L1缓存：1ns 分支预测错误：3ns L2缓存：4ns 解/锁互斥锁：17ns 内存：100ns 固态硬盘随机读取：16,000ns 固态硬盘顺序读取1,000,000bytes：49,000ns 机械硬盘顺序读取1,000,000bytes：825,000ns 我们发现缓存的访问速度远快于内存和硬盘，缓存友好的程序性能会更好 OOP与DOP 对于OOP（Object-Oriented Programming）来说，我们可能每次仅迭代对象的某一项属性，其他属性白白加载了，造成性能的浪费和缓存的不友好 而DOP（Data-Oriented Programming）的实体由多个纯数据组成，系统运行时收集并处理所需的数据，这些数据大多为密集的同质数据，缓存友好 SOA SOA不同于Unity ECS，放在这里用来抛砖引玉，便于理解数据驱动 数据驱动有很多实现方式，比如SOA（Struct of Array），将原本同质的数据合并为数组。 // AOS(Array of Struct)struct Particle&#123; Vector3 position; Vector3 velocity; Color color; float age; // ...&#125; m_particles[N]; // SOA(Struct of Array)struct Particles&#123; Vector3 position[N]; Vector3 velocity[N]; Color color[N]; float age[N]; // ...&#125; m_particles; 这种实现不需要为了对齐做padding即可完美对齐，能节省内存 可以使用SIMD（单指令多数据）加速读写 缓存对齐可以去看TBB Padding，可以使得两个相邻的数据位置更远，从而不出现在一个缓存行中，进而避免了假共享现象 易拓展 相较于面向对象，数据驱动更易拓展 OOP的方案 对于面向对象的数据结构，如果要拓展一个新的字段，如果直接将数据放在类里面（不管这个字段会不会被用到），会增大对象大小，浪费内存，缓存不友好，最后导致系统越来越抗拒新的拓展 如果使用union，确实可以实现不同成员共享空间，省去了那些没有被用到的数据的大小。但需要我们预先决定哪些数据不会被同时使用，大幅提高了编程难度和出错率 struct Data &#123; int dataType; // 用于标识数据类型 union &#123; int intValue; float floatValue; char stringValue[10]; &#125; dataValue;&#125;; 如果使用哈希表，确实得到了弹性，但会产生成员进map的消耗 struct Data &#123; unordered_map&lt;Key, Variant&gt; kv;&#125;; SOA Flexible Table 个人感觉本质就是哈希表，使用起来很像处理JSON和XML 运行时为table添加项，添加项时提供项的定义信息、初始值 MetaTable meta;const TypeID floatType = meta.AddType(&quot;float&quot;, 4, 16);const AttributeID positionXAttribute = meta.AddAttribute(&quot;positionX&quot;, floatType, 0.0f);const AttributeID positionYAttribute = meta.AddAttribute(&quot;positionY&quot;, floatType, 0.0f);const AttributeID positionZAttribute = meta.AddAttribute(&quot;positionZ&quot;, floatType, 0.0f);const AttributeID velocityXAttribute = meta.AddAttribute(&quot;velocityX&quot;, floatType, 0.0f);// ...SOATable particles(meta);particles.ReserveRows(N);particles.AppendRows(N);for (size_t i = 0; i &lt; N; i++) &#123; particles.SetValue(i, positionXAttribute, ...);// ...&#125; GO与ECS Unity的GO和ECS是对OOP和DOP的具体实现 传统的GO+Mono模式：场景中有大量的GO，他们拥有各自的脚本和组件，运行时遍历GO，按生命周期执行Mono脚本（一定是所有OnEnable()执行完后，再执行所有的Start()） ECS模式，场景由Entity和System组成，这些Entity拥有纯数据的Component，而System负责收集其负责的Component，集中处理 能看出，ECS模式是数据密集型的，同类的数据集中存储，集中处理。而GO是一个相对完整独立的个体，每个GO都会处理自己的数据。 ECS缓存友好，适用于单指令多数据、并行、上下文切换等机制，于是在逻辑处理上会比GO强很多 初始化 安装 之前0.5的时候，Unity ECS就一直藏在掖着，仿佛不肯用户发现安装一般，现在正式发售了，也没有放进包管理器里 打开包管理器，点击按名字添加包 依次添加com.unity.entities和com.unity.entities.graphics 打开快速Play 真的很快 打开Scene预览 不开启这个，你运行时创建的Entity无法在Scene窗口查看 Rider 个人建议配合Rider2023的新UI使用啊，效率能大幅提高，而且还有DOTS类型模板 不过一定要关闭自动保存，不然一切屏就报错 入门 SubScene 这个SubScene很久以前就有，但以前我们可以通过主动加载Prefab的方式实现流式加载，于是很少用这个SubScene，但现在好像把Prefab转Entity这个工作流取消了？ 在Hierarchy节目按右键New Sub Scene即可创建，你可以像操作GO一样在SubScene中添加物体，会自动转化为Entity SubScene右侧有一个Checkbox，这个是用来加载/卸载场景的，SubScene最初的用法就是用来流式加载的 Entity 这属实优化了不少 现在Entity的制作流程极其简答，按GO的方式制作，然后会自动转化为Entity，为了方便你编辑，还提供了两套窗口，通过按右上角的圆圈，即可调整窗口 传统的GO界面（Authoring） Entity界面（Runtime） Component 还是一如既往的脱裤子放屁，突出一个意义不明 IComponentData 纯数据结构体 public struct CubeProperties: IComponentData&#123; public Vector2 FieldSize; public int CubeCount; public Entity CubePrefab;&#125; public struct CubeRandom : IComponentData&#123; public Random Value; MonoBehaviour IComponentData的数据无法在Editor面板上显示（why？），需要使用Mono封装传递（what？） public class CubeMono : MonoBehaviour&#123; public Vector2 FieldSize; public int CubeCount; public GameObject CubePrefab; public uint RandomSeed;&#125;public class CubeBaker : Baker&lt;CubeMono&gt;&#123; public override void Bake(CubeMono authoring) &#123; // 为当前Entity添加Component，可以添加多个 AddComponent(new CubeProperties &#123; FieldSize = authoring.FieldSize, CubeCount = authoring.CubeCount, CubePrefab = GetEntity(authoring.CubePrefab) // 这里做了Prefab转Entity &#125;); AddComponent(new CubeRandom &#123; Value = Random.CreateFromIndex(authoring.RandomSeed) &#125;); &#125;&#125; 将Mono脚本挂在Entity上，切换为Runtime界面，就能看到Component信息了 Aspect 这次ECS还新增了一个IAspect，看上去好像是负责收集Component数据的转换层，可以将多个Component的数据结合在一起，方便System调用 An aspect is an object-like wrapper that you can use to group together a subset of an entity’s components into a single C# struct namespace ECS.Study&#123; public readonly partial struct CubeAspect : IAspect &#123; public readonly Entity Entity; // TransformAspect 已经被取消 private readonly RefRW&lt;LocalTransform&gt; _localTransform; private readonly RefRO&lt;CubeProperties&gt; _cubeProperties; private readonly RefRW&lt;CubeRandom&gt; _cubeRandom; private readonly RefRW&lt;SphereSpawnPoints&gt; _sphereSpawnPoints; public int CubeCount =&gt; _cubeProperties.ValueRO.CubeCount; public Entity CubePrefab =&gt; _cubeProperties.ValueRO.CubePrefab; // 在中心创建一个球，球内将不会创建Cube #region SphereCreate public bool SphereSpawnPointsIsCreated() &#123; return _sphereSpawnPoints.ValueRO.Value.IsCreated &amp;&amp; SphereSpawnPointsCount &gt; 0; &#125; private int SphereSpawnPointsCount =&gt; _sphereSpawnPoints.ValueRO.Value.Value.Value.Length; #endregion // 生成Cube的位置和朝向 #region Transform public LocalTransform GetRandomCubeTransform() &#123; return new LocalTransform &#123; Position = GetRandomPosition(), Rotation = GetRandomRotation(), Scale = GetRandomScale(0.5f) &#125;; &#125; private float3 GetRandomPosition() &#123; float3 randomPosition; do &#123; randomPosition = _cubeRandom.ValueRW.Value.NextFloat3(MinCorner, MaxCorner); &#125; while (math.distancesq(_localTransform.ValueRO.Position, randomPosition) &lt;= CUBE_SAFETY_RADIUS_SQ); return randomPosition; &#125; private float3 HalfDimension =&gt; new() &#123; x = _cubeProperties.ValueRO.FieldSize.x * 0.5f, y = 0f, z = _cubeProperties.ValueRO.FieldSize.y * 0.5f &#125;; private float3 MinCorner =&gt; _localTransform.ValueRO.Position - HalfDimension; private float3 MaxCorner =&gt; _localTransform.ValueRO.Position + HalfDimension; private const float CUBE_SAFETY_RADIUS_SQ = 100; private quaternion GetRandomRotation() &#123; return quaternion.RotateY(_cubeRandom.ValueRW.Value.NextFloat(-0.25f, 0.25f)); &#125; private float GetRandomScale(float min) &#123; return _cubeRandom.ValueRW.Value.NextFloat(min, 1f); &#125; public float2 GetRandomOffset() &#123; return _cubeRandom.ValueRW.Value.NextFloat2(); &#125; #endregion &#125;&#125; System 要说System最大的改动，我感觉就是这东西好建不好删，这东西只要你写了，也不需要挂载，就会直接全局生效，我开着Editor删文件会报DLL被占用，也不好修改，没写好编译就会报错，然后Rider呼吁我Revert掉 // 设置初始化顺序，能在System界面看到[UpdateInGroup(typeof(InitializationSystemGroup))] public partial struct CubeGenerateSystem : ISystem&#123; [BurstCompile] public void OnCreate(ref SystemState state) &#123; // 当场景中包含至少一个 CubeProperties 组件时，启用 Update state.RequireForUpdate&lt;CubeProperties&gt;(); &#125; [BurstCompile] public void OnUpdate(ref SystemState state) &#123; state.Enabled = false; // 禁用 Update var cubeEntity = SystemAPI.GetSingletonEntity&lt;CubeProperties&gt;(); var cube = SystemAPI.GetAspect&lt;CubeAspect&gt;(cubeEntity); var builder = new BlobBuilder(Allocator.Temp); ref var spawnPoints = ref builder.ConstructRoot&lt;SphereSpawnPointsBlob&gt;(); var arrayBuilder = builder.Allocate(ref spawnPoints.Value, cube.CubeCount); var spawnOffset = new float3(0f, -2f, 1f); // 创建命令缓冲区 var cmd = new EntityCommandBuffer(Allocator.Temp); for (int i = 0; i &lt; cube.CubeCount; i++) &#123; // 将命令添加至命令缓冲区 var newCube = cmd.Instantiate(cube.CubePrefab); var newTransform = cube.GetRandomCubeTransform(); cmd.SetComponent(newCube, newTransform); var newSpawnPoint = newTransform.Position + spawnOffset; arrayBuilder[i] = newSpawnPoint; &#125; var blobAsset = builder.CreateBlobAssetReference&lt;SphereSpawnPointsBlob&gt;(Allocator.Persistent); cmd.SetComponent(cubeEntity, new SphereSpawnPoints&#123; Value = blobAsset &#125;); builder.Dispose(); cmd.Playback(state.EntityManager); // 执行命令 &#125; [BurstCompile] public void OnDestroy(ref SystemState state) &#123; &#125;&#125; public struct SphereSpawnPoints : IComponentData&#123; public BlobAssetReference&lt;SphereSpawnPointsBlob&gt; Value;&#125;public struct SphereSpawnPointsBlob&#123; public BlobArray&lt;float3&gt; Value;&#125; 此时启动游戏，会发现生成了一百个Cube，他们分布在一个正方形内部圆外部，转向随机 Job 用起来很像一个函数对象 Job是从System发出的任务 public partial struct DoSomeJob: IJobEntity&#123; // 这两个public的成员用来传递参数 public float DeltaTime; public EntityCommandBuffer ECS; private void Execute(CubeAspect cubeAspect) &#123; ... &#125;&#125; System通过创建对象来调用这个任务 [BurstCompile]public void OnUpdate(ref SystemState state)&#123; var deltaTime = SystemAPI.Time.DeltaTime; var ecbSingleton = SystemAPI.GetSingleton&lt;BeginInitializationEntityCommandBufferSystem.Singleton&gt;(); new DoSomeJob &#123; DeltaTime = deltaTime, ECB = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged) &#125;.Run();&#125; SystemBase 系统交互相关的系统 下面是一个相机盯着中心看，并做旋转的示例 public partial class CameraControllerSystem : SystemBase&#123; protected override void OnUpdate() &#123; var cameraSigleton = CameraSingleton.Instance; if(cameraSigleton == null) return; float positionFactor =(float) SystemAPI.Time.ElapsedTime * cameraSigleton.Speed; float scale = 1; var radius = cameraSigleton.RadiusAtScale(scale); var height = cameraSigleton.HeightAtScale(scale); cameraSigleton.transform.position = new UnityEngine.Vector3 &#123; x = Mathf.Cos(positionFactor) * radius, y = height, z = Mathf.Sin(positionFactor) * radius &#125;; cameraSigleton.transform.LookAt(Vector3.zero, Vector3.up); &#125;&#125; 下面这个代码要挂在场景中（建议挂在相机上） public class CameraSingleton : MonoBehaviour&#123; public static CameraSingleton Instance &#123; get; private set; &#125; private void Awake() &#123; if (Instance != null) &#123; Destroy(gameObject); return; &#125; Instance = this; &#125; [SerializeField] private float startRadius; [SerializeField] private float endRadius; [SerializeField] private float startHeight; [SerializeField] private float endHeight; [SerializeField] private float speed; public float RadiusAtScale(float scale) =&gt; Mathf.Lerp(startRadius, endRadius, 1 - scale); public float HeightAtScale(float scale) =&gt; Mathf.Lerp(startHeight, endHeight, 1 - scale); public float Speed =&gt; speed;&#125; 锐评 就这个简单的小demo，我的编辑器就卡死崩溃了多次，尤其是当我保存编译一个有报错的System文件时，几乎必然要用任务管理器杀项目，太不稳定了 而且这个ECS不仅跟Mono差异巨大，还和0.5版本的ECS差异也巨大，所有人都对这个系统不熟，官方也没提供一些特别好的适普的教程 如果是用Unity做小项目，完全不需要ECS，你的性能瓶颈大概率是渲染和资产。把粒子特效砍一砍，查看一下场景中有没有面数惊人的模型，模型是否有LOD，是否针对设备做了渲染分级，控制场景中实时光源数量，砍掉一些昂贵而作用不明显的渲染feature（比如基于快速傅里叶的水，比如高精度的布料、破坏仿真） 此外我诚心建议Unity把重点放在Editor上，实现一套能用的地表编辑器、动画编辑器、资产编辑器、大世界分块编辑器。引擎好不好用，关键靠Editor，你就算架构设计的再好，再适合客制化，小公司没精力没技术魔改，大公司不稀罕你的原生功能，甚至很多公司跟你闹掰转UE了，你在大型项目中有半点优势吗？ 参考 https://www.youtube.com/watch?v=IO6_6Y_YUdE https://www.tmg.dev/tuts/zombieupdate/ https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html 《为实现极限性能的面向数据编程范式》叶劲峰 GDC 2005","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"},{"name":"ECS","slug":"ECS","permalink":"https://reubensun.com/tags/ECS/"}]},{"title":"Unity小球移动","slug":"game/Catlike小球移动","date":"2023-07-01T17:01:25.000Z","updated":"2025-03-18T07:16:48.445Z","comments":true,"path":"game/Catlike小球移动/","permalink":"https://reubensun.com/game/Catlike%E5%B0%8F%E7%90%83%E7%A7%BB%E5%8A%A8/","excerpt":"","text":"Unity小球移动 摘自Catlike的Movement Tutorial 小球移动 创建小球 使用Input System包，在Package Manager中Unity包搜索即可 创建Input Action资产 创建小球，包含拖尾渲染器、Player Input组件、脚本SphereMovement.cs 移动脚本 public class SphereMovement : MonoBehaviour&#123; [FormerlySerializedAs(&quot;movementSpeed&quot;)] [Header(&quot;Movement Setting&quot;)] [SerializeField, Range(0f, 10f)] private float maxSpeed = 5f; [SerializeField, Range(0f, 100f)] private float maxAcceleration = 10f; [SerializeField] Rect allowedArea = new Rect(-5f, -5f, 10f, 10f); public Vector3 Velocity; private PlayerInput _input; private Vector2 _moveInput; private void Start() &#123; _input = GetComponent&lt;PlayerInput&gt;(); Velocity = Vector3.zero; &#125; private void Update() &#123; _moveInput = _input.actions[&quot;Move&quot;].ReadValue&lt;Vector2&gt;(); // 根据输入得到预期速度 Vector3 desiredVelocity = new Vector3(_moveInput.x, 0, _moveInput.y) * maxSpeed; // 当前时间片速度的最大变化量 float maxSpeedChange = maxAcceleration * Time.deltaTime; // |target - current| &lt;= maxDelta ? target : current + maxDelta Velocity.x = Mathf.MoveTowards(Velocity.x, desiredVelocity.x, maxSpeedChange); Velocity.z = Mathf.MoveTowards(Velocity.z, desiredVelocity.z, maxSpeedChange); // 新速度在当前时间片的位移 Vector3 displacement = Velocity * Time.deltaTime; // 判断新位置是否越界 Vector3 newPosition = transform.localPosition + displacement; if (newPosition.x &lt; allowedArea.xMin) &#123; newPosition.x = allowedArea.xMin; Velocity.x = 0f; &#125; else if (newPosition.x &gt; allowedArea.xMax) &#123; newPosition.x = allowedArea.xMax; Velocity.x = 0f; &#125; if (newPosition.z &lt; allowedArea.yMin) &#123; newPosition.z = allowedArea.yMin; Velocity.z = 0f; &#125; else if (newPosition.z &gt; allowedArea.yMax) &#123; newPosition.z = allowedArea.yMax; Velocity.z = 0f; &#125; // 修改位置 transform.localPosition = newPosition; &#125;&#125;","categories":[{"name":"game","slug":"game","permalink":"https://reubensun.com/categories/game/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"blender使用笔记","slug":"dcc/blender使用笔记","date":"2023-06-30T10:01:25.000Z","updated":"2025-03-18T07:16:48.447Z","comments":true,"path":"dcc/blender使用笔记/","permalink":"https://reubensun.com/dcc/blender%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Blender使用笔记 建模 移动模型 快捷键G 网格合并 选中模型，按快捷键ctrl+J 网格按材质切分 选中模型 进入Edit Mode Mesh——Separate——By Material Modify 布尔建模 Object Mode——选中物体——Add Modifier——Boolean——Apply 有Difference、Union等选择 曲面细分 如果要制作圆弧形模型，可以先创建一些整N边形，然后添加Modifier曲面细分（注意要在Object Mode） Remesh 一些模型的拓扑非常糟糕，可以用Remesh进行重新拓扑，不过这对模型的破坏非常严重 Object Mode——选中物体——Add Modifier——Remesh——Apply 减面 减面是一个非常普遍的需求 Object Mode——选中物体——Add Modifier——Decimate——Apply 模型添加材质 吸附 Object Mode——选中物体——Add Modifier——Shrinkwrap——选择Target——选择顶点组——Apply 如果不选择顶点组，就会整个模型全部吸附 UV UV接缝 在自动展开前，先选中面，Mark Seam（会有红色的线） 比如一个圆柱，可以把环形切一下，然后在竖边切一条 自动展UV2 点击Mesh，在Data处添加UV Maps 选择要修改的uvmap（看不见的话向右拉） 点击UV Editor——按Table开启编辑模式——全选模型——设置Select Mode为面——对模型按右键——UV Unwrap Faces——Smart UV Project 左侧栏工具 斜边 快捷键Ctrl+B 进入Edit Mode——选择边——Edge——Bevel Edges——拖动鼠标 抬升面 渐入Edit Mode——选中面——Shrink/Fatten（在左侧栏） 环切 快捷键Ctrl+R 插入面 快捷键 I，可以在一个圆面里切一个小圆 进入Edit Mode——选择面——Inset Face——拖动鼠标 拓展区域 快捷键 E，可以选中一个圈后复制一份，然后缩放、拖拽 选中一圈边 按住shift alt后用鼠标点击一条边 进入Edit Mode——选择一条边——Select——Select Loops——Edge Loops 点吸附 将一个点吸附到另一个点上，可以实现填补三角形的作用 进入Edit Mode——选择两个点——按M——选择末端点 桥接面 进入Edit Mode——选择两条边——Edge——Bridge Edge Loops Cursor 游标，一个有红白相间的圆，可以用于控制旋转、缩放中心，也可以指定新添加物体的位置 设置游标 Mesh——Snap——Cursor to Selected 使用游标为物体控制中心 选中物体——Object——Set Origin——Origin to 3D Cursor 吸附 让一个物体按规则吸附在其他物体上 顶点组 在Vertex Group中新建组，选择顶点，设置权重，Assign到组中 PCG PCG的核心是几何节点 vrm 一组包含blendshape的模型 最近在找带有脸部Blendshape的角色模型，尤其是使用了苹果ARKit标准，于是我发现了很多vrm模型 Blender不原生支持vrm模型，于是需要下一个插件 VRM Add on 安装后直接import模型 导出到Unity 之前遇到一个问题，vrm模型导出fbx再导入Unity，却在Skin mesh renderer中看不到Blendshape 解决方案：在Blender中删掉多余的Modify，剩下Armature，再重新导出 MMD 安装 blender_mmd_tools插件下载地址 Edit &gt; Perferences &gt; Add-ons &gt; Install &gt; 选择第二步下载的压缩包 激活插件，找到导入的插件，点亮左边的checkbox即可 当你看到如下内容，说明安装成功（这个小箭头确实不明显，容易找不到） 点击下图的Import即可导入模型和动画，在mmd面板可以导出mmd信息，使用blender的File可以导出fbx模型，后续在Unity、AccuRog软件使用 关闭IK 有时我们发现MMD角色的腿不动，很有可能是因为定位到一个非常远的IK，关掉即可（变为灰色） 渲染视频 调整camera位置 使用选择的相机为View 选择一个相机——View——Cameras——Activate Camera 再次执行可以恢复自由相机 调整输出 设置分辨率、Frame Rate、将渲染结果为FFmpeg Video，Encoding为MPEG-4就能输出mp4视频 渲染动画 播放Frame Range的动画，并保存相机渲染结果为视频 Render——Render Animation Auto Rig Pro 插件购买地址Auto Rig Pro，脚本开发建议使用bpy==3.6 自动棒骨 Auto Rig Pro可以绑定生成控制器，便于手动制作动画。如果单纯为了自动绑定人型骨骼，比如MMD2FBX，更适合AccuRig 准备模型 Smart模型 添加点 点击GO！完成 点击Match to Rig 进入Edit模式，点击Mesh，点击Bind 模型导出 导出为Unity能使用的骨骼模型 Remap动画 将动画Remap到骨架上，是的Target骨架播放Source骨架的动画 如果你没有remap.bmap，那么你需要在Object Mode同时选择动画骨架和模型骨架，进入Pose Mode，依次填写Target Bones内容，制作完成后可以Export bmap，以便后续使用 如果原始动画的初始状态和目标模型的初始状态不同，比如一个是A-Pose，一个是T-Pose，我们需要使用第6步，依次点击动画骨架，点击Copy Selected Bones Rotation，即可将动画的初始姿态转为目标模型的初始姿态 脚本 Blender Python 简易参考 指Python bpy脚本，可以在Blender中使用，也可以在Python中作为一个Headless库使用 pip3 install bpy Windows和Linux下bpy版本不同，Windows下python3.11对应bpy==4.3 打开提示 在偏好设置中打开Python Tooltips，将鼠标停滞在按钮、属性上时，都会提示要如何调用，在info窗口可以看到几乎每一次操作对应的命令，便于脚本开发 安装插件 blender有很多好用的插件，也可以用在bpy脚本中 如果不知道插件的名称，可以先UI启动Blender，安装并开关对应插件，在python窗口输入print(bpy.context.preferences.addons.keys())，变化的那一个包，就是你想要的插件的名称 bpy.ops.preferences.addon_install(filepath=f&quot;&#123;os.getcwd()&#125;/xxx.zip&quot;)bpy.ops.preferences.addon_enable(module=&quot;yyy&quot;)print(bpy.context.preferences.addons.keys()) 输出场景内容 for obj in bpy.context.scene.objects: print(f&quot;- &#123;obj.name&#125; (&#123;obj.type&#125;)&quot;) 删除初始状态 # 输出python脚本所在位置print(os.getcwd())# 删除初始状态的几个物体bpy.ops.object.select_all(action=&#x27;SELECT&#x27;)for obj in bpy.data.objects: print(&quot;Name: &quot;, obj.name)print(&quot;Delete all objects&quot;)bpy.ops.object.delete(use_global=False, confirm=False) 打开项目 bpy.ops.wm.open_mainfile(filepath=&quot;template/tapmo.blend&quot;) 渲染视频 output_path = &quot;output/&quot;os.makedirs(output_path, exist_ok=True)bpy.context.scene.frame_start = 1 # 动画开始帧bpy.context.scene.frame_end = 120 # 动画结束帧bpy.context.scene.render.engine = &#x27;BLENDER_EEVEE&#x27;bpy.context.scene.render.filepath = output_pathbpy.ops.render.render(animation=True)","categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"},{"name":"Blender","slug":"Blender","permalink":"https://reubensun.com/tags/Blender/"}]},{"title":"3dmax使用笔记","slug":"dcc/Max使用笔记","date":"2023-06-28T10:01:25.000Z","updated":"2025-03-18T07:16:48.447Z","comments":true,"path":"dcc/Max使用笔记/","permalink":"https://reubensun.com/dcc/Max%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"3dmax使用笔记 3dmax是一个被广泛使用的DCC工具，我之前对这个软件不是很熟悉，于是记录一些平时遇到的常用操作 材质编辑 选中模型，按键盘m，打开材质界面。点击吸管后再点击模型，即可得到该网格所使用的材质列表 点击Modes——Slate Material Editor，即可打开材质连连看 网格塌缩 我们预览模型动画时，想要导出某一帧的网格，而且希望这个网格位置本身被修改，而非运行时被骨骼驱动，于是需要做塌缩 选中网格 在窗口左侧，我们可以看到当前FBX是由哪些东西组成的（比如Mesh、骨骼），如果我们想同时选中所有的Mesh，可以按键盘h，打开快速选中界面，在最上一栏仅选择Mesh（图中蓝色背景的圆球），筛选的就是所有Mesh 塌缩 选中网格后对模型按右键——Convert To：——Convert to Editable Poly，即可完成塌缩","categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"}],"tags":[{"name":"3dmax","slug":"3dmax","permalink":"https://reubensun.com/tags/3dmax/"}]},{"title":"C++模版","slug":"program/C++template","date":"2023-06-28T10:01:25.000Z","updated":"2025-03-18T07:16:42.965Z","comments":true,"path":"program/C++template/","permalink":"https://reubensun.com/program/C++template/","excerpt":"","text":"C++模版 《C++ Templates: The Complete Guide》笔记 为什么使用模版 为了实现泛型 如果不使用泛型，对于一些通用的函数或容器，比如print、vector，我们可能需要逐个实现他们的函数，尽管这些函数的功能十分类似（可能相同），低效复杂而且难以维护 在C++标准库中使用了大量模版 模板的缺点 难以阅读、调试 容易触发编译报错（比如将&lt;&lt;运算符识别为模板展开） 闭源软件不友好（许多开源软件会提供.h和.lib，如果使用模板，头文件中就会暴露实现） 函数模版 模版定义 template&lt;typename T&gt;T getMax(T a, T b)&#123; return a &gt; b ? a : b;&#125;int main() &#123; std::cout &lt;&lt; getMax(5, 6) &lt;&lt; std::endl; // 6 std::cout &lt;&lt; getMax(5.1, 6.1) &lt;&lt; std::endl; // 6.1 return 0;&#125; 这里T是类型参数，我们可以使用任意字符，不过习惯上使用T 处于历史原因，我们也可以使用class来代替typename template&lt;class T&gt;T getMax(T a, T b)&#123; return a &gt; b ? a : b;&#125; 模版实例化 在编译阶段，模版会被编译为多个独立的实体，比如我们调用getMax(5, 6)，编译器会编译出： int getMax(int a, int b)&#123; return a &gt; b ? a : b;&#125; 像这样用具体类型int取代类型参数T的过程叫做实例化 两阶段编译检查 模版分为两步编译：模版定义阶段、模版实例化阶段 在模版定义阶段，不会对类型参数做检查，比如你让两个T对象进行大小比较（a &gt; b），编译器不会去质疑T对象是否支持比较操作符 在模版实例化阶段，模版会再次被检查（尤其是类型参数），如果编译器发现T对象不支持比较操作符，就会报错 我们发现，当我们在实例化一个模版时，编译器需要看到模版的完整定义，但C++函数采用声明和实现分离的思想，函数在编译阶段只需要声明，这出现了冲突。简单的做法是将模版的实现写在头文件中 类型推断 我们在调用getMax时，会根据传入的参数类型，自动推断出T的类型，但这种推断是有限制的 getMax(4, 5); // OK, T is intgetMax(4.1, 5.1); // OK, T is doublegetMax(4, 5.1); // Error, 无法正确推断T的类型const int a = 1;getMax(2, a); // OK, T is int, a的const会被decay掉int b = 2;int &amp;c = b;getMax(2, c); // OK, T is int, c的引用会被decay掉 decay 退化（decay）是指数组变指针，函数变指针，左值变右值的过程 void foo(int arr[])&#123;...&#125;int main()&#123; int myArray[5] = &#123;1, 2, 3, 4, 5&#125;; foo(myArray); // 等价于foo(&amp;myArray[0])&#125; 在上面这段代码，数组myArray被转化为指向数组第一个元素的指针 void foo()&#123;...&#125;int main()&#123; void (*ptr)() = foo; ptr();&#125; 在上面这段代码，函数foo被转化为函数指针 const int a = 1;int b = 2;int &amp;c = b;getMax(2, a); // OK, T is int, a的const会被decay掉getMax(2, c); // OK, T is int, c的引用会被decay掉 在上面这段代码，int&amp;和const int&amp;都被转化为对应的右值 我们可以使用type_traits库来检测decay的合法性 template&lt;typename T, typename U&gt;struct decay_equiv: std::is_same&lt;typename std::decay&lt;T&gt;::type, U&gt;::type &#123;&#125;;int main()&#123; std::cout &lt;&lt; std::boolalpha &lt;&lt; decay_equiv&lt;int&amp;, int&gt;::value &lt;&lt; std::endl; // true std::cout &lt;&lt; std::boolalpha &lt;&lt; decay_equiv&lt;const int&amp;, int&gt;::value &lt;&lt; std::endl; // true&#125; std::boolalpha的作用是将bool类型以true/false的形式打印出来，而非1/0 多个模板参数 当模板有多个参数时，我们可以用&lt;&gt;指定参数类型 在后面的类型，如果可以自动推断出来，可以不写 template&lt;typename RT, typename T1, typename T2&gt;RT getMax(T1 a, T2 b)&#123; return a &gt; b ? a : b;&#125;int main() &#123; std::cout &lt;&lt; getMax&lt;int, double, int&gt;(4, 7.2) &lt;&lt; std::endl; // 7 std::cout &lt;&lt; getMax&lt;int&gt;(4, 7.2) &lt;&lt; std::endl; // 7&#125; 返回类型推断 极其推荐这样写 上面的返回值类型是手动指定的，很容易出现编写错误，因此我们一般会让编译器来角色返回值类型 template&lt;typename T1, typename T2&gt;auto getMax(T1 a, T2 b) -&gt; decltype(a &gt; b ? a : b)&#123; return a &gt; b ? a : b;&#125;int main() &#123; std::cout &lt;&lt; getMax(4, 7.2) &lt;&lt; std::endl; // 7.2 std::cout &lt;&lt; getMax(8, 7.2) &lt;&lt; std::endl; // 8&#125; 我们发现这样写的返回类型由?:运算符的执行结果决定，7.2大于4，于是返回类型为double，8大于7.2，于是返回类型为int 进一步的，若传入的数据是引用类型，可以使用类型萃取，不过一般情况下，上面这种写法就够了 template&lt;typename T1, typename T2&gt;auto getMax2(T1 a, T2 b) -&gt; typename std::decay&lt; decltype(a &gt; b ? a : b)&gt;::type&#123; return a &gt; b ? a : b;&#125; 公共类型 Common Type C++11提供了一种更一般的类型，用于得到两个模板参数的公共类型 template&lt;typename T1, typename T2&gt;std::common_type_t&lt;T1, T2&gt; getMax3(T1 a, T2 b)&#123; return a &gt; b ? a : b;&#125; 默认参数类型 我们可以给参数指定默认值，但要同时给T一个对应默认参数 template&lt;typename T = double&gt;void foo(T a = 3.14)&#123; std::cout &lt;&lt; a &lt;&lt; std::endl;&#125;int main() &#123; foo(15); // 15 foo(); // 3.14&#125; 重载 函数模板可以与同名的普通函数共存，且优先调用普通函数 template&lt;typename T&gt;void foo(T a)&#123; std::cout &lt;&lt; a &lt;&lt; std::endl;&#125;void foo(int a)&#123; std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; a &lt;&lt; std::endl;&#125;int main() &#123; foo(1); // int: 1 foo(3.14); // 3.14 &#125; 函数模板也可以和其他同名但参数类型数量不同的函数模板共存，但必须保证在调用模板时，有且仅有一个模板能匹配 template&lt;typename T1, typename T2&gt; auto max (T1 a, T2 b) &#123; return b &lt; a ? a : b; &#125;template&lt;typename RT, typename T1, typename T2&gt; RT max (T1 a, T2 b) &#123; return b &lt; a ? a : b; &#125; 注意事项 使用值传递 一般而言，函数参数中，简单类型值传递，复杂的类型引用传递。但在模板编程中，我们更倾向于使用值传递 值传递的优点： 语法简单 编译器能更好地优化 移动一般比拷贝成本更低 某些情况没有移动或拷贝 模板既可以适用于复杂类型，也可以适用于简单类型，盲目使用引用会影响简单类型的使用 调用者可以主动使用std::ref()和std::cref() string literal和raw array使用引用传递会出现问题 类模板 类也可以使用模板，STL中的容器就是这样实现的 类模版中的模版成员函数，只有在被调用时才会实例化 类模版的模版参数，要能支持模版函数中使用的各种操作和运算符 template&lt;typename T&gt;class Stack&#123;private: std::vector&lt;T&gt; elems;public: void push(T const&amp; elem); void pop(); T const&amp; top() const; bool empty() const &#123; return elems.empty(); &#125;&#125;;template&lt;typename T&gt;void Stack&lt;T&gt;::push(const T &amp;elem) &#123; elems.push_back(elem);&#125;template&lt;typename T&gt;void Stack&lt;T&gt;::pop() &#123; elems.pop_back();&#125;template&lt;typename T&gt;T const&amp; Stack&lt;T&gt;::top() const &#123; assert(!elems.empty()); // 断言语句，若条件不满足，程序会终止，仅在Debug模式生效 return elems.back();&#125; 由于历史原因，C++11以前的模版，两个相邻尖括号间要有空格，如Stack&lt;Stack&lt;int&gt; &gt;，在C++11之后就不再需要了 静态成员 template&lt;typename T&gt;class Foo&#123;public: static int count;&#125;;template&lt;typename T&gt;int Foo&lt;T&gt;::count = 0;int main() &#123; Foo&lt;int&gt;::count = 10; Foo&lt;double&gt;::count = 20; std::cout &lt;&lt; Foo&lt;int&gt;::count &lt;&lt; std::endl; // 10 std::cout &lt;&lt; Foo&lt;double&gt;::count &lt;&lt; std::endl; // 20&#125; 特例化 对于特定的类型，我们可以进行特例化，可以做针对性的优化 template&lt;&gt;class Stack&lt;std::string&gt; &#123;...&#125;; 特例化也可以部分特例化 template&lt;typename T&gt;class Stack&lt;T*&gt; &#123;...&#125;; 可以多模版参数特例化，可以给予默认模版参数 类型别名 类型别名只是为已经存在的类型定义一个别名，并没有创建新类型，可以用typedef或using实现 typedef-name： typedef Stack&lt;int&gt; IntStack; alias declaration using IntStack2 = Stack&lt;int&gt;; alias declaration也可以被模版化，被称为alias templates template&lt;typename T&gt;using MyStack = Stack&lt;T&gt;; 非类型模版参数 所谓的非类型模版参数，就是不用typename T作为模版参数 下面是使用array实现Stack的代码，用户可以手动指定栈容量，我们使用了std::size_t作为非类型模版参数 template&lt;typename T, std::size_t Maxsize&gt;class Stack&#123;private: std::array&lt;T, Maxsize&gt; elems; std::size_t elemCount;public: Stack(); void push(T const&amp; elem); void pop(); T const&amp; top() const; bool empty() const &#123; return elemCount == 0; &#125; std::size_t size() const &#123; return elemCount; &#125;&#125;;template&lt;typename T, std::size_t Maxsize&gt;Stack&lt;T, Maxsize&gt;::Stack(): elemCount(0) &#123;&#125;template&lt;typename T, std::size_t Maxsize&gt;void Stack&lt;T, Maxsize&gt;::push(const T &amp;elem) &#123; assert(elemCount &lt; Maxsize); elems[elemCount] = elem; ++elemCount;&#125;template&lt;typename T, std::size_t Maxsize&gt;void Stack&lt;T, Maxsize&gt;::pop() &#123; assert(!elems.empty()); --elemCount;&#125;template&lt;typename T, std::size_t Maxsize&gt;T const&amp; Stack&lt;T, Maxsize&gt;::top() const &#123; assert(!elems.empty()); return elems[elemCount-1];&#125;int main() &#123; Stack&lt;int, 10&gt; st10; st10.push(15); std::cout &lt;&lt; st10.top() &lt;&lt; std::endl;&#125; 值得注意的是，Stack&lt;int, 10&gt;和Stack&lt;int, 20&gt;是两种不同的类型，由于没有定义隐式或显示的转换规则，我们不能使用一个取代另一个，也不能把一个赋值给另一个 有效类型 非类型模版参数只能是整形、枚举、指向对象/函数/成员的指针、指向对象/函数的左值引用、nullptr template&lt;double VAT&gt; //!!!, 这个是错误的，因为double不能作为非类型模版参数double process(double v)&#123; return v * VAT;&#125; 若表达式中使用了&gt;，要用()包裹起来 template&lt;int I, bool B&gt;class C;int main()&#123; C&lt;42, sizeof (int &gt; 4)&gt; c; // ERROR! 被截断为C&lt;42, sizeof (int &gt;了 C&lt;42, (sizeof (int) &gt; 4)&gt; c; // OK&#125; auto template&lt;typename T, auto Maxsize&gt;class Stack&#123;private: std::array&lt;T, Maxsize&gt; elems; std::size_t elemCount;public: using size_type = decltype(Maxsize); // !!!, 用于推断Maxsize类型 Stack(); void push(T const&amp; elem); void pop(); T const&amp; top() const; bool empty() const &#123; return elemCount == 0; &#125; size_type size() const &#123; return elemCount; &#125;&#125;; 变参模版 就是接受一组数量可变的参数 template&lt;typename T&gt;void print(T arg)&#123; std::cout &lt;&lt; arg &lt;&lt; &quot; &quot;;&#125;template&lt;typename T, typename... Types&gt;void print(T first, Types... args)&#123; print(first); print(args...);&#125;template&lt;typename C, typename... Index&gt;void printElems(C const&amp; coll, Index... id)&#123; print(coll[id]...);&#125;int main() &#123; print(&quot;hello&quot;, &quot;world&quot;, 1314); // hello world 1314 int a[] = &#123;1, 2, 3, 4, 5, 6, 7&#125;; printElems(a, 2, 3); // 3 4&#125; 折叠表达式 几乎所有二元运算符都可以用于折叠表达式 template&lt;typename ...T&gt;auto getSum(T...s)&#123; return (...+s); // 等同于((s1 + s2) + s3)...&#125;int main() &#123; std::cout &lt;&lt; getSum(1, 2, 3, 4, 5, 6, 7, 8, 9) &lt;&lt; std::endl; // 45&#125; 基础技巧 typename template&lt;typename ...T&gt;void foo(T const&amp; coll)&#123; T::const_interator pos; // Error! 会被认为是静态成员 typename T::const_interator pos; // OK! const_interator是定义在T内的类型&#125; 零初始化 若一个类型没有默认构造函数（比如基础类型和指针类型），被初始化前其值是未定义的，我们可以使用值初始化 template&lt;typename T&gt;void foo1()&#123; T x &#123;&#125;; // 零初始化 std::cout &lt;&lt; x &lt;&lt; std::endl;&#125;template&lt;typename T&gt;void foo2()&#123; T x; std::cout &lt;&lt; x &lt;&lt; std::endl;&#125;int main() &#123; foo2&lt;int&gt;(); // 1, 为啥这是1啊, 因为未定义所以错了 foo2&lt;int&gt;(); // 1 foo1&lt;int&gt;(); // 0, 通过零初始化所以对了 foo2&lt;int&gt;(); // 0, 很难绷, 为啥你又变成0了？未定义果然不靠谱&#125; 我们可以在默认构造函数中使用零初始化 class Foo&#123;private: T x;public: Foo() : x&#123;&#125; &#123; &#125; void print()&#123; std::cout &lt;&lt; x; &#125;&#125;;int main() &#123; Foo&lt;int&gt; x; x.print(); // 0&#125; 如果是非静态成员，也可以这样写 template&lt;typename T&gt;class Foo&#123;private: T x &#123;&#125;;public: void print()&#123; std::cout &lt;&lt; x; &#125;&#125;; this 对于类模版，若基类也依赖于模版参数，那么子类在调用基类的成员时要使用this-&gt;或Base&lt;T&gt;::修饰 template&lt;typename T&gt;class Base&#123;public: void print()&#123; std::cout &lt;&lt; &quot;Hello world&quot;; &#125;&#125;;template&lt;typename T&gt;class Foo: Base&lt;T&gt; &#123;public: void foo()&#123; this-&gt;print(); // !这里要使用this-&gt;不然调用不到Base的成员 &#125;&#125;;int main() &#123; Foo&lt;int&gt; f; f.foo(); // Hello world&#125; 成员模版 类的成员也可以是模版，而且模版参数可以不同 template&lt;typename T&gt;class Stack&#123;private: std::deque&lt;T&gt; elems;public: void push(T const&amp;); void pop(); T const&amp; top() const; bool empty() const &#123; return elems.empty(); &#125; template&lt;typename T2&gt; Stack&amp; operator= (Stack&lt;T2&gt; const&amp;); template&lt;typename &gt; friend class Stack; // 为了访问其他Stack实例的私有成员&#125;;template&lt;typename T&gt;template&lt;typename T2&gt;Stack&lt;T&gt;&amp; Stack&lt;T&gt;::operator=(const Stack&lt;T2&gt; &amp;op2) &#123; elems.clear(); elems.insert(elems.begin(), op2.elems.begin(), op2.elems.end()); return *this;&#125;int main() &#123; Stack&lt;float&gt; floatStack; for(int i = 0; i &lt; 5; i++)&#123; float n = 3.14 * i; floatStack.push(n); std::cout &lt;&lt; n &lt;&lt; &quot; &quot;; // 0 3.14 6.28 9.42 12.56 &#125; std::cout &lt;&lt; std::endl; Stack&lt;int&gt; intStack; intStack = floatStack; while (!intStack.empty())&#123; std::cout &lt;&lt; intStack.top() &lt;&lt; &quot; &quot;; // 12 9 6 3 0 intStack.pop(); &#125;&#125; lambda lambda表达式本质上是成员模版的简化 [](auto x, auto y)&#123; return x + y;&#125; 变量模版 变量也可以使用模版，必须指定类型 template&lt;typename T = long double&gt;constexpr T pi &#123;3.1415926535897932385&#125;;int main() &#123; std::cout &lt;&lt; pi&lt;float&gt; &lt;&lt; std::endl; std::cout &lt;&lt; pi&lt;double&gt; &lt;&lt; std::endl; std::cout &lt;&lt; pi&lt;&gt; &lt;&lt; std::endl;&#125; C++17中类型萃取就是使用了变量模版 namespace std&#123; template&lt;typename T&gt; constexpr bool is_const_v = is_const&lt;T&gt;::value;&#125; 模版参数模版 模版参数也可以是一个类模版 template&lt;typename T, template&lt;typename Elem&gt; class Cont = std::deque&gt;class Stack&#123;private: Cont&lt;T&gt; elems;public: ...&#125;; 移动语义 移动的本质是所有权的转移，这里不过多赘述 移动（move）：将原对象拷贝或赋值给目标对象时，若原对象马上要被销毁，可以将原对象对内部资源和状态的所有权直接转移给目标对象，避免了非必要的拷贝和临时对象 禁用函数模版 C++11提供了辅助模版std::enable_if&lt;&gt;，可以在编译期间忽略掉一些函数模版 注意看，foo()前面的返回值类型是由std::enable_if决定的， template&lt;typename T&gt;typename std::enable_if&lt;(sizeof (T) &gt; 4)&gt;::typefoo()&#123; std::cout &lt;&lt; sizeof (T) &lt;&lt; std::endl;&#125;int main() &#123; foo&lt;int&gt;(); // Error! 没有找到foo, int size 4 foo&lt;double&gt;(); // OK, double size 8 foo&lt;long long&gt;(); // OK, long long size 8&#125; 若(sizeof (T) &gt; 4)为false，根据模版中SFINAE（substitute failure is not an error）规则，替换失败不是错误，而是会将这个函数模版忽略掉，于是foo&lt;int&gt;()会报找不到函数的错 若(sizeof (T) &gt; 4)为true，std::enable_if&lt;&gt;会被拓展为void，如果你给了第二个参数T，std::enable_if&lt;&gt;会被拓展为T类型 template&lt;typename T&gt;std::enable_if_t&lt;(sizeof (T) &gt; 4), T&gt;foo()&#123; std::cout &lt;&lt; sizeof (T) &lt;&lt; std::endl;&#125; 更明智的写法是 template&lt;typename T&gt;using EnableIfSizeGreater4 = std::enable_if_t&lt;(sizeof (T) &gt; 4)&gt;;template&lt;typename T, typename = EnableIfSizeGreater4&lt;T&gt;&gt;void foo()&#123; std::cout &lt;&lt; sizeof (T) &lt;&lt; std::endl;&#125; 禁用构造函数模版 由于转移语义的存在，构造函数的参数类型很可能是错误的，比如传入了一个右值引用 Person(std::string&amp;&amp; s); // 我们希望禁用这个构造函数 下面是一个例子 template&lt;typename T&gt;using EnableIfString = std::enable_if_t&lt;std::is_convertible_v&lt;T, std::string&gt;&gt;;class Person&#123;private: std::string name;public: template&lt;typename STR, typename = EnableIfString&lt;STR&gt;&gt; explicit Person(STR&amp;&amp; n) : name(std::forward&lt;STR&gt;(n)) &#123; std::cout &lt;&lt; &quot;模版构造函数 &quot; &lt;&lt; name &lt;&lt; std::endl; // 使用了完美转发 &#125; Person(Person const&amp; p) : name(p.name) &#123; std::cout &lt;&lt; &quot;拷贝构造函数 &quot; &lt;&lt; name &lt;&lt; std::endl; &#125; Person(Person&amp;&amp; p) : name(std::move(p.name)) &#123; std::cout &lt;&lt; &quot;移动构造函数 &quot; &lt;&lt; name &lt;&lt; std::endl; &#125;&#125;;int main() &#123; std::string s = &quot;sname&quot;; Person p1(s); // 模版构造函数 sname Person p2(&quot;temp&quot;); // 模版构造函数 temp Person p3(p1); // 拷贝构造函数 sname Person p4(std::move(p1)); // 移动构造函数 sname&#125; 我们没法禁用拷贝和移动构造函数，因为我们用成员函数来替代这些函数时，这些函数还会生成默认构造函数 concept enable_if的语法非常丑，而且还额外使用了一个模版参数，使得代码不易读懂 我们需要的是一个能对函数施加限制的语言特性，当限制不满足时函数会被忽略掉，于是C++决定引入concept 模板元编程 模板在编译器实例化，在实例化时可以进行简单的计算，这就是模板元编程 下面是用模板元判断一个数是不是质数 template &lt;unsigned int N, unsigned int Divisor&gt;struct IsPrime &#123; static constexpr bool value = (N % Divisor != 0) &amp;&amp; IsPrime&lt;N, Divisor - 1&gt;::value;&#125;;template &lt;unsigned int N&gt;struct IsPrime&lt;N, 2&gt; &#123; static constexpr bool value = (N % 2 != 0);&#125;;template &lt;unsigned int N&gt;constexpr bool isPrime = IsPrime&lt;N, N / 2&gt;::value;int main() &#123; constexpr unsigned int number = 17; if (isPrime&lt;number&gt;) &#123; std::cout &lt;&lt; number &lt;&lt; &quot; is a prime number.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; number &lt;&lt; &quot; is not a prime number.&quot; &lt;&lt; std::endl; &#125;&#125; decltype 选择合适的模板特化，也叫SFINAE template &lt;typename T, typename U&gt;auto add(T t, U u) -&gt; decltype(t + u) &#123; return t + u;&#125;int main() &#123; std::cout &lt;&lt; add(1, 2) &lt;&lt; std::endl; // int std::cout &lt;&lt; add(1, 1.5) &lt;&lt; std::endl; // double std::cout &lt;&lt; add(1, 1.5f) &lt;&lt; std::endl; // float return 0;&#125; if constexpr 编译器if template &lt;typename T&gt;float addIfFloat(T t) &#123; if constexpr (std::is_integral_v&lt;T&gt;) &#123; return t; &#125; return t + 1.0f;&#125; int main() &#123; std::cout &lt;&lt; addIfFloat(1) &lt;&lt; std::endl; // 1 std::cout &lt;&lt; addIfFloat(1.5f) &lt;&lt; std::endl; // 2.5&#125; 类型萃取 感觉不如C#的反射 用于编译期获得模板参数的性质，下面是判断一个类中是否有成员函数Execute()的示例 template &lt;typename T&gt;struct hasFunction_Execute &#123;private: template &lt;typename U&gt; static auto check(U* ptr) -&gt; decltype(std::declval&lt;U&gt;().Execute(), std::true_type&#123;&#125;); template &lt;typename U&gt; static std::false_type check(...);public: static constexpr bool value = decltype(check&lt;T&gt;(nullptr))::value;&#125;; struct Check &#123; void Execute() &#123; std::cout &lt;&lt; &quot;Check::someFunction() called.&quot; &lt;&lt; std::endl; &#125;&#125;;struct NoCheck &#123; &#125;;int main() &#123; if (hasFunction_Execute&lt;Check&gt;::value) &#123; Check obj; obj.Execute(); &#125; if (hasFunction_Execute&lt;NoCheck&gt;::value) &#123; // 不会执行到这里，因为NoCheck类没有Execute成员函数 &#125; return 0;&#125; 注意这里使用了std::declval，可以用作引用占位符","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"银河恶魔城设计理念学习","slug":"game/银河恶魔城设计理念学习","date":"2023-05-25T01:18:25.000Z","updated":"2025-03-18T07:16:48.445Z","comments":true,"path":"game/银河恶魔城设计理念学习/","permalink":"https://reubensun.com/game/%E9%93%B6%E6%B2%B3%E6%81%B6%E9%AD%94%E5%9F%8E%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"银河恶魔城设计理念学习 昨天跟魔方的策划沟通了一下，发现我之前的设计很不成熟，我所认为的Hook（比如“玩家因为缺少一个能力卡关了，于是去岔路口寻找其他能力”）原来只是这类游戏的共性（Pillar）， 银河恶魔城 能力锁 银河恶魔城大量使用了能力锁，使用低纬度的能力构成高纬度的钥匙，服务于后续游玩，能与关卡产生协同效应 道具锁（Item-Lock）：比如找到一把具体的钥匙道具开门开箱子，真实但不好玩，只能提供很低的心智挑战，或者带来一些消耗资源管理，比如做成一个玩家理论上可以通过，但由于玩家现在太弱了/太穷了而无法通过的软锁 谜题锁（Puzzle-Lock）：一段和游戏流程无关的解密，比如战神中敲钟、荒野之息中呀哈哈，能产生一次性的解密体验，常用于调整玩家游戏节奏 挑战锁（Challenge-Lock）：一段结合游戏中战斗、行动技巧的挑战，比如GTA中骑摩托车跑酷，荒野之息限时射箭 能力锁（Utility-Lock）：新能力解锁新区域，比如玩家得到了二段跳后，能跳到原来不能到达的平台，于是开放了更多的可探索内容 以打开桃色门为例：目标是打开桃色门，挑战锁得到开门的能力/钥匙，奖励是新区域。新区域中会有新的游玩内容，新的奖励/能力，于是形成了正反馈，形成扩张式探索 回路探索 银河恶魔城一般关键能力的获取顺序、关键boss的击杀顺序是固定的，因此流程是线性的。同时该游戏存在破序玩法，可收集道具和某些能力不是必须的，流程又是开放的 银河恶魔城中由于能力锁的存在，玩家无法通过某个房间后，会回到岔路探索其他房间，获得相关能力后再通过原本无法探索的房间，这个过程就是回路探索。一个探索过的房间，当玩家拥有更新的能力后，会有新的体验。（让我想到一些游戏，当你通关后来到新手村，很多人对你的称呼和态度发生变化，原本的困难的敌人也能做到一击必杀，故地重游也能有新的体验） 他建议我在设计地图时，先设计大块的区域功能和区域间的联系，再设计每个房间的整体设计，画出角色第一次进入房间的行为热线。 每个房间的作用围绕资源的布置、节奏的控制来分配；每个房间的内部结构结合这个区域的核心机制进行设计 一张绘制区域内小房间的布局；玩家从首次进入、取得能力、击败boss、进入下一区域的一个动线 游戏目标 游戏目标 游戏中玩家目标和设计师的目标可能不一致，从用户出发设计师最先注意的是体验目标 玩家目标：玩家在游戏设置的情景中被要求达到的结果（比如打到魔王、赚到一万个金币） 体验目标：设计师希望玩家通过游戏体验到的内容（比如了解某个文明的文化，掌握超人力量的满足感，感到恐惧、好奇） 设计目标：设计师希望通过具体的设计手法达到特定的产品效果（比如为长期运营创造空间，简洁扁平的交互设计） GMT G（Goal）：目标 M（Means）：达成目标的高阶手段 T（Tools）：将手段细分的具体可执行的低阶要素 GMT分为玩家目标的GMT和体验目标的GMT 关卡设计 参考 银河恶魔城入门 游戏设计逻辑 关卡设计","categories":[{"name":"game","slug":"game","permalink":"https://reubensun.com/categories/game/"}],"tags":[]},{"title":"银河战士like开发日志","slug":"game/银河战士like开发日志","date":"2023-05-17T23:01:25.000Z","updated":"2025-03-18T07:16:48.445Z","comments":true,"path":"game/银河战士like开发日志/","permalink":"https://reubensun.com/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/","excerpt":"","text":"银河战士like开发日志 终于把毕设忙完了，开始填坑了，首先就是这个银河战士like的游戏，说实话我已经很长时间没做过Gameplay开发了，上来就做这种高难度的动作射击，感觉有些蠢。不过多亏了Mix and Jam开源了一个教程，少走不少弯路。为了自我监督，把开发日志记录在案。说实话我GP水平很差，这个日志应该会踩不少坑 Unity 2021.3.22 URP Windows11，使用内置的Plastic SCM做版本管理（Unity对Plastic SCM支持较好，尽管我更喜欢Git和P4V） 1. 添加角色模型 使用Package Manager添加插件Input System，Player Input组件和Input Action文件均属于该插件 从Mixamo找一个人物模型，放入场景中 添加组件Character Controller（该组件会自带一个胶囊碰撞体，可以调整尺寸以适配角色） 添加组件Player Input 添加一个脚本PlayerController.cs 2. 配置Input Action文件 创建一个Input Action，添加一个Vector2类型的移动，一个跳跃按钮 将该文件拖入Player Input组件的Actions上 3. 编写移动脚本 public class Player : MonoBehaviour&#123; private PlayerInput input; private CharacterController controller; [Header(&quot;Movement Settings&quot;)] [SerializeField, Tooltip(&quot;水平移动速度&quot;)] private float movementSpeed = 6f; private Vector2 moveInput; private void Start() &#123; // 获取角色身上的组件 input = GetComponent&lt;PlayerInput&gt;(); controller = GetComponent&lt;CharacterController&gt;(); &#125; private void Update() &#123; // 读按键输入 moveInput = input.actions[&quot;Move&quot;].ReadValue&lt;Vector2&gt;(); // 若输入不为空，则使用CharacterController进行移动 bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f; if (isMoving) &#123; float hDir = moveInput.x &gt; 0 ? 1 : -1; controller.Move(Vector3.right * hDir * Mathf.Abs(moveInput.normalized.x * movementSpeed) * Time.deltaTime); &#125; &#125;&#125; 进入游戏后按AD键可以实现左右移动（注意坐标系，Unity的2D游戏通常会以x轴正方向为右，y轴正方向为上） 4. 移动动画 去mixamo找几段动画（动画存放在fbx文件中，将fbx导入unity后可以将动画片段抽离、切分），并创建一个Animation Controller 双击打开Animation Controller后，右键创建一个BlendTree，将该BlendTree与Entry相连，并修改BlendTree的参数名为MoveInput 双击进入BlendTree，按右键添加多个Motion，并调整他们的Threshold信息 在角色上添加Animator组件，并将上面创建的Animation Controller拖到上面 修改PlayerController.cs脚本，根据输入设置动画参数，并处理转向 private PlayerInput input;private CharacterController controller;+private Animator animator;private void Start()&#123; input = GetComponent&lt;PlayerInput&gt;(); controller = GetComponent&lt;CharacterController&gt;();+ animator = GetComponent&lt;Animator&gt;();&#125;private void Update()&#123; moveInput = input.actions[&quot;Move&quot;].ReadValue&lt;Vector2&gt;(); bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f; if (isMoving) &#123; float hDir = moveInput.x &gt; 0 ? 1 : -1; controller.Move(Vector3.right * hDir * Mathf.Abs(moveInput.normalized.x * movementSpeed) * Time.deltaTime);+ transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(moveInput.x != 0 ? Vector3.right * moveInput.normalized.x : Vector3.right * hDir), 0.1f); &#125;+ animator.SetFloat(&quot;MoveInput&quot;, Mathf.Abs(moveInput.normalized.x * movementSpeed), 0.2f, Time.deltaTime);&#125; 效果如下，感觉运动停止时有点粘滞感，还需要细调 5. 跳跃 跳跃是该游戏的核心，这只是我估摸着做的第一版，有一说一，手感稀烂 碰撞状态检测 创建脚本CollisionState.cs，并绑定到角色身上。该脚本用于判断角色和场景的关系，目前只做了和水平地表的检测 nearGround的作用是为了连跳 public class CollisionState : MonoBehaviour&#123; [SerializeField, Tooltip(&quot;地表的碰撞层&quot;)] private LayerMask groundLayer; [SerializeField, Tooltip(&quot;在地表上的检测距离&quot;)] private float testDistance = 0f; [SerializeField, Tooltip(&quot;靠近地表的检测距离&quot;)] private float nearDistance = 0.2f; public bool onGround; public bool nearGround; private float offset = 0.05f; private void Update() &#123; onGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, testDistance + offset, groundLayer); nearGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, nearDistance + offset, groundLayer); &#125;&#125; 环境设置 添加Ground碰撞层，并将场景物体设置为Ground（场景物体要有碰撞体） 注意设置角色身上的Ground Layer类型 角色跳跃 下面修改PlayerController.cs，添加跳跃逻辑 首先获取CollisionState脚本，以判断是否能进行跳跃 ...private Animator animator;+private CollisionState collisionState;...private void Start()&#123; ... animator = GetComponent&lt;Animator&gt;();+ collisionState = GetComponent&lt;CollisionState&gt;();&#125; 添加一些跳跃要用到的参数 [Header(&quot;Movement Settings&quot;)] [SerializeField, Tooltip(&quot;水平移动速度&quot;)] private float movementSpeed = 6f;+[SerializeField, Tooltip(&quot;重力&quot;)] +private float gravity = -9.8f;+[SerializeField, Tooltip(&quot;大跳的跳跃高度&quot;)] +private float jumpHeight = 5f;+[SerializeField, Tooltip(&quot;开始加速下落时的速度&quot;)] +private float fallingSpeedup = 10f;private Vector2 moveInput;+private bool jumpPressed = false;+private bool jumpPressDown = false;+private float verticalVelocity;+private bool moveAfterJump = false; // 移动中跳跃，还是跳跃后移动+private float herizontalDirection = 1f;+private bool keepJump = false; // 保持滞空 跳跃，包含起跳、滞空、落地三个过程。 nearGround比真实地表要高一点，于是可以在接近落地时跳跃，优化连跳手感 若按下跳跃键后不放，重力会比直接松开小，因而跳的更高，拥有更长的滞空时间。此外若向下掉落的速度小于fallingSpeedup，仍受较小的重力。 当向下落地时遇到地面，速度为0 private void Update()&#123; moveInput = input.actions[&quot;Move&quot;].ReadValue&lt;Vector2&gt;();+ jumpPressDown = input.actions[&quot;Jump&quot;].WasPressedThisFrame();+ jumpPressed = input.actions[&quot;Jump&quot;].IsPressed();+ #region 跳跃+ // 起跳+ if (jumpPressDown &amp;&amp; collisionState.nearGround)+ &#123;+ verticalVelocity = Mathf.Sqrt(2 * Mathf.Abs(gravity) * jumpHeight);+ moveAfterJump = Mathf.Abs(moveInput.normalized.x) &lt; 0.3f; // 判断起跳时移动速度+ keepJump = true;+ &#125;+ // 滞空+ if (keepJump &amp;&amp; verticalVelocity &gt; -fallingSpeedup)+ &#123;+ verticalVelocity += gravity * Time.deltaTime;+ &#125;+ else if(!collisionState.onGround)+ &#123;+ verticalVelocity += 3 * gravity * Time.deltaTime;+ &#125;+ if (!jumpPressed)+ &#123;+ keepJump = false; // 松开后不能重新滞空+ &#125;+ // 落地+ if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround)+ &#123;+ verticalVelocity = 0;+ moveAfterJump = false;+ keepJump = false;+ &#125;+ // 运动+ controller.Move(Vector3.up * verticalVelocity * Time.deltaTime);+ #endregion...&#125; 为了更真实，我希望角色原地起跳时更难左右移动，于是在这种情况下水平移动速度减半 + #region 水平移动 bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f; if (isMoving) &#123;+ float herizontalSpeed = Mathf.Abs(moveInput.normalized.x * movementSpeed); float hDir = moveInput.x &gt; 0 ? 1 : -1;+ if (moveAfterJump)+ &#123;+ herizontalSpeed /= 2; // 原地起跳，在空中动能很少，按理说应该走不动+ &#125;+ controller.Move(Vector3.right * hDir * herizontalSpeed * Time.deltaTime); transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(moveInput.x != 0 ? Vector3.right * moveInput.normalized.x : Vector3.right * hDir), 0.1f); &#125; animator.SetFloat(&quot;MoveInput&quot;, Mathf.Abs(moveInput.normalized.x * movementSpeed), 0.2f, Time.deltaTime);+ #endregion 6. 跳跃动画 动画状态机比我想象中要麻烦好多。。。我也不知道我这样做对不对。。。 由于没找到合适的动画资源，这一节不少动画是我自己做的，花了相当长时间，结果效果也不太行 按下图所示在Any State后连接跳跃状态，并添加Jump、FallLand、FastJump、FastFallLand四个动画Trigger 当开始跳跃时会进入JumpStart/RollStart（仅播放一次），播放完后进入滞空动画Jumping/Rolling（这段动画会循环播放），当落地时会进入JumpEnd/RollEnd动画 // 起跳if (jumpPressDown &amp;&amp; collisionState.nearGround)&#123; verticalVelocity = Mathf.Sqrt(2 * Mathf.Abs(gravity) * jumpHeight); moveAfterJump = Mathf.Abs(moveInput.normalized.x) &lt; 0.3f; // 判断起跳时移动速度 keepJump = true; herizontalDirection = moveInput.x &gt; 0 ? 1 : -1;+ if (moveAfterJump)+ &#123;+ animator.SetTrigger(&quot;Jump&quot;);+ &#125;+ else+ &#123;+ animator.SetTrigger(&quot;FastJump&quot;);+ &#125;&#125;...// 落地if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround)&#123;+ if (moveAfterJump)+ &#123;+ animator.SetTrigger(&quot;FallLand&quot;);+ &#125;+ else+ &#123;+ animator.SetTrigger(&quot;FastFallLand&quot;);+ &#125; verticalVelocity = 0; moveAfterJump = false; keepJump = false;&#125; 7. 相机 使用插件Cinemachine，现在只做一个简易的版本 在Hierarchy面板按右键——Cinemachine——Virtual Camera 设置虚拟相机，让其Follow角色，并设置死区 效果如下（额，这跳跃的边缘检测还是有问题） 8. 爬墙 有的平台我们差一点点就能跳上去，我希望在这个边缘向左右拉动摇杆，可以实现爬墙的功能，暂时吸附在墙体上 在角色前添加一个空对象ClimbWallPoint（图中蓝色），在前上添加一个空对象PassablePoint（图中红色），这两个点将用于发射碰撞检测射线 修改CollisionState.cs脚本，添加爬墙检测逻辑 [SerializeField, Tooltip(&quot;靠近地表的检测距离&quot;)] private float nearDistance = 0.2f;+[SerializeField, Tooltip(&quot;爬墙检测点&quot;)] private Transform climbWallPoint;+[SerializeField, Tooltip(&quot;爬墙检测距离&quot;)] private float climbTestDistance = 0.2f;+[SerializeField, Tooltip(&quot;可通行检测点&quot;)] private Transform passablePoint;+[SerializeField, Tooltip(&quot;通行检测距离&quot;)] private float passableTestDistance = 1f;private float offset = 0.05f;+private float lookRight;private void Update()&#123; onGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, testDistance + offset, groundLayer); nearGround = Physics.Raycast(transform.position + Vector3.up * offset, Vector3.down, nearDistance + offset, groundLayer);+ lookRight = (climbWallPoint.position.x - transform.position.x) &gt; 0 ? 1 : -1;+ climbWall = Physics.Raycast(climbWallPoint.position, Vector3.right * lookRight, climbTestDistance, groundLayer);&#125;+public bool GetPassable()+&#123;+ bool passable = !Physics.Raycast(passablePoint.position, Vector3.right * lookRight, passableTestDistance, groundLayer);+ return passable;+&#125; 修改PlayerController.cs脚本，感觉角色状态越来越复杂，有些难以管理了，之后要做一个角色状态机 private bool keepJump = false; // 保持滞空+private bool jumping = false; // 处于跳跃状态+private bool climbing = false; // TODO: 角色状态机private void Update()&#123; ... // 起跳 if (jumpPressDown &amp;&amp; collisionState.nearGround) &#123; ... keepJump = true;+ jumping = true; ... &#125; ... if (!jumpPressed) &#123; keepJump = false; // 松开后不能重新滞空 &#125;+ // 爬墙+ if (jumping &amp;&amp; collisionState.climbWall &amp;&amp; collisionState.GetPassable() &amp;&amp; Mathf.Abs(moveInput.normalized.x) &gt; 0.7)+ &#123;+ climbing = true;+ verticalVelocity = 0;+ &#125;+ else+ &#123;+ climbing = false;+ &#125; // 落地 if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround) &#123; ... keepJump = false;+ jumping = false; &#125; bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f;+ if (isMoving &amp;&amp; !climbing) &#123; float herizontalSpeed = Mathf.Abs(moveInput.normalized.x * movementSpeed); ... &#125; &#125; 效果如下（论动画的重要性） 9. 抓墙动画 我继续沿用老办法做抓墙动画，结果却发现手很难抓住墙壁，于是我改用Animation Rigging的方式实现 骨骼的本质是矩阵树，运行时变化矩阵从根节点开始正向改变网格顶点（蒙皮），变化矩阵包含位移旋转缩放信息，Animation Rigging可以让部分骨骼不受动画影响，而是被反向动力学等方式驱动 安装插件 首先通过包管理器安装Animation Rigging，我们发现窗口上方出现了Animation Rigging栏 配置Rig 找到并选中角色后，点击Animation Rigging——Bone Renderer Setup，我们发现角色身上多了一个Bone Renderer组件，骨骼也被绘制出来 选中角色后点击Animation Rigging——Rig Setup，发现角色出现了一个子物体：Rig1 将Rig重命名为RigHand，并创建子节点RightHand，为RightHand添加组件Two Bone IK Constraint 再RightHand下面创建空的子节点，名叫Target，为了容易观察，让其拥有球形Shape 找到骨骼树中想要被反向驱动的三根骨骼，拖至Two Bone IK Constraint组件上，并将Target也拖到该组件上。现在播放动画，我们发现右手不会被动画驱动，而是被Target反向驱动 通常状态不需要Rig，于是我们将Rig的权重设为0 脚本设置手部落地 修改脚本CollisionState.cs，添加手与墙壁的相交位置 public bool GetPassable()&#123; bool passable = !Physics.Raycast(passablePoint.position, Vector3.right * lookRight, passableTestDistance, groundLayer); return passable;&#125;+public Vector3 GetClimbTouchPosition()+&#123;+ Ray ray = new Ray(climbWallPoint.position, Vector3.right * lookRight);+ Physics.Raycast(ray, out RaycastHit hit);+ return hit.point;+&#125; 修改脚本PlayerController.cs，实现贴墙时修改Target的位置和Rig权重 [SerializeField, Tooltip(&quot;开始加速下落时的速度&quot;)] private float fallingSpeedup = 10f;+[SerializeField] private Transform rightHandPosition;+[SerializeField] private Rig rightHandRig;private Vector2 moveInput;...private void Update()&#123; ... // 爬墙 if (jumping &amp;&amp; collisionState.climbWall &amp;&amp; collisionState.GetPassable() &amp;&amp; Mathf.Abs(moveInput.normalized.x) &gt; 0.7) &#123; climbing = true; verticalVelocity = 0;+ rightHandPosition.position = collisionState.GetClimbTouchPosition();+ rightHandPosition.rotation = Quaternion.LookRotation(moveInput.x &gt; 0 ? Vector3.right : Vector3.left);+ rightHandRig.weight = 1; &#125; else &#123; climbing = false;+ rightHandRig.weight = 0; &#125; ...&#125; 尽管还存在臂力惊人单手悬空的问题，但相比上一版已经好了不少 10. 上平台 抓墙的目的自然是为了上平台，修改PlayerController.cs脚本 [SerializeField, Tooltip(&quot;开始加速下落时的速度&quot;)] private float fallingSpeedup = 10f;+[SerializeField, Tooltip(&quot;爬墙时向上跳的初速度&quot;)]+private float climbingJumpSpeed = 10f;...private bool climbing = false; // TODO: 角色状态机+private bool climbingJump = false; // 抓墙时跳跃private void Update()&#123; ... // 起跳 if (jumpPressDown &amp;&amp; collisionState.nearGround) &#123; ... jumping = true;+ climbingJump = false; if (moveAfterJump) &#123; animator.SetTrigger(&quot;Jump&quot;); &#125; ... &#125; // 爬墙+ if (jumping &amp;&amp; collisionState.climbWall &amp;&amp; collisionState.GetPassable() &amp;&amp; Mathf.Abs(moveInput.normalized.x) &gt; 0.7 &amp;&amp; !climbingJump) &#123; climbing = true; verticalVelocity = 0; rightHandPosition.position = collisionState.GetClimbTouchPosition(); rightHandPosition.rotation = Quaternion.LookRotation(moveInput.x &gt; 0 ? Vector3.right : Vector3.left); rightHandRig.weight = 1;+ animator.SetBool(&quot;Climbing&quot;, climbing);+ if (jumpPressDown)+ &#123;+ rightHandRig.weight = 0;+ verticalVelocity = climbingJumpSpeed;+ animator.SetTrigger(&quot;ClimbingUp&quot;);+ climbingJump = true;+ climbing = false;+ &#125; &#125; else &#123; climbing = false; rightHandRig.weight = 0;+ animator.SetBool(&quot;Climbing&quot;, climbing); &#125; // 落地 if (verticalVelocity &lt; 0 &amp;&amp; collisionState.onGround) &#123; ... jumping = false;+ climbingJump = false; &#125; ... 感觉状态已经麻烦到难以管理了，是时候重构状态机了 11. 瞄准射击 建模 首先打开blender 创建一个圆柱1，按tab进入编辑模式，选中上表面，按s将上表面进行缩放，变成一个类似“圆锥”的东西 在圆锥上侧创建一个球，下侧创建一个圆柱2 使用布尔操作，球布尔Difference，圆柱2布尔Union（注意操作后隐藏球和圆柱） 于是得到了枪的建模（相当粗糙） 你可以为模型添加材质 将模型导出至Unity后 持枪 将枪放在左臂骨骼处，于是实现了左手和枪的绑死，播放动画时枪也跟着动，不过做的有些穿模 枪能随着手部正常运动 瞄准 动画状态机添加瞄准动画 Input System绑定左肩键为Aiming 为持枪的手臂添加Rig 修改脚本PlayerController.cs，按下左肩键后手臂水平前举，根据左摇杆输入以角色左肩膀为圆心画圆，此外我希望瞄准时角色不要移动 +[SerializeField] private Transform gunHandPosition;+[SerializeField] private Rig gunHandRig;+[SerializeField] private Transform gunAimCenter;+[SerializeField, Tooltip(&quot;枪距离角色肩膀的距离&quot;)] private float gunToShoulderDistance = 2f; ...private bool jumpPressDown = false;+private bool aiming = false;...private void Update()&#123; ... jumpPressed = input.actions[&quot;Jump&quot;].IsPressed();+ aiming = input.actions[&quot;Aim&quot;].IsPressed(); ... #region 水平移动 bool isMoving = Mathf.Abs(moveInput.normalized.x) &gt; 0.01f; if (isMoving &amp;&amp; !climbing) &#123; float herizontalSpeed = Mathf.Abs(moveInput.normalized.x * movementSpeed); float hDir = moveInput.x &gt; 0 ? 1 : -1; if (moveAfterJump) &#123; herizontalSpeed /= 2; // 原地起跳，在空中动能很少，按理说应该走不动 &#125;+ if (!aiming)+ &#123; controller.Move(Vector3.right * hDir * herizontalSpeed * Time.deltaTime);+ &#125; transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(moveInput.x != 0 ? Vector3.right * moveInput.normalized.x : Vector3.right * hDir), 0.1f); &#125; animator.SetFloat(&quot;MoveInput&quot;, Mathf.Abs(moveInput.normalized.x * movementSpeed), 0.2f, Time.deltaTime); #endregion+ #region 瞄准射击+ if (aiming)+ &#123;+ Vector3 targetPos;+ if (moveInput.magnitude &lt; 0.1f)+ &#123;+ float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;+ targetPos = new Vector3(gunAimCenter.position.x + gunToShoulderDistance * hDir, gunAimCenter.position.y, gunAimCenter.position.z);+ gunHandPosition.position = targetPos;+ gunHandPosition.rotation = Quaternion.LookRotation(new Vector3(1,-1,0));+ &#125;+ else+ &#123;+ float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;+ targetPos = new Vector3(gunAimCenter.position.x + gunToShoulderDistance * moveInput.normalized.x, gunAimCenter.position.y + gunToShoulderDistance * moveInput.normalized.y, gunAimCenter.position.z);+ gunHandPosition.position = targetPos;+ gunHandPosition.rotation = Quaternion.LookRotation(targetPos - gunAimCenter.position);+ gunHandPosition.Rotate(90f, 0f, 0f);+ animator.SetBool(&quot;Aiming&quot;, true);+ &#125;+ &#125;+ else+ &#123;+ gunHandRig.weight = 0;+ animator.SetBool(&quot;Aiming&quot;, false);+ &#125;+ #endregion&#125; 稍微有些生硬，不过另一只手之后要拿近战武器，所以还好。 瞄准辅助线 在角色身上添加LineRenderer组件，设置组件的线Width、材质 修改脚本PlayerController.cs private CollisionState collisionState;+private LineRenderer lineRenderer;...private void Start()&#123; ... collisionState = GetComponent&lt;CollisionState&gt;();+ lineRenderer = GetComponent&lt;LineRenderer&gt;();&#125;private void Update()&#123; if (aiming) &#123; Vector3 targetPos;+ Vector3 deltaPos; if (moveInput.magnitude &lt; 0.1f) &#123; float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;+ deltaPos = new Vector3(gunToShoulderDistance * hDir, 0, 0);+ targetPos = gunAimCenter.position + deltaPos; gunHandPosition.position = targetPos; gunHandPosition.rotation = Quaternion.LookRotation(new Vector3(1,-1,0)); &#125; else &#123; float hDir = controller.transform.forward.x &gt; 0 ? 1 : -1;+ deltaPos = new Vector3(gunToShoulderDistance * moveInput.normalized.x, gunToShoulderDistance * moveInput.normalized.y, 0);+ targetPos = gunAimCenter.position + deltaPos; gunHandPosition.position = targetPos; gunHandPosition.rotation = Quaternion.LookRotation(targetPos - gunAimCenter.position); gunHandPosition.Rotate(90f, 0f, 0f); &#125;+ lineRenderer.SetPositions(new []&#123;targetPos, targetPos + deltaPos * 12&#125;);+ lineRenderer.enabled = true; animator.SetBool(&quot;Aiming&quot;, true); gunHandRig.weight = 1; &#125; else &#123;+ lineRenderer.enabled = false; gunHandRig.weight = 0; animator.SetBool(&quot;Aiming&quot;, false); &#125;&#125; 发射子弹 Input System将手柄X键绑定为Fire开火键 使用Sphere创建子弹预制体，注意关闭阴影、重力，材质我选用了一个自发光的半透明材质，并为子弹添加了一个碰撞层Bullet，同时设置其Tag为Bullet，碰撞体采用Trigger 编写子弹脚本Bullet.cs，子弹在碰撞到物体时会被销毁，超过一段时间后也会被销毁（具体的碰撞逻辑之后再写） public class Bullet : MonoBehaviour&#123; [SerializeField, Tooltip(&quot;子弹销毁时间&quot;)] private float lifeTime = 5f; private float remainingTime; void Start() &#123; remainingTime = lifeTime; &#125; void Update() &#123; remainingTime -= Time.deltaTime; if (remainingTime &lt;= 0) &#123; Destroy(gameObject); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; Destroy(gameObject); &#125;&#125; 编写子弹发射脚本FireManager.cs public class FireManager : MonoBehaviour&#123; [SerializeField, Tooltip(&quot;子弹速度&quot;)] private float bulletSpeed = 10f; [SerializeField, Tooltip(&quot;普通子弹&quot;)] private GameObject commonBullet; public void FireCommonBullet(Vector3 initPosition, Quaternion initRotation) &#123; GameObject bullet = Instantiate(commonBullet, initPosition, initRotation); bullet.GetComponent&lt;Rigidbody&gt;().AddForce(bullet.transform.forward * bulletSpeed); &#125;&#125; 修改PlayerController.cs private LineRenderer lineRenderer;+private FireManager fireManager;...private bool aiming = false;+private bool firePressDown = false;...private void Start()&#123; ... lineRenderer = GetComponent&lt;LineRenderer&gt;();+ fireManager = GetComponent&lt;FireManager&gt;();&#125;private void Update()&#123; ... aiming = input.actions[&quot;Aim&quot;].IsPressed();+ firePressDown = input.actions[&quot;Fire&quot;].WasPressedThisFrame(); if (aiming) &#123; #region 瞄准动作 Vector3 targetPos; Vector3 deltaPos; if (moveInput.magnitude &lt; 0.1f) &#123; ... &#125; else &#123; ... &#125; ... #endregion+ #region 射击+ if (firePressDown)+ &#123;+ fireManager.FireCommonBullet(targetPos, Quaternion.LookRotation(targetPos - gunAimCenter.position));+ &#125;+ #endregion &#125; else&#123; ... &#125; ...&#125; GIF的帧率太低了。。。 注意，现在角色跳跃是也能射击，爬墙时也能射击，但是抓墙时不能自由射击，因为反向后角色会掉下来。我在考虑是否在跳跃时射击添加时停，抓墙时添加按左肩键可以自由射击，不会掉下来。 银河战士抓墙后不需要一直按左摇杆，可以自由射击，但银河战士是可以变成一格高的球的，有些狭小的管道正常姿势无法射击，于是设计了抓墙射击。而我不打算做变成球，我所有的通道都至少两格宽，很纠结 12. 可被射击破环的方块 方块预制体 首先创建可被射击的方块预制体，拥有碰撞盒、VFX和一个脚本 创建脚本InteractiveCube.cs，我希望当方块被子弹击中时会隐藏渲染和碰撞，并播放粒子效果，一段时间后再复原 public class InteractiveCube : MonoBehaviour&#123; [SerializeField] private float recoverTime = 20f; private MeshRenderer meshRenderer; private Collider boxcollider; private VisualEffect visualEffect; private float currentDeadTime; private void Start() &#123; meshRenderer = GetComponent&lt;MeshRenderer&gt;(); boxcollider = GetComponent&lt;Collider&gt;(); visualEffect = GetComponent&lt;VisualEffect&gt;(); visualEffect.Stop(); &#125; private void OnTriggerEnter(Collision other) &#123; if (other.gameObject.CompareTag(&quot;Bullet&quot;)) &#123; meshRenderer.enabled = false; boxcollider.enabled = false; visualEffect.Play(); currentDeadTime = recoverTime; &#125; &#125; private void Update() &#123; if (currentDeadTime &gt;= 0) &#123; currentDeadTime -= Time.deltaTime; if (currentDeadTime &lt;= 0) &#123; meshRenderer.enabled = true; boxcollider.enabled = true; &#125; &#125; &#125;&#125; 特效 现在的特效是随便做的，之后要重写，我希望方块被射击会有破碎效果，复原时会有溶解效果 破碎效果使用Unity VFX插件 首先去Package Manager安装Visual Effect Graph 右键Visual Effect——Visual Effect Graph，创建一个特效，双击后进入面板，配置为单次发射（Single Burst）、设置发射方向、粒子生命周期、添加重力 有点绷不住了 13. 近战攻击 近战攻击相当复杂，我问了几个动作策划，给了我好几种方法： 在武器上绑定胶囊体碰撞盒 在武器附近射线检测 在打击区域绘制方形碰撞盒 逐帧修改判定区域 怪物读玩家指令 在银河战士里，近战多用于反击远程单位（我的游戏也是这样设计的），感觉做成读指令会更方便。但我又想 Timeline Timeline是Unity的时间线工具，常用于制作过场动画、相机蒙太奇，我们这里用来制作打击动作 打开Timeline面板 为角色创建Timeline（此时角色身上会添加PlayableDirector组件），将近战动画clip拖入时间线中，并设置动画的Ease In/Out，这样可以使得Timeline动画和动画状态机的动画混合 注意要关掉Timeline的Play On Awake 我们在角色面前创建一个方形碰撞区域（有着Box Collider和锁死旋转和位移的Rigidbody），添加Tag为Hit，并默认设为unactive。 在Timeline中创建Control Track，在片段期间该物体将设为活跃，结束后恢复隐藏 点击播放键可以预览效果 控制 修改脚本PlayerController.cs private FireManager fireManager;+private PlayableDirector director;...private bool firePressDown = false;+private bool hitPressDown = false;private void Start()&#123; ...+ director = GetComponent&lt;PlayableDirector&gt;();&#125;private void Update()&#123; ...+ hitPressDown = input.actions[&quot;Hit&quot;].WasPressedThisFrame(); ...+ if (hitPressDown &amp;&amp; collisionState.onGround)+ &#123;+ director.Play();+ &#125;&#125; 14. 可被近战破坏的方块 修改脚本InteractiveCube.cs +public enum CubeType+&#123;+ Shoot,+ Hit+&#125;public class InteractibleCube : MonoBehaviour&#123; [SerializeField] private float recoverTime = 20f;+ [SerializeField] private CubeType cubeType; ...+ private string TagName+ &#123;+ get+ &#123;+ if(cubeType == CubeType.Shoot)+ return &quot;Bullet&quot;;+ else+ return &quot;Hit&quot;;+ &#125;+ &#125; ... private void OnTriggerEnter(Collision other) &#123;+ if (other.gameObject.CompareTag(TagName)) &#123; ... &#125; &#125; ...&#125; 15. 零美术成本更换角色模型 适合完全不会绑骨刷权重K帧的非美术，mmd的模型骨骼一般都十分复杂，并且和mixamo不一致 去模之屋等网站获取mmd模型，导入blender中（详情可见blender mmd tools），个人建议选择短发角色 将角色姿态设为T Pose（你可以进入姿态模式，用手掰，可以放一个水平盒子当辅助线），T Pose很重要！ 导出仅含网格的fbx模型 打开mixamo，选择小红人，点击UPLOAD CHARACTOR（导入模型），按步骤完成 即可得到自动绑骨刷权重的角色模型，并能够完美使用mixamo的动画 我这里除了更换角色模型外，还使用了卡渲Shader和后效，网上关于卡渲的项目和教程相当多，这里就按下不表了 16. 地面敌人AI 使用插件Behavior Trees，Asset Store 45刀，参考空洞骑士BOSS战 敌人移动混用了DoTween插件和Charactor Controller 感觉这一节用文字讲好乏力。。。 创建角色单例 创建脚本PlayerInfo.cs，并将其绑定到Player上，该脚本控制了角色血量和是否处于无敌状态 public class PlayerInfo : MonoBehaviour&#123; #region 单例 private static PlayerInfo instance; // 私有构造函数 private PlayerInfo()&#123;&#125; public float Health &#123; get; private set; &#125; = 100f; #endregion #region Prop [SerializeField, Tooltip(&quot;处于无敌状态&quot;)] private bool invincible = false; [SerializeField, Tooltip(&quot;无敌时间&quot;)] private float invincibleTime = 2f; [SerializeField, Tooltip(&quot;无敌时闪烁间隔时间&quot;)] private float blinkTime = 0.1f; [SerializeField, Tooltip(&quot;角色渲染&quot;)] private SkinnedMeshRenderer playerRenderer; #endregion #region Member // 无敌还剩多长时间 private float currentInvincibleTime = 0f; // 闪烁控制时间 private float currentBlinkTime = 0.1f; // 闪烁控制 private bool blinkVisible = true; #endregion public static PlayerInfo Instance &#123; get &#123; if (instance == null) &#123; instance = FindObjectOfType&lt;PlayerInfo&gt;(); &#125; return instance; &#125; &#125; public Vector3 PlayerPosition &#123; get &#123; return transform.position; &#125; &#125; public void HitPlayer(float damage, Vector3 enemyPosition) &#123; if (invincible) &#123; return; &#125; Vector3 moveDirection = new Vector3(0, 1, 0); if(enemyPosition.x &gt; transform.position.x) &#123; moveDirection.x = -1; &#125; else &#123; moveDirection.x = 1; &#125; gameObject.GetComponent&lt;CharacterController&gt;().Move(moveDirection); Health -= damage; currentInvincibleTime = invincibleTime; currentBlinkTime = blinkTime; &#125; private void Update() &#123; if(currentInvincibleTime &gt; 0) &#123; invincible = true; currentInvincibleTime -= Time.deltaTime; currentBlinkTime -= Time.deltaTime; if(currentBlinkTime &lt;= 0) &#123; currentBlinkTime = blinkTime; blinkVisible = !blinkVisible; playerRenderer.enabled = blinkVisible; &#125; &#125; else &#123; invincible = false; playerRenderer.enabled = true; &#125; &#125;&#125; 创建敌人 创建脚本EnemyInfo.cs，并挂到敌人身上，此外敌人身上同时挂在Character Controller、Animator、Behaviour（这个稍后再讲）、BoxCollider（这个碰撞盒是用于被攻击的） 添加碰撞层Enemy，并将敌人设为Enemy（在项目设置中，设置Enemy和玩家不发生碰撞） public class EnemyInfo : MonoBehaviour&#123; public float maxHealth = 30.0f; public float currentHealth; public float findPlayerDistance = 10.0f; private void Start() &#123; currentHealth = maxHealth; &#125; private void OnDrawGizmos() &#123; Gizmos.color = Color.red; Gizmos.DrawWireSphere(transform.position, findPlayerDistance); &#125; private void OnTriggerEnter(Collider other) &#123; if (other.tag == &quot;Bullet&quot;) &#123; currentHealth -= other.GetComponent&lt;Bullet&gt;().damage; &#125; &#125;&#125; 创建敌人攻击碰撞球 我们将敌人受攻击（Box）、敌人和场景的碰撞（CC）、敌人攻击玩家的碰撞（Sphere）分开了 为敌人创建一个子物体叫HitSphere，拥有一个球形碰撞盒和一个碰撞处理脚本，该碰撞球用于攻击玩家 添加碰撞层EnemyHit，该碰撞层仅和玩家碰撞 创建脚本EnemyHitCube.cs public class EnemyHitCube : MonoBehaviour&#123; private void OnTriggerEnter(Collider other) &#123; var playerInfo = other.GetComponent&lt;PlayerInfo&gt;(); if (playerInfo != null) &#123; playerInfo.HitPlayer(10, transform.position); &#125; &#125;&#125; 创建行为树 寻找敌人后打开Behaviour Designer面板，添加任意行为后敌人身上会出现一个Behaviour Tree组件 行为树是由一个个节点组成，当这些节点被执行时，会向其父节点返回执行成功、失败、正在执行等结果 Repeater表示循环执行（我开启了无限循环） Selector是一个或组件，其子节点从左向右开始执行，只要有一个为成功，则返回成功 Sequence表示顺序执行，其子节点从左向右执行，直到一个节点返回失败 我为怪物添加了三个行为： 血量小于0时IsHealthUnder，播放死亡动画，并销毁GameObject 否则 若敌人周围有玩家IsFindPlayer，则追逐玩家EnemyPursuit 否则在周围徘徊EnemyMove 创建敌人行为和条件基类 创建脚本EnemyAction.cs public class EnemyAction : Action&#123; protected Animator animator; protected EnemyInfo info; protected CharacterController controller; public override void OnAwake() &#123; animator = GetComponent&lt;Animator&gt;(); info = GetComponent&lt;EnemyInfo&gt;(); controller = GetComponent&lt;CharacterController&gt;(); &#125;&#125; 创建脚本EnemyConditional.cs public class EnemyConditional: Conditional&#123; protected EnemyInfo info; protected Animator animator; public override void OnAwake() &#123; info = GetComponent&lt;EnemyInfo&gt;(); animator = GetComponent&lt;Animator&gt;(); &#125;&#125; 创建角色移动、追击、死亡行为 创建脚本EnemyMove.cs，该脚本能使得敌人左右徘徊 public class EnemyMove : EnemyAction&#123; public SharedBool lookRight; public SharedFloat currentMoveTime; public float moveSpeed = 1.0f; public float moveUseTime = 2.0f; public float rotateUseTime = 0.5f; private Tween rotateTween; public override void OnStart() &#123; &#125; public override TaskStatus OnUpdate() &#123; float direction = lookRight.Value ? 1 : -1; currentMoveTime.Value += Time.deltaTime; if (currentMoveTime.Value &gt; moveUseTime) &#123; lookRight.Value = !lookRight.Value; currentMoveTime.Value = 0; rotateTween = DOVirtual.DelayedCall(0, () =&gt; transform.DORotateQuaternion(Quaternion.LookRotation(Vector3.right * -direction), rotateUseTime), false); &#125; controller.Move(Vector3.right * direction * moveSpeed * Time.deltaTime); return TaskStatus.Success; &#125;&#125; 创建脚本EnemyPursuit.cs，该脚本能使得敌人向玩家追击 public class EnemyPursuit : EnemyAction&#123; public float moveSpeed = 1.0f; public float rotateUseTime = 0.5f; public override TaskStatus OnUpdate() &#123; float direction = PlayerInfo.Instance.PlayerPosition.x &gt; transform.position.x ? 1 : -1; DOVirtual.DelayedCall(0, () =&gt; transform.DORotateQuaternion(Quaternion.LookRotation(Vector3.right * direction), rotateUseTime), false); controller.Move(Vector3.right * direction * moveSpeed * Time.deltaTime); return TaskStatus.Success; &#125;&#125; 创建脚本EnemyDead.cs，该脚本能使敌人死亡 public class EnemyDead : EnemyAction&#123; public float deadDelayTime = 1.0f; private bool isDeadFinish = false; public override void OnStart() &#123; DOVirtual.DelayedCall(deadDelayTime, () =&gt; &#123; Object.Destroy(gameObject); isDeadFinish = true; &#125;); &#125; public override TaskStatus OnUpdate() &#123; return isDeadFinish ? TaskStatus.Success : TaskStatus.Running; &#125;&#125; 创建敌人行为条件 创建脚本IsFindPlayer.cs，该脚本用于判断敌人周围是否有角色，如果是刚刚发现，会出发一段动画 public class IsFindPlayer : EnemyConditional&#123; public SharedBool firstFindPlayer = true; public override TaskStatus OnUpdate() &#123; if ((transform.position - PlayerInfo.Instance.PlayerPosition).magnitude &lt; info.findPlayerDistance) &#123; if (firstFindPlayer.Value) &#123; animator.SetTrigger(&quot;FindPlayer&quot;); &#125; firstFindPlayer.Value = false; return TaskStatus.Success; &#125; else &#123; firstFindPlayer.Value = true; return TaskStatus.Failure; &#125; &#125;&#125; 创建脚本IsHealthUnder.cs，该脚本用于判断角色血量是否低于某个数值 public class IsHealthUnder : EnemyConditional&#123; public float underNumber = 0f; public override TaskStatus OnUpdate() &#123; if (info.currentHealth &lt;= underNumber) &#123; return TaskStatus.Success; &#125; else &#123; return TaskStatus.Failure; &#125; &#125;&#125; 效果","categories":[{"name":"game","slug":"game","permalink":"https://reubensun.com/categories/game/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"}]},{"title":"有意思的代码","slug":"program/有意思的代码","date":"2023-05-16T22:01:25.000Z","updated":"2025-03-18T07:16:42.969Z","comments":true,"path":"program/有意思的代码/","permalink":"https://reubensun.com/program/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%BB%A3%E7%A0%81/","excerpt":"","text":"有意思的代码 记录一下平时遇到的有意思的代码，不定期更新 在注释中的立方体 001------101 / | / | / | / |011------111 | | 000--|--100 | / | / | / | /010------110 消除未使用变量 有人会认为C++的警告（Warming）等同于报错，于是会通过一些宏关掉一些警告 将变量转化为void类型，相当于明确告诉编译器我不打算使用这个变量，消除“变量未使用”的警告 #define UNUSED(x) (void)(x)int main()&#123; int x; UNUSED(x); // 不使用x ... return 0;&#125; 快速Acos Acos是一个常见的三角函数，其作用是将[-1, 1]的值转换为所对应的弧度 这个是一个使用Eberly的一阶多项式逼近计算反余弦函数 // max absolute error 9.0x10^-3// Eberly&#x27;s polynomial degree 1 - respect bounds// 4 VGPR, 12 FR (8 FR, 1 QR), 1 scalar// input [-1, 1] and output [0, PI]float acosFast(float inX) &#123; float x = abs(inX); float res = -0.156583f * x + (0.5 * PI); res *= sqrt(1.0f - x); return (inX &gt;= 0) ? res : PI - res;&#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"SWIG实现Python调用C++","slug":"program/python调用C++","date":"2023-05-16T16:01:25.000Z","updated":"2025-03-18T07:16:42.968Z","comments":true,"path":"program/python调用C++/","permalink":"https://reubensun.com/program/python%E8%B0%83%E7%94%A8C++/","excerpt":"","text":"SWIG实现Python调用C++ 在实际项目开发中，我们经常有跨语言交互的需求，比如使用Python/Lua脚本调用引擎代码。常用的方案有很多，我们来介绍SWIG 语言 特点 C++/CLI C++和C# 微软为.NET平台高度定制的拓展，允许C++调用托管代码 SWIG 多语言 跨平台多语言，需要写.i文件，有一定侵入性 Boost Python和C++ JNI Java和C++ SWIG 简介 SWIG（Simplified Wrapper and Interface Generato）是一种包装器，通过配置.i文件，自动生成Wrapper文件，以实现其他语言调用C++代码 Interface file .i文件格式如下 // 1. 模块名%module example // 2. 头文件和声明%&#123;#include &quot;example.h&quot;#include &quot;example_controller.h&quot;extern int fact(int);%&#125;// 引用其他.i文件%include &lt;windows.i&gt; // 3. swig特性 // 4. 代码拓展// 将C++中的bool数组封装为BoolArray类%array_class(bool, BoolArray);// 将C++中的std::vector&lt;std::string&gt;封装为StringVector类，所有vector向量都应该像这样封装%template(StringVector) std::vector&lt;std::string&gt;;// 5. 要包装的内容，可以用头文件全部包装// 特别注意，.h文件要按依赖顺序从上到下排布！%include &quot;example.h&quot;%include &quot;example_controller.h&quot; 环境安装 我的环境是Mac M1，安装了brew和python3 安装swig brew install swig 检测是否安装成功 swig -version 样例代码 实现了在python中调用C++定义的add函数 C++代码 // example.hint add(int x, int y); // example.cpp#include &quot;example.h&quot;int add(int x, int y)&#123; return x+y;&#125; SWIG代码 // example.i%module example %&#123;#include &quot;example.h&quot;%&#125;%include &quot;example.h&quot; 执行命令，我们会生成一个.py文件和一个.cxx文件 swig -c++ -python example.i 为了方便使用，我们将生成的.py文件构建为.so文件，创建一个setup.py文件，使用distutils进行编译 # setup.pyfrom distutils.core import setup, Extension example_module = Extension(&#x27;_example&#x27;, sources=[&#x27;example_wrap.cxx&#x27;, &#x27;example.cpp&#x27;], ) setup (name = &#x27;example&#x27;, version = &#x27;0.1&#x27;, author = &quot;SWIG Docs&quot;, description = &quot;&quot;&quot;Simple swig example from docs&quot;&quot;&quot;, ext_modules = [example_module], py_modules = [&quot;example&quot;], ) 执行命令，即会生成一些文件，其中包含一个.so文件 python3 setup.py build_ext --inplace 将.so文件放入环境变量中（不推荐），或者放在python脚本同一个目录中（推荐），即可被调用 # example_test.pyimport example# 调用C++函数result = example.add(3, 4)print(&quot;3 + 4 =&quot;, result) C++包装 函数 // example.hint add(int x, int y); // example.cpp#include &quot;example.h&quot;int add(int x, int y)&#123; return x+y;&#125; // example.i%module example %&#123;#include &quot;example.h&quot;%&#125;%include &quot;example.h&quot; # example_test.pyimport example# 调用C++函数result = example.add(3, 4)print(&quot;3 + 4 =&quot;, result) 常量 // example.i%module example%&#123;#include &quot;example.h&quot;%&#125;#define PI 3.14159265358979323846%constant int Foo = 42;%constant const char *path = &quot;/usr/local/include&quot;;%include &quot;example.h&quot; # example_test.pyimport exampleprint(example.PI) # 3.141592653589793print(example.path) # /usr/local/include 结构体 // example.hstruct Point&#123; double x,y;&#125;; # example_test.pyimport examplep = example.Point()p.x = 1p.y = 2 类 // example.hclass Shape&#123;private: double size;public: void setSize(double s) &#123; size = s;&#125; double getSize() &#123; return size; &#125;&#125;; # example_test.pyimport examples = example.Shape()s.setSize(0.5)print(s.getSize()) 资料 SWIG 4.1 Doc","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"},{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"},{"name":"SWIG","slug":"SWIG","permalink":"https://reubensun.com/tags/SWIG/"}]},{"title":"FBX SDK入门","slug":"dcc/FbxSDK","date":"2023-05-15T10:01:25.000Z","updated":"2025-03-18T07:16:48.447Z","comments":true,"path":"dcc/FbxSDK/","permalink":"https://reubensun.com/dcc/FbxSDK/","excerpt":"","text":"FBX SDK FBX是一种主流的三维模型格式，格式闭源，但可以通过免费的FBX SDK编辑模型 开发环境 Visual Studio 2022 Cmake 安装FBX SDK，我根据环境安装的是2020 VS2022 cmake构建 在FBX SDK安装位置，能看到include、lib等，这里使用动态库构建 cmake_minimum_required(VERSION 3.21)project(FBXStudy)set(CMAKE_CXX_STANDARD 20)set(CMAKE_CXX_STANDARD_REQUIRED ON)set(CMAKE_CXX_EXTENSIONS OFF)add_executable($&#123;PROJECT_NAME&#125; FbxLoader.h FbxLoader.cpp Main.cpp)target_include_directories($&#123;PROJECT_NAME&#125; PRIVATE &quot;$&#123;CMAKE_SOURCE_DIR&#125;/FBXSDK/include&quot;)target_link_libraries($&#123;PROJECT_NAME&#125; PRIVATE &quot;$&#123;CMAKE_SOURCE_DIR&#125;/FBXSDK/lib/libfbxsdk.lib&quot;)add_custom_command(TARGET $&#123;PROJECT_NAME&#125; POST_BUILD COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_if_different &quot;$&#123;CMAKE_SOURCE_DIR&#125;/FBXSDK/bin/libfbxsdk.dll&quot; $&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt;)target_compile_definitions($&#123;PROJECT_NAME&#125; PRIVATE FBXSDK_SHARED) 值得注意的是，当你使用动态库链接FBX SDK时，需要添加编译选项FBXSDK_SHARED，不然会报符号重定义的错误 资料 FBX SDK 2020 文档","categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"}],"tags":[{"name":"FBX","slug":"FBX","permalink":"https://reubensun.com/tags/FBX/"},{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"Physically Based Shading at Disney","slug":"graphics/DisneyBRDF","date":"2023-04-25T10:01:25.000Z","updated":"2025-03-18T07:16:48.444Z","comments":true,"path":"graphics/DisneyBRDF/","permalink":"https://reubensun.com/graphics/DisneyBRDF/","excerpt":"","text":"《Physically Based Shading at Disney》阅读笔记 2012年SIGGRAPH，迪士尼提出了迪士尼规则的基于物理的渲染，立刻成为行业标准，被各大游戏厂商和游戏引擎所采用 本文采用第一人称，我们是指迪士尼 介绍 当时场景渲染还在使用ad-hoc着色模型和punctual灯光，我们渴望一套一致性的、美术友好的着色模型。受毛发渲染启发，我们推出了符合迪士尼规则的PBR模型。 迪士尼PBR模型提供了多种不同的渲染方程，但美术不需要关心渲染的底层逻辑，不需要针对不同的方程调整参数。 微表面模型 BRDF（双向反射分布函数）表示反射光与入射光的能量关系，是某方向出射光辐射率（Radiance）和入射光辐照度（Irradiance）的比值。 微表面模型认为材质表面由无数个理想镜面排列组成，如果某个观察方向上能观察到反射光，那么必然有一些微表面，他们的法线能平分入射光方向和观察方向（几何光学），我们将这些微表面的法线方向称为半向量（half vector）。顾名思义，半向量是入射光和观察方向的一半。 $$ \\mathbf{h}=\\frac{\\mathbf{l}+\\mathbf{v}}{|\\mathbf{l}+\\mathbf{v}|} $$ 一个各向同性的BRDF模型如下，由菲涅尔项、微表面法线分布项、几何遮挡项组成 $$ \\rho\\left(\\mathbf{l}, \\mathbf{v} \\right)= \\mathrm{diffuse} + \\frac{F\\left( \\theta_d \\right) D\\left( \\theta_h \\right) G\\left( \\theta_l,\\theta_v \\right) }{ 4\\cos\\theta_l\\cos\\theta_v} $$ $\\theta_d$是入射光和半向量的夹角，d是difference的意思 $\\theta_h$是半向量和法线的夹角 $\\theta_l$是入射光和法线的夹角 $\\theta_v$是观察方向和法线的夹角 BRDF可视化 我们制作了一个BRDF可视化工具，并将扫描材质转化为Image slice 在最底侧$\\theta_d=0$，入射光和视线重合 在最左侧$\\theta_h=0$，视线位于反射最强烈的部分，是高光项 在最上侧$\\theta_d$最大，模拟光线射到材质边缘是的菲涅尔现象 观察材质 漫反射项 漫反射是灯光进入材质后经过折射、散射后重新发散到材质外部的过程。BRDF并没有考虑光线进出材质的位置变化，没有模拟次表面散射。 下图为随着$\\theta_h$的增大，反射强度的衰减程度，光滑材质反射强度衰减的极快。而粗糙材质就比较慢，甚至有些材质的反射强度与方向无关。部分粗糙材质在掠射角有菲涅尔现象 微表面理论认为材质表面由大量理想镜面组成，光线呈掠射角入射时，入射光线与模型边缘的一些“竖直的”微表面相遇，使许多光发生了反射，形成了菲涅尔效应，更多的能量被用于反射，而非散射。 微表面法线分布项 微表面项描述了沿着半向量方向的微表面占总面积的比例。对于光滑材质，大多数微表面法线与宏观法线方向一致，随着$\\theta_h$增大，面积会迅速减少，而粗糙材质减少就很慢，有着更长的尾部。 下图左为GGX（红）、Beckmann（绿）、Blinn Phong（蓝，注意和绿重叠了）、chrome（黑）四种D项的描述，右图从左到右分别为点光照射chrome、GGX、Beckmann项的结果。 高光菲涅尔项 菲涅尔项描述了光线发生反射和折射的比例，当光线由光疏材质射向光密材质时，随着入射角的增大，反射会越来越强。对于光滑材质，掠射角时菲涅尔项接近100%，对于粗糙材质，尽管无法达到100%，但也增长迅速。 人们发现有些材质的菲涅尔曲线在掠射角处比菲尼尔方程预测的更陡峭，为此引入了几何遮挡项，该项将方法菲涅尔效应。 几何遮挡项 实践中难以测量出几何遮挡项，于是是通过先测量出F项和D项，再计算出G项。 Smith根据D项推导出了一种G项，不过Smith的G项仅再某些情况下有解析式，大部分情况下使用预积分+图表的方式近似。 迪士尼BRDF 材质参数 参数直观、数量少，参数范围通常在0~1但允许超出范围，所有参数组合都是鲁棒合理的 参数名称 含义 baseColor 基础色 subsurface 通过次表面控制漫反射形状 metallic 金属度，所有材质是金属和非电介质根据金属度的混合，0为非金属，1为金属 specular incident specular amount. This is in lieu of an explicit index-of-refraction specularTint 美术可以通过该参数将高光色调向基础色 roughness 粗糙度 anisotropic 各项异性比，用于控制高光形状，0为各项同性，1为各项异性 sheen 光泽，用于布料渲染 sheenTint 美术可以通过该参数将光泽调向基础色 clearcoat 薄膜图层的高光色 clearcoatGloss 薄膜图层的粗糙度 漫反射模型 漫反射的本质是光线进入材质后重新射出，因此至少发生了两次折射，于是有两个菲涅尔项。这两个菲涅尔还能让材质边缘变亮。 $$ \\rho_d=\\frac{baseColor}{\\pi}(1+(F_{D90}-1)(1-\\cos \\theta_l)^5)(1+(F_{D90}-1)(1-\\cos \\theta_v)^5) $$ $$ F_{D90}=0.5+2roughness\\cos^2\\theta_d $$ 高光D项 我们认为目前最流行的GGX拖尾仍不够长，最后选择了GTR $$ D_{GTR}=c/(\\alpha^2\\cos^2\\theta_h+\\sin^2\\theta_h)^{\\gamma} $$ $c$：缩放常数 $\\alpha$：粗糙度参数，0为光滑，1为完全粗糙 高光F项 $$ F_{\\mathrm{Schlick}}=F_0+(1-F_0)(1-\\cos\\theta_d)^5 $$ 高光G项 使用GGX模型作为G项，但对粗糙度进行映射 $$ \\alpha_g=(0.5+roughness/2)^2 $$","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"PBR","slug":"PBR","permalink":"https://reubensun.com/tags/PBR/"},{"name":"SIGGRAPH","slug":"SIGGRAPH","permalink":"https://reubensun.com/tags/SIGGRAPH/"}]},{"title":"法线切线次切线的计算","slug":"graphics/法线切线次切线","date":"2023-04-23T10:01:25.000Z","updated":"2025-03-18T07:16:48.442Z","comments":true,"path":"graphics/法线切线次切线/","permalink":"https://reubensun.com/graphics/%E6%B3%95%E7%BA%BF%E5%88%87%E7%BA%BF%E6%AC%A1%E5%88%87%E7%BA%BF/","excerpt":"","text":"法线切线次切线的计算 顶点法线的计算 模型顶点构成了多个三角面，使用三角面的顶点坐标等得到两条边的向量，求两个向量的叉积能够得到（归一化的）面法线。 $$ \\mathbf{N}=\\frac{(\\mathbf{P}_1-\\mathbf{P}_0)\\times(\\mathbf{P}_2-\\mathbf{P}_0)}{||(\\mathbf{P}_1-\\mathbf{P}_0)\\times(\\mathbf{P}_2-\\mathbf{P}_0)||} $$ 点的顺序与法线方向满足右手螺旋定则，点呈顺逆时针时法线垂直直面向外。 顶点法线可以在DCC中手动指定，也可以用面法线做平滑着色。一般来说某个顶点会参与构成多个三角面，选取这些三角面的面法线做算术平均值，这个过程被称为平滑着色。 硬边上的点属于不同的平滑组，在计算法线时不能平均，在导出时会被拆分为互相重叠的点，各自拥有一个法线、纹理坐标。 如果对未经过归一化的面法线求均值，能实现含权重的顶点法线，三角面面积越大，影响越强。 切线空间 为了得到更高精度的法线，我们会使用切线空间的法线贴图，对顶点法线进行扰动。 切线空间由三个基向量组成，分别为切线$X$、次切线$Y$、法线$Z$，这三个基向量不一定正交，但视为正交。 在不进行扰动时，切线空间的法线为$(0,0,1)$，是顶点法线的方向。切线和次切线所形成的平面与物体表面相切，方向与UV有关，但存在偏差。 三个向量可以构成TBN矩阵，该矩阵能将切线空间法线转化为物体空间/世界空间 $$ \\begin{bmatrix}T_{x}&amp;B_{x}&amp;N_{x}\\\\ T_{y}&amp;B_{y}&amp;N_{y}\\\\ T_{z}&amp;B_{z}&amp;N_{z}\\end{bmatrix} $$ float3 normalValue = normalTexture.sample(textureSampler, uv * params.tiling).xyz * 2.0 - 1.0; normal = float3x3(tangentWS, bitangentWS, normalWS) * normalValue; 计算切线和次切线 int triangleCount = indices.Count / 3;List&lt;float3&gt; sDirList;List&lt;float3&gt; tDirList;for(int i = 0; i &lt; triangleCountl; ++i)&#123; // 三角形的三个顶点 int vertexID0 = indices[i * 3]; int vertexID1 = indices[i * 3 + 1]; int vertexID2 = indices[i * 3 + 1]; // 顶点UV float2 uv0 = uvs[vertexID0]; float2 uv1 = uvs[vertexID1]; float2 uv2 = uvs[vertexID2]; // 顶点坐标 float3 pos0 = positions[vertexID0]; float3 pos1 = positions[vertexID1]; float3 pos2 = positions[vertexID2]; // UV差值 float2 s = float2(uv1.x - uv0.x, uv2.x - uv0.x); float2 t = float2(uv1.y - uv0.y, uv2.y - uv0.y); // 坐标差值 float3 deltaPos0 = pos1 - pos0; float3 deltaPos1 = pos2 - pos0; float r = 1.0f / (s.x * t.y - s.y * t.x); float3 sDir = float3( r* (t.y * deltaPos0.x - t.x * deltaPos1.x), r* (t.y * deltaPos0.y - t.x * deltaPos1.y), r* (t.y * deltaPos0.z - t.x * deltaPos1.z) ); float3 tDir = float3( r* (-s.y * deltaPos0.x + s.x * deltaPos1.x), r* (-s.y * deltaPos0.y + s.x * deltaPos1.y), r* (-s.y * deltaPos0.z + s.x * deltaPos1.z) ); tDirList[vertexID0] += tDir; tDirList[vertexID1] += tDir; tDirList[vertexID2] += tDir; sDirList[vertexID0] += sDir; sDirList[vertexID1] += sDir; sDirList[vertexID2] += sDir;&#125;for(int i = 0; i &lt; vertexCount; ++i)&#123; float3 normal = normals[vertexID0]; float3 tDir = tDirList[i]; // 切线 float3 tangent = tDir - dot(normal, tDir); // 次切线 float3 bitangent = cross(normal, tangent);&#125; 参考 切线空间（Tangent Space）完全解析 《3D游戏与计算机图形学中的数学方法》","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Model","slug":"Model","permalink":"https://reubensun.com/tags/Model/"}]},{"title":"Mac开发环境配置","slug":"program/mac环境安装","date":"2023-04-16T15:01:25.000Z","updated":"2025-03-18T07:16:48.437Z","comments":true,"path":"program/mac环境安装/","permalink":"https://reubensun.com/program/mac%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","excerpt":"","text":"Mac开发环境配置 前几天遇到一个问题，某个VPN软件开启后无法正常关闭，而强行关闭后并没有还原网络配置，导致我只有开着VPN才能连接网络，一时间没有好的办法，于是将Mac重装了系统，记录一下环境配置，没准以后还会用到 我的设备是Macbook Air M1，主要用于Metal开发和写博客 Mac重装系统 重要文件注意备份（放在iCloud最方便） 在关机状态下长按电源键，此时会提示你继续长按进入启动选项 你会看到两个启动选项，一个是当前系统的启动盘，一个是齿轮形状的选项 进入选项，进入磁盘工具，选择要抹除的内容盘，点右上角的抹除 回到齿轮选项界面，点击重装macOS，这个过程需要联网 等待即可 基础开发环境 brew MacOS最常用的包管理器，用于下载各种开发环境、软件、三方库 出于网络原因，建议使用国内镜像安装，打开终端输入 /bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 按输出操作即可 Python3 安装brew后输入 brew install python3 不仅仅是python，可以说大部分的环境都可以用brew install xxx安装 常用工具 Xcode 免费使用，但是打包需要付费账户 无需多说，Mac上开发必备环境，可以直接去App Store安装，值得注意的是，商店里的Xcode是最新版，需要你的系统保持最新 Typora 付费，15刀永久 一款所见即所得的markdown编辑器，界面简洁优美，而且对latex等支持非常好 安装激活后打开某个markdown文件，选中后按command+i打开简介，配置该类文件的打开方式 此外最好也配置一下图片的引用方式，比如使用相对路径，自动复制到文件夹之类的 GitKraken 学生免费，公共仓库免费，商用私有仓库订阅收费 最好的图形界面，功能齐全，看diff也十分方便 LFS功能需要单独安装，在终端输入 brew install git-lfs VS Code 免费 无需多说，一个完美的文本编辑器，如果你不安装VS Code，很有可能用Xcode打开一些文件 Github Copilot 学生免费 强烈建议安装，编程效率提升数倍，不会使用AI的程序员必然被AI取代 在一个Python脚本中，我刚输入md5，就帮我写好了代码 右键助手 免费，App Store搜索即可 我只使用了少量功能，比如新建文件，在当前路径打开终端 Hidden Bar 免费，App Store搜索即可 用于折叠顶部图标，眼不见心不烦 ClashX 免费，开源，当然订阅需要自己去找 一个非常好用的VPN软件","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"Character Creator 插件开发","slug":"dcc/Character Creator","date":"2023-04-14T10:01:25.000Z","updated":"2025-03-18T07:16:48.447Z","comments":true,"path":"dcc/Character Creator/","permalink":"https://reubensun.com/dcc/Character%20Creator/","excerpt":"","text":"Character Creator 插件开发 最近在CC 4/iClone 8开发Python插件，真的是小刀拉屁股，开了眼了，都不知道该从哪里开始吐槽，如果说maya脚本开发叫恶心，CC脚本开发就是阴间 去年CC 4发布，改动了大量API，大部分API都变成Experimental API，之前（指五六年前）的样例代码大多失效，并不不再维护（不会改你可以不改） 官方文档简陋无比，大部分函数和参数没有用法和解释，写满了# No example 给官方发邮件（这是花了钱的）问Python相关的东西，官方只会复读“脚本还在开发，可能有功能不全，你可以尝试去论坛问” 官方论文发言需要审核，我提了两个问题都被拒绝发布（我发邮件你让我去论坛，我去论坛你堵我嘴） 脚本功能不全，有些功能可以读写，有些是只读（像maya你的每一步操作都是由命令实现的，甚至会在窗口将当前命令输出出来） 介绍 Character Creator是reallusion推出的一款商业捏脸软件，可以制作表情动作、动作捕捉等。使用成本比较高，大部分公司都不会使用，网上的信息远少于Maya、3DMax这类DCC。 CC支持使用Python编写脚本、插件，可以通过顶部导航栏中Script--Load Python加载脚本，通过Script--Console Log 打开Log面板，不过这个Log面板远不如Maya的面板信息齐全。 iClone是该公司的另一款软件，用于制作动画，功能与CC十分接近，可以参考iClone的文档编写插件 环境配置 可以参考maya python脚本的环境配置，当时使用的是PyCharm，这里我们使用VS Code VS Code安装Python插件 选择Python解释器（按ctrl+shift+p打开命令界面） 编写脚本 脚本本身不难写，主要是文档和论坛信息太少，某些API的使用可以参考iClone的文档，下面是我认为值得处理的东西 创建带有按钮的窗口 加载脚本后会出现一个对话框，对话框中有一个Label和一个按钮，当按按钮时可以输出”Hello World“ import RLPyfrom shiboken2 import wrapInstancefrom PySide2 import QtWidgetsdef run(): print(&quot;Hello world&quot;)# 类似于main函数，是脚本的入口，加载脚本时自动执行该函数def run_script(): # 创建一个对话框 rl_dialog = RLPy.RUi.CreateRDialog() # 设置对话框名称 rl_dialog.SetWindowTitle(&quot;Main Dialog&quot;) pyside_dialog = wrapInstance(int(rl_dialog.GetWindow()), QtWidgets.QDialog) # 设置对话框宽度 pyside_dialog.setFixedWidth(200) sample_layout = pyside_dialog.layout() # 一个Label label_hello = QtWidgets.QLabel(&quot;Hello World&quot;) # 一个Button button_run = QtWidgets.QPushButton(&quot;run&quot;) # Button绑定事件函数 run button_run.clicked.connect(run) sample_layout.addWidget(label_hello) sample_layout.addWidget(button_run) rl_dialog.Show() 定时任务 定时任务十分重要，通过开启计时，就会定时执行Timeout()内到操作 # 计时器回调class TimerCallback(RLPy.RPyTimerCallback): def __init__(self): RLPy.RPyTimerCallback.__init__(self) def Timeout(self): # 类似于Update print(&quot;Timeout&quot;)# timer，计时器应当放在全局timer = RLPy.RPyTimer()# 设置间隔为 1000 mstimer.SetInterval(1000) # 定时器设为可以重复触发timer.SetSingleShot(False)# 注册事件timer_callback = TimerCallback()timer.RegisterPyTimerCallback(timer_callback)def apply(): # 开始计时 timer.Start()def cancel(): # 暂停计时 timer.Stop() def run_script(): # menu rl_dialog = RLPy.RUi.CreateRDialog() rl_dialog.SetWindowTitle(&quot;main_dialog&quot;) pyside_dialog = wrapInstance(int(rl_dialog.GetWindow()), QtWidgets.QDialog) pyside_dialog.setFixedWidth(200) sample_layout = pyside_dialog.layout() button_apply = QtWidgets.QPushButton(&quot;Apply&quot;) button_apply.clicked.connect(apply) button_cancel = QtWidgets.QPushButton(&quot;Cancel&quot;) button_cancel.clicked.connect(cancel) sample_layout.addWidget(button_apply) sample_layout.addWidget(button_cancel) rl_dialog.Show() 导出当前模型 官网甚至还在用iClone7的老东西误导你，太可恶了！ def export(): # 获取当前场景所有的人物模型（一般只有一个） all_avatars = RLPy.RScene.GetAvatars(RLPy.EAvatarType_All) avatar_name = None for _iter_avatar in all_avatars: avatar_name = _iter_avatar.GetName() avatar = RLPy.RScene.FindObject(RLPy.EObjectType_Avatar, avatar_name) # 导出选项 export_option = RLPy.EExportFbxOptions__None export_option2 = RLPy.EExportFbxOptions2__None export_option3 = RLPy.EExportFbxOptions3__None export_option = export_option | RLPy.EExportFbxOptions_AutoSkinRigidMesh export_option2 = export_option2 | RLPy.EExportFbxOptions2_ResetBoneScale original_size = RLPy.EExportTextureSize_Original default_format = RLPy.EExportTextureFormat_Default setting = RLPy.RExportFbxSetting() setting.SetOption(export_option) setting.SetOption2(export_option2) setting.SetOption3(export_option3) setting.SetTextureSize(original_size) setting.SetTextureFormat(default_format) setting.EnableExportMotion(True) # 开启动画导出，启动后默认导出当前Pose setting.SetExportMotionFps(RLRy.RFps(60)) # 设置导出动画的帧率，会影响动画数据的精度 # 导出文件 result = RLPy.RFileIO.ExportFbxFile(avatar, f&quot;D://Art/man/&#123;file_name&#125;.fbx&quot;, setting) if(result): print(&quot;Success export fbx&quot;) else: print(&quot;Export error&quot;)","categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"}]},{"title":"银河战士like","slug":"game/银河战士like","date":"2023-04-05T10:01:25.000Z","updated":"2025-03-18T07:16:42.960Z","comments":true,"path":"game/银河战士like/","permalink":"https://reubensun.com/game/%E9%93%B6%E6%B2%B3%E6%88%98%E5%A3%ABlike/","excerpt":"","text":"银河战士like 银河战士 我接触银河战士比较晚，还是NS OLED发售时才了解这款游戏，结果上手后立即爱不释手，连续玩了三四天才把普通难度打通。这个游戏的关卡设计给了我极其深刻的印象，我就像做理综试卷一样，揣摩设计者的意图，在没有明确引导的情况下也能找到下一步的目标。 自此一直想做一个类似的游戏，但做了一两年引擎TA后，对策划和GamePlay已经一窍不通了，最近发现Mix-Jim做过Metroid的教程，于是燃起了我做独立游戏的热情，在这里记录一下（2023.4.5），等到毕设做完后就着手开发。 我玩银河战士的心态变化就是： 初始关卡玩家惯性思维向右走，结果发现走到了头，走不动了，然而他惊奇地发现，人物居然能往左走！ 走到左边发现还是走不到，有一个小台阶，台阶上面有个宝箱，然后玩家惊讶得发现，人物居然能跳！ 打开宝箱后你获得了一个能力，但你还不知道是什么，你继续往左走，看到一个房间，房间门太矮了，你过不去，然后你发现，你刚刚获得的能力是变成球！ 靠这种润物细无声的方式，你最后得到了一切，打败了boss，游戏通关，然后告诉你主角是一个比基尼美女，你通关越快，她游戏结束时穿的越裸露！ 你想看裸体吗？赶快二周目吧！ 剧情 游戏剧情 【逆熵科技】宣布打破了能量守恒定律，发明了【无尽能源】，并在某地建造了全球最大的发电厂。奇怪的是，这个发电厂没有人类员工，也不需要输送原材料，更没有污染排放，就能为全世界提供电力，仿佛他们真的发明了无尽能源。随着时间的推移，该发电厂成为地球上最重要也最神秘的设施。 你是一名特警，你在调查一系列【超自然现象】引发的事件，这个事件已经导致多个城市的毁灭，大量生物的绝种，绝症发病率的倍增。经过多年的研究，你发现自从发电厂出现后，超自然事件的发生频率大幅提高，并且事件发生地仿佛以电厂为中心放射分布，于是你申请调查电厂。 不出意外，电厂的调查令并没有批准，你的调查进入僵局，有人暗示你放弃调查。然而一天晚上，电厂出现了事故，收到了求救信号，你作为最近的警官到达了现场，结果却看到非常诡异的画面，电厂的外观变成了【xxx】 你进入电厂后电厂大门立刻锁死，随即又遇到了机械怪物，手枪子弹完全无法伤害他们。你逃到一个房间里，发现了【xxx】，你的手枪接触后形状发生改变，能无需弹药发射脉冲子弹，可以对怪物造成伤害。 你在电厂不断探索，获得了多种【超自然力量】，最后找到求救信息的来源，结果你发现信号来自一扇门，而这个门一直在向外输送能量。 背景 门的那头连接着一个平行世界，那个世界是一个魔法的世界，构成世界的基础物质中有【魔力】的存在，而那个世界正面临着【魔力短缺】的现象。 【魔力】有高能和低能之分，就像我们世界的能量一样，【魔力】由高到低，可以对现实产生影响，被称为【魔法】，而随着【魔法】的普及与滥用，他们世界的【魔力】质量越来越差，他们越来越难以使用魔法。 为了缓解【魔力短缺】，他们向我们这个世界开启了一道门，这个门在将我们世界的物质搬运到他们世界。这个过程影响了双方世界的稳定，我们的世界沉默的【魔力】得到苏醒，引发了基础粒子的分裂，【魔力】吸收了原子释放的部分核能，而其他能量被【逆熵科技】用于发电。传送门将被激化的【魔力】送至他们世界，。 看似双赢，我们得到了能量，他们得到了【魔力】，实则双输。 对于我们 部分【魔力】停留在我们世界中，引起了【超自然现象】，产生了大量次生灾害。 由于我们世界的生物、环境在演变过程中没有【魔力】，因此这些【魔力】无法被我们所使用，反而像辐射一样在破坏我们的细胞结构，影响了人类生存。 对于他们 吸收核能的【魔力】强度过高，而且传送门的位置不像我们这样集中在一个门中，现在他们世界任意一个地方都有可能发生一场小型核爆，可能在天空，可能在地底，也可能在某个人肚子里。他们的世界就像经历核战争一样，到处都是废墟和坑洞。 他们世界大部分设施被摧毁，没有能力关闭传送门，于是他们只能向我们世界发送消息，希望我们可以关闭或改善这个流程，拯救两个世界 设定 电厂被魔化为活物，于是方块被破环后会修复 电厂具有自我保护意识，当核心被抢夺/破环时会召唤boss杀死入侵者（角色拿到一个增强时会进入boss战） 开发计划 角色 跑 跳 快跳（跑起来跳） 慢跳（原地起跳，横向移动速度比跑跳慢一半） 抓墙（差一点点就能跳上的平台，如果手能抓住平台上部，可以抓在墙上） 上平台（抓在墙上按跳跃能上平台） 瞄准射击（按做肩键开启瞄准设计模式，用红线瞄准） 射击为红色激光 按右肩键开启畏缩射击模式，伤害能低，但小怪被击中后会畏缩 近战攻击（两段光剑挥砍，一次从下向上，一次从上向下，第二段后期可以解锁剑气） 近战为蓝色光剑 跟随镜头 无敌时间 被攻击时会触发，角色有菲涅尔描边，此时角色和敌人不会有碰撞 场景物体 普通方块（白色方块） 可被设计破环的方块 破环前不可通行，破环后可以通行，方块被破环后20秒会复原，恢复时有融解恢复特效 射击破环方块（红色方块） 破环时有粒子溅射特效 近战破环方块（蓝色方块） 方块破环时播放破碎动画 敌人 小怪 怪物与角色接触时会向后击飞角色，并给角色0.5秒的无敌时间 飞行怪物 一次仅会有一个飞行怪物攻击角色，并有明显的攻击前摇 前摇攻击时能被近战一击必杀 被畏缩畏缩后会变成一个垫脚石，不再移动，可以被踩踏，20秒后复原 地面怪物 地面角色有一个出生点，平时在出生点左右移动，看到角色后会向角色方向追击 当追击失去视线后，会回到出生点附近，并恢复所有生命 当被畏缩射击后会停止移动一段时间，但角色踩上仍会扣血 Boss 当角色每拿到一个强化，镜头、手柄开始震动，然后boss出现 boss总是可以被刚刚拿到的强化克制 击败boss后会增强角色的最大生命值 场景管理 以（0，0，0）为原点，并设为二维平面的左下角，将场景切分为一个个1x1x1方块组成的世界 分层管理 场景要能导出为scriptableobject 场景编辑 Gizmos绘制场景网格，其中每五格加粗（id % 5 == 0） 摆放吸附 根据起始和终止位置批量生成物体 地图 地图作为单独的全屏界面，目前不打算在游戏屏幕上绘制小地图 地图包含两级缩放 全局地图（展示的是关卡间的关系） 局部地图（展示的是当前关卡的信息，每一个方块都要被绘制） 渲染 尽量使用URP内置的功能 角色要单独写Shader，支持开关菲涅尔描边 全局动态Light Probe，均匀摆放Probe，可以用odin写一个批量摆放插件，注意不要进墙 色调映射和Lut调色 SSAO 抗锯齿","categories":[{"name":"game","slug":"game","permalink":"https://reubensun.com/categories/game/"}],"tags":[]},{"title":"Simplygon插件尝鲜","slug":"dcc/Simplygon","date":"2023-03-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.447Z","comments":true,"path":"dcc/Simplygon/","permalink":"https://reubensun.com/dcc/Simplygon/","excerpt":"","text":"Simplygon插件尝鲜 出于性能等考虑，大型项目往往会使用LOD功能，根据相机距离切换模型精度。而海量的3D模型靠人力拆分LOD显然过于昂贵，因此非常有必要使用模型减面工具，所幸业界已经有非常成熟的商业插件，比如InstaLOD和Simplygon，对于个人开发者，Simplygon提供每日200次的免费使用次数，足够用了 安装 环境为Windows系统+支持Vulkan的显卡 安装VC Redist，这个组件包含了Visual C++的运行时库，VC项目正常运行需要该组件 安装Vulkan SDK 下载Simplygon 选择Free License激活，每个微软账号能有一个Seat，每日200次使用次数 第一个项目 以C#控制台实现模型减面为例 Visual Studio创建一个.Net控制台项目 添加COM依赖，引入转义文件SimplygonDotNetWapper.dll 在项目中添加SimplygonLoader.cs和减面用的模型 编写代码，实现模型按比例减面 static int Main(string[] args)&#123; // 检查是否Load Simplygon using var sg = Simplygon.Loader.InitSimplygon(out var errorCode, out var errorMessage); if (errorCode != Simplygon.EErrorCodes.NoError) &#123; Console.WriteLine($&quot;Failed to initialize Simplygon: ErrorCode(&#123;(int)errorCode&#125;) &#123;errorMessage&#125;&quot;); return (int)errorCode; &#125; // 运行减面程序 RunReduction(sg); return 0;&#125; static void RunReduction(Simplygon.ISimplygon sg)&#123; // 加载模型/场景 Console.WriteLine(&quot;Load scene to process.&quot;); Simplygon.spScene sgScene = LoadScene(sg, &quot;../../../SimplygonMan.obj&quot;); // 初始化 using Simplygon.spReductionProcessor sgReductionProcessor = sg.CreateReductionProcessor(); sgReductionProcessor.SetScene(sgScene); using Simplygon.spReductionSettings sgReductionSettings = sgReductionProcessor.GetReductionSettings(); // 减面设置 sgReductionSettings.SetReductionTargets(Simplygon.EStopCondition.All, true, false, false, false); // 三角面变为50% sgReductionSettings.SetReductionTargetTriangleRatio(0.5f); // 运行 Console.WriteLine(&quot;Start the reduction process.&quot;); sgReductionProcessor.RunProcessing(); // 保存模型，通过修改后缀可以实现导出obj, fbx, usd等类型的模型 Console.WriteLine(&quot;Save processed scene.&quot;); SaveScene(sg, sgScene, &quot;Output.obj&quot;); Console.WriteLine(&quot;Check log for any warnings or errors.&quot;); CheckLog(sg);&#125; static Simplygon.spScene LoadScene(Simplygon.ISimplygon sg, string path)&#123; // Create scene importer using Simplygon.spSceneImporter sgSceneImporter = sg.CreateSceneImporter(); sgSceneImporter.SetImportFilePath(path); // Run scene importer. var importResult = sgSceneImporter.Run(); if (Simplygon.Simplygon.Failed(importResult)) &#123; throw new System.Exception(&quot;Failed to load scene.&quot;); &#125; Simplygon.spScene sgScene = sgSceneImporter.GetScene(); return sgScene;&#125;static void SaveScene(Simplygon.ISimplygon sg, Simplygon.spScene sgScene, string path)&#123; // Create scene exporter. using Simplygon.spSceneExporter sgSceneExporter = sg.CreateSceneExporter(); string outputScenePath = string.Join(&quot;&quot;, new string[] &#123; &quot;output\\\\&quot;, &quot;Reduction&quot;, &quot;_&quot;, path &#125;); sgSceneExporter.SetExportFilePath(outputScenePath); sgSceneExporter.SetScene(sgScene); // Run scene exporter. var exportResult = sgSceneExporter.Run(); if (Simplygon.Simplygon.Failed(exportResult)) &#123; throw new System.Exception(&quot;Failed to save scene.&quot;); &#125;&#125;static void CheckLog(Simplygon.ISimplygon sg)&#123; // Check if any errors occurred. bool hasErrors = sg.ErrorOccurred(); if (hasErrors) &#123; Simplygon.spStringArray errors = sg.CreateStringArray(); sg.GetErrorMessages(errors); var errorCount = errors.GetItemCount(); if (errorCount &gt; 0) &#123; Console.WriteLine(&quot;Errors:&quot;); for (uint errorIndex = 0; errorIndex &lt; errorCount; ++errorIndex) &#123; string errorString = errors.GetItem((int)errorIndex); Console.WriteLine(errorString); &#125; sg.ClearErrorMessages(); &#125; &#125; else &#123; Console.WriteLine(&quot;No errors.&quot;); &#125; // Check if any warnings occurred. bool hasWarnings = sg.WarningOccurred(); if (hasWarnings) &#123; Simplygon.spStringArray warnings = sg.CreateStringArray(); sg.GetWarningMessages(warnings); var warningCount = warnings.GetItemCount(); if (warningCount &gt; 0) &#123; Console.WriteLine(&quot;Warnings:&quot;); for (uint warningIndex = 0; warningIndex &lt; warningCount; ++warningIndex) &#123; string warningString = warnings.GetItem((int)warningIndex); Console.WriteLine(warningString); &#125; sg.ClearWarningMessages(); &#125; &#125; else &#123; Console.WriteLine(&quot;No warnings.&quot;); &#125; // Error out if Simplygon has errors. if (hasErrors) &#123; throw new System.Exception(&quot;Processing failed with an error&quot;); &#125;&#125; 运行，检查减面效果 减面前： 50%减面 10%减面 能看出三角面和顶点数按比例减少了 在使用过程中，发现相同精度的模型，fbx顶点数比obj小，是两者顶点buffer组织的差异导致的吗？还是Win11自带的模型预览器统计方式有问题 其他功能 Simplygon还提供了许多功能，除了基础的静态模型减面生成LOD外，还支持人物模型LOD（保留权重），骨骼缩减，远景、树草替代物生成（如Billboard），遮蔽物减面，详情可以参考官方文档，这里仅抛砖引玉","categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://reubensun.com/tags/CSharp/"}]},{"title":"C与C++的DLL","slug":"program/C++DLL","date":"2023-03-08T15:01:25.000Z","updated":"2025-03-18T07:16:42.965Z","comments":true,"path":"program/C++DLL/","permalink":"https://reubensun.com/program/C++DLL/","excerpt":"","text":"C与C++的DLL 今天中午跟同事吃饭时，有人分享他在清理项目中的Warming，其中包括C++风格的DLL，我才知道，DLL建议写C风格的 根本原因是，C++功能复杂，更依赖Name Mangling，而三大编译器具体实现不尽相同，使得ABI不确定 DLL 我们都知道，代码到可执行文件，要先代码编译得到目标文件，目标文件链接得到可执行文件。但其实可执行文件在执行时，还会进行装载 DLL的本质其实是目标文件的打包，由目标文件和三张表组成 编译 代码会编译为目标文件.obj，目标文件中包含导出符号表，这些符号会有明确的地址 // test1.cppint a; // 在test1.obj文件中a有明确的地址 有的文件中会有只声明，没有实现的符号，放在未解决符号表中。在这些符号没有明确的地址，需要去其他目标文件中寻找 //test2.cppextern int a; // 在test2.obj文件中a没有明确的地址 链接与装载 若程序为静态链接，编译器会在链接阶段扫描导出符号表中的符号地址，将计算后的地址写给未解决符号表中的符号，这个过程被称为重定位 也就是说，从test1.obj中得到a的地址，经过计算，写给test2.obj中的a，这个过程会记录在地址重定向表中 若程序为动态链接，程序会在装载阶段做地址重定向 ABI ABI（Application binary interface） API（Application Programming Interface） 为了保证动态库的版本兼容性，大部分平台会要与DLL函数编写时，要符合ABI ABI包含了二进制的结构布局、访问方法，应用程序可以通过ABI访问库中的二进制数据，代码编译出的ABI与编程语言、操作系统、编译器有关，通常是不确定的 二进制文件格式 不同操作系统的二进制可执行文件格式不同，因此无法兼容 ELF（Executable and Linkable Format），可执行可链接格式，是Linux系统的二进制可执行文件格式 PE（Portable Executable），可移植可执行格式，是Windows系统的二进制可执行文件格式 Name Mangling Name Mangling会对名字进行重新编码，以实现名字的唯一性 C++支持函数重载、类、命名空间、模版，一个类中可以有多个重名函数、重名成员变量，这些名称编译后本质是不同的二进制，因此要做更复杂的Name Mangling 很不幸的是，C++没有对Name Mangling做硬性规定，于是三大编译器g++、MSVC、clang的实现不同，相同的代码可能编出不同的ABI，当你使用跨编译器的dll时，很容易出现错误 C的DLL 和C++相比，C就简单得多 大多数语言都提供了一些简单的方法调用C的DLL，而且C++编译器也支持导出C语言的DLL 生成DLL Windows下生成DLL会得到三个产物：include头文件，dll文件，import library文件 注意import library文件的后缀是.lib，但这个文件只是存储了符号表，并不是其他平台的静态库 MT与MD 操作系统将一些高频使用的代码写成DLL，并永远加载在内存中，称为CRT库 在VS生成DLL时，有MT和MD两个选项 MD指动态C运行时，程序执行时依赖于操作系统提供的CRT MT指静态C运行时，程序会将操作系统的一些CRT静态链接到程序中，运行时就不需要从操作系统那里装载 值得注意的是，如果一个程序混用MT和MD，很容易出现版本不兼容的错误（尤其是在使用编译好的第三方库时） C++生成DLL CMakeList.txt SET(LIB_SRC ./Math.h ./Math.cpp)SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ../libMath)ADD_LIBRARY(MathDLL SHARED $&#123;LIB_SRC&#125;)INSTALL(TARGETS MathDLL)SET_TARGET_PROPERTIES(MathDLL PROPERTIES LINKER_LANGUAGE C RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125; LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125; OUTPUT_NAME &quot;MathDLL&quot; PREFIX &quot;&quot;) Math.h #define DLL_EXPORT extern &quot;C&quot; __declspec(dllexport)DLL_EXPORT int MathAdd(int a, int b); Math.cpp #include &quot;Math.h&quot;int MathAdd(int a, int b)&#123; return a+b;&#125; 动态加载DLL windows下DLL加载： 分析可执行文件的导入符号表，查找所需要的dll文件 为dll文件开辟虚拟地址空间 当dll被真正调用时，将dll文件加载到内存中 #include &lt;iostream&gt;#include &lt;Windows.h&gt;typedef int (*pfnAdd)(int, int);int main() &#123; HINSTANCE handle = LoadLibrary(TEXT(&quot;../lib/libMath/MathDLL.dll&quot;)); pfnAdd pAdd = (pfnAdd) GetProcAddress(handle, &quot;MathAdd&quot;); std::cout &lt;&lt; pAdd(1, 2) &lt;&lt; std::endl; FreeLibrary(handle); return 0;&#125; 参考 DLL written in C vs the same written in C++ What is an application binary interface (ABI)? 使用CMake生成动态链接库DLL","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"算法：前缀和","slug":"program/前缀和","date":"2023-03-07T22:01:25.000Z","updated":"2025-03-18T07:16:42.969Z","comments":true,"path":"program/前缀和/","permalink":"https://reubensun.com/program/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"前缀和 本人没有算法基础，以下均为春招刷Leetcode的笔记，仅用于记录，侵权勿喷 前缀和本质是一种预积分手段，运行时只需要得到边界值，就能快速、无损地获得区间积分值，二维的前缀和SAT在图形学中也有重要的运用 注意数组越界，尤其是前缀乘 明确索引的含义，这关系着数组的长度是否需要+1 前缀和可以使用哈希表加速查找 除自身以外数组的乘积 leetcode 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 特点 使用左右两个前缀和 思路 最简单的方法自然是求所有数的总乘积，ans[i] = total / nums[i]，不过这道题让我们不要用除法（如果数中有0，这种做法也是错的） 我们从左做一次前缀乘，left[i]表示以0~i的前缀乘，从右开始做一次前缀乘，right[i]表示以i~n-1的前缀乘 ans[i]将数组切分为三个部分，他自己，左边和右边，左边等于0~i-1的总乘积，右边等于i+1～n-1的总乘积，左右相乘即可得到最终结果 对于边界做特殊处理 实现 vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; left(n); left[0] = nums[0]; vector&lt;int&gt; right(n); right[n-1] = nums[n-1]; // 求左右前缀和 for(int i = 1; i &lt; n; ++i)&#123; left[i] = left[i-1] * nums[i]; right[n-i-1] = right[n-i] * nums[n-i-1]; &#125; vector&lt;int&gt; ans(n); // 边界处理 ans[0] = right[1]; ans[n-1] = left[n-2]; for(int i = 1; i &lt; n-1; ++i)&#123; ans[i] = left[i-1] * right[i+1]; &#125; return ans; &#125; 和为k的子数组 leetcode 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 -1000 &lt;= nums[i] &lt;= 1000 特点 数组有正有负，因此前缀和不递增 思路 固定右端点，向左找左端点，若存在和为k的连续子数组，我们能找到一个左端点，使得左右端点前缀和之差为k 由于数组中包含负数，因此左端点可能有多个 于是问题转化为从右端点出发，寻找值为ps[j] - k的左端点 当遍历完i后，当前右端点preSum[i]未来也可能是左端点，于是加入哈希表中 实现 int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; preSum(n+1, 0); unordered_map&lt;int, int&gt; mp; // value：key出现过的次数 mp[0] = 1; for(int i = 0; i &lt; n; ++i)&#123; preSum[i+1] = preSum[i] + nums[i]; &#125; int ans = 0; for(int i = 1; i &lt;= n; ++i)&#123; ans += mp[preSum[i]-k]; ++mp[preSum[i]]; // 在遍历完i之前，我们还没遇到过i &#125; return ans; &#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://reubensun.com/tags/leetcode/"}]},{"title":"算法：区间重叠","slug":"program/区间重叠","date":"2023-03-07T22:01:25.000Z","updated":"2025-03-18T07:16:42.969Z","comments":true,"path":"program/区间重叠/","permalink":"https://reubensun.com/program/%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/","excerpt":"","text":"区间重叠 本人没有算法基础，以下均为春招刷Leetcode的笔记，仅用于记录，侵权勿喷 今天刷题时发现一类区间重叠题，思路很巧妙，理解后做起来非常简单 这类题的特点就是给你一组区间，求最多多少个区间重叠 会议室Ⅱ leetcode 给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间，返回 所需会议室的最小数量 输入：intervals = [[0,30],[5,10],[15,20]]输出：2 思路 我们将区间转化为两次操作，对于每一个区间，区间开始会申请一个会议室，区间结束会释放一个会议室 将操作按发生时间排序，依次执行，记录占用会议室的最大数量 实现 int minMeetingRooms(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; vector&lt;vector&lt;int&gt;&gt; v; for(auto&amp; i : intervals)&#123; v.push_back(&#123;i[0], 1&#125;); // 区间开始申请一个会议室 v.push_back(&#123;i[1], -1&#125;); // 区间结束释放一个会议室 &#125; sort(v.begin(), v.end()); // 将操作按发生时刻排序，对于同时发生的操作，先释放再申请 /* sort(v.begin(), v.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)-&gt;bool&#123; if(a[0] == b[0])&#123; return a[1] &lt; b[1]; &#125; return a[0] &lt; b[0]; &#125;); */ int ans = 0; int cur = 0; for(int i = 0; i &lt; v.size(); ++i)&#123; cur += v[i][1]; ans = max(ans, cur); &#125; return ans; &#125; 拼车 leetcode 车上最初有 capacity 个空座位。车只能向一个方向行驶（也就是说，不允许掉头或改变方向） 数组每一项包含三个数，上车人数，上车时刻，下车时刻 当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。 输入：trips = [[2,1,5],[3,3,7]], capacity = 4输出：false 思路 与上题基本相同，不过每次操作的数量改变了 实现 bool carPooling(vector&lt;vector&lt;int&gt;&gt;&amp; trips, int capacity) &#123; vector&lt;vector&lt;int&gt;&gt; v; for(auto&amp; t: trips)&#123; v.push_back(&#123;t[1], t[0]&#125;); v.push_back(&#123;t[2], -t[0]&#125;); &#125; sort(v.begin(), v.end()); int cur = 0; for(int i = 0; i &lt; v.size(); ++i)&#123; cur += v[i][1]; if(cur &gt; capacity)&#123; return false; &#125; &#125; return true; &#125;","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://reubensun.com/tags/leetcode/"}]},{"title":"Google C++代码规范","slug":"program/GoogleC++","date":"2023-03-05T19:01:25.000Z","updated":"2025-03-18T07:16:42.966Z","comments":true,"path":"program/GoogleC++/","permalink":"https://reubensun.com/program/GoogleC++/","excerpt":"","text":"Google C++ 代码规范 Google C++ Style Guide Google提出的一套代码规范，能提高代码的可读性，减少出错。建议配合Effective C++阅读 头文件 所有头文件都应该自给自足（self-contained） self-contained : compile on their own 确保你的header files包含了你需要的所有东西，而不是假设你#include进来的某个（些）headers帮你包含了你需要的东西。 A.h包含了B.h和C.h，而B.h也包含了C.h，那么在A.h中使用C.h时，会难以判断到底该用哪一个 #define 保护 每个头文件都要使用#pragma once保护 前置声明 我个人理解的前置声明，是指在一个.h文件中开头声明另一个.h文件中的类，以此来实现类似#include某个文件的某一部分 与之对应的是直接使用#include引入文件，但这样实际会增加编译工作量，降低编译速度，于是我们非必要不#include Google建议要避免使用前置声明，因为使用前置声明会影响类的修改，也容易产生错误 但使用前置声明可以提高编译速度，因此需要按情况选择 优点 节省编译时间，避免很多不必要的（因为头文件改动而导致的）重新编译 缺点 隐藏了依赖关系 头文件改动时会破坏后续，影响开发者改动API（比如当你要添加一个形参时） 但这个是不是可以通过宏的方法避免？#define Func Func 两个类互相引用 前置声明（Forward Declarations）基本仅用于两个类互相引用 // A.h#include &quot;B.h&quot;class A&#123; B b; //A中使用了B，因此 ...&#125; // B.hclass A;class B&#123; A* a; ...&#125; 失去依赖关系 前置声明最大的问题是失去依赖关系 // B.hstruct B &#123;&#125;;struct D : B &#123;&#125;; //这里的D继承自B #include &quot;b.h&quot;// 如果使用前置声明替换掉#include，就会出现错误void f(B*);void f(void*);void test(D* x) &#123; f(x); &#125; // Calls f(B*) 内联函数 除非是极其高频调用，确定是性能瓶颈的地方，不然不用内联函数 不要内敛超过十行的函数 析构函数远比表面要长，因为他隐式调用着成员和基类的析构函数 #include路径 按照源码目录树结构排列，避免使用UNIX的快捷目录，比如.（当前目录）和..（上级目录） #include顺序 C头文件 C++头文件 第三方库头文件 本项目头文件 作用域 命名空间将全局作用域细分为独立具体的作用域，可以有效防止全局命名冲突 #include &quot;a.h&quot;namespace MyNamespace&#123; class MyClass &#123; ... &#125;;&#125; //namespace MyNamespace 请在命名空间最后注释出命名空间的名字 不要污染命名空间 不要在std命名空间中声明任何东西 不要使用using namespace xxx 不要在头文件中使用命名空间别名，如namespace bbb = ::Foo::Bar::Baz 静态变量 不要在.h文件中声明静态变量，至少不能用全裸的静态变量 不要定义静态存储周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中静态变量的构造和析构顺序不确定，会导致bug（除非你使用constexpr） 原生数据类型（POD，Olain Old Data），如int、char、float，int*、int[]、结构体 在同一编译单元，静态初始化会优先于动态初始化，并按照声明顺序初始化，以逆序销毁 但是不同编译单元，初始化、销毁顺序是未定义行为 类 构造函数不要调用虚函数 在类被完全初始化前，这个类其实是基类+其他部分，此时调用虚函数不一定会指向子类的重载，可能会报错、出错 优点 不需要考虑类是否被完全初始化 初始化的对象可以为const类型 如果你想进行有意义的non-trivial初始化，可以使用明确的Init()方法，或者工厂模式 与之对应，析构函数要设为虚函数 不要隐式类型转换 不要使用隐式类型转换 隐式转换会降低代码可读性，由于是存在函数重载时，让人难以判断到底在用哪一个函数 隐式转化可能会导致类型不匹配的错误 使用explict关键词（常用于单参数构造函数和类型转化操作符），可以使当前类型只能被显示类型转换，如果使用隐式转化，会报错 class Foo&#123; explicit Foo(int x, int y); //这个类型不能被隐式转化，调用Func(&#123;42, 3.14&#125;)会报错 ...&#125;void Func(Foo f); 拷贝和移动 如果你的类型需要拷贝和支持，就请实现它，否则禁用它（=delete） std::unique_ptr&lt;int&gt; 可移动，但是不能复制 可拷贝类型，可以使用相同类型的另一对象进行初始化，当前对象会得到相同的值，同时不改变源对象。 用户通过定义拷贝构造函数、拷贝赋值操作符实现 可移动对象，可以使用相同类型的临时对象进行初始化，当前对象会得到相同的值 用户通过定义移动构造函数、移动赋值操作符实现 不要为任何有可能有子类的类型提供拷贝和移动，可能会导致对象割裂 除了数据成员，其他一律用class C++的class和struct很像，大部分功能相同，不过 struct可以拥有成员变量，但不能拥有成员函数（你可以写非成员函数+引用） struct成员为public，而class可以拥有private成员 struct的继承方式为public，比class少（尽管全世界C++项目99%的继承都是public继承） struct与pairs、tuples struct的字段名更具可读性，当数据有意义时，尽量使用struct 不过pairs和tuples更适用于泛型编程 组合与继承 组合很好用，能用接口用接口，如果非要用继承，请public继承 对于虚函数进行重载时，用override、final标记，尽管这个关键字没有什么作用，但能提高代码可读性 全世界C++项目99%的继承都是public继承 public、protected、private继承你可以理解为设限 如果是public继承，那么子类访问父类成员的存取类型都不会超高public（废话），父类的public、protected、private成员，对于子类为public、protected、private 如果是protected继承，那么子类访问父类成员的存取类型都不会超高protected，父类的public、protected、private成员，对于子类为protected、protected、private 请不要使用多重继承，不过你能继承多个接口 关于接口 接口是用interface标记的类，只有纯虚数和静态函数，没有非静态成员 接口不能被直接实例化，也不需要定义构造函数 请为接口实现虚析构函数 请不要为其添加函数实现或非静态成员数据 操作符重载 尽量别重载 访问控制 类的数据成员应该为private，除非是一个常量 数据成员设为private，然后编写public的访问函数，不过感觉不如C#的属性优雅 声明顺序 随便找个.h文件，看看类的声明是怎么写的 相似的声明放在一起，并按以下顺序 类型及类型别名（typedef, using, enum ，嵌套的结构体和类） 静态常量 工厂函数 构造函数和赋值运算符 析构函数 其他函数 数据成员 先写public，再写protected、private 不要将大段的函数定义写在类定义中，建议.h声明，.cpp定义 函数 参数 见名知意，知行合一 看到函数名就能知道这是干什么的，比如Get、Set，如果一个函数是Get，那就做Get的事 优先使用返回值而非输出参数，这能提高可读性和性能 不要返回空指针（除非你是这样设计的） 输入参数、不需要改变的参数可以用const引用 输出参数、可以被修改的参数可以用指针 参数需要排序，输入先于输出，无默认值先于有默认值 void foo(const std::string&amp; in_str, std::string* out_str); 简短的函数 个人感觉完全没必要，尤其是对于C#、Java，40行好干什么 简短的函数能提高代码可读性，提高调试效率，在函数式编程很常用 函数重载 函数重载能够使同一作用域中，有一组相同函数名、不同参数列表的函数，常用于命名一组功能相似的函数 不过如果函数仅靠参数类型进行重载，就会涉及匹配、派生类之类的问题，让人感受困惑 如果要重载Append()，其实可以在函数名上添加类型信息，比如AppendInt()、AppendString() 缺省参数 写缺省不如写重载 缺省本质上就是一种函数重载，所有不适合使用重载的地方，都不适合使用缺省 由于缺省参数会干扰函数指针，因此一定不要在虚函数中使用缺省参数 函数返回值的后置写法 后置写法本身没问题，swift、js等语言都是这样写的，但是对于C++来说是一种“很新的东西”，容易让人感到困惑 C++11后，C++的函数可以使用后置返回类型，不过除了lambda表达式，一般不这样写 // 前置写法int foo(int x);// 后置写法auto foo(int x) -&gt; int;// lambda只能后置写法sort(vec.begin(), vec.end(), [](int a, int b) -&gt; bool &#123; return a &lt; b; &#125;); 在泛型编程中，当返回类型依赖于模版参数时，也可以使用后置写法，能提高可读性 // 前置写法template&lt;class T, class U&gt;decltype(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u);// 后置写法template&lt;class T, class U&gt;auto add(T t, U u) -&gt; decltype(t + u); 所有权和智能指针 关于所有权和智能指针，可以参考垃圾回收中引用计数法 C++标准鼓励我们使用智能指针管理资源 对于一个动态的对象，我们更倾向于让其拥有单一、固定所有权（ownership），并使用指南指针做所有权转换 std::unique_ptr，独占资源 当指针离开作用域，资源就会被销毁 无法复制（copy），但能转移（move）所有权 std::shared_ptr，共享资源 当资源失去所有引用时，资源被销毁 可以复制，共享所有权（无需转移） 好处 有的对象甚至没法复制，只能转移 转移通常比复制更高效，尤其是一些const对象，转移比深拷贝高效得多 使用智能指针能提高可读性，也减少了内存泄漏 其他 右值引用 关于左右值，建议阅读C++11 只在定义移动构造函数和移动赋值操作时使用右值引用 推荐使用std::move，不要使用std::forward（除非你在模版编程） // copyvoid set(const string &amp; var1, const string &amp; var2)&#123; m_var1 = var1; m_var2 = var2; &#125;// movevoid set(string &amp;&amp; var1, string &amp;&amp; var2)&#123; m_var1 = std::move(var1); m_var2 = std::move(var2);&#125;// forwardtemplate&lt;typename T1, typename T2&gt;void set(T1 &amp;&amp; var1, T2 &amp;&amp; var2)&#123; m_var1 = std::forward&lt;T1&gt;(var1); m_var2 = std::forward&lt;T2&gt;(var2);&#125; forward的作用是什么？ 如果不使用forward，我们需要同时定义copy和move函数，在处理左值时调用copy，处理右值调用move，这增加了代码量，如果使用forward，我们只需要写一份 但forward让一个函数能干两种事，这不符合“知行合一”，为了代码可读性，我们通常不会使用。如果我们明确这个函数要move，那就用move 友元 友元：在定义一个类时，可以将一些（定义在外部的）函数声明为友元，这些友元函数可以访问该类的private、protected成员 友元扩大了类的封装，在OOP中很忌讳，但只要合理，还是可以用的 原本是private的成员，对于友元类、函数，都是public的 友元类似一种许可，当一个类设置友元后，相当于给友元开了管理员权限，能随意访问原本受保护的成员 如果你要用，请写在同一个文件中 class Child&#123;public: Child() &#123; name = &quot;default name&quot;; &#125; string getName() &#123; return name; &#125; friend class Mother; // 母亲有权利修改孩子的名字，尽管setName是private的private: string name; void setName(string nn) &#123; name = nn; &#125; &#125;;class Mother&#123;public: Child child; void renameChild(string nn)&#123; child.setName(nn); &#125;&#125;;int main()&#123; Mother mother; Child child; mother.child = child; // child.setName()的访问控制为private，你没法在这里调用 cout &lt;&lt; mother.child.getName() &lt;&lt; endl; // default name mother.renameChild(&quot;Tom&quot;); cout &lt;&lt; mother.child.getName() &lt;&lt; endl; // Tom return 0;&#125; 异常 谷歌不使用C++异常，让异常Let it crash。不过异常在C#、Java、Swift中很常用， 抛异常可能会导致一些未定义行为，比如不要在析构函数中使用异常 不使用异常，如果出错常用方法为： 直接abort() 吞异常，Let it crash RTTI 不使用运行时类型识别，不使用typeid和dynamic_cast 运行时类型识别会使代码难以维护，如果你需要用RTTI（除了单元测试），说明你的类设计的不好 类型转化 使用C++风格的类型转化（而非C风格的） double double_value;// C++float f = static_cast&lt;float&gt;(double_value);// Cfloat f2 = (float)double_value; 使用static_cast做值转换、子类指针转父类指针 使用const_cast去掉const限定符 使用reinterpret_cast做指针和整型、指针和指针间的转换（仅在你会用时使用） 不使用dynamic_cast 严格别名 C++的reinterpret_cast不会编译为任何CPU指令，会编译为纯汇编，于是你可以像汇编一样操作指向内存的指针地址，破坏了C++对汇编对抽象 严格别名（strict aliasing）规定：只有同一种类型的指针，才可以出现别名，总之没事别做不相干类型的指针转化 float* f;int* i;// 编译器优化时会假定 f != i// 若你的代码让 f == i （比如使用reinterpret_cast），那就是未定义行为，违反严格别名规则 当你通过指针，将一个struct塞到一个buffer中，或者将一个buffer塞到struct中，在这个过程中，指针的类型发生转换，从buffer转化为struct typedef struct Msg &#123; int a; int b;&#125; Msg;int main() &#123; int x[2] = &#123;1, 2&#125;; int* p = x; Msg* msg = (Msg*)p; // Msg* msg = reinterpret_cast&lt;Msg*&gt;(p); cout &lt;&lt; msg-&gt;a &lt;&lt; endl; // 1 cout &lt;&lt; msg-&gt;b &lt;&lt; endl; // 2 return 0;&#125; 上面这个过程干了什么？你知道这个buffer的内存地址、长度，你想直接用这些信息访问内存，这是对的，但是某些情况下这就是未定义行为 流 谷歌认为除了日志接口需要，不要使用流 说实话我感觉流挺方便的，只要能保持输出的一致性就行，而且C++的Stream类型安全，用起来十分方便，尤其是输出字符串和对象时 自增与自减 谷歌建议一律使用前置自增自减，尤其是迭代器 一般而言，使用前置自增++i能提高性能，后置会生成临时对象和拷贝复制 不过，如果自增自减后变量并没有被用到，仅仅是用于记录迭代次数，编译器会对后置自增自减进行优化，性能一样，而且后置更像自然语言，可读性更强 const 在任何能使用const的地方使用const或constexpr 整型 C++内置的整型只，只使用int 如果需要明确长度，那就用&lt;cstdint中的int16_t、int64_t 如果你不确定用何种大小的int，那么用最大的 可移植性 代码应该对32位和64位系统友好，在处理打印、比较、结构体对齐时要注意 不是所有人都在用64位系统（不过iOS这种封闭平台确实做到了完全禁用32位） 预处理宏 尽管在图形Shader中，用宏进行条件变异很常用，但这其实是因为GPU对分支的处理不好，因此我们通过编译多份代码来避免运行时使用分支。不过这对CPU代码纯属是提高包体，降低可读性，增加调试难度，不推荐使用 宏具有全局作用域，使你看到的和编译器看到的内容不同，尽量用内联、const进行替换 不要使用宏做条件编译 不要在.h文件中定义宏 使用完#define后要立刻#undef 不要使用展开后让C++构造不稳定的宏 #define max(a,b) (a &gt; b ? a : b) int x = 5, y = 6;int n = max(++x, ++y); // 本质为 int n = (++x &gt; ++y ? ++x : ++y)，和预期不一致 不要在宏后面写单行注释 不要用##处理函数、类、变量的名字，可读性很差 // 用##将两个宏拼起来，很trick的写法#define CONS(a,b) int(a##e##b)cout &lt;&lt; CONS(2, 3) &lt;&lt; endl; // 输出2000，因为CONS宏将2和3拼成了2e3 nullptr 空指针用nullptr，数值用0（或者0.0），std::string用\\0 绝对不要用NULL sizeof sizeof用于获取类型的大小，不过不建议对类型使用，而是对varname使用 MyStruct data;memset(&amp;data, 0, sizeof(MyStruct)); // 对类型使用，不推荐memset(&amp;data, 0, sizeof(data)); // 对varname使用，推荐// 如果有人改动了data的类型，比如改成了MyStruct2，第二种方法不会出错 类型推断 函数模版参数类型推断 template&lt;typename T&gt;void f(T t);f(0); // f&lt;int&gt;(0) 类模版类型推断 Class Template Argument Deduction（CTAD） std::array a = &#123;1, 2, 3&#125;; // a is a std::array&lt;int, 3&gt; auto变量类型推断 若一个变量被声明为auto，那么它的类型会自动匹配成初始化表达式的类型 auto a = 42; // a is an intauto&amp; b = a; // b is an int&amp;auto d &#123;42&#125;; // d is an int, not a std::initializer_list&lt;int&gt;auto il = &#123;1,2,3,4&#125;; // il is a std::initializer_list&lt;int&gt; 有的变量类型巨长（尤其是使用模版和命名空间时），而且一次初始化要写两遍，使用auto能提高可读性 仅在局部变量中使用auto，比如for循环 仅在一眼能看出类型的地方使用auto 不要列表初始化auto变量 for(auto&amp; i: list)&#123;...&#125; 函数返回值类型推断 不要用于函数返回值，除非你是lambda使用后置返回值 auto f() -&gt; int &#123; return 1; &#125; 指定的初始化 C++20才加入的新东西，感觉大家的项目基本都没法用吧 可以方便的生成高可读性高聚合的初始化表达式，尤其对一些字段顺序不明显的结构 struct Point &#123; float x = 0.0; float y = 0.0; float z = 0.0;&#125;;Point p = &#123; .x = 1.0, .y = 2.0, // z will be 0.0&#125;; Lambda表达式 将所有的捕获显示写出来 只有lambda声明周期很短时，才使用[&amp;] 使用[=]显式捕获 [=](int x) &#123; return x + n; &#125; // 默认捕获方式，不好[n](int x) &#123; return x + n; &#125; // 显式捕获方式，好[&amp;] &#123; foo.doSomething(); &#125; // 不好[&amp;foo] &#123; foo.doSomething(); &#125; // 好 泛型编程 避免复杂的泛型编程，这东西可读性相当差，调试难度相当高 别名 别名（Aliases）能让复杂类型的名字变简单，尤其是那些带有命名空间的类型 typedef Foo Bar; // 传统方法using Bar = Foo; // C++11后推荐的用法 不要在公共区域使用别名，除非你写对其写详细注释 不要在公共区域引入命名空间别名 命名规范 命名规范因项目而异，只要保持一致性即可，谷歌的命名规范我个人不习惯，可能我C#、Swift写的比较多，感觉好奇怪 通用规范 命名别嫌长，要见名知意 你看看人家Java的方法名长度 不要用汉语拼音 你要记住，英语是表音文字，因此可以靠读音/26个字母排列明确意义，而汉字是象形文字，形状才能明确意义，只靠汉语拼音无法明确区分同音字词。 而且汉语拼音是新中国扫盲、普及普通话的工具，不仅外国人看不懂，甚至一些说方言的人也看不懂 慎用缩写 日本人用假名翻译“龙”，还省去了几个词，结果/ˈdræɡən/硬是读成了“多拉贡” 注释 见名知意，自文档的代码确实好，但有时你还是需要写注释，以提高可读性 每个文件开头写入版权公告（不要轻易删除原作者的信息） 代码段行前注释，描述类行后注释，行后注释要对齐 假设读代码的人水平比你高，有些过于明显的API解释，不要写（不会有人给i++写注释吧） 标点、换行（对于python，yml很重要）建议依赖IDE，统一即可 写TODO（比如Xcode就支持TODO:和MARK:，很多IDE都能检查） 如果一个接口被弃用，可以写弃用注释DEPRECATED 格式 个人建议格式依赖IDE，如果你有自己的坚持，那么先配置IDE 一行不能太长，不然别人要缩放屏幕或者拖动水平滚动条，#include语句除外 使用UTF-8编码（GB-2312的中文注释用UTF-8打开就是乱码） 只使用空格而非制表符，IDE都支持将制表符替换为空格，建议一个制表符=4个空格 返回类型，函数名，前几个参数都放在头一行 空行不要超过两行","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"光学复习","slug":"optics/光学复习","date":"2023-03-03T15:01:25.000Z","updated":"2025-03-18T07:16:48.440Z","comments":true,"path":"optics/光学复习/","permalink":"https://reubensun.com/optics/%E5%85%89%E5%AD%A6%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"光学复习 复习重点 [x] 相速度 [x] 偏振态 [x] 费马原理 [x] 横向放大率 [x] 薄透镜成像 [ ] 透镜组成像（做图法） [ ] 反射过程中的相移 [ ] 布鲁斯特角 [ ] 反射光与折射光的偏振态 [x] 全反射 [x] 相干条件 [x] 杨氏双缝干涉 [x] 时间、空间相干性 [x] 等倾干涉 [x] 等厚干涉 [ ] 迈克尔逊干涉仪 [ ] 多光束干涉 [x] 增反膜与增透膜 [x] 惠更斯-菲涅尔原理 [x] 衍射的分类 [ ] 衍射与傅立叶变换 [ ] 单缝衍射 [x] 圆孔衍射 [ ] Airy斑 [ ] 瑞丽判据 [ ] 多缝衍射 [x] 光栅方程 [ ] Abbe成像原理 [ ] 最小分辨距离、角度 [x] 光栅 [x] 双折射 [x] 惠更斯作图法 [ ] 波片 [x] 光偏振态的改变与检测 [x] 黑体辐射与光量子 作业解析 3.32 一个4.0 v白炽手电筒灯泡消耗0.25 A，将约1.0%的耗散功率转化为光(λ≈550 nm)。如果梁的截面积是10平方厘米，近似圆柱形 (a)每秒发射多少光子?(b)每米光束中有多少光子?©光束离开手电筒时的通量密度是多少? a 根据功率和光的能量公式 $$ P=UI $$ $$ n\\hslash c/\\lambda=0.01P $$ 求出n b 每米光子数=光子总数/长度 $$ nt=ct $$ $$ c=3.0\\times 10^8 $$ c $$ 密度=0.01P/S $$ 8.4 描述下列光的偏振态 根据xy的振幅和相位判断偏振态 $$ \\delta=(E_x/E_y)\\Delta \\varphi $$ ab $$ E_x/E_y=-1 $$ $$ phase(E_x)=phase(E_y) $$ 偏振方向为 $$ -\\pi/4 $$ c $$ E_x/E_y=1 $$ $$ phase(E_x)=phase(E_y)+\\pi/4 $$ 偏振方向为 $$ \\pi/4 $$ d $$ E_x/E_y=1 $$ $$ phase(E_x)=phase(E_y)-\\pi/2 $$ 偏振方向为 $$ -\\pi/2 $$ 记偏振态的技巧 $\\delta = 0$时，是一个左下到右上的线偏振，随着$\\delta$增大，偏振的形状呈正弦形状，左顺右逆 7.36 证明组速度可以写成 $$ v_g=\\frac{c}{n}+\\frac{\\lambda c}{n^2}\\frac{\\mathrm{d}n}{\\mathrm{d}\\lambda} $$ 证明 5.5 考试例题 求反射光偏振 根据shell公式求折射角 $$ 1 \\times \\sin \\theta = n\\sin \\gamma $$ $$ \\gamma = 18.7^{\\circ} $$ 根据菲涅尔公式求出反射光ps偏振比 $$ r_p=\\frac{\\tan (\\alpha - \\gamma)}{\\tan (\\alpha + \\gamma)}=0.176 $$ $$ r_s=-\\frac{\\sin (\\alpha - \\gamma)}{\\sin (\\alpha + \\gamma)}=-0.261 $$ 得到反射光ps分量 $$ E_p=r_pE_0\\cos 45^\\circ $$ $$ E_s=r_sE_0\\sin 45^\\circ $$ 求反射光的偏振和入射面的夹角$\\theta’$ $$ \\theta’=\\arctan|\\frac{r_s}{r_p}|=\\arctan 1.483=56^\\circ $$ 由于入射角小于布鲁斯特角 $$ \\alpha_B = \\arctan n=57.3^\\circ $$ 所以ps都有相位移，合成后仍在13象限","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：光源","slug":"optics/光源","date":"2023-03-03T10:01:30.000Z","updated":"2025-03-18T07:16:48.440Z","comments":true,"path":"optics/光源/","permalink":"https://reubensun.com/optics/%E5%85%89%E6%BA%90/","excerpt":"","text":"十一：光源 内容概述 黑体辐射 光电效应 波粒二象性 黑体辐射 室温下的铁是黑灰色，高温下是暗红色，极高温下是橙色 任何温度大于绝对零度的物体，都会发出热辐射（Thermal radiation），这是由带电粒子随机运动产生的 处于平衡状态的物体，能量吸收率等于释放率，高吸收伴随着高释放 基尔霍夫辐射定律 将一个物体置于一个等温真空室中，物体会吸收真空室中的热辐射，达到相同的温度（无论物体和环境的材质） 处于热平衡的物体满足 $$ R/\\alpha=I $$ $R$，Radiation，物体的辐射率 $I$：Irradiance，真空室的辐照度 $\\alpha$：吸收率 基尔霍夫辐射定律：在热平衡状态下，光谱辐照度和光谱吸收系数之间的比值仅与辐射波长和温度有关，与辐射物体本身的性质无关。 $$ f(\\lambda, T)=\\frac{r(\\lambda, T)}{\\alpha(\\lambda, T)} $$ 联系两个方程可得：好的吸收器是好的发光器（A good absorber is a good emitter） 黑体 黑体：在任何温度和波长下，吸收率$\\alpha$都为1的材质 $$ \\alpha \\equiv 1 $$ 黑体辐射实验 光电效应 光量子假说 爱因斯坦提出光量子假说，成功解释了光电效应的实验现象 康普顿散射 1923年，康普顿发现，当x射线穿过石墨和金属等材料时，除了波长不变的散射外，还存在散射光子，随着散射角的增大，其波长也会变大。 波粒二象性 激光 原子能级跃迁，从高能态到低能态，会发射激光 激光（Laser，Light Amplification by Stimulated Emission of Radiation）","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：各项异性","slug":"optics/各向异性","date":"2023-03-02T10:01:30.000Z","updated":"2025-03-18T07:16:48.440Z","comments":true,"path":"optics/各向异性/","permalink":"https://reubensun.com/optics/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7/","excerpt":"","text":"十：各向异性 内容概述 光在各向异性的介质中的传播 偏振 双折射晶体 透过双折射晶体（比如方解石晶体），在某些角度只有一个像，在某些角度会有两个像 双折射 现象：一束光经过晶体后被分为了两束光 我们称之为o光和e光 o光：按折射定律传播的光 e光：不按折射定律传播的光 光轴：光束沿着光轴传播时，o光和e光不分开（这个方向两个折射率是相同的） 主截面：界面法线和光轴构成的平面 主平面：晶体内光线和光轴构成的平面 o光和e光都是线偏振光，o光的振动方向与主平面垂直，e光的振动方向与主平面平行 单轴晶体：只有一个光轴的晶体，比如方解石、石英 双轴晶体：有两个光轴方向的晶体，比如云母、蓝宝石、硫磺 o光和e光的光速不同，波面形状也不同 o光沿各个方向的传播速度相同，于是波面是一个球 e光沿着不同方向传播速度不同，我们特别的选取垂直于光轴的面作为e光的波面，这个波面是一个椭圆 这两个椭圆是相切的，但大小不确定 若o光比e光大，那么是正晶体 若o光比e光小，那么是负晶体 惠更斯作图法 偏振态：我们在光线上各距离绘制短线和圆点，用来表示偏振 短线表示偏振沿着纸面 点表示偏振垂直纸面 自然光横线和点的数量应该一样多 绘制折射光 过A点做边缘光线的垂线AB，垂足为B 我们能求出光线的传播时间$t=\\overline{BB’}/c $ 以A为圆心，做一个半径为$\\mathrm{v}_o t$的圆，这是o光波面 以A为中心，做一个半轴为$\\mathrm{v}_o t 和 \\mathrm{v}_e t$的椭圆，椭圆要和圆在光轴处相切 从B’出发做圆和椭圆的切线，切点为$A’_o,A’_e$ o光折射光为$AA’_o$ e光折射光为$AA’_e$ 光的偏振 由于晶体可以分离o光和e光，因此可以做成偏振器 光的偏振状态 回忆一下 光有五种偏振状态 自然光 部分偏振光 线偏振光 圆偏振光 椭圆偏振光 光偏振状态的检验：将光通过检偏器，旋转检偏器，通过光强的变化判断 无变化：自然光、圆偏振光 有变化但没有消光：部分偏振光、椭圆偏振光 有变化且有消光，线偏振光 仅通过检偏，只能简单分出三类光，无法更近一步区分偏振态，而使用晶体可以明确知道偏振态 马吕斯定律：线偏振光经过检偏器，光强满足 $$ I=I_0\\cos^2\\varphi $$ 布鲁斯特定律：光线以大于布鲁斯特角入射，反射光是线偏振光 $$ \\tan i_B=\\frac{n_2}{n_1} $$ 光在晶体中的传播 洛匈棱镜 由两块冰洲石构成 左侧光轴平行纸平面和入射光，光线进入时不会发生双折射 右侧光轴垂直纸平面，光线进入后o光变e光，e光变o光 沃拉斯顿棱镜 光线进入左侧，o光和e光方向不变，速度改变，e光会比o光快 尼科尔棱镜 偏振光的获取和检验 核心思想为垂直振动和合成，任何一个偏振态，都是两个垂直振动的合成 所有偏振态都是由两垂直的线偏振光合成，两者的相位差$\\delta$将决定合成的是何种偏振光 $\\lambda/4$波晶片能带来$\\pi/2$的相位差 光通过晶体时，o光和e光可能方向不变，相位差改变，通过调整两者间相位差，就能得到圆偏振、椭圆偏振 求出射光偏振态 出射光相位差=入射光相位差+波晶片相位差 偏振光检验 使用偏振片将五种偏振光变为三组 对于自然光和圆偏振光那一组 光线继续通过$\\lambda/4$波晶片，如果变为线偏振光，则为圆偏振光 对于部分偏振光和椭圆偏振光那一组 将偏振片旋转至光强最强处 将$\\lambda/4$波晶片光轴旋转至与偏振片透振方向平行 去除偏振片，光线继续通过$\\lambda/4$波晶片 此时o光和e光与椭圆主轴一致，若变为线偏振光，则为椭圆偏振光 左右旋检验 一个圆偏振片，通过$\\lambda/4$波晶片，再通过透振方向为斜对角线的偏振片 旋转偏振片，若发现有消光位置，则停止旋转（圆偏振通过波晶片变线偏振，透过偏振片会有消光），此时透振方向和线偏振光偏振方向垂直 若透振方向为一三象限，入射光为右旋 若透振方向为二四象限，入射光为左旋","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：傅立叶变化光学","slug":"optics/傅立叶变化光学","date":"2023-03-02T10:01:25.000Z","updated":"2025-03-18T07:16:48.441Z","comments":true,"path":"optics/傅立叶变化光学/","permalink":"https://reubensun.com/optics/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E5%8C%96%E5%85%89%E5%AD%A6/","excerpt":"","text":"八：傅立叶变换光学 内容概述 衍射系统的屏函数 夫朗禾费衍射的傅立叶频谱分析 阿贝成像原理和相衬显微镜 变换光学 前面几章，我们使用波的叠加来分析描述干涉衍射，而傅立叶变化光学中，我们使用光场变换的观点来看待干涉衍射 傅立叶光学的本质就是将复杂的光学现象切分为多个不同频率、不同取向的正弦光栅之和 傅立叶展开的本质是将复杂的函数切分为多个三角函数之和 屏函数 衍射屏左侧的空间叫照明空间，其中的场被称为入射场$\\tilde{U}_1$ 衍射屏右侧的空间叫衍射空间，其中的场被称为衍射场$\\tilde{U}_2$ 接收屏处的场叫接收场$\\tilde{U}$ 使用屏函数$\\tilde{t}$来描述衍射屏对入射光的波前的改变 $$ \\tilde{t}(x,y)=\\frac{\\tilde{U}_1}{\\tilde{U}_2}=t(x,y)\\exp [i\\varphi_t(x,y)] $$ $t(x,y)$是屏函数的模，若模为固定值，则该衍射屏为相位型。比如透镜、棱镜 $\\varphi_t$是屏函数的相位，若相位为固定值，则该衍射屏为振幅型。比如单孔、圆孔 相因子判断法 正弦光栅衍射 正弦光栅从数学上，就是傅立叶级数的基函数 光栅 光栅：具有周期性的空间结构或光学性能的衍射屏统称为光栅 光栅的种类： 透射光栅、反射光栅 平面光栅、凹面光栅 黑白光栅、正弦光栅 一维、二维、三维光栅 阿贝成像原理 衍射屏的屏函数可以展开为傅立叶级数 相衬显微镜 显微镜看的切片都很薄，对光的吸收很小，如果不染色，很难引起透射光振幅的变化，因此显微镜是相位型的 如果我们想要显微镜看东西更清楚，可以通过增加相位移的方式增大图像的反衬度（衬比度）","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：衍射","slug":"optics/衍射","date":"2023-02-25T10:10:25.000Z","updated":"2025-03-18T07:16:48.439Z","comments":true,"path":"optics/衍射/","permalink":"https://reubensun.com/optics/%E8%A1%8D%E5%B0%84/","excerpt":"","text":"七：衍射 内容概述 衍射（Diffraction），光在传播途中偏移直线传播，强度重新分布的过程 惠更斯-菲涅尔原理 定量分析衍射 统一衍射和直线传播 衍射 衍射是光在传播途中偏移直线传播，强度重新分布的过程 物体遮挡光线，就会产生阴影 在几何光学中，平行光只会被完全遮挡/完全不遮挡，因此阴影应该是清晰的 但现实中的平行光阴影是软阴影，其实就是发生了衍射 点、面光源的软阴影是由于光源由尺寸 一组平行的波阵面通过小孔，会变成圆形 波长越长，越容易观测到衍射 小孔尺寸在波长的1000倍左右时衍射现象不明显 小孔尺寸在波长的10倍左右时衍射十分明显 小孔尺寸和波场相近时会发生散射 衍射的分类 菲尼尔衍射（近场衍射）：光源和接收屏距离有限 夫朗禾费衍射（远场衍射）：光源和接收屏距离无限（也就是入射光是平行光） 夫朗禾费衍射需要用透镜将平行光汇聚 光栅衍射 多光束干涉和单缝衍射的混合 多光束干涉决定明条纹位置 $$ d\\sin \\theta=k\\lambda $$ 缺级 $$ k=\\frac{d}{a}k’ $$ 干涉与衍射的关系 相同： 干涉和衍射都是相干叠加 不同： 干涉是离散点光源叠加求和，衍射是连续次波源叠加积分 干涉满足几何光学规律，衍射不满足几何光学规律 惠更斯-菲涅尔原理 惠更斯 惠更斯：波阵面上每一个点，本质上是一个球面次级小波的发射源，下一个波阵面实际上是这些球面的包络线（envelope） 理论的作用 根据这个理论，给定一个波阵面，我们可以画出下一个波阵面 解释了光在各向同性介质中的传播原理 解释了反射和折射公式 局限性 无法区分光沿直线传播和发生衍射的条件 无法定量分析衍射强度 根据该理论，应该会有反转波 菲涅尔 菲涅尔修正了惠更斯的理论 波阵面上每一个（无阻塞）点都是球面波的发射源，频率与主波相同 不在波阵面上的点，都是由小波相干叠加得到的 衍射是无数干涉的叠加 倾斜因子 惠更斯的理论会应该会存在向后的波，菲涅尔引入了倾斜因子（Tilt factor） $$ F(\\theta_0, \\theta)=\\frac{1}{2}(\\cos\\theta_0+\\cos \\theta) $$ 倾斜因子的引入使得向后的波强度为0，自然就不会出现反转波 不过倾斜因子的引入是纯经验，这也是菲涅尔理论的局限性 基尔霍夫积分定律 基尔霍夫在倾斜因子的基础上添加了一个常数K，提供了一个$-\\pi/2$的相位差 $$ K=\\frac{e^{-i\\pi/2}}{\\lambda} $$ 于是衍射积分公式转化为： 巴俾涅原理 两个互补的衍射屏叠加，效果等同于自由传播 半波带法 下图为单缝夫朗禾费衍射，计算方法为半波带法 波带数 $$ \\frac{a \\sin \\theta}{\\lambda/2} $$ a是衍射屏孔径 暗纹位置（暗纹准确，明纹不准确） $$ a \\sin \\theta = \\pm k \\lambda $$ 中央明纹宽度 $$ \\Delta x_0=2f\\frac{\\lambda}{a} $$ 衍射图样 单缝衍射 圆孔衍射 圆孔衍射：亮暗相间的同心圆环，中心可能是暗也可能是亮的 中心强度与孔径明暗，与屏幕距离不敏感 Airy斑：中心圆斑 瑞丽判据：如果一个物点的Airy斑的边缘在另一个Airy斑中心上，那么这两个物点恰好可分辨 圆屏衍射 圆屏衍射：亮暗相间的同心圆环，但中心总是一个亮点 亮点与物体大小、屏幕距离都无关，这个亮点我们称为柏松亮斑 一个圆球的影子，中心居然会有一个亮点，衍射，很神奇吧 光栅衍射 菲涅尔波带片 根据菲尼尔衍射原理，将偶数个半波带遮挡住，就能得到菲涅尔波带片（就是对一个平整的圆形玻璃，将其表面部分图黑一个个同心圆环） 若一个波带片有20个半波带，遮挡偶数个半波带，轴上中心点的光强为 $$ A’=A_1+A_2+A_3+A_4+A_{19}\\approx 10A_1=20A_0 $$ $$ I’=A’^2=400A_0^2=400I $$ 我们发现中心点的光强变强，因此菲涅尔波带片相当于透镜，可以汇聚光强 涂黑半径 $$ \\rho_K=\\sqrt{k}\\rho_1 $$ k取1,2,3… 成像公式 $$ \\frac{1}{R}+\\frac{1}{b}=\\frac{1}{f} $$ R：点光源到波带片的距离 b：波带片到汇聚点到距离 波带片与透镜 相同 都能汇聚能量 不同 透镜只有一个汇聚点，波带片有多个实汇聚点和虚汇聚点 透镜满足等光程性，波带片相邻波带片间有一个波长的光程差 波带片面积大、轻便、可折叠","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：干涉","slug":"optics/干涉","date":"2023-02-25T10:01:25.000Z","updated":"2025-03-18T07:16:48.440Z","comments":true,"path":"optics/干涉/","permalink":"https://reubensun.com/optics/%E5%B9%B2%E6%B6%89/","excerpt":"","text":"六：干涉 内容概述 干涉（Interference），光的叠加不满足线性叠加，证明了光的波性 干涉条件 干涉方法与装置 干涉仪 干涉 干涉让光学从线性光学变成非线性光学 线性光学 在几何光学中，我们认为光是独立传播的 光是一种横波，光在介质中传播会引起介质粒子振动，若独立传播成立，那么两束光的交叉区域，粒子的振动是两个振动的叠加，这就是叠加原理 光的叠加实际上是介质的性质（因为描述的是介质粒子振动的叠加） 线性介质：在该介质中，波满足叠加原理 非线性介质：在该介质中，波不满足叠加原理 违反叠加原理的介质是非线性介质，现象是非线性现象，学科是非线性光学 此外，叠加原理只有在低强度光下才成立，因此激光发明后，非线性光学才蓬勃发展 复振幅叠加法 求解相干光强有三种方法，实际分析时通常使用复振幅法 三角函数法：波可以由三角函数表示，对三角函数做恒等变化，即可求相干光强 矢量图解法 复振幅法 首先将三角函数表示为复振幅 $$ \\tilde{\\mathbf{E}_i}=\\mathbf{A}_i e^{i\\varphi i} $$ 复振幅的叠加 $$ \\tilde{\\mathbf{E}}=\\sum{i=1}^n\\tilde{\\mathbf{E}_i} $$ 合光强 $$ I = \\tilde{\\mathbf{E}}\\cdot \\tilde{\\mathbf{E}}^* $$ 相干叠加 现在有两个相同频率（frequency）相同偏振（polarization）的光波，下面是他们电场强度随时间的变化（用复数表示三角函数） $$ \\mathbf{E_1}=\\mathbf{A_1} e^{i(kr_1-\\omega t+\\varphi _{01})} $$ $$ \\mathbf{E_2}=\\mathbf{A_2} e^{i(kr_2-\\omega t+\\varphi _{02})} $$ 他们相交于点P，根据叠加原理，P点点电场强度为 $$ \\mathbf{E}=\\mathbf{E_1}+\\mathbf{E_2}=[\\mathbf{A_1}e^{i(kr_1+\\varphi_{01})} + \\mathbf{A_2}e^{i(kr_2+\\varphi_{02})}]e^{-i\\omega t} $$ 显然，振幅为 $$ \\tilde{\\mathbf{E}}=\\mathbf{A_1}e^{i(kr_1+\\varphi_{01})} + \\mathbf{A_2}e^{i(kr_2+\\varphi_{02})} $$ 由于光过于高频，我们没法实时进行光电场强度的检测，于是我们使用光强（intensity，$I$）来进行推导 $$ I \\propto \\tilde{\\mathbf{E}}\\cdot \\tilde{\\mathbf{E}}^*=\\mathbf{A_1}^2+\\mathbf{A_2}^2+2\\mathbf{A_1A_2}\\cos(kr_1-kr_2+\\varphi_{01}-\\varphi_{02}) $$ $$ I = I_1+ I_2 + 2\\sqrt{I_1I_2}\\cos \\delta $$ $$ \\delta=kr_1-kr_2+\\varphi_{01}-\\varphi_{02} $$ 我们发现，两个光波进行叠加，光强不只是简单叠加，还有一个尾巴，这个尾巴就是干涉 干涉：因波的叠加引起强度重新分布的现象 并且我们发现： 干涉强度与时间无关，与空间位置有关，且保持不变 当$\\delta=2m\\pi$，干涉强度最大，我们称之为构造干涉（constructive interference） $$ I=(\\mathbf{A_1}+\\mathbf{A_2})^2 $$ 当$\\delta=(2m+1)\\pi$，干涉强度最小，我们称之为相消干涉（destructive interference） $$ I=(\\mathbf{A_1}-\\mathbf{A_2})^2 $$ 非相干叠加 一般而言，两个光频率和偏振不一样，经过推导 $$ I_{12}=2\\mathbf{A_1}\\cdot \\mathbf{A_2} \\cos [(\\omega_2 - \\omega_1)t + \\theta_1 - \\theta_2] $$ 我们到处干涉强度为0的条件 两个光频率不同，$\\cos[…]$的均值为0 两个光光矢量垂直，$\\mathbf{A_1}\\cdot \\mathbf{A_2}=0$ 两个光夹角（相位差）迅速且无序变化，$\\cos[…]$的均值为0 干涉条件 因此我们总结出发生干涉的条件 频率相同 相同的平行分量 固定的相位差 如果不满足干涉条件，那么平均下来 $$ I=I_1+I_2 $$ 杨氏干涉 普通光源：普通光源的发光单位为原子、分子，不同原子间的发光是独立的，他们的频率、偏振、相位都是不同的，因此他们的光是不会发生干涉的 有干涉条件我们可以得出两种获得干涉光的方法： 分波前法（杨氏干涉） 分振幅法（薄膜等厚干涉） 使用杨氏干涉实验、菲涅尔双棱镜、劳埃德镜可以将普通光源变成干涉光 杨氏干涉，两束光的出相相同，因此干涉光的相位差只取决于光程差 $$ \\Delta \\varphi= \\frac{2\\pi }{\\lambda}\\Delta OPL=k\\delta $$ k：波数，$k=\\frac{2\\pi}{\\lambda}$ $\\delta$：光程差 衬比度 衬比度，也可以叫做可见度 干涉条纹的衬比度（constrast）定义为 $$ \\gamma = \\frac{I_\\max-I_\\min}{I_\\max + I_\\min} $$ 用于描述条纹的反差程度，当可见性为1时最清晰，当为0时完全不可分辨 杨氏双缝干涉实验 杨氏实验是通过两个点波光源进行干涉实验的典型 如果光是一种波，那么光在传播过程中应该会有波前（传播最靠前的波阵面），提取一个波前，并将其分为两部分，就能得到两个相干光 现在有一个非常窄的单色光源，经过两个带缝平面，会生成两个相干光，进而发生衍射现象，在平面留下明暗条纹 $$ I=A^2=4I_1\\cos^2\\frac{\\pi \\Delta}{\\lambda} $$ 若$\\Delta=m\\lambda, I=I_{max}=4I_1$，呈现亮条纹 若$\\Delta=(2m-1)\\lambda/2, I=I_{min}=0$，呈现暗条纹 杨氏干涉实验的衬比度为 $$ \\gamma = \\frac{2(A_1/A_2)}{1+(A_1/A_2)^2} $$ 当间距不大时，角度比较小，缝间距是相同的，间距为 $$ \\Delta x=\\frac{D}{d}\\lambda $$ 判断一点的暗亮 看上图 在杨氏干涉实验中，给定$d,D,x$，判断点在明条纹中还是暗条纹中 核心思想就是：判断光程差是半波长的偶数倍还是奇数倍，偶数为明条纹，基数为暗条纹 以P点为圆心，$S_1P$为半径画一个圆，圆和$S_2P$相交于点$S’$，那么$S_2S’$就是光程差 不过$S_2S’$很难求，于是我们进行近似，我们从$S_1$出发做$S_2P$的垂线，垂足可以近似为点$S’$ 我们知道斜边长度为d，只要知道$\\angle S_2S_1S’$，就能求出光程差 不过$\\angle S_2S_1S’$还是太难求了，我们用角$\\theta$来近似 $\\sin \\theta \\approx \\tan \\theta = x/D$ 有了光程差，就能知道这是几个波长，是明是暗 可见条纹的最大级数 $$ j_\\max= d/\\lambda $$ 求P点光强 $$ I=A_1^2+A_2^2+2A_1A_2\\cos \\Delta\\varphi $$ $$ \\Delta \\varphi = k \\cdot \\delta $$ 干涉条纹的移动 我们不仅观测到明暗条纹，还观测到条纹的移动和变化 移动光源，对于屏幕上一点，求多少个条纹经过该点 对于屏幕上点P，经过点P的条纹数取决于两条相干光线的光程差（OPL） 当光程差增减一个$\\lambda$时，就会经过一条条纹 移动光源，对于特定的一个条纹，求其移动了多长距离 杨氏双缝中 $$ \\delta x = -\\frac{D}{R}\\delta s $$ 其他干涉仪器 本质都是杨氏双缝干涉，条纹间距都满足 $$ \\Delta x=\\frac{D}{d}\\lambda $$ 这些干涉仪器相比起杨氏干涉，不使用狭缝过滤光，因此光线强度更高 菲涅尔双平面镜 劳埃德镜 菲涅尔双棱镜 彩色光杨氏双缝 如果传入的是白光，条纹将为彩色 时空相干性 现实中的普通光源的发光单元为原子、分子，靠自发辐射发光（激光光源靠受激辐射），这是一个随机过程，产生的光是随机、无规律、不相干的。看起来我们无法用普通光源做干涉实验，但实际上杨氏双缝是可以使用普通光源的，因为杨氏双缝中两个光都是由同一束光分割而成的 尽管普通光源的相位随机，但是杨氏双缝两束光的相位差与原光源相位无关，仅与空间位置有关 不过，光源的尺寸和光谱尺寸仍然会对杨氏干涉产生影响 在杨氏干涉中，我们使用了很窄的单色光源，然而现实中光源总是有尺寸，其颜色也不是单色而是光谱中一小段 空间相干性：光源尺寸对干涉强度的影响 时间相干性：光谱尺寸对干涉强度的影响（也就是说光不是真的纯色） 空间相干性 任何光源都有一定的宽度，我们将其视为多个不相干的点光源排布，屏幕上的总强度为各个光源的干涉条纹的线性叠加 我们发现沿着x轴方向的长度会让条纹模糊 沿着y轴方向的长度会让亮纹和亮纹重叠，于是条纹更清晰 我们在做杨氏双缝时常常使用平行于y轴方向的光 时间相干性 现实中光不是纯色光，光的波长不同，干涉条纹长度不同，于是不同波长的干涉条纹就会发生重叠，进而降低条纹的衬比度 薄膜干涉 薄膜（film）一种透明介质，将空间划分三个折射率不同的区域，其中中间的区域不能过厚 薄膜干涉（Thin film interference）：光在薄膜表面发生反射和折射，下表面的反射光和上表面的折射光发生干涉 比如彩色太阳眼镜和阳光下的七彩肥皂泡 光线在射向薄膜后会发生反射和透射，透射光可能会再次反射透射，返回薄膜表面，进而和入射光相遇，发生干涉 等厚干涉：发散的入射光（点光）和透射光干涉，干涉发生在薄膜表面 等倾干涉：平行的透射光干涉，干涉发生在无穷远，需要用透镜汇聚，形状为同心条纹 特别注意！等厚和等倾是指的条纹间距，而不是薄膜形状，等厚的条纹需要上下不平行的薄膜 等厚度干涉 等厚干涉发生在薄膜表面 厚度不均匀的薄膜发生的干涉，入射光为平行光，决定条纹间距的是因厚度不均带来的光程差 $$ \\delta = 2nh\\sqrt{n^2-n_0^2\\sin^2 i_1} +\\lambda/2 $$ $i$是折射角 常见的等厚干涉有 劈尖：光线垂直入射 角度越大，条纹数量越多 折射率越大，条纹间距越大 牛顿环 增透膜与高反膜 汽油膜，肥皂泡，昆虫翅膀 厚度均匀的薄膜发生的干涉，入射光为平行光，各个方向的干涉增强被分离出去 增透膜 n2的反射光被干涉相消，根据能量守恒，透射光会更多 折射率 $$ n=\\sqrt{n_1n_2} $$ $$ n_1 &lt; n &lt; n_2 $$ 厚度 $$ h=\\frac{\\lambda_0}{4n} $$ 增反膜 反射被干涉增强，透射光会减少 折射率 $$ n &gt; n_1 且 n &gt; n_2 $$ 厚度 $$ h=\\frac{\\lambda_0}{4n} $$ 等倾斜角干涉 等倾干涉发生在无穷远处 上下表面平行的薄膜发生的干涉，入射光为点光源 $$ \\delta = 2nh\\cos i_2 $$ 半波损失 波从光疏射向光密，在反射过程中会产生$\\pi$个相位跃变，我们称之为半波损失 由于半波损失的存在，薄膜干涉明暗条纹的产生条件实际上与杨氏双缝相反 $$ \\delta = 2nh\\cos i_2 + \\lambda/2 $$ 等倾图样 内高外低，内疏外密 干涉仪 多光束干涉 $$ \\Delta L=2nh\\cos i $$ 光在介质内不断反射折射，新的反射折射光强度成等比数列 迈克耳孙干涉仪 使用分振幅法将两个相互垂直的平面镜等效为空气薄膜，空气薄膜可以等倾，也可以等厚 法布里-珀罗干涉仪 由两个梯形透镜组成，用于生成等倾干涉条纹","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"提问的智慧","slug":"program/AskQuestion","date":"2023-02-18T10:01:25.000Z","updated":"2025-03-18T07:16:42.965Z","comments":true,"path":"program/AskQuestion/","permalink":"https://reubensun.com/program/AskQuestion/","excerpt":"","text":"提问的智慧 提问的方式，可能会很大程度影响你是否能得到有用的回答 树立好的形象 当你想问问题，一定要树立你的形象：我已经做了努力，我不是一个不劳而获且浪费别人时间的提问者 你可以做的努力有 网上搜素 查看文档、手册、issuse 看看源码 自己先做试验 问题不要带有错误的预设 草率的发问只会得到草率的回答，如果你的预设错了，下面的尝试和思考都是无用功 很多民科认为自己推翻了相对论、微积分，很有可能是使用了一个错误的预设 not even wrong Q：你是哪个省的 Right：四川省 Wrong：西藏省 Not even wrong：妈妈生的 不要明知故问 特别要批评哪些为了“耍存在感”而明知自问，列举了一大串知识试图诱导他人的思路，然后在最后向别人进行提问 不要认为自己够格得到回答 如果你没有为这个问题付费，那你不要期待自己一定能得到好的回答，你需要通过靠提出有内涵的、有趣的、有思维激励作用的问题挣得回答 选择正确的提问地点 不要在主题不和的论坛贴出你的问题 比如在NS吧问原神好不好玩，在A9问XGPU是否值得购买 不要在进阶的论坛中问低级问题，反之亦然 比如你认为火箭燃料应该用水洗煤，在太空应该用铅笔替代 不要在不同的论坛反复问同一件事 这让人感觉你在大喊大叫 不要向陌生人发私人邮件 你没有付费，别人就没有必要回答，更不要说私聊对方让他“加班” 可以试一试在Stack Overflow问程序相关的问题 向一个群体提问，而非个人 个人没有义务回答你的问题 向群体问一个好问题能对整个群体有益，你的提问可以被后来者看到 向群体问问题能减轻某个个人的压力 描述问题 使用有意义的标题 使用目标-差异做标题 X.org 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形 言之有物 低声下气不如清晰地说明情况 不要使用 大佬，求救 在线等，很急 我是一个菜鸡，呜呜呜 有人能帮帮我吗 如果你真的很菜，你可以去一些更入门的论坛去搜寻答案（菜的远远不止你一个人，因此你遇到的问题很可能其他人也会遇到） 不要擅自声称找到bug 如果你没有非常明确的根据，不要擅自声称找到了bug（很可能是因为你不会用导致的） 如果你对该软件还没有足够的了解，就声称自己遇到的困难是bug，这可能会惹恼软件作者 即使真的有bug，你最好要写的像是你做错了什么，给开发者一个台阶下，他可能反过来给你说抱歉 不要进行猜测 如果你的猜测有效，那还用向别人求助吗？ 你认为问题是怎么来的并不重要，重要地是描述问题本身，你的错误推测甚至可能会影响回答者的思路 蠢问题 我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下… 按时间顺序描述问题症状 描述目标而非过程 蠢问题 我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？ 聪明问题 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。 问题解决后 问题解决后你应该感谢帮助你的人 将标题修改为已解决，并在最后补充说明，你是如何解决问题的 参考 How to Ask Question","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://reubensun.com/tags/PM/"}]},{"title":"SSSR","slug":"graphics/SSSR","date":"2023-02-10T01:16:25.000Z","updated":"2025-03-18T07:16:48.444Z","comments":true,"path":"graphics/SSSR/","permalink":"https://reubensun.com/graphics/SSSR/","excerpt":"","text":"《Stochastic Screen Space Reflections》阅读笔记 2015年SIGRAPH，EA提出了SSSR，用于《镜之边缘》中镜面反射 需求有 支持清晰（sharp）和模糊（blurry）反射 邻接性，越近反射越清晰（contact hardening） 高光拉伸 逐像素的粗糙度和法线 相关工作 mirror-only SSR 我们先回顾传统的SSR 从屏幕像素开始RayMarching（需要View空间的世界坐标和法线） 根据深度可以很轻松找到第一个落点，根据法线很容易求出反射光线的角度 使用简单的线性步进，求反射光线的命中点 反射光线向前步进一段距离，到达C点 通过三角形边角性质，可以求出C点距离镜头的距离，这其实就是View空间的深度 若C点距离镜头的距离小于等于深度，则说明命中 将命中位置进行透视投影，使用上一帧的渲染结果作为反射颜色 glossy SSR 模糊滤波 杀戮尖塔提供了一种glossy SSR，就是对反射像素做一次卷积模糊，但这种模糊是一视同仁的模糊，没有实现越近越清晰 重要性采样 相对于普通的SSR，这里根据法线求反射光线方向时，加入一些随机偏差，反射光线形成了一个锥形，进而实现了模糊的SSR 当物体离反射面比较近时，根据正弦定理，滤波的像素数量更少，于是清晰度更高 但是在光线数量比较少的情况下，会有大量噪点，效果很差 作者的算法 将屏幕划分为Tile，进行一次低分辨率的光线步进，评估Tile的重要性，需要多少射线 根据材质粗糙度判断使用何种的RayMarching 昂贵的射线：借助Hi-Z的精确tracing，能得到准确的命中点 用于smooth表面 便宜的射线：简单的线性步进 用于粗糙表面（反正会做严重的滤波，不需要高精度） 使用BRDF重要性采样决定射线方向 使用邻居的采样信息进行模糊 TAA Tile评估 对于每一个Tile以1/8分辨率发射射线 判断射线（的反射光线）是否击中 若所有光线都没命中，则跳过这个Tile的步进 根据命中的比例和命中信息的差异，判断这个Tile中的像素需要多少个光线 Hi-Z tracing 详情可以去看《GPU Pro 5》 Hi-Z使用四叉树组织屏幕深度，将层次关系存储在MipMap层级中，用于加速反射光线的求交 Hi-Z的构建时，对屏幕尺寸的深度进行滤波，每次保存2x2像素中最浅的像素，也就是说最高级别的Hi-Z存储着整张图中最浅的深度 用C点表示光线在步进过程中的头坐标，我们射线求交的原理就是判断C点距离相机的距离和该点深度图的深度关系，相交处必然是一侧比C点深，一侧比C点浅 此外还有几条经验： 从相机出发的射线，落点位置是View空间该方向最浅的位置 从相机出发的射线，与落点位置的法线夹角应该大于$45^{\\circ}$ 若夹角小于$45^{\\circ}$，那么反射信息来自相机身后的内容，屏幕空间没有这些信息（可以用Cubemap补充信息） 若夹角大于$45^{\\circ}$，那么我们基本可以认为，反射光线在步进过程中，深度在不断变深 我们实际寻找的是，光线在步进过程中，比C点要深的最浅位置（更深，但只能深一点点） 由于起初我们位于最浅的位置，而步进的光线越来越深，因此第一个min-Z小于C点深度的位置，就是交点位置，我们只需要一直向右，不用回头 这样得到的Mip等级比较高，我们通过降低Mip等级，每次取比C深中最浅的那一个，直到Mip为0 算法复杂度为$O(\\log n)$ 重要性采样 重要性采样是蒙特卡洛积分中用于减少方差的算法，详情可以去看PBRT 简单来说就是我们有一个积分，我们不得不实时求这个积分，于是我们将这个积分很多项分离出去，最后变成了 复杂离散项 x 一段简单函数的积分 蒙特卡洛积分 这是一个三角形，如果我们想求三角形的面积，可以对三角形的高度函数做积分 第一种切分方法：均匀切分，三角形被分为等宽的长方形，每个长方形长$\\Delta x$，高$\\sqrt{1-x^2}$ $$ S=\\sum _{i=0}^N \\Delta x \\times h_i $$ 第二种切分方法：重要性切分，左侧长方形更窄，右侧更宽 $$ S=\\sum _{i=0}^N x_i \\times h_i $$ 三角形切被分为一个个长方形，长方形的面积代表贡献。很显然，左侧的长方形高度越高，相同宽度面积越大，贡献越多。也就是说，相同的x轴变化，左侧部分对积分的影响越明显，越高频 能看出（在同等误差下）重要性采样所需要的采样次数比均匀采样要小 重要性采样的思想就是，在高频处我们进行更多次的采样，低频处进行更少的采样，最后根据权重合并，就能在采样次数比较少的情况下，得到最精确的积分值 高度函数$h_i$就是采样值 宽度函数$x_i$就是重要性权重 面积$S$就是在当前概率分布下的采样期望 概率密度函数 详情可以去看概率论 在上一步，我们将连续函数的积分，转化为离散的采样值 x 重要性权重，然后我们发现，这个重要性权重怎么求？ 还是上面的三角形，我们发现横坐标可以取[0, r]中任意值（r为三角形边长） 因此具体到某个点（随机变量），被取到的概率为$\\frac{\\mathrm{d}x}{r}$（这里其实不怎么精确，概率论中点取到的概率为0，这里实际上是一段很小的区域被取到的概率） 对于一个区域[a, b]，我们进行积分，得到随机变量取到该区域的概率P $$ P(a &lt; X \\le b)=F(b)-F(a)=\\int_a^b \\frac{1}{r}\\mathrm{d}x=\\frac{b-a}{r} $$ 分布函数：$F(x)$ 概率密度函数：$1/r$，我们用$p(x)$表示 概率：$P(a &lt; X \\le b)$ 哦，现在我们知道了这个重要性权重有多大了 $$ x_i=\\Delta x/P=1/p(x) $$ 进而我们可以写出这个三角形面积的期望 $$ S=\\sum _{i=0}^N x_i \\times h_i=\\lim {N \\rightarrow \\infty}\\frac{1}{N}\\sum{k=1}^{N}\\frac{f(x_k)}{p(x)} $$ 不过，值得注意的是，我们上面使用的PDF是均匀的，其实并能很好地加速收敛，实际会使用一个和原函数形状类似的PDF来加速收敛（PDF的选择不会影响最终结果，但是会影响收敛速度） BRDF生成射线方向 BRDF，双向反射分布函数，用于描述光线进出材质后能量的变化 我们在实现BRDF时，通常会实现以下接口 eval：给定入射光方向和视线方向，求BRDF值 sample：生成射线方向 pdf：返回sample生成的射线的PDF 我们以最简单的phong着色为例 在RTOW中，我们朝着随机半球方向生成向量，该向量就是新射线的方向，同时求出该方向的PDF 我个人理解，射线方向是随机生成的，每个方向出现的可能性相同，但是他们的PDF不同，你可以理解为重要性采样求三角形面积时，每个大长方形是由内部多个（数量相同）等高的小长方形拼成的，但是小长方形的宽度不一致，1/PDF就是小长方形的宽度。越重要的地方，长方形宽度越小，越密集，于是实现了重要性采样 virtual bool scatter( const ray&amp; r_in, const hit_record&amp; rec, color&amp; alb, ray&amp; scattered, double&amp; pdf) const override &#123; auto scatter_direction = rec.normal + random_unit_vector(); // Catch degenerate scatter direction if (scatter_direction.near_zero()) scatter_direction = rec.normal; scattered = ray(rec.p, unit_vector(scatter_direction), r_in.time()); alb = albedo-&gt;value(rec.u, rec.v, rec.p); pdf = dot(rec.normal, scattered.direction()) / pi; return true; &#125; 上面生成新射线方向时，使用法线+球面向量，最后的形状就类似下图红色 还清除了朝下（射向材质内部的）的射线 随机数 作者使用了Halton Sequences生成随机数，并引入了截断，角度有最大值，这样能减弱BRDF的长尾巴（Tail）对结果的影响（这些尾巴会带来很多噪点） float2 u = halton(sampleIdx);u.x = lerp(u.x, 1.0, bias);importanceSample(u); 过滤重要性采样 一种基于预计算的光追，我们假设射线是圆锥形，我们可以根据MipMap层级得到滤波结果 复用邻居光线 复用 上面提到glossy ssr会导致严重的噪点问题，即使使用重要性采样，每个像素仍需要大量光线才能得到低噪点的结果 我们注意到，相邻像素，他们的位置相近，可见性应该也是接近的，那么邻居像素朝某方向发射的光线，其实也可以被当前像素复用 当然直接做模糊（比如用高斯滤波）会导致很多光斑，经过很多数学推导和近似后，给出了以下公式 result = 0.0;weightSum = 0.0;for(auto&amp; pixel : neighborhood)&#123; weight = localBRDF(pixel.hit) / pixel.hitPDF; result += color(pixel.hit) * weight; weightSum += weight;&#125;result /= weightSum; 稀疏 受邻居光线的启发，我们完全没必要每个像素都做射线，只需要在低分辨率下某些点做多次射线，其邻居使用这个射线结果就可以 TAA 我们不仅在空间上做射线的复用，也可以在时间上及逆行复用 参考 SSR","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"},{"name":"SIGGRAPH","slug":"SIGGRAPH","permalink":"https://reubensun.com/tags/SIGGRAPH/"},{"name":"GI","slug":"GI","permalink":"https://reubensun.com/tags/GI/"}]},{"title":"Probe-based Lighting in Unity Enemies","slug":"graphics/UnityEnemies","date":"2023-02-10T01:16:25.000Z","updated":"2025-03-18T07:16:48.443Z","comments":true,"path":"graphics/UnityEnemies/","permalink":"https://reubensun.com/graphics/UnityEnemies/","excerpt":"","text":"《Probe-based Lighting in Unity Enemies》阅读笔记 2022年SIGGRAPH，Unity发布了一个数字人项目，在头发、眼球、GI方面效果非常好，我们来分析一下他的Probe-based GI 论文地址 感觉原理上就是在Volume GI的基础上，存了遮罩信息用于偏移采样点，使用紧凑哈希提高了空间利用率，感觉手游大世界完全可以上这个 不用Lightmap 难以处理复杂的集合体，难以处理LOD 烘焙速度慢，严重制约开发效率 无法处理动态物体，无法提供统一的光照 无法处理人物 Worse directional quality Adaptive Probe Volumes 将空间划分为相同大小的cell，将cell作为分块烘焙、分块加载的最小单位 cell被细分为brick，在几何体密集的地方，brick越细分 细分 可以参考Lumen中Build Voxel Faces，本质就是推箱子 细分的原理是使用Raycast判断一个区域有没有物体（命中点），我们使用SDF加速射线检测 我们将一个cell划分为4x4的brick，这样就有16条起始边界，这些边界构成了一个正方形 每一条边界向内发射一条长度为一的射线（使用SDF加速），若没有命中，则向内移动一格 直到所有边界都命中后，我们得到右图所示的brick 数据结构 感觉很类似与VolumeGI，由索引buffer和3DTexture组成，通过紧凑哈希来降低存储 An indirection buffer存储了cell信息，cell索引→SH指针 Spherical Harmonics Pool中存储SH信息，SH指针→SH系数 采样 采样流程：World Position → Cell Indirection → Per-Cell Brick Indirection→ Brick UVW →Trilinear Sample SH Data 基于着色点posWS生成cellPos 加载cell信息 找到该着色点位于cell中哪一个brick（brick的最低层级可能是由相机距着色点距离决定的） int localBrickIndex = floor(residualPosWS / (_MinBrickSize * pow(3, minFoundBrickLevel))); //若minFoundBrickLevel=1，那么cell被细分为3x3个bricklocalBrickIndex -= validArea.min; 加载brick信息 通过brick信息+offset采样3DTexture 接缝 我们根据场景几何体密度构建空间八叉树，对于稀疏空间使用精度更低的高Subdiv Level存储Probe信息，在Level交界处有时会有明显的接缝问题 解决方法：采样时加入抖动 黑斑 当我们做Probe摆放时，由于按网格和brick摆放，经常会出现Probe放在墙内的情况，这会导致墙面、地板发黑 Unity的做法是一种辐照度驱动的摆放，通过判断Probe位置处四周backface比例，来判断这个Probe的有效性 对于有效性低/无效的Probe，Unity给出的解决方案就是，让墙内的Probe变亮 Post-Bake 烘焙后遍历Probe，找到在墙内的无效Probe 搜索其邻居Probe，使用其中有效Probe进行加权插值，权重是距离的平方反比 于是墙内的Probe就成功变亮了 Pre-Bake 参考《The lighting technology of Detroit Become Human》 使用Post-Bake后，确实黑斑少了，但是我们发现墙体出现了漏光，为此我们加入了Virtual Offset（bake阶段的offset），在烘焙时，将Probe移至墙外，最后再将墙外烘焙的信息写入墙内Probe中，于是既没有破坏网格结构，也实现了墙内Probe变亮 漏光 我感觉防漏光的本质就是让墙体“变厚”，无论是摆放层面上的遮光板，烘焙时期的Virtual Offset，还是是采样层面的偏移 传统的Probe采样，薄墙体由于使用了墙壁另一面的Probe信息发生漏光。为了避免漏光，采样时通常对采样位置进行偏移（Biases） Normal Bias，采样点沿着法线方向偏移 这样做实际上让物体沿着法线方向变大了 偏移的过多/过少，都会影响效果 难以调优 View Bias，采样点朝着相机方向偏移 依赖于相机 难以调优 Validity Based Weighting 而Unity使用了Validity Based Weighting技术来减弱漏光，本质还是对采样点进行偏移 原理上是通过标记遮罩得出偏移方向，使得偏移方向基于辐照度，而非模型法线、视线， 每一个Probe存储者8bit的遮罩，用于记录其八个方向（2x2x2）的邻居是否有效 若某个邻居无效，则推动采样点远离那个邻居（计算偏移的方向和大小） 但我们现在其实只得到了偏移的方向，不知道偏移的距离 遮光板 美术可以手动摆放一个遮光板，使得某些位置上的Probe失效 这确实让房顶下面不再漏光，但是这让房顶上面的物体过黑了 Unity的做法是对遮光板内Probe的邻居进行判断 若邻居Probe都不在室内（Occluding objects），那么不会使用遮光板，使用原本的数据 若邻居有在室内的，室内物体用到该Probe时才会变黑 场景管理 将球偕信息编码在3DTexture中比较好做Streaming","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"},{"name":"SIGGRAPH","slug":"SIGGRAPH","permalink":"https://reubensun.com/tags/SIGGRAPH/"},{"name":"GI","slug":"GI","permalink":"https://reubensun.com/tags/GI/"}]},{"title":"Metal：TBDR","slug":"graphics/TiledDeferred","date":"2023-02-08T14:33:25.000Z","updated":"2025-03-18T07:16:48.443Z","comments":true,"path":"graphics/TiledDeferred/","permalink":"https://reubensun.com/graphics/TiledDeferred/","excerpt":"","text":"Tile Base Deferred Rendering 基于Apple M1和Metal图形库 移动端GPU渲染架构 IMR（Immediate Mode Rending），即时模式渲染，按drawcall顺序绘制 TBR（Tile Base Rendering） 将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上 FS读信息，渲染每一个tile 当FS将所有的tile渲染完毕后，将完成的frame信息写入System Memory中 TBR相较于IMR能省带宽，而移动端的性能瓶颈在于带宽 值的注意的是，TBR产生带宽优势的核心是片上存储，而非Tile 我个人感觉为什么要使用Tile，可能是因为移动端GPU规模太小，难以放下整张RT。毕竟理论上使用一张大RT的采样成本更低，比如将一组TextureArray转化为VSM，能很明显提高滤波速度 我在实际测试中发现当你隐式使用TBR时也会自动切分Tile，手动指定Tile尺寸反而增大了带宽和GPU时间（我也不清楚为什么，希望有人能给我解释一些） On-Chip Memory 片上存储（on-chip memory），是集成在GPU上的存储空间 GPU中有多种存储数据的结构，访问速度从快到慢排依次是 Register Memory（RMEM） 访问极快，不需要消耗时钟周期（除非发生了冲突或者先写后读） 只对负责对其进行读写的线程可见 Shared Memory（SMEM） 对处于同一个block所有的线程都是可见的，所以常用与数据交换 Constant Memory（CMEM） 用于存储常量数据 Texture Memory（TMEM） 用于存储常量数据 Local Memory（LMEM）和Global Memory（GMEM） LMEM只是对GMEM的一个抽象，两者存取速度上一样的 只对负责对其进行读写的线程可见 一般用来存储automatic变量 automatic变量是一种大尺寸的数据结构/数组 有缓存机制（类比cache） 其中RMEM与SMEM是集成在GPU芯片上的，其他的则是存储在显存中的（你可以类比寄存器，cache和内存） Metal使用On-Chip Mem Metal使用On-Chip Mem最大的变化就是，你不再需要在RenderPass中读取上一个Pass的贴图，传递给下一个Pass，Shader的输入值可以直接替换为上一个Pass的输出结果，并直接使用 上一个Pass的结果你也可以通过imageblock&lt;GBufferOut&gt; img_blk_gBuffer访问 -fragment float4 fragment_deferredSun(VertexOut in [[stage_in]],+fragment float4 fragment_tiled_deferredSun(VertexOut in [[stage_in]], constant Params &amp;params [[buffer(ParamsBuffer)]], constant Light *lights [[buffer(LightBuffer)]],- texture2d&lt;float&gt; albedoTexture [[texture(BaseColor)]],- texture2d&lt;float&gt; normalTexture [[texture(NormalTexture)]],- texture2d&lt;float&gt; positionTexture [[texture(NormalTexture + 1)]])+ GBufferOut gBuffer)&#123; uint2 coord = uint2(in.position.xy);- float4 albedo = albedoTexture.read(coord);+ float4 albedo = gBuffer.albedo;- float3 normal = normalTexture.read(coord).xyz;+ float3 normal = gBuffer.normal.xyz;- float3 position = positionTexture.read(coord).xyz;+ float3 position = gBuffer.position.xyz; Material material &#123; .baseColor = albedo.xyz, .specularColor = float3(0), .shininess = 500 &#125;; float3 color = phongLighting(normal, position, params, lights, material); color *= albedo.a; return float4(color, 1);&#125; Single RednerPass 类比Vulkan的SubPass 传统的延迟渲染，是一个多Pass渲染。GBufferPass生成MRT，传递给LightingPass着色输出，这个过程中会有大量的贴图IO带宽 TBDR（Tile Base Deferred Rendering）利用了Metal图形库Single RenderPass的特性 在一个Single Pass中有多个小Pass，小Pass共享一组片上存储 一个Pass运行后，会在片上生成一些临时贴图，其他Pass可以直接访问这些贴图 TBDR是Apple芯片的功能，对于安卓GPU Adreno：frameBuffer fetch deferred，提前绑定（开辟）好MRT，使用时RT不动，Pass动 Mali：pixel loacl storage deferred，将GBuffer存在on-clip mem上，于是就减少了IO消耗 drawable 当我们使用MTKView呈现渲染结果时，需要指定currentDrawable unc draw(cullingResult: CullingResult, in view: MTKView) &#123; guard let commandBuffer = RHI.commandQueue.makeCommandBuffer(), let descriptor = view.currentRenderPassDescriptor else &#123; return &#125; updateUniforms(cullingResult: cullingResult) updateParams(cullingResult: cullingResult, options: options) // 阴影投射 shadowRenderPass.draw(commandBuffer: commandBuffer, cullingResult: cullingResult, uniforms: uniforms, params: params, options: options) // TBDR tiledDeferredRenderPass.skyboxCube = cullingResult.skybox tiledDeferredRenderPass.shadowTexture = shadowRenderPass.shadowTexture tiledDeferredRenderPass.descriptor = descriptor tiledDeferredRenderPass.draw(commandBuffer: commandBuffer, cullingResult: cullingResult, uniforms: uniforms, params: params, options: options) // Post-Process postProcessRenderPass.drawableTexture = view.currentDrawable?.texture postProcessRenderPass.preTexture = tiledDeferredRenderPass.finalTexture postProcessRenderPass.draw(commandBuffer: commandBuffer, cullingResult: cullingResult, uniforms: uniforms, params: params, options: options) guard let drawable = view.currentDrawable else &#123; return &#125; commandBuffer.present(drawable) commandBuffer.commit() &#125; 我们在TBDR时，将GBuffer和Depth设为.messoryless，并不保存，这些RT将放置在Color1～4中 albedoTexture = Self.makeTexture( size: size, pixelFormat: .bgra8Unorm, label: &quot;Albedo Texture&quot;, storageMode: .memoryless)...for (index, texture) in textures.enumerated() &#123; let attachment = descriptor.colorAttachments[RenderTarget0.index + index] attachment?.texture = texture attachment?.loadAction = .clear attachment?.storeAction = .dontCare attachment?.clearColor = MTLClearColor(red: 0.73, green: 0.92, blue: 1, alpha: 1) &#125; GBuffer Pass不输出Color0，Light Pass输出Color0，保存后传递给Post-Process Pass 其实你也可以直接将Light Pass的Color0设置为view.currentDrawable?.texture，这样Light Pass的结果会直接呈现在View上 之前在这一步卡了很久，如果你不显式保存Color0，那么最后一个Pass的Color0就会成为drawable 但如果你将Color0保存，你会发现屏幕变品红色，没有报错，截帧会崩溃，其实就是你保存Color0后没有显式指定view.currentDrawable?.texture = Color0，View没有东西可以显示 参考 WWDC 2020 Metal by Tutorials","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Render","slug":"Render","permalink":"https://reubensun.com/tags/Render/"},{"name":"Metal","slug":"Metal","permalink":"https://reubensun.com/tags/Metal/"}]},{"title":"SPH：入门","slug":"graphics/SPH","date":"2023-02-02T22:16:25.000Z","updated":"2025-03-18T07:16:48.444Z","comments":true,"path":"graphics/SPH/","permalink":"https://reubensun.com/graphics/SPH/","excerpt":"","text":"SPH入门 SPH（Smoothed Particle Hydrodynamics）光滑粒子流体力学 A mesh-free method for the discretization of functions and partial differential operators SPH是一种基于拉格朗日视角的算法，是一种空间离散化的算法，常用于连续介质的数值模拟 材质导数的坐标 拉格朗日坐标：视角随着介质移动而移动（粒子模拟） 欧拉坐标：视角是固定的，检测穿过视角的介质流速（网格模拟） SPH进行简单流体模拟，简单来说就是 介质离散化，使用多个质点来表示流体（离散化） 对于每一个粒子，找到它附近的粒子（临域搜索） 计算密度（质量密度估计） 计算压强（控制方程，如理想气体状态方程+动量守恒），压强差、粘滞力等 更新运动状态 水体渲染（Marching Cube） 离散化 狄拉克函数 狄拉克$\\delta$函数，这是一个广义函数，其在整个定义域中积分值都集中在原点 $$ \\delta (\\mathbf{r})= \\begin{cases} \\infty &amp; |\\mathbf{r}|=0 \\\\ 0 &amp; otherwise \\end{cases} $$ 该函数仅在积分中有意义，可以通过高斯钟形函数（正态分布）逼近 在物理学中我们常用质点表示物体，但是因此使得密度函数失去了意义（因为质点没有空间），此时密度函数就塌缩成了狄拉克函数 空间中任何标量场函数，都可以用狄拉克函数表示： $$ A(\\mathbf{x})=(A*\\delta)(\\mathbf{x})=\\int A(\\mathbf{x}‘)\\delta (\\mathbf{x}-\\mathbf{x}’)dv’ $$ $dv’$是$\\mathbf{x}'$对应的体积积分变量 $A(\\mathbf{x}): \\mathbb{R}^d \\rightarrow \\mathbb{R}$，d是维度，意思就是这是一个空间函数 $\\mathbb{R}$是实数集 $\\mathbb{R}^+$是正实数集（不含0） $\\mathbb{R}^d$是d维实数集 光滑核函数 我们有了狄拉克函数，想要把连续函数来离散表示 核函数（kernel functions，smoothing kernels）是一种随着距离而衰减的函数，与高斯函数要在整个作用域积分不同，核函数是有最大影响半径的，最大影响半径用$h$表示 核函数满足 归一化 狄拉克条件 非负性 对称性 有界性 一个经典的核函数是三次样条器（cubic spline kernel） 其中$q=\\frac{1}{h}||\\mathbf{r}||$ 离散化 有个数学大佬告诉我，这里就是“在某个i点处求所有其他j点按核函数加权的平均值，只不过离散化的时候划成了区块赋予了密度和体积” 换句话说，这其实就是一次卷积（数学家真是不讲人话） 参考上面那张核函数的图，离散化就是对于$i$点，我们求该点附近场密度函数值和核函数（一堆$j$点）的加权平均值 在数学上，$\\langle A(x)\\rangle $表示平均值 质量密度估计 粒子不需要携带质量密度函数，对于空间中任意位置的点，都可以通过离散化求出该点密度 对于$\\mathbf{x}_i$位置处的点，其密度为： $$ \\rho_{i} =\\sum_{j} m_{j}W_{ij} $$ 不过在流体边界，这样求密度会导致数据偏小，需要做边界处理 下图绿色点临域完整，得到正确的密度，而红色点只能得到一个较小的密度 微分算子的离散化 上面我们已经实现场函数的离散化，实现了质量密度估计。但除此之外，还有一些空间微分算子（导数）值得离散化 $$ \\nabla A_{i}\\approx \\sum_{j} A_{j}\\frac{m_{j}}{\\rho_{j} } \\nabla W_{ij} $$ 关于拉普拉斯算符，可以去看Nabla算子，简单来说这东西是将标量场转化为向量场，一阶算符就是梯度，二阶是散度，用于得到数据变化最快的方向。文中也实现了拉普拉斯算符的离散化 文章介绍了两种最常用的梯度的近似方法，并给了适用范围 差分公式（Difference Formula）：用于近似速度的散度 对称公式（Symmetric Formula）：用于近似力、脉冲的梯度 差分公式 在高中学微积分时，我们用两个相邻的点组成的线来逼近切线，以此引入了极限、导数的概念。在实际应用中，这两个点不可能无穷近，于是存在误差 使用差分表示导数（导数就是），我们只能把$h$取到一个很小的值，而不是无穷小，因此这个导数是有误差的 $$ f’(x)=\\lim_{h \\rightarrow0}\\frac{f(x+h/2)-f(x-h/2)}{h} $$ 我们需要衡量这个误差的大小，于是我们将$f(x\\pm h/2)$泰勒展开后带入上式，得到 $$ f’(x)=\\lim_{h \\rightarrow0}\\frac{f’(x)h+O(h^3)}{h}=f’(x)+O(h^2) $$ 误差大小为$O(h^2)$ 经计算，二阶导数的误差也是$O(h^2)$ 对称公式 临域搜索 这里介绍最简单的，不做空间优化的临域搜索，进阶内容可以看临域搜索 由于核函数存在作用范围，我们在积分时，只需要遍历核半径内其他粒子的信息。这样相较于nxn的全遍历，能大幅减少计算，为此我们需要构建临域表 网格化 临域搜索是一种基于网格（grid）构建粒子拓扑关系的算法，找到该粒子所在位置和其相邻位置有哪些粒子 我们将整个（粒子作用的）场景均匀切分为一个个三维网格，每个网格为立方体，边长等于核半径$\\hslash $， 每个网格拥有一个坐标$(i,j,k)$，用于表示网格在场景中的位置 对于任意一个粒子，其核函数的作用范围是一个球，临域搜索就是计算球内有哪些粒子 空间网格化 遍历粒子，记录每个网格中有多少个粒子，有哪些粒子 遍历粒子，建立临域表 求该粒子的核函数球位于哪些网格中 遍历那些网格，取出网格中所有粒子，计算距离 将距离小于核半径的粒子id存储在临域表中 数据结构 名称 Key Value _neighbourList id.x * maximumParticlesPerCell * 8 + _neighbourTracker[id.x]++ 临居的id _neighbourTracker id.x 当前粒子有多少个临居 _hashGrid hashCellIdx * maximumParticlesPerCell + previousCount id.x _hashGridTracker hashCellIdx 该网格中的粒子数 id.x：当前粒子id hashCellIdx：网格坐标的Hash值 maximumParticlesPerCell：每个网格的的粒子最大数量（提前留好空） previousCount：空里有几个粒子 球作用于哪些网格 我们发现核函数球最少位于8个网格中（一个2x2x2的立方体），最多位于27个网格中（一个3x3x3的立方体），我们只需要找出核函数球位于哪些网格中，就能减少很多便利 在这里，我们只使用8个网格作为临域（舍弃那些不重要的网格），很显然，球心向哪个方向靠，我们就使用哪8个网格 找到球心所在网格坐标，构建临域坐标表，临域坐标初始均设为球心位置 判断中心网格的中心坐标与球心的坐标位置关系 存储临域Hash Key void GetNearbyKeys(int3 originIndex, float3 position, out int nearbyKeys[8]) &#123; int3 nearbyBucketIndices[8]; for (int i = 0; i &lt; 8; i++) &#123; nearbyBucketIndices[i] = originIndex; &#125; if ((originIndex.x + 0.5f) * CellSize &lt;= position.x) &#123; nearbyBucketIndices[4].x += 1; nearbyBucketIndices[5].x += 1; nearbyBucketIndices[6].x += 1; nearbyBucketIndices[7].x += 1; &#125; else &#123; nearbyBucketIndices[4].x -= 1; nearbyBucketIndices[5].x -= 1; nearbyBucketIndices[6].x -= 1; nearbyBucketIndices[7].x -= 1; &#125; if ((originIndex.y + 0.5f) * CellSize &lt;= position.y) &#123; nearbyBucketIndices[2].y += 1; nearbyBucketIndices[3].y += 1; nearbyBucketIndices[6].y += 1; nearbyBucketIndices[7].y += 1; &#125; else &#123; nearbyBucketIndices[2].y -= 1; nearbyBucketIndices[3].y -= 1; nearbyBucketIndices[6].y -= 1; nearbyBucketIndices[7].y -= 1; &#125; if ((originIndex.z + 0.5f) * CellSize &lt;= position.z) &#123; nearbyBucketIndices[1].z += 1; nearbyBucketIndices[3].z += 1; nearbyBucketIndices[5].z += 1; nearbyBucketIndices[7].z += 1; &#125; else &#123; nearbyBucketIndices[1].z -= 1; nearbyBucketIndices[3].z -= 1; nearbyBucketIndices[5].z -= 1; nearbyBucketIndices[7].z -= 1; &#125; for (int j = 0; j &lt; 8; j++) &#123; int3 nbcellIndex = nearbyBucketIndices[j]; if (nbcellIndex.x &lt; 0 || nbcellIndex.x &gt;= Dimensions || nbcellIndex.y &lt; 0 || nbcellIndex.y &gt;= Dimensions || nbcellIndex.z &lt; 0 || nbcellIndex.z &gt;= Dimensions) &#123; nearbyKeys[j] = -1; //出界了 &#125; else &#123; nearbyKeys[j] = Hash(nearbyBucketIndices[j]); &#125; &#125;&#125;//将三维坐标转化为一维hash keyint Hash(int3 cell) &#123; return cell.x + Dimensions * (cell.y + Dimensions * cell.z);&#125; 构建临域表 [numthreads(100, 1, 1)]void BuildNeighbourList(uint3 id : SV_DispatchThreadID)&#123; _neighbourTracker[id.x] = 0; const int3 cell = GetCell(_particles[id.x].position); int cells[8]; GetNearbyKeys(cell, _particles[id.x].position, cells); for (uint j = 0; j &lt; 8; j++) &#123; if (cells[j] == -1) continue; // Grid does not contain cell. const uint numberOfParticlesInCell = min(_hashGridTracker[cells[j]], maximumParticlesPerCell); ; for (uint index = 0; index &lt; numberOfParticlesInCell; index++) &#123; const uint potentialNeighbour = _hashGrid[cells[j] * maximumParticlesPerCell + index]; if (potentialNeighbour == id.x) continue; const float3 v = _particles[potentialNeighbour].position - _particles[id.x].position; if (dot(v, v) &lt; radius2) // Use squared length (= dot) instead of length for performance. &#123; _neighbourList[id.x * maximumParticlesPerCell * 8 + _neighbourTracker[id.x]++] = potentialNeighbour; &#125; &#125; &#125;&#125; 控制方程 尽管物体在微观层面（比如原子）是离散的，但在宏观层面上，流体、固体表现为连续介质 continuum, a region of continuously distributed mass 根据定义，一个连续介质可以被切分为多个小的连续介质（类比实数的稠密性，任意两个实数间总存在第三个实数），而不影响其性质 材料粒子（material particle）：a portion of matter contained in an infinitesimal volume 连续性方程 连续性方程描述了物体的密度与时间的关系 $$ \\frac{D\\rho}{Dt}=-\\rho(\\nabla \\cdot \\mathbf{v}) $$ 随体导数 随体导数（material derivative）：$\\frac{D(\\cdot)}{Dt}$ 随体导数描述了材质点的场量随着时间的变化率 在制作不可压缩的介质中，必须始终保持 $$ \\frac{D\\rho}{Dt}=0 $$ 随体导数与坐标系有关，常见的坐标系有：拉格朗日坐标系和欧拉坐标系 线性动量守恒定律 高中物理就学过的碰撞时动量守恒，力作用在物体上，会改变物体的动量 将运动公式（equation of motion）用积分的形式写出来就是 $$ \\rho \\frac{D^2\\mathbf{x}}{Dt^2}=\\nabla \\cdot \\mathbf{T}+\\mathbf{f}_{ext} $$ $\\mathbf{T}$：应力张量（stress tensor） $\\mathbf{f}_{ext}$：体积力（body forces），穿越空间作用在所有流体元上的非接触力，例如重力、惯性力、电磁力 理解应力张量 对于材质内部一个微小平面，这个平面会受材质中其他点的作用力，这个力可能不与平面垂直。其中垂直于平面的力叫正向应力，平行于平面的力叫剪应力 矢量是一种一维张量，由大小和一个方向组成。然而对于应力，我们没法使用矢量进行表示，于是改用二维张量来表示，一个方向是应力的指向，一个方向是应力所在的平面方向 对于材质内一个点，它可能处于无数个平面中，我们需要用一种平面无关的方式来表示其受力状态。在三维空间中，我们选择了三组正交基底$(\\mathbf{e}_1,\\mathbf{e}_2,\\mathbf{e}_3)$构建坐标系，应用中给定一个方向$\\mathbf{e}$，就能求出该方向的应力矢量 其中$\\mathbf{T}$为应力矢量，$\\sigma $为柯西应力张量（一个3x3的矩阵） $\\sigma_{xy}$的意思是，处于yz平面，指向y方向 柯西应力张量只适用于材料微小变形的情况 Navier-Stokes方程 一个经典的不可压缩流体的张力表示方法 $$ \\mathbf{T}=-p+\\mu (\\nabla \\mathbf{v}+\\nabla \\mathbf{v}^T) $$ $p$：压强 $\\mu$：粘度（viscosity ） 我们将该液体的应力张量公式带入牛顿运动公式，得到速度的公式 $$ \\rho \\frac{D\\mathbf{v}}{Dt}=-\\nabla p + \\mu \\nabla^2 \\mathbf{v}+\\mathbf{f}_{ext} $$ 压强可以由密度表示，根据理想气体压强公式，我们得知压强与密度呈线性关系，于是我们取一个静止状态下的密度$\\rho_0$，通过与当前状态密度做差值，就能得出压强 理想气体压强公式，初中就学了，$pV=nRT$ $$ p=B((\\frac{\\rho}{\\rho_0})^{\\gamma}-1) $$ $B$：体积模量（bulk modulus） 弹力 拥有弹力的固体，应力张量来自于固体的形变，之后会展开讲 积分求解 混合初始边界值问题 我们上面给出了控制方程，但是想要求解运动问题，必须给定初始位置和速度（场） 一般而言，混合初始边界值问题（Mixed Initial-Boundary Value Problem）没有解析解，只有数值解 得嘞，这一节就这一句话，这一句话一个字都看不懂 混合边界 简单来说，就是要想求解运动问题，必须既要给初始位置，也要给初始速度（场） 边界条件也叫定解条件，是微分方程里的概念，给定初始值才能求控制方程、偏微分方程的解（比如带入解中的未知数） 放在物理学中叫临界条件，就是物体处于某两种状态间的交界处，比如冰水混合物 边界条件对于解决物理问题（比如求极值）十分重要 有三类边界条件 第一类边界条件（迪利克雷边界条件，Dirichlet boundary condition） 直接告诉你边界值，比如热传递中告诉你边界处温度 第二类边界（若依曼边界条件，Neumann boundary condition） 告诉你边界处的梯度，比如热传递中告诉你热流密度（温度的梯度） 混合边界条件 第一二类边界的混合，比如热对流微分公式，公式中既有温度，也有梯度，只有同时给出两者，才能求解 $$ q=h(T_0-T_a) $$ 解析解与数值解 解析解（analytic solution），形如一个函数，给定变量就能得出任意位置的解 数值解（numerical solution），这是一个数，是采用有限元、数值逼近、插值等方法得到的解 据说在数学家和物理学家眼里，解析解才是真正的解，更高贵，美丽 让我突然想到三体力魏成想要求出三体问题的解析解，结果最后发现这个问题只有数值解 算子分裂 就是使用分治的算法，将一个复杂的偏微分方程（PDE），分解为几个连续的子问题 在实践中证明，像这样每步操作依赖于上一步，一步一步操作，能提高系统的稳定性 时间积分 在实时渲染中，和精度相比，性能、稳定性和鲁棒性更重要 在GAMES201开篇讲弹簧质点模型时，关于质点的运动方程，给出了两种积分器：显式积分器和隐式积分器 显式积分器 从过去的状态得到现在的状态，表示简单容易实现 $$ \\mathbf{v}_{t+1}=\\mathbf{v}_t+\\Delta t \\frac{\\mathbf{f}_t}{m} $$ $$ \\mathbf{x}_{t+1}=\\mathbf{x}t+\\Delta t \\mathbf{v}{t+1} $$ 但是显式积分器有一个问题，就是容易爆炸，于是$\\Delta t$不能太大，应满足 $$ \\Delta t \\le c\\sqrt{\\frac{m}{k}} \\ \\ (c \\sim 1) $$ CFL条件 这是CFL条件（Courant–Friedrichs–Lewy condition），是某些偏微分方程的收敛条件，它决定了显式积分器中粒子在单位时间内走过的距离，必须小于粒子大小（或者说质点间的间距） $$ \\Delta t \\le \\lambda \\frac{\\tilde{h}}{|\\mathbf{v}^{\\max}|} $$ $\\tilde{h}$：粒子大小（质点间的间距） $\\lambda$：一个常量 $\\mathbf{v}^{\\max}$：粒子运动的最快速度 隐式积分器 现在的状态依赖于现在的状态（求$t+1$时刻的信息，结果需要$t+1$时刻的信息），难以实现，但鲁棒性强 $$ \\mathbf{v}_{t+1}=\\mathbf{v}t+\\Delta t \\mathbf{M}^{-1}\\mathbf{f}(\\mathbf{x}{t+1}) $$ $$ \\mathbf{x}_{t+1}=\\mathbf{x}t+\\Delta t \\mathbf{v}{t+1} $$ $\\mathbf{M}$：质量矩阵 Marching Cube 符号表 参考 Physics Simulation in Visual Computing GAMES201 MrKill的知乎 alen-cell","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"Physics","slug":"Physics","permalink":"https://reubensun.com/tags/Physics/"},{"name":"SPH","slug":"SPH","permalink":"https://reubensun.com/tags/SPH/"}]},{"title":"我是谁","slug":"我是谁","date":"2023-02-02T09:50:25.000Z","updated":"2025-03-18T07:16:42.969Z","comments":true,"path":"我是谁/","permalink":"https://reubensun.com/%E6%88%91%E6%98%AF%E8%B0%81/","excerpt":"","text":"一个渴望得到认同的怪兽 大家好，我叫Reuben，是一个渴望得到认同的怪兽。 在小学时就很有表达欲，在班级制作并发售了一款宝可梦卡牌，当时就想做游戏。上大学后加入了游戏开发社团，本以为会去做游戏策划，但由于一些偶然因素，学习了一些图形学知识后去找TA实习，毕业去了家做自研游戏引擎的公司 平时有在做一些游戏demo，但严重缺乏美术资源，基本都是写了策划案搓了点demo就放弃了 随着LLM的兴起，我感觉AIGC可以解决独立开发缺少美术的问题，AI在游戏行业必然大有所为，于是现在又转行做AI了 经历 多模态算法工程师 阶跃星辰 2024.4~至今 游戏引擎 不鸣科技 2022.12~2024.4 图形实习 腾讯 2022.9~2022.12 技术美术实习 字节朝夕光年 2021.12~2022.9 游戏策划实习 字节朝夕光年","categories":[],"tags":[]},{"title":"C++11特性","slug":"program/C++11","date":"2023-02-01T14:01:25.000Z","updated":"2025-03-18T07:16:42.965Z","comments":true,"path":"program/C++11/","permalink":"https://reubensun.com/program/C++11/","excerpt":"","text":"C++11特性 都什么年代了，还在整C++11？八股害人啊 一：C++11的“新”特性 nullptr 一个新关键字，用于表示指针指向no value，可以被自动转化为各种指针类型，但是不会被转化为整数 比NULL好，因为NULL的本质就是整数0 auto 通过auto声明变量、对象，可以自动推到其类型，在处理表达式时有奇效 auto l = [](int x) -&gt; &#123;...&#125;; 一致性初始化 一致性初始化（Uniform Initiallization），简单来说就是可以用大括号来做初始化 int v[] &#123;1, 2, 3&#125;;vector&lt;int&gt; v2 &#123;1, 2, 3&#125;;complex&lt;double&gt; c&#123;4.0, 3.0&#125;; 但是这个操作不支持窄化（narrowing），即 int x = 5.3; //x == 5int y &#123;5.3&#125;; //Error 新的for循环 for(auto&amp; item: lists)&#123;...&#125;for(int i : &#123;1, 2, 3, 4&#125;)&#123;...&#125; 左值右值 左值 左值：占用一定内存，具有可辨认身份（可以被取地址、引用）的对象（表达式结束后仍然存在的持久对象），C++中绝大多数变量都是左值 int i = 1; // i 是左值int *p = &amp;i; // i 的地址是可辨认的i = 2; // i 在内存中的值可以改变A a; // 用户自定义类实例化的对象也是左值++i=0; // i 是左值，会先自增，再赋值为0 右值 右值：左值以外的所有对象，分为亡值（xvalue, eXpiring Value，任务完成后就会被销毁）和纯右值（prvalue,Pure Rvalue，在表达式结束后就会被销毁） 亡值尽管也很快销毁，但是在生命周期内也是具有可辨识身份的，因此属于广义左值 int i = 2; // 2 这种字面量，是纯右值int x = i + 2; // (i + 2) 这种运算表达式，是纯右值A a = A(); // A() 这种函数非引用返回的临时对象，是纯右值，是一个临时对象，在a构造完成后会被销毁A&amp;&amp; a = A(); // a是一个右值引用，A是一个返回右值引用的函数，A()返回的对象是一个亡值，在右值引用的帮助下，生命周期变的和a一致int i = sum(1, 2) // sum(1, 2) 是右值 不能对右值赋值 i + 2 = 4; // 错误，不能对右值赋值 不能对右值取地址 int *p = &amp;(i + 2); // 错误，不能对右值取地址 int square1(int&amp; a) &#123;return a * a;&#125;int square2(const int&amp; a) &#123;return a * a;&#125; ...int i = 2;square1(i); // 正确square1(2); // 错误，不能对右值取地址square2(2); // 正确 常量左值引用 为什么可以const int &amp;a = 2;呢？这里一个常量左值引用（a）被绑定到了一个右值（2）上，这导致右值2的生命周期变得和a相同 const int &amp;a = 2; // 可以int&amp; b = 2; // 错误 转移语意 转移语意（move semantic），本质是所有权的转移，将即将销毁的对象转移给他人，避免非必要的拷贝和临时对象 比如一个函数定义为 void fun(const T&amp; v)&#123;...&#125; 当我们调用时 T t;fun(t); //1fun(t+1); //2 我们发现，第一种调用时，直接传了引用，没有拷贝和临时变量，而第二种，实际上是 T temp = t+1; //T temp(t+1)或者 T temp.T(t+1)fun(temp); 总之是调用了拷贝构造函数和生成了临时变量，这不是我们想要的，于是引入了左右值和转移语意的概念，然后就诞生了一种新的调用方式： fun(std::move(t+1)); std::move的作用是将其参数t+1变成一个右值引用（rvalue reference），是一个T&amp;&amp;的类型 一旦一个类型被“标记”为右值，就意味着这是一个临时对象，你可以随意使用它的内容和资源 然后我们可以优化一下这个函数的定义 class T&#123;public: T (const T&amp; lvalue); // 通过左值拷贝构造（根传统C++一样） T (T&amp;&amp; rvalue); // 通过右值move构造&#125;void fun(T&amp;&amp; v)&#123;...&#125; 右值被move以后，就变成有效但不确定的状态 字符串字面量 Raw String Literal 以R开头的字符串，可以换行，不需要转义，用于正则表示式有奇效 R&quot;(\\\\n)&quot;; //等于 &quot;\\\\\\\\n&quot; Encoded String Literal 用于国际化 noexcept 让函数无法抛出异常，遇到未定义事件会直接abort，这相当于假定了这个函数是绝对不会出现异常的，标准库中大量函数均有这种要求 noexcept后面可以跟一个bool条件，为true时就不抛异常 void fun() noexcept;void fun2(T&amp; x, T&amp; y) noexcept(noexcept(x.swap(y)))&#123; x.swap(y); //这个函数意味着，只要xy交换不抛异常，那么下面这些函数体做任何事都不会抛异常&#125; constexpr 用于让表达式核定与编译期，能助力TMP编程 constexpr int square(int x)&#123; return x*x;&#125;float a[square(9)]; //以前的写法template&lt;unsigned n&gt;struct Factorial&#123; enum &#123; value = n * Factorial&lt;n-1&gt;::value &#125;;&#125;;//C++11写法template&lt;unsigned n&gt;struct Factorial&#123; constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;;&#125;; 新的模板 不定个数的参数 void f(int i)&#123; cout &lt;&lt; i &lt;&lt; endl;&#125;template &lt;typename T , typename... Types&gt;void f(const T&amp; first, const Types&amp;... args)&#123; cout &lt;&lt; first &lt;&lt; endl; f(args...);&#125;int main() &#123; f(1, 2, 3); return 0;&#125; 模板别名 template &lt;typename T&gt;using Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;Vec&lt;int&gt; coll; //等价于std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll; Lambda 允许函数的定义式被用作一个参数、local对象 定义与调用 []&#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;&#125;; //这是一个lambda表达式[]&#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;&#125;(); //定义并直接调用表达式auto l = []&#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;&#125;;l(); //调用表达式 含参 auto l2 = [](const std::string&amp; s)&#123; cout &lt;&lt; s &lt;&lt; endl;&#125;;l(&quot;hello&quot;); 返回值 []() -&gt; int &#123; return 42; &#125; 外部作用域 分值传递和引用传递两种，值传递不能进行修改 int x = 0;int y = 42;auto l = [x, &amp;y] &#123; cout &lt;&lt; x &lt;&lt; &quot;+&quot; &lt;&lt; y &lt;&lt; endl; ++y;&#125;l(); //调用，注意xy不是参数，不需要写在括号里 mutable 这个关键词是const的反义词，意思是可变的，于是让值传递也可变 int x = 0;auto l = [x]() mutable &#123; cout &lt;&lt; x &lt;&lt; endl; x++;&#125;l(); decltype 自动推导表达式的类型，大号typeof const int &amp;i = 1;int a = 2;decltype(i) b = 2; // b是const int&amp; 推断返回类型 可以将返回类型的声明放在参数列之后 template &lt;typename T1, typename T2&gt;auto add(T1 x, T2 y) -&gt; decltype(x+y)&#123; return x + y;&#125; 带领域的枚举 promise与future std::promise意思为共享状态，是C++11提供的在两个异步任务间传递数据的方式，常与std::future一起使用 void producer(std::promise&lt;int&gt;&amp; p)&#123; // 生产者端 std::cout &lt;&lt; &quot;Producer\\n&quot;; std::this_thread::sleep_for(std::chrono::seconds(1)); // 设置共享数据为 42 p.set_value(42);&#125;int main() &#123; std::promise&lt;int&gt; p; // 将 promise 与 future 绑定 std::future&lt;int&gt; f = p.get_future(); std::thread producer_thread(producer, std::ref(p)); // 分离执行线程 producer_thread.detach(); int result = f.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; std::thread用于表示一个执行线程，这个线程可以选择在主线程执行join()或者另一个线程中执行detach()。 若使用join()，则主线程会等待子线程执行完毕后再继续执行，若使用detach()，则主线程会直接执行，而子线程会在后台执行，两者不会相互影响。 二：一般概念 可被调用的对象 Callable Object，一种对象，可以通过某些方式调用其某些函数，它可以是 函数 指向成员函数的指针 函数对象 lambda表达式 三：通用工具 pair 本质是一个struct int add(pair&lt;int, int&gt; p)&#123; return p.first + p.second;&#125;int main() &#123; pair&lt;int, int&gt; p(42, 10); cout &lt;&lt; add(p); return 0;&#125; tuple 大号pair，可以有多个值 int f(tuple&lt;int, int, int&gt; t)&#123; return get&lt;0&gt;(t) + get&lt;1&gt;(t) + get&lt;2&gt;(t);&#125;int main() &#123; tuple&lt;int, int, int&gt; t(3, 5, 7); cout &lt;&lt; f(t); return 0;&#125; 智能指针 智能指针智能在，它能知道自己是不是指向某物的最后一个指针 shared_ptr：共享式拥有 多个指针可以指向一个资源，通过引用计数法GC 为了解决引用计数法的缺点（比如循环引用），提供weak_ptr等辅助类 unique_ptr：独占式拥有 同一时间只能有一个unique_ptr指向某个资源，可以进行拥有权的移交 极值 Numeric Limit 用于得到当前平台下，一些数值类型的长度（大小） Trait 是一种技术方案，用来为同一类数据提供统一的操作函数，核心就是使用另外的模版类type_traits存储不同数据类型的type，这样就可以兼容各种数据类型 外覆器 Reference Wrapper 允许函数模板可以操作引用，不需要写特化版本 具体有两个函数 ref：隐式转化为T&amp; cref：隐式转化为const T &amp; template &lt;typename T&gt;void fun(T v);int x;fun(std::ref(x)); //此时T为int&amp;int x;fun(std::cref(x)); //此时T为const int&amp; Function Type Wrapper 允许将可调用对象当作最高级对象（first-class object） vector&lt;function&lt;void(int, int)&gt;&gt; tasks; //一个存储多个可调用对象的vectortasks.push_back(func); //void func(int x, int y);tasks.push_back([] (int x, int y) &#123;...&#125;); //添加一个lambda表达式for(function&lt;void(int, int)&gt; f : tasks)&#123; f(36, 36); //遍历所有的可调用对象，并调用&#125; 辅助函数 min max swap operator == != &gt; &lt; &gt;= &lt;= 编译期分数运算 ratio&lt;5, 5&gt; one;cout &lt;&lt; one.num &lt;&lt; &quot;/&quot; &lt;&lt; one.den &lt;&lt; endl; // 1/1ratio&lt;5, 3&gt; two;cout &lt;&lt; two.num &lt;&lt; &quot;/&quot; &lt;&lt; two.den &lt;&lt; endl; // 5/3 四：STL STL是C++标准库的核心，是一个泛型（generic）程序库，由三部分组成 容器（Container） 迭代器（Iterator） 算法（Algorithm） 有序容器 顺序与插入顺序有关，与元素值无关，常常通过array、linked list实现 array vector deque list forward_list 关联式容器 在内部进行排序的集合，位置取决于value，常常通过二叉树实现 set multiset（mult的意思是元素可以重复） map multimap（mult的意思是key可以重复） 无序容器 元素位置无关紧要，重要的是元素是否在容器内，常常通过哈希表实现 unordered_set unordered_multiset unordered_map unordered_multmap 让一个类可以作为unordered_map的key 核心是特化std class Student&#123;public: Student(int id, std::string name) : m_id(id), m_name(name) &#123;&#125; size_t hash() const &#123; return std::hash&lt;int&gt;()(m_id) ^ std::hash&lt;std::string&gt;()(m_name); &#125; bool operator==(const Student&amp; other) const &#123; return m_id == other.m_id &amp;&amp; m_name == other.m_name; &#125;private: int m_id; std::string m_name;&#125;;namespace std&#123; template&lt;&gt; struct hash&lt;Student&gt; &#123; size_t operator()(const Student&amp; student) const &#123; return student.hash(); &#125; &#125;;&#125; std::unordered_map&lt;Student, int&gt; student_score_map;Student student1(1, &quot;Alice&quot;);Student student2(2, &quot;Bob&quot;);student_score_map.emplace(student1, 100);student_score_map.emplace(student2, 90); 其他容器 string 寻常的数组（一种type，而非class） 迭代器 迭代器是一个可以遍历STL容器全部、部分元素的对象 操作 *：取元素 ++：迭代器前进至下一个元素 注意，++i比i++效率高一点点，因为后者要创建临时对象 ==、!=：判断两个迭代器是否指向同一个位置 =：赋值 种类 R/W 读写次数 跳转 举例 输入/输出迭代器 只读/只写 能且仅能读写一次 i++ istream_iterators、ostream_iterators 前向/双向迭代器 读写 能读写多次 i++ STL的set、map 随机访问迭代器 读写 能读写多次 i += n vector、deque、string、array 从上到下，迭代器能力越来越强（他们间有继承关系，前向 is a 输入） 算法 大多为非成员函数，思想是泛型编程（而不是OOP） 函数对象 一个行为像函数的对象，思想是泛型编程 class X&#123;public: int operator() (int a, int b) const;&#125;;...X fo;fo(arg1, arg2); //等同于fo.operator()(arg1, arg2); 函数对象是一个带状态的函数 函数对象有自己的类型 函数对象速度通常比普通函数快（编译期间有更好的优化）","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"profile工具","slug":"graphics/profile工具","date":"2023-02-01T10:01:25.000Z","updated":"2025-03-18T07:16:48.442Z","comments":true,"path":"graphics/profile工具/","permalink":"https://reubensun.com/graphics/profile%E5%B7%A5%E5%85%B7/","excerpt":"","text":"Profile工具 工具手册 工具 优点 评价 Unity profiler 用起来最简单，可以网络远程测试 功能不是很全 Xcode 功能全，而且使用简单 只能iOS，而且iOS打包很折磨 RenderDoc 安卓利器 snapdragon 只能用于高通骁龙soc，使用时注意有无adb Nsight 贼难用（可能是Unity图形API的锅） PIX 调试DX12也就这个好使 Xcode 配置Xcode项目 Xcode想要截帧需要依赖Xcode源项目 签名配置（略，这玩意贼恶心，尤其是别人的项目） 配置截帧 Edit Scheme CaptureMetal API Validation 截帧 截帧信息分析 GPU时间（首页就有） 带宽 截帧分享 找到这个文件，分享给其他人 Nsight 连接Unity Editor 以管理员身份打开 配置 Application Executable：Unity.exe所在的绝对路径 Command Line Arguements：-projectPath ”项目根路径“ 项目根路径：文件夹内有Asset、Package的那个文件夹 启动 点击Launch Frame Debugger 注意，请将Unity和Unity Hub都关掉 注意 Unity HDRP使用了D3D11On12，在使用NSight时会报Warm，暂时先别管 Snapdragon 连接安卓APP Connect to a device 如果找不到设备，检查有无adb命令，或者直接用adb连接 Realtime看带宽 从左下角Process中挑 Trace Capture看GPU时间 RenderDoc 连接安卓APP 手机连接电脑，电脑打开RenderDoc Connect 打开Launch Application窗口 Program——Executable Path——选择要截帧的APP 连接Unity Editor 右键Scene，Load RenderDoc 按小相机截帧 PIX 权限配置 开启Window开发者模式 开启英伟达开发者模式（以管理员身法打开英伟达控制面板） 注意，更换模式时，请注意关闭、保存Unity（和显卡相关的软件会崩掉） 连接Unity Editor 以管理员身份打开PIX Attach Unity Editor（配置方式同NSight） 按GPU Capture截帧","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"TA","slug":"TA","permalink":"https://reubensun.com/tags/TA/"}]},{"title":"CMake入门","slug":"program/CMake入门","date":"2023-02-01T10:01:25.000Z","updated":"2025-03-18T07:16:48.439Z","comments":true,"path":"program/CMake入门/","permalink":"https://reubensun.com/program/CMake%E5%85%A5%E9%97%A8/","excerpt":"","text":"CMake 快速入门 一个大项目（Project）内嵌多个子项目（SubProject） 一个子项目内有src、include、CMakeLists.txt，其中有一个子项目中有main.cpp 最外面的CMakeLists.txt，负责连接所有子项目： cmake_minimum_required(VERSION 3.20)project(Project)set(CMAKE_CXX_STANDARD 14)add_subdirectory(subProject1)add_subdirectory(subProject2) subProject1（main.cpp所在的子项目）下面的CMakeLists.txt： file(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp include/*.h)add_executable(subProject1 $&#123;srcs&#125;)target_include_directories(subProject1 PUBLIC include)target_link_libraries(subProject1 PUBLIC subProject2) subProject2下面的CMakeLists.txt： file(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp include/*.h)add_library(subProject2 STATIC $&#123;srcs&#125;)target_include_directories(subProject2 PUBLIC include) 生成sln项目 $cmake -G &quot;Visual Studio 16 2019&quot; 用vs打开sln项目能看到2+n个项目，其中 ALL_BUILD：编译该项目会编译整个工程 ZERO_CHECK：监视CMakeLists.txt的变化，一旦改变会告诉编译器重新构建工程 或者可以用make构建项目 $cmake -H. -Bbuild 一：CMake基础语法 CMakeLists.txt 我们将CMake指令放在CMakeLists.txt文件中 #设置CMake所需最低版本cmake_minimum_required(VERSION 3.20)#设置项目名称为CMakeStudy，支持的语言为C++（CXX表示C++）project(CMakeStudy LANGUAGES CXX)#设置创建的新目标名称：一个名叫CMakeStudy的可执行文件#这个可执行文件是通过编译和链接源文件main.cpp生成的add_executable(CMakeStudy main.cpp) CMake语言不区分大小写，但参数区分大小写 CMake的缺省默认语言为C++ 构建 写好CMakeLists.txt文件后，在命令行中输入： $cmake -H. -Bbuild 这个命令会搜索当前目录下的根CMakeLists.txt文件，创建一个build目录，在其中生成所有的代码 然后再build目录中输入命令，以完成编译 $cmake --build . 一般我们不会在源码内部构建，因为这会污染源码的目录树 链接 如果项目中有多个文件，如 可以改目标生成 add_executable(hello main.cpp Message.cpp Message.h) 但是这种改法太麻烦了，每添加一个文件就要在后面添一端，最后这东西会特别长 我们可以把这个类编译成一个（静态）库，然后再将库链接到可执行文件中（你还记得c++编译器的编译步骤吗？） cmake_minimum_required(VERSION 3.20)project(CMakeStudy LANGUAGES CXX)#将两个文件编译成库add_library(message STATIC Message.h Message.cpp)#目标不变add_executable(hello main.cpp)#链接target_link_libraries(hello message) 此外，我们能在buid目录中找到一个名为/形如libmessage.a的文件，这就是编译得到的静态库 add_library 生成一个名叫message的库 add_library(message STATIC Message.h Message.cpp) 第一个参数是目标名，后续可以使用该名来引用库 第二个参数是库的种类 STATIC：静态库 SHARED：动态库 OBJECT：对象库（将代码编译到可执行文件内部的静态库） MODULE：一种不会链接到项目中任何目标的动态共享对象（DSO），可以运行时动态加载 此外CMake还有一些不会出现在构建系统里的库 IMPORTED：项目外部的库，用于对现有依赖项进行构建，认为是不可变的 INTERFACE：也是项目之外的库，但是可变 ALIAS：对已有的库做别名 条件语句 在讲链接时，我们给出了两种编译方法，我们希望能在两种方式间切换 cmake_minimum_required(VERSION 3.20)project(CMakeStudy LANGUAGES CXX)#引入一个新变量USE_LIBRARY，设置为OFFset(USE_LIBRARY OFF)#打印信息message(STATUS &quot;Compile sources into a library? $&#123;USE_LIBRARY&#125;&quot;)set(BUILD_SHARED_LIBS OFF)#引入一个list变量: _sources，包含两个文件list(APPEND _sources Message.h Message.cpp)#判断，若USE_LIBRARY为真，则编译成库if(USE_LIBRARY) add_library(message $&#123;_sources&#125;) add_executable(hello main.cpp) target_link_libraries(hello message)else() add_executable(hello main.cpp $&#123;_sources&#125;)endif() 逻辑变量 true：1、ON、YES、true、Y、非零数 false：0、OFF、NO、false、N、IGNORE、NOTFOUND、空字符串、以-NOTFOUND为后缀 全局变量 CMake有一些全局变量，修改他们可以起到配置作用，这里设置的 set(BUILD_SHARED_LIBS OFF) 当设置为OFF时，可以使add_library不用传递第二个参数 变量名 含义 CMAKE_RUNTIME_OUTPUT_DIRECTORY .exe、.dll文件的输出路径 CMAKE_ARCHIVE_OUTPUT_DIRECTORY .a文件的输出路径 CMAKE_LIBRARY_OUTPUT_DIRECTORY .so文件的输出路径 CMAKE_CURRENT_SOURCE_DIR 当前CMakeLists.txt所在路径 PROJECT_NAME 项目名字 CMAKE_MODULE_PATH cmake模块所在路径 用户选项 在上面我们引入了一个条件语句，但是是硬编码的。我们希望用户可以控制USE_LIBRARY，于是可以使用option #set(USE_LIBRARY OFF)option(USE_LIBRARY &quot;Compile sources into a library&quot; OFF) 将上面下面的set替换为option，运行 $cmake -D USE_LIBRARY=ON 如果是Clion可以配置 构建类型 类型 有无优化 Debug 没有优化，带调试符号 Release 有优化，没有调试符号 RelWithDebInfo 有少量优化，带调试符号 MinSizeRel 不增加代码大小来优化 编译选项 cmake_minimum_required(VERSION 3.20)project(CMakeStudy LANGUAGES CXX)list(APPEND flags &quot;-fPIC&quot; &quot;-Wall&quot;)if(NOT WIN32) list(APPEND flags &quot;-Wextra&quot; &quot;-Wpedantic&quot;)endif()#添加一个库add_library(message STATIC Message.h Message.cpp)#为库设置编译选项target_compile_options(message PRIVATE $&#123;flags&#125;)#添加可执行目标add_executable(hello main.cpp)#为可执行目标设置编译选项target_compile_options(hello PRIVATE &quot;-fPIC&quot;)#链接target_link_libraries(hello message) 可见性 含义 PRIVATE 编译选项仅对目标生效，不会传递（hello链接了message，但不会接受message的编译选项） INTERFACE 编译选项对目标生效，并传递给相关目标 PUBLIC 编译选项对目标和使用它的目标生效 -Wall、-Wextra等是警告标志 如果A模块链接了core模块，B模块链接了A模块，如果B模块想用core的头文件，A在链接core时需要是PUBLIC MSVC 配置MSVC编译选项 if(MSVC) target_compile_options(my_executable PRIVATE /EHs-c-) # 禁用异常处理 target_compile_options(my_executable PRIVATE /W4 /WX) # 设置警告级别为 4，并将警告视为错误endif() 循环 foreach(_source $&#123;sources_with_lower_optimization&#125;) get_source_file_property(_flags $&#123;_source&#125; COMPILE_FLAGS) message(STATUS &quot;Source $&#123;_source&#125; has the following extra COMPILE_FLAGS: $&#123;_flags&#125;&quot;)endforeach() 命令 cmake中可以添加一些自定义命令，常用于实现编译前文件拷贝操作，比如将第三方.dll文件复制到可执行文件到项目根路径 add_custom_command(TARGET $&#123;PROJECT_NAME&#125; POST_BUILD COMMAND $&#123;CMAKE_COMMAND&#125; -E copy “$&#123;xxx.dll&#125;” $&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt; ) 命令执行时机： POST_BUILD：生成目标文件后 PRE_BUILD：编译前 PRE_LINK：链接前 执行的命令是Linux Command，比如copy $&#123;source&#125; $&#123;target&#125;，echo $&#123;output_string&#125; 搜索 我们不可能将每一个文件都以单文件的形式写进CMakeLists.txt中，于是我们需要按照某种规则搜索所有的文件 file(GLOB_RECURSE SRC_FILES_H &quot;$&#123;SOURCE_DIR&#125;/*.h&quot;)file(GLOB_RECURSE SRC_FILES_CPP &quot;$&#123;SOURCE_DIR&#125;/*.cpp&quot;)set(ALL_FILES $&#123;SRC_FILES_H&#125; $&#123;SRC_FILES_CPP&#125;) 排除SRC中部分文件 list(FILTER SRC EXCLUDE REGEX &quot;/ui/*&quot;)list(FILTER SRC EXCLUDE REGEX &quot;/core/+&quot;) 二：环境检查 检查平台 我们要处理如下的C++源码（hello-world.cpp） std::string say_hello() &#123;#ifdef IS_WINDOWS return std::string(&quot;Hello from Windows!&quot;);#elif IS_LINUX return std::string(&quot;Hello from Linux!&quot;);#elif IS_MACOS return std::string(&quot;Hello from macOS!&quot;);#else return std::string(&quot;Hello from an unknown system!&quot;);#endif&#125; CMake可以加入 #查询操作系统if(CMAKE_SYSTEM_NAME STREQUAL &quot;Linux&quot;) #设置宏 target_compile_definitions(hello-world PUBLIC &quot;IS_LINUX&quot;)endif()if(CMAKE_SYSTEM_NAME STREQUAL &quot;Darwin&quot;) target_compile_definitions(hello-world PUBLIC &quot;IS_MACOS&quot;)endif()if(CMAKE_SYSTEM_NAME STREQUAL &quot;Windows&quot;) target_compile_definitions(hello-world PUBLIC &quot;IS_WINDOWS&quot;)endif() 检查编译器 if(CMAKE_CXX_COMPILER_ID MATCHES Intel) ...endif()if(CMAKE_CXX_COMPILER_ID MATCHES GNU) ...... 检查处理器架构 if(CMAKE_SIZEOF_VOID_P EQUAL 8) #64bitselse() #32bitsendlf() 三：链接外部库 语法 find_package #查找名为OpenCV的包，如果没找到就报错find_package(OpenCV REQUIRED) 该函数的本质就是去（先去标准路径）寻找一个包名-config.cmake文件 在mac，找OpenCV找的可能就是 /usr/lib/cmake/OpenCV/OpenCVConfig.cmake 如果你安装的位置不是标准路径，你可以 在build时手动指定-xxx_DIR=&quot;aaa/lib/cmake/xxx&quot; 只有第一次指定，只要不删掉build目录，就不需要重新指定 可以在CMakeLists.txt最开头写set(xx_DIR &quot;aaa/lib/cmake/xxx&quot;)、 可以给xxx_DIR设置环境变量 链接静态库 在项目根目录新建lib文件夹 将要链接的静态库（test_library.a）复制到lib文件夹中 找包 find_library(TEXT_LIBRARY test_library lib) 链接 target_link_libraries(testapp LINK_PUBLIC &amp;&#123;TEST_LIBRARY&#125;) 链接动态库 常用库 Eigen Eigen是一个纯头文件实现的线性代数库，在mac上可以使用brew安装 安装（记住eigen的版本） $brew install eigen 将Eigen链接到系统文件夹（brew一般会自动链接） $brew link --overwrite eigen 链接 #寻找Eigen包，并附带包版本find_package(Eigen3 3.4 REQUIRED CONFIG)#若找到，则打印信息if (TARGET Eigen3::Eigen) message(STATUS &quot;Eigen3 $&#123;EIGEN3_VERSION_STRING&#125; found in $&#123;EIGEN3_INCLUDE_DIR&#125;&quot;)endif ()#目标add_executable(path-info main.cpp)#链接target_link_libraries(path-info PUBLIC Eigen3::Eigen ) #include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;int main(int argc, char **argv)&#123; int dim = std::atoi(argv[1]); Eigen::MatrixXd A = Eigen::MatrixXd::Random(dim, dim); std::cout &lt;&lt; A; return 0;&#125; brew的用法 这里提一嘴Homebrew，这是一个mac上非常好用的包管理器，可以非常“优雅”地安装软件 brew会把软件安装在/usr/local/Cellar目录 安装目录软链接到/usr/local/opt bin目录执行文件链接到/usr/local/bin中（opt也有可能在根目录） 常用命令 $ brew -v # 安装完成后可以查看版本$ brew --help # 简洁命令帮助$ man brew # 完整命令帮助$ brew search git # 搜索软件包$ brew info git # 查看软件包信息$ brew home git # 访问软件包官方站(用浏览器打开)$ brew install git # 安装软件包(这里是示例安装Git版本控制)$ brew uninstall git # 卸载软件包$ brew list # 显示已经安装的所有软件包$ brew list --versions # 查看你安装过的包列表（包括版本号）$ brew update # 同步远程最新更新情况，对本机已经安装并有更新的软件用*标明$ brew outdated # 查看已安装的哪些软件包需要更新$ brew upgrade git # 更新单个软件包$ brew deps php # 显示包依赖$ brew cleanup # 清理所有已安装软件包的历史老版本$ brew cleanup git # 清理单个已安装软件包的历史版本$ brew cleanup -n # 查看哪些软件包要被清除 拷贝动态库 有时为了可拓展性和编译速度，我们会将一个项目切分为多个模块，这些模块编译为dll，然后拷贝到主程序（exe）所在的目录 # 将 OptickCore.dll拷贝到 client.exe所在路径add_custom_command(TARGET client POST_BUILD COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_if_different $&lt;TARGET_FILE:OptickCore&gt; $&lt;TARGET_FILE_DIR:client&gt;) 四：项目 模块 我们可以将一个大的CMake源码分成一个个模块，将这些模块放在cmake文件夹里，后缀为.cmake 如下的项目结构 .├── cmake│ └── colors.cmake└── CMakeLists.txt cmake/colors.cmake文件内包含了一个色彩输出的定义 macro(define_colors) if(WIN32) # has no effect on WIN32 set(ColourReset &quot;&quot;) set(ColourBold &quot;&quot;) set(Red &quot;&quot;) set(Green &quot;&quot;) set(Yellow &quot;&quot;) set(Blue &quot;&quot;) ... else() string(ASCII 27 Esc) set(ColourReset &quot;$&#123;Esc&#125;[m&quot;) set(ColourBold &quot;$&#123;Esc&#125;[1m&quot;) set(Red &quot;$&#123;Esc&#125;[31m&quot;) set(Green &quot;$&#123;Esc&#125;[32m&quot;) set(Yellow &quot;$&#123;Esc&#125;[33m&quot;) set(Blue &quot;$&#123;Esc&#125;[34m&quot;) ... endif()endmacro() 在CMakeLists.txt引用 #将/cmake目录添加到路径列表list(APPEND CMAKE_MODULE_PATH &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;)#引入colors.cmakeinclude(colors)#使用定义define_colors() 函数 function(函数名 参数1 参数2) ...endfunction() 参考资料 Clion CMake CMake菜谱 小鹏老师","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"},{"name":"CMake","slug":"CMake","permalink":"https://reubensun.com/tags/CMake/"}]},{"title":"WPF中的C#","slug":"program/Csharpe","date":"2023-02-01T10:01:25.000Z","updated":"2025-03-18T07:16:48.438Z","comments":true,"path":"program/Csharpe/","permalink":"https://reubensun.com/program/Csharpe/","excerpt":"","text":"WPF中的C# C#语法 字符串 字符串替换 string raw = &quot;Hello world&quot;;string pre_str = &quot;Hello&quot;;string new_str = &quot;Hi&quot;;string pre_str2 = &quot;hello&quot;;string ans = raw.Replace(pre_str, new_str); // 匹配大小写string ans2 = Regex.Replace(raw, pre_str, new_str, RegexOptions.IgnoreCase); // 大小写无关 Console Console可以设置输出的wei’zhi，在初始化等待时，在同一行反复输出等待的时间 DateTime startTime = DateTime.Now;Init();Console.WriteLine(&quot;Init...&quot;);while(!InitSuccess())&#123; TimeSpan elapsedTime = DateTime.Now - startTime; Console.SetCursorPosition(0, Console.CursorTop - 1); Console.Write(new string(&#x27; &#x27;, Console.WindowWidth)); Console.SetCursorPosition(0, Console.CursorTop - 1); Console.WriteLine($&quot;Waiting &#123;elapsedTime.TotalSeconds&#125; s&quot;); Thread.Sleep(10);&#125; 容器 C#容器和其他语言接近，这里只列出一些我感觉很有意思的写法 ConcurrentDictionary 线程安全地修改key所对应的List，若Key不存在，则新建一个 这是一种线程安全的哈希表，使用分段锁机制实现并发访问 private static readonly ConcurrentDictionary&lt;string, List&lt;object&gt;&gt; instanceDictionary = new ConcurrentDictionary&lt;string, List&lt;object&gt;&gt;();public void Add(string key ,object instance)&#123; instanceDictionary.AddOrUpdate(key, k =&gt; new List&lt;object&gt; &#123; instance &#125;, (k, exitingList)=&gt; &#123; exitingList.Add(instance); return exitingList; &#125;);&#125; ConcurrentBag 线程安全的集合类型，底层基于ConcurrentDictionary实现 string[] files = ...;var bag = new ConcurrentBag&lt;CSVLine&gt;();Parallel.ForEach(Partitioner.Create(0, files.Length), range =&gt;&#123; for (int i = range.Item1; i &lt; range.Item2; i++) &#123; bag.Add(line); &#125;&#125; 正则表达式 string source = &quot;building.lod0.mesh&quot;string pattern = @&quot;lod(\\d).mesh&quot;;Match match = Regex.Match(source, pattern);if(match.Success)&#123; string ans = match.Value; // &quot;lod0.mesh&quot; string level = match.Groups[1].Value; // &quot;0&quot;&#125; 委托 C#的委托类似于C++的函数指针，C#中，将参数a,b委托给了对象adder的Add方法，委托本质上是一种支持()运算符的对象。既然是对象，就可以有自己的成员和状态 delegate int Fun(int a, int b);class Adder&#123; private int c = 0; public Adder(int c)&#123; this.c = c; &#125; public int Add(int a, int b)&#123; return a+b+c; &#125;&#125;//Main()&#123;...Adder adder = new Adder(1);Fun f = adder.Add;f(2,3); //return 6 C#委托支持匿名委托和lambda表达式 delegate int Fun(int a, int b);//Main()&#123;...Fun f = delegate(int a, int b)&#123; cout &lt;&lt; a+b &lt;&lt; endl;&#125;;Fun f2 = (int a, int b)=&gt;&#123; cout &lt;&lt; a+b &lt;&lt; endl;&#125;; C++的函数指针 C/C++的函数指针是一个指向函数入口的指针，不具有对象的性质，只能指向非成员函数 typedef int(*Func)(int a, int b);int Add(int a, int b)&#123; return a+b;&#125;int main(int argc, char **argv)&#123; Func func = Add; std::cout &lt;&lt; func(1,2); //cout 3 return 0;&#125; 当然，如果加上类型限制符，还是可以指向成员函数的 class Multiple&#123;public: int Mul(int a, int b)&#123; return a * b; &#125;&#125;;typedef int(Multiple::*Fm)(int a, int b);int main(int argc, char **argv)&#123; Multiple multiple; Fm f = &amp;Multiple::Mul; std::cout &lt;&lt; (multiple.*f)(3,4); return 0;&#125; 如果想让C++对委托具有对象的性质，我们可以重载()操作符 class Adder&#123;public: Adder(int c)&#123; this-&gt;c = c; &#125; int operator()(int a, int b)&#123; return a+b+c; &#125;private: int c;&#125;;int main(int argc, char **argv)&#123; Adder adder(1); std::cout &lt;&lt; adder(2, 3); return 0;&#125; Action泛型委托 C#一种无返回值的泛型委托 public delegate void Action&lt;in T&gt;(T obj); 无参数Action xxx = 函数 public class Name&#123; public string InstanceName&#123; private set; get; &#125; public Name(string name) &#123; InstanceName = name; &#125; public void DisplayName() &#123; Console.WriteLine($&quot;I&#x27;m &#123;InstanceName&#125;&quot;); &#125;&#125;public static void Main(string[] args)&#123; Name testName = new Name(&quot;Tim&quot;); Action showName = testName.DisplayName; showName();&#125; 有参数Action&lt;参数类型&gt; xxx = 函数 public class Name&#123; public string InstanceName&#123; private set; get; &#125; public Name(string name) &#123; InstanceName = name; &#125; public void DisplayName(string str) &#123; Console.WriteLine($&quot;I&#x27;m &#123;InstanceName&#125;, &#123;str&#125;&quot;); &#125;&#125;public static void Main(string[] args)&#123; Name testName = new Name(&quot;Tim&quot;); Action&lt;string&gt; showName = testName.DisplayName; showName(&quot;HHH&quot;);&#125; Func泛型委托 C#一种有返回值的泛型委托 public delegate TResult Func&lt;out TResult&gt;(); public class Adder&#123; private int c; public Adder(int c) &#123; this.c = c; &#125; public int Add(int a, int b) &#123; return a + b + c; &#125;&#125;public static void Main(string[] args)&#123; Adder adder = new Adder(1); //第一个参数是返回值类型，后面的参数是输入参数类型 Func&lt;int, int, int&gt; method = adder.Add; //使用时不需要写返回值参数 Console.WriteLine(method(2, 3));&#125; 事件 这里的事件指CLR事件模型，详细内容见下文 委托：把工作委托给了某个函数，可以直接调用 事件：订阅者侦听发行者，发行者可以通过回调函数间接让订阅者干事（而且订阅者具体干什么，要看订阅者心情，发行者无权过问） //事件参数public class MyEventArgs: EventArgs&#123; public string Args &#123; private set; get; &#125; public MyEventArgs(string args) &#123; Args = args; &#125;&#125;//事件发行者public class EventSource&#123; MyEventArgs eventArgs; public string Name; public EventSource(string args) &#123; eventArgs = new MyEventArgs(args); &#125; public delegate void handlerEvent(Object sender, MyEventArgs args); public event handlerEvent m_handler_event; public void Handler() &#123; m_handler_event?.Invoke(this, eventArgs); //也可以写成 m_handler_event(this, eventArgs); &#125;&#125; //事件订阅者class MainClass&#123; public static void Main(string[] args) &#123; EventSource source = new EventSource(&quot;Event had been raised!&quot;); source.Name = &quot;Tim&quot;; source.m_handler_event += new EventSource.handlerEvent(writeHello); //也可以写成 source.m_handler_event += writeHello; source.Handler(); //输出：Hello Tim, Event had been raised! &#125; static void writeHello(Object sender, MyEventArgs args) &#123; EventSource source = sender as EventSource; Console.WriteLine($&quot;Hello &#123;source.Name&#125;, &#123;args.Args&#125;&quot;); &#125;&#125; 最初我很好奇，我们注册了一个处理函数，source.m_handler_event += writeHello，但是好像没看到怎么传参进去。 其实是因为C#的委托本质是一个支持()运算符的对象，所有处理函数形式上跟委托一致，参数是委托对象的成员变量 一个事件可以注册多个处理函数，于是事件也称为多重委托 模式匹配 一种更好的if else using System;// 定义形状基类public abstract class Shape&#123; public abstract void Draw();&#125;// 定义圆形类public class Circle : Shape&#123; public double Radius &#123; get; set; &#125; public override void Draw() &#123; Console.WriteLine($&quot;Drawing a circle with radius &#123;Radius&#125;&quot;); &#125;&#125;// 定义矩形类public class Rectangle : Shape&#123; public double Width &#123; get; set; &#125; public double Height &#123; get; set; &#125; public override void Draw() &#123; Console.WriteLine($&quot;Drawing a rectangle with width &#123;Width&#125; and height &#123;Height&#125;&quot;); &#125;&#125;class Program&#123; static void Main() &#123; Shape[] shapes = &#123; new Circle &#123; Radius = 5.0 &#125;, new Rectangle &#123; Width = 4.0, Height = 6.0 &#125;, null // 添加一个 null 值来演示常量模式 &#125;; foreach (var shape in shapes) &#123; // 使用 is 表达式进行模式匹配 if (shape is Circle circle) &#123; Console.WriteLine($&quot;Found a circle with radius &#123;circle.Radius&#125;&quot;); &#125; else if (shape is Rectangle rectangle) &#123; Console.WriteLine($&quot;Found a rectangle with width &#123;rectangle.Width&#125; and height &#123;rectangle.Height&#125;&quot;); &#125; else if (shape is null) &#123; Console.WriteLine(&quot;Found a null shape&quot;); &#125; else &#123; Console.WriteLine(&quot;Unknown shape&quot;); &#125; // 使用 switch 表达式进行模式匹配 string description = shape switch &#123; Circle c =&gt; $&quot;A circle with radius &#123;c.Radius&#125;&quot;, Rectangle r =&gt; $&quot;A rectangle with width &#123;r.Width&#125; and height &#123;r.Height&#125;&quot;, null =&gt; &quot;A null shape&quot;, _ =&gt; &quot;An unknown shape&quot; &#125;; Console.WriteLine(description); &#125; &#125;&#125; WPF客户端 WPF客户端的入口是一个继承了Application的类，通常是App.xaml和App.xaml.cs App.xaml &lt;Application x:Class=&quot;WpfApp1.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:WpfApp1&quot; StartupUri=&quot;MainWindow.xaml&quot;&gt; &lt;Application.Resources&gt; &lt;!--定义全局的资源、样式、主题--&gt; &lt;/Application.Resources&gt;&lt;/Application&gt; 若App.xaml中配置了StartupUri=&quot;MainWindow.xaml&quot;，程序开始时打开窗口MainWindow.xaml App.xaml.cs App.xaml.cs内定义了一个类App，这个类继承自Application 可以重载函数，以控制程序开始、结束时的行为 namespace WpfApp1&#123; public partial class App : Application &#123; protected override void OnStartup(StartupEventArgs e)&#123;&#125; protected virtual void OnExit(ExitEventArgs e)&#123;&#125; &#125;&#125; 如App.xaml中不配置StartupUri，也可以在此手动创建窗口 public partial class App : Application&#123; protected override void OnStartup(StartupEventArgs e) &#123; base.OnStartup(e); string[] commandLineArgs = e.Args; // parser commandLineArgs MainWindow mainWindow = new MainWindow(); mainWindow.Show(); &#125;&#125; 运行WPF项目 string exePath = &quot;WpfApp1.exe&quot;;string arguments = &quot;/param1 value1 /param2 value2&quot;;ProcessStartInfo startInfo = new ProcessStartInfo&#123; FileName = exePath, Arguments = arguments, UseShellExecute = true&#125;;Process.Start(startInfo); Binding 逻辑层与UI层 程序 = 数据 + 算法 三层结构：存储、逻辑、展示（UI） 逻辑层可以访问UI层的数据，但展示层不能访问逻辑层，UI层能显示信息，靠的是绑定逻辑层数据 this.textBoxName.SetBinding(TextBox.TextProperty, new Binding(&quot;Name&quot;) &#123; Source = stu = new Student() &#125;); UI层不仅可以绑定逻辑层数据，也可以绑定UI层数据 //为 Text属性设置 Binding为 slider1的...&lt;TextBox x:Name=&quot;textBox2&quot; Text=&quot;&#123;Binding Value, ElementName=slider1&#125;&quot; BorderBrush=&quot;Black&quot; Margin=&quot;5&quot;/&gt; 在XAML中加入 xmlns:local=&quot;clr-namespace:BindingStudy&quot; 即可在XAML中使用BindingStudy命名空间里C#定义的类 绑定的实现 绑定实现的机制：源对象的属性（Property）发生改变时，会Invoke一个事件，Binding负责侦听这个事件 class Student : INotifyPropertyChanged&#123; public event PropertyChangedEventHandler PropertyChanged; private string name; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; if(this.PropertyChanged != null) &#123; this.PropertyChanged.Invoke(this, new PropertyChangedEventArgs(&quot;Name&quot;)); &#125; &#125; &#125;&#125; Path 源对象往往会有多个属性，我们可以使用Path，设置绑定那些属性，而且Path支持多级路径（简单说就是一直点下去）和索引器（Indexer） &lt;TextBox x:Name=&quot;textBoxName&quot; BorderBrush=&quot;Black&quot; Margin=&quot;5&quot;/&gt;&lt;TextBox x:Name=&quot;textBox1&quot; Text=&quot;&#123;Binding Path=Text.Length, ElementName=textBoxName, Mode=OneWay&#125;&quot; BorderBrush=&quot;Black&quot; Margin=&quot;5&quot;/&gt; &lt;TextBox x:Name=&quot;textBox2&quot; Text=&quot;&#123;Binding Path=Text.[3], ElementName=textBoxName, Mode=OneWay&#125;&quot; BorderBrush=&quot;Black&quot; Margin=&quot;5&quot;/&gt; 此外Path也支持多级斜线（也是可以一直斜线下去，其中&quot;/&quot;就是自身） this.textBoxName.SetBinding(TextBox.TextProperty, new Binding(&quot;/Length&quot;) &#123; Source = stringList &#125;); 当源数据本身就是数据（比如int、string类型），我们可以不写Path，或者将Path省略为&quot;.&quot; this.textBlock1.SetBinding(TextBlock.TextProperty, new Binding(&quot;.&quot;) &#123; Source = str &#125;); 集合 &lt;StackPanel x:Name=&quot;stackPanel&quot; Background=&quot;LightBlue&quot;&gt; &lt;TextBlock Text=&quot;Student ID:&quot; FontWeight=&quot;Bold&quot; Margin=&quot;5&quot;/&gt; &lt;TextBox x:Name=&quot;textBoxId&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;Student List:&quot; FontWeight=&quot;Bold&quot; Margin=&quot;5&quot;/&gt; &lt;ListBox x:Name=&quot;listBoxStudents&quot; Height=&quot;110&quot; Margin=&quot;5&quot;&gt; &lt;ListBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Path=Id&#125;&quot; Width=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding Path=Name&#125;&quot; Width=&quot;60&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding Path=Age&#125;&quot; Width=&quot;30&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListBox.ItemTemplate&gt; &lt;/ListBox&gt;&lt;/StackPanel&gt;public MainWindow()&#123; InitializeComponent(); List&lt;Student&gt; stuList = new List&lt;Student&gt;() &#123; new Student()&#123;Id=0, Name=&quot;赵&quot;, Age=21&#125;, new Student()&#123;Id=1, Name=&quot;钱&quot;, Age=22&#125;, new Student()&#123;Id=2, Name=&quot;孙&quot;, Age=11&#125;, new Student()&#123;Id=3, Name=&quot;李&quot;, Age=50&#125;, new Student()&#123;Id=4, Name=&quot;周&quot;, Age=44&#125;, &#125;; this.listBoxStudents.ItemsSource = stuList; //this.listBoxStudents.DisplayMemberPath = &quot;Name&quot;; Binding binding = new Binding(&quot;SelectedItem.Id&quot;) &#123; Source = this.listBoxStudents &#125;; this.textBoxId.SetBinding(TextBox.TextProperty, binding);&#125; XML SOAP（Simple Object Access Protocel，简单对象访问协议）：一种基于XML的数据交换协议 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;StudentList&gt; &lt;Student Id=&quot;0&quot;&gt; &lt;Name&gt;赵&lt;/Name&gt; &lt;/Student&gt; &lt;Student Id=&quot;1&quot;&gt; &lt;Name&gt;钱&lt;/Name&gt; &lt;/Student&gt; &lt;Student Id=&quot;2&quot;&gt; &lt;Name&gt;孙&lt;/Name&gt; &lt;/Student&gt; &lt;Student Id=&quot;3&quot;&gt; &lt;Name&gt;李&lt;/Name&gt; &lt;/Student&gt; &lt;Student Id=&quot;4&quot;&gt; &lt;Name&gt;周&lt;/Name&gt; &lt;/Student&gt;&lt;/StudentList&gt;&lt;ListView x:Name=&quot;listViewStudents&quot; Height=&quot;130&quot; Margin=&quot;5&quot;&gt; &lt;ListView.View&gt; &lt;GridView&gt; &lt;GridViewColumn Header=&quot;Id&quot; Width=&quot;80&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=@Id&#125;&quot;/&gt; &lt;GridViewColumn Header=&quot;Name&quot; Width=&quot;120&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=Name&#125;&quot;/&gt; &lt;/GridView&gt; &lt;/ListView.View&gt;&lt;/ListView&gt;&lt;Button Content=&quot;Load Click&quot; Click=&quot;Button_Click&quot; Height=&quot;25&quot; Margin=&quot;5,0&quot;/&gt; private void Button_Click(object sender, RoutedEventArgs e)&#123; XmlDataProvider xdp = new XmlDataProvider(); xdp.Source = new Uri(@&quot;D:\\code\\BindingStudy\\BindingStudy\\RawData.xml&quot;); xdp.XPath = @&quot;/StudentList/Student&quot;; this.listViewStudents.DataContext = xdp; this.listViewStudents.SetBinding(ListView.ItemsSourceProperty, new Binding());&#125; LINQ LINQ（Language-Integrated Query，语言集成查询）：一种对象查询机制，查询的结果为IEnumerable类型 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;StudentList&gt; &lt;Class&gt; &lt;Student Id=&quot;0&quot; Name=&quot;Tim&quot; Age=&quot;29&quot;/&gt; &lt;Student Id=&quot;1&quot; Name=&quot;Tom&quot; Age=&quot;20&quot;/&gt; &lt;Student Id=&quot;2&quot; Name=&quot;Mess&quot; Age=&quot;9&quot;/&gt; &lt;/Class&gt; &lt;Class&gt; &lt;Student Id=&quot;3&quot; Name=&quot;Tony&quot; Age=&quot;2&quot;/&gt; &lt;Student Id=&quot;4&quot; Name=&quot;Viv&quot; Age=&quot;23&quot;/&gt; &lt;Student Id=&quot;5&quot; Name=&quot;Oio&quot; Age=&quot;88&quot;/&gt; &lt;/Class&gt;&lt;/StudentList&gt;&lt;ListView x:Name=&quot;listViewStudents&quot; Height=&quot;130&quot; Margin=&quot;5&quot;&gt; &lt;ListView.View&gt; &lt;GridView&gt; &lt;GridViewColumn Header=&quot;Id&quot; Width=&quot;80&quot; DisplayMemberBinding=&quot;&#123;Binding Id&#125;&quot;/&gt; &lt;GridViewColumn Header=&quot;Name&quot; Width=&quot;120&quot; DisplayMemberBinding=&quot;&#123;Binding Name&#125;&quot;/&gt; &lt;GridViewColumn Header=&quot;Age&quot; Width=&quot;80&quot; DisplayMemberBinding=&quot;&#123;Binding Age&#125;&quot;/&gt; &lt;/GridView&gt; &lt;/ListView.View&gt;&lt;/ListView&gt;private void Button_Click(object sender, RoutedEventArgs e)&#123; XDocument doc = XDocument.Load(@&quot;D:\\code\\BindingStudy\\BindingStudy\\RawData.xml&quot;); this.listViewStudents.ItemsSource = from element in doc.Descendants(&quot;Student&quot;) where element.Attribute(&quot;Name&quot;).Value.StartsWith(&quot;T&quot;) select new Student() &#123; Id = int.Parse(element.Attribute(&quot;Id&quot;).Value), Name = element.Attribute(&quot;Name&quot;).Value, Age = int.Parse(element.Attribute(&quot;Age&quot;).Value) &#125;; &#125;class Student&#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125;&#125; 校验 “你永远不能相信来自前端的数据” 我们认为Source的数据一定是正确的，但Target的数据是有可能出现问题的 public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); Binding binding = new Binding(&quot;Value&quot;) &#123; Source = this.slider1 &#125;; binding.UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged; //当源数据改变时进行校验 RangeValidationRule rvr = new RangeValidationRule(); rvr.ValidatesOnTargetUpdated = true; //当Target数据改变时进行校验 binding.ValidationRules.Add(rvr); binding.NotifyOnValidationError = true; this.textBox1.SetBinding(TextBox.TextProperty, binding); this.textBox1.AddHandler(Validation.ErrorEvent, new RoutedEventHandler(this.ValidationError)); &#125; //若校验失败，将失败信息添加到 ToolTip上 void ValidationError(object sender, RoutedEventArgs e) &#123; if(Validation.GetErrors(this.textBox1).Count &gt; 0) &#123; this.textBox1.ToolTip = Validation.GetErrors(this.textBox1)[0].ErrorContent.ToString(); &#125; else &#123; this.textBox1.ToolTip = null; &#125; &#125;&#125;&lt;StackPanel x:Name=&quot;stackPanel&quot; Background=&quot;LightBlue&quot;&gt; &lt;TextBox x:Name=&quot;textBox1&quot; Margin=&quot;5&quot;/&gt; &lt;Slider x:Name=&quot;slider1&quot; Minimum=&quot;-10&quot; Maximum=&quot;110&quot; Margin=&quot;5&quot;/&gt;&lt;/StackPanel&gt;class RangeValidationRule : ValidationRule&#123; //对数据范围进行校验，仅当在[0,100]时校验通过，校验失败时返回信息 public override ValidationResult Validate(object value, CultureInfo cultureInfo) &#123; double d = 0; if(double.TryParse(value.ToString(), out d)) &#123; if(d &gt;= 0 &amp;&amp; d &lt;= 100) &#123; return new ValidationResult(true, null); &#125; &#125; return new ValidationResult(false, &quot;Validation Failed!!!&quot;); &#125;&#125; 数据转换 Slider的Value是double类型，TextBox的Text是string类型，但是Binding后数据往来自如，是因为数据转化机制 class ClassAToClassBConverter : IValueConverter&#123; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; ... &#125; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) &#123; ... &#125;&#125;&lt;Window x:Class=&quot;BindingStudy.MainWindow&quot; ... &lt;Window.Resources&gt; &lt;local:ClassAToClassBConverter x:Key=&quot;atb&quot;/&gt; &lt;/Window.Resources&gt; &lt;StackPanel x:Name=&quot;stackPanel&quot; Background=&quot;LightBlue&quot;&gt; ... &lt;../../images Width=&quot;20&quot; Height=&quot;20&quot; Source=&quot;&#123;Binding Path=A, Converter=&#123;StaticResource atb&#125;&#125;&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 属性 英语中的属性 Property是物体自带的属性 Attribute是物体的描述属性 张三是中国人，身上有一百块钱。中国人是张三的Attribute, 100块钱是张三的property C#中的属性 将字段设为private，使用一对非private的方法来包装它，以实现高内聚 C#中提供语法糖，将Get和Set合并为了属性（Property），这种属性也被称为CLR（Common Language Runtime）属性 class Student&#123; private string name; public string Name &#123; get; set; &#125;&#125; 此外反编译后发现，属性的本质是两个函数，并不会增加字段数量（不额外占内存） 依赖属性 （WPF属性加强版） 依赖属性（Dependency Property）可以自己没有值，通过Binding从数据源获得值 拥有依赖属性的对象被称为依赖对象 传统开发中，对象所占用的内存在进行实例化时就确定（分配）了，而依赖属性可以允许对象不分配部分空间 class Student : DependencyObject&#123; //依赖对象的 CLR封装 public string Name &#123; get &#123; return (string)GetValue(NameProperty); &#125; set &#123; SetValue(NameProperty, value); &#125; &#125; //依赖对象 public static readonly DependencyProperty NameProperty = DependencyProperty.Register(&quot;Name&quot;, typeof(string), typeof(Student)); //Binding封装 public BindingExpressionBase SetBinding(DependencyProperty dp, BindingBase binding) &#123; return BindingOperations.SetBinding(this, dp, binding); &#125;&#125; “Name”：指明使用哪一个 CLR属性作为这个依赖属性的包装器 (Wrapper) typeof(string)：指明此依赖属性用来储存什么类型的值 typeof(Student))：指明此依赖属性要注册关联到谁身上 &lt;StackPanel x:Name=&quot;stackPanel&quot; Background=&quot;LightBlue&quot;&gt; &lt;TextBox x:Name=&quot;textBox1&quot; BorderBrush=&quot;Black&quot; Margin=&quot;5&quot;/&gt; &lt;TextBox x:Name=&quot;textBox2&quot; BorderBrush=&quot;Black&quot; Margin=&quot;5&quot;/&gt;&lt;/StackPanel&gt;public partial class MainWindow : Window&#123; Student stu; public MainWindow() &#123; InitializeComponent(); stu = new Student(); stu.SetBinding(Student.NameProperty, new Binding(&quot;Text&quot;) &#123; Source = textBox1 &#125;); textBox2.SetBinding(TextBox.TextProperty, new Binding(&quot;Name&quot;) &#123; Source = stu &#125;); &#125;&#125; 我们还发现，依赖对象并没有实现INotifyPropertyChanged接口，但是当期值发生改变时，与之相关的Binding对象依然可以得到通知，于是依赖对象是天生的合格源数据 在VS中，输入propdp并按两次tab，就能得到一个依赖属性模板 依赖属性的注册 前文我们获得依赖对象的实例时，是通过DependencyProperty.Register注册得到： 创建DependencyProperty实例，并使用其CLR属性名的哈希异或宿主类型的哈希，得到key（通过其他算法，保证唯一） 将key和实例存储到一张全局的HashTable上 GlobalIndex = CLR属性名的HaseCode XOR 宿主类型HashCode 于是运行时只要知道CLR属性名和宿主，就能找到依赖对象实例 依赖属性的读写 依赖属性对象的作用是检索真正的属性值，而非存储属性值 每个DependencyObject实例都自带一个数组，当某个依赖属性的值要被读取时，算法会在这个数组中检索。而用于检索的键值，实际上就是依赖属性的GlobalIndex 也就是说，这个被static readonly修饰的属性，它的作用是一个“标记”，当你需要找某个东西时，就来这里拼一个id，用id查数组 附加属性 附加属性（Attached Properties）：一个属性本不属于某个对象，但由于某种需求后来附加上。换句话说，将对象放入一个特定环境后，才会具有出来的属性 举个例子，比如Human这个类，它可以有很多很多种属性，现在我们想在里面加入一个新的需求，如果我们直接改动这个类，过于繁琐。而如果提前留好空，那么有时候又会空间浪费 附加属性的作用就是让宿主和属性解耦，让宿主的设计更为灵活 事件 消息 事件的前身是消息（Message），Windows系统就是一个消息驱动的操作系统，后来微软为了降低开发难度，将消息系统封装为了事件模型 CLR事件模型 CLR事件模型由三部分组成 事件的拥有者：即消息的发送者 事件的响应者：即消息的接收者，它可以使用事件处理器（Event Handler）对事件做相应 事件的订阅关系：事件的拥有者可以随时激发事件，但只有关注（订阅）了这个事件的响应者会对此产生反应 事件本质上就是一个使用event关键字修饰的委托（Delegate）类型成员变量，事件处理器是一个函数 A订阅了B，实际上就是让B.Event和A.EventHandler关联起来 事件激发就是B.Event被调用 举例 Windows Form按按钮 事件的拥有者 button 事件 button.Click 事件的响应者 窗体 事件处理器 this.button_Click() 订阅关系 this.button.Click += new System.EventHandler(this.button_Click) 路由事件 （WPF事件加强版） 路由事件没有显示订阅关系 事件拥有者只负责激发事件，至于谁会倾听，他并不知道 事件响应者装有事件倾听器，若有事件传递于此，可以决定事件是否可以继续传递 如果事件不归他管，那就踢给下一个人，继续传播 若事件归他管，那就进行处理，并判断是否还需要传给下一个人 public abstract class ButtonBase : ContentControl, ICommandSource&#123; //声明并注册路由事件 public static readonly RoutedEvent ClickEvent = EventManager.RegisterRoutedEvent(&quot;Click&quot;, RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(ButtonBase)); //为路由事件添加 CLR事件包装器 public event RoutedEventHandler Click &#123; add &#123; this.AddHandler(ClickEvent, value); &#125; remove &#123; this.RemoveHandler(ClickEvent, value); &#125; &#125; //激活路由事件的方法 protected virtual void OnClick() &#123; RoutedEventArgs newEvent = new RoutedEventArgs(ButtonBase.ClickEvent, this); this.RaiseEvent(newEvent); &#125;&#125; WPF路由事件有三种策略 Bubble：冒泡式，激发者向其上级一层一层路由，直到到根，路径是确定且唯一 Tunnel：隧道式，激发者向其下级一层一层路由，路径有很多，但朝向响应者移动，就像形成一个隧道 Direct：直达式，类似CLR事件，直接向响应者发送事件 命令 事件不具有约束力，事件接收者使用自己的行为响应事件 命令具有约束力，当命令到达某个组件时，会主动调用组件的某个方法 命令系统 命令（Command）：实现ICommand接口 命令源（Command Source）：实现ICommandSource接口 命令目标（Command Target）：实现IInputElement接口 命令关联（Command Binding） 其他功能 获取当前应用程序域的基础目录 获得.exe文件所在的文件夹目录 string path = System.AppDomain.CurrentDomain.BaseDirectory； 动态加载程序集 加载一个C# DLL文件，然后就可以使用反射来调用API // 这是一个库项目，将被构建为 MathUtils.DLLnamespace MathUtils&#123; public class MathUtils &#123; public static int Add(int a, int b) &#123; return a + b; &#125; &#125;&#125; // 加载DLLstring dllPath = &quot;MathUtils.dll&quot;;byte[] buffer = File.ReadAllBytes(dllPath);Assembly assembly = Assembly.Load(buffer);// 获得类型Type mathType = assembly.GetType(&quot;MathUtils.MathUtils&quot;);if(mathType != null)&#123; // 获得方法 MethodInfo method = mathType.GetMethod(&quot;Add&quot;); if (method != null) &#123; // 执行函数 object[] parameters = new object[] &#123; 1, 2 &#125;; object result = method.Invoke(null, parameters); Console.WriteLine(result); &#125;&#125; Activator 这是一个动态创建对象实例的类型，可以实现泛型 // 自定义类型public class Person&#123; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; public Person(string firstName, string lastName) &#123; FirstName = firstName; LastName = lastName; &#125; public void DisplayInfo() &#123; Console.WriteLine($&quot;Name: &#123;FirstName&#125; &#123;LastName&#125;&quot;); &#125;&#125; // 基于 Activator的泛型工厂public class ObjectFactory&lt;T&gt;&#123; public T CreateInstance(params object[] constructorArgs) &#123; try &#123; // 使用 Activator.CreateInstance 创建泛型类型的实例 return (T)Activator.CreateInstance(typeof(T), constructorArgs); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Failed to create instance: &#123;ex.Message&#125;&quot;); return default(T); &#125; &#125;&#125; // 使用样例ObjectFactory&lt;Person&gt; personFactory = new ObjectFactory&lt;Person&gt;();Person person = personFactory.CreateInstance(&quot;John&quot;, &quot;Doe&quot;);person.DisplayInfo(); 值得注意的时，C#的泛型类型也是在编译期确定的（与C++相同），这样可以提供编译检查等功能","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://reubensun.com/tags/CSharp/"},{"name":"Windows","slug":"Windows","permalink":"https://reubensun.com/tags/Windows/"}]},{"title":"Pro-TBB","slug":"program/Pro-TBB","date":"2023-02-01T10:01:25.000Z","updated":"2025-03-18T07:16:48.437Z","comments":true,"path":"program/Pro-TBB/","permalink":"https://reubensun.com/program/Pro-TBB/","excerpt":"","text":"Pro TBB 在摩尔定律逐渐失效的今日，CPU主频和单核性能提升越来越不明显，为了得到跟高的性能，我们走向了并行计算的道路 概念 并发和并行 并发（Concurrent）：happening during the same time span，处理器在两件事间快速切换，宏观上看，就像是同时发生的（下图AB） 并行（Parallel）：happening at the same time，多个处理器一起做事（下图CD） TBB基础 TBB（Threading Building Blocks）是一个非常流行的C++并行编程（parallel programming）方案 使用Task而非Thread Thread与硬件相关，直接编写难以跨平台，而且线程间通信过于频繁，过于繁琐 TBB使用Task编程，运行时会将程序映射到硬件上（该方法对嵌套并行的支持很不错） TBB任务调度使用工作窃取，当一个任务队列执行完毕后，核心会去其他任务队列中窃取任务，于是可以提高核心的利用率 TBB实现了可组合性（Composability） 简单来说就是支持for循环 方便移植（portable） Mac上安装使用TBB 安装tbb $brew install tbb 链接tbb #寻找tbb包find_package(TBB REQUIRED)...#链接target_link_libraries(TimeStudy TBB::tbb) 引用头文件 #include&lt;tbb/tbb.h&gt; 在Ubuntu上安装TBB $sudo apt-get install libtbb-dev 调用函数 template&lt;typename Func0, [...,] typename FuncN&gt;void parallel_invoke(const Func0&amp; f0, [...,] const FuncN&amp; fN); 一个简单的TBB示例，并行输出两行字符串 通过tbb::parallel_invoke实现任务、函数粒度的并行 #include &lt;iostream&gt;#include &lt;tbb/tbb.h&gt;int main() &#123; tbb::parallel_invoke( []()&#123;std::cout &lt;&lt; &quot;TBB!&quot; &lt;&lt; std::endl;&#125;, []()&#123;std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;&#125; ); return 0;&#125; 我们这里使用lambda表达式创建了匿名（anonymous）函数，可以大幅简化TBB编写 快排示例 传统快排算法（升序） 在数列中取一个数作为基准数 比基准小的放在基准左边，大的放在右边 对左右两边分别快排，直到只剩一个数（左右重合） 能看出，这个算法采用了分治的思想，很适合并行 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;tbb/tbb.h&gt;using QV = std::vector&lt;int&gt;;//传统快排void quickSort(QV::iterator left, QV::iterator right)&#123; if(left &gt;= right)&#123; return; &#125; int pivot_value = *left; QV::iterator i = left, j = right - 1; while(i != j)&#123; while(i != j &amp;&amp; pivot_value &lt; *j) --j; //从右向左找，直到找到一个比基准小的 while(i != j &amp;&amp; pivot_value &gt;= *i) ++i; //从左往右找，直到找到一个比基准大的 std::iter_swap(i, j); &#125; std::iter_swap(left, i); quickSort(left, i); quickSort(j+1, right);&#125;//并行快排void parallelQuicksort(QV::iterator left, QV::iterator right)&#123; if(left &gt;= right)&#123; return; &#125; int pivot_value = *left; QV::iterator i = left, j = right - 1; while (i != j) &#123; while (i != j &amp;&amp; pivot_value &lt; *j) --j; while (i != j &amp;&amp; pivot_value &gt;= *i) ++i; std::iter_swap(i, j); &#125; std::iter_swap(left, i); // recursive call tbb::parallel_invoke( //lambda表达式[=]表示传入当前函数所有的成员 [=]() &#123; parallelQuicksort(left, i); &#125;, [=]() &#123; parallelQuicksort(i + 1, right); &#125; );&#125;//使用cutoffvoid parallelCutoffQuicksort(QV::iterator left, QV::iterator right)&#123; const int cutoff = 100; if (right - left &lt; cutoff) &#123; quickSort(right, left); &#125; else &#123; int pivot_value = *left; QV::iterator i = left, j = right - 1; while (i != j) &#123; while (i != j &amp;&amp; pivot_value &lt; *j) --j; while (i != j &amp;&amp; pivot_value &gt;= *i) ++i; std::iter_swap(i, j); &#125; std::iter_swap(left, i); // recursive call tbb::parallel_invoke( [=]() &#123; parallelQuicksort(left, i); &#125;, [=]() &#123; parallelQuicksort(i + 1, right); &#125; ); &#125;&#125;int main() &#123; std::vector&lt;int&gt; nums; for(int i = 0; i &lt; 5000; ++i)&#123; nums.push_back(rand() % 5000); &#125; //warmup tbb::parallel_for(0, 10, [](int) &#123; tbb::tick_count t0 = tbb::tick_count::now(); while ((tbb::tick_count::now() - t0).seconds() &lt; 0.01); &#125;); std::vector&lt;int&gt; nums2 = nums; tbb::tick_count t0 = tbb::tick_count::now(); quickSort(nums.begin(), nums.end()); std::cout &lt;&lt; &quot;Normal Time=&quot; &lt;&lt; (tbb::tick_count::now() - t0).seconds() &lt;&lt; std::endl; tbb::tick_count t1 = tbb::tick_count::now(); parallelQuicksort(nums2.begin(), nums2.end()); std::cout &lt;&lt; &quot;Parallel Time=&quot; &lt;&lt; (tbb::tick_count::now() - t1).seconds() &lt;&lt; std::endl; return 0;&#125; 最后结果，当数组比较大的时候，并行快排速度会更快一点 Normal Time=0.0023285Parallel Time=0.00110846 此外tbb进行任务分配也会有开销，因此我们往往将大任务分成若干个小任务后，让小任务串型执行，上文中的cutoff就是起到这个作用，这样往往能得到更高的性能 时刻查询 //t0时刻tbb::tick_count t0 = tbb::tick_count::now(); ...//当前时刻-t0时刻=经过了多长时间段（并转化为秒）std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; (tbb::tick_count::now() - t0).seconds() &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl; 并行开发中动态内存管理十分复杂、危险（内存泄漏），这里推荐使用C++11的智能指针（自带GC） Flow Graph 将函数执行制作成Graph，实现消息驱动的并行（有些类似FrameGraph） void fig1_10(const std::vector&lt;ImagePtr&gt;&amp; image_vector)&#123; const double tint_array[] = &#123;0.75, 0, 0&#125;; tbb::flow::graph g; int i = 0; //注意，source_node已经失效 tbb::flow::input_node&lt;ImagePtr&gt; src(g, [&amp;i, &amp;image_vector](tbb::flow_control &amp;fc) -&gt; ImagePtr &#123; if(i &lt; image_vector.size())&#123; return image_vector[i++]; &#125; else&#123; fc.stop(); return &#123;&#125;; &#125; &#125;); tbb::flow::function_node&lt;ImagePtr, ImagePtr&gt; gamma(g, tbb::flow::unlimited, [] (ImagePtr img) -&gt; ImagePtr&#123; return applyGamma(img, 1.4); &#125; ); tbb::flow::function_node&lt;ImagePtr, ImagePtr&gt; tint(g, tbb::flow::unlimited, [tint_array] (ImagePtr img) -&gt; ImagePtr&#123; return applyTint(img, tint_array); &#125; ); tbb::flow::function_node&lt;ImagePtr&gt; write(g, tbb::flow::unlimited, [] (ImagePtr img)&#123; writeImage(img); &#125; ); tbb::flow::make_edge(src, gamma); tbb::flow::make_edge(gamma, tint); tbb::flow::make_edge(tint, write); src.activate(); g.wait_for_all();&#125; 最后该程序会以流水线的形式执行，当第一张图片完成gamma矫正，去执行tint着色时，第二张图片开始执行gamma矫正（每张图片间互不影响） 相比于TimeStudy的串型执行，流水线执行效率会更快 循环 template&lt;typename Index, typename Func&gt;Func parallel_for(Index frist, Index last, [Index step,] const Func&amp; f); 上面的代码，我们将图片处理切分为几个小块，但小块内部仍然是单线程 我们注意到，在图片处理时，有一个很大的循环在遍历图片上的像素点，那么能不能并行做这件事？ 我们并行处理每一行 tbb::parallel_for(0, height, [&amp;in_rows, &amp;out_rows, width, gamma](int i)&#123; for(int j = 0; j &lt; width; ++j)&#123; const ImageLib::Image::Pixel&amp; p = in_rows[i][j]; double v = 0.3 * p.bgra[2] + 0.59 * p.bgra[1] + 0.11 * p.bgra[0]; double res = pow(v, gamma); if(res &gt; ImageLib::MAX_BGR_VALUE)&#123; res = ImageLib::MAX_BGR_VALUE; &#125; out_rows[i][j] = ImageLib::Image::Pixel(res, res, res); &#125; &#125; ); tbb::parallel_for(0, height, [&amp;in_rows, &amp;out_rows, width, tints](int i)&#123; for(int j = 0; j &lt; width; ++j)&#123; const ImageLib::Image::Pixel&amp; p = in_rows[i][j]; std::uint8_t b = (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[0]) * tints[0]; std::uint8_t g = (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[1]) * tints[1]; std::uint8_t r = (double)p.bgra[0] + (ImageLib::MAX_BGR_VALUE - p.bgra[2]) * tints[2]; out_rows[i][j] = ImageLib::Image::Pixel( (b &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : b, (g &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : g, (r &gt; ImageLib::MAX_BGR_VALUE) ? ImageLib::MAX_BGR_VALUE : r ); &#125; &#125; ); M1 Mac Xcode Clang至今不支持C++17的std::execution，对OpenMP的支持也相当差 归约 template&lt;typename Range, typename Value, typename Func, typename Reduction&gt;Value parallel_reduce(const Range&amp; range, const Value&amp; identity, const Func&amp; func, const Reduction&amp; reduction); 树形规约 求最大值 下面是一个vector求最大值的示例，实现机制就是将整个数组分成一个个小块（chunks），分别对小块求最值，然后将小块归约（reduce），最后求得最值（形成了一个树型结构） int pmax(const std::vector&lt;int&gt; &amp;arr)&#123; int max_value = tbb::parallel_reduce( //range，扫描范围 tbb::blocked_range&lt;int&gt;(0, arr.size()), //identity，小块数据的初始值，这里赋值为int类型的最小值-2147483648 std::numeric_limits&lt;int&gt;::min(), //func，每个小块的处理方式 [&amp;](const tbb::blocked_range&lt;int&gt; &amp;r, int init) -&gt; int&#123; for(int i = r.begin(); i != r.end(); ++i)&#123; init = std::max(init, arr[i]); &#125; return init; &#125;, //reduction，小块间合并的处理方式 [](int x, int y) -&gt; int&#123; return std::max(x, y); &#125; ); return max_value;&#125; 下面这是一个求PI的示例 double calcPI(int degree)&#123; double dx = 1.0 / degree; double sum = tbb::parallel_reduce( //range，扫描范围 tbb::blocked_range&lt;int&gt;(0, degree), //identity，小块数据的初始值，这里赋值为0 0.0, //func，每个小块的处理方式 [=](const tbb::blocked_range&lt;int&gt; &amp;r, double init) -&gt; double&#123; for(int i = r.begin(); i != r.end(); ++i)&#123; double x = (i + 0.5)*dx; double h = std::sqrt(1 - x*x); //勾股定理 init += h * dx; &#125; return init; &#125;, //reduction，小块间合并的处理方式 [](double x, double y) -&gt; double&#123; return x+y; &#125; ); return 4 * sum;&#125; 扫描 template&lt;typename Range, typename Value, typename Scan, typename Combine&gt;Value parallel_scan(const Range&amp; range, const Value&amp; identity, const Scan&amp; scan, const Combine&amp; combine); 前缀和 前缀和在图形领域也有很大的用处 对于一个数组，我们将其分为三个小块ABC A.init=0, B.init=0scan(A), scan(B)B.init = A.ansC.init = A.ans + B.ansscan(B), scan(C) 最后我们只用了串行2/3的扫描时间，但是多做了1/3的扫描工作，时间减少了，但是工作量变大了 int parallelPrefix(const std::vector&lt;int&gt; &amp;v, std::vector&lt;int&gt; &amp;psum)&#123; int N = v.size(); psum[0] = v[0]; int final_sum = tbb::parallel_scan( //range tbb::blocked_range&lt;int&gt;(1, N), //identity (int)0, //scan body [&amp;v, &amp;psum](const tbb::blocked_range&lt;int&gt; &amp;r, int sum, bool is_final_scan) -&gt; int&#123; for(int i = r.begin(); i &lt; r.end(); ++i)&#123; sum += v[i]; if(is_final_scan)&#123; psum[i] = sum; &#125; &#125; return sum; &#125;, //combine body [](int x, int y)&#123; return x+y; &#125; ); return final_sum;&#125; 可见性 如图，等间距摆放一个个薄板（厚度忽略不计），从最右上角向左看，能看到哪些薄板？ 解题的本质就是比较夹角大小，只要夹角一直递增，就能看到 void visibility(const std::vector&lt;double&gt; &amp;heights, std::vector&lt;bool&gt; &amp; visible, double dx)&#123; const int N = heights.size(); double max_angle = std::atan2(dx, heights[0] - heights[1]); double final_max_angle = tbb::parallel_scan( //range tbb::blocked_range&lt;int&gt;(1, N), //identity 0.0, //scan body [&amp;heights, &amp;visible, dx](const tbb::blocked_range&lt;int&gt; &amp;r, double max_angle, bool is_final_scan) -&gt; double &#123; for(int i = r.begin(); i != r.end(); ++i)&#123; double my_angle = atan2(i * dx, heights[0] - heights[i]); if(my_angle &gt;= max_angle)&#123; max_angle = my_angle; &#125; else if(is_final_scan)&#123; visible[i] = false; &#125; &#125; return max_angle; &#125;, //combine body [](double a, double b)&#123; return std::max(a, b); &#125; );&#125; parallel_for_each parallel_for在使用时必须指定range，但如果要处理的item数量不确定（比如在执行过程中修改itemList），那么就不能使用，这个时候我们可以使用parallel_for_each template &lt;typaname InputIterator, typename Body&gt;void parallel_for_each( InputIterator first, InputIterator last, Body body ); 下面是一个遍历树的示例，若一个节点的v.first为prime，将其v.second修改为true。我们不知道树有多大，于是采用递归遍历 void f(PrimesTreeElement::Ptr root)&#123; PrimesTreeElement::Ptr tree_arry[] = &#123;root&#125;; //tbb::parallel_do已经废弃 tbb::parallel_for_each( tree_array, [](PrimesTreeElement::Ptr e, //tbb::parallel_do_feeder已被废弃 tbb::feeder&lt;PrimesTreeElement::Ptr&gt;&amp; feeder)&#123; if(e)&#123; if(isPrime(e-&gt;v.first)) e-&gt;v.second = true; if(e-&gt;left) feeder.add(e-&gt;left); if(e-&gt;right) feeder.add(e-&gt;right); &#125; &#125; );&#125; 前向替换 前向替换（Forward Substitution）是线性代数中一种求解线性方程组的方法 一般解线性方程组有两种方法： 直接法 高斯消元法 LU分解法 迭代法 高斯消元法：初中就学了，就是两个方程变化后相加减（也可以换元），消除变量，直到得到解。这个方法可以拓展到矩阵中，就是把线性方程转化为行阶梯矩阵（中间那个矩阵），然后简化为简化行阶梯矩阵（右边那个矩阵） $$ \\left[ \\begin{matrix} 2 &amp; 1 &amp; -1 &amp;|&amp; 8 \\\\ -3 &amp; -1 &amp; 2 &amp; | &amp; -11 \\\\ -2 &amp; 1 &amp; 2 &amp; | &amp; -3 \\end{matrix} \\right] =&gt; \\left[ \\begin{matrix} 2 &amp; 1 &amp; -1 &amp;|&amp; 8 \\\\ 0 &amp; 1/2 &amp; 1/2 &amp; | &amp; 1 \\\\ 0 &amp; 0 &amp; -1 &amp; | &amp; 1 \\end{matrix} \\right] =&gt; \\left[ \\begin{matrix} 1 &amp; 0 &amp; 0 &amp;|&amp; 2 \\\\ 0 &amp; 1 &amp; 0 &amp; | &amp; 3 \\\\ 0 &amp; 0 &amp; 1 &amp; | &amp; -1 \\end{matrix} \\right] $$ 前向替换法就是得到行阶梯矩阵后 能写出以下式子 $$ \\begin{cases} x_1 = b_1/a_{11} \\\\ x_2 = (b_2-a_{21}x_1)/a_{22} \\\\ \\ \\vdots \\\\ x_n = (b_n -a_{n1}x_1-a_{n2}x_2 - \\cdots -a_{nn-1}x_{n-1})/a_{nm} \\end{cases} $$ 于是我们只需要从第一个式子开始，逐步向下替换，就能求出方程的解 如果是下三角矩阵，那就是后向替换 //a是一个下三角矩阵，x、b是向量void serialFS(std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; a, std::vector&lt;double&gt;&amp; b) &#123; const int N = x.size(); for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; b[i] -= a[j + i*N] * x[j]; &#125; x[i] = b[i] / a[i + i*N]; &#125;&#125; 加入分块和并行后： void parallelFS(std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b) &#123; const int N = x.size(); const int block_size = 512; const int num_blocks = N / block_size; //tbb::atomic已经废弃 std::vector&lt;std::atomic&lt;char&gt;&gt; ref_count(num_blocks * num_blocks); for (int r = 0; r &lt; num_blocks; ++r) &#123; for (int c = 0; c &lt;= r; ++c) &#123; if (r == 0 &amp;&amp; c == 0) ref_count[r * num_blocks + c] = 0; else if (c == 0 || r == c) ref_count[r * num_blocks + c] = 1; else ref_count[r * num_blocks + c] = 2; &#125; &#125; using BlockIndex = std::pair&lt;size_t, size_t&gt;; BlockIndex top_left(0, 0); //tbb::parallel_do已经废弃 tbb::parallel_for_each(&amp;top_left, &amp;top_left + 1, [&amp;](const BlockIndex &amp;bi, tbb::feeder&lt;BlockIndex&gt; &amp;feeder) &#123; size_t r = bi.first; size_t c = bi.second; int i_start = r * block_size, i_end = i_start + block_size; int j_start = c * block_size, j_max = j_start + block_size - 1; for (int i = i_start; i &lt; i_end; ++i) &#123; int j_end = (i &lt;= j_max) ? i : j_max + 1; for (int j = j_start; j &lt; j_end; ++j) &#123; b[i] -= a[j + i * N] * x[j]; &#125; if (j_end == i) &#123; x[i] = b[i] / a[i + i * N]; &#125; &#125; // add successor to right if ready if (c + 1 &lt;= r &amp;&amp; --ref_count[r * num_blocks + c + 1] == 0) &#123; feeder.add(BlockIndex(r, c + 1)); &#125; // add succesor below if ready if (r + 1 &lt; (size_t) num_blocks &amp;&amp; --ref_count[(r + 1) * num_blocks + c] == 0) &#123; feeder.add(BlockIndex(r + 1, c)); &#125; &#125; );&#125; 流水线 void parallel_pipeline( size_t max_number_of_live_tokens, const filter&lt;void,void&gt;&amp; filter_chain );template&lt;typename T, typename U, typename Func&gt;filter_t&lt;T, U&gt; make_filter(filter::mode mode, const Func&amp; f); 管线（pipeline）是过滤器（filters）的线性序列，物体（items）在通过过滤器时，会被处理 //并行 将字符串中大写变小写void fig_2_27(int num_tokens, std::ofstream &amp;caseBeforeFile, std::ofstream &amp;caseAfterFile) &#123; tbb::parallel_pipeline( //tokens num_tokens, //第一个filter，负责创建字符串 tbb::make_filter&lt;void, CaseStringPtr&gt;( //tbb::filter::serial_in_order已经废弃 tbb::filter_mode::serial_in_order, //filter body [&amp;](tbb::flow_control &amp;fc) -&gt; CaseStringPtr &#123; CaseStringPtr s_ptr = getCaseString(caseBeforeFile); if (!s_ptr) fc.stop(); return s_ptr; &#125;) &amp; // 链接 //第二个filter，负责修改字符串 tbb::make_filter&lt;CaseStringPtr, CaseStringPtr&gt;( //filter node tbb::filter_mode::parallel, //filter body [](CaseStringPtr s_ptr) -&gt; CaseStringPtr &#123; std::transform(s_ptr-&gt;begin(), s_ptr-&gt;end(), s_ptr-&gt;begin(), [](char c) -&gt; char &#123; if (std::islower(c)) return std::toupper(c); else if (std::isupper(c)) return std::tolower(c); else return c; &#125;); return s_ptr; &#125;) &amp; //链接 //第三个filter，负责写字符串 tbb::make_filter&lt;CaseStringPtr, void&gt;( //filter node tbb::filter_mode::serial_in_order, //filter body [&amp;](CaseStringPtr s_ptr) -&gt; void &#123; writeCaseString(caseAfterFile, s_ptr); &#125;) );&#125; Flow Graphs 并行编程另一个问题是混乱，传统并行编程为了避免程序混乱（messy），我们需要事无巨细地管理每一件事。但在上一节简单提到的Flow Graphs，提供了一个简单的管理方法 Flow Graphs允许我们用图（DAG）来描述程序，相比于parallel_do和parallel_pipeline，FlowGraphs自由度更高，推荐使用。 每个节点是一个并行函数，箭头代表数据的流向/消息传递，我们将这个图称为数据流向图（data flow graphs） 图也可以描述操作的前后顺序，进而可以构建一些传统方法难以表示的独立结构体，这种图被称为依赖图（dependency graphs） 预热 static void warmupTBB() &#123; //tbb::task_scheduler_init::default_num_threads()已经弃用 tbb::parallel_for(0, tbb::this_task_arena::max_concurrency(), [](int) &#123; tbb::tick_count t0 = tbb::tick_count::now(); while ((tbb::tick_count::now() - t0).seconds() &lt; 0.01); &#125;);&#125; 无论是web服务器、CPU/GPU并行计算，深度学习，都有warmup的概念 对于一个项目，如果采用冷启动的方式，从零瞬间增加计算量，可能会把系统压垮，于是我们可以使用warmup，逐步提高项目负荷。 数据流图 构建图对象 创建节点，填充节点信息 链接节点 发送消息 等待图完成 void graphSample()&#123; //创建图对象 tbb::flow::graph g; //创建节点 tbb::flow::function_node&lt;int, std::string&gt; my_first_node( g, tbb::flow::unlimited, [](const int &amp;in) -&gt; std::string&#123; std::cout &lt;&lt; &quot;first node received: &quot; &lt;&lt; in &lt;&lt; std::endl; return std::to_string(in); &#125; ); tbb::flow::function_node&lt;std::string&gt; my_second_node( g, tbb::flow::unlimited, [](const std::string &amp;in)&#123; std::cout &lt;&lt; &quot;second node received: &quot; &lt;&lt; in &lt;&lt; std::endl; &#125; ); //链接 tbb::flow::make_edge(my_first_node, my_second_node); //发送消息 my_first_node.try_put(10); //等待图完成 g.wait_for_all();&#125; 节点 Flow Graphs有三种节点 functional control flow buffering function_node template&lt;typename Body&gt;function_node(graph&amp; g, size_t concurrency, Body body); 函数节点，当消息传递到该节点，会被函数处理，并将输出值传递给后继者 //输入一个int类型，输出一个std::string类型tbb::flow::function_node&lt;int, std::string&gt; my_first_node( //图对象 g, //节点的并发限制，0是无限制(unlimited)，1是串行(serial) tbb::flow::unlimited, //body [](const int &amp;in) -&gt; std::string&#123; std::cout &lt;&lt; &quot;first node received: &quot; &lt;&lt; in &lt;&lt; std::endl; return std::to_string(in); &#125; ); 函数节点可以从他所连接（edges）其他节点获取消息，也可以使用try_put手动向其传递消息 join_node template &lt;typename Body, typename... Bodies&gt;join_node(graph&amp;, Body, Bodies...)-&gt;join_node&lt;std::tuple&lt;std::decay_t&lt;input_t&lt;Body&gt;&gt;, std::decay_t&lt;input_t&lt;Bodies&gt;&gt;...&gt;, key_matching&lt;output_t&lt;Body&gt;&gt;&gt;; 流控制节点，当消息传递到该节点，会创建一个消息元组（tuple），然后将元组广播给所有后继者 //my_node，输入int，输出std::stringtbb::flow::function_node&lt;int, std::string&gt; my_node&#123;...&#125;;//my_other_node，输入int，输出doubletbb::flow::function_node&lt;int, double&gt; my_other_node&#123;...&#125;;//join节点，这里的作用是将两个节点的输出整合，传递给my_final_nodetbb::flow::join_node&lt;std::tuple&lt;std::string, double&gt;, tbb::flow::queueing&gt; my_join_node&#123;g&#125;;//my_final_node，输入一个元组tbb::flow::function_node&lt;std::tuple&lt;std::string, double&gt;, int&gt; my_final_node&#123;g, tbb::flow::unlimited, [](const std::tuple&lt;std::string, double&gt;&amp; in) -&gt; int &#123; std::cout &lt;&lt; &quot;final: &quot; &lt;&lt; std::get&lt;0&gt;(in) &lt;&lt; &quot; and &quot; &lt;&lt; std::get&lt;1&gt;(in) &lt;&lt; std::endl; return 0; &#125; &#125;; 有的时候，我们需要保证join_node的输入的对应的。比如我想将两张照片拼成一张，我开两个节点并行读项目，再用join_node整合后传入merge函数节点，然而在这个过程中，我必须保证传入的两个像素点在同一位置，为此，我们可以添加一个frameNumber做标记（tags） //使用函数对象作为tags，可以用input_port&lt;i&gt;读出来tbb::flow::join_node&lt;std::tuple&lt;Image, Image&gt;, tbb::flow::tag_matching &gt; join_images_node(g, [] (Image left) &#123; return left.frameNumber; &#125;, [] (Image right) &#123; return right.frameNumber; &#125; );...tbb::flow::make_edge(increase_left_node, tbb::flow::input_port&lt;0&gt;(join_images_node));tbb::flow::make_edge(increase_right_node, tbb::flow::input_port&lt;1&gt;(join_images_node));tbb::flow::make_edge(join_images_node, merge_images_node); 链接 template&lt;typename Message&gt; inline void make_edge( sender&lt;Message&gt; &amp;p, receiver&lt;Message&gt; &amp;s );template&lt; typename MultiOutputNode, typename MultiInputNode &gt; inline void make_edge( MultiOutputNode&amp; output, MultiInputNode&amp; input ); 我们可以使用make_edge链接两个节点 //这里的input_port是一种sender，跟节点差不多，都能互相链接make_edge(my_node, tbb::flow::input_port&lt;0&gt;(my_join_node));make_edge(my_other_node, tbb::flow::input_port&lt;1&gt;(my_join_node));make_edge(my_join_node, my_final_node); 激活 为了激活图，我们需要向图中传递消息，除了前文的try_put，我们也可以使用input_port //my_node是一个input_nodemy_node.activate(); //将其设为活动状态，启用消息生成 等待 g.wait_for_all(); 性能限制 Flow Graphs是一个基于Task的并行框架，当消息到达一个节点时，根据节点的并发限制，创建Task。生成的Task会进一步映射为线程（跟上一节讲的循环、算法的机制一样） 真正限制Flow Graphs性能的有 串行节点（serial node） 工作线程数 任务复杂度 依赖图 很像RenderGraph 数据流向图 依赖图 Edges含义 表示数据流向 表示节点的先后顺序 信息传递方式 消息 shared memory 节点类型 function_node continue_node 节点的先后顺序，描述的是依赖关系，只有前面节点执行结束后，后面节点才能安全、正确地执行 依赖图不使用函数节点，而是继续节点continue_node，节点间的消息传递使用，当传入continue_node的消息（continue_msg）数量等于该节点需要的消息数量，节点内的函数会开始执行 continue_node只关心传入的消息数量，不关心消息源。这导致依赖图必须是非循环的（acyclic），因为一个物体循环发出两次消息，（在这里）等同于两个物体各发出一次消息 构建依赖图 创建图对象 创建节点 链接 发送信息 等待图完成 前向替换 之前我们使用parallel_for_each实现了一份前向替换，我们现在用依赖图再实现一次 经观察，我们发现辅对角线的块/迭代器是相互独立的，他们之间没有依赖关系（上图(b)，块BC间没有依赖，他们只需要在A之后执行就可以正确运算） 经观察，同时并行计算的最大块数为辅对角线的长度，也就是图中标注的 a set of independent blocks 经观察，上图(b)中每一个块需要接受两个msg，正好与block_sizes大小相等 using Node = tbb::flow::continue_node&lt;tbb::flow::continue_msg&gt;;using NodePtr = std::shared_ptr&lt;Node&gt;;NodePtr createNode(tbb::flow::graph &amp;g, int r, int c, int block_size, std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b);void addEdges(std::vector&lt;NodePtr&gt; &amp;nodes, int r, int c, int block_size, int num_blocks);void dependencyGraphFS(std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b)&#123; const int N = x.size(); const int block_size = 1024; const int num_blocks = N / block_size; //创建num_blocks * num_blocks个节点，只不过我们只会用到下半部分 std::vector&lt;NodePtr&gt; nodes(num_blocks * num_blocks); //创建图对象 tbb::flow::graph g; //我们从最下面一行开始向上构建 for(int r = num_blocks-1; r &gt;= 0; --r)&#123; for(int c = r; c &gt;= 0; --c)&#123; //创建图节点 nodes[r * num_blocks + c] = createNode(g, r, c, block_size, x, a, b); //链接 addEdges(nodes, r, c, block_size, num_blocks); &#125; &#125; //传入消息 nodes[0]-&gt;try_put(tbb::flow::continue_msg()); //等待完成 g.wait_for_all();&#125;NodePtr createNode(tbb::flow::graph &amp;g, int r, int c, int block_size, std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;a, std::vector&lt;double&gt; &amp;b)&#123; const int N = x.size(); return std::make_shared&lt;Node&gt;( g, [r, c, block_size, N, &amp;x, &amp;a, &amp;b](const tbb::flow::continue_msg &amp; msg)&#123; int i_start = r * block_size, i_end = i_start + block_size; int j_start = c * block_size, j_max = j_start + block_size -1; //对于每个块，串行进行正向替换计算 for(int i = i_start; i &lt; i_end; ++i)&#123; int j_end = (i &lt;= j_max) ? i : j_max+1; for(int j = j_start; j &lt; j_end; ++j)&#123; b[i] -= a[j + i*N] * x[j]; &#125; if(j_end == i)&#123; x[i] = b[i] / a[i + i*N]; &#125; &#125; return msg; &#125; );&#125;void addEdges(std::vector&lt;NodePtr&gt; &amp;nodes, int r, int c, int block_size, int num_blocks)&#123; NodePtr np = nodes[r * num_blocks + c]; //每个块链接自己的下面和右边，最下面和最右边不链接 if(c + 1 &lt; num_blocks &amp;&amp; r != c)&#123; tbb::flow::make_edge(*np, *nodes[r * num_blocks + c + 1]); &#125; if(r + 1 &lt; num_blocks)&#123; tbb::flow::make_edge(*np, *nodes[(r+1) * num_blocks + c]); &#125;&#125; PSTL parallel_sort 同步 在并行编程中，我们要极力避免同步（Synchronization）和互斥（exclusion），这会严重影响性能 但是很多情况下，我们不得不同步，书中称其为“必要之恶”（necessary evil） 写冲突 比如我们想要统计一张图中各种颜色出现的次数，如果是串行处理，我们就遍历每一个像素，用一个数组存储统计值 for(int i = 0; i &lt; N; ++i)&#123; hist[image[i]]++;&#125; 但当我们想要并行处理遍历像素时，就会出现问题。如果两个线程同时读到了同一种颜色，于是都想执行hist[p]++，而如果该操作不支持原子（atomic）操作，就会出现写冲突 RMW 现代操作系统将很多操作设置为原子操作，该操作被视为一个完成的操作，不可分割，因此是线程安全的。比如对齐读（Aligned Read），对齐写（Aligned Write） 原子的本意就是不可分割的意思，当年化学家和物理学家认为原子是最小的粒子（尽管并非如此） Read-Modify-Write（RMW）设计原则，可以让复杂操作原子化，当多个线程想要对某个内存进行修改时，保证线程安全并只执行一次 windows原子操作的实现原理（_InterlockedIncrement） 读内存 计算得到新值 若内存位置仍然是原始值，则将新值写入该内存位置 若不是原始值，则在下一个循环周期中重新操作 锁 解决并行写冲突最简单的方法就是加锁，我们给对象加一个互斥锁（mutex），写之前上锁，写完解锁，其他线程无法操作锁住的对象。而上锁解锁操作中间的代码被称为临界区（critical section），是被锁保护的部分。 锁会影响性能 //tbb::task_scheduler_init init&#123;nth&#125;已经弃用，用于设置最大线程数tbb::global_control global_limit(tbb::global_control::max_allowed_parallelism, nth);using my_mutex_t=tbb::spin_mutex;my_mutex_t my_mutex;std::vector&lt;int&gt; hist_p(num_bins);parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r) &#123; //这种写法比my_lock.acquire(my_mutex)、my_lock.release()好 my_mutex_t::scoped_lock my_lock&#123;my_mutex&#125;; for (size_t i = r.begin(); i &lt; r.end(); ++i) hist_p[image[i]]++; &#125;); 原子操作 锁过于消耗性能，原子操作效果会好一些，只不过这样还是比线性慢，而且不是真共享（Sharing） 什么是原子？原子的原意就是不可分割的基本粒子，我们在实现a++时，本质是分了三步 取a 加法运算 写a 由于并行计算，其他线程可能在你完整完成这三步期间进行操作，于是就会出现冲突。而原子操作就是将这三步视为一步，不可分割，在完整完成这三部之前，其他线程无权访问，等到操作结束 std::vector&lt;std::atomic&lt;int&gt;&gt; hist_p2(num_bins);parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r) &#123; for(size_t i = r.begin(); i &lt; r.end(); ++i) &#123; hist_p2[image[i]]++; &#125; &#125; ); Thread Local Storage 一个较好的解决方案是私有化（Privatization）和归并（Reduction） 我感觉这个的设计理念就是：如果不得不同步，那就尽可能让更多更复杂的计算并行执行，最后对统一、规范、简单的数据进行同步 前面并行统计Image像素信息时，会出现多个线程写冲突。但如果让每个线程都有一个Image副本，线程对自己的副本进行操作（私有化），最后将这些副本进行归并。 私有化确实不会出现写冲突了，尽管归并仍然存在同步问题，但这个归并更简单，毕竟归并几个数，远远比处理几个线程冲突要简单，性能开销小 TBB提供了多种私有化+归并的的方案，其中归并模板（parallel_reduce）在TBB基础时就讲了 Thread Local Storage（TLS）：让每一个线程拥有一份副本，只不过存储开销过大，不宜过多使用 enumerable_thread_specific（ETS） combinable ETS tbb::enumerable_thread_specific&lt;T&gt;对象是一个大容器，容器内包含者每一个线程所对应的副本，我们可以使用迭代器进行访问 using vector_t = std::vector&lt;int&gt;;using priv_h_t = tbb::enumerable_thread_specific&lt;vector_t&gt;;priv_h_t priv_h&#123;num_bins&#125;;//私有化parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r) &#123; //若该线程第一次使用local，那么会创建一个新的vector&lt;int&gt;，初始值为0 priv_h_t::reference my_hist = priv_h.local(); for (size_t i = r.begin(); i &lt; r.end(); ++i)&#123; //my_hist是引用，实际上是在修改priv_h[xxx]，以此将数据传递到线程外 my_hist[image[i]]++; &#125; &#125;);//归并vector_t hist_p3(num_bins);for(auto i=priv_h.begin(); i!=priv_h.end(); ++i)&#123; for (int j=0; j&lt;num_bins; ++j) &#123; hist_p3[j]+=(*i)[j]; &#125;&#125; 使用STL算法替代循环，进行归并 //我们可以使用transform替代循环遍历for (auto&amp; i: priv_h) &#123; // i traverses all private vectors std::transform(hist_p3.begin(), // source 1 begin hist_p3.end(), // source 1 end i.begin(), // source 2 begin hist_p3.begin(), // destination begin std::plus&lt;int&gt;() ); // binary operation &#125; 由于归并过于常用，TBB也对归并做了封装 //使用combine_eachpriv_h.combine_each([&amp;](vector_t i)&#123; std::transform(hist_p3.begin(), // source 1 begin hist_p3.end(), // source 1 end i.begin(), // source 2 begin hist_p3.begin(), // destination begin std::plus&lt;int&gt;() ); // binary operation &#125;);//或者使用combinevector_t hist_p = priv_h.combine([](vector_t a, vector_t b) -&gt; vector_t &#123; std::transform(a.begin(), // source 1 begin a.end(), // source 1 end b.begin(), // source 2 begin a.begin(), // destination begin std::plus&lt;int&gt;() );// binary operation return a; &#125;); combinable combinable&lt;T&gt;对象也是一个容器，每一个线程对应一个instance 但是与ETS不同，combinable&lt;T&gt;并不能使用迭代器访问，这样设计的目的是不向外暴露对象，这样归并结束后大容器和其中的数据都释放了，以此节省局部空间 //combinabletbb::combinable&lt;vector_t&gt; priv_h2&#123;[num_bins]()&#123;return vector_t(num_bins);&#125;&#125;;//私有化parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r) &#123; vector_t&amp; my_hist = priv_h2.local(); for (size_t i = r.begin(); i &lt; r.end(); ++i) my_hist[image[i]]++; &#125;);//归并vector_t hist_p4(num_bins);priv_h2.combine_each([&amp;](vector_t i) &#123; // for each priv histogram a std::transform(hist_p4.begin(), // source 1 begin hist_p4.end(), // source 1 end i.begin(), // source 2 begin hist_p4.begin(), // destination begin std::plus&lt;int&gt;() ); // binary operation &#125;); 最终性能比较，能看出TLS能大幅提高性能 Serial: 0.399203Parallel: 2.01466Atomic: 0.500326ETC: 0.0348115combinable: 0.0339478 parallel_reduce 最简单的归并，还是给用tbb封装好的模板，该算法的本质是树形规约 //parallel_reduceusing image_iterator = std::vector&lt;uint8_t&gt;::iterator;t0 = tbb::tick_count::now();vector_t hist_p5 = parallel_reduce ( /*range*/ tbb::blocked_range&lt;image_iterator&gt;&#123;image.begin(), image.end()&#125;, /*identity*/ vector_t(num_bins), // 1st Lambda: Parallel computation on private histograms [](const tbb::blocked_range&lt;image_iterator&gt;&amp; r, vector_t v) &#123; std::for_each(r.begin(), r.end(), [&amp;v](uint8_t i) &#123;v[i]++;&#125;); return v; &#125;, // 2nd Lambda: Parallel reduction of the private histograms [num_bins](vector_t a, const vector_t &amp; b) -&gt; vector_t &#123; for(int i=0; i&lt;num_bins; ++i) a[i] += b[i]; return a;&#125;); 并发容器 在上一节我们遇到了同步问题，处理同步会大幅降低性能，为此我们使用了TLS等方法实现了高效的显式同步，而这一节，我们将介绍TBB的核心，并发（Concurrent） TBB提供了一些高效、线程安全的并发容器，他们大多是使用细粒度的锁或者无锁设计 细粒度锁：指锁定真正需要锁定的地方（其实还是挺低效的），比如一个数组我们只锁我们需要的某一个元素，其他线程如果不访问我这个元素，就能正常并行 无锁：有的线程负责操作，有的线程负责纠错 TBB的并发容器并发性能很好，但串行性能不如STL 顺序表（Sequences） concurrent_vector 队列（Queues） concurrent_queue concurrent_bounded_queue concurrent_priority_queue 无序关联容器（Unordered associative containers） concurrent_hash_map map/multimap set/multiset 有序关联容器（Ordered associative containers） map/multimap set/multiset concurrent_hash_map template &lt;typename Key, typename T, typename HashCompare = tbb_hash_compare&lt;Key&gt;, typename Allocator = tbb_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;class concurrent_hash_map &#123;..&#125; 这是一个字符串-Int的哈希表 //HashCompare必须有hash函数和equal函数struct MyHashCompare&#123; static size_t hash(const std::string&amp; s)&#123; size_t h = 0; for(auto &amp;c : s)&#123; h = (h*17)^c; &#125; return h; &#125; static bool equal(const std::string&amp; x, const std::string&amp; y)&#123; return x == y; &#125;&#125;;//hash maptypedef tbb::concurrent_hash_map&lt;std::string, int, MyHashCompare&gt; StringTable;//一个函数对象，用于记录table内元素数量class Tally&#123;private: StringTable&amp; table;public: Tally(StringTable&amp; table_): table(table_) &#123;&#125; void operator() (const tbb::blocked_range&lt;std::string*&gt; range) const &#123; for(std::string* p = range.begin(); p != range.end(); ++p)&#123; //accessor类似于锁、智能智能，在accessor完成前，其他线程不能lookup这个key StringTable::accessor a; table.insert(a, *p); a-&gt;second += 1; &#125; &#125;&#125;; int main() &#123; StringTable table; tbb::parallel_for( tbb::blocked_range&lt;std::string*&gt;( Data, Data+N, 1000 ), Tally(table) ); for( StringTable::iterator i=table.begin(); i!=table.end(); ++i ) printf(&quot;%s %d\\n&quot;,i-&gt;first.c_str(),i-&gt;second); return 0;&#125; 内存分配 内存分配最重要的是正确，TBB提供了一套可拓展的内存分配 现代C++推荐使用智能指针进行内存管理，不推荐使用malloc和new。TBB完全适配所有版本的C++标准，也推荐使用智能指针进行内存分配 TBB动态内存分配的核心是线程内存池（memory pooling by threads），该内存池可以避免内存分配带来的性能下降，也不苛求“避免cache间不必要的数据移动” TBB还提供了可拓展的缓存对齐，比std::aligned_alloc使用更简单方便。只不过滥用缓存对齐可能会带了巨大的内存浪费 在并行编程中，内存分配的主要问题是：分配器的争用，缓存效果 分配器争用：C++内存分存储在两个位置，堆和栈。传统的非线程分配器只能在单个全局堆中分配和释放内存，这个过程配合锁以实现互斥，很低效 缓存效应：某些操作可能会把缓存中的数据移动到缓存的另一处，这是很无效的行为，要避免 缓存填充（对齐） 用于解决假共享（我们在同步那一节解决了真共享带来的问题） 基于局部性原则，当CPU查询某个数据时： 若cache中没有找到，就会去内存中寻找 找到后会将该数据写入cache（时间局部性，刚刚被引用过的一个内存位置容易再次被引用） 并将其相邻元素也写入cache（空间局部性，一个内存位置被引用，其相邻位置很可能马上被引用） 如上图，CPU访问a时，先去cache去找，如果cache中没有，就会去内存中寻找，找到后将a和相邻的b写入cache的同一行。但问题出现了，如果当前cache的其他行里，已经有b了呢？ 另一个线程也拥有一缓存行，里面存储了b，结果b却被移动到a那一行了，于是这个线程要访问b，又要去内存中找，增加了cache miss。此外多线程中，a那个线程多半是不会用到b的，于是平白做了cache位置的移动。 这个现象被称为假共享（false sharing），a和b并不是共享对象，但是由于他们靠的太近了，以至于在一个缓存行中，其中一个对象的更新，会强制另一个对象更新。 在多线程中，假共享可以通过缓存填充（cache padding）解决。缓存填充，就是在缓存中两个变量中间填充一些没有意义的数据，于是导致这两个变量不会处于同一个缓存行中，于是避免了假共享。 我们还是以统计图片像素为例，我们发现这种方法比直接用原子操作要快一些 struct bin&#123; std::atomic&lt;int&gt; count; //4 bytes uint8_t padding[64 - sizeof(count)]; //60 bytes&#125;;//cache paddingstd::vector&lt;bin, tbb::cache_aligned_allocator&lt;bin&gt;&gt; hist_p6(num_bins);t0 = tbb::tick_count::now();parallel_for(tbb::blocked_range&lt;size_t&gt;&#123;0, image.size()&#125;, [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r) &#123; for(size_t i = r.begin(); i &lt; r.end(); ++i) &#123; hist_p6[image[i]].count++; &#125; &#125; ); 我们可以用C++特性来创建结构体： struct bin&#123; //C++17后，可以用std::hardware_destructive_interference_size替代64 alignas(64) std::atomic&lt;int&gt; count;&#125;; 代理 TBB的TBBmalloc库使用代理方法，可以实现在不同操作系统，不改变代码，只需要配置一些动态库、代理库、环境变量，就可以实现全局替换new、malloc等分配函数，这对跨平台真的很重要 Task调度 Chapter10 资料 Pro TBB API Document 代码仓库","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"},{"name":"并行计算","slug":"并行计算","permalink":"https://reubensun.com/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"}]},{"title":"垃圾回收","slug":"engine/GC","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.446Z","comments":true,"path":"engine/GC/","permalink":"https://reubensun.com/engine/GC/","excerpt":"","text":"垃圾回收 前言 《垃圾回收的算法与实现》读书笔记，其中的代码大多为伪代码 一：概念 GC，Garbage Collection，垃圾回收 功能 找到内存中的垃圾 回收垃圾 为什么需要GC 如果没有GC，程序员需要手动进行内存管理，开发麻烦，容易引发内存泄漏、野指针，而且因此导致的BUG很难被定位，修复麻烦 如果有GC，就可以避免这些问题 GC的种类 保守式GC：不能识别指针和非指针时，一律视为非指针 准确式GC GC的算法 标记清除法：标记活动对象，其他的都回收 引用计数法：回收引用值为0的对象 GC复制法：复制活动对象，其他的都回收 GC的选取 最大暂停时间短：游戏 整体处理时间短：音频编码 对象 这里的对象并不是OOP里的Object，而是被应用程序使用的数据的集合，对象由头和域构成 头（header）：包含对象的大小和种类 域（field）：参考OOP里的成员 对象分为活动对象和非活动对象，GC会保留活动对象，销毁非活动对象 mutator 可以简单理解为应用程序，在程序运行过程中，会分配/调用/改变对象（只能操作活动对象），伴随着mutator运行，会产生垃圾 GC算法的评估标准 吞吐量（throughput）：单位时间的处理能力 最大暂停时间（在进行GC时，mutator会被暂停） 堆使用效率 访问局部性 二：标记清除法 学这一节之前想想操作系统里文件系统 该算法分为两步 标记阶段：将所有活动对象做上标记 清除阶段：将所有没被标记的对象回收 标记阶段 通过根，找到直接引用的对象，标记 递归标记所有能访问到的对象（常用深搜，因为内存使用量更少） void mark(obj)&#123; if(!obj.mark) obj.mark = true; for(child: obj.children) mark(*child);&#125; 清除阶段 遍历堆，回收所有没有被标记的对象，并将其放入空闲链表，以备分配 分配策略 在创建新对象obj时，遍历空闲链表，寻找合适的块，这里使用First-fit算法（因为快） First-fit：找到第一个能放下obj的块 Best-fit：找到最小的能放下obj的块 Worst-fit：找到最大的能放下obj的块 合并策略 分配和回收会导致大量小的分块，于是需要合并，在这里直接遍历堆，将连续的空闲块合并 评价 优点 实现简单 与保守式GC兼容（因为对象不会被移动） 缺点 碎片化，导致空间浪费，访问性能降低 不支持写时复制（比如UNIX中的fork()） 优化方案 分级空闲链表 使用多个空闲链表，分别只连接不同大小的分块，分配时先找所对应的区间，可以提高性能 BiBOP（Big Bag Of Pages） 将大小相近的对象整理成固定大小的块进行管理 碎片化的原因之一是杂乱散布的大小各异的对象，如果将堆固定分割，就可以减缓碎片化 位图标记 不直接堆对象进行标记，而是记录对象的标志位，存储在一个表格中 与写时复制技术兼容（因为不会修改对象本身，可以复用） 清除标志位更高效（只需要把表中要清除的对象的标志位改成一个特殊值） 延迟标记清除法 分配时，先调用清除，如果能清出足够的空间来分配，则直接分配，否则进行普通的标记操作 清除时，同样是First-fit遍历堆，但遍历的起点是上次开始的地点的右侧 延迟的内核是不主动清除，而是等到要分配时再清除 三：引用计数法 学这一节前，想想智能指针 引用计数法中，对象会记录自己被引用次数，主要分为两个阶段 创建新对象：分配内存，将对象引用次数设为1 更新指针：先增后减计数器值，若引用次数为0则回收 //更新指针ptr，让其指向objvoid update_ptr(ptr, obj)&#123; inc_ref_cnt(obj); //obj要被ptr引用了，所以obj计数值++ dec_ref_cnt(*ptr); //ptr之前引用的东西不再被引用 *ptr = obj;&#125;void dec_ref_cnt(obj)&#123; obj.ref_cnt--; //obj不再被引用，所以计数值-- if(obj.ref_cnt == 0)&#123; //如果obj没人用了，obj就要被清除 for(child: obj.children)&#123; //obj被清除了，那obj引用的对象，被引用次数要-- dec_ref_cnt(*child); &#125; reclaim(obj); //执行回收 &#125;&#125; 评价 优点： 对象变成垃圾时立刻被回收（延迟标记清除算法要等到分块用尽后才开始回收垃圾） 最大暂停时间短（只有在更新指针的时候才会打断mutator） 减少延根指针遍历所有子节点的次数（尤其在分布式系统中，效果显著） 缺点 频繁进行计数值的操作 计数器本身空间比较大（32位系统的计数器就要32位大小） 循环引用无法回收 如果两个物体互相引用，并不和其他对象有联系，于是他们成为了一座“孤岛”，成为了事实意义上的垃圾，但是却无法被回收（因为只要被引用，就不算垃圾） 优化方案 延迟引用计数法 解决频繁操作 使用ZCT表（Zero Count Table），记录所有执行dec_ref_cnt后计数值变成0的对象（也就是说计数值变成0，不会立刻被视为垃圾回收），当ZCT表满了以后，开始回收表中的对象 优点：延迟了根引用的计数（只有要回收时才会一起操作），降低了计数值的操作频率 缺点 不再能即刻回收垃圾（你可以理解为以前有垃圾就仍，现在要先堆一波垃圾再扔） 最大暂停时间延长（scan_zct()要访问整个ZCT，这个过程muator是被中断的） void dec_ref_cnt(obj)&#123; obj.ref_cnt--; if(obj.ref_cnt == 0)&#123; //计数值变为0，可能会变成垃圾 if(is_full($zct))&#123; scan_zct(); //如果zct表满了，就扫描zct，并回收 &#125; push($zct, obj); //将obj放入zct表 &#125;&#125;void scane_zct()&#123; fot(r: $root)&#123; (*r).ref_cnt++; //根直接引用的对象的计数器++，直接引用计数时，根会极频繁改动 &#125; for(obj: $zct)&#123; if(obj.ref_cnt == 0)&#123; remove($zct, obj); delete(obj); &#125; &#125; fot(r: $root)&#123; (*r).ref_cnt--; &#125;&#125; Sticky引用计数法 解决空间浪费 32位电脑意味着可以有$2^{32}$个对象，这些对象可能都会引用obj，所以obj的计数位应当可以记录被引用$2^{32}$次，所以计数位要有32位 如果计数位太少，一些比较大的对象就无法正常表示（直接做饱和运算，汽车速度超过速度计的最大值会停在最大值处），一旦出现这种情况，我们可以 什么都不做 这会导致如果一个物体被引用的次数特别多，超出了目前表示的范围，即使他变成了垃圾也无法回收 但是，事实上绝大多数对象计数值一直在0和1间变化（生成后立刻回收），所以很少出现溢出 而且一个对象被频繁引用，说明他十分重要，十分重要的东西被回收的概率并不大 很多时候不需要保证内存永不泄露，只需要保证一段时间内不泄露就行，很多软件，用户不会一直开着的 结合使用标记清除算法 什么都不做，可能会导致内存耗尽，如果耗尽，那就用标记清除法清一次（相当于垃圾太多了，管不来了，就干脆来一次大扫除） //标记void mark()&#123; for(r: $roots)&#123; push(*r, $stack); //将所有根直接引用对象入栈 &#125; while(!$stack.empty())&#123; obj = pop($stack); obj.ref_cnt++; if(obj.ref_cnt == 1)&#123; //这说明obj只进栈一次 for(child: obj.children)&#123; push(*child, $stack); &#125; &#125; &#125;&#125;//清除void sweep()&#123; index = $heap_top; while(index &lt; $heap_end)&#123; //遍历整个堆 if(index.ref_cnt == 0)&#123; reclaim(index); //回收计数值为0的对象 &#125; index += index.size; &#125;&#125; 一位引用计数法 是Sticky的极端，计数位只有一位（两个tag，一个MULTIPLE，一个UNIQUE），而且将计数位放在指针上，而非放在对象上 void copy_ptr(dest_ptr, src_ptr)&#123; delete_ptr(dest_ptr); *dest_ptr = *src_ptr; set_tag(dest_ptr, MULTIPLE); if(src_ptr.tag == UNIQUE)&#123; set_tag(src_ptr, MULTIPLE); &#125;&#125;void delete_ptr(ptr)&#123; if(ptr.tag == UNIQUE) reclaim(*ptr); //如果对象以前只被引用一次，那么这次就要被回收&#125; 优点 cache命中率高 缺点 同Sticky，而且更严重 部分标记清除法 解决循环引用 只对可能会有循环引用的对象使用标记清除法，其他对象使用引用计数法 每个对象会有两个状态位（于是就有四个状态），分别为 BLACK：绝对不是垃圾的对象（初始值） WHILE：绝对是垃圾的对象 GRAY：搜索完毕的对象 HATCH：可能是循环垃圾的对象 void dec_ref_cnt(obj)&#123; obj.ref_cnt--; if(obj.ref_cnt == 0)&#123; delete(obj); &#125; else if(obj.color != HATCH)&#123; obj.color = HATCH; queue.push(obj); &#125;&#125; 对放入队列的对象进行标记清除算法 Object new_obj(size)&#123; obj = pickup_chunk(size); //分配内存 if(obj != null)&#123; //如果分配成功 obj.color = BLACK; obj.ref_cnt = 1; return obj; &#125; else if(!queue.empty())&#123; //说明现在空间不足，要回收垃圾，先看是否存在HATCH物体 scan_hatch_queue(); return new_obj(size); //回收queue内后重新尝试分配 &#125; else&#123; allocation_fall(); &#125;&#125;void scan_hatch_queue()&#123; //循环扫描队列，直至队列为空 obj = queue.pop(); if(obj.color == HATCH)&#123; paint_gray(obj); //把obj和其孩子变为GRAY，孩子们引用值-- scan_gray(obj); //引用值&gt;0涂黑，等于0涂白 collect_while(obj); &#125; else if(!queue.empty())&#123; scane_hatch_queue(); &#125;&#125;void paint_gray(obj)&#123; if(obj.color == (BLACK | HATCH))&#123; obj.color = GRAY; for(child: obj.children)&#123; (*child).ref_cnt--; paint_gray(*child); &#125; &#125;&#125;void scan_gray(obj)&#123; if(obj.color == GRAY)&#123; if(obj.ref_cnt &gt; 0)&#123; paint_black(obj); &#125; else&#123; obj.color = WHITE; for(child: children(obj))&#123; scan_gray(*child); &#125; &#125; &#125;&#125;void paint_black(obj)&#123; obj.color = BLACK; for(child : children(obj))&#123; (*child).ref_cnt++ if((*child).color != BLACK)&#123; paint_black(*child) &#125; &#125; &#125;void collect_while()&#123; if(obj.color == WHILE)&#123; obj.color = BLACK; for(child: obj.children)&#123; collect_while(*child); &#125; reclaim(obj); &#125;&#125; 优点 可以回收循环引用 缺点 一个对象要被查找三次，导致最大暂停时间+++ 四：GC复制法 想一下渲染中的双缓冲 先把整个空间分为等大的两部分，From和To，我们用From空间分配活动对象 GC时，把所有活动对象（递归）复制到其他空间（To空间），然后把原空间（From空间）所有对象回收，然后把空间互换 评价 优点 吞吐量大 分配速度快（Frist-fit） 不会发生碎片化（每次回收时，都会把所有对象重新排在From空间的开头，这个操作被称为压缩） 兼容缓存 缺点 堆效率低（因为二等分后，只能利用其中一半） 不兼容保守式GC 复制对象时要递归复制，会消耗栈，可能导致栈溢出 优化方案 Cheney GC复制法 从递归复制改为迭代复制（基于队列的广度优先搜索） 下图搜索顺序：A BC DEFG HIJKLMNO ![Cheney GC](/images/Cheney GC.png) 优点 从递归变成迭代，降低栈压力 缺点 不利于缓存（在上图，我们假设每个页最多存放三个块，我们发现有引用关系的对象很可能不在同一个块中） 近似深度优先搜索方法 在页间做深度优先搜索，在页内做广度优先搜索 下图搜索顺序：ABC DHI EJK FLM GNO 多空间复制法 把空间分成十份，一个From，一个To，八个标记清除法 五：标记压缩法 结合了标记清除法的标记+GC复制法的压缩 Lisp2算法 类比原地删除数组中某个元素 标记方法和标记清除法一样，标记后遍历堆，将所有活动对象压缩到左侧 优点 比GC复制法堆效率高，比标记压缩法碎片少 缺点 三次遍历堆，效率过低 Two-Finger算法 这个算法优缺点很明显，所以先说优缺点，再谈实现 优点 只需要两次遍历堆 不需要额外的forward指针（Lisp2的对号） 缺点 对象大小必须一致（可以与BiBOP结合使用） 压缩时破坏排序（一般有引用关系的对象会放在一起），于是不适合缓存 在Lisp2算法中，可以说几乎每一个活动对象都需要移动，一般来说越靠近左边，移动的概率、距离越小，而越后面则越大（可以类比幽灵堵车） 我们能不能固定前面的对象，只移动后面的对象，从而实现压缩呢？（如果后面的对象和前面的对象大小一致，完全可以） 表格算法 算法分为三部：移动对象群，构建间隙表格，更新指针 移动对象群（Lisp2一次移动一个对象，这个一次移动所有相邻对象） 构建间隙表格（设一个小格子尺寸为50） a到b：live在B开头，scan在D开头，于是将B的初始位置和B向左移动的距离$(100,100)$写到D处 b到c： 先把间隙表格向后移动，移到FG之后，于是H处写入$(100,100)$ FG的初始位置和向左移动的距离为$(550,300)$，写入H之后（后是左边的G） 更新指针 ImmixGC算法 六：保守式GC 把疑似指针的一律视为指针 不明确的根 常见的根有 寄存器 调用栈 全局变量空间 在c++等语言里，int这种内置变量（非指针）和void*指针都存放在栈里，GC无法区分两者的区别，保守式GC就干脆不区分两者 存储着不确定对象的根，称为不明确的根，而基于这些根的GC算法，被称为保守式GC（ambiguous GC） 检查内容 是否位对齐（32位CPU，指针是4的倍数，64位CPU，指针是8的倍数） 不对齐的一定是非指针 是否指向堆内 对象放在堆中，所以指针一定指向堆 是否指向对象开头 我们发现，有的时候我们会遇到一些格式与指针一致的非指针，我们称之为貌似指针的非指针（false pointer） 在标记清除算法中，遇到这种貌似指针的非指针，会胡乱找到一个对象，我们不知道这个对象是活动对象还是非活动对象，所以一律视为活动对象，进行标记 注意：保守GC是只有当判断不出来到底是不是指针时才将其视为指针，而不是把所有对象都视为指针（迫不得已，凑合凑合用） 评价 优点 开发容易，程序员不需要意识到GC的存在 缺点 识别指针和非指针需要付出代价（检查内容） 将false pointer指向的错误对象视为活动对象，这些东西不会被用到，却进栈了 支持保守GC的算法不多 准确式GC 正确的根（exact roots）可以精确地识别指针和非指针 基于正确的根的GC被称为准确式GC 构建正确的根的方法：打标签 32位CPU指针的值是4的倍数，那么其低2位一定是0 我们可以将所有非指针左移1位，然后将其低1位置为1 //打标签int addTag(int a)&#123; a = a &lt;&lt; 1; //小心溢出，如果会溢出，就用一个更大的数据结构 a = a|1; return a;&#125;//去标签（在使用时需要恢复成正常数值），而且使用完后还有再次打标签int getValue(int a)&#123; a = a &gt;&gt; 1; return a;&#125; 除了打标签，还可以专门构建一个只存放指针的根，比如一些使用虚拟机（VM）的语言 评价 优点 不需要判断是否为指针，没有判断带来的性能代价 堆中只会存在指针，可以适用于一些移动对象的GC算法 缺点 构建准确的根需要性能成本 语言使用时更麻烦 间接引用 为什么保守式GC不能移动对象？因为一个false pointer可能是一个非指针，移动会导致问题 句柄 如图，即使我们移动了堆中的对象，也却不会改变根内的内容 优点： 可以使用复制算法 缺点： 访问一个对象需要访问两次内存 MostlyCopyingGC 保守式GC复制算法 黑名单 有的false pointer即使是非指针，错把他当指针用也可以找到一个对象（尽管这个过程是未定义的），如果这个非指针可以做到这个事，拿我们就把这个非指针指向的地址存放到黑名单中 黑名单中存放的是地址，如果在这些地址中分配空间，可能会导致未定义事件 所以在这些地址上分配对象时要十分小心，比如只能分配小对象、只能分配没有子对象的小对象，因为这些对象比较小，即使变成垃圾，被错误识别了，危害也比较小 七：分代垃圾回收 引入了年龄这一概念，优先回收那些容易成为垃圾的对象 年龄 我们在引用计数法中提到过，绝大多数的对象生成后立刻会被回收，而被引用次数多多对象很难变成垃圾 于是我们引入年龄这一概念，初始为0，每经历一次GC算法，如果没有被回收，则年龄+1 我们发现年龄越大，说明对象越重要，越不容易被回收，于是年龄越大，参与回收的频率就越低 评价 优点 提高吞吐量 缺点 很多对象出生立刻回收只是一个经验，不适合所有程序，一旦某程序对象比较“长寿”，会起反作用 八：增量式垃圾回收 想一想单核CPU并行的本质，就是将线程切分，来回切换 通过逐步推进垃圾回收来控制最大暂停时间，不一次执行完GC，而是执行一会mutator，执行一会GC 三色标记法 评价 优点 降低最大暂停时间 缺点 降低了吞吐量 九：RC Immix算法 这是一个2013年的算法，听懂掌声 将合并型引用计数法和Immix组合到一起，改善了引用计数法的吞吐量","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"GC","slug":"GC","permalink":"https://reubensun.com/tags/GC/"}]},{"title":"大象无形UE笔记","slug":"engine/大象无形UE笔记","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.445Z","comments":true,"path":"engine/大象无形UE笔记/","permalink":"https://reubensun.com/engine/%E5%A4%A7%E8%B1%A1%E6%97%A0%E5%BD%A2UE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"UE学习笔记 基类 UObject 一切对象的基类。UE为UObject类提供了 垃圾回收GC 被UProperty标记的变量会自动进行生命周期管理 非UObject可以使用C++标准推荐的智能指针 引用计数 反射 序列化 资源的存储与加载 自动检测默认变量的更改 自动变量初始化 与Editor的交互 运行时类型识别 UE禁用了C++的dynamic_cast，你可以使用Cast&lt;&gt;替代 网络复制 反射 反射分为静态反射和动态反射，C++没有该机制（尽管C++可以在编译时进行类型推导，但远不如Java那种Class对象的机制好用），于是UE自己做了一套 功能 运行时知道类、函数的所有相关信息（属性表，函数表），进而实现可视化编程（蓝图，面板） 通过函数名/类名+连续数据块访问对应函数/类 反射说白了就是将类、函数的信息（用哈希表）存储，运行时根据函数名、类名（key）查找信息，UE的反射是通过UBT和UHT实现的 通过宏标记C++代码 UHT生成.generated.h和.generated.cpp文件 引擎初始化时注册反射信息 Actor 一切实体的基类。能够被挂载组件（U） Component 基类：UActorComponent Component是一种属性+行为的集合 通讯 Actor之间要进行通讯，Unity可以通过获得GO引用、获得GO的组件的方式进行通讯 UE Actor的通讯方式有 获取引用 Cast 接口 事件 Pawn 英语意思为棋子，指可以被操控的兵卒（可以被玩家操控，也可以被AI操控） Charactor 继承自Pawn，是一个更复杂的可操控角色，该角色的特点是有一种特殊的组件，Charactor Movement Controller 控制器，负责控制Pawn、Charactor的行为 命名原则 通过类的前缀来区分类的类型 前缀 意义 F 纯C++类，通常为功能类 U 继承自UObject，但不继承自Actor A 继承自Actor S Slate控件 H HitResult相关类 T 模版类 E 枚举类 对象 创建对象 F类，使用new U类，使用NewObject A类，使用SpawnActor new FClass();NewObject&lt;UxxxClass&gt;();GetWorld()-&gt;SpawnActor&lt;AxxxClass&gt;(); UObject 生命周期 创建 内存分配，返回一个分配好尺寸但没有初始化的指针（你steam下游戏也是先清出一片区域，再正式下载） 对象构建 创建FObjectInitializer 将FObjectInitializer作为参数传递给函数指针ClassConstructor，得到对象 反序列化 获取类信息GetClass 判断类信息是否载入，若没有载入则进行预载 载入名字、Outer、类信息（类信息保存在ObjClass对象中，感觉和Java的类对象机制很接近） 载入脚本成员变量信息 反序列化的规则： 只反序列化UPROPERTY标记，且不等于默认值的数据 先创建出对象，再反序列化（还原数据） 对象具有所属关系 若一个对象所有信息和原始对象相同，尽管他们在内存的位置不同（指针值不同），该对象就是原始对象 释放消亡 UObject无法手动释放，但是可以被请求，将其标记后等待引擎将其释放 GC分为两步，析构、回收 蓝图 UPROPERTY：注册成员变量到蓝图 UFUNCTION：注册函数到蓝图 引擎基础功能 正则表达式 #include &quot;Regex.h&quot;...FString TextStr(&quot;This is a string&quot;);FRegexPattern TestPattern(TEXT(&quot;C.+H&quot;));FRegexMatcher TestMatcher(TestPattern, TextStr);if(TestMatcher.FindNext())&#123; UE_LOG(MyLog, Warning, TEXT(&quot;找到匹配内容 %d -%d&quot;), TestMatcher.GetMatchBeginning(), TestMatcher.GetMatchEnding());&#125; 路径 //获取xxx目录路径FString FPaths::xxxDir(); //判断文件是否存在bool FPaths::FileExists(const FString&amp; InPath); //相对路径转化为绝对路径FString ConvertRelativePathToFull(const FString&amp; BasePath, FString&amp;&amp; InPath)； XML &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;note name=&quot;Ami&quot; age=&quot;100&quot;&gt; &lt;from&gt;John&lt;/from&gt; &lt;list&gt; &lt;line&gt;Hello&lt;/line&gt; &lt;line&gt;world&lt;/line&gt; &lt;/list&gt;&lt;/note&gt; 使用FXmlFile或者FastXML操作xml文件 FString xmlFilePath = TEXT(&quot;xxx/Test.xml&quot;);FXmlFile* xml = new FXmlFile();xml-&gt;LoadFile(xmlFilePath);FXmlNode* RootNode = xml-&gt;GetRootNode();FString from_content = RootNode-&gt;FindChildNode(&quot;from&quot;)-&gt;GetContent();FString note_name = RootNode-&gt;GetAttribute(&quot;name&quot;);TArray&lt;FXmlNode*&gt; list_node = RootNode-&gt;FindChildNode(&quot;list&quot;)-&gt;GetChildrenNodes(); JSON FString JsonStr = &quot;[&#123;\\&quot;author\\&quot;: \\&quot;Tim\\&quot;&#125;, &#123;\\&quot;age\\&quot;: \\&quot;100\\&quot;&#125;]&quot;;TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParsed;TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::Create(JsonStr);bool BFlag = FJsonSerializer::Deserialize(JsonReader, JsonParsed);&#123; FString FStringAutor = JsonParsed[0]-&gt;AsObject()-&gt;GetStringField(&quot;autor&quot;);&#125; 文件 FPlatformFileManager::Get()-&gt;GetPlatformFile(); GConfig //写配置GConfig-&gt;SetString(TEXT(&quot;Section&quot;), TEXT(&quot;Key&quot;), TEXT(&quot;Value&quot;), FPaths::xxxDir()/&quot;Config.ini&quot;);//读配置FString Result;GConfig-&gt;GetString(TEXT(&quot;Section&quot;), TEXT(&quot;Key&quot;), Result, FPaths::xxxDir()/&quot;Config.ini&quot;); UE_LOG UE_LOG(log分类，log类型，log内容)； 字符串 能否修改 大小写敏感 语意 FName 无法修改 不敏感 名字，在整个字符串表只出现一次 FText 无法修改 敏感 被显示的字符串 FString 能够修改 敏感 普通字符串 图片 ../../imagesrWrapper 模块 模块 模块就像Unity的Package，用于整理文件结构，便于编译 一个模块包含 Public文件夹 .h文件 Private文件夹 .cpp文件 模块名.build.cs文件（继承自ModuleRules类） UBT Unreal Build Tool.cs中有Main函数，主要做三个功能 收集信息：环境变量、目录信息等 确定生成的目标类型 生成构建 UHT Unreal Header Tool，一个基于引擎代码，但不需要引擎完全启动，编译后得到一个.exe文件的程序 引擎核心 UE Begin Play 内存分配 提供了多套内存分配器，其中包含TBB（TBB的内存分配一大特点就是可以通过代理的方式全局替换new、malloc等操作符），TBB见《高性能C+++》笔记，那边有详细介绍 TBB内存分配主要包括 LTS，线程内存池，每个线程会独立拥有一个局部的内存池，互不影响，但最后需要归约 缓存对齐，通过在变量间填充大量无效信息，使得不同变量处于不同缓存行中，于是避免了假共享问题 引擎初始化 PreInit 接收cmd命令，判断启动模式 初始化游戏主线程（将当前线程当作主线程） 初始化随机数 初始化TaskGraph系统，设置线程数量，启动线程池 调用LoadCoreModules，启动CoreUObject模块 启动引擎、渲染、动画蓝图、Slate、贴图压缩、地形模块 Init 各个模块初始化，并执行所有PostEngineInit函数 进入主循环 主循环 UE是一个多线程引擎，将游戏逻辑、渲染、声音、IO等系统分离 主线程是游戏逻辑线程，内含一个while循环，循环内有一个Trick，可以类比Unity的Update 渲染线程数游戏逻辑线程的从属，接收来自主线程的命令，进行渲染绘制。渲染线程比逻辑线程慢一帧 并发并行 线程 并行 并发 Task Graph UE最强大的多线程框架，将任务抽象为Task UE内部使用了TBB，感觉这部分内容和TBB基本一致 详情见FBaseGraphTask、FTaskThreadBase FRunnableThread+FRunnable 详情见QueuedThreadPoolWrapper.h，并不是很好用 渲染 渲染线程 UE的游戏线程和渲染线程分离（事实上现在基本所有引擎都这样），渲染线程是游戏线程的“附庸” 在引擎Init时，会调用StartRenderingThread函数，启动渲染线程 该函数主要做： 创建渲染线程 从TaskGraph中取任务 注册渲染线程 注册Trick 运行 渲染线程的主要执行内容在RenderingThreadMain中，游戏线程可以通过EQUEUE_Render_COMMAND等宏命令向渲染线程的TaskMap中添加渲染任务，渲染线程提取这些命令后将其添加到RHICommandList中，最后传递到GPU中 RHI RHI（Render Hardware Interface），对图形库的一种封装，以供上层使用 UE5中含义 FRenderResource 渲染线程中的资源，如贴图、顶点buffer、顶点id FRHIResource GPU侧的资源，如Texture2D、3D、Cube DynamicRHI 所有图形API适配器的基类 RHI RHIContext RHI命令上下文 RHICommandList RHI指令队列 FRHICommandListExecutor 将RHI指令翻译为图形API 多线程 DX11 DX11尝试从硬件层面解决多线程渲染，提供了两种设备上下文：即时上下文（Immediate Context）和延迟上下文（Deferred Context） 延迟上下文多线程并行，最后将生成的CommandList归约到即时上下文中，由即时上下文Execute 对于某些支持硬件级加速的驱动，延迟上下文可以将CommandList也直接提交给图形驱动 DX11的多线程，感觉就是一种简单的异步，仅仅是加速了指令录制，减少了等待 DX12 取消了DX11的渲染上下文，不再使用DrawCall，而是直接使用CommandList来调用图形驱动 DX12渲染线程并行进行指令录制，生成一些命令列表（CommandList） 然后将这些命令列表提交给命令队列（CommandQueue）中 命令队列根据指令类型，将指令放入不同的GPU引擎中 命令队列有三种：复制队列（Copy Queue）、计算队列（Compute Queue）、3D队列 GPU引擎有三种：复制引擎、计算引擎、3D引擎 命令队列和GPU引擎都可以并行执行 渲染管线 物理 UE5使用Chaos替代PhysX作为新的物理引擎 Chaos PhysX 基于位置（PBD） 基于速度 支持大世界坐标（LWC） 不支持 支持网络同步 不支持 异步 UE5可以启用异步物理模拟，物理线程会作为单独的线程运行（类似渲染线程） 由于是独立线程，物理模拟可以以固定的间隔运行，既可以提高精确度，也方便C/S网络同步 但开启异步后物理线程无法即时获取游戏线程的输入，有可能影响游戏逻辑 功能 布料 破坏 载具 场 PBD 论文 大世界 World partition","categories":[{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"}],"tags":[{"name":"Unreal","slug":"Unreal","permalink":"https://reubensun.com/tags/Unreal/"}]},{"title":"Maya插件开发","slug":"dcc/maya插件","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.447Z","comments":true,"path":"dcc/maya插件/","permalink":"https://reubensun.com/dcc/maya%E6%8F%92%E4%BB%B6/","excerpt":"","text":"Maya maya，老东西，行业标准，真难用（不是） 腾讯巨神级TA、碧血红天的blog、Pycharm环境搭建 创建一个python工具 Python插件和Unity Editor那种工具不太一样，这个其实本质就是一个嵌入式的脚本，通过命令调用maya指令，就算有UI也是现绘制的，也不需要什么项目结构，就一个py文件 创建一个python文件 import maya.cmds as cmdsdef createWindow(): if cmds.window(&#x27;mywindow&#x27;, exists=True): cmds.deleteUI(&#x27;mywindow&#x27;) windowvar = cmds.window(&#x27;mywindow&#x27;) cmds.columnLayout() checkButton = cmds.button(l=&#x27;Test&#x27;, command=&#x27;testFunc()&#x27;) cmds.showWindow(&#x27;mywindow&#x27;)def testFunc(): print &quot;Hello&quot;createWindow() 添加到工具栏 当你的代码完成后，可以将其固定到工具架上 怎么写 这应该是很多人写maya插件最大的疑惑，我的建议是先学美术，开着脚本编辑器，按照美术流程走一遍，你会发现你每一次操作，脚本编辑器都会输出一个指令，这个应该能让你深受启发 如果你的脚本编辑器没有显示，那么在脚本编辑器中设置显示二者 常用API import maya.cmds as cmds #这是一个将MEL指令用python封装的库，适合面向过程编程import maya.OpenMaya as om #拥有cmd没有的功能，运行效率更高 删除：cmds.delete(p) 选中：p = cmds.ls('Name') 创建 Cube：pCube = cmds.polyCube(w=10, h=10, d=10, name='myCube') 移动（到指定位置） 平移：cmds.move(0, 10, 0, pCube) 缩放：cmds.scale(2, 2, 2, pCube) 旋转：cmds.rotate(45, 45, 0, pCube) 选择（得到的是对象数组） 当前选择：list = cmds.ls(selection=True) 读参数 位置：cmds.getAttr('%s.translate ' % (p)) 位置（某一维）：y = cmds.getAttr('%s.translateY ' % (p)) 写参数 位置（某一维）：cmds.setAttr('%s.translateX' % (p), 10) 想知道maya物体的参数，可以通过表达式编辑器查看（窗口-动画编辑器-表达式编辑器） 得到顶点数据 def printVertexPos(): selectObjectList = cmds.ls(selection=True) VertexArray = cmds.ls(&#x27;&#123;&#125;.vtx[:]&#x27;.format(selectObjectList[0]), fl = True) for v in VertexArray: print cmds.xform(v, query = True, translation = True, worldSpace = True) 工具实例 平滑法线 平滑法线 模型展2UV #创建一个名称为sph的多边形def createFunc(): cmds.polySphere(n=&#x27;sph&#x27;)#删除除了map1以外所有的uvmapdef deleteUVs(): au = cmds.polyUVSet(query=True, allUVSets=True) for j in range(len(au)-1): cmds.polyUVSet(delete=True, uvSet=au[j+1])#自动展选中物体的2UV，并命名为map2def pickUV2(): list = cmds.ls(dag=1, selection=True) au = cmds.polyUVSet(query=True, allUVSets=True) if(len(au) == 1): cmds.polyAutoProjection(list[1] + &#x27;.f[*]&#x27;, cm = 1, uvs= &#x27;map2&#x27;) else: print &quot;map2 has been exited&quot; 动画clip #输出选中的动画片段的开始帧和结束帧def printClip(): list = cmds.ls(selection=True) for p in list: start = cmds.getAttr(&#x27;%s.clipStart &#x27; % (p)) end = cmds.getAttr(&#x27;%s.clipStart &#x27; % (p)) + cmds.getAttr(&#x27;%s.clipDuration &#x27; % (p)) print start print end 打开文件 def openFile(): path = &#x27;C:/Users/Admin/Desktop/多边形.fbx&#x27; cmds.file(path, i=True) 开关UV编辑器 def openUVPanel(): if cmds.window(&#x27;polyTexturePlacementPanel1Window&#x27;, ex=1): cmds.deleteUI(&#x27;polyTexturePlacementPanel1Window&#x27;) mel.eval(&#x27;toggleUVToolkit;&#x27;) else: mel.eval(&#x27;texturePanelShow;&#x27;)","categories":[{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"}]},{"title":"DX12龙书","slug":"graphics/DX12笔记","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.444Z","comments":true,"path":"graphics/DX12笔记/","permalink":"https://reubensun.com/graphics/DX12%E7%AC%94%E8%AE%B0/","excerpt":"","text":"DX12 环境搭建 Windows 10/11系统 安装PIX 安装Visual Studio 2019 Windows应用程序 Windows应用程序使用事件驱动（详情可以去看WPF） Windows应用程序的入口点是WinMain函数 int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow)&#123; LearnDX::D3D12HelloWindow sample(1280, 720, L&quot;D3D12 Hello Window&quot;); return LearnDX::Win32Application::Run(&amp;sample, hInstance, nCmdShow);&#125; 主程序会创建一个窗口，并进入消息循环，检索处理操作系统发来的消息，并对其进行相应 message 发送时机 WM_CHAR 键盘输入一个字符 WM_COMMAND 使用菜单栏、控件 WM_CREATE 创建一个窗口 WM_DESTROY 一个窗口被摧毁 WM_LBUTTONDOWN 按下鼠标左键 WM_LBUTTONUP 鼠标左键被释放 WM_MOUSEMOVE 鼠标指针被移动 WM_PAINT 一个窗口需要重新粉刷 WM_QUIT 应用程序即将终止，WinMain返回 WM_SIZE 调整窗口大小 当接收到WM_QUIT消息时（比如用户关闭窗口），会退出消息循环，应用程序即将结束，WinMain函数返回 COM 为什么要使用COM 我们在编写C++时，经常会生成dll文件，这是一种动态库，保存了许多通用的数据和函数，运行时软件可以通过函数指针的方式导出dll的函数，从而实现运行时动态链接 当我们在同一操作系统、同一编译器环境写构建C++项目，可以复用这个dll文件。然而当你使用其他语言时，如果这个语言读不懂dll的二进制，不知道如何与之沟通，这个语言就不能使用这个dll文件。 或者另一种情况，当你更新了这个dll文件，而应用还在用老办法调用dll，很有可能也会出错 为了解决上述问题，微软提出了组件对象模型（Component Object Model，COM），一套软件组件的二进制接口，可以实现跨编程语言的进程间通信、创建动态对象，在二进制层面打破了代码依赖 COM的优点 软件（apps）使用抽象接口访问服务器（servers，这里指dll文件），可以使用接口指针调用COM类的成员函数 软件无需知道COM的内部实现，COM对象的创建与释放由COM自行完成 COM可能同时被多个软件使用，使用引用计数法进行GC 每个COM类都有独一无二的ID，因此内存中可以同时加载多个拥有相同接口的COM类，软件可以自行选择使用哪一个COM类 COM规定了一种特殊的layout，可以被任何支持COM的语言所解析（但可惜的是，支持COM的语言并不多，因此你还是只能用C++去写DX） COM实际上是由指针和函数表组成（就像C++的虚函数） COM的实现 COM中所有接口都继承于IUnknown，该接口提供了三个操作 AddRef：增加引用计数的次数，每次拷贝接口指针时都会执行 Release：减少引用计数的次数，当次数为0，释放对象 QueryInterface：返回指向该对象的指针 不过显式控制COM对象的引用过于困难，C++推荐使用智能指针 DXGI DirectX Graphics Infrastructure (DXGI)，负责管理一些low-level的任务，比如如何将frame呈现在显示器上，gamma矫正，屏幕刷新，交换链等 依赖 VS添加DX12依赖 打开VS--项目--属性--配置属性--链接器--输入--附加依赖项 cmake添加依赖 cmake_minimum_required(VERSION 3.20)project(DXEngine)set(CMAKE_CXX_STANDARD 17)file(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp src/*.h)add_executable(DXEngine WIN32 $&#123;srcs&#125;)target_include_directories(DXEngine PUBLIC include)# 比较重要的是d3d12.lib dxgi.libtarget_link_libraries(DXEngine PRIVATE d3d12.lib dxgi.lib dxguid.lib uuid.lib kernel32.lib user32.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib runtimeobject.lib ) 批注 VS提供了一套批注系统，SAL（Source code annotation language） 字符串 Windows的字符串是一大噩梦 代码的字符编码主要有两种，ASCII和UNICODE，Windows内部使用了utf-16存储字符串，并支持两种API，用以支持ASCII和UNICODE，他们分布以A和W结尾 为了支持两种API，于是推出了一种新的字符类型宽字符：wchat_t，微软将其重命名为WCHAR 宽字符在使用时要在前面加L，比如L'a' 微软又将字符串进行重命名，提出了窄字符串STR和宽字符串WSTR，并给出了他们的指针LPSTR和LPWSTR LPSTR = const char*LPWSTR = const wchar_t* 如果你用VS开发，可以设置整个项目使用UNICODE，但我不建议这样做 强烈推荐当你要使用字符串函数时，明确使用后缀是A还是W，并且要注意你WindowProc的类型（是使用DefWindowProcW还是DefWindowProcA） d3dx12.h 这是一个.h文件，内含许多DX开发常用函数，将该文件复制到项目中 这个文件中使用了大量Windows SDK，因此你最好用VS2019的Toolchains（Clion的用户使用内置的MinGW可能会报一堆错） 至于为什么要求是VS2019，是因为这个文件与Windows10 SDK版本强相关，VS2019的SDK直接就是对应版本，2017需要手动下载，2015直接没法用 详情 创建第一个窗体 这个窗体啥也没有，就输出一个蓝色屏幕，下面是创建这个窗体的过程 WindowProc是一个回调函数，用于处理传给窗口的消息 OnInt()是D3D12HelloWindow的生命周期函数，包含两个部分，加载管线和加载资源 描述符堆（Descriptor Heap），用于CPU向GPU传递资源（比如数组、贴图），告诉GPU去哪里访问这些资源 描述资源的类型、维度、GPU虚拟地址、硬件信息 我们将描述符绑定在slots上，GPU可以通过访问slots上的描述符找到资源 栅栏（Fence），可以将其插入命令队列以实现同步 DX12支持多线程渲染，命令队列和命令列表的关系如下 硬件架构 CPU Cache占绝大部分面积 ALU、控制单元少，但复杂强大 GPU 计算核心占绝大部分面积 计算核心数量极多，个头小，可编程，支持并行 渲染管线 输入汇编器 输入汇编器（Input Assembler） 输入：顶点索引和顶点缓冲 行为：组装成图元 输出：传给顶点着色器 网格（Mesh）是由图元（通常为三角形）组成的几何体 顶点缓冲区（vertex buffers）存储了顶点相关的数据 输入布局（Input layout）描述了顶点缓冲区的布局，为顶点属性指定语意，使得输入汇编器能读懂顶点缓冲区 索引缓冲（index buffers）内含顶点索引，通过指向顶点缓冲区来组成图元 原始拓扑（Primitive topologies），描述了图元间的连接、邻接关系 特别的，Triangle Strip的三个顶点满足公式 $$ \\Delta_i={i, i+(1+i%2), i+(2-i%2)} $$ 光栅器 光栅器（Rasterizer），发生在片元着色器之前 输入：NDC空间的2D图元 行为： 剔除：裁剪掉视口外的图元，剔除背面（可选） 画线：获得图元所覆盖的像素区域 插值：根据重心坐标和顶点属性进行插值 输出：传给片元着色器 资源管理 内存 GPU可以访问四种内存 专用视频内存（Dedicated video memory）：我们分配GPU资源最常用的地方 专用系统内存（Dedicated system memory）：GPU内部专用内存，应用程序不能使用 共享系统内存（Shared system memory）：CPU可见的显存，常用于CPU向GPU传递数据 CPU系统内存（CPU system memory）：CPU可以任意访问，但GPU要通过PCI-e总线访问，速度极慢 视图和描述符 视图=描述符≈资源指针 简称 全称 意义 CBV Constant buffer view 描述常量缓冲区 UAV Unordered access view 常用于多线程读写 SRV Shader resource view 描述只读纹理和缓冲区 Samplers 采样器 RTV Render Target View 描述渲染目标 DSV Depth Stencil View 描述深度缓冲区 IBV Index Buffer View 描述顶点索引缓冲区 VBV Vertex Buffer View 描述顶点缓冲区 SOV Stream Output View 描述流输出缓冲区 资源状态 资源的多线程读写是冲突的，于是要通过资源状态实现互斥 GPU使用转化资源的状态来指定资源的预期用途，比如要读一张贴图，该贴图必须处于读取状态 DX12使用ResourceBarrier管理资源状态 根签名 在HLSL中，我们可以声明一个变量 Texture2D g_texture : register(t0); 该变量的类型是SRV，绑定到t的第0槽 t：SRV s：Samplers u：UAV b：CBV 管道状态 管道状态（pipeline state object ，PSO）定义了渲染管线的每个阶段的行为，PSO创建后不可变 Bundles 捆绑包（Bundles），用于将少量命令组合在一起，方便使用 Bundles只能提交给CommandList，不能直接提交给命令队列 常量缓冲区 就是CBuffer，是一种访问延迟更低，适合CPU高频更新的缓冲区 在着色器程序执行期间，常量缓冲区不会发送改变 常量缓冲区需要256字节对齐，一般使用4KB或者64KB（关于为什么要对齐、什么是假引用、缓存行，可以去看《高性能C++》笔记）","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"DX12","slug":"DX12","permalink":"https://reubensun.com/tags/DX12/"}]},{"title":"TA面试题","slug":"graphics/TA面试题","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.443Z","comments":true,"path":"graphics/TA面试题/","permalink":"https://reubensun.com/graphics/TA%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"TA面试题 这里面不少答案都是我自己凭感觉答的，不保真 什么是渲染管线 渲染管线是通过安排CPU发出Draw Call的内容以及顺序，指导GPU进行一系列操作，并协同将开发者期待的图像渲染在屏幕上 剔除 渲染 后处理 什么是Draw Call Draw Call是CPU为GPU准备渲染数据，并指令GPU进行一次渲染的操作，是重量级的 什么是Batching 将多个简单、使用同一材质的物体合并渲染的方式叫Batching batch是批的意思 渲染管线的渲染流程 延迟着色阶段（光栅化）Deferred Shading (rasterization) 直接阴影阶段（光线追踪或光栅化）Direct shadows (ray trace or rasterization) 光照阶段（计算着色器+光线追踪）Lighting (compute + ray trace) 反射阶段（光线追踪或计算着色器）Reflections(ray trace or compute) 全局光照阶段（计算着色器+光线追踪）Global Illumination (compute and ray trace) 环境光遮蔽阶段（光线追踪或计算着色器） Ambient occlusion (ray trace or compute) 透明与半透明渲染阶段（光线追踪+计算着色器）Transparency &amp; Translucency (ray trace and compute) 后处理阶段（计算着色器）Post processing (compute) 渲染流水线的基本流程 渲染就是从一个三维场景出发，获得一个二维图像的过程。分为四个过程，应用阶段、几何阶段、光栅化阶段、像素处理阶段，其中几何阶段光栅化阶段主要在GPU中进行。 几何阶段分为五个步骤：顶点着色器、曲面细分着色器、几何着色器、裁剪、屏幕映射 光栅化阶段分为四个步骤：三角形设置、三角形遍历、片元着色器、逐片元操作 什么是顶点着色器 输入值是CPU通过Draw Call发出的顶点数组（没有索引） 输出值是齐次裁剪空间坐标（如果不使用细分着色器和几何着色器） 什么是细分着色器 在显卡中**视口变换器(Viewport Transform)**中实现 将复杂的曲面转化为简单的点、线、三角形，可以增加网格细度，并在细分后的顶点上生成插值属性 如果使用了曲面细分着色器，顶点着色器就不会处理空间变化（如果没有顶点动画的需求，顶点着色器只负责传递数据），而是交给曲面着色器和几何着色器 在不改变网格外形的情况下，对网格进行平滑操作 什么是几何着色器 在视口变换器中实现，输出值是齐次裁剪空间 能改变顶点数量 能按索引访问顶点 什么是网格着色器 新一代三合一着色器，用于整合顶点、细分、几何着色器 可以实现无矩式渲染 屏幕映射 输入齐次裁剪空间 （通过透视除法）转化到归一化设备坐标(NDC)，最后输出屏幕空间坐标 什么是渲染路径 渲染路径是一系列对光照和着色(尤其是光照)的控制选项的集合 主流引擎支持前向渲染，延迟渲染，和自定义渲染 前向渲染 批次数=相机数x对象数x（除了主有向平行光外的逐片元光照数+1） 随着片元光照数量增多，性能大幅下降 延迟渲染 类似一种后处理 批次数=相机数x（网格数+逐片元光照数） 将几何通路和光照渲染通路分开，几何通道结果输送到G-Buffer中，然后对每个像素只进行一次光照计算 自定义渲染 屏幕后处理、天空盒、透明物体 延迟渲染 为什么延迟渲染不支持透明度混合 因为半透明网格在G-Buffer中会被其他片元覆盖 为什么延迟渲染不支持真的对抗锯齿 因为G-Buffer需要的带宽远远大于帧缓冲，在多重抗锯齿下难以满足负载 前向渲染 前向渲染的渲染通路（Pass）有两种，分布是基本通路（forwardbase）和附加通路（forwardadd） forwardbase 对所有的默认的有向平行光源及其产生的阴影进行逐片元计算，同时对其它基于顶点的和基于球谐光照的光源，以及物体的自发光、统一环境光和光照贴图进行计算 只对一个有效灯光执行一次，所以只会执行一次 forwardadd 对剩下的使用逐片元光照的光源进行光照计算 必须和forwardbase一同使用，不然会被忽略掉 对forwardbase外所有有效灯光都执行一次，所以会执行多次 向量 向量点乘叉乘的几何意义 点乘是投影，叉乘是法向量（方向符合右手定则，沿大拇指方向） 向量点乘叉乘的数学意义 $\\mathbf{a} =\\left( x_{1},y_{1},z_{1}\\right) $ $\\mathbf{b} =\\left( x_{2},y_{2},z_{2}\\right) $ $\\mathbf{a} \\cdot \\mathbf{b} =|\\mathbf{a} ||\\mathbf{b} |\\cos \\theta =x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}$ 求向量$\\mathbf{a}$关于向量$\\mathbf{b}$的对称向量$\\mathbf{c}$ $\\mathbf{a} \\cdot \\mathbf{b}=\\mathbf{c} \\cdot \\mathbf{b}$ $|\\mathbf{a} |=|\\mathbf{c} |$ 求点M关于直线l的对称点N M和N的中点在直线上 $\\overrightarrow{MN} $与直线垂直 欧拉角是什么？有何优缺点 欧拉角是一个直观利用三维向量表达旋转的方法 优点：占用的空间小，不会遇到非法输入 缺点：没有统一标准、不能跨平台；三个分量可能不正交，可能有无法表示的角度；不能插值运算 图形渲染用到哪些空间 顶点着色器：模型空间–M–世界空间–V–观察空间–P–齐次裁剪空间----屏幕空间 什么是模版测试 将屏幕的部分像素通过一个通道盖住，在渲染时剔除通道上不满足条件的值 如何渲染半透明物体 透明度测试 透明度混合 如何优化着色器代码 复杂计算放在顶点着色器中 简化等式，比如说：p = sqrt(2*(X+1))可以改写成1.414*sqrt(X+1)等 尽量使用内建函数 重复度低的操作可以交给CPU 使用顺序结构代替分支 丢弃片元时直接将alpha设为0 纹理图尽量使用2的n次方大小 将许多小纹理拼成一个大纹理 近点采样能满足要求就不要使用线性采样 如何判断多边形是凸多边形 角度法：内角是否小于180° 凸包法：如果凸包和原始多边形点数一样多，那么就是凸多边形 顶点凹凸性：本质上还是角度法，就是相邻顶点组成向量叉乘 相交测试 见图形学笔记 法线贴图 纹理就是贴图 法线纹理用RGB三个通道分布存储法向量在XYZ轴上分量大小 由于法线贴图大部分文素的方向都是朝向法线方向，于是法线贴图大多是蓝色的 如何渲染阴影 体积阴影法 深度阴影法 什么是HDR 高动态范围，一种颜色缓冲技术，使用更高的精度来表示亮度，能更真实的反应光照 HDR通过色调映射转到LDR 什么是伽马矫正 早期摄像机通过伽马加码，将实际亮度存储为更亮的值，显示时通过该骂解码获得正确的功率 什么是色调映射 就是利用显示器有限的亮度范围来近似实现HDR，就是将亮度映射到[0,1]的范围内，并压缩到8位的渲染目标上 什么是PBR 基于物理的渲染 正交投影和透视投影的区别 都是源于对针孔摄像机对数学建模 视锥形状不一样 什么是齐次坐标 为了实现仿射变换，将三维顶点引入四维空间，这个空间叫做齐次坐标空间 旋转平移矩阵 见图形学笔记 高光模型 漫反射模型 Lambert模型：反射光强度和 表面法线和光源的夹角的 余弦值成正比 半Lambert模型：光照有一个保底值，于是没有黑面 Minnaert模型：用于模拟丝绒 Oren-Nayar模型：风之旅人的沙子 高光反射模型 Phong模型：纯几何的经验模型，就是在Lambert漫反射上加了一点高光，强度与 视角方向和反射光方向的夹角的 余弦值成正比 Blinn-Phong模型：Phong的改进，不计算反射光，而是计算视角方向和光源方向的角平分矢量h，用h替代反射方向计算高光 Schlick模型：对BP模型的优化，简化一些运算，能获得更类似于油漆的效果 基于物理的模型 Cook-Torrance模型 什么是光栅化 是渲染流水线的一个重要阶段 三角形设置和三角形遍历可以合成光栅化，计算三角网格，并进行线性插值 阴影，软阴影 什么是抗锯齿 锯齿是走样的一种，指在渲染三角形、线的时候，像素要么存在，要么不存在，于是出现锯齿现象 SSAA，超级采样抗锯齿，翻倍渲染向下采样 MSAA，多重采样抗锯齿，每个像素内有多个采样点，渲染时以点数加权获得（性能好，不支持延迟渲染） FXAA/TXAA，放弃精度，让边缘模糊 延时渲染 场景中有大量实时光源时，前向渲染效率会下降，使用两个Pass，一个不计算光照，只计算片元是否可见 不支持抗锯齿，不能处理透明物体 故障检测 后处理 亮度饱和度对比度 边缘检测 高斯模糊 动态模糊 Bloom效果 贴图技术 贴图就是纹理 BRDF 双向反射分布函数 作品集里实现原理 ezy-slice原理：网格中存储了顶点数据、三角形数据、法线数据，使用MeshFilter获得sharemesh（mesh是新网格，sharemesh是原始网格） 物体的节点和三角形被分为三个部分（上下和切割面），相交处的三角形做分割操作，然后让原始网格不可见 如何区分位置和方向 齐次坐标，w==0就是位置，w==1就是方向 SSAO SS（Screen Space），都是后处理 SSGI屏幕空间全局光照 SSAO屏幕空间环境光遮蔽，对屏幕空间上每一个片元，在其法线范围的半球体中进行采样，采样点在深度纹理采样，从而判断该点是否被遮蔽 一般来说使用SSAO后还要在进行一次模糊，还需要进行时域平滑来避免闪动 SSR SSR屏幕空间反射，在相机中发射出n条光线，然后根据物体的法向量和摄像机的射线方向计算出这条光线的反射方向。再对他进行raymarch（光线步进）计算。 动态模糊 种类 相机动态模糊 对象动态模糊 原理 保存多帧数据进行混合 速度映射图，图中存储了每一个像素的速度，沿着这个速度采集像素，进行加权混合，得到模糊效果 线框 方法1:深度偏移（这玩意不是线框，是描边） 使用两个Pass渲染，一个正常渲染，一个在深度偏移的情况下渲染一遍线 两个Pass有性能损失 深度偏移是为了防止线条被遮挡，这会导致多边形和线框在相同位置的片元的深度值不一样 方法2:几何着色器（这才是线框） 几何着色器可以使用索引数组访问顶点的拓扑结构 线框渲染可以使用几何着色器访问三角形，并计算每个顶点到对边的垂线长度，于是通过插值获得三角形中每个点到三角形三个边的最短距离 我们知道在光栅化阶段要插值上色，那么我们可以在插值的时候进行判断，当垂线距离符合条件时（离三角形边特别近）就染上线框的颜色 片元着色器和像素着色器的区别 在大部分情况下没有区别 在极个别情况下（大概是OpenGL那边）我门认为如果片元着色器中的输入数据是恰好覆盖屏幕的四边形时，这个片元着色器被称为像素着色器 SDF 距离函数 shadertoy的本质就是通过编写（2D）距离函数来绘制物体 为什么shader中少用分支和循环 因为在gpu中，分支的实现原理是两个分支都执行，然后丢弃不需要的分支，这个增长是指数级的（2^n^） 什么是Cubemap 立方体纹理，是实现环境映射的一种方法 什么是光照探针 是一组封装后的Cubemap，在烘培或预计算时，对空间中的一些采样点（光照探针）采集Cubemap，在运行环境渲染运动物体时，CPU会从离物体最近的光照探针中获取Cubemap，按照距离进行插值。 这个过程实现了CPU和GPU的解耦，CPU只需要维护一组固定的光照探针组，GPU只需要处理与这个物体相关的临近Cubemap 通过光照探针获取环境景象需要对场景进行六次渲染（毕竟有六个面） 什么是球偕函数 将真实环境中连续的光照方程进行离散化，通过球形坐标系分解简化反射方程，通过球偕变换获得球偕系数，在运行时根据球偕系数重建方程 采样-分解-变换-重构 参数和分量 参数是黑盒，分量是白盒（你可以理解的是，别人在unity面板上拖动的属性多半是参数，一种东西的组成是分量，比如颜色可能就有由高光、漫反射等分量） 为什么次表面散射用漫反射做高斯模糊 因为lambert的光照强度与入射光线和法线夹角有关，而折射和反射的比例也与这个夹角有关（菲涅尔） 折射光是次表面散射的入射光，折射的光越强，散射的光也会越强 什么是光线步进 光线步进（raymarching）：从摄像机位置向屏幕每一个像素点发射一条光线，光线按照一定步长前进，并检测当前光线是否位于物体表面，据此调整光线前进幅度，直到抵达物体表面，再按照一般光线追踪的方法计算颜色值。 什么是MC算法 **步进立方体算法（Marching Cube）**是一种在密度场中采样来生成多边形的算法，在生成多边形之后再依照多边形渲染的过程进行正常的渲染。 相比射线扫描算法，步进立方体算法可以生成并保存多边形，所以在密度场的修改频率不高的情况下，使用步进立方体算法可以节省很多不必要的性能消耗。 核心：确定等值面 什么是屏幕空间阴影纹理 对于多光源的情况，每个光源都可以产生一个深度阴影纹理。在着色器中对这些深度阴影纹理逐个进行处理，可以得到若干个屏幕空间的阴影纹理，将这些屏幕空间下的阴影纹理混合就可得到一个总的屏幕空间阴影纹理，它表示了在屏幕空间中某个片元接受到的来自所有光源产生的阴影强度的总和 什么是URP unity内的**渲染管线（Render pipelines）**包括 内置渲染管线（Build-in） 可编程渲染管线（Scriptable Render Pipeline，SRP） 高清渲染管线（High Definition Render Pipeline，HDRP） 通用渲染管线（Universal Render Pipeline，URP） 什么是滤波模式 纹素坐标是整数值，但UV坐标不是，所以要有一种方法由UV坐标获得纹素值 最近相邻滤波(Nearest neighbor filtering，或者Point sampling) UV坐标 x 纹理大小，然后四舍五入取最近的纹素 有明显的像素块 双线性滤波(Bilinear filtering，或者liner filtering) 根据一个坐标到其附近最近的四个像素点的距离进行加权平均，得到一个混合的颜色 三线性滤波(Trilinear filtering) 在相邻的两个Mipmap层次上分别进行双线性滤波，再对得到的两个值进行线性插值 当距离非常大或非常小的时候，三线性滤波会退化为双线性滤波 各项异性滤波(Anisotropic filtering) 当一个目标表面和透视摄像机之间的角度较大时，纹理的填充面积实际上并不是正方形，这引入了模糊和闪烁等瑕疵 需要在一个非正方形区域内采样和混合 有的使用长方形，有的使用梯形 什么是纹理映射 就是将三维的空间坐标点转化为二维的纹理坐标点 步骤： 投影映射 变换函数 纹理采样 纹理转换 什么是纹理压缩 这是一种有损压缩，对于一张原始纹理，会创建两张小纹理A和B，同时还有一个矩阵M，M的行列和原始纹理的长宽一致，里面的值类似于调色板中的索引，实现纹理A和纹理B的混合 GPU的寻址方式 集成显卡 对集成显卡来说，GPU使用CPU专门划分出来的一份内存空间**UMA（Unified Memory Architecture，一致性储存架构）**作为显存，GPU和CPU使用不同的虚拟地址对UMA中同一个物理地址进行寻址，两者共享总线。 在渲染时，CPU将顶点数据存储到主存中，然后GPU通过**GART(Graphic Address Remapping Table，显存地址重定位表)**访问UMA 独立显卡 独立显卡中CPU和显卡的沟通是使用异步的**DMA(Direct Memory Access，内存直接访问)**实现的。 CPU将DMA命令从内存中读取，并写入DMA控制器 DMA控制器直接操控内存总线，在不依赖CPU的情况下将数据传输给显卡驱动 显卡驱动给DMA控制器发送信息（握手） DMA占用内存总线，向内存请求地址，向显卡发送信号 显卡接受信号后将数据传输到内存，并清除DMA请求信号 沟通结束，触发一次CPU中断 CPU和GPU分支预测方式有何差别 CPU CPU在流水线中进行分支预测 静态分支预测 动态分支预测 协同分支预测 GPU 将两个结果都运行一次，然后丢弃不需要的分支，这样会严重影响性能（指数级），这个现象被称为线路分歧 纹理数据在GPU中是如何排列的 纹理存储器中的数据以一维/二维/三维数组的形式存储在显存中，可以通过缓存加速访问 在kernel中访问纹理存储器的操作称为纹理拾取(texture fetching) 将显存中的数据与纹理参照系关联的操作，称为将数据与纹理绑定(texture binding) shader中的变量类型（OpenGL） uniform 在顶点着色器和片元着色器中的声明方式完全一样，可以视为被双方共享的全局变量 attribute 只能在顶点着色器中使用的变量，一般用于存储顶点的位置、法线、uv、颜色信息 varying 顶点着色器和片元着色器之间做数据传输用的变量，必须保证在两者中声明保持一致 如何保证顶点着色器传入片元着色器的数据一致性 varying变量声明一致？ 矩阵乘法 两条直线的交点就是C的位置 x左乘A x右乘A 直线扫描转化法 数值微分法DDA 思想：步进和通过舍入选择像素 $P_{0}(0,0)$到$P_{1}(5,2)$ k=0.4 $i$ $x_{i}=x_{i-1}+1$ $y_{i}=y_{i-1}+k$ $round(y_{i})$ 坐标 0 0 0 0 (0,0) 1 1 0+0.4=0.4 0 (1.0) 2 2 0.4+0.4=0.8 1 (2,1) 3 3 0.8+0.4=1.2 1 (3,1) 4 4 1.2+0.4=1.6 2 (4,2) 5 5 1.6+0.4=2.0 2 (5,2) 中点画线法 相比于DDA算法，省去了浮点数运算 直线方程$F(x,y)=Ax+By+C=0$，若$F(x,y)&gt;0$则位于直线上方，若$&lt;0$则位于直线下方，若$=0$则在点上 使用步进思想，根据中点误差项判断是向右移动还是向右上移动（如果0&lt;k&lt;1) 直线已经经过点$P$，下一步经过了点$P_{u}$和$P_{d}$，他们的中点是M，我们将M带入直线方程，通过判断大小来决定是不是 为了进一步降低消耗，使用步进，每一次就将点$P(x_{i}+1,y_{i}+0.5)$带入直线方程$Ax+By+C=0$ d&lt;0就取右边的点，$d_{i+1}=d_{i}+A+B$ d&gt;0就取右上的点，$d_{i+1}=d_{i}+A$ 只不过我们只关心符号，所以可以用2d代替d d&lt;0就取右边的点，$d_{i+1}=d_{i}+2A+2B$ d&gt;0就取右上的点，$d_{i+1}=d_{i}+2A$ Bresenham画线法 本质上和中点画线一样 $d_{i}&lt;0$就取右边的点，$d_{i+1}=d_{i}+2\\Delta y$ $d_{i}\\geqslant 0$就取右上的点，$d_{i+1}=d_{i}+2\\Delta y-2\\Delta x$ $d_{1}=2\\Delta y-\\Delta x$ $P_{0}(0,0)$到$P_{1}(5,2)$ k=0.4 $\\Delta y=2$ $\\Delta x=5$ $i$ $d_{i}$ $x_{i}$ $y_{i}$ 坐标 0 0 0 0 (0,0) 1 $d_{1}=2\\Delta y-\\Delta x=-1&lt;0$ 1 0 (1.0) 2 $d_{2}=d_{1}+2\\Delta y=3&gt;0$ 2 1 (2,1) 3 $d_{3}=d_{2}+2\\Delta y-2\\Delta x=-3&lt;0$ 3 1 (3,1) 4 $d_{4}=d_{3}+2\\Delta y=1&gt;0$ 4 2 (4,2) 5 $d_{5}=d_{4}+2\\Delta y-2\\Delta x=-5&lt;0$ 5 2 (5,2) 构建贝塞尔曲线 一阶 两个点$P_{0},P_{1}$ 直接坐标线形插值 $B_{1}(t)=(1-t)P_{0}+tP_{1}$ 二阶 三个点$P_{0},P_{1},P_{2}$ 先求$P_{0}P_{1}$和$P_{1}P_{2}$的一阶贝塞尔，然后再对两个一阶进行线性插值 n阶 $$ B_{i,n}\\left( t\\right) =\\frac{n!}{i!\\left( n-i\\right) !} t^{i}\\left( 1-t\\right)^{n-i} $$ $i$是第几项，从0开始 $n$是控制点总数 线段的裁剪 Cohen-Sutherland 尽量避免求交运算 编码，把空间分为九个部分，其中中间部分是屏幕，其outcode编码为 判断时，两个端点的outcode值为$o_{1}和o_{2}$ 若$o_{1}=o_{2}=0（其实是0000）$：说明两个点都在屏幕中间 若$o_{1}\\neq 0,o_{2}=0（12顺序可以颠倒）$：说明一个在屏幕内，一个在屏幕外，而非零端点的编码说明了线段与裁剪窗口哪一个边（或者两个边）相交，需要计算交点 若$o_{1}&amp;o_{2}\\neq 0$：说明两个点在裁剪窗口的同一侧，可以直接丢弃 若$o_{1}&amp;o_{2}= 0$：需要计算交点 Liang-Barsky 窗口$Wx_{l}=0,Wx_{r}=4,Wy_{b}=0,Wy_{t}=3$ 直线： $$ \\begin{cases}x=-2+u\\left( 7+2\\right) &amp;\\ y=6+u(-2-6)&amp;\\end{cases} $$ $$ \\begin{cases}u_{1}=2/9&amp;\\ u_{2}=2/3&amp;\\ u_{3}=3/4&amp;\\ u_{4}=3/8&amp;\\end{cases} $$ $u_{max}=\\max(0,2/9,3/8)=3/8$ $u_{min}=\\min(1,2/3,3/4=2/3)$ 所以保留$u_{2}u_{4}$，其中$u_{2}=(4,2/3)\\ u_{4}=(11/8,3)$ Early-z 在vertex后，fragment前做一次深度测试，如果失败，则不进行fragment（如果成功，还是要在fragment中做ZTest），这样可以大幅提高性能 开启AlphaTest需要关闭Early-Z，因为AlphaTest通过会写入深度值，而新写入的深度值无法通过Early-Z，于是本该输出的颜色被剔除了（现在硬件做了优化，可以更智能的自动开关Early-Z） 什么是球面度 球面度sr是立体角的国际单位（平面角的单位是角度/弧度），可以理解为三维的弧度 弧度 在一个圆上切一个扇形，弧长等于$r$所对应的角为1弧度 一个完整的圆的弧度为$2\\pi$ 球面度 在一个球上切一个“锥形”，锥形的底面积等于$r^2$所对应的角为1球面度 一个完整的球的球面度为$4\\pi$ 为什么BRDF 函数的单位是 1/sr BRDF，双向反射分布函数，是材质表面某一点出射**辐射率（Radiance）和入射辐照度（Irradiance）**的比值 $$ BRDF=\\frac{dL\\left( \\omega_{o} \\right) }{dE\\left( \\omega_{i} \\right) } $$ 辐射率$L$：每单位面积每单位**投影固体角（projected solid angle）**上的能量 辐照度$E$：每单位面积上的能量 为什么BRDF不直接用出射辐射率/入射辐射率呢？ 原因一：因为入射辐射率很难测量 测量**出射辐射率$L_{0}$**很简单，只要我在出射方向上放一个下面的仪器，对准该点就可以了 测量入射辐射率很麻烦，需要要求光源很小，没有其他光的干扰，所以实际测量的时候不可行，于是不使用，最后BRDF就是出射辐照度/入射辐射率，这两个 而测量辐照度$E_{i}$只需要一个面积较小的平面，接收半球方向的光通量$\\Phi $，$E=\\Phi /S $ 原因二：数学 如果是辐射率/辐射率，当出射立体角$\\omega_{o}$趋近为0时，两者比值为0（上面是无穷小），没有意义 $$ \\lim_{\\omega_{o} \\rightarrow 0} \\frac{dL_{o}}{L_{i}} =0 $$ 但辐射率/辐照度不等于零，因为上面下面都有无穷小，所以是不定式/等价无穷小，有意义 $$ \\lim_{\\omega_{o} \\rightarrow 0} \\frac{dL_{o}}{dE_{i}} \\neq 0 $$ 什么是万向节死锁 Gimbal Lock （万向节死锁，或叫 环向锁节） 在传统的欧拉坐标系，相机可以沿着xyz三个方向旋转，这三个轴有旋转的先后顺序，可以理解为父母层级关系，父轴旋转时子轴也会跟着旋转 Y轴 X轴 Z轴 相邻两个轴始终保持垂直，但有的时候，第一个轴会和第三个轴重合，于是你就会失去一个自由度，你无法朝向某一个方向旋转了，如果要旋转，就需要同时旋转两个轴，这个旋转很不流畅，会出现抽搐，被称为万向节死锁 可以通过引入四元数解决 有什么常见的遮挡算法 画家算法 后画覆盖新画 这是剔除的核心，下面几个都是对其的加速和优化 沃诺克算法（Warnock） 不停地四分屏幕 当前子空间没有多边形：完成！ 当前子空间只有一个多边形：画！ 当前子空间有简单的前后关系：画前面的！ 当前子空间只有一个像素那么大了：画离该像素点距离最近的多边形！ 否则，继续递归细分 BSP-Tree（二维空间分割树） 不停地二分空间，在每一个只有简单前后关系的子空间里使用画家算法 Z-Buffer 写入颜色时也写入Z值，绘制时根据Z值判断是否覆盖 有overdraw，只能处理不透明物体，多使用了一个Z-Buffer 如何判断点在三角形内 同侧法 若点P在三角形ABC内部，则 点P和点A在直线BC同侧 点P和点B在直线AC同侧 点P和点C在直线AB同侧 判断是否同侧都方法是叉积同号 叉积法 PA、PB、PC两两叉积，如果三者同号则为内部 重心公式 平面内两个不平行的非零向量可以表示任何向量 $$ \\overrightarrow{AP} =u\\overrightarrow{AB} +v\\overrightarrow{AC} $$ 两边点积 $$ \\overrightarrow{AP}\\cdot \\overrightarrow{AC} =u\\overrightarrow{AB}\\cdot \\overrightarrow{AC} +v\\overrightarrow{AC}\\cdot \\overrightarrow{AC} $$ $$ \\overrightarrow{AP}\\cdot \\overrightarrow{AB} =u\\overrightarrow{AB}\\cdot \\overrightarrow{AB} +v\\overrightarrow{AC}\\cdot \\overrightarrow{AB} $$ 两个变量两个公式，可以求出u和v 什么是MIS 多重重要性采样（multiple importance sampling，MIS），在光追中，当光源和物体表面材质都接近$\\delta$分布时，无论在光源上采样还是按BSDF采样都会带来很高的方差，使用MIS可以提高效果 思路就是结合不同种采用方法，分布采用被积函数的不同部分，讲这些部分结合起来，以达到最优效果 什么是德尔塔分布 $\\delta$函数（狄拉克函数）：除了零点以外的点都等于零，但在其整一个定义域内的积分为1的函数（这种函数本身并不存在） $\\delta$分布：符合$\\delta$函数的分布 已知UV和深度如何重建世界坐标 使用逆矩阵 用uv和深度重建NDC坐标，乘以VP矩阵的逆矩阵以重建世界坐标 线性深度 正交投影 uvz线性映射回视锥长方体 透视投影 通过z确定投影面大小，然后uv线性映射 草地弯曲是怎么实现的 顶点偏移？ 离角色很近的树叶如何保持性能 是不是每一次draw call都需要重新传一次顶点数据 贴花 前向：绘制几何体 延迟：Gbuffer中绘制 SSR会丢失信息，可以怎么处理 用cubemap补一下？ 为什么有法线贴图还需要顶点法线信息 为了构建TBN矩阵 在片元着色器中采集切线空间法线贴图信息，然后使用TBN矩阵恢复成世界空间法线，那么TBN是怎么来的呢？ half3x3 tangentToWorld = half3x3(i.tangentWS.xyz, bitangent.xyz, i.normalWS.xyz); 是使用顶点着色器传入的世界空间切线、次切线、法线构建的 Forward+ 和传统的前向渲染比添加了一个光源剔除阶段 着色分三个阶段： depth prepass（可选） Light culling shading 将光源信息存储在一个线性布局的缓冲区中，方便查找 light culling阶段和延迟渲染中光照累计很相似，对于每一个像素，先找其所在的tile，求能照射到这个tile的光源列表，然后进行着色 理论上对每一个像素找灯光是效果最好的，现在这种找tile很显然是会计算一些多余的灯光，但是大幅减少了查找灯光的计算量，在查找和着色间寻找一个平衡 移动端GPU渲染架构 IMR Immediate Mode Rending，即时模式渲染，按drawcall顺序绘制 TBR Tile Base Rendering 将画面分割为一个个tile，在VS对每一个tile处理，将结果存到On-Chip Memory上，然后FS读信息，渲染每一个tile 作用：省带宽，每次传一个小tile，对带宽的压力会比IMR小很多（IMR一次传一整张屏幕） TBDR Tile Base Deferred Rendering 上面我们在FS对每一个tile做渲染时，完全可以记录哪些灯光会影响这个tile，使用这些光做计算 思路 TBR省带宽了，但是没减少overdraw，而TBDR处理了剔除问题，降低了overdraw TBR的其他应用 MSAA：MSAA是对一个像素多采几个点，原本采样很费，因为要加载卸载贴图 但是由于TBR每一个tile都是片上的，相当于省了加载卸载，性能好很多 只不过虽然采样变便宜了，采样结果一多，就要处理更多的采样数据，所以也不能无限制的使用 此外这会让多边形覆盖更多的像素 如图，只有一个采样点时（红点），红圈所在的像素不会被算进去，但MSAA时就会被算进去 视差贴图 视差贴图（Parallax Mapping）效果类似法线贴图，其原理是对纹理采样uv做偏移，不修改顶点信息 原本平坦的表面，如果变成如图的凹凸形状，原本视线会与平面在B处相交，现在则在A处相交，我们采集$A’$点的信息 从B到$A’$做了什么呢？本质就是采样点从B点出发，沿着视线在平面的投影做了一次偏移，偏移的长度可以通过三角形相似求得 //输入B的uv，得到A‘的uvfloat2 ParallaxMapping(float2 texCoords,float3 viewDir)&#123; float height = texture(depthMap, texCoords).r; float2 p = viewDir.xy / viewDir.z * (height * height_scale); return texCoords - p; &#125; 如果按深度步进，通过从上到下找第一个深度小于A的平面，来求$A’$的位置，就是陡峭视差映射(Steep Parallax Mapping)的思想 virtual texture 根据是否实时生成（合并）virtual texture，该技术分为VT和RVT，该技术主要用于大世界地形上 在说VT前，要先谈texture splatting。大世界的地表纹理通常是使用多张纹理混合而成的（比如沙子、草、岩石、雪），而混合这些贴图的技术称为texture splatting 该技术很简单，比如要混合四张图，那么生成一个新的RGBA贴图，在某一点的混合图为 blenderTex = Texture1 * map.r + Texture2 * map.g + Texture3 * map.b + Texture4 * map.a;//其中 map.r + map.g + map.b + map.a 恒等于1 我们发现这种混合技术要频繁采样，混合四张图，要采9张图（四个材质图，四个法线图，一个splat图），而我们知道采一张大图会比采多个小图性能高很多，那么我们能不能把这九张小图拼成一张大图呢？这就是VT 但我们没必要一次把这九张完整的图合并，这也存在浪费，那么我们只需要合并需要被采样的图 我们把原图做预处理，分割成一个个小tile，并维护一个映射表，当我们要采样某个范围内的贴图时，先根据映射表找到所有相关的tile（回传给CPU，让CPU去加载tile），再把tile合并 帕尼尼投影 一种屏幕后效，画面中心凸起，镜头左右两边在垂直方向上保留画面原样 SSBO Shader Storage Buffer Object，该对象可以在不同shader间共享数据，功能类似UBO（Uniform Buffer Object） 两者（SSBO和UBO）区别 SSBO更大 SSBO的大小可以在运行时确定 UBO在显卡的常量区（CMEM），SSBO在全局区（SMEM） SSBO更灵活，能支持更多种的数据类型 计算任意多边形面积 凸多边形 一多边形某个点为顶点，将多边形划分为多个三角形，计算每个三角形的面积（可以用向量叉积），再加起来 凹多边形 向量的叉积是有方向的 $$ S_{OAB}=0.5*(\\overrightarrow{OA} \\times \\overrightarrow{OB}) $$ $$ S_{ABCDE}=S_{OBC}+S_{OCD}+S_{ODE}+S_{OEA}+S_{OAB} $$ OBB包围盒 常见的包围盒有AABB和OBB，AABB是轴向的，生成简单，但当物体旋转时效果并不好，OBB是有向的，沿着物体的主成分方向生成最小的一个矩形包围盒，可以随物体旋转 OBB2D的生成思路是：通过主成分分析（PCA）获得特征向量，作为OBB的主轴，然后将所有点包含 主成分分析 主成分分析是一种通过正交变换，将一组可能相关的变量集合变换成一组线性不相关的变量集合，即主成分 简单来说就是根据所有顶点生成协方差矩阵，对其对角化 BS变形器 blendshape 将一个mesh变化为另一个mesh（顶点数不变）的规则，就是一个BS，其最重要的功能是做表情 什么是灭点 在透视投影中，不平行于投影平面的平行线会聚集到一点，改点就是灭点 用途 在制作屏幕后效时（比如雨水），在相机的双锥体上渲染（而不是直接对屏幕四边形），可以得到一种雨水向远处收拢的感觉 选人界面的打光与镜头 打光 环境光：用HDRI贴图提供 直接光：打在人物正面斜上方，提供主要亮度，开启阴影 虚拟光：用于模拟反光板的提供的光源，亮度较弱，方向和相机一个位置（卡渲中常用，可以减弱光照对比，减弱阴影问题） 镜头 使用长焦镜头，也就是提高FOV，这样可以减少面部崎变，让人显得更瘦（反其道而行之，就是大头猪鼻特效） 开启景深 深度景深：没法处理半透明物体，人物头发也会会出问题（因为深度变化太小） Circle Blur：效果更好，美颜相机大多使用这个，原理就是把人抠出来，把人以外的背景模糊 眼球渲染的要点 眼白 血丝 可以直接画在贴图上 次表面散射 将散射函数预积分到LUT图上 眼睛 镜面反射 颗粒状眼白法线，来表现眼白的粘液 AO 在眼球外层做一个用来遮蔽的半透明模型 虹膜 缩放 uv采样缩放 视差 焦散（猫的眼睛发亮） 双层法线，圆滑的法线计算高光，平整的法线计算漫反射 虹膜对光线的吸收（眼珠旁边有黑圈） 根据uv画圆 瞳孔收缩 泪腺 移动端Deferred 移动端延迟与GPU架构强相关 iOS：one pass deferred Adreno：frameBuffer fetch deferred 提前绑定（开辟）好MRT，使用时RT不动，Pass动 Mali：pixel loacl storage deferred 将GBuffer存在on-clip mem上，于是就减少了IO消耗 移动端SubPass Unity移动端使用Metal和Vulkan API时，都可以使用SubPass，但略有不同 在同一个RenderPass的不同SubPass间切换，是不会带来带宽消耗的 Metal 支持FrameBufferFetch，即可以在一个SubPass中对RT读写 不支持在Tile上读取深度 Vulakn 不支持FrameBufferFetch 支持在Tile读深度（mali设备读浮点纹理比读tile的深度更高效） 由于Metal不支持读深度，而mali Vulkan读深度效率比读RT差，所以Metal和Vulkan都在GBuffer Pass时额外生成一张深度RT，在LightingPass里用 角色灯光术语 光比 指物体受光面亮度与阴影面亮度的比值，比值越大，明暗对比越强 常出现在黑暗空间爆炸光效照亮角色 二值化光 照明时，灯光颜色在固定好的暗部颜色和亮部颜色之间插值 抗锯齿 抗锯齿有两大类，时间层面和空间层面，但本质都是增加采样点数 空域抗锯齿 MSAA（MultiSampling Anti-Aliasing）：一个像素采多个点 On-Clip MSAA FXAA（Fast Approximately -Aliasing）：卷积模糊 SMAA（Enhanced Subpixel Morphological）：边缘检测–矢量化–像素混合 时域抗锯齿 TAA（Temporal Antialiasing），一帧采一下，几帧后就等于采了很多点 svoGI Sparse Voxel Octree（稀疏体素八叉树） GI，是VXGI的进阶版本 无偏渲染 SST Sparse Shadow Tree，一种大范围阴影渲染方案 论文地址 ShadowCache 对静态物体和动态物体使用两套CSM，一套只绘制动态物体，每帧刷新，一套只绘制静态物体，低频刷新 低频刷新的CSM被称为ShadowCache TressFX 一种实时毛发渲染系统 XGen 一个maya的头发制作工具 maya文档 Vulkan的基本概念 Vulkan对象主要分为三个部分，每个部分都有一个主对象 Instance 第一个Vulkan对象，用于连接应用程序和Vulkan运行时 PhysicalDevice 显卡 可以枚举图形队列 可以枚举内存堆和内存类型 Device 逻辑设备 Queue：用于向GPU传递命令（类比SRP的上下文） CommandPool：用于创建CommandBuffer CommandBuffer：命令缓冲区，可以通过vkQueueSubmit提交到Queue中 Sampler：一组采样器状态，用于设置滤波模式、寻址模式等 Buffer&amp;Image：资源，渲染时不会直接使用 BufferView&amp;ImageView：对资源的解释（Buffer&amp;Image中，我们所需要的部分），渲染时直接使用（类比SRP的RT） SurfaceKHR：控制屏幕窗口，与平台相关 SwapchainKHR：交换链，内含一组图片，用于实现显示交换 立即渲染 双缓冲 多重缓冲 Descriptor：描述符，用于访问资源（顶点信息，缓冲区，图像，采样器） DescriptorSet DescriptorSetLayout DescriptorPool FrameBuffer：ImageView的集合（RT、MRT） Attachment：附件（类比SRP的RenderTarget） Attachment初始化：Load Action Attachment写回内存：Save Action RenderPass：一次渲染流水线的执行，将信息输出到FBO的Attachments中 SubPass：渲染的中间Pass，他们的目标不是FBO，而是一些临时的目标 Pipeline：管线 ComputePipeline GraphicsPipeline PipelineLayout ShaderModule：使用SPIR-V进行着色器编译 PipelineCache Query：查询，用于得到某指令的执行情况 Fence&amp;Semaphore Fence：栅栏，用于CPU和GPU同步 Semaphore：信号量：用于GPU内部的同步（对客户端黑盒）","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"TA","slug":"TA","permalink":"https://reubensun.com/tags/TA/"}]},{"title":"ddx与ddy","slug":"graphics/ddx与ddy","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.442Z","comments":true,"path":"graphics/ddx与ddy/","permalink":"https://reubensun.com/graphics/ddx%E4%B8%8Eddy/","excerpt":"","text":"ddx与ddy 在OpenGL中叫dFdx和dFdy，在HLSL中叫ddx和ddy HLSL deriv_rtx ddx和ddy是一个求偏导的过程，依赖于硬件光栅化，只能用于fragment着色器，意思为计算blocks内相邻片元间value的变化（value可以是任意参数，比如uv、color、position、normal），注意不要在分支中使用偏导 $$ \\mathrm{ddx}=\\frac{\\mathrm{p}(x+1,y)-\\mathrm{p}(x,y)}{1} $$ 三角形光栅化时，fragment着色器一次处理2x2个像素，其中左上角的像素$(x,y)$始终为偶数坐标 如果一个几何体不够大，使用抗锯齿算法后渲染分辨率仍然比2x2要小，那么这个几何体在光栅化前就会被剔除，以此不必担心像素不够的情况 mipmap（UV） 使用mipmap会增加贴图存储，但是能提高性能和效果，在对mipmap贴图进行采样时，我们可以手动指定采样层级 我们需要一种方法能求mipmap层级（如果层级不对，会导致纹素比异常，产生摩尔纹等） ddx和ddy一个应用是求贴图mipmap层级 float mip_map_level(in vec2 texture_coordinate)&#123; vec2 dx_vtc = dFdx(texture_coordinate); vec2 dy_vtc = dFdy(texture_coordinate); float delta_max_sqr = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc)); return 0.5 * log2(delta_max_sqr);&#125; 在OpenGL4.x提供了mipmap函数textureQueryLod() 面法线（坐标） 我们在fragment着色器中对世界坐标做ddx和ddy，就能得到三角面上两个向量（这俩向量还是垂直的），而平面上两个非平行向量就能确定一个平面，他们的叉积就是面法线（注意手系和法线正负） vec3 faceNormal = normalize( cross(dFdx(pos), dFdy(pos)) ); 该技术常用于平面着色（Flat Shading），让物体有一种低面感，法线没有插值，是ground着色、phong着色以前的东西（老古董前的老古董） 高度图（法线） 与面法线原理类似，给定一张单通道的灰度图当作高度图，通过ddx、ddy就能得到高度的变化，进而得到法线的变化 fixed h = tex2D(_HightMap, i.uv).r;float offsetU = -ddx(h); float offsetV = ddy(h);float3 n = normalize(i.normal.xyz + float3(offsetU, offsetV, 0) * _Intensity);","categories":[{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"}],"tags":[{"name":"shader","slug":"shader","permalink":"https://reubensun.com/tags/shader/"}]},{"title":"Nabla算子","slug":"math/Nabla算子","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.441Z","comments":true,"path":"math/Nabla算子/","permalink":"https://reubensun.com/math/Nabla%E7%AE%97%E5%AD%90/","excerpt":"","text":"Nabla算子 参考 $\\nabla$：Nabla算子，将数量场变成向量场 当其作用于函数，如$\\nabla F(x)$，意思为求该函数梯度 当其点乘函数，如$\\nabla \\cdot F(x)$，意思为求该函数的散度 当其叉乘（三维）函数，如$\\nabla \\times F(x)$，意思为求该函数的旋度 函数可视化 对于函数$f(x,y)=x^2+y^2$，我们有两种可视化方法，第一种叫做图像： $$ {(\\vec{x}, f(\\vec{x}))|\\vec{x} \\in D} $$ 第二种叫做等值面: $$ {\\vec{x}|f(\\vec{x})=c} $$ 等值面只需要二维空间就能表示三维数据 梯度 Nabla算子其实是一个向量： $$ \\nabla =\\left[ \\frac{\\partial }{\\partial x_1}, \\frac{\\partial }{\\partial x_2 },\\cdots,\\frac{\\partial }{\\partial x_n } \\right]^{T} $$ Nabla算子作用于函数（标量场），可以将标量场转化为向量场，我们称该向量场为梯度 $$ \\nabla f= \\left[ \\begin{array}{c} \\frac{\\partial f}{\\partial x_1}\\\\ \\frac{\\partial f}{\\partial x_2}\\\\ \\vdots\\\\ \\frac{\\partial f}{\\partial x_n}\\\\ \\end{array} \\right] $$ 梯度垂直于等值面，意义为变化最快的方向（图中黄色箭头） 散度 我们知道向量和向量间可以进行点乘，其结果为一个标量，那么Nabla算子和向量相乘，我们称所得到的标量为散度 $$ \\vec{f}=\\left[ \\begin{array}{c} f_1\\\\ f_2\\\\ \\vdots\\\\ f_n\\\\ \\end{array} \\right] $$ $$ \\nabla \\cdot \\vec{f}=\\frac{\\partial f_1}{\\partial x_1}+\\frac{\\partial f_2}{\\partial x_2}+\\cdots +\\frac{\\partial f_n}{\\partial x_n} $$ 上图的白色箭头表示一个向量，我们发现这些箭头都是在朝外扩散，而散度就是用来衡量箭头向外扩散的程度 散度的物理意义是通量的局部描述。我们在图上画一个圈，我们发现会有向量进入这个圈，也有向量离开这个圈，那么进出之合，我们就称之为通量（比如磁通量），我们将通量除以圈的面积，就得到了通量的体密度。若这个圆取无穷小，那么体密度的极限值就是该点的散度 是不是突然很好理解麦克斯韦方程中$\\nabla \\cdot \\mathbf{E}=0$的原因了？ 其实这个公式就是高斯公式 旋度 向量不仅可以点乘，其实也可以叉乘，两个三维向量叉乘，能得到一个3x3的行列式。最后得到一个矩阵，我们称为旋度 旋度的物理意义就是环量的面密度。现在有一个在旋转的场，我们在场上画一个圈，场在这个圈内会做功，这个功就是环量，我们求出单位面积上环量，这个极限值描述了漩涡的强度。旋度就是旋转最快的方向 梯度的散度 nabla算子和自己做内积，于是会得到一个数量场，意义为求梯度的散度 这个操作为$\\nabla\\cdot \\nabla$，也可以写作$\\nabla^2、\\nabla^T \\nabla$，但为了避免歧义，我们引入了一个新的符号，拉普拉斯算子 $$ \\Delta=\\nabla \\cdot\\nabla $$","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"复变函数","slug":"math/复变函数","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.441Z","comments":true,"path":"math/复变函数/","permalink":"https://reubensun.com/math/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/","excerpt":"","text":"复变函数 复变函数 复数 复数可以表示为实数和纯虚数的和 代数式： $$ z=x+\\mathrm{i}y $$ x：实部，记为Re z y：虚部，记为Im z 复平面： 极坐标下 $$ \\begin{cases} \\rho=\\sqrt{x^2+y^2} \\ \\varphi=\\arctan (y/x) \\end{cases} $$ $$ \\begin{cases} x=\\rho \\cos \\varphi \\ y=\\rho \\sin \\varphi \\end{cases} $$ 于是复数可以表示为三角式 $$ z=\\rho (\\cos \\varphi+ \\mathrm{i}\\sin \\varphi )=\\rho e^{\\mathrm{i}\\varphi} $$ $\\rho$：模，记为$|z|$ $\\varphi$：辐角，记为Arg z 复数的辐角有无穷多个，彼此间差$2k\\pi$，于是我们约定在$[0,2\\pi)$的辐角为主辐角 复数零的辐角没有意义 复数的运算 加减（满足交换律、结合律） $$ z_1\\pm z_2=(x_1 \\pm x_2)+\\mathrm{i}(y_1\\pm y_2) $$ 乘（满足交换律、结合律、分配律） $$ z_1z_2=(x_1x_2-y_1y_2)+\\mathrm{i}(x_1y_2-x_2y_1) $$ $$ z_1z_2=\\rho_1 \\rho_2 e^{\\mathrm{i}(\\varphi_1+\\varphi_2)} $$ 除（是乘的逆运算） $$ \\frac{z_1}{z_2}=\\frac{x_1x_2+y_1y_2}{x_2^2+y_2^2}+\\mathrm{i}\\frac{x_2y_1+x_1y_2}{x_2^2+y_2^2} $$ $$ \\frac{z_1}{z_2}=\\frac{\\rho_1}{\\rho_2} e^{\\mathrm{i}(\\varphi_1-\\varphi_2)} $$ n次幂 $$ z^n=\\rho^n e^{\\mathrm{i}n\\varphi} $$ n次根式 $$ \\sqrt[n]{z}=\\sqrt[n]{\\rho}\\ e^{\\mathrm{i}\\frac{\\varphi}{n}} $$ 复变函数 $$ \\omega=f(z) $$ z为$\\omega$的宗量，$z\\in E$ 区域 在解析函数论中，函数的定义域不是一般的点集，而是满足一定条件的点击，称为区域，用B表示 邻域：以复数$z_0$为圆心，画一个半径为任意小正实数的圆，圆内所有点被称为$z_0$的邻域 内点：若某点及其邻域都属于点集E，那么该点是点集E的内点 外点：若某点及其邻域都不属于点集E，那么该点是点集E的外点 边界点：若某点及其邻域既有属于点集E的点，也有不属于的点，那么该点是点集E的边界点 边界线：全体边界点构成边界线 区域是满足以下两条件的点集 全由内点组成 具有连通性，点集内任意两点都联通，且路径上的点都在该点集 闭区域：区域+边境线组成的点集 连续 $$ 当z\\rightarrow z_0时，f(z)\\rightarrow f(z_0) $$ 导数 实变数$\\Delta x$只能沿着实轴趋近0，但复变数$\\Delta z$可以沿着复平面上任意一曲线逼近0 若极限 $$ \\lim _{\\Delta z \\rightarrow 0}\\frac{f(z+\\Delta z)-f(z)}{\\Delta z} $$ 存在，且与$\\Delta z \\rightarrow 0$的方式无关，则称函数$\\omega=f(z)$在$z$点可导（也称单演），这个极限被称为函数在该点的导数（也叫微商） 若$\\Delta z$沿着平行于实轴方向逼近0，$\\Delta y \\equiv 0,\\Delta z=\\Delta x \\rightarrow 0$ $$ \\lim _{\\Delta z \\rightarrow 0}\\frac{\\Delta\\omega}{\\Delta z}=\\frac{\\partial v}{\\partial x}+\\mathrm{i}\\frac{\\partial u}{\\partial x} $$ 若$\\Delta z$沿着平行于虚轴方向逼近0，$\\Delta x \\equiv 0,\\Delta z=\\mathrm{i}\\Delta y \\rightarrow 0$ $$ \\lim _{\\Delta z \\rightarrow 0}\\frac{\\Delta\\omega}{\\Delta z}=\\frac{\\partial v}{\\partial y}-\\mathrm{i}\\frac{\\partial u}{\\partial y} $$ 要想让在该点可导，这两个极限必须同时存在且相等，于是 $$ \\begin{cases} \\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\ \\frac{\\partial v}{\\partial x}=-\\frac{\\partial u}{\\partial y} \\end{cases} $$ 这个方程被称为柯西-黎曼方程，或者柯西-黎曼条件（C-R条件），这个方程是复变函数可导的必要条件 充要条件为：函数的偏导存在且连续，且满足C-R条件 解析函数 若函数$f(z)$在点$z_0$及其邻域上处处可导，则称$f(z)$在$z_0$点解析 若$f(z)$在区域B上处处解析，那么称$f(z)$是区域B上的解析函数 解析函数是一类具有特殊性质的复变函数 正交性 若函数$f(z)=u+\\mathrm{i}v$在区域B上解析，则 $$ u(x,y)=C_1,v(x,y)=C_2 $$ 是B上的两组正交曲线族，即梯度$\\nabla u$（其直角坐标分量为$\\frac{\\partial u}{\\partial x}$和$\\frac{\\partial u}{\\partial y}$）与梯度$\\nabla v$（其直角坐标分量为$\\frac{\\partial v}{\\partial x}$和$\\frac{\\partial v}{\\partial y}$）正交 调和函数 若函数$f(z)=u+\\mathrm{i}v$在区域B上解析，则$u,v$均为B上的调和函数 若函数$H(x,y)$存在二阶连续偏导数，且满足拉普拉斯方程$\\nabla^2H=0$，则该函数为调和函数 应用 给定一个二元的调和函数，将其看作某个解析函数的实部，利用C-R条件求出对应的虚部，于是就构建了一个解析函数 曲线积分法 凑全微分显式法 不定积分法 多值函数 根式函数、对数函数就是一种多值函数 黎曼面 傅里叶变换 傅里叶级数 我们已经学过，周期函数可以唯一展开为以三角函数为基本函数族的级数 这些三角函数满足任意两个函数的乘积在一个周期内的积分为0，即正交性 利用三角函数的正交性，我们求出展开系数，这个系数被称为傅里叶系数 这个三角函数族是完备的 完备的充要条件：任意一平方可积函数的傅里叶级数均值收敛于它本身 傅里叶级数收敛定理 若一周期函数$f(x)$满足狄里希利条件，则函数的傅里叶级数收敛（也就是函数可以用傅里叶级数表示），且收敛值为 当$x$是$f(x)$的连续点时，级数收敛于$f(x)$ 当$x$是$f(x)$的间断点时，级数收敛于$\\frac{1}{2}[f(x-0)+f(x+0)]$ 傅里叶级数的复数表示 $$ \\sum^{\\infty}_{n=-\\infty}c_ne^{\\mathrm{i}\\frac{n\\pi x}{l}} $$ $$ c_n=\\frac{1}{2l}\\int^l_{-l}f(x)e^{-\\mathrm{i}\\frac{n\\pi x}{l}}\\mathrm{d}x $$ 傅里叶积分 一般来说非周期函数不能展开为傅里叶级数，但是如果我们将这个函数视为周期趋近于无穷的函数 $$ f(x)=\\int_0^{\\infty}A(\\omega)\\cos \\omega \\mathrm{d}\\omega+\\int_0^{\\infty}B(\\omega)\\sin \\omega \\mathrm{d}\\omega $$ 其中 $$ A(\\omega)=\\frac{1}{\\pi}\\int^{\\infty}_{-\\infty}f(\\xi)\\cos \\omega\\xi\\mathrm{d}\\xi $$ $$ B(\\omega)=\\frac{1}{\\pi}\\int^{\\infty}_{-\\infty}f(\\xi)\\sin \\omega\\xi\\mathrm{d}\\xi $$ 上面的公式是傅里叶积分，这两个参数函数称为傅里叶变换式 傅里叶积分定理 若函数$f(x)$在区间$(-\\infty,\\infty)$满足 $f(x)$在任意一有限区间内满足狄里希利条件 在$(-\\infty,\\infty)$绝对可积（即$\\int^{\\infty}_{-\\infty}|f(x)|\\mathrm{d}x$收敛） 则$f(x)$可以用傅里叶积分表示，且积分值为$\\frac{1}{2}[f(x-0)+f(x+0)]$ 傅里叶积分的复数表示 $$ f(x)=\\int^{\\infty}{-\\infty}F(\\omega)e^{\\mathrm{i}\\omega x}\\mathrm{d}\\omega =\\frac{1}{\\sqrt{2\\pi}}\\int^{\\infty}{-\\infty}F(\\omega)e^{\\mathrm{i}\\omega x}\\mathrm{d}\\omega $$ $$ F(\\omega)= \\begin{cases} \\frac{1}{2}[A(\\omega)-\\mathrm{i}B(\\omega)] &amp; (\\omega\\ge 0) \\ \\frac{1}{2}[A(|\\omega|)+\\mathrm{i}B(|\\omega|)] &amp; (\\omega&lt; 0) \\end{cases} $$ $$ F(\\omega)=\\frac{1}{\\sqrt{2\\pi}}\\int^{\\infty}_{-\\infty}f(x)[e^{\\mathrm{i}\\omega x}]^{*}\\mathrm{d}\\omega $$ 这里的$[]^*$是复数的共轭的意思，实际上就是直接给虚部加一个符号 我们称$f(x)$为原函数，$F(\\omega)$为像函数 例题 求矩阵脉冲函数$f(t)=h \\ rect (t/2T)$的傅里叶变换 $$ \\mathscr F[h \\ rect (t/2T)] =\\frac{1}{\\sqrt{2\\pi}}\\int^{\\infty}{-\\infty}h \\ rect (t/2T)e^{-\\mathrm{i}\\omega t}\\mathrm{d}t \\ =\\frac{h}{2\\pi}\\int^{T}{-T}e^{-\\mathrm{i}\\omega t}\\mathrm{d}t \\ =-\\frac{h}{2\\pi \\mathrm{i}\\omega}e^{-\\mathrm{i}\\omega t}|^{T}_{-T} \\ =\\frac{h}{\\pi}\\frac{\\sin \\omega T}{\\omega} $$ 傅里叶变化的基本性质 导数定理 $$ \\mathscr F[f’(x)]=\\mathrm{i}\\omega F(\\omega) $$ 积分定理 $$ \\mathscr F[\\int^{(x)}f(\\xi)\\mathrm{d}\\xi]=\\frac{1}{\\mathrm{i}\\omega} F(\\omega) $$ 相似性定理 $$ \\mathscr F[f(ax)]=\\frac{1}{a} F(\\frac{\\omega}{a}) $$ 延迟定理 $$ \\mathscr F[f(x-x_0)]=e^{-\\mathrm{i}\\omega x_0} F(\\omega) $$ 位移定理 $$ \\mathscr F[e^{\\mathrm{i}\\omega_0 x} f(x)]=f(\\omega-\\omega_0) $$ 卷积定理 $$ \\mathscr F[f_1(x)*f_2(x)]=2\\pi F_1(\\omega)F_2(\\omega) $$ 拉普拉斯变换 拉普拉斯变换 傅里叶积分和傅里叶变换存在的条件是原函数在任意一有限区间满足狄里希利条件，且在$(-\\infty,\\infty)$上绝对可积，这实际上是一个相当苛刻的条件，导致很多常见函数都不满足 而拉普拉斯变换是一种条件更宽泛的变换 拉普拉斯变换常用于初始值问题，即知道某个物理量在初始时刻$t=0$的值$f(0)$，求一段时刻后的情况$f(t)$ 我们置$f(t)=0$，构造一个函数$g(t)$，使得 $$ g(t)=e^{-\\sigma t}f(t) $$ 其中$e^{-\\sigma t}$为收敛因子，正实数$\\sigma$取特别大，以保证$g(t)$在$(-\\infty,\\infty)$绝对可积 于是我们对$g(t)$进行傅里叶变换，得到 $$ G(\\omega)=\\frac{1}{2\\pi}\\int^{\\infty}{0}f(t)e^{-(\\sigma +\\mathrm{i}\\omega )t}\\mathrm{d}t $$ 令$p=\\sigma +\\mathrm{i}\\omega$，$G(\\omega)=\\overline{f}(p)/2\\pi$，则 $$ \\mathscr L[f(t)]=\\overline{f}(p)=\\int^{\\infty}{0}f(t)e^{-pt}\\mathrm{d}t $$ 我们称这个积分为拉普拉斯积分，而函数$\\overline{f}(p)$为$f(t)$的拉普拉斯变换函数，这个变化过程称为拉普拉斯变换，$e^{pt}$称为核 变换条件 在$[0,\\infty)$的任意有限区间上，除了有限个第一类间断点外，函数及其导数是处处连续的 存在常数$M&gt;0$，$\\sigma \\ge0$，使得对任意$t\\in [0,\\infty)$有 $$ |f(t)|&lt;Me^{\\sigma t} $$ 其中$\\sigma$的下界称为收敛横标，记为$\\sigma_0$ 在实际应用中，大部分函数都满足这个条件 性质 $\\overline{f}(p)$是$Re p=\\sigma &gt; \\sigma_0$的半平面上的解析函数 当$|p|\\rightarrow \\infty$，且$|Arg p|\\le \\frac{\\pi}{2}-\\varepsilon(\\varepsilon &gt; 0)$，$\\overline{f}(p)$存在且满足 $$ \\lim_{p\\rightarrow \\infty}\\overline{f}(p)=0 $$ 线性定理 导数定理 积分定理 相似性定理 位移定理 延迟定理 卷积定理 拉普拉斯变换的反演 由像函数转化为原函数的步骤称为反演 有理分式反演法 查表法 黎曼-梅林反演公式","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"概率论","slug":"math/概率论","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:42.963Z","comments":true,"path":"math/概率论/","permalink":"https://reubensun.com/math/%E6%A6%82%E7%8E%87%E8%AE%BA/","excerpt":"","text":"概率论 一：随机事件与概率 事件 事件的概念 样本空间$\\Omega$ 其单元素子集：基本事件 其最大子集：必然事件 最小子集：即空集$\\empty$，不可能事件 事件域$F$ 事件的关系 包含 $A\\subset B$：A被包含在B、B包含A、A发生时B一定发生 相等 $A=B$：A等于B，两事件是同一个集合、描述的是同一件事 互不相容 A和B不能同时发生 事件的运算 基本运算 并 $A \\cup B$：A和B至少有一个会发生 交 $A \\cap B$：A和B同时发生 差 $A-B$：A发生，但B不发生 对立 $\\overline{A}$：即$\\Omega - A$ 运算性质 交换律 结合律 分配律 对偶律（德摩根公式） $\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}$：并的对立等于对立的交 $\\overline{A \\cap B} = \\overline{A} \\cup \\overline{B}$：交的对立等于对立的并 概率 公理化表示 设$\\Omega$为一个样本空间，$F$为$\\Omega$的某些子集组成的一个事件域，对任意事件$A \\in F$，有一个定义在$F$上的实值函数$P(A)$，满足： 非负 $P(A) \\ge 0$ 正则 $P(\\Omega) = 1$ 可列可加 若$A_1,A_2,A_3,…A_n$互不相容，则和的概率等于概率的和 则称$P(A)$为事件$A$的概率，$(\\Omega, F, P)$为概率空间 排列 n中取r，考虑顺序 $$ P^r_n = \\frac{n!}{(n-r)!} $$ 全排列 $$ P_n = n! $$ 注意，这里的P是方案数的意思 组合 n中取r，不考虑顺序 $$ C^r_n=\\binom{n}{r}=\\binom{n}{n-r}=\\frac{n!}{r!(n-r)!} $$ 并规定 $$ C^0_n=1 $$ 频率 $n(A)$：频数，n次重复实验中事件A出现的次数 $f_n(A)$：频率=频数/n 我们认为频率的稳定值就是概率 古典概率 通过样本数进行估计 $$ P(A)=\\frac{事件A所含样本数}{\\Omega 所含样本总数} $$ 几何概率 通过面积、体积进行估计 $$ P(A)=\\frac{S_A}{S_{\\Omega}} $$ 蒙特卡洛方法 概率的性质 $P(\\Omega)=1$ $P(\\empty)=0$ 有限可加性：和的概率等于概率之和 $P(\\overline{A}) = 1-P(A)$ 若$A\\sub B$ $P(B-A) = P(B)-P(A) =P(B) - P(AB)$ $P(B) \\ge P(A)$ $P(A\\cup B)=P(A)+P(B)-P(AB)$ 条件概率 条件概率：在B发生的情况下，A发生的概率 $$ P(A|B) = \\frac{P(AB)}{P(B)} $$ 乘法公式 $$ P(A_1…A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1…A_n-1) $$ 全概率公式 $$ P(A) = \\sum^{n}_{i=1}P(B_i)P(A|B_i) $$ $$ P(A)=P(B)P(A|B)+P(\\overline{B})P(A|\\overline{B}) $$ 贝叶斯公式（用于计算后验概率） $$ P(B|A)=\\frac{P(B)P(A|B)}{P(B)P(A|B)+P(\\overline{B})P(A|\\overline{B})} $$ 独立性 若$P(AB)=P(A)P(B)$，则称AB两事件相互独立 独立重复试验 二：随机变量及其分布 随机变量 定义在样本空间$\\Omega$上的实值函数$X=X(\\omega)$称为随机变量，$\\omega$是样本点 当$\\omega$变化时，$X$会变化，这东西更像一个函数，不要被“变量”给迷惑了 随机事件 随机事件是随机变量的集合 若$B$是某些实数组成的集合，$B\\sub R$，则${X \\in B}$表示随机事件： $$ {\\omega:X(\\omega) \\in B} \\sub \\Omega $$ 特别的，${X \\in B}$可以写成类似${X \\le a }$、${ a &lt; X &lt; b}$ 分布列 $$ p(x_i) = P(X=x_i) $$ X 0 1 2 3 P 1/2 1/4 1/8 1/8 分布函数 设$X$是一个连续随机变量，对于任意实数$x$，称 $$ F(x) = P(X \\le x) $$ 为随机变量$X$的分布函数，并称$X$服从$F(x)$，记为$X \\sim F(x) $ $F(x)$定义域$(-\\infty， \\infty)$，值域$[0, 1]$ $F(x)$满足 单调非减 有界 右连续，即$F(x_0+0)=F(x_0)$ 概率密度函数 设随机变量$X$的分布函数为$F(x)$，如果存在实数轴上一个非负可积函数$p(x)$，使得对任意实数$x$有 $$ F(x) = \\int^x_{-\\infty}p(t)\\mathrm{d}t $$ 则称$p(x)$为$X$的概率密度函数 在$F(x)$可导的点上，$F’(x)=p(x)$ 非负性 正则性 期望 离散 对于离散随机变量$X$，其分布列为$p(x_i), i=1,2,3…n,…$ 若级数不收敛，即 $$ \\sum^n_{i=1}|x_i|p(x_i) &lt; \\infty $$ 则称 $$ E(X) = \\sum^{\\infty}_{i = 1}x_i p(x_i) $$ 为随机变量$X$、或者该分布的数学期望 连续 设连续随机变量$X$的概率密度函数为$p(x)$ 若 $$ \\int^{\\infty}{-\\infty}|x|p(x)\\mathrm{d}x &lt; \\infty $$ 则称 $$ E(X) = \\int^{\\infty}{-\\infty}xp(x)\\mathrm{d}x $$ 为$X$的数学期望 数学期望的物理解释是重心 性质 $$ E[g(X)]=\\sum_{i}g(x_i)p(x_i) $$ $$ E©=c $$ $$ E(aX)=aE(X) $$ $$ E[g_1(X) + g_2(X)]=E[g_1(X)]+E[g_2(X)] $$ 方差 $$ Var(X)=E(X-E(X))^2 $$ 标准差 $$ \\sigma(X) = \\sqrt{Var(X)} $$ 性质 $$ Var(X)=E(X^2)-[E(X)]^2 $$ $$ Var© = 0 $$ $$ Var(aX+b)=a^2Var(X) $$ 切比雪夫不等式 出现大偏差的概率的上下界，与方差呈正比 $$ P(|X-E(X)| \\ge \\epsilon) \\le \\frac{Var(X)}{\\epsilon^2} $$ 若方差为0，则 $$ P(X=E(X))=1 $$ 常见分布 离散 二项分布 两点分布 泊松分布 超几何分布 连续 正态分布 均匀分布 指数分布 伽马分布 贝塔分布 三：多维随机变量及其分布 多维随机变量 如果$X_1(\\omega),X_2(\\omega),X_3(\\omega)…X_n(\\omega)$是定义在同一样本空间$\\Omega = {\\omega}$上的n个随机变量，则称 $$ X(\\omega)=(X_1(\\omega),X_2(\\omega),X_3(\\omega)…X_n(\\omega)) $$ 为N维随机变量 必须为同一样本空间 N个小孩中，身高是一个随机变量，体重也是一个随机变量，（身高，体重）是一个二维随机变量 联合分布函数 $$ F(x_1, x_2,…,x_n)=P(X_1\\le x_1, X_2 \\le x_2, …, X_n \\le x_n) $$ 为n维随机变量$(X_1, X_2, …,X_n)$的联合分布函数 独立性 若 $$ F(x_1, x_2,…,x_n)=\\prod^n_{i=1}F_i(x_i) $$ 则称$X_1, X_2, …,X_n$相互独立（充要条件） 简单说，独立的随机变量，联合概率密度可以直接相乘 期望 $$ E(Z)=\\sum_i \\sum_j g(x_i, y_j)P(X=x_i, Y=y_j) $$ $$ E(Z)=\\int^{\\infty}{-\\infty} \\int^{\\infty}{-\\infty} g(x,y)p(x,y)\\mathrm{d}x\\mathrm{d}y $$ 重期望公式 $$ E(X)=E(E(X|Y)) $$ 四：大数定律与中心极限定理 收敛性 依概率收敛：大数定律 按分布收敛：中心极限定理 依概率收敛 有的随机变量X的概率非常难求，如果可以找到一个简单的随机变量Y的分布来拟合X，可以大幅简化计算 设${X_n}$为以随机变量序列，$X$为一随机变量，对任意$\\varepsilon &gt; 0$，有 $$ P(|X_n - X| \\ge \\varepsilon)\\rightarrow 0 \\ \\ (n\\rightarrow \\infty) $$ 则称序列${X_n}$依概率收敛于X，记作$X_n \\xrightarrow{P} X$ 简单来说，就是概率集中在某个X处 弱收敛 若 $$ \\lim_{n \\rightarrow \\infty}F_n(x)=F(x) $$ 则称${F_n(x)}$弱收敛于$F(x)$，记作$F_n(x) \\xrightarrow{W} F(x)$ 也称序列${X_n}$按分布收敛于X，记作$X_n \\xrightarrow{L} X$ 依概率收敛比按分布收敛，收敛性更强 特征函数 设X是一个随机变量，称 $$ \\varphi(t)=E(e^{itX}) $$ 为X的特征函数 任一随机变量的特征函数总是存在 大数定理 伯努利大数定理 $$ \\lim_{n \\rightarrow \\infty}P(|\\frac{S_n}{n} - p| &lt; \\varepsilon)=1 $$ 意义为：随着n次数的增多，频率会越来越接近概率（随机变量序列的算数平均 依概率收敛到 其均值的算数平均） 中心极限定理 在某些情况下，随机变量和 的分布函数收敛于正态分布","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"微积分","slug":"math/微积分","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:42.962Z","comments":true,"path":"math/微积分/","permalink":"https://reubensun.com/math/%E5%BE%AE%E7%A7%AF%E5%88%86/","excerpt":"","text":"微积分 无穷级数 从有限项之和拓展到无限项之和 一根绳子，日取其半，万世不竭。但无论截取多少次，最后总长应该还是这跟绳子，即 $$ 1=\\frac{1}{2}+\\frac{1}{2^2}+\\frac{1}{2^3}+…+\\frac{1}{2^n}+… $$ 另一个例子 $$ 1+(-1)+1+(-1)+1+(-1)… $$ 等于多少呢？ 到底是 $$ 1+[(-1)+1]+[(-1)+1]…=1+0+0… $$ 还是 $$ (1-1)+(1-1)+…(1-1)+…=0+0+0… $$ 这里出现了矛盾，为此我们建立了无穷级数的概念 常数项级数 常数项无穷级数 给定一个数列${u_n}$，由它构成的表达式 $$ u_1+u_2+…+u_n+… $$ 被称为常数项无穷级数，简称级数，其中$u_n$被称为该级数的通项 该级数的前n项和称为部分和，记为$s_n$ 当n依次取1,2,3…时，部分和构成一个新数列${s_n}$，被称为部分和数列 当n无限增大时，若部分和存在极限，即 $$ \\lim_{n \\rightarrow \\infty}s_n=s $$ 则称该级数收敛，并称极限$s$为该级数的和 若不存在极限，则称该级数发散 讨论级数收敛/发散 部分和公式好求，可以求公式，判断其有无极限 不好求，可以反证 先假设收敛，然后化简公式，最后得出形如$s+x&gt;s$的结论，证否 $$ \\lim_{n \\rightarrow \\infty}s_n=\\lim_{n \\rightarrow \\infty}s_{2n}=s $$ 余项 去掉级数A前n项，得到一级数 $$ u_{n+1}+u_{n+2}+…+u_{n+k}+…=\\sum^{\\infty}_{k=n+1}u_k $$ 称该级数为级数A的余项 若级数A收敛，则余项的前m项之和$s_m’$满足 $$ s_m’=s-s_n $$ 一般，我们将n项后余项和记为$r_n$ $$ s=s_n+r_n $$ 性质 级数中去掉/加上有限个项，不改变级数的收敛性 若一级数收敛，则其通项乘以一个常数$k$，仍然收敛，且和为$ks$ 若两级数收敛，则两通项相加或相减，对应的级数仍然收敛，且和为$s+\\sigma$ 若一级数收敛，在其中加任意个括号，仍然收敛 级数收敛的必要条件是通项在无穷大处有极限，且为0 柯西收敛准则 级数收敛的充要条件 正项级数 若级数中各项非负，则称该级数为正项级数 正项级数的部分和必然是递增的 正项级数收敛的充要条件：其部分和数列有上界 比较审敛法 对于两个正项级数A，B，其通项分别为$u_n,v_n$ 自某项起，$u_n\\ge v_n$，若B发散，则A发散（大于发散则发散） 自某项起，$u_n\\le v_n$，若B收敛，则A收敛（小于收敛则收敛） 比较审敛法的极限形式 对于两个正项级数A，B，其通项分别为$u_n,v_n$，若 $$ \\lim_{n \\rightarrow \\infty}\\frac{u_n}{v_n}=\\lambda $$ 有意义（极限存在或者为无穷大） $0&lt;\\lambda&lt;\\infty$：两级数收敛性相同 $lambda=0$：若B收敛，则A收敛（小于收敛则收敛） $\\lambda=\\infty$：若B发散，则A发散（大于发散则发散） 比值审敛法 也称达朗贝尔判别法 对于一正向级数A，其通项为$u_n$，若 $$ \\lim_{n \\rightarrow \\infty}\\frac{u_{n+1}}{u_n}=\\rho $$ 有意义 $\\rho &lt;1$：A收敛 $\\rho &gt;1$：A发散 $\\rho =1$：A可能收敛也可能发散 根值审敛法 也称柯西判别法 对于一正向级数A，其通项为$u_n$，若 $$ \\lim_{n \\rightarrow \\infty}\\sqrt[n]{u_n}=\\rho $$ 有意义 $\\rho &lt;1$：A收敛 $\\rho &gt;1$：A发散 $\\rho =1$：A可能收敛也可能发散 积分审敛法 对于一正向级数A，其通项为$u_n$，若存在$[1, \\infty)$上单调递减的非负连续函数$f(x)$，使得$u_n=f(n)$，则级数A与反常积分$\\int^{\\infty}_1 f(x)\\mathrm{d}x$收敛性相同 反常积分就是积分域包含无穷上/下限，或者被积函数有瑕点的积分 瑕点：函数值区域无穷的点 奇点：函数值未定的点（比如间断点、无定义点） 任意项级数 交错级数 形如 $$ u_1-u_2+u_3-u_4…(-1)^{n-1}u_n+… $$ 或者 $$ -u_1+u_2-u_3+u_4…(-1)^{n}u_n+… $$ 的级数，称为交错级数 其中$u_n &gt; 0$ 交错级数审敛法 若$u_n \\ge u_{n+1}$ ，且$\\lim_{n \\rightarrow \\infty}u_n=0$ 则级数 $\\sum^{\\infty}_{n=1}(-1)^{n-1}u_n$ 收敛 且其和 $s \\le u_1$ ，其余项 $|r_n|\\le u_{n+1}$ 绝对收敛与条件收敛 对于一级数$A=\\sum^{\\infty}_{n=1}u_n$，其各项取绝对值 得到新正项级数$B=\\sum^{\\infty}_{n=1}|u_n|$ 定理：若B收敛，则A收敛（所以这就是我们为什么要研究正项级数） 若B收敛，A必收敛，此时称A为绝对收敛 若B发散，而A却收敛，此时称A为条件收敛 性质 绝对级数的更序级数仍为绝对级数 更序级数：对某级数的项进行重排后得到的新级数 两个绝对级数的柯西乘积仍然绝对收敛，且其和为$s\\times \\sigma$ 柯西乘积：参考向量相乘，$(a_1, a_2)(b_1,b_2)=(a_1b_1,a_2b_2)$ 函数项级数 前面讨论的常数项级数用于表示无穷多个数的和，当其收敛时，其和为一个常数 而函数项级数用于表示无穷多个函数的和 设定义在集合$D\\subseteq \\mathbf{R}$的一系列函数（称为函数列） $$ u_1(x),u_2(x),u_3(x)…u_n(x)… $$ 称 $$ \\sum^{\\infty}_{n=1}u_n(x) $$ 为函数项级数，$u_n(x)$为通项，前n项和称为部分和 极限函数 若对于某个点$x_0 \\in D$，${ u_n(x_0)}$收敛，则称点$x_0$为该函数列的一个收敛点 所有收敛点构成的集合称为收敛域 若${ u_n(x)}$处处收敛（或逐点收敛），那么就形成了一个定义在D上的函数$f(x)$，D上每一个x都有该函数列一个极限值与之相对应，并称函数$f(x)$为该函数列的极限函数 $$ f(x)=\\lim_{n \\rightarrow \\infty}f_n(x) $$ 极限函数与函数项级数 若点$x_0 \\in D$是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的收敛点 若点$x_0 \\in D$不是某级数的部分和函数列${s_n(x)}$的收敛点，则称$x_0$为该级数的发散点 收敛点的集合称为该级数的收敛域 若级数在D上处处收敛，于是形成了一个定义在D上的和函数$s(x)$ $$ s(x)=\\lim_{n \\rightarrow \\infty}s_n(x) $$ 收敛性 略 幂级数 幂级数是一种特殊的，也是最常用的函数项级数 我们把形如 $$ a_0(x-x_0)^0+a_1(x-x_0)^1+a_2(x-x_0)^2+…a_n(x-x_0)^n+… $$ 的函数项级数称为$x-x_0$的幂级数 其中$x_0$是一个常数，$a_0,a_1,…a_n,…$是幂级数的系数 对任意幂级数总有，当$x=0$时，幂级数收敛，即0是收敛点 阿贝尔定理 若$x=x_0 \\ne 0$且幂级数收敛，则当$|x|&lt;|x_0|$时，幂级数绝对收敛 若$x=x_0 \\ne 0$且幂级数发撒，则当$|x|&gt;|x_0|$时，幂级数发散 收敛半径 幂级数$\\sum^{\\infty}_{n=1}a_nx^n$的收敛域K是以原点为中心的一个区间，在区间内绝对收敛，在区间外发散，区间界可能收敛也可能发散，于是我们称这个收敛域的半径R为收敛半径 对于某个幂级数，若$a_n \\ne 0$，且 $$ \\lim_{n \\rightarrow \\infty}|\\frac{a_{n+1}}{a_n}|=\\rho $$ 若$0&lt;\\rho &lt;\\infty$，收敛半径$R=\\frac{1}{\\rho}$ 若$\\rho =0$，收敛半径$R=\\infty$ 若$\\rho =\\infty$，收敛半径$R=0$ 运算 对于两个幂级数A、B，他们的收敛半径分别为$R_1$、$R_2$ $R=\\min(R_1, R_2)$，则在$(-R, R)$上 幂级数乘以一个常数仍然收敛 A和B的线性组合仍然收敛 A和B的乘积仍然收敛 和函数的性质 在收敛区间内，和函数$s(x)$满足 连续性 可微性 $$ s’(x)=\\sum^{\\infty}_{n=1}na_nx^{n-1} $$ 可积性 $$ \\int^x_0s(t)\\mathrm{d}t=\\sum^{\\infty}_{n=0}\\frac{a_n}{n+1}x^{n+1} $$ 函数展开为幂级数 在前面几节，我们讨论了函数项级数（尤其是幂级数）在收敛区间内可以得到一个和函数 那么，能不能给定一个（和）函数，将其展开为幂级数呢？ 幂级数可以视为多项式的推广，那么我们能不能用多项式来逼近（和）函数呢？ 泰勒级数 若$f(x)$在区间$(x_0-R, x_0+R)$能展开成幂级数，$f(x)$在$x=x_0$处有任意阶导数，那么幂级数有且仅有一个展开形式，且幂级数的系数为 $$ a_n=\\frac{1}{n!}f^{(n)}(x_0) $$ n取0，1，2… 我们称这个幂级数为函数$f(x)$在$x_0$处的泰勒级数，记作 $$ f(x)\\sim f(x_0)+\\frac{f’(x_0)}{1!}(x-x_0)+\\frac{f’'(x_0)}{2!}(x-x_0)^2+…+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+… $$ 展开条件 若$f(x)$在区间$(x_0-R, x_0+R)$处有任意阶导数，那么$f(x)$在该区间内能展开称泰勒级数的充要条件为 $$ \\lim _{n \\rightarrow \\infty}R_n(x)=0 $$ $R_n(x)$：n以后的余项 推论 若存在一个常数$M&gt;0$，使得任意x属于区间$(x_0-R, x_0+R)$，都有当n趋近于无穷时，余项的绝对值小于M，则函数可以在该区间展开成泰勒级数 麦克劳林展开式 泰勒公式的特例，$x_0=0$ $$ f(x)=f(0)+\\frac{f’(0)}{1!}x+\\frac{f’'(0)}{2!}x^2+…++\\frac{f^{(n)}(0)}{n!}x^n+… $$ 经典展开 $$ e^x=1+\\frac{x}{1!}+\\frac{x^2}{2!}+…+\\frac{x^n}{n!}+… $$ $$ \\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-…+(-1)^{n-1}\\frac{x^{2n-1}}{(2n-1)!}+… $$ 傅里叶级数 使用三角函数来拟合一个已知函数 三角级数 一般来说，形如 $$ \\frac{a_0}{2}+\\sum^{\\infty}_{n=1}(a_n\\cos nx+b_n \\sin nx) $$ 的级数被称为三角级数 正交性 函数系 $$ {1,\\cos x, \\sin x, \\cos 2x, \\sin 2x, …,\\cos nx, \\sin nx,…} $$ 被称为基本三角函数系 正交性：该函数系任意两个不同的函数的乘积，在区间$[-\\pi,\\pi]$上的积分等于0 三角级数的系数 $$ a_n=\\frac{1}{\\pi}\\int^{\\pi}_{-\\pi}f(x)\\cos nx \\ \\mathrm{d}x $$ $$ b_n=\\frac{1}{\\pi}\\int^{\\pi}_{-\\pi}f(x)\\sin nx \\ \\mathrm{d}x $$ 这两个式子被称为欧拉-傅里叶公式，由这个公式确定的系数被称为傅里叶系数 对任意在区间$[-\\pi,\\pi]$上可积函数$f(x)$都可以求出其傅里叶级数，但这个级数不一定收敛，即使收敛也不一定收敛于$f(x)$ 于是我们需要知道什么时候$f(x)$可以被展开成收敛在$f(x)$的傅里叶级数 收敛定理（狄里希利充分条件） 对于一个周期为$2\\pi$的周期函数，如果它满足狄里希利条件： 在一个周期内连续，或者只有有限个第一类间断点 第一类间断点：左右极限都存在，但该点函数值或该点无定义 在一个周期内之多有有限个严格极值点 则$f(x)$的傅里叶级数收敛，且 当$x$是$f(x)$的连续点时，级数收敛于$f(x)$ 当$x$是$f(x)$的间断点时，级数收敛于$\\frac{1}{2}[f(x-0)+f(x+0)]$ 其他概念 周期延拓 正弦级数（奇函数） 余弦级数（偶函数） 奇延拓 偶延拓 复数表示 欧拉公式 $$ \\sin z=\\frac{e^{iz}-e^{-iz}}{2i} $$ $$ \\cos z=\\frac{e^{iz}+e^{-iz}}{2} $$ 记 $$ \\frac{a_0}{2}=c_0 $$ $$ \\frac{a_n-ib_n}{2}=c_n $$ $$ \\frac{a_n+ib_n}{2}=c_{-n} $$ 则傅里叶级数简化为 $$ \\sum^{\\infty}_{n=-\\infty}c_ne^{i\\frac{n\\pi x}{l}} $$ $$ c_n=\\frac{1}{2l}\\int^l_{-l}f(x)e^{-i\\frac{n\\pi x}{l}}\\mathrm{d}x $$ 多元函数 方向导数 设点$P_0(x_0,y_0)\\in \\mathbf{R}^2$，$l$是平面上的一非零向量，其单位向量为$e_i=\\cos \\alpha \\mathbf {i}+\\cos \\beta \\mathbf {j}$，函数$z=f(x,y)$在点$P_0$的某邻域内有定义，$P_0$为直线L上的一个定点（直线L平行于向量$l$），若极限 $$ \\lim_{t\\rightarrow 0}\\frac{f(x_0+t\\cos \\alpha,y_0+t\\cos \\beta)-f(x_0,y_0)}{t} $$ 存在，则称此极限为函数$z=f(x,y)$在直线L上点$P_0$处，延方向$l$的方向导数 梯度 方向导数刻画了函数在点$P_0$处沿着方向$l$的变化快慢程度，我们希望知道在该点，哪一个方向变化最快，于是引入了梯度 设函数$z=f(x,y)$在点$P_0(x_0,y_0)$处可偏导，则称向量 $$ f_x(x_0,y_0)\\mathbf{i}+f_y(x_0, y_0)\\mathbf{j} $$ 为函数$z=f(x,y)$在点$P_0(x_0,y_0)$处的梯度，记作$\\mathbf{grad}f(x_0,y_0)$，或$\\nabla f(x_0,y_0)$ 当方向为$(\\frac{\\partial z}{\\partial x}|_P,\\frac{\\partial z}{\\partial y}|_P)$时，变化速度最快 物理意义 梯度方向=法线方向","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"球函数","slug":"math/球函数","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.441Z","comments":true,"path":"math/球函数/","permalink":"https://reubensun.com/math/%E7%90%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"球函数 三大偏微分方程 拉普拉斯方程（椭圆） 热方程（抛物线） 波方程（双曲线） 常微分方程 含有未知函数的导数（含高阶导数）或微分的等式，称为微分方程 若未知函数是一元函数，则该函数为常微分方程 若导数的阶数为1，那么称为一阶微分方程 球坐标系 讨论常微分方程时，边界是记为重要的，而当边界是球形时，球坐标系会更好用 直角坐标系上点$P(x,y,z)$，也可以用三个有次序的数$(r,\\theta,\\varphi)$表示 $$ \\begin{cases} x=r \\sin \\theta \\cos \\varphi \\ y=r \\sin \\theta \\sin \\varphi \\ z=r\\cos \\theta \\end{cases} $$ $$ \\begin{cases} r=\\sqrt{x^2+y^2+z^2} \\ \\theta=\\arccos \\frac{z}{r} \\ \\varphi=\\arctan \\frac{y}{x} \\end{cases} $$ 拉普拉斯方程 拉普拉斯算符 多元函数用梯度表示不同方向函数值变化的速度，拉普拉斯算符$\\nabla$就是对多元函数求梯度 对梯度再次做拉普拉斯算符$\\nabla ^2$，就是求梯度的散度 在直角坐标系下，二阶拉普拉斯算符为 $$ \\nabla^2=\\frac{\\partial ^2}{\\partial x^2}+\\frac{\\partial ^2}{\\partial y^2}+\\frac{\\partial ^2}{\\partial z^2} $$ 在球坐标下，二阶拉普拉斯算法为（将xyz带入，化简得到） $$ \\nabla^2=\\frac{1}{r^2}\\frac{\\partial}{\\partial r}(r^2\\frac{\\partial}{\\partial r}) +\\frac{1}{r^2\\sin \\theta }\\frac{\\partial}{\\partial \\theta}(\\sin \\theta \\frac{\\partial}{\\partial \\theta}) +\\frac{1}{r^2\\sin^2 \\theta }\\frac{\\partial^2}{\\partial \\varphi^2} $$ 拉普拉斯方程 拉普拉斯方程$\\nabla^2 u=0$，表示的物理含义是：在各个方向上（比如二维直角坐标系，就是x和y方向）加速度合为0 这意味着什么？一个不与外界进行能量交换的系统，其拉普拉斯方程为0 一个不受外力的系统，其整体加速度为0 一个不与外界传热的系统，其整体能量传播为0 一个理想的简谐振动 闭合磁场、电场 我们称拉普拉斯方程为0的函数叫做Harmonic 球坐标系下的拉普拉斯方程 函数$u(r,\\theta,\\varphi)$的拉普拉斯方程为 $$ \\nabla^2u=\\frac{1}{r^2}\\frac{\\partial}{\\partial r}(r^2\\frac{\\partial u}{\\partial r}) +\\frac{1}{r^2\\sin \\theta }\\frac{\\partial}{\\partial \\theta}(\\sin \\theta \\frac{\\partial u}{\\partial \\theta}) +\\frac{1}{r^2\\sin^2 \\theta }\\frac{\\partial^2 u}{\\partial \\varphi^2}=0 $$ 我们将距离和方向分离，得到 $$ u(r,\\theta,\\varphi)=R®Y(\\theta,\\varphi) $$ $R®$表示距离 $Y(\\theta,\\varphi)$表示方向，被称为球函数 带入可得 $$ \\frac{Y}{r^2}\\frac{\\mathrm{d}}{\\mathrm{d} r}(r^2\\frac{\\mathrm{d} R}{\\mathrm{d} r}) +\\frac{R}{r^2\\sin \\theta }\\frac{\\partial}{\\partial \\theta}(\\sin \\theta \\frac{\\partial Y}{\\partial \\theta}) +\\frac{R}{r^2\\sin^2 \\theta }\\frac{\\partial^2 Y}{\\partial \\varphi^2}=0 $$ 移项、化简可得 $$ \\frac{1}{R}\\frac{\\mathrm{d}}{\\mathrm{d} r}(r^2\\frac{\\mathrm{d} R}{\\mathrm{d} r}) =-\\frac{1}{\\sin \\theta Y}\\frac{\\partial}{\\partial \\theta}(\\sin \\theta \\frac{\\partial Y}{\\partial \\theta}) -\\frac{1}{Y}\\frac{1}{\\sin^2 \\theta }\\frac{\\partial^2 Y}{\\partial \\varphi^2} $$ 我们发现，这个方程左边是与$R$有关的函数，右边是与$\\theta,\\varphi$有关的函数，显然两者不可能相等，除非他们同时等于一个常数 我们令这个常数为$l(l+1)$，于是得到两个方程 $$ \\frac{\\mathrm{d}}{\\mathrm{d} r}(r^2\\frac{\\mathrm{d} R}{\\mathrm{d} r})-l(l+1)R=0 $$ $$ \\frac{1}{\\sin \\theta }\\frac{\\partial}{\\partial \\theta}(\\sin \\theta \\frac{\\partial Y}{\\partial \\theta}) +\\frac{1}{\\sin^2 \\theta }\\frac{\\partial^2 Y}{\\partial \\varphi^2} +l(l+1)Y=0 $$ 第二个方程叫做球函数方程 如果我们进一步分离变量，令 $$ Y(\\theta,\\varphi)=\\Theta(\\theta)\\Phi(\\varphi) $$ 带入球函数方程，化简得到两个常微分方程 $$ \\Phi’'+\\lambda \\Phi=0 $$ $$ \\sin \\theta \\frac{\\mathrm{d}}{\\mathrm{d} \\theta}(\\sin \\theta \\frac{\\mathrm{d \\Theta}}{\\mathrm{d} \\theta})+[l(l+1)\\sin^2\\theta-\\lambda]\\Theta=0 $$ 连带勒让德方程 上一步我们得到了两个常微分方程，第一个方程和自然周期条件构成本征值问题，在经过很多步的推导化简（感觉这些内容对我来说有些超纲），可以把第二个式子改写为 $$ (1-x^2)\\frac{\\mathrm{d}^2\\Theta}{\\mathrm{d}x^2}-2x\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}x}+[l(l+1)-\\frac{m^2}{1-x^2}]\\Theta=0 $$ 这个式子被称为$l$阶连带勒让德方程 这个式子的解，即函数$\\Theta$的表达式为连带勒让德函数 级数解法 用球坐标系对拉普拉斯方程进行分离变数，得到了连带勒让德方程等特殊的函数方程，这些方程大多都是线性二阶常微分方程，很难用常规办法解，但可以用级数解法解出 常点与奇点 对于一个复变函数的线性二阶常微分方程 $$ \\frac{\\mathrm{d}^2w}{\\mathrm{d}z^2}+p(z)\\frac{\\mathrm{d}w}{\\mathrm{d}z}+q(z)w=0 $$ 若系数函数$p(z)$、$q(z)$在点$z_0$的邻域中是解析的，则点$z_0$叫做该方程的常点，若点$z_0$是奇点，则点$z_0$叫做该方程的奇点","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"线性代数","slug":"math/线性代数","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.441Z","comments":true,"path":"math/线性代数/","permalink":"https://reubensun.com/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","excerpt":"","text":"线性代数 一：线性方程组 概念 线性方程 线性方程组 系数 解：一组能让方程左右相等的数 解集：方程组的所有解的集合 等价：若两个线性方程组拥有相同解集，则两者等价 相容：方程组有一个或无穷多个解 不相容：方程组无解 矩阵 方程组 $$ \\begin{gathered} x_1-2x_2+x_3=0 \\\\ 2x_2-8x_3=8 \\\\ 5x_1-5x_3=10 \\end{gathered} $$ 的系数矩阵为 $$ \\left[ \\begin{matrix}1&amp;-2&amp;1\\\\ 0&amp;2&amp;-8\\\\ 5&amp;0&amp;-5\\end{matrix} \\right] $$ 增广矩阵为 $$ \\left[ \\begin{matrix}1&amp;-2&amp;1&amp;0\\\\ 0&amp;2&amp;-8&amp;8\\\\ 5&amp;0&amp;-5&amp;10\\end{matrix} \\right] $$ 这个增广矩阵，3行4列，是一个3x4的矩阵 我们对增广矩阵进行多次矩阵运算，于是得到 $$ \\left[ \\begin{matrix}1&amp;0&amp;0&amp;1\\\\ 0&amp;1&amp;0&amp;0\\\\ 0&amp;0&amp;1&amp;-1\\end{matrix} \\right] $$ 于是原方程有且仅有一个解$(1,0,-1)$ 初等行变换 也就是行简化 倍加：a=a+nb，把某行加上某一行的倍数 对换：swap(a,b)，把某两行对换 倍乘：a *= n (n!=0)，把某行所有元素乘以一个非零的数 阶梯矩阵 形如 $$ \\left[ \\begin{matrix}x&amp;&amp;&amp;\\\\ 0&amp;x&amp;&amp;\\\\ 0&amp;0&amp;x&amp;\\end{matrix} \\right] $$ 的矩阵，被称为阶梯形 $x$为先导元素，非零 若先导元素均为1，而且该列只有先导元素非零，则矩阵被称为简化阶梯形 $x$所在的位置被称为主元位置，拥有主元的列被称为主元列 $*$取任意值 行简化 任何非零矩阵都可以行简化为阶梯形矩阵 简化阶梯形具有唯一性 线性方程的解 对增广矩阵运用行简化，得到一个简化阶梯形 $$ \\left[ \\begin{matrix}1&amp;0&amp;-5&amp;1\\\\ 0&amp;1&amp;1&amp;4\\\\ 0&amp;0&amp;0&amp;0\\end{matrix} \\right] $$ 对应的线性方程组为 $$ \\begin{gathered} x_1-5x_3=1 \\\\ x_2+x_3=4 \\\\ 0=0 \\end{gathered} $$ 其中$x_1,x_2$为基本变量，$x_3$为自由变量 于是可以得到线性方程组的通解 $$ \\begin{cases} x_1=1+5x_3&amp;\\\\ x_2=4-x_3&amp;\\\\ x_3是自由变量 \\end{cases} $$ 向量方程 向量 n维向量可以写成nx1列矩阵的形式 $$ \\mu=\\begin{bmatrix} 1\\\\ 1\\\\ \\vdots \\\\ 1 \\end{bmatrix} $$ 所有元素为0的向量称为零向量 当且仅当两个向量对应元素全相等时，两向量相等 为了方便书写，我们会将n维向量横着写（注意！用的是括号，并且相邻元素间用逗号隔开） $$ (1,1,…,1) $$ 向量方程 向量方程： $$ x_1\\mathbf{a_1}+x_2\\mathbf{a_2}+…+x_n\\mathbf{a_n}=\\mathbf{b} $$ 的解，等同于增广矩阵为 $$ \\begin{bmatrix}\\mathbf{a_1}&amp;\\mathbf{a_2}&amp;…&amp;\\mathbf{a_n}\\end{bmatrix} $$ 的线性方程组的解 $Span{\\nu}$ $Span{\\nu_1,\\nu_2,…,\\nu_n }$ 矩阵运算 $$ A\\mathbf{x}= \\begin{bmatrix}\\mathbf{a_1}&amp;\\mathbf{a_2}&amp;…&amp;\\mathbf{a_n}\\end{bmatrix} \\begin{bmatrix}x_1\\\\ x_2\\\\ \\vdots \\\\ x_n\\end{bmatrix} =x_1\\mathbf{a_1}+x_2\\mathbf{a_2} + …+x_n\\mathbf{a_n} $$ 当且仅当左边的列数等于右边的行数，才可以运算（横乘竖） 矩阵方程 $$ A\\mathbf{x}=\\mathbf{b} $$ 齐次线性方程组 若线性方程的常数项为0，则称该线性方程为齐次的，可以写成 $$ A\\mathbf{x}=\\mathbf{0} $$ 的形式 齐次线性方程必有一个平凡解，即$\\mathbf{x}=\\mathbf{0}$ 齐次线性方程有非平凡解，当且仅当方程组至少有一个自由变量 要判断$A\\mathbf{x}=\\mathbf{0}$有无非平凡解 写出方程组的增广矩阵$[A, \\mathbf{0}]$ 将矩阵化简为简化阶梯形 若存在某一行全为0（该行对应的变量就是自由变量），则有非平凡解 哪些不全为0的行所对应的变量称为基本变量 线性无关 若线性方程仅有平凡解，则该组向量（矩阵各列）线性无关 矩阵 要判断某个矩阵各列是否线性无关： 写出矩阵的增广矩阵$[A, \\mathbf{0}]$ 对矩阵进行行简化 若矩阵没有自由变量，则说明各列线性无关 向量的集合 一个向量的集合线性无关的条件：当且仅当向量不是零向量 两个向量的集合线性相关的条件：当且仅当某个（非零）向量是另一个（非零）向量的倍数 多个向量的集合线性相关的条件：当且仅当至少有一个向量是其他向量的线性组合 若一个向量组中向量个数多于每个向量的元素个数，那么这个向量组线性相关（充分条件） 能看出，两个向量属于多个向量 线性变换 变换 $$ A\\mathbf{x}=\\mathbf{b} $$ 一个n维向量左乘一个m行n列的矩阵，会得到一个m维的向量 我们称$\\mathrm{R}^n \\rightarrow \\mathrm{R}^m$这个过程为一个变换，也可以叫做函数、映射 变化的规则为$T$，$\\mathrm{R}^n$被称为$T$的定义域，$\\mathrm{R}^m$被称为$T$的余定义域 对于$\\mathrm{R}^n$中的一个向量$x$，其在$\\mathrm{R}^m$中的向量$T(x)$被称为$x$的像，所有的像的集合被称为值域 线性变换 若定义域中的一切向量满足 $T(\\mathbf{u}+\\mathbf{v})=T(\\mathbf{u})+T(\\mathbf{v}) $ $T(c\\mathbf{u})=cT(\\mathbf{u})$ 则称该变换为线性变换 线性变换的性质： $T(\\mathbf{0})=\\mathbf{0}$ $T(c\\mathbf{u}+d\\mathbf{v})=cT(\\mathbf{u})+dT(\\mathbf{v}) $ 若n等于m，$T(\\mathbf{x})=r \\ \\mathbf{x}$ 若r &gt; 1，则称为拉伸变换 若0 &lt; r &lt; 1，则称为压缩变化 变化矩阵 二维空间的变化矩阵为，$(x_1, y_1)$为变化后单位正方形右下角的位置，$(x_2, y_2)$为变化后单位正方形左上角的位置 $$ \\left[ \\begin{matrix}x_1&amp;x_2\\\\ y_1&amp;y_2\\end{matrix} \\right] $$ 二：矩阵代数 矩阵 对于一个mxn的矩阵，也就是m行n列的矩阵，我们可以写作 $$ A=[\\mathbf{a}_1 \\ \\mathbf{a}_2\\ \\cdots \\mathbf{a}_n] $$ 其中 矩阵A的对角元素为$a_{11}, a_{22}, \\cdots$，他们组成了矩阵A的主对角线 对角矩阵：非对角线元素全为0的矩阵 零矩阵：元素全为0的矩阵，根据其尺寸，可以写为$\\mathbf{0}_{m \\times n}$ 矩阵运算 矩阵相等：维数相同且对应元素均相同 矩阵相加：维数相同的矩阵才能相加，结果为对应元素相加 矩阵标量乘：矩阵所有元素乘一个标量","categories":[{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"}],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"光学：几何光学","slug":"optics/几何光学","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.440Z","comments":true,"path":"optics/几何光学/","permalink":"https://reubensun.com/optics/%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6/","excerpt":"","text":"四：几何光学 几何光学，也被称为射线光学（Ray optics），忽略光的波动性，以几何方法来研究光在均匀介质中的传播 基本定律 几何光学包含两个部分，一个是光学三定律，定性描述了几何光学中光的传递，一个是费马原理，定量计算了光的传播（通常为光学元件间近轴传播） 光学三定律 光在均匀介质中沿直线传播 光的反射、折射定律 反射角等于入射角 入射角与折射角的正弦值之比等于折射率之比（Snell定律） 光独立传播，光路可逆 Shell定律 $$ n_i\\sin \\theta_i= n_t \\sin \\theta_t $$ 反射光线是最短路径（亚历山大） 光程 由于光在介质中移动速度不同，为了方便描述光在介质中移动某段距离要花费的时间，我们引入了光程长度。于是我们在计算时就可以认为光速永远不变，只是光的传播距离与现实距离不同 光程长度（Optical path length，OPL）：光在介质中传播长度与介质的折射率的乘积 $$ [l]=ns $$ 光程描述的是：光在该介质中移动真实距离所花费的时间，如果在真空中能运动多远的距离 费马原理 开创了以“路径积分，变分原理“来描述物理规律的思维方式 费马原理（也叫最短时间原则）： 光在两点间的传播路径是最短路径（最短路径可以由多条，但是其光程相同） 两点间的光程恒定（光程函数的导数为0） 费马原理可以推导出光学三定律 在均匀介质中折射率为常数，光在两点间的传播路径为最短距离，又由于两点间直线距离最短，因此光沿着直线传播 由于反射点、折射点都在交线OO‘上，因此他们在同一平面内（在交线上距离最短） 由于两点间直线最短，沿着反射轴做反射光线的对称直线，发现当反射角等于入射角时，入射光线和对称光线为一条直线 用折射率和三角形长度表示折射光线的光程，该光程应该是最小值，因而导数为0，求导化简得出Shell公式 透镜成像 根据费马原理，两点间光沿着光程最短的路径传播，这说明凸透镜成像中每一条光线的光程都相等 实际上，凹透镜散射光光线的反向延长线与入射光组成的总光程也是根根相等的 等光程 等光程：如果一个光学器械每条光线都是等光程的（比如透镜），我们称之为等光程，他们可以严格成像 不等光程的器械不能成像，近似光程的器械能成模糊的像 费马原理的应用 反曲椭球面生成平行光：从椭球面焦点发生灯光，会生成平行光，由于平型光不会汇聚，因此他们的光程为无穷大 光在椭球面内反射：在椭球面内，两个焦点间光程为恒定值（毕竟椭圆上的点到两个焦点距离的和为焦距） 双曲透镜将平行光汇聚到一点 半球面反射 成像 光学系统（Optical system）：一个包含一个或多个光学元器件的系统 物体空间（Object space）：入射光线所在的区域 图像空间（…/…/images space）：出射光线所在的区域 理想光学系统（ideal optical system）：物体能被完美地成像，比如平面镜反射 共轭点（conjugate points）：物体点和图像点组成共轭点 对于一个理想光线系统，每对共轭点的光程（后面以OPL指代）均相同 实像：物体发出的光经过反射、折射后，汇聚成新的像，被称为实像（比如凸透镜） 虚像：物体发出的光经过反射、折射后，变成了发散光线，将其反向延长得到的像，被称为虚像（比如凹透镜、平面镜） 单心性 从一点发射光源，经过光学系统后，仍然汇聚为一点，那么这个光学系统满足单心性 平面镜反射满足单心性，折射不满足 不满足单心性，物像和图像不共轭，不能完美成像 全反射 当光从光密射入光疏，且角度大于某个值后，只发生反射，不发生折射 光导纤维 不过光疏介质介质中并没有没有透射波，但这些透射波与界面平行，且振幅在垂直界面方向按指数衰减，于是很快就没了，这个波被称为隐失波 人眼为什么能看到虚像 人为什么能看到东西？是因为物体经过眼睛，在视网膜上成了像，在这里，眼睛是成像系统 我们在讨论实像虚像时，提到的光学系统那些透镜们，于是虚像的全称应该是“某物体在xxx光学系统的虚像”，人眼并不是看到了“某物体在xxx光学系统的虚像”，而是在该处，经由人眼，看到了一个实像 理想光学系统 共轭性：物像种每个点、线、面都能在图像上找到对应的点、线、面 等光程 棱镜成像 球面成像 尽管球面不是一个很好的光学器械，但比较好加工（其实现在加工技术已经很好了，很多人的眼镜都是非球面的），于是球面成像是几何光学很重要的一块 光轴：若一个光学系统由球面组成，各球心的连线在一条直线上，该光学系统被称为共轴球面系统，这条直线被称为光轴 球差 我们上面提到球面不是一个很好的光学器械，因为透镜成像有球差 透镜成像，靠近光轴的光会被汇聚在靠后的位置，远离光轴的光会被汇聚在靠前的位置，也就是透射光经过球面成像后不再汇聚为一点，单心性被破坏 近轴条件 由于球差的存在，我们假设光只在近轴处传播，于是“消除”了球差 近轴条件（paraxial condition）：入射角与光轴（optical axis）的夹角（用$u$表示）小于等于$5^{\\circ}$ 此时，三角函数可以近似 $$ \\cos u \\approx 1 \\ \\sin u \\approx u \\ \\tan u \\approx \\sin u $$ 消球差平面（Aplanatic Surface）：允许所有光线在两点之间以相等的OPL传播的表面 符号法则 简单来说，若左侧的光射向一个左凸的球面在右侧汇聚，距离都是正的 设入射光从左向右 若入射点在顶点（球面和光轴的交点）左侧，那么入射点到顶点的距离为正，反之为负 若汇聚点在顶点右侧，那么汇聚点到顶点的距离为正，反之为负 若球心在顶点左侧，则半径为负，反之为正 绘图标准 基准点：球面顶点(单球面系统)、焦点 基准线：光轴、各折射点的法线 长度量：由指定原点量起顺光线传播方向为正，反之为负。 高度量：垂直向上为正，反之为负。 角度量规定：以锐角衡量，以主光轴顺时针转到光线为正。 规定：图上只标绝对值。 球面反射 Reflection at spherical surfaces $$ \\frac{1}{-s}+\\frac{1}{-s’}=-\\frac{2}{r} $$ 光轴（QA这条线） 焦点（image focus，图中$\\mathrm{F’}$）：平行于光轴的光线打到球面上，会汇集到一点，这个个点被称为焦点 物体焦距（Object focal length，用$f$表示） 图像焦距（…/…/images focal length，用$f’$表示） 在球面反射，物体焦距和图像焦距是相等的 $$ f= \\lim_{s’ \\rightarrow \\infty}s \\ f’= \\lim_{s \\rightarrow \\infty}s’ \\ \\frac{1}{s}+\\frac{1}{s’}=\\frac{1}{f} $$ 球面折射 Refraction at spherical surfaces $$ \\frac{n_1}{-s}+\\frac{n_2}{s’}=\\frac{n_2-n_1}{r} \\equiv \\Phi $$ 光焦度（用$\\Phi$表示）：用与描述光线系统对光线的曲折能力 高斯透镜公式（Gaussian Lens Formula） $$ \\frac{f}{s}+\\frac{f’}{s’}=1 $$ 牛顿透镜公式（Newton form of Lens Formula） $$ x_0x_i=ff’ $$ 离轴点成像 Imaging for off-axis points 就是y比较大，导致不能使用三角函数近似 薄透镜成像 透镜：由两个同轴折射球组成的镜子，根据球心位置，分为凸透镜（convex lens）和凹透镜（concave lens） 薄透镜（Thin lens）：中心半径和曲率厚度可以忽略不记的透镜 光轴（Optic axis）：连接两个曲面中心的轴 光学中心（Optic center）：两个球面的基准点（vertex）视为重合，重合点就是光学中心 凸透镜分为双凸、平凸、弯凸三种 凹透镜分为双凹、平凹、弯凹三种 透镜公式 $$ \\frac{n_1}{-s_1}+\\frac{n_2}{s_2’}=\\frac{n_0-n_1}{r_1}+\\frac{n_2-n_0}{r_2}\\equiv \\Phi $$ 焦平面 焦平面（Focal plane）：垂直于光轴且经过焦点的平面 前焦平面（front focal plane）：光射入透镜的面 后焦平面（back focal plane）：光从透镜射出的面 透镜使得光的落点与入射角有关，且满足 $$ y=f \\cdot \\tan\\theta \\approx f\\cdot \\theta $$ 用透镜成像等于两倍的傅里叶变换 光阑 光阑（stop）：限制（limit）成像光束的器件，比如透镜（lens）、光圈（aperture）、窗口片（the frame of windows） 光圈 光圈（aperture stop，下图DD’）：用于限制光线宽度的期间 Field stop：用于限制成像区域和方位 景深 景深（Depth of field/focus）：聚焦深度，入射点P在光轴方向移动，移动距离$\\Delta x$在景深范围内，图像是清晰的 能看出图中$P_1$过早聚焦，$P_2$过晚聚焦，他们相对于$P$，都显得比较模糊 在物体空间的最大$\\Delta x$被称为Depth of field 在图像空间的最大$\\Delta x$被称为Depth of focus 相对孔径 相对孔径（Relative aperture）：光圈的直径（用$D$表示）和焦距（focal length，用$f$表示）的比值 $D/f$越大，说明光学系统收集光的能力越强 f-number 相对孔径的倒数，意义为焦距是直径的多少倍 比如一个光学系统，焦距160nm，光圈直径20nm，那么它的f-number等于160/20=8，记作$f/8$","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：反射和折射","slug":"optics/反射和折射","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.440Z","comments":true,"path":"optics/反射和折射/","permalink":"https://reubensun.com/optics/%E5%8F%8D%E5%B0%84%E5%92%8C%E6%8A%98%E5%B0%84/","excerpt":"","text":"五：反射与折射 内容概述 光在单层各项同性表面的反射与折射 菲涅尔方程 全内反射 相位突变，布鲁斯特角 菲涅尔方程 菲涅尔方程 各项同性介质（Isotropic medium）：折射率处处相同的材质 光密介质：折射率高的介质（这是一个相对概念） 光疏介质：折射率低的介质（这是一个相对概念） 在几何光学中的那些反射方程，只能得到入射光、反射光、折射光间的方向关系 而菲涅尔方程（Fresnel Equations）可以求出反射光、折射光的振幅、相位、偏振 菲涅尔方程的边界条件表明：磁场和电场在边界处连续，也就是入射光的电场磁场=反射光+折射光的电场磁场 我们将入射光的电场分为两个部分，方向满足右手正交系 平行（parallel）于平面的电场$E_p$ 垂直（senkrecht）与平面向外的电场$E_s$ 经过复杂的推导，我们能得到 $$ r_p=\\frac{E_{1p}’}{E_{1p}}=\\frac{\\tan(\\mathrm{i_1}-\\mathrm{i_2})}{\\tan(\\mathrm{i_1}+\\mathrm{i_2})} \\\\ r_s=\\frac{E_{1s}’}{E_{1s}}=-\\frac{\\sin(\\mathrm{i_1}-\\mathrm{i_2})}{\\sin(\\mathrm{i_1}+\\mathrm{i_2})} \\\\ t_p=\\frac{E_{2p}}{E_{1p}}=\\frac{2\\cos \\mathrm{i_1}\\sin \\mathrm{i_2}}{\\sin(\\mathrm{i_1}+\\mathrm{i_2}) \\cos (\\mathrm{i_1}-\\mathrm{i_2})} \\\\ t_s=\\frac{E_{2s}}{E_{1s}}=\\frac{2\\cos \\mathrm{i_1}\\sin \\mathrm{i_2}}{\\sin(\\mathrm{i_1}+\\mathrm{i_2})} $$ $r$：反射光 $t$：折射光（透射光，Transmission） 于是我们能得出几个结论 反射光、折射光与入射角、折射率有关 $p$与$s$是独立的 菲涅尔方程的含义 外反射 外反射（External reflection）：从折射率低射向折射率高，比如从空气射向玻璃 我们发现，随着入射角的增加 折射一直是正数，并且两个方向没有明显差异 $r_s$一直是负数，而$r_p$先正后负 布鲁斯特角（Brewster’s angle，图中$i_B$），在此处$r_p$发生了一个$180^{\\circ}$的相变 当入射角为$90^{\\circ}$时，也就是掠射角（grazing angles），我们发现此时完全不发生折射，只发生反射 对于一个湿表面，远看发现很亮，近看却发现变暗了 远看水面，大部分光来自反射，于是波光粼粼；近看水面，折射部分加强，于是清澈见底 让入射角为$0^{\\circ}$，也就是垂直入射时，$r_p$完全反向反射回来，折射很微弱 内反射 内反射（Internal reflection）：从折射率高射向折射率低，比如从玻璃射向空气 $t_p=t_s$，两者没有相位差 当$i=i_c$，此时$r_p=r_s=1$，我们称之为全内反射（Total Internal Reflection，TIR），$i_c$被称为临界角（critical angle） 相位移 相位移（Phase shift） 从低折射率到高折射率，会有一次$\\pi$相位移 从高折射率到低折射率，没有相位移 薄膜相位移：光线在薄膜内发生多次反射，可能会附加一段相位移 简化菲涅尔方程 反射比（Reflectance，用$R$表示）：反射光占入射光的能量 折射比（Transmittance，用$T$表示）：透射光（折射光）占入射光的能量 能流（Energy flow）：单位时间内通过单位横截面积的能量 能流 = 辐照度 x 横截面积 $$ R=r^2 $$ $$ T=\\frac{n_2\\cos i_2}{n_1\\cos i_1}t^2 $$ 根据能量守恒定律（Energy conservation law）：$R+T=1$ 当垂直入射时，带入菲涅尔方程，得到 $$ \\begin{cases} r_p=\\frac{n_2-n_1}{n_2+n_1} \\\\ r_s=-r_p \\\\ t_p=\\frac{2n_1}{n_1+n_2} \\\\ t_s=t_p \\end{cases} $$ 于是得到 $$ R_p=R_s=\\left( \\frac{n_2-n_1}{n_2+n_1}\\right)^2 $$ $$ T_p=T_s=\\frac{4n_1n_2}{(n_1+n_2)^2} $$ 对于空气（$n_1=1$）和玻璃（$n_2=1.5$），$R=0.04，T=0.96$ 这也是为什么图形学中取 0.04为F0的基准值 为什么晚上室内玻璃像镜子一样？ 晚上的玻璃，$R\\approx 0.08$，室内的光线大部分都会反射回来，而室外的光线只有很少才会透射进来，看到的光绝大多数都来自室内的反射光，因此像镜子一样 此外，夜晚室内光线本身也比室外光线强 为什么白天从黑暗的房间看外面看，看的很清楚，而从室外向里看，却看不清？ 单透玻璃的原理是什么？ 金属 金属（电介质）表面存在大量自由电荷，在外部电场的作用下，自由电子在固体表面（相对固定的金属阳离子）间不断弹跳 德鲁德模型 德鲁德模型（Drude model）是一种描述金属表面自由电子运动的模型（很复杂，看一下，图一乐） $$ P=-nex $$ $$ m\\frac{\\partial^2 x}{\\partial t^2}+m \\gamma \\frac{\\partial x}{\\partial t}=eEe^{-\\mathrm{i}\\omega t} $$ 偏振度（用$P$表示，在电磁波那一章在介绍洛伦兹震荡时有一个极其类似的公式） 阻尼率（damping rate，用$\\gamma$表示） 电荷密度（density of electron，用$n$表示） 这个推导很复杂，又涉及复变函数之类的，直接给结论：当平面波垂直射向金属时，$R \\approx 1$ 布鲁斯特角 布鲁斯特角（Brewster’s angle），在外反射那一节提到过，当$i_1=i_B,r_p=0$ 一个应用是测量不透明介质的折射率 $$ \\tan i_B=\\frac{n_2}{n_1} $$ 另一个一个应用是制作偏振器，激光经过偏振器后，射出的光线是线偏振的 自然光（非偏振光）的反射光、折射光是偏振光，但如果给镜头安装偏振器，并适当旋转偏振片，使偏振片的透振方向与反射光的透振方向垂直，此时$i_1=i_B,r_p=0$，不发生反射，只发生透射，于是会看得更清晰 偏振 线偏振光的反射、折射光仍为线偏振光，但其光矢量方向会发生改变（上为入射光，下为反射光） 圆偏振/椭圆偏振光的反射折射光一般为椭圆偏振光 全内反射 从折射率高射向折射率低，当入射角满足$i_1 \\ge i_c$时，就会发生全内反射（Total internal reflection） 此时$R\\equiv 1$，也就是所有能量都被反射，不发生透射，于是低折射率那一侧看不到任何光，物体变黑了，这个现象就是全内反射 全内反射的应用：棱镜（Prisms）、光纤 隐失波 隐失波（Evanescent wave） ：光从光密介质入射光疏介质时，如果发生全内反射，光疏介质那一侧产生的电磁波 隐失波的振幅随着穿透深度（Depth of penetration）的增加而呈现指数衰减，随切线方向而改变相位，因此是一种表面波 $$ d=\\frac{\\lambda_2}{2\\pi \\Omega} $$ 穿透深度：与分界面的垂直深度，用$d$表示 $\\sqrt{1-\\sin ^2 i_2} \\equiv \\mathrm{i}\\Omega$ 隐失波沿着z轴衰减，沿着x轴传播 $$ E_2=E_{02}e^{-z/d}e^{\\mathrm{i}(k_xx-\\omega t)} $$ 隐失波不是横波 隐失波的一个应用是制作分光镜，如果只有一个棱镜（下图黑色三角形），会发生全内反射，光线全部反射 如果将两个棱镜靠近，通过控制两者间空气的间隙，在隐失波的作用下，能实现分光 其他应用： 光子隧穿 近场扫描显微镜 指纹检测","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：波动光学","slug":"optics/波动光学","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.440Z","comments":true,"path":"optics/波动光学/","permalink":"https://reubensun.com/optics/%E6%B3%A2%E5%8A%A8%E5%85%89%E5%AD%A6/","excerpt":"","text":"二：波动光学 内容概述 简谐波（simple harmonic waves） 傅里叶变换（Fourier Transform） 波的物理量 数学基础 常用函数 三角函数 欧拉公式 $$ e^{\\mathrm{i}x}=\\cos x + \\mathrm{i}\\sin x $$ 三角函数的复数表示 $$ \\sin z=\\frac{e^{\\mathrm{i}z}-e^{-\\mathrm{i}z}}{2\\mathrm{i}} $$ $$ \\cos z=\\frac{e^{\\mathrm{i}z}+e^{-\\mathrm{i}z}}{2} $$ $\\delta$函数 德尔塔函数，冲击函数 整体积分为1，除了0点以外，其他点函数值都为0 $$ \\delta(x)=0,(x\\ne0) $$ $$ \\int^{\\infty}_{-\\infty}\\delta(x)dx=1 $$ 高斯函数 概率论里的正态分布 $$ f(x)=ae^{-(x-b)^2/2c^2} $$ a&gt;0 洛伦兹函数 概率论里的柯西分布 $$ f(x)=\\frac{A}{B^2+x^2} $$ 矩形脉冲函数 $$ f(t)=E[u(t+\\frac{\\tau}{2})-u(t-\\frac{\\tau}{2})] $$ 波的数学表示 定态波：空间中各点均为同频率的简谐振荡，各点振幅不随时间改变 震荡（Vibration）：物理量围绕其平衡位置进行周期性变化 简谐震荡（Harmonic vibration）：物理量随着时间以三角函数的形式进行震荡 $$ U(t)=A\\cos(\\omega t+\\varphi_0) $$ 振幅（amplitude，用$A$表示） 角频率（angular frequency，用$\\omega$表示） $$ \\omega=\\frac{2\\pi}{T} $$ 相位（phase，用$\\varphi$表示） 初相（initial phase，用$\\varphi_0$表示） 波（waves）：震荡在空间中的传播 简谐波（simple harmonic waves）：进行简谐震荡的波 单色平面波可以视为简谐波 波阵面（wave surface）：波在介质中传播，经过相同时间所到达的各点所连成的线/面 波前（wave front）：最前面的波阵面 相速度（phase velocity，用$v_p$表示）：波传递的速度 $$ v_p=\\frac{\\omega}{k} $$ 傅立叶变换 将一个满足条件的函数，转化为三角函数（或他们积分）的线性组合 $$ \\hat{f}=&lt;f,E_k&gt;=\\int f(x)e^{-2\\pi i k\\cdot x}\\mathrm{d}x $$ 其傅里叶级数为 $$ \\sum\\hat{f}(k)E_k $$","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"光学：电磁波","slug":"optics/电磁波","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.439Z","comments":true,"path":"optics/电磁波/","permalink":"https://reubensun.com/optics/%E7%94%B5%E7%A3%81%E6%B3%A2/","excerpt":"","text":"三：电磁波 内容概述 横波的性质（nature），强度（intensity），能量流动（energyflow） 偏振态（Polarization states），琼斯矩阵（Jones matrix/vector） 吸收（Absorption），色散（dispersion），折射率（refractive index） 微小粒子导致的散射（Scattering） 波 构成波的条件： 波源 介质 能量来源 波的性质： 时间周期性 空间周期性 能量传播 波的分类 标量波 矢量波 光的基本性质 光是电磁波 可见光的波长在400nm~760nm 在做干涉衍射计算时，经常去白光的平均波长550nm 人眼对550nm的黄绿光最敏感 单色光（Monochromatic light），指仅有一种波长的光，仅存在于理论中 光速 光在真空（vacuum）中的速度（简称光速，用c表示）为 $$ c=\\frac{1}{\\sqrt{\\varepsilon_0 \\mu_0}}=2.997 924 58 \\times10^8 m/ s $$ 光在介质（medium）中的速度（也叫做相速度，用v表示）为 $$ v=\\frac{1}{\\sqrt{\\varepsilon_0 \\varepsilon_r\\mu_0\\mu_r}}=\\frac{c}{\\sqrt{\\varepsilon_r \\mu_r}} $$ 很显然光在介质中的速度比在真空中慢，我们用折射率（Refractive index，用n表示）来描述这一性质 $$ n=\\frac{c}{v} $$ 光穿过线性介质（linear medium）时，其频率不会发生改变 光的波长（用$\\lambda$表示） $$ \\lambda=\\frac{c}{v} $$ 波粒二象性 波 如果光是波，那么光应该有波的性质： $$ \\mathbf{k}=\\frac{2\\pi}{\\lambda}\\hat{\\mathbf{k}} $$ $$ v=\\frac{\\lambda}{T}=\\lambda \\nu $$ $$ \\omega=2\\pi \\nu =\\frac{2\\pi}{T}=\\frac{2\\pi}{\\lambda}v=kv=k_0c $$ 波长（wavelength，用$\\lambda$表示） 波向量（wave vector，用$\\mathbf{k}$表示） 频率（frequency，用$\\nu$表示） 周期（temporal period，用$T$表示） 角频率（angular frequency，用$\\omega$表示） 速度（velocity，用$v$表示） 光是电磁波，其电矢量和磁矢量在做简谐振动，一般情况下，我们只讨论电场强度的变化 粒 如果光是粒子，那么光应该有粒子的性质： $$ E=h\\nu=\\hbar \\omega $$ $$ \\mathbf{p}=\\hbar \\mathbf{k}=\\frac{h}{\\lambda}\\hat{\\mathbf{k}} $$ 能量（Energy，用$E$表示） 动量（Momentum，用$\\mathbf{p}$表示） 普朗克常量（Plank constant，用$h$表示，$h=6.626\\times 10^{-34}\\mathrm{J}\\cdot\\mathrm{s}$ 约化普朗克常量（用$\\hbar$表示） 波粒二象性 光具有波粒二象性（Wave-particle duality），光在传播过程中体现出明显的波性，在光与物质交互（light-matter interaction）中粒性更明显 光子与电子 不同之处 电子 光子 静止质量（Rest mass） $m_0$ 0 运动质量（Motion mass） $m$ $hv/c^2$ 运动速度（Motion velocity） $&lt;c$ $c$ 自旋（Spin） 1/2 1 分布定律 费力（Fermion） 玻色（Boson） 相同之处 满足波粒二象性 向量波与标量波 向量波（Vector wave），波函数是向量的波，比如电磁波（EM wave） 标量波（Scalar wave），波函数是标量的波，比如声波（Acoustic wave） 光波（Lightwaves）是一种向量波，但为了方便，我们在讨论干涉衍射时，会认为光是标量波，仅仅在讨论偏振时，才认为光是向量波 电磁波 物理量 电场强度（用$\\mathrm{E}$表示）：单位电荷在电场中受到的力 磁场强度（用$\\mathrm{H}$表示）：通电导线周围有磁场，其强度与电流大小、距离远近有强度（但实际被后世推翻，无实际意义） 电场通量密度（用$\\mathrm{D}$表示）：单位面积的电场通量 磁场通量/感应密度（用$\\mathrm{B}$表示）：经过一个曲面的磁力线的数量 电磁学三定律 库伦定律，真空中两个静止的点电荷间作用力满足 $$ F=k\\frac{q_1q_2}{r^2} $$ 静电力常量（$k=9.0\\times 10^9 \\mathrm{N} \\cdot\\mathrm{m^2}/\\mathrm{C^2}$） 安培环路定律（Ampère’s Circuital Law），也叫右手螺旋定则，载流导线能生磁 法拉第电磁感应定律（Faraday’s Induction Law），磁场变化能产生电场，感应电动势大小与磁通量变化率成正比，电场方向符合楞次定律（由于磁通量的改变而产生的感应电流，其方向为抗拒磁通量改变的方向） 麦克斯韦方程 真空中麦克斯韦方程： 法拉第 $$ \\nabla \\times \\mathbf{E}=-\\frac{\\partial \\mathbf{B}}{\\partial t} $$ 安培 $$ \\nabla \\times \\mathbf{B}=\\mu_0 \\varepsilon_0 \\frac{\\partial \\mathbf{E}}{\\partial t} $$ 真空磁导率（也称为磁常数，用$\\mu_0$表示，$\\mu_0=4\\pi \\times 10^{-7}\\mathrm{H}/\\mathrm{m}$） 真空电容率（也称为电常数，用$\\varepsilon_0$表示，$\\varepsilon_0=8.854…\\times10^{-12}\\mathrm{F}/\\mathrm{m}$） 高斯电场 $$ \\nabla \\cdot \\mathbf{E}=0 $$ 高斯磁场 $$ \\nabla \\cdot \\mathbf{B}=0 $$ 自由空间的波动方程（wave equations，由麦克斯韦方程推出）： $$ \\nabla^2\\mathbf{E}=\\mu_0 \\varepsilon_0 \\frac{\\partial^2 \\mathbf{E}}{\\partial t^2} $$ $$ \\nabla^2\\mathbf{B}=\\mu_0 \\varepsilon_0 \\frac{\\partial^2 \\mathbf{B}}{\\partial t^2} $$ 平面波 三维的电磁波很难分析，我们可以分解变量，将其转化为两个垂直的平面波 平面波（Plane waves）：传播时波面在一个平面的电磁波 平面波的电场方向和磁场方向，与波矢方向垂直，如图，$\\mathbf{k}$为波矢方向（推导过程略），从这里也能看出，平面波是横波，方向满足右手定则 平面波的磁感应强度B和电场强度E的比值等于波速 $$ \\frac{|E|}{|B|}=\\sqrt{\\frac{1}{\\mu \\varepsilon}}=v $$ 电场强度和磁场强度的关系为（注意，这里不是磁感应强度） $$ \\sqrt{\\varepsilon_0 \\varepsilon_r}|\\mathrm{E}|=\\sqrt{\\mu_0\\mu_r}|\\mathrm{H}| $$ 自由空间阻抗（单位和电阻相同，用$Z_0$表示） $$ Z_0=\\sqrt{\\frac{\\mu_0}{\\varepsilon_0}}=376.73\\Omega $$ 波能传递能量，我们引入坡印廷向量（Poynting vector，用$\\mathrm{S}$来表示）来描述能量流动，其方向为电磁能传递方向，大小为能流密度（单位面积的能量传输速率） $$ \\mathrm{S}=\\mathrm{E}\\times \\mathrm{H} $$ 平面波$\\mathrm{E}\\times \\mathrm{H} // \\mathrm{k}$ 傍轴条件 当$\\rho \\ll z，r \\approx z$ 远场条件 辐照度 电磁波的辐照度（Irradiance，用$\\mathrm{I}$表示，也称为Intensity），是坡印廷向量在时间上的平均值 $$ \\mathrm{I}=\\left&lt; \\mathrm{S} \\right&gt;=\\frac{nc\\varepsilon_0}{2}\\mathrm{E_0}^2 $$ $c$是真空中光速 $\\mathrm{E_0}$是电磁波电场强度的振幅（电场强度是一个三角周期函数） 从这里可以看出，辐照度与$\\mathrm{E_0}$的平方成正比 偏振 偏振（Polarization）：光矢量在垂直于传播方向的平面上的震动状态，我们这里提的是电场强度$\\mathrm{E}$的震动 根据是否发生偏振 不偏振光（Unpolarizedlight） 完全偏振光（Completely polarized light） 部分偏振光（Partially polarized light） 根据向量$\\mathrm{E}$的终点（endpoint）轨迹 线偏振（Linearly polarized light） 圆偏振（Circularly polarized light） 椭圆偏振（Elliptically polarized light） 若光线沿着z轴传播，其方程满足 $$ (\\frac{E_x}{E_{0x}})^2+(\\frac{E_y}{E_{0y}})^2-2(\\frac{E_x}{E_{0x}})(\\frac{E_y}{E_{0y}})\\cos \\delta = \\sin ^2 \\delta $$ 线偏振 当$\\delta=2m\\pi$时，方程变为 $$ (\\frac{E_x}{E_{0x}})^2+(\\frac{E_y}{E_{0y}})^2-2(\\frac{E_x}{E_{0x}})(\\frac{E_y}{E_{0y}}) = 0 \\ (\\frac{E_x}{E_{0x}}-\\frac{E_y}{E_{0y}})^2=0 $$ 于是得到线偏振的方程（一三象限） $$ \\frac{E_x}{E_{0x}}=\\frac{E_y}{E_{0y}} \\equiv \\cot \\alpha $$ 同理，当$\\delta=2(m+1)\\pi$时，方程等于（二四象限） $$ \\frac{E_x}{E_{0x}}=-\\frac{E_y}{E_{0y}} $$ 用虚数将两个方程合并，得到 $$ \\frac{E_x}{E_{y}}=\\frac{E_{0x}}{E_{0y}}e^{\\mathrm{i}m’\\pi} $$ 当$m’$为偶数（0 or even）时，一三象限 当$m’$为奇数（odd）时，二四象限 椭圆偏振与圆偏振 当$\\delta=(2m+1)\\frac{\\pi}{2}$时，方程变为 $$ (\\frac{E_x}{E_{0x}})^2+(\\frac{E_y}{E_{0y}})^2=1 $$ 这是一个椭圆方程，我们称之为椭圆偏振 倘若$E_{0x}=E_{0y}=E_{0}$，方程退化为 $$ E_x^2+E_y^2=E_0^2 $$ 我们称之为圆偏振 当$\\delta=\\pi / 2$时，y轴驱动x轴移动，此时为顺时针，称为RCP 当$\\delta=-\\pi / 2$时，x轴驱动y轴移动，此时为逆时针，称为LCP 琼斯矢量 将偏振光的状态以向量的形式写出，方便运算（只适合完全极化光） $$ \\mathrm{E}=\\left[ \\begin{array}{c} E_x(t)\\ E_y(t)\\ \\end{array} \\right] $$ 琼斯向量左乘一个2x2矩阵，可以得到一个新的琼斯向量，这个矩阵被称为琼斯矩阵 偏振度 偏振度（Degree of polarization，用$P$表示）：用来衡量偏振程度的物理量 $$ P=\\frac{I_p}{I_t}=\\frac{I_p}{I_p+I_n} $$ $I_p$：完全偏振光部分的辐照度 $I_n$：不偏振光部分（自然光）的辐照度 吸收 兰伯特定律 兰伯特定律（Lambert law）：光在气体介质中传播，光强（intensity）随着传播深度增加而递减，满足 $$ I=I_0 e^{-\\alpha x} $$ 吸收系数（用$\\alpha$表示） 传播深度（用$x$表示） 贝尔定律 贝尔定律（Beer law）：光在溶剂中传播，光强满足 $$ I=I_0 e^{-ACL} $$ 浓度（用$C$表示） 常数$A$，与溶质性质有关，与浓度无关 该公式满足有两个条件 溶液浓度不能过高，以免出现分子间作用力（这也能解释为什么常数$A$为什么和浓度无关，因为浓度一高，公式就不成立了） 光强不能过高 色散 色散（Dispersion）：光波的相速度随着频率的改变而改变的现象 正常色散（Normal dispersion）：折射率随着波长的增加而减小 柯西公式： $$ n=A+B/\\lambda^2+C/\\lambda^4 $$ 反常色散（Anomalous dispersion）：折射率随着波长的增加而增加 反常色散通常发生在吸收带（absorption band）附近，反常色散并不是异常的，叫这个名字只是历史问题 洛伦兹震荡模型 洛伦兹震荡模型（Lorentz oscillator model）：在一个尺寸为$\\Delta V$的空间内有一个电子（电荷量为$1.6\\times10^{-19}C$），在光的电场作用下，让该电子相对于稳定位置偏离x 偏振度（单位体积电偶极矩的振幅，用$P$表示）写作 $$ P=\\frac{1}{\\Delta V}ex=n_0ex $$ 电荷密度（density of charge，用$n_0$表示） $x$是电子的运动方程，如下 $$ x(\\omega)=-\\frac{eE(\\omega)}{m_0}\\frac{1}{\\omega^2+\\mathrm{i}\\omega \\gamma-\\omega_0^2} $$ 将$x$带入，得到 $$ P=-\\frac{n_0e^2}{m_0}\\frac{1}{\\omega^2+\\mathrm{i}\\omega \\gamma-\\omega_0^2}E(\\omega) \\equiv \\varepsilon_0 \\chi(\\omega)E(\\omega) $$ 根据定义 $$ \\varepsilon=\\varepsilon_0[1+\\chi(\\omega)] $$ 带入得 $$ n^2=\\varepsilon/\\varepsilon_0=1-\\frac{n_0e^2}{m_0}\\frac{1}{\\omega^2+\\mathrm{i}\\omega \\gamma-\\omega_0^2} $$ 如图，洛伦兹模型解释了为什么在靠近吸收带时，会发生反常色散 组速度 在介质中不同波长的光速度不同，红光波长大，跑的更快 那么如果一个光，包含了多种波长的光，我们用组速度（Group velocity，用$v_g$表示）来描述其速度 $$ v_g=\\frac{\\mathrm{d}\\omega}{\\mathrm{d}k} $$ 散射 一般我们在讨论光在介质中传播，认为是没有损失的，但实际上光在介质中传播是存在吸收的 吸收：光强度随着穿进介质深度而减弱的现象 原因： 光能转化为其他能，比如热量、化学能、电能 发生散射，光向四面八方传播（丁达尔效应） 瑞丽散射 瑞丽散射（Rayleigh scattering）：光在细小粒子间散射 $$ I_{scat}\\propto 1/\\lambda^4 $$ $$ I_{\\theta}\\propto I_{\\pi/2}(1+\\cos^2 \\theta) $$ 米氏散射 米氏散射（Mie scattering）：光在大型粒子内部散射","categories":[{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"}]},{"title":"Effective C++","slug":"program/Effective C++","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:42.966Z","comments":true,"path":"program/Effective C++/","permalink":"https://reubensun.com/program/Effective%20C++/","excerpt":"","text":"Effective C++ 一：C++基础 C++很成熟，很NB C++支持面向过程（procedural）、面向对象（object-orientend）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming） 其核心是四个部分 C 区块block 语句statements 预处理器preprocessor 内置数据类型 数组arrays 指针pointers Object-Orientend C++ 类classes（构造函数，析构函数） 封装encapsulation 继承inheritance 多态polymorphism 虚函数virtual（动态绑定） Template C++ STL 替换#define 使用编译器替代预处理器 尽量使用const、enum定义常量，使用inlines定义函数宏 const #define PI 3.1415926 因为#define不是语言的一部分，在编译器开始工作前，PI就会被处理掉，所以一旦报错，你无法追踪到PI，只能看到3.1415926，这会浪费你的时间 应该改为 const double Pi 3.1415926; 值得注意的事 定义常量指针指向char*-based字符串 const char* const authorName = &quot;Reuben&quot;; 作用域限制在class内的常量，需要让其成为类的一个成员，并且为了让常量至多有一份实体，必须让其成为一个静态成员 class GemePlayer&#123;private: static const int NumTurns = 5; //这只是一个声明式 int scores[NumTurns];&#125;;const int GamePlayer::NumTurns; //这是定义式，因为在声明时已经赋值，所以这里就不赋值了 C++要求我们使用的所有东西都提供一个定义式，但如果不取其地址，可以只有声明式，不写定义式 从这里可以看出，const可以封装，而#define不行 enum class GemePlayer&#123;private: enum &#123; NumTurns = 5 &#125;; int scores[NumTurns];&#125;; const指针 const在星号左边，被指物是常量 char greeting[] = &quot;Hello&quot;;const char* p = greeting; const在星号右边，指针本身是常量 char greeting[] = &quot;Hello&quot;;char* const p = greeting; const在星号两边，被指物和指针都是常量 char greeting[] = &quot;Hello&quot;;const char* const p = greeting; 确认对象在使用前已经被初始化 C++初始化顺序 基类比子类先初始化 成员变量根据其声明次序初始化 二：构造/析构/赋值 空类的默认函数 一个空类，编译器会给他声明一个copy构造函数，一个copy赋值操作符，一个析构函数 一个类，如果没有构造函数，也会自动声明一个default构造函数 这些函数都是public且inline的 禁用自动生成的函数 如果希望不自动生成coyy构造和copy赋值函数，但又不愿意自己定义相关函数，最好禁用掉（而且如果你自己定义了copy函数，那你的类就支持copy了，这可能不是你所希望的） 你可以把copy函数定义为private类型，并不实现他们（甚至参数不需要写参数名） class HomeForSale&#123;private: HomeForSale(const HomeForSale&amp;); HomeForSale&amp; operator=(const HomeForSale&amp;);&#125;; 可以制作一个不可被copy的类，让子类继承 class Uncopyable&#123;protected: Uncopyable()&#123;&#125; ~Uncopyable()&#123;&#125;private: Uncopyable(const Uncopyable&amp;); Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;;class HomeForSale: private Uncopyable&#123; ...&#125;; 为多态基类声明virtual析构函数 一定要有一个virtual析构函数 如果这个类要成为一个基类，那么一定要有一个virtual析构函数 在工厂模式，我们使用工厂函数构造的对象需要适当的delete掉，但是，我们不能依赖客户去使用delete函数，因为他们可能会用错 class TimeKeeper&#123;public: ...&#125;;class AtomicClock: public TimeKeeper &#123;...&#125;;class WaterClock: public TimeKeeper &#123;...&#125;; TimeKeeper* ptk = getTimeKeeper(); //创建一个动态分配对象...delete ptk; //释放对象，避免资源泄漏 上面这个过程的问题其实出在getTimeKeeper()指向一个派生类（derived class）对象（比如AtomicClock），而这个对象却要经由一个基类（base class）指针删除（比如TimeKeeper*） 如果这个基类的析构函数不是virtual的，就会出现问题： 如果派生类有基类没有的成分（成员变量），这些新成分有可能不会被销毁，于产生了一个诡异的“局部销毁”对象 解决方法就是给基类一个virtual析构函数 class TimeKeeper&#123;public: TimeKeeper(); virtual ~TimeKeeper(); ...&#125;; 最好不要有virtual析构函数 如果这个类不可能成为基类，那么最好不要有virtual析构函数 为什么呢？因为要实现virtual函数，对象必须携带某种信息，用于在运行时确定该调用哪一个virtual函数，这个信息通常由vptr（virtual table pointer）指针携带，这个指针指向一个由函数指针构成的数组，称为vtbl（virtual table），每一个带有virtual函数的类都有一个属于自己的vtbl 这个vtbl会增大对象的体积，一个指针要64bits（这个要取决于电脑系统的寻址范围，只不过现在电脑都是64位的？），对一些比较小的类来说，增加64bits可能会让容量翻倍 这个vtbl会让代码失去兼容性，因为其他语言没有vtpr，这就会导致C++的对象和其他语言（如C）结构不同，于是没法接受/传递给其他语言，如果你自己实现vptr，那将不再具备移植性 请不要继承没有virtual析构函数的类 比如string、vector、list、set等等 而且 C++没有像 Java的final classes或者C#的sealed classes的禁止派生机制 不要在析构函数里抛出异常 当一个vector v容器被销毁时，其所包含的所有元素也需要被销毁。如果被销毁的元素的析构函数里可以抛异常，如果析构其中第一个元素的时候，抛了一个异常，如果后续的元素被析构时，也抛了异常，这样就会导致程序结束或者不确定性行为 有两个不怎么好的解决方法 遇到异常，直接std::abort()，即遇到异常，宁愿直接强制停止程序，也不要让异常传播 遇到异常，把异常记录下来，另程序继续运转，即吞下异常 这会使得这个错误被”低估“，但仍然会比直接强杀程序/程序不确定性执行要好 比较好的方法，这是一个控制数据库连接的函数，关闭连接时要析构相关内容 class DBConnevtion&#123;public: ... static DBConnevtion create(); void close(); &#125;;class DBConn&#123;public: ... void close() //封装给客户用的,关闭连接的函数 &#123; db.close(); closed = true; &#125; ~DBConn()&#123; if(!closed)&#123; try&#123; db.close(); &#125; catch(...)&#123; ... //强制关闭程序或者吞下异常 &#125; &#125; &#125;private: DBConnection db; bool closed;&#125;; 不要在构造和析构过程中调用virtual函数 在C++中（Java和C#没有这个烦恼），在构造和析构过程中调用virtual函数，有可能不会带来你所期望的结果 可以简单理解为在C++中，基类构造期间，vritual函数不是vritual函数 因为基类会先于派生类构造。基类构造时，构造的对象是基类类型，而非派生类类型，那么此时调用virtual函数，调用的是基类的版本，而非派生类的virtual函数 同理，进入派生类析构函数的对象，其派生出的成员变量就“消失”了，没法调用，进入基类析构函数的对象，就是一个基类对象，调用的virtual函数是基类版本的 令operator=返回一个对*this的引用 连续赋值 x = y = z = 15;//其实就等于x = (y = (z = 15))； 为了实现来连续赋值，赋值操作符必须返回一个reference，指向操作符左侧实参 class Widget&#123;public: Widget&amp; operator=(const Widget&amp; rhs) &#123; ... return *this; &#125; Widget&amp; operator+=(const Widget&amp; rhs)&#123; ... return *this; &#125;&#125;; xxxxxxxxxx #添加要提交的内容$git add 文件名/文件夹名#提交所有内容（不包含忽略文件），并设置提交信息为“这是一段话”$git commit -a -m 这是一段话bash 如果对象自己赋给自己，我们称之为自我赋值 w = w;a[i] = a[j]; //当i=j时，自我赋值*px = *py; //px和py指向同一个物体时，自我赋值 在赋值操作中： 我们会先另左边的操作数先释放掉当前使用的数据 令其使用右操作数的副本 最后返回左操作数 class Widget&#123; ...private: Bitmap *pb;&#125;;//!!!这个不安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 如果自我赋值，即rhs和pb指向同一个对象，那么delete pb后，这个对象就已经被销毁了，下面使用的*rhs就是一个已经被删除的对象 解决方法1：延后delete Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this;&#125; 解决方法2：使用copy and swap技术 Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Widget temp(rhs); swap(temp); //令*this与temp交换 return *this;&#125; 复制对象的一切 如果你对class的成员变量做修改（比如继承），一定要对copy函数也做修改，不然可能会出错，而且这个错编译器不会报错 派生类需要重载copy函数，但基类部分的copy要通过调用基类的copy函数（因为基类的许多成员变量可能是private的） 所以copy函数需要 复制所有local变量 调用所有基类中的适当的copy函数 三：资源管理 让对象管理资源 将资源（主要是heap- based类型的资源）放入对象内，一旦控制流离开对象，对象的析构函数就会自动释放那些资源 申请资源后立即将其放进对象中，资源获取时机就是初始化时机（Resource Acquisition is Initialization，RAII） 在对象的析构函数中释放资源 C++的auto_ptr是一个类指针（pointer-like）对象，也就是智能指针，其析构函数会自动delete掉其所指向的对象 注意： 不要让多个auto_ptr指向同一个对象，因为一个对象被多次删除就会导致“未定义行为” auto_ptr如果被复制，则原指针会指向null，新指针对获取对象的唯一拥有权 **RCSP（引用计数型智能指针）**也是一种智能指针（比如tr1::shared_ptr），会持续跟踪有多少对象指向某个资源，只有这个资源无人指向时，才会删除该资源 小心copy行为 大多数RAII对象的copy函数： 禁止复制 采用引用计数法（RCSP） 复制底部资源（深拷贝） 转移底层资源所有权（auto_ptr） 在资源管理类中提供对原始资源的访问 有的时候你需要操作原始资源，而不是智能指针类型。两个智能指针都有一个get函数，用于显示转换，获取原始指针类型（或者是复件） new与delete一个数组 一个指针指向一个数组，如果删除这个指针，是删掉这个指针？还是同时一起删掉这个数组呢？ 如果new了一个数组，就delete一个数组 string* ptr1 = new string[100];delete [] ptr1; 如果new了一个对象，就delete一个对象 string* ptr2 = new string;delete ptr2; 很多时候很难确定当前这个对象是数组还是一个对象 typedef string AddressLines[4];string* pal = new AddressLines;delete [] pal; 最简单的方法是不用数组，使用STL里的容器，如vector&lt;string&gt; 以独立语句将newed对象置入智能指针 C++中调用一个函数，会先计算每一个传递进去的实参 如果按下面的写法，将newed对象置入智能指针中 分配函数(shared_ptr&lt;Widget&gt;(new Widget), 资源访问); //不要这样写 需要执行一下函数 调用“资源访问”函数（A） 执行new Widget（B） 调用shared_ptr构造函数（C） 然而和C#等语言不同，C++里这几个函数执行顺序无法确定（其实只是A的顺序无法确定，B一定会比C先执行） 如果执行顺序是BAC，且A执行异常，那么B所返回的指针将会遗失，不会正常放入智能指针中，于是发生资源泄漏 所以简单的方法是分离语句 shared_ptr&lt;Widget&gt; pw(new Widget);分配函数(pw, 资源访问); 四：设计与声明 让接口容易被正确使用 客户会犯错，所以接口要考虑各种错误，接口也不能要求用户记住要做某件事（因为他们可能会忘记） 限制参数传递 这是一个日期类 class Date&#123;public: Date(int month, int day, int year); ...&#125;;...Date d(4, 20, 2022); 客户很有可能填错顺序，也有可能填入一个无效的参数 可以使用外覆类型（wrapper types），当然做出类会更好 struct Day&#123; explict Day(int d) : val(d) &#123;&#125; int val;&#125;;struct Month&#123; explict Month(int m) : val(m) &#123;&#125; int val;&#125;;struct Year&#123; explict Year(int y) : val(y) &#123;&#125; int val;&#125;;class Date&#123;public: Date(const Mouth&amp; month, const Day&amp; day, const Year&amp; year); ...&#125;;...Date d(Month(4), Day(20), Year(2022)); 一致性 自定义的行为要与内置类型的行为一致，比如你不能把operator*重载成operator+ 或则像STL中，容器的接口都很一致，比如size、push_back等等 设计class犹如设计type 对象要如何创建和销毁 对象的初始化和对象的赋值有什么差别（拷贝构造与赋值操作） 对象如果被值传递，意味着什么（深浅拷贝） 约束成员变量的合法值 是否可以/需要被继承 能否类型转换，如何类型转换 支持何种操作符 成员变量的访问修饰 成员函数的访问修饰 未声明接口（undecided interface） 是否需要定义模版 真的需要一个新类吗？ 多用引用传递 C++默认以值传递的方式传递参数，值传递会创建值的副本（也就意味着会调用构造函数和析构函数），这对一些很大的自定义类型来说性能非常糟糕 使用const引用传递会好很多 不会创建新的对象 不会改变原有对象 可以避免对象切割问题 对象切割：当派生类对象作为一个基类对象进行值传递时，调用的是基类的拷贝构造函数，于是这个派生类对象被切割了 只不过引用传递是大多是通过指针实现的，在处理一些简单的内置类型时（比如int），效率反而不如值传递（内置类型也可能是存放在栈里的？），此外STL容器和迭代器设计之初就是为了值传递，慎用引用传递 必须返回对象时，不要返回引用 如果必须返回对象，请不要返回引用（比如operator*，operator==），因为有可能会返回一个指向不存在的对象的引用，比如返回了一个右值的引用（只不过右值也不能被取地址），或者返回了一个local对象的引用 将成员变量隐藏 成员变量应该为private，而不是public 客户只能通过成员函数访问变量，于是可以统一接口（全都是函数） 分离读写权限（这一点C#做的更好？） 封装后便于后续更新（改变成员变量后，客户仍可以使用旧成员函数访问） 便于对成员变量进行约束（更不容易出现异常值） protected并不比public更具有封装性 使用非成员函数 C#，java选手可以略过 C++标准库就是这样写的 这里有一个类，其中有多个成员函数 class WebBrowser&#123;public: void doA(); void doB(); void doC(); ...&#125;; 现在需要令一个函数做ABC三件事，有两种写法 成员函数 class WebBrowser&#123;public: ... void doEverything()&#123; doA(); doB(); doC(); &#125; ...&#125;; 非成员函数 void doEverything(WebBrowser&amp; wb)&#123; wb.doA(); wb.doB(); wb.doC();&#125; 令人意外的是，第二种方法（使用非成员函数）更好 什么是封装 一个东西被封装，那么将不再可见，越多东西被封装，能被看见的东西就越少，那么我们能改变的东西会越少，弹性越小，封装性越强 为什么推崇封装，是因为封装可以让我们在只影响有限客户的情况下改变事物 为什么第二种比第一种封装性更强 因为第一种给用户两种调用方法，一个是调用成员函数doEverything()，一个是调用所有的do函数。两者功能完全一致，而且还增多了第一个类的成员函数，降低了封装性 注意第一种方法中，doEverything()和其他do函数访问权利一致，而且都是public，这个函数的作用仅仅是提供便利 那么第二种方式是不是不太符合面向对象呢？因为这个函数不在类里。解决方法也很简单，定义一个工具类，将这个函数定义为该工具类的静态成员（static member）函数即可 或者把相关的非成员函数写在一个namespace里（也可以定义在一个头文件中，这样其他namespace可以选择性使用） namespace WebBrowserStuff&#123; class WebBrowser&#123;...&#125;; void doEverything(WebBrowser&amp; wb)&#123;...&#125;&#125; 可拓展性更强 客户可以自行定义一个头文件，然后在头文件中自己定义一个提供便利的非成员函数（毕竟对客户而言，类是不可/不应该修改的） 可拆分 用户可以把不同的非成员函数放在不同的头文件中，按需索取（而类必须完整定义，不可分割） 如果所有参数都需要进行类型转换，使用非成员函数 令类支持隐式类型转换是一个非常糟糕的主意，但如果每次都做显示转化又非常麻烦，尤其是当你在做一个数值运算的函数时 比如一个有理数乘法 class Rational&#123;public: //这个类没有自定义的explict构造函数 const Rational opertaor* (const Rational&amp; rhs) const; ...&#125;; Rational oneEighth(1,8);Rational oneHalf(1,2);Rational result = oneHalf * oneEighth; //成功result = result * oneEighth; //成功result = oneHalf * 2; //成功，等价于 result = oneHalf.operator*(2)result = 2 * oneHalf; //失败，等价于 result = 2.operator*(oneHalf) result = oneHalf * 2;为什么成功，因为这里发生了一次隐式转换，将2转化为了一个Rational类型 在编译器中可能等价于 const Rational temp(2);result = oneHalf * temp; 如果这个类有自定义的explict构造函数，上面这几个运算都失败，因为无法将2转化为一个Rational类型 result = 2 * oneHalf; 为什么会失败，因为隐式转换只能转换**参数列（parameter list）**内的参数，不能转化成员函数所隶属的对象（即this对象），此时2就是一个int类型，没有我们所自定义的operator*函数，自然会失败 可以发现，想要实现混合运算，非常麻烦，但是如果把这个运算做成一个非成员函数，会好很多（因为所有的操作数都是参数，都在参数列中，都可以被隐式转换） const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125; 此外要极力避免使用友元（friend）函数 成员函数的对立面是非成员函数，一个函数不方便做成成员函数，要先考虑做成非成员函数 写一个不抛异常的swap函数 swap函数原本是STL的一部分，后来称为了异常安全性编程的核心，以及成为用来处理自我赋值的常见机制。总之swap很重要 std是一个很特殊的命名空间，客户可以全特化（total template specialization)std里面的templates，但是不可以添加新的templates到std里面，std的内容完全由C++标准委员会决定 全特化：针对某个类做模板函数的特例，如对std::swap做一个针对Widget的特化 class WidgetImpl&#123;...&#125;; //这个类的对象中存储着真正的数据class Widget&#123;public: Widget&amp; operator=(const Widget&amp; rhs)&#123; ... *pImpl = *(rhs.pImpl); ... &#125; ... void swap(Widget&amp; other)&#123; //这个函数决对不可抛异常 using std::swap; swap(pImpl, other.pImpl);//这是pimpl写法，交换两个对象只需要置换其pImpl指针 &#125; ...private: WidgetImple* pImpl; //这个类有一个指向资源对象的指针&#125;;namespace std&#123; template&lt;&gt; void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123; //这个可以抛异常 a.swap(b); &#125;&#125; 此外，C++的STL容器就是上面这种写法，提供了public swap成员函数和std::swap的特化版本 五：实现（Implementations） 随意定义变量可能会导致性能降低 过度使用转型（casts）可能会导致性能降低，难以维护，可读性低 返回对象的内部数据的handles，可能会破坏封装 未考虑异常可能会导致资源泄露和数据败坏 过度使用inline可能会导致包体膨胀 过度耦合（coupling）可能会增加构建时间（build times） 尽量延后变量定义式的出现时间 避免未曾使用的变量 如果你定义了一个（类型中带有构造函数或析构函数的）变量，当程序的**控制流（control flow）**到达这个变量时，就会调用构造函数函数，当这个变量离开作用域时，就会调用析构函数，尽管这个变量没有被使用过 此外，如果一个函数的中间代码抛了异常，那么前面的变量就有可能未被使用，白构造了、 避免无意义的默认构造函数 如果你提前定义一个变量，这个变量可能会用默认构造函数构造，最后再赋值。这样不如将变量定义延后，用拷贝构造函数构造，这样性能会更好 循环 此外，如果变量只在循环内使用，是将其定义在循环内呢？还是循环外？ 循环内 for(int i = 0; i &lt; n; i++)&#123; Widget w(...); ...&#125; n个构造函数+n个析构函数 如果Widget是一个很敏感的类，这样会让其作用域更小，更容易理解和维护 循环外 Widget w;for(int i = 0; i &lt; n; i++)&#123; w = ...; ...&#125; 一个构造函数+一个析构函数+n个赋值操作 如果赋值成本比构造+析构要低，这样更好（尤其是n很大的时候） 少做转型 C++是强类型语言，设计目标应该是保证类型错误绝不发生，然而类型转换破坏了类型系统 Java、C#，这些语言的类型转换比频繁，而且相对安全，但C++极具风险 C++的类型转化 旧式转换 (T)expression T(expression) 新式转换 const_cast&lt;T&gt;(expression) 用于将对象的常量性转除（cast away the constness） 比如将const转化为non-const 注意，这个转换的目的，是将一个原本不是const但是莫名加了const的变量，去掉多余的const。如果你对一个真正的const做转换，是未定义行为，真正的const在编译阶段就放在readonly区了 dynamic_cast&lt;T&gt;(expression) 用来安全向下转型 无法由旧式语句执行 耗费巨大 reinterpret_cast&lt;T&gt;(expression) 用于低级转型，实际操作取决于编译器，不可移植 极其少用 static_cast&lt;T&gt;(expression) 用于强迫隐式转换（implicit conversions） 比如non-const转化为const，int转化为double，void*转化为typed，基类指针转化为派生类指针 避免C++类型转换出问题的核心是避免使用基类的接口处理派生类 一个对象多个地址 C++很神奇，如果一个基类指针指向一个派生类对象，如 Dervied d;Base* b = &amp;d; 这可能会导致两个指针值不一样，即这个对象有两个地址，一个Derivied*指针一个Base*指针，这派生类指针上往往会有一个偏移量（offset），通过这个偏移量，可以通过派生类指针找到基类指针 上面这种事在Java、C#、C中绝对不会发生，但是C++可以多继承，很容易出现这种情况（单继承时也会出现），所以请不要假定对象在C++中如何布局，更不应该基于这个假设对对象进行类型转换 如果你想让当前对象调用基类的函数，如果对*this做强制转化，转换为基类，*this其实是先前产生的*this对象的基类部分，这个部分的成员函数可能与当前对象不同，最后导致调用函数出现问题 class SpecialWindow: public Window&#123;public: virtual void onResize()&#123; //static_cast&lt;Window&gt;(*this).onResize(); //这样不好 Window::onResize(); //请用这种方式调用基类的onResize函数（作用到当前对象上） ... &#125;&#125; dynamic_cast 这东西执行起来特别慢，尤其是操作深度继承和多重继承的对象 什么时候使用这个东西？当你想在一个你认为是派生类对象的对象上执行派生类的操作函数，但你手里却只有一个指向基类的引用/指针时 解决方法： 使用类型安全容器（比如智能指针），存储指向派生类对象的指针，然后操作容器 在基类中提供virtual函数 避免返回指向对象内部成分的handles 前面也写过，我们可以把数据分离出来，对象中只存一个指向数据的指针/引用，这样复制起来会更方便 但是如果我们传递出指向对象的指针/引用，即使这个数据是private类型，但这个数据是可以会被修改的 class Point&#123;public: ... void setX(int val); ...&#125;;struct RectData&#123; Point ulhc; //upper left hand corner Point lrhc; //lower right hand corner&#125;;class Rectangle&#123;public: ... Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125; //这样返回了引用，非常不好 ...private: std::tr1::shared_ptr&lt;RectData&gt; pData;&#125;;...rec.upperLeft().setX(50); //rec是一个Rectangle类型，我们发现这里居然实现了对Rectangle的修改 upperLeft函数本来只是为了提供给客户获得（get）Rectangle的一个坐标点，结果通过修改其指向/引用的对象。调用一个const函数，修改（set）了Rectangle本身，而且还是一个内部数据RectData 为什么会出现这种情况呢？是因为成员函数返回了一个handles（包括指针、引用、迭代器） 解决方法很简单，只要让handles不可以被修改，就可以了 class Rectangle&#123;public: ... const Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125; ...&#125;; 但这样还是返回了指向对象内部的handles，如果所指向的东西不存在，就会导致dangling handles（空悬的号码牌），比如返回了一个对local变量的引用，依然特别危险 当然，有的时候不得不返回handles，比如operator[] 异常安全性很重要 **异常安全性（Exception safety）**即当异常被抛出时，满足一下两个条件： 不泄漏任何资源 不允许数据败坏 不泄漏资源比较好解决，前面已经做过使用对象管理资源了，而解决数据败坏比较复杂 三个保证： 基本承诺：如果异常被抛出，程序中任何事物仍保持在有效状态下，没有对象/数据结构/约束被破坏 强烈保证：如果异常被抛出，程序状态不改变。即如果函数成功，则完全成功，如果函数失败，则返回调用函数前的状态（可以通过copy-and-swap实现） 不抛掷（nothrow）：绝对不会抛出异常，任何情况下都能完美完成承诺的任务，比如内置类型int、指针等（但是很难实现） 异常安全码必须提供上述三种保障之一，如果不能保障，则不具备异常安全性 了解inline函数 内联函数有很多优点，比如比宏好很多，也可以免除函数调用成本，此外编译器会对这部分代码做最优化 缺点也很明显，会让包体变大，会导致换页行为（paging），会降低cache命中率（如果内联函数很大的话），所以只适用于小型、频繁调用的函数 内联函数一般放在头文件中，因为大多数建置环境，在编译时进行内联 降低文件间的编译依存 如果头文件内的代码被修改，所以使用这个头文件的文件也会被重新编译 为什么C++要让类的实现放在定义式之中？其中一个重要因素是编译器必须在编译期间知道对象的大小，而知道对象大小的方法就是去访问定义式（这也是C++为什么需要先定义，后使用） 这个问题在Java等语言中不存在，这些语言的实现类似于**pimpl（pointer to implementation）**写法，如果一个类中有一个自定义的数据类型，我们不需要知道这个类具体有多大，我们只需要分配一个指针大小的空间，让这个指针指向这个类 话说应该不会有人不知道implementation是实现的意思吧 class PersonImpl; //pimpl写法，这是Person类的前置声明class Data; //Data的前置声明class Address; //Address的前置声明class Persion&#123; //像这样使用pimpl的类，往往被称为Handle classespublic: ... std::string name() const; ...private: std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;&#125;; 在这种设计下，Person就与Data、Address以及Persons的实现分离了，改动这些类也不会导致使用Person的客户重新编译，客户无法看到Person的实现细节，真正实现接口与实现分离 这个操作的本质是用声明的依赖性替换定义的依赖性 此外最好为声明式和定义式提供不同的文件，比如把声明放在一个头文件中，引用这个头文件就可以快速引入多个声明 此外还有另一种制作Handle class的方法，就是令Person成为一个特殊的抽象基类，称为Interface class，这个类没有成员变量，没有构造函数，单纯描述了几个纯虚函数和一个virtual析构函数。从功能上很接近C#、Java的Interfaces，但是更有弹性（比如可以在其中实现成员变量和成员函数） class Person&#123; //Interface classpublic: virtual ~Person(); virtual std::string name() const = 0; ...&#125;;class Person&#123; //具现化public: static std::tr1::shared_ptr&lt;Person&gt; create(const std::string&amp; name...); ...&#125;;...//使用std::tr1::shared_ptr&lt;Person&gt; pp(Person::create(name...));std::cout &lt;&lt; pp-&gt;name(); class RealPerson: public Person&#123; public: RealPerson(const std::string&amp; name, ...): theName(name), ...&#123;&#125; virtual ~RealPerson() &#123;&#125; std::string name() const; ...private: std::string theName;&#125;;std::string ReakPerson::name()&#123;...&#125;std::tr1::shared_ptr&lt;Person&gt; Person::create(const std::string&amp; name, ...)&#123; retrun std::tr1::shared_ptr&lt;Person&gt;(new RealPerson(name, ...));&#125; 六：继承与面向对象 is-a：是一个 has-a：有一个 is-implemented-in-terms-of：根据xx实现出 public继承是is-a关系 class Student: public Person&#123;...&#125;; //Student is a Person 每个学生都是人，但每个人不一定是学生，人这个概念更一般化，学生这个概念更特殊化 public继承下，可以把子类当父类用，毕竟需要人的地方绝对可以接受一个学生，父类的函数可以对子类使用 这就出现了一个问题，子类一定要is a父类，不然会出现问题 错误的继承： 企鹅是鸟（企鹅是鸟的派生类），鸟会飞（其实这句话是错的），所以企鹅会飞？ 正方形是矩形的特例，矩形可以自由调整长宽，所以正方形也可以自由调整长宽？ 避免遮掩父类成员 int x;void Fun()&#123; double x; ...&#125; 由于作用域的名称遮掩规则，函数内部的local变量x覆盖了全局变量x 子类名称会遮掩父类名称，在public继承下是错误的 在OOP中，如果子类重载了父类的non-virtual函数，就意味着子类使用同名函数遮掩了父类函数，就意味着这个父类函数没有被子类继承！，那么在这种情况下，继承就不是is-a关系了 在public继承下，子类继承了父类的一切 class Base&#123;public: virtual void f1() = 0; virtual void f1(int); void f2(); void f2(double); ...private: int x;&#125;;class Derived: public Base&#123;public: virtual void f1(); void f2();&#125;;...Derived d;int x;d.f1(); //正确，调用Derived::f1d.f1(x); //错误，因为Derived::f1遮掩了Base::f1，而Derived::f1中没有f1(int)d.f2(); //正确，调用Derived::f2d.f2(x); //错误，因为Derived::f2遮掩了Base::f2，而Derived::f2中没有f2(double) 将被遮掩的名称重见天日 解决起来很简单，只需要让父类的函数在子类作用域内可见，可以使用using关键字 class Derived: public Base&#123;public: using Base::f1; using Base::f2; virtual void f1(); void f2();&#125;;...Derived d;int x;d.f1(); //正确，调用Derived::f1d.f1(x); //正确，调用Base::f1d.f2(); //正确，调用Derived::f2d.f2(x); //正确，调用Base::f2 如果是private继承，子类只继承了父类的一部分，如果子类只想要父类的某一个函数，可以使用转交函数，这对象的作用就是不使用using关键字，实现让父类函数出现在子类作用域中 class Derived: private Base&#123;public: virtual void f1()&#123; Base::f1(); //inline转交函数 &#125; ...&#125;;...Derived d;int x;d.f1(); //正确，调用Derived::f1d.f1(x); //错误，因为Derived::f1遮掩了Base::f1 区分接口继承和实现继承 public继承分为两个部分 函数接口继承 函数实现继承 接口继承 实现继承 纯虚函数 具体指定 不继承 非纯虚函数 具体指定 继承一份缺省实现 non-virtual函数 具体指定 继承一份强制实现 考虑使用virtual以外的选择 基于NVI的Template Method模式 Non-Virtual Interface（NVI）流派主张virtual函数应该为private类型，让客户使用public non-virtual成员函数间接调用virtual函数 class GameCharacter&#123;public： int healthValue() const &#123; ... int retVal = doHealthValue(); ... return retVal; &#125;private： virtual int doHealthValue() const &#123; ... &#125;&#125;; 其中healthValue()被称为virtual函数的外覆器（wrapper） 基于函数指针的Strategy模式 class GameCharacter;int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public: typedef int (*HealthCalcFunc)(const GameCharacter&amp;); explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125; int healthValue() const &#123; return healthFunc(*this); &#125; ...private: HealthCalcFunc healthFunc;&#125;; 在这种模式下，defaultHealthCalc函数不再是GameCharacter体系内的成员函数，通过修改函数指针，就可以让GameCharacter使用不同种类的计算函数，弹性更强，而且可以在运行时变更 此外defaultHealthCalc函数不需要/不能访问GameCharacter内的non-public部分， 基于tr1::function的Strategy模式 上面使用函数指针，是为了将函数变成某个类似于函数的东西，比如函数指针，比如tr1::function对象 class GameCharacter;int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public: typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc; explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): healthFunc(hcf)&#123;&#125; int healthValue() const &#123; return healthFunc(*this); &#125; ...private: HealthCalcFunc healthFunc;&#125;; 古典的Strategy模式 class GameCharacter;class HealthCalcFunc&#123;public: ... virtual int calc(const GameCharacter&amp; gc) const&#123;...&#125; ...&#125;;HealthCalcFunc defaultHealthCalc;class GameCharacter&#123;public: explicit GameCharacter(HealthCalcFunc* phcf = &amp;defaultHealthCalc): pHealthFunc(phcf)&#123;&#125; int healthValue() const &#123; return phealthFunc-&gt;calc(*this); &#125; ...private: HealthCalcFunc* pHealthFunc;&#125;; 绝不重新定义继承而来的non-virtual函数 静态绑定（staticcally bound）：non-virtual就是这种 动态绑定（dynamically bound）：virtual就是这种 class B&#123;public: void f(); ...&#125;;class D: public B&#123;public: void f(); ...&#125;;...D x;B* pB = &amp;x;D* pD = &amp;x;pB-&gt;f(); //调用B::fpD-&gt;f(); //调用D::f 绝对不重新定义继承而来的缺省参数值 virtual函数是动态绑定的，缺省参数值是静态绑定的 class Cricle: public Shape&#123;...&#125;;...Shape* p1; //p1的静态类型是Shape*，没有动态类型Shape* p2 = new Circle; //p2的静态类型是Shape*，动态类型是Circle* 静态类型 指针的类型就是静态类型 动态类型 所指向的对象的类型是动态类型 动态类型可以通过赋值等操作改变 virtual函数也是动态绑定的，具体调用哪一个函数取决于发出调用的对象的动态类型，所以允许重载 但缺省参数值是静态绑定的，如果重载一个含有缺省参数值的virtual函数，有可能会导致使用父类的缺省参数值，调用子类的函数 has-a和根据xx实现出 一个类中有多个小类，这种关系被称为复合（composition），其中这些小类被称为合成成分物（composed object） 在应用域，复合意味着has-a 人有名字（也不尽然） 在实现域，复合意味着is-implemented-in-terms-of 队列是由数组实现的（有的队列中维护了一个数组，当然不是所有的队列都使用数组实现） 少用private继承 经典 C++糟粕，请问 C#有这个吗？ 本质上是一种is-implemented-in-terms-of关系，父类和子类间并没有逻辑上的联系，仅仅是想用父类的某些特性来实现子类，这东西在设计层面完全没有意义，纯粹是一种实现技术 private继承，编译器无法自动将子类对象转化为父类对象 private继承，父类中所有属性变成private类型（比如父类中的public、protected类型） 尽量使用复合来替代pirvate继承，除非你想让子类可以访问父类protected成员，或者需要诚信定义virtual函数 此外private继承的对象有可能比复合的对象要小 少用多重继承 经典 C++糟粕，请问 C#有这个吗？ 可能会导致歧义 当然你可以在调用函数的时候指出是来自哪一个基类 可能会导致菱形继承 菱形继承可能会导致变量重复 七：模版与泛型 模板（templates）是泛型编程（generic programming）的基础 模板机制是一个完整的图灵机（Turing-complete），引出了模板元编程（template metaprogramming， TMP），在编译时TMP从templates中具现出若干C++代码，这些代码会被编译期正常编译 评价 优点： 模板编程能够实现非常灵活且类型安全的接口 极好的性能（更小的文件、更短的运行期，更少的内存需求） 可以将一些运行时才能侦测到的错误，在编译期找出来 缺点： 难以编程和维护 编译报错信息难以理解 难以重构 编译时间大幅变长 因此C++模板一般只用在少量高频使用的基础组件，不要写太复杂的，也不将模板暴露出去（用户不会用，就不给他们用），写好注释 隐式接口和编译期多态 OOP中经常使用显式接口和运行时多态 泛型编程更多使用隐式接口和编译期多态 template&lt;typename T&gt;void doProcessing(T&amp; w)&#123; if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget)&#123; T temp(w) temp.normalize(); temp.swap(w); &#125;&#125; 从这个例子来看，t的类型应该必须支持size、normalize、swap等函数，这些函数就是一组隐式接口 所有涉及t的函数调用，都有可能造成template的具现化（instantiated），使得这些调用能够成功 这种具现化行为出现在编译期，”以不同的template参数具现化function template“会导致调用不同的函数，这就是编译期多态 Traits 一种约定俗成的技术方案，为同一类数据提供统一的操作函数 比如我们想实现一个通用的decode()，我们不可能每自定义一个类，就重载一次函数，我们可以使用模板来实现。 enum Type&#123; TYPE_1; TYPE_2;&#125;;class FOO&#123; Type type = Type::TYPE_1;&#125;;class Bar&#123; Type type = Type::TYPE_2;&#125;;//统一的模板函数template&lt;typename T&gt;void decode(const T&amp; data, char* buf)&#123; if(T::type == Type::TYPE_1)&#123; ... &#125; else if(T::type == Type::TYPE_2)&#123; ... &#125;&#125; 但是对于系统内置的变量，我们无法对其进行修改，于是我们引入了traits技术 enum Type&#123; TYPE_1; TYPE_2;&#125;;class FOO&#123; Type type = Type::TYPE_1;&#125;;class Bar&#123; Type type = Type::TYPE_2;&#125;;template&lt;typename T&gt;struct type_traits&#123; Type type = T::type;&#125;//为内置数据类型特化为独有的 type_traitstemplate&lt;typename int&gt;struct type_traits&#123; Type type = Type::TYPE_1;&#125;//统一的模板函数template&lt;typename T&gt;void decode(const T&amp; data, char* buf)&#123; if(type_traits&lt;T&gt;::type == Type::TYPE_1)&#123; ... &#125; else if(type_traits&lt;T&gt;::type == Type::TYPE_2)&#123; ... &#125;&#125; 该技术使得类型测试在编译期可用，将类型测试放在编译期，可以使得测试代码不进入可执行文件中，这也就是将类型测试的工作量从运行时转到编译期，这也就是为什么TMP能以牺牲编译时长为代价，提高代码运行效率的原因 模板元编程 TMP是一个函数式语言，这类语言经常使用递归。函数式语言的递归不涉及函数调用，而是递归模板具现化 如果一门语言具备以下功能，则称为图灵完全 数值运算和符号运算 判断 递归 数值运算+递归 //一个TMP计算阶乘，而且阶乘的技术发生在编译期template&lt;unsigned n&gt;struct Factorial&#123; enum &#123; value = n * Factorial&lt;n-1&gt;::value &#125;;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123; enum &#123; value = 1 &#125;;&#125;;int main()&#123; std::cout &lt;&lt; Factorial&lt;5&gt;::value;&#125; C++11TMP这种函数式编程得到了加强，上文也可以这样写 template&lt;unsigned n&gt;struct Factorial&#123; constexpr static auto value&#123; n * Factorial&lt;n - 1&gt;::value &#125;;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123; constexpr static auto value = 1;&#125;; 判断 template&lt;bool Value&gt;struct if_constexpr&#123; constexpr static auto value = 1;&#125;;template&lt;&gt;struct if_constexpr&lt;false&gt; &#123; constexpr static auto value = 2;&#125;;int main()&#123; std::cout &lt;&lt; if_constexpr&lt;true&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; if_constexpr&lt;false&gt;::value &lt;&lt; std::endl;&#125; typedef 在泛型编程中，typedef也很常用，他的作用很多，其中有一个是为复杂声明定义一个简单的别名 下面是一个函数指针的示例 void add(int x, int y) &#123; std::cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; x + y &lt;&lt; std::endl;&#125;void dec(int x, int y) &#123; std::cout &lt;&lt; &quot;x-y=&quot; &lt;&lt; x - y &lt;&lt; std::endl;&#125;void mul(int x, int y) &#123; std::cout &lt;&lt; &quot;x*y=&quot; &lt;&lt; x*y &lt;&lt; std::endl;&#125;void (*op[3])(int, int) = &#123; add, dec, mul &#125;;int main()&#123; for (int i = 0; i &lt; 3; ++i) &#123; （*op[i])(4, 3); &#125;&#125; 如果使用typedef typedef void (*Func[3])(int, int);Func f = &#123; add, dec, mul &#125;;int main()&#123; for (int i = 0; i &lt; 3; ++i) &#123; f[i](4, 3); &#125;&#125; 八：定制new和delete Java和C#等语言有自己内置的GC，但C++必须手动管理内存，这虽然麻烦，但是值得，尤其是一些设计苛刻的项目 new-handler 当operator new无法分配内存时，会抛异常。在其抛异常前，会调用一个错误处理函数来处理内存不足的问题，即new-handler 使用set_new_handler来指定new-handler void outOfMem()&#123; std::cerr &lt;&lt; &quot;内存不足\\n&quot;; std::abort();&#125;int main()&#123; std::set_new_handler(outOfMem); //该函数的参数是一个函数指针 int* array = new int[10000000L]; ...&#125; 当operator new无法满足内存申请时，会不断调用new-handler函数，直到找到足够的内存，所以new-handler函数应该满足 让更多的内存可被使用 实现方法是程序开始时就分配一大块内存，每次调用new-handler时就释放一点点 安装另一个new-handler 如果现在这个new-handler无法获取更多内存，需要知道哪一个new-handler具备增大内存的实力，然后使用set_new_handler来替换自己 卸除new-handler 通过set_new_handler赋值null，将new-handler卸载，使得在内存分配不足时，会抛异常 抛出bad_alloc异常 这种异常不会被operator new捕获，会被传播至内存索求处 不反回 调用abort或者exit class NewHandlerHolder&#123;public: explicit NewHandlerHolder(std::new_handler nh): handler(nh) &#123;&#125; //获取当前的new_handler ~NewHandlerHolder() &#123; std::set_new_handler(handler); &#125; private: std::new_handler handler; //用于记录当前的new_handler&#125;;void* Widget::operator new(std::size_t size) throw(std::bad_alloc)&#123; NewHandlerHolder h(std::set_new_handler(currentHandler)); //安装Widget的new-handler return ::operator new(size); //分配对象或者抛异常&#125;//离开这个函数的声明周期时，NewHandlerHolder被析构，new-handler恢复之前的值 void outOfMem();Widget::set_new_handler(outOfMem);Widget* pwl = new Widget; //内存不足时会调用outOfMem mixin风格的写法 template&lt;typename T&gt;class NewHandlerSupport&#123;public: static std::new_handler_set set_new_handler(std::new_handler p) throw(); static void* operator new(std::size_t size) throw(std::bad_alloc); ...private: static std::new_handler currentHandler;&#125;;template&lt;typename T&gt;std::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()&#123; std::new_handler oldHandler = currentHandler; currentHandler = p; return oldHandler;&#125;template&lt;typename T&gt;void* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) throw(std::bad_alloc)&#123; NewHandlerHolder h(std::set_new_handler(currentHandler)); return ::operator new(size);&#125; class Widget: public NewHandlerSupport&lt;Widget&gt;&#123; ...&#125;; 像这样，一个类继承于一个模版基类，而且这个模版基类以这个类作为类型参数，被称为怪异的循环模版模式（curiously recurring template pattern，CRTP） 替换new和delete的时机 C++中所有的news返回的指针都必须要地址对齐，int要4对齐，double要8对齐 写一个好的new很难，只有当你想改善效能、对heap运行作物进行调试、收集heap使用信息等时才对其进行替换 编写new和delete的规则 如果你真的需要自己写一个new/delete，那就写吧，只不过要符合一些规则 new 应该内含一个无穷循环，在其中尝试分配内存，点那个无法满足内存需求时，调用new-handler 有能力处理0 bytes申请（比如将0 bytes申请视为1 bytes申请） new可能会被继承，而派生类的大小可能会比基类大，需要对其做处理（比如改用标准new），即处理比正确大小更大的（错误）申请 delete 收到null指针时不做任何事 处理比正确大小更大的（错误）申请 编写new时也要写对应的delete Widget* pw = new Widget; 在这里调用了两个函数，一个时用以分配内存的operator new，一个是Widget的构造函数 如果构造函数调用异常，pw将不会被赋值，客户手中将不会有指针指向之前分配的内存。但如果不释放那个内存，就会导致内存泄漏。所以释放内存是交给C++运行时系统的 运行时系统会调用operator new所对应的operator delete来释放地址，对于拥有正常签名式的new和delete来说不成问题 void* operator new(std::size_t) throw(std::bad_alloc); //普通的newvoid operator delete(void* rawMemory) throw(); //global中的普通的newvoid operator delete(void* rawMemory, std::size_t size) throw(); //class中的new 但当你自定义了一个new，却同时写了一个普通形式的delete，就会出现问题 void* operator new(std::size_t, void* pMemory) throw(); //placement new，比普通new多带一个参数Widget* pw = new (std::cerr) Widget; //调用operator new，并以cerr作为其实参 当内存分配成功，而构造函数出现异常时，运行时系统有责任取消内存分配，并恢复旧观，但现在运行时系统无法知道真正被调用的operator new时如何运作的，所以运行时系统会去寻找参数个数与类型都与operator new相同的某个operator delete void operator delete(void*, std::ostream&amp;) throw(); //palcement delete class Widget&#123;public: static void* operator new(std::size_t size, std::ostream&amp; logStream) throw(std::bad_alloc); static void operator delete(void* pMemory) throw(); static void operator delete(void* pMemoty, std::ostream&amp; logStream) throw(); ...&#125;; 如果此时调用delete pw，只会调用普通的delete，因为只有在构造时发生异常时，运行时系统才会调用placement delete 最简单的方式是建立一个base class，令其包含所有正常形式的new和delete，然后继承这个基类，使用using表达式，再扩充new和delete 九：杂项 不要忽视编译器警告 很多人忽视警告，毕竟一个问题如果真的很严重，应该报错 比如下面这个错误，虽然只会报一个警告，但会导致错误的程序行为 class B&#123;public: virtual void f() const;&#125;;class D: public B&#123; virtual void f();&#125;; 报警告 warning: D::f() hides virtual B::f() 原本的目的是为了在D中重新定义virtual函数f()，但由于B中f()是const，在D中不是，此时B中的f()并没有在D中重新被声明，而是被整个遮掩了 去熟悉标准程序库 尤其是TR1 C++98有什么 STL、容器（container）、迭代器（iterator）、算法（algorithm）、函数对象（function object）、容器适配器、函数对象适配器 Iostream 国际化支持 数值处理，包括复数（complex）和纯数值数组（valarray） 异常阶层体系 C89标准程序库 TR1有什么（全在std::tr1中） 智能指针tr1::shared_ptr和tr1::weak_ptr tr1::function tr1::bind 和（彼此无关的独立组件） 哈希表 正则表达式 Tuple变量组 tr1::array tr1::mem_fn tr1::reference_wrapper 随机数生成工具 数学特殊函数 C99兼容 和（基于template） Type traits tr1::result_of 熟悉Boost","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"}]},{"title":"Ubuntu入门","slug":"program/Ubuntu入门","date":"2023-01-31T10:01:25.000Z","updated":"2025-03-18T07:16:48.437Z","comments":true,"path":"program/Ubuntu入门/","permalink":"https://reubensun.com/program/Ubuntu%E5%85%A5%E9%97%A8/","excerpt":"","text":"Ubuntu入门 你可以使用neofetch查看系统信息，我这里是一台WSL2 无头环境（Headless Environment）是指没有GUI的计算环境 常用快捷键 快捷键 意义 ctrl+C 关掉当前运行的程序 ctrl+R 搜索过去运行过的命令 常用命令 命令 意义 ls -a 查看当前目录内容 `ls -l cd 路径名 路径跳转 clear 清空窗口 find 文件名 找出当前文件夹内符合条件的文件 支持正则 whoami 查看当前用户身份 pwd 查看当前工作目录 cat test.txt 查看文件内容 cat &gt; new.txt 新建文件 cat file1 file2 &gt; file 合并文件 mkdir 文件夹名 创建文件夹 -p可以创建多级文件夹 cp src dst 复制文件 kill 进程名 杀死进程 unzip 解压zip文件 需要先安装unzip rm test.txt 删除文件 -r递归删文件夹 -f强删 nvidia-smi 查看当前N卡驱动 echo &lt;变量名称&gt; 打印一个变量 echo $xxx 打印环境变量 eval $(命令内容) 执行一个命令 可以传入很多参数 bash &lt;程序名称&gt; 用bash执行一个程序 可以再前面加一些临时的变量，如venv_dir=- bash ./webui.sh chmod u+x &lt;文件名&gt; 给文件持有者添加执行权限 也有数字模式，比如chmod 777 &lt;文件名&gt; curl &lt;链接&gt; 访问一个链接 使用-X POST可以用POST请求类型，使用-v可以显示详细信息 export no_proxy=“$no_proxy, x.x.x.x” 对某个链接关闭代理 修改后存储在~/.bashrc中 source ~/.bashrc 让shell读取并执行脚本 这里作用是立刻应用之前对~/.bashrc的修改 df -h / 查看磁盘剩余空间 head -n 1 &lt;文件名&gt; 打印文件第一行的内容 查看一些巨大的jsonl的格式很有用 文件访问 Windows访问Linux文件，路径为\\\\wsl$\\Ubuntu-20.04\\home\\username Linux访问Windows文件，路径为/mnt/c/Users/username 在本地和远端服务器通过SSH传递文件 scp &lt;local path&gt; xxx.com:/xxx 常用软件 apt-get Linux内置的包管理器，可以非常优雅地安装管理各种包、软件 # 安装gitsudo apt-get install git# 安装tbbsudo apt-get install libtbb-dev # 查看所有已安装软件（这个信息量巨大，而且有重复信息，不简易使用）$sudo apt-cache search all# 查看所有已安装软件（去重）$sudo apt-cache search all | wc#查看所有名字中带gcc的软件$sudo apt-cache search all | grep gcc 如果遇到报错：“E: Unable to locate package”，可以执行一次更新 sudo apt-get update VS Code 在Windows系统中安装VS Code，并选择添加PATH 在WSL中如果要打开当前目录，直接输入 $code . 推荐安装VS Code的WSL插件 使用快捷键CTRL+SHIFT+P，打开命令面板，键入WSL，进行一些设置 C++ 包名 描述 g++ C++编译器 libtbb-dev tbb并行库 cmake 项目构建 git 版本管理 gfortran fortran编译器 liblapack-dev、liblapacke-dev BLAS和LAPACK线代库 gdb 调试器 Git 配置 使用Git前需要先配置git config，可以输命令，也可以无脑用vscode改.gitconfig文件 git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;youremail@domain.com&quot; 生成SSH公钥 SSH公钥对Linux很重要，比如SSH连接、Git都会用到 生成方法很简单，生成后你可以将.ssh/id_rsa.pub的内容拷贝到需要密钥的网站 ssh-keygen -t rsa -C &lt;邮箱&gt; 拉取项目 项目拉取有两种常见方法 ssh：需要配置SSH Key，只能拉自己的项目，但不提交时不需要账号密码 https：非常方便，只需要git clone，而且可以拉别人的项目，但提交时需要输入账号密码 其实你也可以在输入一次密码后输入 git config --global credential.helper store 我们这里说的密码是token，可以去Github生成token 提交 # 添加要提交的内容git add &lt;文件名/文件夹名&gt;# 提交所有内容（不包含忽略文件），并设置提交信息为“这是一段话”git commit -a -m &lt;信息&gt; 分支 # 展示所有分支git branch -a# 切分支git checkout &lt;分支名&gt; Tmux 经常使用Windows系统的同学，直接使用Linux会感觉我好像一次只能干一件事（尤其是你运行了一个Web后端），因为Windows所有窗口都是一个个单独的进程，UI和逻辑也是多线程，于是我们可以轻松在多个前台任务中切换 其实Linux也是一个多线程多进程的操作系统，我们也可以同时执行多个前台任务，使用的就是Tmux 你可以认为Tmux就是一个个窗口，你可以打开、挂起、恢复窗口，你可以开一个窗口用于开Web后端，然后开另一个窗口做其他事情 命令 # 展示当前所有的窗口tmux ls# 杀掉某个窗口tmux kill-window -t &lt;窗口编号&gt;# 新建某个窗口tmux newn -s &lt;session名称&gt;# 挂起，窗口内的程序会继续运行，直接关窗口也是这样tmux detach# 打开最近一个窗口tmux a# 关闭当前窗口exit 快捷键 快捷键 描述 ctrl+B 进入命令模式 shift+’ 创建一个split窗口 命令模式+ C 创建一个新的窗口 命令模式下 + D 挂起当前窗口 命令模式下 + [ 开启上下滚动模式（可以看之前的命令行输出，按ctrl+C退出） 命令模式下 + / 搜索内容，按n匹配下一个 命令模式下 + x + y 强制退出tmux窗口 命令模式下 + p 回到上一个tmux窗口 Pip # 下载包pip install &lt;包名&gt;# 查看是否有某个包pip show &lt;包名&gt;# 查看某个包的版本pip list | grep &lt;包名&gt; Anaconda3 非常好用的Python环境管理工具，你可以创建多个虚拟Python环境，不用再考虑版本问题了 # 创建一个环境，python版本指定为3.10conda create -n &lt;环境名&gt; python=3.10 pip# 切换环境，成功切换后bash左侧会有一个(环境名)conda activate &lt;环境名&gt;# 删除环境conda remove -name &lt;环境名&gt; --all# 查看所有环境conda env list SSH 我们经常使用SSH连接其他远程主机，但SSH经常会断掉，其实我们只需要在config里加一个参数，即可让SSH连接定时发送一段空数据包，以实现维持连接的效果 Host xxx.com ServerAliveInterval 40 压缩软件 # 解压 xxx.tar.xztar -xf xxx.tar.xz# 解压 xxx.zipunzip xxx.zip CUDA # 查看cuda版本nvcc -V","categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://reubensun.com/tags/Linux/"}]}],"categories":[{"name":"program","slug":"program","permalink":"https://reubensun.com/categories/program/"},{"name":"ai","slug":"ai","permalink":"https://reubensun.com/categories/ai/"},{"name":"engine","slug":"engine","permalink":"https://reubensun.com/categories/engine/"},{"name":"graphics","slug":"graphics","permalink":"https://reubensun.com/categories/graphics/"},{"name":"dcc","slug":"dcc","permalink":"https://reubensun.com/categories/dcc/"},{"name":"game","slug":"game","permalink":"https://reubensun.com/categories/game/"},{"name":"math","slug":"math","permalink":"https://reubensun.com/categories/math/"},{"name":"optics","slug":"optics","permalink":"https://reubensun.com/categories/optics/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://reubensun.com/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://reubensun.com/tags/Linux/"},{"name":"AI","slug":"AI","permalink":"https://reubensun.com/tags/AI/"},{"name":"Diffusion","slug":"Diffusion","permalink":"https://reubensun.com/tags/Diffusion/"},{"name":"Unity","slug":"Unity","permalink":"https://reubensun.com/tags/Unity/"},{"name":"Editor","slug":"Editor","permalink":"https://reubensun.com/tags/Editor/"},{"name":"Unreal","slug":"Unreal","permalink":"https://reubensun.com/tags/Unreal/"},{"name":"LLM","slug":"LLM","permalink":"https://reubensun.com/tags/LLM/"},{"name":"Llama","slug":"Llama","permalink":"https://reubensun.com/tags/Llama/"},{"name":"Qwen","slug":"Qwen","permalink":"https://reubensun.com/tags/Qwen/"},{"name":"Animation","slug":"Animation","permalink":"https://reubensun.com/tags/Animation/"},{"name":"URP","slug":"URP","permalink":"https://reubensun.com/tags/URP/"},{"name":"RL","slug":"RL","permalink":"https://reubensun.com/tags/RL/"},{"name":"CXX","slug":"CXX","permalink":"https://reubensun.com/tags/CXX/"},{"name":"OpenAI","slug":"OpenAI","permalink":"https://reubensun.com/tags/OpenAI/"},{"name":"Csharp","slug":"Csharp","permalink":"https://reubensun.com/tags/Csharp/"},{"name":"Web","slug":"Web","permalink":"https://reubensun.com/tags/Web/"},{"name":"PS","slug":"PS","permalink":"https://reubensun.com/tags/PS/"},{"name":"CSharp","slug":"CSharp","permalink":"https://reubensun.com/tags/CSharp/"},{"name":"OBJ","slug":"OBJ","permalink":"https://reubensun.com/tags/OBJ/"},{"name":"Shader","slug":"Shader","permalink":"https://reubensun.com/tags/Shader/"},{"name":"Model","slug":"Model","permalink":"https://reubensun.com/tags/Model/"},{"name":"高等数学","slug":"高等数学","permalink":"https://reubensun.com/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"Pytorch","slug":"Pytorch","permalink":"https://reubensun.com/tags/Pytorch/"},{"name":"UV","slug":"UV","permalink":"https://reubensun.com/tags/UV/"},{"name":"Perforce","slug":"Perforce","permalink":"https://reubensun.com/tags/Perforce/"},{"name":"Metal","slug":"Metal","permalink":"https://reubensun.com/tags/Metal/"},{"name":"Physics","slug":"Physics","permalink":"https://reubensun.com/tags/Physics/"},{"name":"Jolt Physics","slug":"Jolt-Physics","permalink":"https://reubensun.com/tags/Jolt-Physics/"},{"name":"Hair","slug":"Hair","permalink":"https://reubensun.com/tags/Hair/"},{"name":"Rust","slug":"Rust","permalink":"https://reubensun.com/tags/Rust/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"https://reubensun.com/tags/WebAssembly/"},{"name":"Vulkan","slug":"Vulkan","permalink":"https://reubensun.com/tags/Vulkan/"},{"name":"CMake","slug":"CMake","permalink":"https://reubensun.com/tags/CMake/"},{"name":"Texture","slug":"Texture","permalink":"https://reubensun.com/tags/Texture/"},{"name":"Culling","slug":"Culling","permalink":"https://reubensun.com/tags/Culling/"},{"name":"Effect","slug":"Effect","permalink":"https://reubensun.com/tags/Effect/"},{"name":"Render","slug":"Render","permalink":"https://reubensun.com/tags/Render/"},{"name":"glTF","slug":"glTF","permalink":"https://reubensun.com/tags/glTF/"},{"name":"Git","slug":"Git","permalink":"https://reubensun.com/tags/Git/"},{"name":"ECS","slug":"ECS","permalink":"https://reubensun.com/tags/ECS/"},{"name":"Blender","slug":"Blender","permalink":"https://reubensun.com/tags/Blender/"},{"name":"3dmax","slug":"3dmax","permalink":"https://reubensun.com/tags/3dmax/"},{"name":"SWIG","slug":"SWIG","permalink":"https://reubensun.com/tags/SWIG/"},{"name":"FBX","slug":"FBX","permalink":"https://reubensun.com/tags/FBX/"},{"name":"PBR","slug":"PBR","permalink":"https://reubensun.com/tags/PBR/"},{"name":"SIGGRAPH","slug":"SIGGRAPH","permalink":"https://reubensun.com/tags/SIGGRAPH/"},{"name":"leetcode","slug":"leetcode","permalink":"https://reubensun.com/tags/leetcode/"},{"name":"光学","slug":"光学","permalink":"https://reubensun.com/tags/%E5%85%89%E5%AD%A6/"},{"name":"PM","slug":"PM","permalink":"https://reubensun.com/tags/PM/"},{"name":"GI","slug":"GI","permalink":"https://reubensun.com/tags/GI/"},{"name":"SPH","slug":"SPH","permalink":"https://reubensun.com/tags/SPH/"},{"name":"TA","slug":"TA","permalink":"https://reubensun.com/tags/TA/"},{"name":"Windows","slug":"Windows","permalink":"https://reubensun.com/tags/Windows/"},{"name":"并行计算","slug":"并行计算","permalink":"https://reubensun.com/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"name":"GC","slug":"GC","permalink":"https://reubensun.com/tags/GC/"},{"name":"DX12","slug":"DX12","permalink":"https://reubensun.com/tags/DX12/"},{"name":"shader","slug":"shader","permalink":"https://reubensun.com/tags/shader/"}]}